{"pr_number": 2012, "pr_title": "Immutables support in DynamoDb Enhanced Client", "pr_createdAt": "2020-08-30T20:54:27Z", "pr_url": "https://github.com/aws/aws-sdk-java-v2/pull/2012", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzNTM5Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480335396", "bodyText": "I see I missed some javadocs for these new interface methods. Will add those shortly.", "author": "bmaizels", "createdAt": "2020-08-31T19:13:33Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java", "diffHunk": "@@ -72,9 +73,18 @@\n      * attribute when using the versioned record extension.\n      *\n      * @return A collection of all key attribute names for the table.\n+     *\n+     * @deprecated Use {@link #keyAttributes()} instead.\n      */\n+    @Deprecated\n     Collection<String> allKeys();\n \n+    Collection<Index> indices();", "originalCommit": "09d6fa660d2853d4239a5add3e0fce75328085d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzNTkzMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480335930", "bodyText": "I see a typo in 'delcared'. Will fix.", "author": "bmaizels", "createdAt": "2020-08-31T19:14:06Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java", "diffHunk": "@@ -43,6 +47,21 @@\n         return StaticTableSchema.builder(itemClass);\n     }\n \n+    /**\n+     * Returns a builder for the {@link StaticImmutableTableSchema} implementation of this interface which allows all\n+     * attributes, tags and table structure to be directly delcared in the builder.", "originalCommit": "09d6fa660d2853d4239a5add3e0fce75328085d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzODY2OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480338668", "bodyText": "I am thinking I should add 'implements TableSchema' here because WrappedTableSchema is an internal class and I want the TableSchema interface to be part of the public contract of this class.", "author": "bmaizels", "createdAt": "2020-08-31T19:16:58Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/BeanTableSchema.java", "diffHunk": "@@ -41,72 +40,61 @@\n import software.amazon.awssdk.enhanced.dynamodb.AttributeConverterProvider;\n import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;\n import software.amazon.awssdk.enhanced.dynamodb.EnhancedType;\n-import software.amazon.awssdk.enhanced.dynamodb.TableMetadata;\n import software.amazon.awssdk.enhanced.dynamodb.TableSchema;\n import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeGetter;\n import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeSetter;\n-import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanConstructor;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.ObjectConstructor;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.WrappedTableSchema;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.BeanTableSchemaAttributeTag;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbAttribute;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbConvertedBy;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbFlatten;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbIgnore;\n-import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmutable;\n \n /**\n  * Implementation of {@link TableSchema} that builds a table schema based on properties and annotations of a bean\n  * class. Example:\n  * <pre>\n  * <code>\n  * {@literal @}DynamoDbBean\n- * public class CustomerAccount {\n- *     private String unencryptedBillingKey;\n+ * public class Customer {\n+ *     private String accountId;\n+ *     private int subId;            // primitive types are supported\n+ *     private String name;\n+ *     private Instant createdDate;\n  *\n  *     {@literal @}DynamoDbPartitionKey\n- *     {@literal @}DynamoDbSecondarySortKey(indexName = \"accounts_by_customer\")\n- *     public String accountId;\n+ *     public String getAccountId() { return this.accountId; }\n+ *     public void setAccountId(String accountId) { this.accountId = accountId; }\n  *\n  *     {@literal @}DynamoDbSortKey\n- *     {@literal @}DynamoDbSecondaryPartitionKey(indexName = \"accounts_by_customer\")\n- *     public String customerId;\n- *\n- *     {@literal @}DynamoDbAttribute(\"account_status\")\n- *     public CustomerAccountStatus status;\n- *\n- *     {@literal @}DynamoDbFlatten(dynamoDbBeanClass = Customer.class)\n- *     public Customer customer;\n- *\n- *     public Instant createdOn;\n+ *     public int getSubId() { return this.subId; }\n+ *     public void setSubId(int subId) { this.subId = subId; }\n  *\n- *     // All public fields must be opted out to not participate in mapping\n- *     {@literal @}DynamoDbIgnore\n- *     public String internalKey;\n+ *     // Defines a GSI (customers_by_name) with a partition key of 'name'\n+ *     {@literal @}DynamoDbSecondaryPartitionKey(indexNames = \"customers_by_name\")\n+ *     public String getName() { return this.name; }\n+ *     public void setName(String name) { this.name = name; }\n  *\n- *     public enum CustomerAccountStatus {\n- *         ACTIVE,\n- *         CLOSED\n- *     }\n+ *     // Defines an LSI (customers_by_date) with a sort key of 'createdDate' and also declares the\n+ *     // same attribute as a sort key for the GSI named 'customers_by_name'\n+ *     {@literal @}DynamoDbSecondarySortKey(indexNames = {\"customers_by_date\", \"customers_by_name\"})\n+ *     public Instant getCreatedDate() { return this.createdDate; }\n+ *     public void setCreatedDate(Instant createdDate) { this.createdDate = createdDate; }\n  * }\n- * </code>\n- * {@literal @}DynamoDbBean\n- * public class Customer {\n- *     public String name;\n  *\n- *     {@literal public List<String> address;}\n- * }\n- * }\n  * </pre>\n+ *\n  * @param <T> The type of object that this {@link TableSchema} maps to.\n  */\n @SdkPublicApi\n-public final class BeanTableSchema<T> implements TableSchema<T> {\n+public final class BeanTableSchema<T> extends WrappedTableSchema<T, StaticTableSchema<T>> {", "originalCommit": "09d6fa660d2853d4239a5add3e0fce75328085d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzOTM2OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480339368", "bodyText": "I am thinking I should add 'implements TableSchema' here because WrappedTableSchema is an internal class and I want the TableSchema interface to be part of the public contract of this class.", "author": "bmaizels", "createdAt": "2020-08-31T19:17:42Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/ImmutableTableSchema.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.enhanced.dynamodb.mapper;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter;\n+import software.amazon.awssdk.enhanced.dynamodb.AttributeConverterProvider;\n+import software.amazon.awssdk.enhanced.dynamodb.EnhancedType;\n+import software.amazon.awssdk.enhanced.dynamodb.TableSchema;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.immutable.ImmutableInfo;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.immutable.ImmutableIntrospector;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.immutable.ImmutablePropertyDescriptor;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeGetter;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeSetter;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.ObjectConstructor;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.ObjectGetterMethod;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.StaticGetterMethod;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.WrappedTableSchema;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.BeanTableSchemaAttributeTag;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbAttribute;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbConvertedBy;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbFlatten;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmutable;\n+\n+/**\n+ * Implementation of {@link TableSchema} that builds a table schema based on properties and annotations of an immutable\n+ * class with an associated builder class. Example:\n+ * <pre>\n+ * <code>\n+ * {@literal @}DynamoDbImmutable(builder = Customer.Builder.class)\n+ * public class Customer {\n+ *     {@literal @}DynamoDbPartitionKey\n+ *     public String accountId() { ... }\n+ *\n+ *     {@literal @}DynamoDbSortKey\n+ *     public int subId() { ... }\n+ *\n+ *     // Defines a GSI (customers_by_name) with a partition key of 'name'\n+ *     {@literal @}DynamoDbSecondaryPartitionKey(indexNames = \"customers_by_name\")\n+ *     public String name() { ... }\n+ *\n+ *     // Defines an LSI (customers_by_date) with a sort key of 'createdDate' and also declares the\n+ *     // same attribute as a sort key for the GSI named 'customers_by_name'\n+ *     {@literal @}DynamoDbSecondarySortKey(indexNames = {\"customers_by_date\", \"customers_by_name\"})\n+ *     public Instant createdDate() { ... }\n+ *\n+ *     // Not required to be an inner-class, but builders often are\n+ *     public static final class Builder {\n+ *         public Builder accountId(String accountId) { ... };\n+ *         public Builder subId(int subId) { ... };\n+ *         public Builder name(String name) { ... };\n+ *         public Builder createdDate(Instant createdDate) { ... };\n+ *\n+ *         public Customer build() { ... };\n+ *     }\n+ * }\n+ *\n+ * </pre>\n+ * @param <T> The type of object that this {@link TableSchema} maps to.\n+ */\n+@SdkPublicApi\n+public final class ImmutableTableSchema<T> extends WrappedTableSchema<T, StaticImmutableTableSchema<T, ?>> {", "originalCommit": "09d6fa660d2853d4239a5add3e0fce75328085d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "efffc864d0cddee3fc785c48804ac617c1aa25fd", "url": "https://github.com/aws/aws-sdk-java-v2/commit/efffc864d0cddee3fc785c48804ac617c1aa25fd", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-08-31T22:48:20Z", "type": "forcePushed"}, {"oid": "1d08b9f31ecae9a8d757d50e51bc5a1f8cd91227", "url": "https://github.com/aws/aws-sdk-java-v2/commit/1d08b9f31ecae9a8d757d50e51bc5a1f8cd91227", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-09-01T01:18:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3ODUxOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480478518", "bodyText": "What does 'if a class is used as a document within .. ' mean?", "author": "cenedhryn", "createdAt": "2020-08-31T23:52:11Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/annotations/DynamoDbImmutable.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.enhanced.dynamodb.mapper.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter;\n+import software.amazon.awssdk.enhanced.dynamodb.AttributeConverterProvider;\n+import software.amazon.awssdk.enhanced.dynamodb.DefaultAttributeConverterProvider;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.ImmutableTableSchema;\n+\n+/**\n+ * Class level annotation that identifies this class as being a DynamoDb mappable entity. Any class used to initialize\n+ * a {@link ImmutableTableSchema} must have this annotation. If a class is used as a document within another annotated", "originalCommit": "0e74c847f8447ea426c5146374feaf57e08f7a7f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDUxOTkxOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480519918", "bodyText": "Why is this commented out?", "author": "cenedhryn", "createdAt": "2020-09-01T00:58:04Z", "path": "services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/mapper/StaticAttributeTest.java", "diffHunk": "@@ -204,26 +204,25 @@ public void build_addAttributeConverter() {\n         assertThat(attributeConverterR).isEqualTo(attributeConverter);\n     }\n \n-    @Test\n-    public void resolve_uses_customConverter() {\n-        when(attributeConverter.transformFrom(any())).thenReturn(AttributeValue.builder().s(\"test-string-custom\").build());\n-\n-        StaticAttribute<SimpleItem, String> staticAttribute = StaticAttribute.builder(SimpleItem.class, String.class)\n-                                                                         .name(\"test-attribute\")\n-                                                                         .getter(SimpleItem::getAString)\n-                                                                         .setter(SimpleItem::setAString)\n-                                                                         .attributeConverter(attributeConverter)\n-                                                                         .build();\n-\n-        ResolvedStaticAttribute<SimpleItem> resolvedAttribute =\n-            staticAttribute.resolve(AttributeConverterProvider.defaultProvider());\n-\n-        Function<SimpleItem, AttributeValue> attributeValueFunction = resolvedAttribute.attributeGetterMethod();\n-\n-        SimpleItem item = new SimpleItem(\"test-string\");\n-        AttributeValue resultAttributeValue = attributeValueFunction.apply(item);\n-\n-        assertThat(resultAttributeValue.s()).isEqualTo(\"test-string-custom\");\n-    }\n-\n+//    @Test", "originalCommit": "0e74c847f8447ea426c5146374feaf57e08f7a7f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI3NjQwNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481276405", "bodyText": "Nit: 'known indices'", "author": "cenedhryn", "createdAt": "2020-09-01T16:26:08Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java", "diffHunk": "@@ -72,9 +73,36 @@\n      * attribute when using the versioned record extension.\n      *\n      * @return A collection of all key attribute names for the table.\n+     *\n+     * @deprecated Use {@link #keyAttributes()} instead.\n      */\n+    @Deprecated\n     Collection<String> allKeys();\n \n+    /**\n+     * Returns all the indices known for this table.", "originalCommit": "a41407c5c9d5dad51484306b3eec42425a4e80e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI4NDM3OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481284378", "bodyText": "It may be confusing to users that there is an Index interface that they can't use as an index but instead contains metadata.\nIndex is a nested interface but StaticIndex is a top level class\n\nHave you considered alternative code organization such as top level interface IndexMetadata, for consistency? Naming with metadata would also alleviate mixups with customers trying to use Index and Key for actual queries, which would seem logical to me if I was a user.", "author": "cenedhryn", "createdAt": "2020-09-01T16:39:49Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java", "diffHunk": "@@ -124,4 +152,39 @@ static String primaryIndexName() {\n         // actions of a client, so it should not be altered unless absolutely necessary.\n         return \"$PRIMARY_INDEX\";\n     }\n+\n+    /**\n+     * A metadata class that stores information about an index\n+     */\n+    interface Index {", "originalCommit": "a41407c5c9d5dad51484306b3eec42425a4e80e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9ce7a3f59bb19b87c20381efb9da33f05522798c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9ce7a3f59bb19b87c20381efb9da33f05522798c", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-09-01T18:58:45Z", "type": "forcePushed"}, {"oid": "6f1405f00d6bb4880739a17e544db8d881d6d24a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6f1405f00d6bb4880739a17e544db8d881d6d24a", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-09-01T19:11:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3MjI2Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481372267", "bodyText": "nit, <p> \ud83d\ude1b", "author": "zoewangg", "createdAt": "2020-09-01T19:11:33Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java", "diffHunk": "@@ -72,9 +73,36 @@\n      * attribute when using the versioned record extension.\n      *\n      * @return A collection of all key attribute names for the table.\n+     *\n+     * @deprecated Use {@link #keyAttributes()} instead.\n      */\n+    @Deprecated\n     Collection<String> allKeys();\n \n+    /**\n+     * Returns metadata about all the known indices for this table.\n+     * @return A collection of {@link IndexMetadata} containing information about the indices.\n+     */\n+    Collection<IndexMetadata> indices();\n+\n+    /**\n+     * Returns all custom metadata for this table. These entries are used by extensions to the library, therefore the\n+     * value type of each metadata object stored in the map is not known and is provided as {@link Object}.\n+     *", "originalCommit": "9ce7a3f59bb19b87c20381efb9da33f05522798c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjc0Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481402746", "bodyText": "Will fix.", "author": "bmaizels", "createdAt": "2020-09-01T20:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3MjI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NDAzMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481374030", "bodyText": "Can we add more javadocs to explain the definition of abstract here since abstract is an overloaded term?", "author": "zoewangg", "createdAt": "2020-09-01T19:14:57Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java", "diffHunk": "@@ -115,4 +172,17 @@\n      * @return The {@link EnhancedType} of the modelled item this TableSchema maps to.\n      */\n     EnhancedType<T> itemType();\n+\n+    /**\n+     * Returns a complete list of attribute names that are mapped by this {@link TableSchema}\n+     */\n+    List<String> attributeNames();\n+\n+    /**\n+     * A boolean value that represents whether this {@link TableSchema} is abstract.\n+     *\n+     * @return true if it is abstract, and therefore cannot be used directly to create records but can be referred to\n+     * by other schemata, and false if it is concrete and may be used to map records directly.\n+     */\n+    boolean isAbstract();", "originalCommit": "6f1405f00d6bb4880739a17e544db8d881d6d24a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjgyMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481402820", "bodyText": "Okay. +1", "author": "bmaizels", "createdAt": "2020-09-01T20:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NDAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTQ1Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481375452", "bodyText": "Can we break up the if statement a bit, like creating variables with meaningful names? seems a bit hard to read with so many predicates.", "author": "zoewangg", "createdAt": "2020-09-01T19:17:47Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.enhanced.dynamodb.internal.immutable;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbIgnore;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmutable;\n+\n+@SdkInternalApi\n+public class ImmutableIntrospector {\n+    private static final ImmutableIntrospector INSTANCE = new ImmutableIntrospector();\n+    private static final String BUILD_METHOD = \"build\";\n+    private static final String BUILDER_METHOD = \"builder\";\n+    private static final String GET_PREFIX = \"get\";\n+    private static final String IS_PREFIX = \"is\";\n+    private static final String SET_PREFIX = \"set\";\n+\n+    // Methods from Object are commonly overridden and confuse the mapper, automatically exclude any method with a name\n+    // that matches a method defined on Object.\n+    private static final Set<String> NAMES_TO_EXCLUDE =\n+        Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n+                                          .map(Method::getName)\n+                                          .collect(Collectors.toSet()));\n+\n+    public static <T> ImmutableInfo<T> getImmutableInfo(Class<T> immutableClass) {\n+        return INSTANCE.introspect(immutableClass);\n+    }\n+\n+    private static boolean isMappableMethod(Method method) {\n+        return method.getDeclaringClass() != Object.class\n+            && method.getAnnotation(DynamoDbIgnore.class) == null\n+            && !method.isSynthetic()\n+            && !method.isBridge()\n+            && !Modifier.isStatic(method.getModifiers())\n+            && !NAMES_TO_EXCLUDE.contains(method.getName());\n+    }\n+\n+    private <T> ImmutableInfo<T> introspect(Class<T> immutableClass) {\n+        Class<?> builderClass = validateAndGetBuilderClass(immutableClass);\n+        Optional<Method> staticBuilderMethod = findStaticBuilderMethod(immutableClass, builderClass);\n+        List<Method> getters = filterAndCollectGetterMethods(immutableClass.getMethods());\n+        Map<String, Method> indexedBuilderMethods = filterAndIndexBuilderMethods(builderClass.getMethods());\n+        Method buildMethod = extractBuildMethod(indexedBuilderMethods, immutableClass)\n+            .orElseThrow(\n+                () -> new IllegalArgumentException(\n+                    \"An immutable builder class must have a public method named 'build()' that takes no arguments \" +\n+                        \"and returns an instance of the immutable class it builds\"));\n+\n+        List<ImmutablePropertyDescriptor> propertyDescriptors =\n+            getters.stream()\n+                   .map(getter -> {\n+                       validateGetter(getter);\n+                       String propertyName = normalizeGetterName(getter);\n+\n+                       Method setter = extractSetterMethod(propertyName, indexedBuilderMethods, getter, builderClass)\n+                           .orElseThrow(\n+                               () -> generateExceptionForMethod(\n+                                   getter,\n+                                   \"A method was found on the immutable class that does not appear to have a \" +\n+                                       \"matching setter on the builder class.\"));\n+\n+                       return ImmutablePropertyDescriptor.create(propertyName, getter, setter);\n+                   }).collect(Collectors.toList());\n+\n+        if (!indexedBuilderMethods.isEmpty()) {\n+            throw generateExceptionForMethod(indexedBuilderMethods.values().iterator().next(),\n+                                             \"A method was found on the immutable class builder that does not appear \" +\n+                                                 \"to have a matching getter on the immutable class.\");\n+        }\n+\n+        return ImmutableInfo.builder(immutableClass)\n+                            .builderClass(builderClass)\n+                            .staticBuilderMethod(staticBuilderMethod.orElse(null))\n+                            .buildMethod(buildMethod)\n+                            .propertyDescriptors(propertyDescriptors)\n+                            .build();\n+    }\n+\n+    private Optional<Method> findStaticBuilderMethod(Class<?> immutableClass, Class<?> builderClass) {\n+        try {\n+            Method method = immutableClass.getMethod(BUILDER_METHOD);\n+\n+            if (Modifier.isStatic(method.getModifiers()) && method.getReturnType().isAssignableFrom(builderClass)) {\n+                return Optional.of(method);\n+            }\n+        } catch (NoSuchMethodException ignored) {\n+            // no-op\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private IllegalArgumentException generateExceptionForMethod(Method getter, String message) {\n+        return new IllegalArgumentException(\n+            message + \" Use the @DynamoDbIgnore annotation on the method if you do not want it to be included in the \" +\n+                \"TableSchema introspection. [Method = \\\"\" + getter + \"\\\"]\");\n+    }\n+\n+    private Class<?> validateAndGetBuilderClass(Class<?> immutableClass) {\n+        DynamoDbImmutable dynamoDbImmutable = immutableClass.getAnnotation(DynamoDbImmutable.class);\n+\n+        if (dynamoDbImmutable == null) {\n+            throw new IllegalArgumentException(\"A DynamoDb immutable class must be annotated with @DynamoDbImmutable\");\n+        }\n+\n+        return dynamoDbImmutable.builder();\n+    }\n+\n+    private void validateGetter(Method getter) {\n+        if (getter.getReturnType() == void.class || getter.getReturnType() == Void.class) {\n+            throw generateExceptionForMethod(getter, \"A method was found on the immutable class that does not appear \" +\n+                \"to be a valid getter due to the return type being void.\");\n+        }\n+\n+        if (getter.getParameterCount() != 0) {\n+            throw generateExceptionForMethod(getter, \"A method was found on the immutable class that does not appear \" +\n+                \"to be a valid getter due to it having one or more parameters.\");\n+        }\n+    }\n+\n+    private List<Method> filterAndCollectGetterMethods(Method[] rawMethods) {\n+        return Arrays.stream(rawMethods)\n+                     .filter(ImmutableIntrospector::isMappableMethod)\n+                     .collect(Collectors.toList());\n+    }\n+\n+    private Map<String, Method> filterAndIndexBuilderMethods(Method[] rawMethods) {\n+        return Arrays.stream(rawMethods)\n+                     .filter(ImmutableIntrospector::isMappableMethod)\n+                     .collect(Collectors.toMap(this::normalizeSetterName, m -> m));\n+    }\n+\n+    private String normalizeSetterName(Method setter) {\n+        String setterName = setter.getName();\n+\n+        if (setterName.length() > 3\n+            && Character.isUpperCase(setterName.charAt(3))\n+            && setterName.startsWith(SET_PREFIX)) {\n+\n+            return Character.toLowerCase(setterName.charAt(3)) + setterName.substring(4);\n+        }\n+\n+        return setterName;\n+    }\n+\n+    private String normalizeGetterName(Method getter) {\n+        String getterName = getter.getName();\n+\n+        if (getterName.length() > 2\n+            && Character.isUpperCase(getterName.charAt(2))\n+            && getterName.startsWith(IS_PREFIX)\n+            && isMethodBoolean(getter)) {\n+\n+            return Character.toLowerCase(getterName.charAt(2)) + getterName.substring(3);\n+        }\n+\n+        if (getterName.length() > 3\n+            && Character.isUpperCase(getterName.charAt(3))\n+            && getterName.startsWith(GET_PREFIX)) {\n+\n+            return Character.toLowerCase(getterName.charAt(3)) + getterName.substring(4);\n+        }\n+\n+        return getterName;\n+    }\n+\n+    private boolean isMethodBoolean(Method method) {\n+        return method.getReturnType() == boolean.class || method.getReturnType() == Boolean.class;\n+    }\n+\n+    private Optional<Method> extractBuildMethod(Map<String, Method> indexedBuilderMethods, Class<?> immutableClass) {\n+        Method buildMethod = indexedBuilderMethods.get(BUILD_METHOD);\n+\n+        if (buildMethod == null\n+            || buildMethod.getParameterCount() != 0\n+            || !immutableClass.equals(buildMethod.getReturnType())) {\n+\n+            return Optional.empty();\n+        }\n+\n+        indexedBuilderMethods.remove(BUILD_METHOD);\n+        return Optional.of(buildMethod);\n+    }\n+\n+    private Optional<Method> extractSetterMethod(String propertyName,\n+                                                 Map<String, Method> indexedBuilderMethods,\n+                                                 Method getterMethod,\n+                                                 Class<?> builderClass) {\n+        Method setterMethod = indexedBuilderMethods.get(propertyName);\n+\n+        if (setterMethod == null", "originalCommit": "6f1405f00d6bb4880739a17e544db8d881d6d24a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjkwNw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481402907", "bodyText": "Okay. +1", "author": "bmaizels", "createdAt": "2020-09-01T20:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyOTIxMQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481329211", "bodyText": "Can we do this in a constructor and make the singleton lazily-initialized so that we only do this if getImmutableInfo is invoked? That also has the slight advantage of using the classloader that invokes getImmutableInfo (the first time), not the one that statically initializes the class... not that I expect the methods on Object to change much between classloaders.", "author": "millems", "createdAt": "2020-09-01T17:56:52Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.enhanced.dynamodb.internal.immutable;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbIgnore;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmutable;\n+\n+@SdkInternalApi\n+public class ImmutableIntrospector {\n+    private static final ImmutableIntrospector INSTANCE = new ImmutableIntrospector();\n+    private static final String BUILD_METHOD = \"build\";\n+    private static final String BUILDER_METHOD = \"builder\";\n+    private static final String GET_PREFIX = \"get\";\n+    private static final String IS_PREFIX = \"is\";\n+    private static final String SET_PREFIX = \"set\";\n+\n+    // Methods from Object are commonly overridden and confuse the mapper, automatically exclude any method with a name\n+    // that matches a method defined on Object.\n+    private static final Set<String> NAMES_TO_EXCLUDE =\n+        Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n+                                          .map(Method::getName)\n+                                          .collect(Collectors.toSet()));", "originalCommit": "a41407c5c9d5dad51484306b3eec42425a4e80e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzgyNA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481403824", "bodyText": "I was trying not to synchronize as the static class loader path is guaranteed to be thread synchronized. Do you think it would be preferable to do a synchronized double-null-check type lazy initialization here?", "author": "bmaizels", "createdAt": "2020-09-01T20:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyOTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTE5Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481405197", "bodyText": "Since it's not a big deal if we double-initialize, doing a synchronized double-null-check lazy initialization wouldn't even need to be on a volatile variable. It would probably be the best of both worlds.", "author": "millems", "createdAt": "2020-09-01T20:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyOTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3MjMzMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481472333", "bodyText": "Okay, will do that and make it non-volatile.", "author": "bmaizels", "createdAt": "2020-09-01T22:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyOTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4ODkwOQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481488909", "bodyText": "As discussed offline and due to spotbug's protests we'll make this volatile after all.", "author": "bmaizels", "createdAt": "2020-09-01T23:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyOTIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NDEwOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481394108", "bodyText": "Should we make \"is bean style\" an annotation setting, instead of trying to guess by looking at the method names? I'm worried about an attribute starting with \"Set\" being magically messed up because we're trying to be too clever.\nE.g. A customer probably wants a \"setOfStuff\" attribute to be stored as \"setOfStuff\", not \"ofStuff\".", "author": "millems", "createdAt": "2020-09-01T19:54:05Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.enhanced.dynamodb.internal.immutable;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbIgnore;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmutable;\n+\n+@SdkInternalApi\n+public class ImmutableIntrospector {\n+    private static final ImmutableIntrospector INSTANCE = new ImmutableIntrospector();\n+    private static final String BUILD_METHOD = \"build\";\n+    private static final String BUILDER_METHOD = \"builder\";\n+    private static final String GET_PREFIX = \"get\";\n+    private static final String IS_PREFIX = \"is\";\n+    private static final String SET_PREFIX = \"set\";\n+\n+    // Methods from Object are commonly overridden and confuse the mapper, automatically exclude any method with a name\n+    // that matches a method defined on Object.\n+    private static final Set<String> NAMES_TO_EXCLUDE =\n+        Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n+                                          .map(Method::getName)\n+                                          .collect(Collectors.toSet()));\n+\n+    public static <T> ImmutableInfo<T> getImmutableInfo(Class<T> immutableClass) {\n+        return INSTANCE.introspect(immutableClass);\n+    }\n+\n+    private static boolean isMappableMethod(Method method) {\n+        return method.getDeclaringClass() != Object.class\n+            && method.getAnnotation(DynamoDbIgnore.class) == null\n+            && !method.isSynthetic()\n+            && !method.isBridge()\n+            && !Modifier.isStatic(method.getModifiers())\n+            && !NAMES_TO_EXCLUDE.contains(method.getName());\n+    }\n+\n+    private <T> ImmutableInfo<T> introspect(Class<T> immutableClass) {\n+        Class<?> builderClass = validateAndGetBuilderClass(immutableClass);\n+        Optional<Method> staticBuilderMethod = findStaticBuilderMethod(immutableClass, builderClass);\n+        List<Method> getters = filterAndCollectGetterMethods(immutableClass.getMethods());\n+        Map<String, Method> indexedBuilderMethods = filterAndIndexBuilderMethods(builderClass.getMethods());\n+        Method buildMethod = extractBuildMethod(indexedBuilderMethods, immutableClass)\n+            .orElseThrow(\n+                () -> new IllegalArgumentException(\n+                    \"An immutable builder class must have a public method named 'build()' that takes no arguments \" +\n+                        \"and returns an instance of the immutable class it builds\"));\n+\n+        List<ImmutablePropertyDescriptor> propertyDescriptors =\n+            getters.stream()\n+                   .map(getter -> {\n+                       validateGetter(getter);\n+                       String propertyName = normalizeGetterName(getter);\n+\n+                       Method setter = extractSetterMethod(propertyName, indexedBuilderMethods, getter, builderClass)\n+                           .orElseThrow(\n+                               () -> generateExceptionForMethod(\n+                                   getter,\n+                                   \"A method was found on the immutable class that does not appear to have a \" +\n+                                       \"matching setter on the builder class.\"));\n+\n+                       return ImmutablePropertyDescriptor.create(propertyName, getter, setter);\n+                   }).collect(Collectors.toList());\n+\n+        if (!indexedBuilderMethods.isEmpty()) {\n+            throw generateExceptionForMethod(indexedBuilderMethods.values().iterator().next(),\n+                                             \"A method was found on the immutable class builder that does not appear \" +\n+                                                 \"to have a matching getter on the immutable class.\");\n+        }\n+\n+        return ImmutableInfo.builder(immutableClass)\n+                            .builderClass(builderClass)\n+                            .staticBuilderMethod(staticBuilderMethod.orElse(null))\n+                            .buildMethod(buildMethod)\n+                            .propertyDescriptors(propertyDescriptors)\n+                            .build();\n+    }\n+\n+    private Optional<Method> findStaticBuilderMethod(Class<?> immutableClass, Class<?> builderClass) {\n+        try {\n+            Method method = immutableClass.getMethod(BUILDER_METHOD);\n+\n+            if (Modifier.isStatic(method.getModifiers()) && method.getReturnType().isAssignableFrom(builderClass)) {\n+                return Optional.of(method);\n+            }\n+        } catch (NoSuchMethodException ignored) {\n+            // no-op\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private IllegalArgumentException generateExceptionForMethod(Method getter, String message) {\n+        return new IllegalArgumentException(\n+            message + \" Use the @DynamoDbIgnore annotation on the method if you do not want it to be included in the \" +\n+                \"TableSchema introspection. [Method = \\\"\" + getter + \"\\\"]\");\n+    }\n+\n+    private Class<?> validateAndGetBuilderClass(Class<?> immutableClass) {\n+        DynamoDbImmutable dynamoDbImmutable = immutableClass.getAnnotation(DynamoDbImmutable.class);\n+\n+        if (dynamoDbImmutable == null) {\n+            throw new IllegalArgumentException(\"A DynamoDb immutable class must be annotated with @DynamoDbImmutable\");\n+        }\n+\n+        return dynamoDbImmutable.builder();\n+    }\n+\n+    private void validateGetter(Method getter) {\n+        if (getter.getReturnType() == void.class || getter.getReturnType() == Void.class) {\n+            throw generateExceptionForMethod(getter, \"A method was found on the immutable class that does not appear \" +\n+                \"to be a valid getter due to the return type being void.\");\n+        }\n+\n+        if (getter.getParameterCount() != 0) {\n+            throw generateExceptionForMethod(getter, \"A method was found on the immutable class that does not appear \" +\n+                \"to be a valid getter due to it having one or more parameters.\");\n+        }\n+    }\n+\n+    private List<Method> filterAndCollectGetterMethods(Method[] rawMethods) {\n+        return Arrays.stream(rawMethods)\n+                     .filter(ImmutableIntrospector::isMappableMethod)\n+                     .collect(Collectors.toList());\n+    }\n+\n+    private Map<String, Method> filterAndIndexBuilderMethods(Method[] rawMethods) {\n+        return Arrays.stream(rawMethods)\n+                     .filter(ImmutableIntrospector::isMappableMethod)\n+                     .collect(Collectors.toMap(this::normalizeSetterName, m -> m));\n+    }\n+\n+    private String normalizeSetterName(Method setter) {\n+        String setterName = setter.getName();\n+\n+        if (setterName.length() > 3\n+            && Character.isUpperCase(setterName.charAt(3))\n+            && setterName.startsWith(SET_PREFIX)) {\n+\n+            return Character.toLowerCase(setterName.charAt(3)) + setterName.substring(4);\n+        }\n+\n+        return setterName;\n+    }", "originalCommit": "6f1405f00d6bb4880739a17e544db8d881d6d24a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NzQ3OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481397479", "bodyText": "Some code generators will produce immutable implementations that have 'set'. I think it would be inconvenient to require an additional annotation for all of those. I feel it would be preferable to annotate the exceptions with @DynamoDbAttribute(\"setOfStuff\") (which is already supported)", "author": "bmaizels", "createdAt": "2020-09-01T20:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NDEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTkzNg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481405936", "bodyText": "I was thinking a boolean on the class-level annotation, instead of one on every attribute. That seems less troublesome and prevents magic confusion (I feel like this is the opposite argument we usually have - you're usually the anti-magic one!)", "author": "millems", "createdAt": "2020-09-01T20:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NDEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4ODgyNw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481488827", "bodyText": "As we discussed offline, we'll bias towards making it easy for customers using code generators such as Lombok and not require an additional opt-in flag for getter/setter prefixes.", "author": "bmaizels", "createdAt": "2020-09-01T23:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NDEwOA=="}], "type": "inlineReview"}, {"oid": "08945b911393841c37d72bfb38524fef1ba391b1", "url": "https://github.com/aws/aws-sdk-java-v2/commit/08945b911393841c37d72bfb38524fef1ba391b1", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-09-01T23:34:26Z", "type": "commit"}, {"oid": "08945b911393841c37d72bfb38524fef1ba391b1", "url": "https://github.com/aws/aws-sdk-java-v2/commit/08945b911393841c37d72bfb38524fef1ba391b1", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-09-01T23:34:26Z", "type": "forcePushed"}, {"oid": "0199b0a97b762957d22e6ed7257e9fe698409e33", "url": "https://github.com/aws/aws-sdk-java-v2/commit/0199b0a97b762957d22e6ed7257e9fe698409e33", "message": "Merge branch 'master' into bmaizels/ddbenhanced-immutables-poc", "committedDate": "2020-09-01T23:34:55Z", "type": "commit"}]}