{"pr_number": 1907, "pr_title": "Add CloudWatchMetricPublisher, a MetricPublisher implementation that uploads metric data to CloudWatch.", "pr_createdAt": "2020-06-18T00:06:39Z", "pr_url": "https://github.com/aws/aws-sdk-java-v2/pull/1907", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5ODQ1Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r442498452", "bodyText": "Do you think the word filter should be in this method name somewhere?", "author": "bmaizels", "createdAt": "2020-06-18T20:57:52Z", "path": "metric-publishers/cloudwatch-metric-publisher/src/main/java/software/amazon/awssdk/metrics/publishers/cloudwatch/CloudWatchMetricPublisher.java", "diffHunk": "@@ -0,0 +1,507 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.metrics.publishers.cloudwatch;\n+\n+import static software.amazon.awssdk.metrics.publishers.cloudwatch.internal.CloudWatchMetricLogger.METRIC_LOGGER;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import software.amazon.awssdk.annotations.Immutable;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.annotations.ThreadSafe;\n+import software.amazon.awssdk.core.metrics.CoreMetric;\n+import software.amazon.awssdk.metrics.MetricCategory;\n+import software.amazon.awssdk.metrics.MetricCollection;\n+import software.amazon.awssdk.metrics.MetricCollector;\n+import software.amazon.awssdk.metrics.MetricPublisher;\n+import software.amazon.awssdk.metrics.SdkMetric;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.MetricUploader;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.task.AggregateMetricsTask;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.task.UploadMetricsTasks;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.transform.MetricCollectionAggregator;\n+import software.amazon.awssdk.services.cloudwatch.CloudWatchAsyncClient;\n+import software.amazon.awssdk.services.cloudwatch.model.Dimension;\n+import software.amazon.awssdk.services.cloudwatch.model.MetricDatum;\n+import software.amazon.awssdk.services.cloudwatch.model.PutMetricDataRequest;\n+import software.amazon.awssdk.services.cloudwatch.model.StatisticSet;\n+import software.amazon.awssdk.utils.ThreadFactoryBuilder;\n+\n+/**\n+ * An implementation of {@link MetricPublisher} that aggregates and uploads metrics to Amazon CloudWatch on a periodic basis.\n+ *\n+ * <p>This simplifies the process of uploading custom metrics to CloudWatch, and can also be configured on the AWS\n+ * SDK clients directly to upload AWS SDK-specific metrics (e.g. request latencies, failure rates) to CloudWatch.\n+ *\n+ * <p><b>Overview</b>\n+ *\n+ * <p>This publisher aggregates metric data in memory, and periodically uploads it to CloudWatch in a background thread. This\n+ * minimizes the work necessary to upload metrics, allowing the caller to focus on collecting the data.\n+ *\n+ * <p>The default settings of the metrics publisher are meant to minimize memory usage and CloudWatch cost, while still\n+ * providing a useful amount of insight into the metric data. Care should be taken when overriding the default values on the\n+ * publisher, because they can result in an associated increased in memory usage and CloudWatch cost.\n+ *\n+ * <p>By default, all metrics are uploaded using summary statistics. This means that only count, maximum, minimum, sum and\n+ * average data is available in CloudWatch. Metric details (e.g. p90, p99) can be enabled on a per-metric basis using\n+ * {@link Builder#detailedMetrics(Collection)}.\n+ *\n+ * <p>See {@link Builder} for the configuration values that are available for the publisher, and how they can be used to\n+ * increase the functionality or decrease the cost the publisher.\n+ *\n+ * <p><b>Logging</b>\n+ *\n+ * The CloudWatchMetricPublisher logs all aggregation and upload-related logs to the\n+ * {@code software.amazon.awssdk.metrics.publishers.cloudwatch} namespace. To determine how many metrics are being uploaded\n+ * successfully without checking the CloudWatch console, you can check for a \"success\" message at the DEBUG level. At the TRACE\n+ * level, you can see exactly which metrics are being uploaded.\n+ *\n+ * <p><b>Configuring AWS SDK clients to upload client metrics</b>\n+ *\n+ * TODO\n+ *\n+ * <p><b>Uploading your own custom metrics</b>\n+ *\n+ * <i>Step 1: Define which metrics you wish to collect</i>\n+ *\n+ * <p>Metrics are described using the {@link SdkMetric#create(String, Class)} method. When you describe your metric, you specify\n+ * the name that will appear in CloudWatch and the Java data-type of the metric. The metric should be described once for your\n+ * entire application.\n+ *\n+ * <p>Supported types: (1) {@link Number} types (e.g. {@link Integer}, {@link Double}, etc.), (2) {@link Duration}.\n+ *\n+ * <pre>\n+ *     // In this and the following examples, we want to collect metrics about calls to a method we have defined: \"myMethod\"\n+ *     public static final class MyMethodMetrics {\n+ *         // The number of times \"myMethod\" has been called.\n+ *         private static final SdkMetric&lt;Integer&gt; MY_METHOD_CALL_COUNT =\n+ *                 SdkMetric.create(\"MyMethodCallCount\", Integer.class);\n+ *\n+ *         // The amount of time that \"myMethod\" took to execute.\n+ *         private static final SdkMetric&lt;Duration&gt; MY_METHOD_LATENCY =\n+ *                 SdkMetric.create(\"MyMethodLatency\", Duration.class);\n+ *     }\n+ * </pre>\n+ *\n+ * <p><i>Step 2: Create a {@code CloudWatchMetricPublisher}</i>\n+ *\n+ * <p>A {@code CloudWatchMetricPublisher} should be created once for your entire application, and be reused wherever it is\n+ * needed. {@code CloudWatchMetricPublisher}s are thread-safe, so there should be no need to create multiple instances. Most\n+ * people create and manage the publisher in their inversion-of-control (IoC) container (e.g. Spring/Dagger/Guice).\n+ *\n+ * <p>Note: When your application is finished with the {@code CloudWatchMetricPublisher}, make sure to {@link #close()} it. Your\n+ * inversion-of-control container may handle this for you on JVM shutdown.\n+ *\n+ * <p>See {@link CloudWatchMetricPublisher.Builder} for all available configuration options.\n+ *\n+ * <pre>\n+ *     // Create a CloudWatchMetricPublisher using a custom namespace.\n+ *     MetricPublisher metricPublisher = CloudWatchMetricPublisher.builder()\n+ *                                                                .namespace(\"MyApplication\")\n+ *                                                                .build();\n+ * </pre>\n+ *\n+ * <p><i>Step 3: Collect and Publish Metrics</i>\n+ *\n+ * <p>Create and use a {@link MetricCollector} to collect data about your configured metrics.\n+ *\n+ * <pre>\n+ *     // Call \"myMethod\" and collect metrics about the call.\n+ *     Instant methodCallStartTime = Instant.now();\n+ *     myMethod();\n+ *     Duration methodCallDuration = Duration.between(methodCallStartTime, Instant.now());\n+ *\n+ *     // Write the metrics to the CloudWatchMetricPublisher.\n+ *     MetricCollector metricCollector = MetricCollector.create(\"MyMethodCall\");\n+ *     metricCollector.reportMetric(MyCustomMetrics.MY_METHOD_CALL_COUNT, 1);\n+ *     metricCollector.reportMetric(MyCustomMetrics.MY_METHOD_LATENCY, methodCallDuration);\n+ *     MetricCollection metricCollection = metricCollector.collect();\n+ *\n+ *     metricPublisher.publish(metricCollection);\n+ * </pre>\n+ *\n+ * <p><b>Warning:</b> Make sure the {@link #close()} this publisher when it is done being used to release all resources it\n+ * consumes. Failure to do so will result in possible thread or file descriptor leaks.\n+ */\n+@ThreadSafe\n+@Immutable\n+@SdkPublicApi\n+public final class CloudWatchMetricPublisher implements MetricPublisher {\n+    /**\n+     * The maximum queue size for the internal {@link #executor} that is used to aggregate metric data and upload it to\n+     * CloudWatch. If this value is too high, memory is wasted. If this value is too low, metrics could be dropped.\n+     *\n+     * This value is not currently configurable, because it's unlikely that this is a value that customers should need to modify.\n+     * If customers really need control over this value, we might consider letting them instead configure the\n+     * {@link BlockingQueue} used on the executor. The value here depends on the type of {@code BlockingQueue} in use, and\n+     * we should probably not indirectly couple people to the type of blocking queue we're using.\n+     */\n+    private static final int MAXIMUM_TASK_QUEUE_SIZE = 128;\n+\n+    private static final String DEFAULT_NAMESPACE = \"AwsSdk/JavaSdk2\";\n+    private static final int DEFAULT_MAXIMUM_CALLS_PER_UPLOAD = 10;\n+    private static final Duration DEFAULT_UPLOAD_FREQUENCY = Duration.ofMinutes(1);\n+    private static final Set<SdkMetric<String>> DEFAULT_DIMENSIONS = Stream.of(CoreMetric.SERVICE_ID,\n+                                                                               CoreMetric.OPERATION_NAME)\n+                                                                           .collect(Collectors.toSet());\n+    private static final Set<MetricCategory> DEFAULT_METRIC_CATEGORIES = Stream.of(MetricCategory.DEFAULT,\n+                                                                                   MetricCategory.HTTP_CLIENT)\n+                                                                               .collect(Collectors.toSet());\n+    private static final Set<SdkMetric<?>> DEFAULT_DETAILED_METRICS = Collections.emptySet();\n+\n+    /**\n+     * Whether {@link #close()} should call {@link CloudWatchAsyncClient#close()}. This is false when\n+     * {@link Builder#cloudWatchClient(CloudWatchAsyncClient)} was specified, meaning the customer has to close the client\n+     * themselves.\n+     */\n+    private final boolean closeClientWithPublisher;\n+\n+    /**\n+     * The aggregator that takes {@link MetricCollection}s and converts them into {@link PutMetricDataRequest}s. This aggregator\n+     * is *not* thread safe, so it should only ever be accessed from the {@link #executor}'s thread.\n+     */\n+    private final MetricCollectionAggregator metricAggregator;\n+\n+    /**\n+     * The uploader that takes {@link PutMetricDataRequest}s and sends them to a {@link CloudWatchAsyncClient}.\n+     */\n+    private final MetricUploader metricUploader;\n+\n+    /**\n+     * The executor that executes {@link AggregateMetricsTask}s and {@link UploadMetricsTasks}s.\n+     */\n+    private final ExecutorService executor;\n+\n+    /**\n+     * A scheduled executor that periodically schedules a {@link UploadMetricsTasks} on the {@link #executor} thread. Note: this\n+     * executor should never execute the flush task itself, because that needs access to the {@link #metricAggregator}, and the\n+     * {@code metricAggregator} should only ever be accessed from the {@link #executor} thread.\n+     */\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * The maximum number of {@link PutMetricDataRequest}s that should ever be executed as part of a single\n+     * {@link UploadMetricsTasks}.\n+     */\n+    private final int maximumCallsPerUpload;\n+\n+    private CloudWatchMetricPublisher(Builder builder) {\n+        this.closeClientWithPublisher = resolveCloseClientWithPublisher(builder);\n+        this.metricAggregator = new MetricCollectionAggregator(resolveNamespace(builder),\n+                                                               resolveDimensions(builder),\n+                                                               resolveMetricCategories(builder),\n+                                                               resolveDetailedMetrics(builder));\n+        this.metricUploader = new MetricUploader(resolveClient(builder));\n+        this.maximumCallsPerUpload = resolveMaximumCallsPerUpload(builder);\n+\n+        ThreadFactory threadFactory = new ThreadFactoryBuilder().threadNamePrefix(\"cloud-watch-metric-publisher\").build();\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor(threadFactory);\n+        this.executor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,\n+                                               new ArrayBlockingQueue<>(MAXIMUM_TASK_QUEUE_SIZE),\n+                                               threadFactory);\n+\n+        long flushFrequencyInMillis = resolveUploadFrequency(builder).toMillis();\n+        this.scheduledExecutor.scheduleAtFixedRate(this::flushMetrics,\n+                                                   flushFrequencyInMillis, flushFrequencyInMillis, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private Set<MetricCategory> resolveMetricCategories(Builder builder) {\n+        return builder.metricCategories == null ? DEFAULT_METRIC_CATEGORIES : new HashSet<>(builder.metricCategories);\n+    }\n+\n+    private Set<SdkMetric<?>> resolveDetailedMetrics(Builder builder) {\n+        return builder.detailedMetrics == null ? DEFAULT_DETAILED_METRICS : new HashSet<>(builder.detailedMetrics);\n+    }\n+\n+    private Set<SdkMetric<String>> resolveDimensions(Builder builder) {\n+        return builder.dimensions == null ? DEFAULT_DIMENSIONS : new HashSet<>(builder.dimensions);\n+    }\n+\n+    private boolean resolveCloseClientWithPublisher(Builder builder) {\n+        return builder.client == null;\n+    }\n+\n+    private CloudWatchAsyncClient resolveClient(Builder builder) {\n+        return builder.client == null ? CloudWatchAsyncClient.create() : builder.client;\n+    }\n+\n+    private Duration resolveUploadFrequency(Builder builder) {\n+        return builder.uploadFrequency == null ? DEFAULT_UPLOAD_FREQUENCY : builder.uploadFrequency;\n+    }\n+\n+    private String resolveNamespace(Builder builder) {\n+        return builder.namespace == null ? DEFAULT_NAMESPACE : builder.namespace;\n+    }\n+\n+    private int resolveMaximumCallsPerUpload(Builder builder) {\n+        return builder.maximumCallsPerUpload == null ? DEFAULT_MAXIMUM_CALLS_PER_UPLOAD : builder.maximumCallsPerUpload;\n+    }\n+\n+    @Override\n+    public void publish(MetricCollection metricCollection) {\n+        try {\n+            executor.submit(new AggregateMetricsTask(metricAggregator, metricCollection));\n+        } catch (RejectedExecutionException e) {\n+            METRIC_LOGGER.warn(() -> \"Some AWS SDK client-side metrics have been dropped because an internal executor did not \"\n+                                     + \"accept them. This usually occurs because your publisher has been shut down or you have \"\n+                                     + \"generated too many requests for the publisher to handle in a timely fashion.\", e);\n+        }\n+    }\n+\n+    private void flushMetrics() {\n+        while (true) {\n+            try {\n+                executor.submit(new UploadMetricsTasks(metricAggregator, metricUploader, maximumCallsPerUpload));\n+                break;\n+            } catch (RejectedExecutionException e) {\n+                Thread.yield();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        scheduledExecutor.shutdownNow();\n+\n+        flushMetrics();\n+        executor.shutdown();\n+        try {\n+            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n+                executor.shutdownNow();\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+\n+        metricUploader.close(closeClientWithPublisher);\n+    }\n+\n+    /**\n+     * Create a new {@link Builder} that can be used to create {@link CloudWatchMetricPublisher}s.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Create a {@link CloudWatchMetricPublisher} using all default values.\n+     */\n+    public static CloudWatchMetricPublisher create() {\n+        return builder().build();\n+    }\n+\n+    /**\n+     * Builder class to construct {@link CloudWatchMetricPublisher} instances. See the individual properties for which\n+     * configuration settings are available.\n+     */\n+    public static final class Builder {\n+        private CloudWatchAsyncClient client;\n+        private Duration uploadFrequency;\n+        private String namespace;\n+        private Integer maximumCallsPerUpload;\n+        private Collection<SdkMetric<String>> dimensions;\n+        private Collection<MetricCategory> metricCategories;\n+        private Collection<SdkMetric<?>> detailedMetrics;\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Configure the {@link PutMetricDataRequest#namespace()} used for all put-metric-data calls from this publisher.\n+         *\n+         * <p>If this is not specified, {@code AwsSdk/JavaSdk2} will be used.\n+         */\n+        public Builder namespace(String namespace) {\n+            this.namespace = namespace;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure the {@link CloudWatchAsyncClient} instance that should be used to communicate with CloudWatch.\n+         *\n+         * <p>If this is not specified, the {@code CloudWatchAsyncClient} will be created via\n+         * {@link CloudWatchAsyncClient#create()} (and will be closed when {@link #close()} is invoked).\n+         *\n+         * <p>If you specify a {@code CloudWatchAsyncClient} via this method, it <i>will not</i> be closed when this publisher\n+         * is closed. You will need to need to manage the lifecycle of the client yourself.\n+         */\n+        public Builder cloudWatchClient(CloudWatchAsyncClient client) {\n+            this.client = client;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure the frequency at which aggregated metrics are uploaded to CloudWatch and released from memory.\n+         *\n+         * <p>If this is not specified, metrics will be uploaded once per minute.\n+         *\n+         * <p>Smaller values will: (1) reduce the amount of memory used by the library (particularly when\n+         * {@link #detailedMetrics(Collection)} are enabled), (2) increase the number of CloudWatch calls (and therefore\n+         * increase CloudWatch usage cost).\n+         *\n+         * <p>Larger values will: (1) increase the amount of memory used by the library (particularly when\n+         * {@code detailedMetrics} are enabled), (2) increase the time it takes for metric data to appear in\n+         * CloudWatch, (3) reduce the number of CloudWatch calls (and therefore decrease CloudWatch usage cost).\n+         *\n+         * <p><b>Warning:</b> When {@code detailedMetrics} are enabled, all unique metric values are stored in memory until they\n+         * can be published to CloudWatch. A high {@code uploadFrequency} with multiple {@code detailedMetrics} enabled can\n+         * quickly consume heap memory while the values wait to be published to CloudWatch. In memory constrained environments, it\n+         * is recommended to minimize the number of {@code detailedMetrics} configured on the publisher, or to upload metric data\n+         * more frequently. As with all performance and resource concerns, profiling in a production-like environment is\n+         * encouraged.\n+         */\n+        public Builder uploadFrequency(Duration uploadFrequency) {\n+            this.uploadFrequency = uploadFrequency;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure the maximum number of {@link CloudWatchAsyncClient#putMetricData(PutMetricDataRequest)} calls that an\n+         * individual \"upload\" event can make to CloudWatch. Any metrics that would exceed this limit are dropped during the\n+         * upload, logging a warning on the {@code software.amazon.awssdk.metrics.publishers.cloudwatch} namespace.\n+         *\n+         * <p>The SDK will always attempt to maximize the number of metrics per put-metric-data call, but uploads will be split\n+         * into multiple put-metric-data calls if they include a lot of different metrics or if there are a lot of high-value-\n+         * distribution {@link #detailedMetrics(Collection)} being monitored.\n+         *\n+         * <p>This value combined with the {@link #uploadFrequency(Duration)} effectively provide a \"hard cap\" on the number of\n+         * put-metric-data calls, to prevent unbounded cost in the event that too many metrics are enabled by the user.\n+         *\n+         * <p>If this is not specified, put-metric-data calls will be capped at 10 per upload.\n+         */\n+        public Builder maximumCallsPerUpload(Integer maximumCallsPerUpload) {\n+            this.maximumCallsPerUpload = maximumCallsPerUpload;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure the {@link SdkMetric}s that are used to define the {@link Dimension}s metrics are aggregated under.\n+         *\n+         * <p>If this is not specified, {@link CoreMetric#SERVICE_ID} and {@link CoreMetric#OPERATION_NAME} are used, allowing\n+         * you to compare metrics for different services and operations.\n+         *\n+         * <p><b>Warning:</b> Configuring the dimensions incorrectly can result in a large increase in the number of unique\n+         * metrics and put-metric-data calls to cloudwatch, which have an associated monetary cost. Be sure you're choosing your\n+         * metric dimensions wisely, and that you always evaluate the cost of modifying these values on your monthly usage costs.\n+         *\n+         * <p><b>Example useful settings:</b>\n+         * <ul>\n+         * <li>{@code CoreMetric.SERVICE_ID} and {@code CoreMetric.OPERATION_NAME} (default): Separate metrics by service and\n+         * operation, so that you can compare latencies between AWS services and operations.</li>\n+         * <li>{@code CoreMetric.SERVICE_ID}, {@code CoreMetric.OPERATION_NAME} and {@code CoreMetric.HOST_NAME}: Separate\n+         * metrics by service, operation and host so that you can compare latencies across hosts in your fleet. Note: This should\n+         * only be used when your fleet is relatively small. Large fleets result in a large number of unique metrics being\n+         * generated.</li>\n+         * <li>{@code CoreMetric.SERVICE_ID}, {@code CoreMetric.OPERATION_NAME} and {@code HttpMetric.HTTP_CLIENT_NAME}: Separate\n+         * metrics by service, operation and HTTP client type so that you can compare latencies between different HTTP client\n+         * implementations.</li>\n+         * </ul>\n+         */\n+        public Builder dimensions(Collection<SdkMetric<String>> dimensions) {\n+            this.dimensions = new ArrayList<>(dimensions);\n+            return this;\n+        }\n+\n+        /**\n+         * @see #dimensions(SdkMetric[])\n+         */\n+        @SafeVarargs\n+        public final Builder dimensions(SdkMetric<String>... dimensions) {\n+            return dimensions(Arrays.asList(dimensions));\n+        }\n+\n+        /**\n+         * Configure the {@link MetricCategory}s that should be uploaded to CloudWatch.\n+         *\n+         * <p>If this is not specified, {@link MetricCategory#DEFAULT} and {@link MetricCategory#HTTP_CLIENT} are used.\n+         *\n+         * <p>All {@link SdkMetric}s are associated with at least one {@code MetricCategory}. This setting determines which\n+         * category of metrics uploaded to CloudWatch. Any metrics {@link #publish(MetricCollection)}ed that do not fall under\n+         * these configured categories are ignored.\n+         *\n+         * <p>Note: If there are {@link #dimensions(Collection)} configured that do not fall under these {@code MetricCategory}\n+         * values, the dimensions will NOT be ignored. In other words, the metric category configuration only affects which\n+         * metrics are uploaded to CloudWatch, not which values can be used for {@code dimensions}.\n+         */\n+        public Builder metricCategories(Collection<MetricCategory> metricCategories) {", "originalCommit": "6b9e6f6c3d9cc7f640c14346ccb46abd56eca8e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NTg3Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443055872", "bodyText": "I don't have an opinion either way. Save it for the surface area review? I can't think of something that isn't too long.", "author": "millems", "createdAt": "2020-06-19T21:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5ODQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MzEyMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443063120", "bodyText": "ok", "author": "bmaizels", "createdAt": "2020-06-19T22:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5ODQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMDYwNw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r442500607", "bodyText": "Thinking about future extensibility how about a metrics configuration object of some kind with a builder and for each metric different things could be configured like : addMetricConfiguration(m -> m.metric(MY_METRIC).detailed(true).someFutureThing(...))", "author": "bmaizels", "createdAt": "2020-06-18T21:02:10Z", "path": "metric-publishers/cloudwatch-metric-publisher/src/main/java/software/amazon/awssdk/metrics/publishers/cloudwatch/CloudWatchMetricPublisher.java", "diffHunk": "@@ -0,0 +1,507 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.metrics.publishers.cloudwatch;\n+\n+import static software.amazon.awssdk.metrics.publishers.cloudwatch.internal.CloudWatchMetricLogger.METRIC_LOGGER;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import software.amazon.awssdk.annotations.Immutable;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.annotations.ThreadSafe;\n+import software.amazon.awssdk.core.metrics.CoreMetric;\n+import software.amazon.awssdk.metrics.MetricCategory;\n+import software.amazon.awssdk.metrics.MetricCollection;\n+import software.amazon.awssdk.metrics.MetricCollector;\n+import software.amazon.awssdk.metrics.MetricPublisher;\n+import software.amazon.awssdk.metrics.SdkMetric;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.MetricUploader;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.task.AggregateMetricsTask;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.task.UploadMetricsTasks;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.transform.MetricCollectionAggregator;\n+import software.amazon.awssdk.services.cloudwatch.CloudWatchAsyncClient;\n+import software.amazon.awssdk.services.cloudwatch.model.Dimension;\n+import software.amazon.awssdk.services.cloudwatch.model.MetricDatum;\n+import software.amazon.awssdk.services.cloudwatch.model.PutMetricDataRequest;\n+import software.amazon.awssdk.services.cloudwatch.model.StatisticSet;\n+import software.amazon.awssdk.utils.ThreadFactoryBuilder;\n+\n+/**\n+ * An implementation of {@link MetricPublisher} that aggregates and uploads metrics to Amazon CloudWatch on a periodic basis.\n+ *\n+ * <p>This simplifies the process of uploading custom metrics to CloudWatch, and can also be configured on the AWS\n+ * SDK clients directly to upload AWS SDK-specific metrics (e.g. request latencies, failure rates) to CloudWatch.\n+ *\n+ * <p><b>Overview</b>\n+ *\n+ * <p>This publisher aggregates metric data in memory, and periodically uploads it to CloudWatch in a background thread. This\n+ * minimizes the work necessary to upload metrics, allowing the caller to focus on collecting the data.\n+ *\n+ * <p>The default settings of the metrics publisher are meant to minimize memory usage and CloudWatch cost, while still\n+ * providing a useful amount of insight into the metric data. Care should be taken when overriding the default values on the\n+ * publisher, because they can result in an associated increased in memory usage and CloudWatch cost.\n+ *\n+ * <p>By default, all metrics are uploaded using summary statistics. This means that only count, maximum, minimum, sum and\n+ * average data is available in CloudWatch. Metric details (e.g. p90, p99) can be enabled on a per-metric basis using\n+ * {@link Builder#detailedMetrics(Collection)}.\n+ *\n+ * <p>See {@link Builder} for the configuration values that are available for the publisher, and how they can be used to\n+ * increase the functionality or decrease the cost the publisher.\n+ *\n+ * <p><b>Logging</b>\n+ *\n+ * The CloudWatchMetricPublisher logs all aggregation and upload-related logs to the\n+ * {@code software.amazon.awssdk.metrics.publishers.cloudwatch} namespace. To determine how many metrics are being uploaded\n+ * successfully without checking the CloudWatch console, you can check for a \"success\" message at the DEBUG level. At the TRACE\n+ * level, you can see exactly which metrics are being uploaded.\n+ *\n+ * <p><b>Configuring AWS SDK clients to upload client metrics</b>\n+ *\n+ * TODO\n+ *\n+ * <p><b>Uploading your own custom metrics</b>\n+ *\n+ * <i>Step 1: Define which metrics you wish to collect</i>\n+ *\n+ * <p>Metrics are described using the {@link SdkMetric#create(String, Class)} method. When you describe your metric, you specify\n+ * the name that will appear in CloudWatch and the Java data-type of the metric. The metric should be described once for your\n+ * entire application.\n+ *\n+ * <p>Supported types: (1) {@link Number} types (e.g. {@link Integer}, {@link Double}, etc.), (2) {@link Duration}.\n+ *\n+ * <pre>\n+ *     // In this and the following examples, we want to collect metrics about calls to a method we have defined: \"myMethod\"\n+ *     public static final class MyMethodMetrics {\n+ *         // The number of times \"myMethod\" has been called.\n+ *         private static final SdkMetric&lt;Integer&gt; MY_METHOD_CALL_COUNT =\n+ *                 SdkMetric.create(\"MyMethodCallCount\", Integer.class);\n+ *\n+ *         // The amount of time that \"myMethod\" took to execute.\n+ *         private static final SdkMetric&lt;Duration&gt; MY_METHOD_LATENCY =\n+ *                 SdkMetric.create(\"MyMethodLatency\", Duration.class);\n+ *     }\n+ * </pre>\n+ *\n+ * <p><i>Step 2: Create a {@code CloudWatchMetricPublisher}</i>\n+ *\n+ * <p>A {@code CloudWatchMetricPublisher} should be created once for your entire application, and be reused wherever it is\n+ * needed. {@code CloudWatchMetricPublisher}s are thread-safe, so there should be no need to create multiple instances. Most\n+ * people create and manage the publisher in their inversion-of-control (IoC) container (e.g. Spring/Dagger/Guice).\n+ *\n+ * <p>Note: When your application is finished with the {@code CloudWatchMetricPublisher}, make sure to {@link #close()} it. Your\n+ * inversion-of-control container may handle this for you on JVM shutdown.\n+ *\n+ * <p>See {@link CloudWatchMetricPublisher.Builder} for all available configuration options.\n+ *\n+ * <pre>\n+ *     // Create a CloudWatchMetricPublisher using a custom namespace.\n+ *     MetricPublisher metricPublisher = CloudWatchMetricPublisher.builder()\n+ *                                                                .namespace(\"MyApplication\")\n+ *                                                                .build();\n+ * </pre>\n+ *\n+ * <p><i>Step 3: Collect and Publish Metrics</i>\n+ *\n+ * <p>Create and use a {@link MetricCollector} to collect data about your configured metrics.\n+ *\n+ * <pre>\n+ *     // Call \"myMethod\" and collect metrics about the call.\n+ *     Instant methodCallStartTime = Instant.now();\n+ *     myMethod();\n+ *     Duration methodCallDuration = Duration.between(methodCallStartTime, Instant.now());\n+ *\n+ *     // Write the metrics to the CloudWatchMetricPublisher.\n+ *     MetricCollector metricCollector = MetricCollector.create(\"MyMethodCall\");\n+ *     metricCollector.reportMetric(MyCustomMetrics.MY_METHOD_CALL_COUNT, 1);\n+ *     metricCollector.reportMetric(MyCustomMetrics.MY_METHOD_LATENCY, methodCallDuration);\n+ *     MetricCollection metricCollection = metricCollector.collect();\n+ *\n+ *     metricPublisher.publish(metricCollection);\n+ * </pre>\n+ *\n+ * <p><b>Warning:</b> Make sure the {@link #close()} this publisher when it is done being used to release all resources it\n+ * consumes. Failure to do so will result in possible thread or file descriptor leaks.\n+ */\n+@ThreadSafe\n+@Immutable\n+@SdkPublicApi\n+public final class CloudWatchMetricPublisher implements MetricPublisher {\n+    /**\n+     * The maximum queue size for the internal {@link #executor} that is used to aggregate metric data and upload it to\n+     * CloudWatch. If this value is too high, memory is wasted. If this value is too low, metrics could be dropped.\n+     *\n+     * This value is not currently configurable, because it's unlikely that this is a value that customers should need to modify.\n+     * If customers really need control over this value, we might consider letting them instead configure the\n+     * {@link BlockingQueue} used on the executor. The value here depends on the type of {@code BlockingQueue} in use, and\n+     * we should probably not indirectly couple people to the type of blocking queue we're using.\n+     */\n+    private static final int MAXIMUM_TASK_QUEUE_SIZE = 128;\n+\n+    private static final String DEFAULT_NAMESPACE = \"AwsSdk/JavaSdk2\";\n+    private static final int DEFAULT_MAXIMUM_CALLS_PER_UPLOAD = 10;\n+    private static final Duration DEFAULT_UPLOAD_FREQUENCY = Duration.ofMinutes(1);\n+    private static final Set<SdkMetric<String>> DEFAULT_DIMENSIONS = Stream.of(CoreMetric.SERVICE_ID,\n+                                                                               CoreMetric.OPERATION_NAME)\n+                                                                           .collect(Collectors.toSet());\n+    private static final Set<MetricCategory> DEFAULT_METRIC_CATEGORIES = Stream.of(MetricCategory.DEFAULT,\n+                                                                                   MetricCategory.HTTP_CLIENT)\n+                                                                               .collect(Collectors.toSet());\n+    private static final Set<SdkMetric<?>> DEFAULT_DETAILED_METRICS = Collections.emptySet();\n+\n+    /**\n+     * Whether {@link #close()} should call {@link CloudWatchAsyncClient#close()}. This is false when\n+     * {@link Builder#cloudWatchClient(CloudWatchAsyncClient)} was specified, meaning the customer has to close the client\n+     * themselves.\n+     */\n+    private final boolean closeClientWithPublisher;\n+\n+    /**\n+     * The aggregator that takes {@link MetricCollection}s and converts them into {@link PutMetricDataRequest}s. This aggregator\n+     * is *not* thread safe, so it should only ever be accessed from the {@link #executor}'s thread.\n+     */\n+    private final MetricCollectionAggregator metricAggregator;\n+\n+    /**\n+     * The uploader that takes {@link PutMetricDataRequest}s and sends them to a {@link CloudWatchAsyncClient}.\n+     */\n+    private final MetricUploader metricUploader;\n+\n+    /**\n+     * The executor that executes {@link AggregateMetricsTask}s and {@link UploadMetricsTasks}s.\n+     */\n+    private final ExecutorService executor;\n+\n+    /**\n+     * A scheduled executor that periodically schedules a {@link UploadMetricsTasks} on the {@link #executor} thread. Note: this\n+     * executor should never execute the flush task itself, because that needs access to the {@link #metricAggregator}, and the\n+     * {@code metricAggregator} should only ever be accessed from the {@link #executor} thread.\n+     */\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * The maximum number of {@link PutMetricDataRequest}s that should ever be executed as part of a single\n+     * {@link UploadMetricsTasks}.\n+     */\n+    private final int maximumCallsPerUpload;\n+\n+    private CloudWatchMetricPublisher(Builder builder) {\n+        this.closeClientWithPublisher = resolveCloseClientWithPublisher(builder);\n+        this.metricAggregator = new MetricCollectionAggregator(resolveNamespace(builder),\n+                                                               resolveDimensions(builder),\n+                                                               resolveMetricCategories(builder),\n+                                                               resolveDetailedMetrics(builder));\n+        this.metricUploader = new MetricUploader(resolveClient(builder));\n+        this.maximumCallsPerUpload = resolveMaximumCallsPerUpload(builder);\n+\n+        ThreadFactory threadFactory = new ThreadFactoryBuilder().threadNamePrefix(\"cloud-watch-metric-publisher\").build();\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor(threadFactory);\n+        this.executor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,\n+                                               new ArrayBlockingQueue<>(MAXIMUM_TASK_QUEUE_SIZE),\n+                                               threadFactory);\n+\n+        long flushFrequencyInMillis = resolveUploadFrequency(builder).toMillis();\n+        this.scheduledExecutor.scheduleAtFixedRate(this::flushMetrics,\n+                                                   flushFrequencyInMillis, flushFrequencyInMillis, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private Set<MetricCategory> resolveMetricCategories(Builder builder) {\n+        return builder.metricCategories == null ? DEFAULT_METRIC_CATEGORIES : new HashSet<>(builder.metricCategories);\n+    }\n+\n+    private Set<SdkMetric<?>> resolveDetailedMetrics(Builder builder) {\n+        return builder.detailedMetrics == null ? DEFAULT_DETAILED_METRICS : new HashSet<>(builder.detailedMetrics);\n+    }\n+\n+    private Set<SdkMetric<String>> resolveDimensions(Builder builder) {\n+        return builder.dimensions == null ? DEFAULT_DIMENSIONS : new HashSet<>(builder.dimensions);\n+    }\n+\n+    private boolean resolveCloseClientWithPublisher(Builder builder) {\n+        return builder.client == null;\n+    }\n+\n+    private CloudWatchAsyncClient resolveClient(Builder builder) {\n+        return builder.client == null ? CloudWatchAsyncClient.create() : builder.client;\n+    }\n+\n+    private Duration resolveUploadFrequency(Builder builder) {\n+        return builder.uploadFrequency == null ? DEFAULT_UPLOAD_FREQUENCY : builder.uploadFrequency;\n+    }\n+\n+    private String resolveNamespace(Builder builder) {\n+        return builder.namespace == null ? DEFAULT_NAMESPACE : builder.namespace;\n+    }\n+\n+    private int resolveMaximumCallsPerUpload(Builder builder) {\n+        return builder.maximumCallsPerUpload == null ? DEFAULT_MAXIMUM_CALLS_PER_UPLOAD : builder.maximumCallsPerUpload;\n+    }\n+\n+    @Override\n+    public void publish(MetricCollection metricCollection) {\n+        try {\n+            executor.submit(new AggregateMetricsTask(metricAggregator, metricCollection));\n+        } catch (RejectedExecutionException e) {\n+            METRIC_LOGGER.warn(() -> \"Some AWS SDK client-side metrics have been dropped because an internal executor did not \"\n+                                     + \"accept them. This usually occurs because your publisher has been shut down or you have \"\n+                                     + \"generated too many requests for the publisher to handle in a timely fashion.\", e);\n+        }\n+    }\n+\n+    private void flushMetrics() {\n+        while (true) {\n+            try {\n+                executor.submit(new UploadMetricsTasks(metricAggregator, metricUploader, maximumCallsPerUpload));\n+                break;\n+            } catch (RejectedExecutionException e) {\n+                Thread.yield();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        scheduledExecutor.shutdownNow();\n+\n+        flushMetrics();\n+        executor.shutdown();\n+        try {\n+            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n+                executor.shutdownNow();\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+\n+        metricUploader.close(closeClientWithPublisher);\n+    }\n+\n+    /**\n+     * Create a new {@link Builder} that can be used to create {@link CloudWatchMetricPublisher}s.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Create a {@link CloudWatchMetricPublisher} using all default values.\n+     */\n+    public static CloudWatchMetricPublisher create() {\n+        return builder().build();\n+    }\n+\n+    /**\n+     * Builder class to construct {@link CloudWatchMetricPublisher} instances. See the individual properties for which\n+     * configuration settings are available.\n+     */\n+    public static final class Builder {\n+        private CloudWatchAsyncClient client;\n+        private Duration uploadFrequency;\n+        private String namespace;\n+        private Integer maximumCallsPerUpload;\n+        private Collection<SdkMetric<String>> dimensions;\n+        private Collection<MetricCategory> metricCategories;\n+        private Collection<SdkMetric<?>> detailedMetrics;\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Configure the {@link PutMetricDataRequest#namespace()} used for all put-metric-data calls from this publisher.\n+         *\n+         * <p>If this is not specified, {@code AwsSdk/JavaSdk2} will be used.\n+         */\n+        public Builder namespace(String namespace) {\n+            this.namespace = namespace;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure the {@link CloudWatchAsyncClient} instance that should be used to communicate with CloudWatch.\n+         *\n+         * <p>If this is not specified, the {@code CloudWatchAsyncClient} will be created via\n+         * {@link CloudWatchAsyncClient#create()} (and will be closed when {@link #close()} is invoked).\n+         *\n+         * <p>If you specify a {@code CloudWatchAsyncClient} via this method, it <i>will not</i> be closed when this publisher\n+         * is closed. You will need to need to manage the lifecycle of the client yourself.\n+         */\n+        public Builder cloudWatchClient(CloudWatchAsyncClient client) {\n+            this.client = client;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure the frequency at which aggregated metrics are uploaded to CloudWatch and released from memory.\n+         *\n+         * <p>If this is not specified, metrics will be uploaded once per minute.\n+         *\n+         * <p>Smaller values will: (1) reduce the amount of memory used by the library (particularly when\n+         * {@link #detailedMetrics(Collection)} are enabled), (2) increase the number of CloudWatch calls (and therefore\n+         * increase CloudWatch usage cost).\n+         *\n+         * <p>Larger values will: (1) increase the amount of memory used by the library (particularly when\n+         * {@code detailedMetrics} are enabled), (2) increase the time it takes for metric data to appear in\n+         * CloudWatch, (3) reduce the number of CloudWatch calls (and therefore decrease CloudWatch usage cost).\n+         *\n+         * <p><b>Warning:</b> When {@code detailedMetrics} are enabled, all unique metric values are stored in memory until they\n+         * can be published to CloudWatch. A high {@code uploadFrequency} with multiple {@code detailedMetrics} enabled can\n+         * quickly consume heap memory while the values wait to be published to CloudWatch. In memory constrained environments, it\n+         * is recommended to minimize the number of {@code detailedMetrics} configured on the publisher, or to upload metric data\n+         * more frequently. As with all performance and resource concerns, profiling in a production-like environment is\n+         * encouraged.\n+         */\n+        public Builder uploadFrequency(Duration uploadFrequency) {\n+            this.uploadFrequency = uploadFrequency;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure the maximum number of {@link CloudWatchAsyncClient#putMetricData(PutMetricDataRequest)} calls that an\n+         * individual \"upload\" event can make to CloudWatch. Any metrics that would exceed this limit are dropped during the\n+         * upload, logging a warning on the {@code software.amazon.awssdk.metrics.publishers.cloudwatch} namespace.\n+         *\n+         * <p>The SDK will always attempt to maximize the number of metrics per put-metric-data call, but uploads will be split\n+         * into multiple put-metric-data calls if they include a lot of different metrics or if there are a lot of high-value-\n+         * distribution {@link #detailedMetrics(Collection)} being monitored.\n+         *\n+         * <p>This value combined with the {@link #uploadFrequency(Duration)} effectively provide a \"hard cap\" on the number of\n+         * put-metric-data calls, to prevent unbounded cost in the event that too many metrics are enabled by the user.\n+         *\n+         * <p>If this is not specified, put-metric-data calls will be capped at 10 per upload.\n+         */\n+        public Builder maximumCallsPerUpload(Integer maximumCallsPerUpload) {\n+            this.maximumCallsPerUpload = maximumCallsPerUpload;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure the {@link SdkMetric}s that are used to define the {@link Dimension}s metrics are aggregated under.\n+         *\n+         * <p>If this is not specified, {@link CoreMetric#SERVICE_ID} and {@link CoreMetric#OPERATION_NAME} are used, allowing\n+         * you to compare metrics for different services and operations.\n+         *\n+         * <p><b>Warning:</b> Configuring the dimensions incorrectly can result in a large increase in the number of unique\n+         * metrics and put-metric-data calls to cloudwatch, which have an associated monetary cost. Be sure you're choosing your\n+         * metric dimensions wisely, and that you always evaluate the cost of modifying these values on your monthly usage costs.\n+         *\n+         * <p><b>Example useful settings:</b>\n+         * <ul>\n+         * <li>{@code CoreMetric.SERVICE_ID} and {@code CoreMetric.OPERATION_NAME} (default): Separate metrics by service and\n+         * operation, so that you can compare latencies between AWS services and operations.</li>\n+         * <li>{@code CoreMetric.SERVICE_ID}, {@code CoreMetric.OPERATION_NAME} and {@code CoreMetric.HOST_NAME}: Separate\n+         * metrics by service, operation and host so that you can compare latencies across hosts in your fleet. Note: This should\n+         * only be used when your fleet is relatively small. Large fleets result in a large number of unique metrics being\n+         * generated.</li>\n+         * <li>{@code CoreMetric.SERVICE_ID}, {@code CoreMetric.OPERATION_NAME} and {@code HttpMetric.HTTP_CLIENT_NAME}: Separate\n+         * metrics by service, operation and HTTP client type so that you can compare latencies between different HTTP client\n+         * implementations.</li>\n+         * </ul>\n+         */\n+        public Builder dimensions(Collection<SdkMetric<String>> dimensions) {\n+            this.dimensions = new ArrayList<>(dimensions);\n+            return this;\n+        }\n+\n+        /**\n+         * @see #dimensions(SdkMetric[])\n+         */\n+        @SafeVarargs\n+        public final Builder dimensions(SdkMetric<String>... dimensions) {\n+            return dimensions(Arrays.asList(dimensions));\n+        }\n+\n+        /**\n+         * Configure the {@link MetricCategory}s that should be uploaded to CloudWatch.\n+         *\n+         * <p>If this is not specified, {@link MetricCategory#DEFAULT} and {@link MetricCategory#HTTP_CLIENT} are used.\n+         *\n+         * <p>All {@link SdkMetric}s are associated with at least one {@code MetricCategory}. This setting determines which\n+         * category of metrics uploaded to CloudWatch. Any metrics {@link #publish(MetricCollection)}ed that do not fall under\n+         * these configured categories are ignored.\n+         *\n+         * <p>Note: If there are {@link #dimensions(Collection)} configured that do not fall under these {@code MetricCategory}\n+         * values, the dimensions will NOT be ignored. In other words, the metric category configuration only affects which\n+         * metrics are uploaded to CloudWatch, not which values can be used for {@code dimensions}.\n+         */\n+        public Builder metricCategories(Collection<MetricCategory> metricCategories) {\n+            this.metricCategories = new ArrayList<>(metricCategories);\n+            return this;\n+        }\n+\n+        /**\n+         * @see #metricCategories(Collection)\n+         */\n+        public Builder metricCategories(MetricCategory... metricCategories) {\n+            return metricCategories(Arrays.asList(metricCategories));\n+        }\n+\n+        /**\n+         * Configure the set of metrics for which detailed values and counts are uploaded to CloudWatch, instead of summaries.\n+         *\n+         * <p>By default, all metrics published to this publisher are summarized using {@link StatisticSet}s. This saves memory,\n+         * because it allows the publisher to store a fixed amount of information in memory, no matter how many different metric\n+         * values are published. The drawback is that metrics other than count, sum, average, maximum and minimum are not made\n+         * available in CloudWatch. The {@code detailedMetrics} setting instructs the publisher to store and publish itemized\n+         * {@link MetricDatum#values()} and {@link MetricDatum#counts()}, which enables other metrics like p90 and p99 to be\n+         * queried in CloudWatch.\n+         *\n+         * <p><b>Warning:</b> When {@code detailedMetrics} are enabled, all unique metric values are stored in memory until they\n+         * can be published to CloudWatch. A high {@code uploadFrequency} with multiple {@code detailedMetrics} enabled can\n+         * quickly consume heap memory while the values wait to be published to CloudWatch. In memory constrained environments, it\n+         * is recommended to minimize the number of {@code detailedMetrics} configured on the publisher, or to upload metric data\n+         * more frequently. As with all performance and resource concerns, profiling in a production-like environment is\n+         * encouraged.\n+         *\n+         * <p>In addition to additional heap memory usage, detailed metrics can result in more requests being sent to CloudWatch,\n+         * which can also introduce additional usage cost. The {@link #maximumCallsPerUpload(Integer)} acts as a safeguard against\n+         * too many calls being made, but if you configure multiple {@code detailedMetrics}, you may need to increase the\n+         * {@code maximumCallsPerUpload} limit.\n+         */\n+        public Builder detailedMetrics(Collection<SdkMetric<?>> detailedMetrics) {", "originalCommit": "6b9e6f6c3d9cc7f640c14346ccb46abd56eca8e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1Njk2MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443056960", "bodyText": "I mentioned on the call that I tried this and it felt like I was being too cute. I can try again, though.", "author": "millems", "createdAt": "2020-06-19T21:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMDYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2NzQ0NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443067444", "bodyText": "We can defer to the surface review? I think it'd be a good thing for future extensibility.", "author": "bmaizels", "createdAt": "2020-06-19T22:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMDYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2ODU0OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443068549", "bodyText": "Let's merge and then add a task to prototype alternatives, to make sure we don't forget during the surface review.", "author": "millems", "createdAt": "2020-06-19T22:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMDYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2NzQwOQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r442967409", "bodyText": "I think the class design makes this difficult to unit test effectively. Ideally there should be something that can be injected/mocked here, so that the specific behavior/responsibilities of this class can be tested in unit style rather than functional style including the behavior of the AggregateMetricsTask.", "author": "bmaizels", "createdAt": "2020-06-19T17:38:20Z", "path": "metric-publishers/cloudwatch-metric-publisher/src/main/java/software/amazon/awssdk/metrics/publishers/cloudwatch/CloudWatchMetricPublisher.java", "diffHunk": "@@ -0,0 +1,507 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.metrics.publishers.cloudwatch;\n+\n+import static software.amazon.awssdk.metrics.publishers.cloudwatch.internal.CloudWatchMetricLogger.METRIC_LOGGER;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import software.amazon.awssdk.annotations.Immutable;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.annotations.ThreadSafe;\n+import software.amazon.awssdk.core.metrics.CoreMetric;\n+import software.amazon.awssdk.metrics.MetricCategory;\n+import software.amazon.awssdk.metrics.MetricCollection;\n+import software.amazon.awssdk.metrics.MetricCollector;\n+import software.amazon.awssdk.metrics.MetricPublisher;\n+import software.amazon.awssdk.metrics.SdkMetric;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.MetricUploader;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.task.AggregateMetricsTask;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.task.UploadMetricsTasks;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.transform.MetricCollectionAggregator;\n+import software.amazon.awssdk.services.cloudwatch.CloudWatchAsyncClient;\n+import software.amazon.awssdk.services.cloudwatch.model.Dimension;\n+import software.amazon.awssdk.services.cloudwatch.model.MetricDatum;\n+import software.amazon.awssdk.services.cloudwatch.model.PutMetricDataRequest;\n+import software.amazon.awssdk.services.cloudwatch.model.StatisticSet;\n+import software.amazon.awssdk.utils.ThreadFactoryBuilder;\n+\n+/**\n+ * An implementation of {@link MetricPublisher} that aggregates and uploads metrics to Amazon CloudWatch on a periodic basis.\n+ *\n+ * <p>This simplifies the process of uploading custom metrics to CloudWatch, and can also be configured on the AWS\n+ * SDK clients directly to upload AWS SDK-specific metrics (e.g. request latencies, failure rates) to CloudWatch.\n+ *\n+ * <p><b>Overview</b>\n+ *\n+ * <p>This publisher aggregates metric data in memory, and periodically uploads it to CloudWatch in a background thread. This\n+ * minimizes the work necessary to upload metrics, allowing the caller to focus on collecting the data.\n+ *\n+ * <p>The default settings of the metrics publisher are meant to minimize memory usage and CloudWatch cost, while still\n+ * providing a useful amount of insight into the metric data. Care should be taken when overriding the default values on the\n+ * publisher, because they can result in an associated increased in memory usage and CloudWatch cost.\n+ *\n+ * <p>By default, all metrics are uploaded using summary statistics. This means that only count, maximum, minimum, sum and\n+ * average data is available in CloudWatch. Metric details (e.g. p90, p99) can be enabled on a per-metric basis using\n+ * {@link Builder#detailedMetrics(Collection)}.\n+ *\n+ * <p>See {@link Builder} for the configuration values that are available for the publisher, and how they can be used to\n+ * increase the functionality or decrease the cost the publisher.\n+ *\n+ * <p><b>Logging</b>\n+ *\n+ * The CloudWatchMetricPublisher logs all aggregation and upload-related logs to the\n+ * {@code software.amazon.awssdk.metrics.publishers.cloudwatch} namespace. To determine how many metrics are being uploaded\n+ * successfully without checking the CloudWatch console, you can check for a \"success\" message at the DEBUG level. At the TRACE\n+ * level, you can see exactly which metrics are being uploaded.\n+ *\n+ * <p><b>Configuring AWS SDK clients to upload client metrics</b>\n+ *\n+ * TODO\n+ *\n+ * <p><b>Uploading your own custom metrics</b>\n+ *\n+ * <i>Step 1: Define which metrics you wish to collect</i>\n+ *\n+ * <p>Metrics are described using the {@link SdkMetric#create(String, Class)} method. When you describe your metric, you specify\n+ * the name that will appear in CloudWatch and the Java data-type of the metric. The metric should be described once for your\n+ * entire application.\n+ *\n+ * <p>Supported types: (1) {@link Number} types (e.g. {@link Integer}, {@link Double}, etc.), (2) {@link Duration}.\n+ *\n+ * <pre>\n+ *     // In this and the following examples, we want to collect metrics about calls to a method we have defined: \"myMethod\"\n+ *     public static final class MyMethodMetrics {\n+ *         // The number of times \"myMethod\" has been called.\n+ *         private static final SdkMetric&lt;Integer&gt; MY_METHOD_CALL_COUNT =\n+ *                 SdkMetric.create(\"MyMethodCallCount\", Integer.class);\n+ *\n+ *         // The amount of time that \"myMethod\" took to execute.\n+ *         private static final SdkMetric&lt;Duration&gt; MY_METHOD_LATENCY =\n+ *                 SdkMetric.create(\"MyMethodLatency\", Duration.class);\n+ *     }\n+ * </pre>\n+ *\n+ * <p><i>Step 2: Create a {@code CloudWatchMetricPublisher}</i>\n+ *\n+ * <p>A {@code CloudWatchMetricPublisher} should be created once for your entire application, and be reused wherever it is\n+ * needed. {@code CloudWatchMetricPublisher}s are thread-safe, so there should be no need to create multiple instances. Most\n+ * people create and manage the publisher in their inversion-of-control (IoC) container (e.g. Spring/Dagger/Guice).\n+ *\n+ * <p>Note: When your application is finished with the {@code CloudWatchMetricPublisher}, make sure to {@link #close()} it. Your\n+ * inversion-of-control container may handle this for you on JVM shutdown.\n+ *\n+ * <p>See {@link CloudWatchMetricPublisher.Builder} for all available configuration options.\n+ *\n+ * <pre>\n+ *     // Create a CloudWatchMetricPublisher using a custom namespace.\n+ *     MetricPublisher metricPublisher = CloudWatchMetricPublisher.builder()\n+ *                                                                .namespace(\"MyApplication\")\n+ *                                                                .build();\n+ * </pre>\n+ *\n+ * <p><i>Step 3: Collect and Publish Metrics</i>\n+ *\n+ * <p>Create and use a {@link MetricCollector} to collect data about your configured metrics.\n+ *\n+ * <pre>\n+ *     // Call \"myMethod\" and collect metrics about the call.\n+ *     Instant methodCallStartTime = Instant.now();\n+ *     myMethod();\n+ *     Duration methodCallDuration = Duration.between(methodCallStartTime, Instant.now());\n+ *\n+ *     // Write the metrics to the CloudWatchMetricPublisher.\n+ *     MetricCollector metricCollector = MetricCollector.create(\"MyMethodCall\");\n+ *     metricCollector.reportMetric(MyCustomMetrics.MY_METHOD_CALL_COUNT, 1);\n+ *     metricCollector.reportMetric(MyCustomMetrics.MY_METHOD_LATENCY, methodCallDuration);\n+ *     MetricCollection metricCollection = metricCollector.collect();\n+ *\n+ *     metricPublisher.publish(metricCollection);\n+ * </pre>\n+ *\n+ * <p><b>Warning:</b> Make sure the {@link #close()} this publisher when it is done being used to release all resources it\n+ * consumes. Failure to do so will result in possible thread or file descriptor leaks.\n+ */\n+@ThreadSafe\n+@Immutable\n+@SdkPublicApi\n+public final class CloudWatchMetricPublisher implements MetricPublisher {\n+    /**\n+     * The maximum queue size for the internal {@link #executor} that is used to aggregate metric data and upload it to\n+     * CloudWatch. If this value is too high, memory is wasted. If this value is too low, metrics could be dropped.\n+     *\n+     * This value is not currently configurable, because it's unlikely that this is a value that customers should need to modify.\n+     * If customers really need control over this value, we might consider letting them instead configure the\n+     * {@link BlockingQueue} used on the executor. The value here depends on the type of {@code BlockingQueue} in use, and\n+     * we should probably not indirectly couple people to the type of blocking queue we're using.\n+     */\n+    private static final int MAXIMUM_TASK_QUEUE_SIZE = 128;\n+\n+    private static final String DEFAULT_NAMESPACE = \"AwsSdk/JavaSdk2\";\n+    private static final int DEFAULT_MAXIMUM_CALLS_PER_UPLOAD = 10;\n+    private static final Duration DEFAULT_UPLOAD_FREQUENCY = Duration.ofMinutes(1);\n+    private static final Set<SdkMetric<String>> DEFAULT_DIMENSIONS = Stream.of(CoreMetric.SERVICE_ID,\n+                                                                               CoreMetric.OPERATION_NAME)\n+                                                                           .collect(Collectors.toSet());\n+    private static final Set<MetricCategory> DEFAULT_METRIC_CATEGORIES = Stream.of(MetricCategory.DEFAULT,\n+                                                                                   MetricCategory.HTTP_CLIENT)\n+                                                                               .collect(Collectors.toSet());\n+    private static final Set<SdkMetric<?>> DEFAULT_DETAILED_METRICS = Collections.emptySet();\n+\n+    /**\n+     * Whether {@link #close()} should call {@link CloudWatchAsyncClient#close()}. This is false when\n+     * {@link Builder#cloudWatchClient(CloudWatchAsyncClient)} was specified, meaning the customer has to close the client\n+     * themselves.\n+     */\n+    private final boolean closeClientWithPublisher;\n+\n+    /**\n+     * The aggregator that takes {@link MetricCollection}s and converts them into {@link PutMetricDataRequest}s. This aggregator\n+     * is *not* thread safe, so it should only ever be accessed from the {@link #executor}'s thread.\n+     */\n+    private final MetricCollectionAggregator metricAggregator;\n+\n+    /**\n+     * The uploader that takes {@link PutMetricDataRequest}s and sends them to a {@link CloudWatchAsyncClient}.\n+     */\n+    private final MetricUploader metricUploader;\n+\n+    /**\n+     * The executor that executes {@link AggregateMetricsTask}s and {@link UploadMetricsTasks}s.\n+     */\n+    private final ExecutorService executor;\n+\n+    /**\n+     * A scheduled executor that periodically schedules a {@link UploadMetricsTasks} on the {@link #executor} thread. Note: this\n+     * executor should never execute the flush task itself, because that needs access to the {@link #metricAggregator}, and the\n+     * {@code metricAggregator} should only ever be accessed from the {@link #executor} thread.\n+     */\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * The maximum number of {@link PutMetricDataRequest}s that should ever be executed as part of a single\n+     * {@link UploadMetricsTasks}.\n+     */\n+    private final int maximumCallsPerUpload;\n+\n+    private CloudWatchMetricPublisher(Builder builder) {\n+        this.closeClientWithPublisher = resolveCloseClientWithPublisher(builder);\n+        this.metricAggregator = new MetricCollectionAggregator(resolveNamespace(builder),\n+                                                               resolveDimensions(builder),\n+                                                               resolveMetricCategories(builder),\n+                                                               resolveDetailedMetrics(builder));\n+        this.metricUploader = new MetricUploader(resolveClient(builder));\n+        this.maximumCallsPerUpload = resolveMaximumCallsPerUpload(builder);\n+\n+        ThreadFactory threadFactory = new ThreadFactoryBuilder().threadNamePrefix(\"cloud-watch-metric-publisher\").build();\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor(threadFactory);\n+        this.executor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,\n+                                               new ArrayBlockingQueue<>(MAXIMUM_TASK_QUEUE_SIZE),\n+                                               threadFactory);\n+\n+        long flushFrequencyInMillis = resolveUploadFrequency(builder).toMillis();\n+        this.scheduledExecutor.scheduleAtFixedRate(this::flushMetrics,\n+                                                   flushFrequencyInMillis, flushFrequencyInMillis, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private Set<MetricCategory> resolveMetricCategories(Builder builder) {\n+        return builder.metricCategories == null ? DEFAULT_METRIC_CATEGORIES : new HashSet<>(builder.metricCategories);\n+    }\n+\n+    private Set<SdkMetric<?>> resolveDetailedMetrics(Builder builder) {\n+        return builder.detailedMetrics == null ? DEFAULT_DETAILED_METRICS : new HashSet<>(builder.detailedMetrics);\n+    }\n+\n+    private Set<SdkMetric<String>> resolveDimensions(Builder builder) {\n+        return builder.dimensions == null ? DEFAULT_DIMENSIONS : new HashSet<>(builder.dimensions);\n+    }\n+\n+    private boolean resolveCloseClientWithPublisher(Builder builder) {\n+        return builder.client == null;\n+    }\n+\n+    private CloudWatchAsyncClient resolveClient(Builder builder) {\n+        return builder.client == null ? CloudWatchAsyncClient.create() : builder.client;\n+    }\n+\n+    private Duration resolveUploadFrequency(Builder builder) {\n+        return builder.uploadFrequency == null ? DEFAULT_UPLOAD_FREQUENCY : builder.uploadFrequency;\n+    }\n+\n+    private String resolveNamespace(Builder builder) {\n+        return builder.namespace == null ? DEFAULT_NAMESPACE : builder.namespace;\n+    }\n+\n+    private int resolveMaximumCallsPerUpload(Builder builder) {\n+        return builder.maximumCallsPerUpload == null ? DEFAULT_MAXIMUM_CALLS_PER_UPLOAD : builder.maximumCallsPerUpload;\n+    }\n+\n+    @Override\n+    public void publish(MetricCollection metricCollection) {\n+        try {\n+            executor.submit(new AggregateMetricsTask(metricAggregator, metricCollection));", "originalCommit": "6b9e6f6c3d9cc7f640c14346ccb46abd56eca8e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2NzY0OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443067648", "bodyText": "As discussed I don't consider this feedback to be blocking.", "author": "bmaizels", "createdAt": "2020-06-19T22:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2NzQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzODQ5OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443038498", "bodyText": "Maybe also check for executor shutdown as this could cause an infinite loop", "author": "bmaizels", "createdAt": "2020-06-19T20:49:46Z", "path": "metric-publishers/cloudwatch-metric-publisher/src/main/java/software/amazon/awssdk/metrics/publishers/cloudwatch/CloudWatchMetricPublisher.java", "diffHunk": "@@ -0,0 +1,507 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.metrics.publishers.cloudwatch;\n+\n+import static software.amazon.awssdk.metrics.publishers.cloudwatch.internal.CloudWatchMetricLogger.METRIC_LOGGER;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import software.amazon.awssdk.annotations.Immutable;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.annotations.ThreadSafe;\n+import software.amazon.awssdk.core.metrics.CoreMetric;\n+import software.amazon.awssdk.metrics.MetricCategory;\n+import software.amazon.awssdk.metrics.MetricCollection;\n+import software.amazon.awssdk.metrics.MetricCollector;\n+import software.amazon.awssdk.metrics.MetricPublisher;\n+import software.amazon.awssdk.metrics.SdkMetric;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.MetricUploader;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.task.AggregateMetricsTask;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.task.UploadMetricsTasks;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.transform.MetricCollectionAggregator;\n+import software.amazon.awssdk.services.cloudwatch.CloudWatchAsyncClient;\n+import software.amazon.awssdk.services.cloudwatch.model.Dimension;\n+import software.amazon.awssdk.services.cloudwatch.model.MetricDatum;\n+import software.amazon.awssdk.services.cloudwatch.model.PutMetricDataRequest;\n+import software.amazon.awssdk.services.cloudwatch.model.StatisticSet;\n+import software.amazon.awssdk.utils.ThreadFactoryBuilder;\n+\n+/**\n+ * An implementation of {@link MetricPublisher} that aggregates and uploads metrics to Amazon CloudWatch on a periodic basis.\n+ *\n+ * <p>This simplifies the process of uploading custom metrics to CloudWatch, and can also be configured on the AWS\n+ * SDK clients directly to upload AWS SDK-specific metrics (e.g. request latencies, failure rates) to CloudWatch.\n+ *\n+ * <p><b>Overview</b>\n+ *\n+ * <p>This publisher aggregates metric data in memory, and periodically uploads it to CloudWatch in a background thread. This\n+ * minimizes the work necessary to upload metrics, allowing the caller to focus on collecting the data.\n+ *\n+ * <p>The default settings of the metrics publisher are meant to minimize memory usage and CloudWatch cost, while still\n+ * providing a useful amount of insight into the metric data. Care should be taken when overriding the default values on the\n+ * publisher, because they can result in an associated increased in memory usage and CloudWatch cost.\n+ *\n+ * <p>By default, all metrics are uploaded using summary statistics. This means that only count, maximum, minimum, sum and\n+ * average data is available in CloudWatch. Metric details (e.g. p90, p99) can be enabled on a per-metric basis using\n+ * {@link Builder#detailedMetrics(Collection)}.\n+ *\n+ * <p>See {@link Builder} for the configuration values that are available for the publisher, and how they can be used to\n+ * increase the functionality or decrease the cost the publisher.\n+ *\n+ * <p><b>Logging</b>\n+ *\n+ * The CloudWatchMetricPublisher logs all aggregation and upload-related logs to the\n+ * {@code software.amazon.awssdk.metrics.publishers.cloudwatch} namespace. To determine how many metrics are being uploaded\n+ * successfully without checking the CloudWatch console, you can check for a \"success\" message at the DEBUG level. At the TRACE\n+ * level, you can see exactly which metrics are being uploaded.\n+ *\n+ * <p><b>Configuring AWS SDK clients to upload client metrics</b>\n+ *\n+ * TODO\n+ *\n+ * <p><b>Uploading your own custom metrics</b>\n+ *\n+ * <i>Step 1: Define which metrics you wish to collect</i>\n+ *\n+ * <p>Metrics are described using the {@link SdkMetric#create(String, Class)} method. When you describe your metric, you specify\n+ * the name that will appear in CloudWatch and the Java data-type of the metric. The metric should be described once for your\n+ * entire application.\n+ *\n+ * <p>Supported types: (1) {@link Number} types (e.g. {@link Integer}, {@link Double}, etc.), (2) {@link Duration}.\n+ *\n+ * <pre>\n+ *     // In this and the following examples, we want to collect metrics about calls to a method we have defined: \"myMethod\"\n+ *     public static final class MyMethodMetrics {\n+ *         // The number of times \"myMethod\" has been called.\n+ *         private static final SdkMetric&lt;Integer&gt; MY_METHOD_CALL_COUNT =\n+ *                 SdkMetric.create(\"MyMethodCallCount\", Integer.class);\n+ *\n+ *         // The amount of time that \"myMethod\" took to execute.\n+ *         private static final SdkMetric&lt;Duration&gt; MY_METHOD_LATENCY =\n+ *                 SdkMetric.create(\"MyMethodLatency\", Duration.class);\n+ *     }\n+ * </pre>\n+ *\n+ * <p><i>Step 2: Create a {@code CloudWatchMetricPublisher}</i>\n+ *\n+ * <p>A {@code CloudWatchMetricPublisher} should be created once for your entire application, and be reused wherever it is\n+ * needed. {@code CloudWatchMetricPublisher}s are thread-safe, so there should be no need to create multiple instances. Most\n+ * people create and manage the publisher in their inversion-of-control (IoC) container (e.g. Spring/Dagger/Guice).\n+ *\n+ * <p>Note: When your application is finished with the {@code CloudWatchMetricPublisher}, make sure to {@link #close()} it. Your\n+ * inversion-of-control container may handle this for you on JVM shutdown.\n+ *\n+ * <p>See {@link CloudWatchMetricPublisher.Builder} for all available configuration options.\n+ *\n+ * <pre>\n+ *     // Create a CloudWatchMetricPublisher using a custom namespace.\n+ *     MetricPublisher metricPublisher = CloudWatchMetricPublisher.builder()\n+ *                                                                .namespace(\"MyApplication\")\n+ *                                                                .build();\n+ * </pre>\n+ *\n+ * <p><i>Step 3: Collect and Publish Metrics</i>\n+ *\n+ * <p>Create and use a {@link MetricCollector} to collect data about your configured metrics.\n+ *\n+ * <pre>\n+ *     // Call \"myMethod\" and collect metrics about the call.\n+ *     Instant methodCallStartTime = Instant.now();\n+ *     myMethod();\n+ *     Duration methodCallDuration = Duration.between(methodCallStartTime, Instant.now());\n+ *\n+ *     // Write the metrics to the CloudWatchMetricPublisher.\n+ *     MetricCollector metricCollector = MetricCollector.create(\"MyMethodCall\");\n+ *     metricCollector.reportMetric(MyCustomMetrics.MY_METHOD_CALL_COUNT, 1);\n+ *     metricCollector.reportMetric(MyCustomMetrics.MY_METHOD_LATENCY, methodCallDuration);\n+ *     MetricCollection metricCollection = metricCollector.collect();\n+ *\n+ *     metricPublisher.publish(metricCollection);\n+ * </pre>\n+ *\n+ * <p><b>Warning:</b> Make sure the {@link #close()} this publisher when it is done being used to release all resources it\n+ * consumes. Failure to do so will result in possible thread or file descriptor leaks.\n+ */\n+@ThreadSafe\n+@Immutable\n+@SdkPublicApi\n+public final class CloudWatchMetricPublisher implements MetricPublisher {\n+    /**\n+     * The maximum queue size for the internal {@link #executor} that is used to aggregate metric data and upload it to\n+     * CloudWatch. If this value is too high, memory is wasted. If this value is too low, metrics could be dropped.\n+     *\n+     * This value is not currently configurable, because it's unlikely that this is a value that customers should need to modify.\n+     * If customers really need control over this value, we might consider letting them instead configure the\n+     * {@link BlockingQueue} used on the executor. The value here depends on the type of {@code BlockingQueue} in use, and\n+     * we should probably not indirectly couple people to the type of blocking queue we're using.\n+     */\n+    private static final int MAXIMUM_TASK_QUEUE_SIZE = 128;\n+\n+    private static final String DEFAULT_NAMESPACE = \"AwsSdk/JavaSdk2\";\n+    private static final int DEFAULT_MAXIMUM_CALLS_PER_UPLOAD = 10;\n+    private static final Duration DEFAULT_UPLOAD_FREQUENCY = Duration.ofMinutes(1);\n+    private static final Set<SdkMetric<String>> DEFAULT_DIMENSIONS = Stream.of(CoreMetric.SERVICE_ID,\n+                                                                               CoreMetric.OPERATION_NAME)\n+                                                                           .collect(Collectors.toSet());\n+    private static final Set<MetricCategory> DEFAULT_METRIC_CATEGORIES = Stream.of(MetricCategory.DEFAULT,\n+                                                                                   MetricCategory.HTTP_CLIENT)\n+                                                                               .collect(Collectors.toSet());\n+    private static final Set<SdkMetric<?>> DEFAULT_DETAILED_METRICS = Collections.emptySet();\n+\n+    /**\n+     * Whether {@link #close()} should call {@link CloudWatchAsyncClient#close()}. This is false when\n+     * {@link Builder#cloudWatchClient(CloudWatchAsyncClient)} was specified, meaning the customer has to close the client\n+     * themselves.\n+     */\n+    private final boolean closeClientWithPublisher;\n+\n+    /**\n+     * The aggregator that takes {@link MetricCollection}s and converts them into {@link PutMetricDataRequest}s. This aggregator\n+     * is *not* thread safe, so it should only ever be accessed from the {@link #executor}'s thread.\n+     */\n+    private final MetricCollectionAggregator metricAggregator;\n+\n+    /**\n+     * The uploader that takes {@link PutMetricDataRequest}s and sends them to a {@link CloudWatchAsyncClient}.\n+     */\n+    private final MetricUploader metricUploader;\n+\n+    /**\n+     * The executor that executes {@link AggregateMetricsTask}s and {@link UploadMetricsTasks}s.\n+     */\n+    private final ExecutorService executor;\n+\n+    /**\n+     * A scheduled executor that periodically schedules a {@link UploadMetricsTasks} on the {@link #executor} thread. Note: this\n+     * executor should never execute the flush task itself, because that needs access to the {@link #metricAggregator}, and the\n+     * {@code metricAggregator} should only ever be accessed from the {@link #executor} thread.\n+     */\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * The maximum number of {@link PutMetricDataRequest}s that should ever be executed as part of a single\n+     * {@link UploadMetricsTasks}.\n+     */\n+    private final int maximumCallsPerUpload;\n+\n+    private CloudWatchMetricPublisher(Builder builder) {\n+        this.closeClientWithPublisher = resolveCloseClientWithPublisher(builder);\n+        this.metricAggregator = new MetricCollectionAggregator(resolveNamespace(builder),\n+                                                               resolveDimensions(builder),\n+                                                               resolveMetricCategories(builder),\n+                                                               resolveDetailedMetrics(builder));\n+        this.metricUploader = new MetricUploader(resolveClient(builder));\n+        this.maximumCallsPerUpload = resolveMaximumCallsPerUpload(builder);\n+\n+        ThreadFactory threadFactory = new ThreadFactoryBuilder().threadNamePrefix(\"cloud-watch-metric-publisher\").build();\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor(threadFactory);\n+        this.executor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,\n+                                               new ArrayBlockingQueue<>(MAXIMUM_TASK_QUEUE_SIZE),\n+                                               threadFactory);\n+\n+        long flushFrequencyInMillis = resolveUploadFrequency(builder).toMillis();\n+        this.scheduledExecutor.scheduleAtFixedRate(this::flushMetrics,\n+                                                   flushFrequencyInMillis, flushFrequencyInMillis, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private Set<MetricCategory> resolveMetricCategories(Builder builder) {\n+        return builder.metricCategories == null ? DEFAULT_METRIC_CATEGORIES : new HashSet<>(builder.metricCategories);\n+    }\n+\n+    private Set<SdkMetric<?>> resolveDetailedMetrics(Builder builder) {\n+        return builder.detailedMetrics == null ? DEFAULT_DETAILED_METRICS : new HashSet<>(builder.detailedMetrics);\n+    }\n+\n+    private Set<SdkMetric<String>> resolveDimensions(Builder builder) {\n+        return builder.dimensions == null ? DEFAULT_DIMENSIONS : new HashSet<>(builder.dimensions);\n+    }\n+\n+    private boolean resolveCloseClientWithPublisher(Builder builder) {\n+        return builder.client == null;\n+    }\n+\n+    private CloudWatchAsyncClient resolveClient(Builder builder) {\n+        return builder.client == null ? CloudWatchAsyncClient.create() : builder.client;\n+    }\n+\n+    private Duration resolveUploadFrequency(Builder builder) {\n+        return builder.uploadFrequency == null ? DEFAULT_UPLOAD_FREQUENCY : builder.uploadFrequency;\n+    }\n+\n+    private String resolveNamespace(Builder builder) {\n+        return builder.namespace == null ? DEFAULT_NAMESPACE : builder.namespace;\n+    }\n+\n+    private int resolveMaximumCallsPerUpload(Builder builder) {\n+        return builder.maximumCallsPerUpload == null ? DEFAULT_MAXIMUM_CALLS_PER_UPLOAD : builder.maximumCallsPerUpload;\n+    }\n+\n+    @Override\n+    public void publish(MetricCollection metricCollection) {\n+        try {\n+            executor.submit(new AggregateMetricsTask(metricAggregator, metricCollection));\n+        } catch (RejectedExecutionException e) {\n+            METRIC_LOGGER.warn(() -> \"Some AWS SDK client-side metrics have been dropped because an internal executor did not \"\n+                                     + \"accept them. This usually occurs because your publisher has been shut down or you have \"\n+                                     + \"generated too many requests for the publisher to handle in a timely fashion.\", e);\n+        }\n+    }\n+\n+    private void flushMetrics() {\n+        while (true) {", "originalCommit": "6b9e6f6c3d9cc7f640c14346ccb46abd56eca8e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzOTc3MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443039771", "bodyText": "I think we should remove this as we discussed.", "author": "bmaizels", "createdAt": "2020-06-19T20:53:48Z", "path": "metric-publishers/cloudwatch-metric-publisher/src/main/java/software/amazon/awssdk/metrics/publishers/cloudwatch/internal/task/UploadMetricsTasks.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.metrics.publishers.cloudwatch.internal.task;\n+\n+import static software.amazon.awssdk.metrics.publishers.cloudwatch.internal.CloudWatchMetricLogger.METRIC_LOGGER;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.CloudWatchMetricPublisher;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.MetricUploader;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.transform.MetricCollectionAggregator;\n+import software.amazon.awssdk.services.cloudwatch.model.PutMetricDataRequest;\n+\n+/**\n+ * A task that is executed on the {@link CloudWatchMetricPublisher}'s executor to collect requests from a\n+ * {@link MetricCollectionAggregator} and write them to a {@link MetricUploader}.\n+ */\n+@SdkInternalApi\n+public class UploadMetricsTasks implements Runnable {\n+    private final MetricCollectionAggregator collectionAggregator;\n+    private final MetricUploader uploader;\n+    private int maximumRequestsPerFlush;\n+\n+    public UploadMetricsTasks(MetricCollectionAggregator collectionAggregator,\n+                              MetricUploader uploader,\n+                              int maximumRequestsPerFlush) {\n+        this.collectionAggregator = collectionAggregator;\n+        this.uploader = uploader;\n+        this.maximumRequestsPerFlush = maximumRequestsPerFlush;\n+    }\n+\n+    @Override\n+    public void run() {\n+        List<PutMetricDataRequest> allRequests = collectionAggregator.getRequests();\n+        List<PutMetricDataRequest> requests = allRequests;\n+        if (requests.size() > maximumRequestsPerFlush) {\n+            METRIC_LOGGER.warn(() -> \"Maximum AWS SDK client-side metric call count exceeded: \" + allRequests.size() +\n+                                     \" > \" + maximumRequestsPerFlush + \". Some metric requests will be dropped. This occurs when \"\n+                                     + \"the caller has configured too many metrics or too unique of dimensions without an \"\n+                                     + \"associated increase in the maximum-calls-per-upload configured on the publisher.\");\n+\n+            // Randomly pick which requests we intend to keep/drop so that we aren't always dropping the same ones if this happens\n+            // a lot of times in a row.\n+            Collections.shuffle(requests);", "originalCommit": "6b9e6f6c3d9cc7f640c14346ccb46abd56eca8e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NzEyOQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443057129", "bodyText": "I don't think that's what we concluded, but to avoid arguing, I'll just remove it.", "author": "millems", "createdAt": "2020-06-19T21:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzOTc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3MzU2MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443073560", "bodyText": "I think our options are 1) send nothing  2) send as much as we can but undetermined order  3) send as much as we can but determined order   4) send as much as we can but actively shuffle. I think no matter what option we pick the settings need to be changed as this isn't a good situation for the customer. I'm almost leaning towards 1) under the assumption that no data might be better than incomplete/misleading data especially where aggregates are concerned but 2 might be more appropriate because it wouldn't fail all the time necessarily so there may be partial data anyway. Doing 3 or 4 seems like we're saying this is another kind of happy path and I don't think I'm ready to agree with that at this point.", "author": "bmaizels", "createdAt": "2020-06-19T23:07:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzOTc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NDI1MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443074250", "bodyText": "Crazy idea but can we buffer and try and send them in subsequent requests? Obviously the buffer can fill up at which point we really have to drop stuff on the ground, but it would give the system a bit of elasticity to deal with spikes.", "author": "bmaizels", "createdAt": "2020-06-19T23:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzOTc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NDg3MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443074870", "bodyText": "(3) is also quite difficult to implement. (1) could still result in inconsistent values, since previous and future flushes could include data from the 'time bucket' of the dropped values. I think (2) or (4) are both probably fine, from the customer perspective. In that case (2)  might win since it's less code.", "author": "millems", "createdAt": "2020-06-19T23:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzOTc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0NzU2NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443047565", "bodyText": "Not sure about this, seems like an OO smell that we have to put implementation specific logic (reflection at that!) inside an abstract interface. Can we rethink this do you have any other ideas how we can do this without breaking encapsulation/layering?", "author": "bmaizels", "createdAt": "2020-06-19T21:17:59Z", "path": "metric-publishers/cloudwatch-metric-publisher/src/main/java/software/amazon/awssdk/metrics/publishers/cloudwatch/internal/transform/MetricAggregator.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.metrics.publishers.cloudwatch.internal.transform;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.metrics.CoreMetric;\n+import software.amazon.awssdk.metrics.SdkMetric;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.CloudWatchMetricPublisher;\n+import software.amazon.awssdk.services.cloudwatch.model.Dimension;\n+import software.amazon.awssdk.services.cloudwatch.model.MetricDatum;\n+import software.amazon.awssdk.services.cloudwatch.model.StandardUnit;\n+\n+/**\n+ * Used by {@link MetricCollectionAggregator} to aggregate metrics in memory until they are ready to be added to a\n+ * {@link MetricDatum}.\n+ *\n+ * <p>This is either a {@link SummaryMetricAggregator} or a {@link DetailedMetricAggregator}, depending on the configured\n+ * {@link CloudWatchMetricPublisher.Builder#detailedMetrics(Collection)} setting.\n+ */\n+@SdkInternalApi\n+interface MetricAggregator {\n+    /**\n+     * The metric that this aggregator is aggregating. For example, this may be aggregating {@link CoreMetric#API_CALL_DURATION}\n+     * metric values. There may be multiple aggregators for a single type of metric, when their {@link #dimensions()} differ.\n+     */\n+    SdkMetric<?> metric();\n+\n+    /**\n+     * The dimensions associated with the metric values that this aggregator is aggregating. For example, this may be aggregating\n+     * \"S3's putObject\" metrics or \"DynamoDb's listTables\" metrics. The exact metric being aggregated is available via\n+     * {@link #metric()}.\n+     */\n+    List<Dimension> dimensions();\n+\n+    /**\n+     * Get the unit of the {@link #metric()} when it is published to CloudWatch.\n+     */\n+    StandardUnit unit();\n+\n+    /**\n+     * Add the provided metric value to this aggregator.\n+     */\n+    void addMetricValue(double value);\n+\n+    /**\n+     * Execute the provided consumer if this {@code MetricAggregator} is a {@link SummaryMetricAggregator}.\n+     */\n+    default void ifSummary(Consumer<SummaryMetricAggregator> summaryConsumer) {\n+        if (this instanceof SummaryMetricAggregator) {\n+            summaryConsumer.accept((SummaryMetricAggregator) this);\n+        }\n+    }\n+\n+    /**\n+     * Execute the provided consumer if this {@code MetricAggregator} is a {@link DetailedMetricAggregator}.\n+     */\n+    default void ifDetailed(Consumer<DetailedMetricAggregator> detailsConsumer) {\n+        if (this instanceof DetailedMetricAggregator) {\n+            detailsConsumer.accept((DetailedMetricAggregator) this);\n+        }\n+    }", "originalCommit": "6b9e6f6c3d9cc7f640c14346ccb46abd56eca8e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NzIyNw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443057227", "bodyText": "We talked about this already on the call. Let's discuss offline.", "author": "millems", "createdAt": "2020-06-19T21:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0NzU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MjIxMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443062213", "bodyText": "Summarizing here for posterity:\nThe alternatives are: polymorphism, a visitor and what I did.\nThe first was the worst in terms of 'separation of concerns', because it leaked the cloudwatch concerns of limits and request building to something that was on the 'aggregate' path, which to this point is cloudwatch agnostic.\nVisitor is the 'standard' solution for the double-dispatch needed here, but I didn't like it because creating an anonymous class too greatly impacted the readability of the callsite with a lot of boilerplate and distraction.\nWhat I did was a compromise on the visitor solution, because it allowed me to use lambdas, which avoided the boilerplate issue and avoided needing to define a 'visitor' class.", "author": "millems", "createdAt": "2020-06-19T22:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0NzU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2Nzk3NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443067975", "bodyText": "Okay fair enough looks like you gave a few alternatives there some serious consideration! If I had done it I might have gone with the visitor pattern, but I don't think we should block on this concern given these are internal classes.", "author": "bmaizels", "createdAt": "2020-06-19T22:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0NzU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MDM5Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443050393", "bodyText": "Do you think it's possible to test the shutdown behavior? That's the part of this class that actually worries me the most.", "author": "bmaizels", "createdAt": "2020-06-19T21:27:40Z", "path": "metric-publishers/cloudwatch-metric-publisher/src/test/java/software/amazon/awssdk/metrics/publishers/cloudwatch/CloudWatchMetricPublisherTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.metrics.publishers.cloudwatch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.never;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ThreadLocalRandom;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import software.amazon.awssdk.core.metrics.CoreMetric;\n+import software.amazon.awssdk.http.HttpMetric;\n+import software.amazon.awssdk.metrics.MetricCategory;\n+import software.amazon.awssdk.metrics.MetricCollector;\n+import software.amazon.awssdk.metrics.SdkMetric;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.internal.transform.MetricCollectionAggregator;\n+import software.amazon.awssdk.services.cloudwatch.CloudWatchAsyncClient;\n+import software.amazon.awssdk.services.cloudwatch.model.Dimension;\n+import software.amazon.awssdk.services.cloudwatch.model.MetricDatum;\n+import software.amazon.awssdk.services.cloudwatch.model.PutMetricDataRequest;\n+import software.amazon.awssdk.services.cloudwatch.model.PutMetricDataResponse;\n+\n+public class CloudWatchMetricPublisherTest {", "originalCommit": "6b9e6f6c3d9cc7f640c14346ccb46abd56eca8e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODI0NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443058244", "bodyText": "What specific part worries you? All of the tests currently rely on the close behavior flushing out the executor pool. Almost every test in this class would fail if it didn't work. The only thing we don't test is the timeout behavior, which would require a non-public constructor.", "author": "millems", "createdAt": "2020-06-19T21:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MDM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2ODMwMQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443068301", "bodyText": "What happens if a thread gets stuck? That'd be the timeout case I guess. What happens if the thread is interrupted during shutdown?", "author": "bmaizels", "createdAt": "2020-06-19T22:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MDM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2OTE3Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443069172", "bodyText": "+1, the interrupted case we can test. Timeout case is definitely harder.", "author": "millems", "createdAt": "2020-06-19T22:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MDM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTEwNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443051105", "bodyText": "Can we have tests that probe the boundary conditions to do with upload limits, like what happens if the publish is on the boundary, just over and just under kinda thing?", "author": "bmaizels", "createdAt": "2020-06-19T21:30:16Z", "path": "metric-publishers/cloudwatch-metric-publisher/src/test/java/software/amazon/awssdk/metrics/publishers/cloudwatch/internal/transform/MetricCollectionAggregatorTest.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.metrics.publishers.cloudwatch.internal.transform;\n+\n+import static java.time.temporal.ChronoUnit.HOURS;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import software.amazon.awssdk.core.metrics.CoreMetric;\n+import software.amazon.awssdk.http.HttpMetric;\n+import software.amazon.awssdk.metrics.MetricCategory;\n+import software.amazon.awssdk.metrics.MetricCollection;\n+import software.amazon.awssdk.metrics.MetricCollector;\n+import software.amazon.awssdk.metrics.SdkMetric;\n+import software.amazon.awssdk.metrics.publishers.cloudwatch.FixedTimeMetricCollection;\n+import software.amazon.awssdk.services.cloudwatch.model.StatisticSet;\n+\n+public class MetricCollectionAggregatorTest {\n+    private static final String DEFAULT_NAMESPACE = \"namespace\";\n+    private static final Set<SdkMetric<String>> DEFAULT_DIMENSIONS = Stream.of(CoreMetric.SERVICE_ID, CoreMetric.OPERATION_NAME)\n+                                                                           .collect(Collectors.toSet());\n+    private static final Set<MetricCategory> DEFAULT_CATEGORIES = Collections.singleton(MetricCategory.HTTP_CLIENT);\n+    private static final Set<SdkMetric<?>> DEFAULT_DETAILED_METRICS = Collections.emptySet();\n+\n+    @Test\n+    public void maximumRequestsIsHonored() {\n+        assertThat(aggregatorWithUniqueMetricsAdded(MetricCollectionAggregator.MAX_METRIC_DATA_PER_REQUEST).getRequests())\n+            .hasSize(1);\n+        assertThat(aggregatorWithUniqueMetricsAdded(MetricCollectionAggregator.MAX_METRIC_DATA_PER_REQUEST + 1).getRequests())\n+            .hasSize(2);\n+    }\n+\n+    @Test\n+    public void maximumMetricValuesIsHonored() {\n+        assertThat(aggregatorWithUniqueValuesAdded(HttpMetric.MAX_CONCURRENCY,\n+                                                   MetricCollectionAggregator.MAX_VALUES_PER_REQUEST).getRequests())\n+            .hasSize(1);\n+        assertThat(aggregatorWithUniqueValuesAdded(HttpMetric.MAX_CONCURRENCY,\n+                                                   MetricCollectionAggregator.MAX_VALUES_PER_REQUEST + 1).getRequests())\n+            .hasSize(2);\n+    }\n+\n+    @Test\n+    public void dimensionOrderInCollectionDoesNotMatter() {\n+        MetricCollectionAggregator aggregator = defaultAggregator();\n+\n+        MetricCollector collector = collector();\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(CoreMetric.OPERATION_NAME, \"OperationName\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 1);\n+        aggregator.addCollection(collectToFixedTime(collector));\n+\n+        collector = collector();\n+        collector.reportMetric(CoreMetric.OPERATION_NAME, \"OperationName\");\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 2);\n+        aggregator.addCollection(collectToFixedTime(collector));\n+\n+        assertThat(aggregator.getRequests()).hasOnlyOneElementSatisfying(request -> {\n+            assertThat(request.metricData()).hasSize(1);\n+        });\n+    }\n+\n+    @Test\n+    public void metricsAreAggregatedByDimensionMetricAndTime() {\n+        MetricCollectionAggregator aggregator = defaultAggregator();\n+\n+        MetricCollector collector = collector();\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 1);\n+        aggregator.addCollection(collectToFixedTimeBucket(collector, 0));\n+\n+        collector = collector();\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 2);\n+        aggregator.addCollection(collectToFixedTimeBucket(collector, 0));\n+\n+        collector = collector();\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(CoreMetric.OPERATION_NAME, \"OperationName\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 3);\n+        collector.reportMetric(HttpMetric.AVAILABLE_CONCURRENCY, 4);\n+        aggregator.addCollection(collectToFixedTimeBucket(collector, 0));\n+\n+        collector = collector();\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(CoreMetric.OPERATION_NAME, \"OperationName\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 5);\n+        aggregator.addCollection(collectToFixedTimeBucket(collector, 1));\n+\n+        assertThat(aggregator.getRequests()).hasOnlyOneElementSatisfying(request -> {\n+            assertThat(request.namespace()).isEqualTo(DEFAULT_NAMESPACE);\n+            assertThat(request.metricData()).hasSize(5).allSatisfy(data -> {\n+                assertThat(data.values()).isEmpty();\n+                assertThat(data.counts()).isEmpty();\n+                if (data.dimensions().isEmpty()) {\n+                    assertThat(data.metricName()).isEqualTo(HttpMetric.MAX_CONCURRENCY.name());\n+                    assertThat(data.statisticValues().sampleCount()).isEqualTo(1);\n+                    assertThat(data.statisticValues().sum()).isEqualTo(1);\n+                } else if (data.dimensions().size() == 1) {\n+                    assertThat(data.metricName()).isEqualTo(HttpMetric.MAX_CONCURRENCY.name());\n+                    assertThat(data.statisticValues().sampleCount()).isEqualTo(1);\n+                    assertThat(data.statisticValues().sum()).isEqualTo(2);\n+                } else {\n+                    assertThat(data.dimensions().size()).isEqualTo(2);\n+                    if (data.timestamp().equals(Instant.EPOCH)) {\n+                        // Time bucket 0\n+                        if (data.metricName().equals(HttpMetric.MAX_CONCURRENCY.name())) {\n+                            assertThat(data.statisticValues().sampleCount()).isEqualTo(1);\n+                            assertThat(data.statisticValues().sum()).isEqualTo(3);\n+                        } else {\n+                            assertThat(data.metricName()).isEqualTo(HttpMetric.AVAILABLE_CONCURRENCY.name());\n+                            assertThat(data.statisticValues().sampleCount()).isEqualTo(1);\n+                            assertThat(data.statisticValues().sum()).isEqualTo(4);\n+                        }\n+                    } else {\n+                        // Time bucket 1\n+                        assertThat(data.metricName()).isEqualTo(HttpMetric.MAX_CONCURRENCY.name());\n+                        assertThat(data.statisticValues().sampleCount()).isEqualTo(1);\n+                        assertThat(data.statisticValues().sum()).isEqualTo(5);\n+                    }\n+                }\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void metricSummariesAreCorrectWithValuesInSameCollector() {\n+        MetricCollectionAggregator aggregator = defaultAggregator();\n+        MetricCollector collector = collector();\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 2);\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 1);\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 4);\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 4);\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 3);\n+        aggregator.addCollection(collectToFixedTime(collector));\n+\n+        assertThat(aggregator.getRequests()).hasOnlyOneElementSatisfying(request -> {\n+            assertThat(request.namespace()).isEqualTo(DEFAULT_NAMESPACE);\n+            assertThat(request.metricData()).hasOnlyOneElementSatisfying(metricData -> {\n+                assertThat(metricData.dimensions()).hasOnlyOneElementSatisfying(dimension -> {\n+                    assertThat(dimension.name()).isEqualTo(CoreMetric.SERVICE_ID.name());\n+                    assertThat(dimension.value()).isEqualTo(\"ServiceId\");\n+                });\n+                assertThat(metricData.values()).isEmpty();\n+                assertThat(metricData.counts()).isEmpty();\n+                assertThat(metricData.statisticValues()).isEqualTo(StatisticSet.builder()\n+                                                                               .minimum(1.0)\n+                                                                               .maximum(4.0)\n+                                                                               .sum(14.0)\n+                                                                               .sampleCount(5.0)\n+                                                                               .build());\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void metricSummariesAreCorrectWithValuesInDifferentCollector() {\n+        MetricCollectionAggregator aggregator = defaultAggregator();\n+\n+        MetricCollector collector = collector();\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 2);\n+        aggregator.addCollection(collectToFixedTime(collector));\n+\n+        collector = collector();\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 1);\n+        aggregator.addCollection(collectToFixedTime(collector));\n+\n+        collector = collector();\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 4);\n+        aggregator.addCollection(collectToFixedTime(collector));\n+\n+        collector = collector();\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 4);\n+        aggregator.addCollection(collectToFixedTime(collector));\n+\n+        collector = collector();\n+        collector.reportMetric(CoreMetric.SERVICE_ID, \"ServiceId\");\n+        collector.reportMetric(HttpMetric.MAX_CONCURRENCY, 3);\n+        aggregator.addCollection(collectToFixedTime(collector));\n+\n+        assertThat(aggregator.getRequests()).hasOnlyOneElementSatisfying(request -> {\n+            assertThat(request.namespace()).isEqualTo(DEFAULT_NAMESPACE);\n+            assertThat(request.metricData()).hasOnlyOneElementSatisfying(metricData -> {\n+                assertThat(metricData.dimensions()).hasOnlyOneElementSatisfying(dimension -> {\n+                    assertThat(dimension.name()).isEqualTo(CoreMetric.SERVICE_ID.name());\n+                    assertThat(dimension.value()).isEqualTo(\"ServiceId\");\n+                });\n+                assertThat(metricData.values()).isEmpty();\n+                assertThat(metricData.counts()).isEmpty();\n+                assertThat(metricData.statisticValues()).isEqualTo(StatisticSet.builder()\n+                                                                               .minimum(1.0)\n+                                                                               .maximum(4.0)\n+                                                                               .sum(14.0)\n+                                                                               .sampleCount(5.0)\n+                                                                               .build());\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void detailedMetricsAreCorrect() {", "originalCommit": "6b9e6f6c3d9cc7f640c14346ccb46abd56eca8e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODc3MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443058770", "bodyText": "How is that different than MetricCollectionAggregatorTest#maximumRequestsIsHonored and MetricCollectionAggregatorTest#maximumMetricValuesIsHonored?", "author": "millems", "createdAt": "2020-06-19T21:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MjY0NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443062644", "bodyText": "Oh yeah true, do you think we should be testing the aggregation/values published in those tests as well as the counts?", "author": "bmaizels", "createdAt": "2020-06-19T22:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2OTMzMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1907#discussion_r443069330", "bodyText": "I'll try it out. I don't think that's covered elsewhere.", "author": "millems", "createdAt": "2020-06-19T22:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTEwNQ=="}], "type": "inlineReview"}, {"oid": "88e1b072fff9e7833513ff9077bdac2b02ba6754", "url": "https://github.com/aws/aws-sdk-java-v2/commit/88e1b072fff9e7833513ff9077bdac2b02ba6754", "message": "Add CloudWatchMetricPublisher, a MetricPublisher implementation that uploads metric data to CloudWatch.", "committedDate": "2020-06-19T23:50:54Z", "type": "commit"}, {"oid": "88e1b072fff9e7833513ff9077bdac2b02ba6754", "url": "https://github.com/aws/aws-sdk-java-v2/commit/88e1b072fff9e7833513ff9077bdac2b02ba6754", "message": "Add CloudWatchMetricPublisher, a MetricPublisher implementation that uploads metric data to CloudWatch.", "committedDate": "2020-06-19T23:50:54Z", "type": "forcePushed"}]}