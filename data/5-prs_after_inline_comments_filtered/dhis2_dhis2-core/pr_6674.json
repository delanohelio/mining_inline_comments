{"pr_number": 6674, "pr_title": "fix: Updated the Converter class; Fixed failing tests", "pr_createdAt": "2020-11-15T14:47:18Z", "pr_url": "https://github.com/dhis2/dhis2-core/pull/6674", "timeline": [{"oid": "93ecdcce1df3b6987da6a0fde26dc6a2af4b02ef", "url": "https://github.com/dhis2/dhis2-core/commit/93ecdcce1df3b6987da6a0fde26dc6a2af4b02ef", "message": "Updated the Converter class; Fixed failing tests", "committedDate": "2020-11-15T14:43:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc5MDE0NQ==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r523790145", "bodyText": "Maybe change import collapse param? don't need to collapse into * here", "author": "mortenoh", "createdAt": "2020-11-15T17:47:04Z", "path": "dhis-2/dhis-services/dhis-service-tracker/src/test/java/org/hisp/dhis/tracker/converter/RelationshipTrackerConverterServiceTest.java", "diffHunk": "@@ -55,7 +55,7 @@\n import java.util.List;\n \n import static junit.framework.TestCase.assertNotNull;\n-import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.*;", "originalCommit": "93ecdcce1df3b6987da6a0fde26dc6a2af4b02ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed", "url": "https://github.com/dhis2/dhis2-core/commit/c3f11e59a52bb38b78c029df4d75d05fa8db08ed", "message": "expand import for Assert.*", "committedDate": "2020-11-16T07:58:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExOTM1MQ==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524119351", "bodyText": "updateEnrollmentReferences and enrollment.setNotes seem to happen only in the enrollments that are in the payload as a separate entity.\nIf the enrollments are inside a TEI these 2 functions are not called.\nIs this correct?", "author": "enricocolasante", "createdAt": "2020-11-16T10:56:23Z", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()", "originalCommit": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5OTIyNw==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524999227", "bodyText": "You are absolutely right. I moved the note-updates to the for-loops that interate over the entire collections.", "author": "stian-sandvold", "createdAt": "2020-11-17T09:18:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExOTM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExOTY4Mg==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524119682", "bodyText": "Some as enrollments comment", "author": "enricocolasante", "createdAt": "2020-11-16T10:56:40Z", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )", "originalCommit": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5OTM5Mw==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524999393", "bodyText": "same solution as previous", "author": "stian-sandvold", "createdAt": "2020-11-17T09:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExOTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyMDM2MA==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524120360", "bodyText": "We already have a loop around enrollmentHashMap.values(), can we put this logic there?", "author": "enricocolasante", "createdAt": "2020-11-16T10:57:18Z", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()", "originalCommit": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMTU1OA==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525001558", "bodyText": "This should/will be moved to a preprocessor soon, but I will move them into the loop for now :)", "author": "stian-sandvold", "createdAt": "2020-11-17T09:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyMDM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyMDUyMg==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524120522", "bodyText": "Same as enrollments", "author": "enricocolasante", "createdAt": "2020-11-16T10:57:28Z", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()\n+            .forEach( enrollment -> enrollment\n+                .setNotes(\n+                    enrollment.getNotes().stream()\n+                        .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                        .collect( Collectors.toList() )\n+                ) );\n+\n+        eventHashMap.values()", "originalCommit": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMTU3MQ==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525001571", "bodyText": "This should/will be moved to a preprocessor soon, but I will move them into the loop for now :)", "author": "stian-sandvold", "createdAt": "2020-11-17T09:22:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyMDUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyNDYwNg==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524124606", "bodyText": "If 2 identical relationships without UID are in the payload, after updating the reference I think that the distinct will not recognise them as equals.", "author": "enricocolasante", "createdAt": "2020-11-16T11:01:11Z", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()\n+            .forEach( enrollment -> enrollment\n+                .setNotes(\n+                    enrollment.getNotes().stream()\n+                        .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                        .collect( Collectors.toList() )\n+                ) );\n+\n+        eventHashMap.values()\n+            .forEach(\n+                event -> event.setNotes( event.getNotes().stream()\n+                    .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                    .collect( Collectors.toList() )\n+                ) );\n+\n+        return TrackerBundleParams.builder()\n+            .trackedEntities( new ArrayList<>( trackedEntityMap.values() ) )\n+            .enrollments( new ArrayList<>( enrollmentHashMap.values() ) )\n+            .events( new ArrayList<>( eventHashMap.values() ) )\n+            .relationships( relationshipHashMap.values().stream()", "originalCommit": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMzMyMg==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525003322", "bodyText": "You are right :) This is solved by Luciano's changes anyway, so I will just remove it!", "author": "stian-sandvold", "createdAt": "2020-11-17T09:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyNDYwNg=="}], "type": "inlineReview"}, {"oid": "efac254e3ce0af93a656b68a1ab97f42f6af735d", "url": "https://github.com/dhis2/dhis2-core/commit/efac254e3ce0af93a656b68a1ab97f42f6af735d", "message": "Fixed code based on initial feedback", "committedDate": "2020-11-17T09:27:41Z", "type": "commit"}, {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c", "url": "https://github.com/dhis2/dhis2-core/commit/1adca824b3dd60095d1350829836a0463e1d9d8c", "message": "Merge branch 'NTI-converter-update' of github.com:dhis2/dhis2-core into NTI-converter-update", "committedDate": "2020-11-17T09:31:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjI0MQ==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525056241", "bodyText": "If event.getEvent() is null, what is going to happen?", "author": "enricocolasante", "createdAt": "2020-11-17T10:44:04Z", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );", "originalCommit": "1adca824b3dd60095d1350829836a0463e1d9d8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1OTI5NQ==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525059295", "bodyText": "The extractEvents method will update references, which will also generate UID if getEvent is null. So at this point, it can never be null :)", "author": "stian-sandvold", "createdAt": "2020-11-17T10:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjMzMw==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525056333", "bodyText": "We are updating references only for the events that are coming as a separate entity in the payload.\nIf we have an event inside an enrollment and this event has no uid, at some point the validation will fail.\nIs this expected?", "author": "enricocolasante", "createdAt": "2020-11-17T10:44:11Z", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        Set<Relationship> relationships = new HashSet<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n-        {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            enrollment.setNotes( enrollment.getNotes().stream()\n+                .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() )\n+            );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )", "originalCommit": "1adca824b3dd60095d1350829836a0463e1d9d8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA2MDQ0NA==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525060444", "bodyText": "The references are updated within \"extractEvents\", so this should not be a problem :)", "author": "stian-sandvold", "createdAt": "2020-11-17T10:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjUyNg==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525056526", "bodyText": "Same as events", "author": "enricocolasante", "createdAt": "2020-11-17T10:44:30Z", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );", "originalCommit": "1adca824b3dd60095d1350829836a0463e1d9d8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA2MDU3NA==", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525060574", "bodyText": "Same as events :)", "author": "stian-sandvold", "createdAt": "2020-11-17T10:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjUyNg=="}], "type": "inlineReview"}]}