{"pr_number": 5871, "pr_title": "chore: Refactoring of DefaultAnalyticsService [DHIS2-9212]", "pr_createdAt": "2020-07-31T07:59:20Z", "pr_url": "https://github.com/dhis2/dhis2-core/pull/5871", "timeline": [{"oid": "29b5f0ee7e08f5a1a896fea3552db8ff1e07c639", "url": "https://github.com/dhis2/dhis2-core/commit/29b5f0ee7e08f5a1a896fea3552db8ff1e07c639", "message": "chore: Refactoring of DefaultAnalyticsService [DHIS2-9212]\n\nNo changes were mande in the flow, rules or order of execution. The existing unit tests were just adapted to support the new classes. The goal was to make the service more decoupled, focused and testable.", "committedDate": "2020-07-31T07:58:24Z", "type": "commit"}, {"oid": "46a7de6b2488778d2c248e09ab6b84dff3e39142", "url": "https://github.com/dhis2/dhis2-core/commit/46a7de6b2488778d2c248e09ab6b84dff3e39142", "message": "chore: Adding missing comments [DHIS2-9212]", "committedDate": "2020-07-31T08:20:44Z", "type": "commit"}, {"oid": "1c656fcb31616a11eeee7e18ae96874dd5cb7bb7", "url": "https://github.com/dhis2/dhis2-core/commit/1c656fcb31616a11eeee7e18ae96874dd5cb7bb7", "message": "chore: Fixing only the critical Sonar issues [DHIS2-9212]\n\nFixing only the minimal and critial code smells pointed by Sonar, so we minimize impact in the code extracted.", "committedDate": "2020-07-31T11:44:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMDIyNw==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464210227", "bodyText": "I would consider removing the \"Internal\" wording from the method name, since I think it made sense when part of a larger class but in this new Aggregator can be confusing.", "author": "luciano-fiandesio", "createdAt": "2020-08-03T06:05:49Z", "path": "dhis-2/dhis-services/dhis-service-analytics/src/main/java/org/hisp/dhis/analytics/data/handling/DataAggregator.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package org.hisp.dhis.analytics.data.handling;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.hisp.dhis.analytics.DataQueryParams.DX_INDEX;\n+import static org.hisp.dhis.analytics.DataQueryParams.VALUE_ID;\n+import static org.hisp.dhis.analytics.DataQueryParams.newBuilder;\n+import static org.hisp.dhis.analytics.ProcessingHint.SINGLE_INDICATOR_REPORTING_RATE_FILTER_ITEM;\n+import static org.hisp.dhis.analytics.SortOrder.ASC;\n+import static org.hisp.dhis.common.DimensionalObject.DATA_X_DIM_ID;\n+\n+import javax.annotation.PostConstruct;\n+\n+import org.hisp.dhis.analytics.DataQueryParams;\n+import org.hisp.dhis.common.DimensionalObject;\n+import org.hisp.dhis.common.Grid;\n+import org.hisp.dhis.system.grid.ListGrid;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * Class responsible for aggregating all necessary data, provided by the\n+ * handlers, into the Grid object\n+ */\n+@Component\n+public class DataAggregator\n+{\n+\n+    private final HeaderHandler headerHandler;\n+\n+    private final MetadataHandler metaDataHandler;\n+\n+    private final DataHandler dataHandler;\n+\n+    public DataAggregator( HeaderHandler headerHandler, MetadataHandler metadataHandler, DataHandler dataHandler )\n+    {\n+        checkNotNull( headerHandler );\n+        checkNotNull( metadataHandler );\n+        checkNotNull( dataHandler );\n+\n+        this.headerHandler = headerHandler;\n+        this.metaDataHandler = metadataHandler;\n+        this.dataHandler = dataHandler;\n+    }\n+\n+    /**\n+     * Returns a grid with aggregated data.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a grid with aggregated data.\n+     */\n+    public Grid getAggregatedDataValueGridInternal( DataQueryParams params )", "originalCommit": "1c656fcb31616a11eeee7e18ae96874dd5cb7bb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIzOTcwMQ==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464239701", "bodyText": "Yes, I can do it", "author": "maikelarabori", "createdAt": "2020-08-03T07:29:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMDIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMjU2NQ==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r465132565", "bodyText": "Done", "author": "maikelarabori", "createdAt": "2020-08-04T15:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMDIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMDgwMw==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464210803", "bodyText": "Remove @param(s) or add description for the arguments", "author": "luciano-fiandesio", "createdAt": "2020-08-03T06:07:54Z", "path": "dhis-2/dhis-services/dhis-service-analytics/src/main/java/org/hisp/dhis/analytics/data/handling/DataHandler.java", "diffHunk": "@@ -0,0 +1,1161 @@\n+package org.hisp.dhis.analytics.data.handling;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static java.lang.Math.min;\n+import static java.util.Collections.singletonList;\n+import static org.apache.commons.collections4.CollectionUtils.isEmpty;\n+import static org.apache.commons.lang3.ArrayUtils.remove;\n+import static org.apache.commons.lang3.StringUtils.join;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.COUNT;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.SUM;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.DATA_VALUE;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.ORG_UNIT_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.VALIDATION_RESULT;\n+import static org.hisp.dhis.analytics.DataQueryParams.COMPLETENESS_DIMENSION_TYPES;\n+import static org.hisp.dhis.analytics.DataQueryParams.DISPLAY_NAME_DATA_X;\n+import static org.hisp.dhis.analytics.DataQueryParams.DX_INDEX;\n+import static org.hisp.dhis.analytics.DataQueryParams.NUMERATOR_DENOMINATOR_PROPERTIES_COUNT;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationDimensionalItemValueMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationOrgUnitGroupCountMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.newBuilder;\n+import static org.hisp.dhis.analytics.DimensionItem.asItemKey;\n+import static org.hisp.dhis.analytics.DimensionItem.getItemIdentifiers;\n+import static org.hisp.dhis.analytics.DimensionItem.getOrganisationUnitItem;\n+import static org.hisp.dhis.analytics.DimensionItem.getPeriodItem;\n+import static org.hisp.dhis.analytics.OutputFormat.ANALYTICS;\n+import static org.hisp.dhis.analytics.event.EventQueryParams.fromDataQueryParams;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.convertDxToOperand;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.findDimensionalItems;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getDoubleMap;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValue;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValueObject;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.hasPeriod;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.isPeriodInPeriods;\n+import static org.hisp.dhis.analytics.util.PeriodOffsetUtils.getPeriodOffsetRow;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT_OPERAND;\n+import static org.hisp.dhis.common.DataDimensionItemType.INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_ATTRIBUTE;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.VALIDATION_RULE;\n+import static org.hisp.dhis.common.DimensionType.ATTRIBUTE_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.CATEGORY_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.DATA_X;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT_GROUP;\n+import static org.hisp.dhis.common.DimensionalObject.ATTRIBUTEOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.CATEGORYOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DATA_X_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DIMENSION_SEP;\n+import static org.hisp.dhis.common.DimensionalObject.ORGUNIT_GROUP_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.PERIOD_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.asTypedList;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.convertToDimItemValueMap;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getAttributeOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getCategoryOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDataElements;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDimensionItem;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.replaceOperandTotalsWithDataElements;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS_ON_TIME;\n+import static org.hisp.dhis.common.ReportingRateMetric.EXPECTED_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.REPORTING_RATE_ON_TIME;\n+import static org.hisp.dhis.commons.util.DebugUtils.getStackTrace;\n+import static org.hisp.dhis.commons.util.SystemUtils.getCpuCores;\n+import static org.hisp.dhis.dataelement.DataElementOperand.TotalType.values;\n+import static org.hisp.dhis.period.DailyPeriodType.NAME;\n+import static org.hisp.dhis.period.PeriodType.getPeriodFromIsoString;\n+import static org.hisp.dhis.period.PeriodType.getPeriodTypeFromIsoString;\n+import static org.hisp.dhis.setting.SettingKey.ANALYTICS_MAX_LIMIT;\n+import static org.hisp.dhis.setting.SettingKey.DATABASE_SERVER_CPUS;\n+import static org.hisp.dhis.system.util.MathUtils.getRounded;\n+import static org.hisp.dhis.system.util.MathUtils.getWithin;\n+import static org.hisp.dhis.system.util.MathUtils.isZero;\n+import static org.hisp.dhis.util.ObjectUtils.firstNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.hisp.dhis.analytics.AnalyticsManager;\n+import org.hisp.dhis.analytics.AnalyticsTableType;\n+import org.hisp.dhis.analytics.DataQueryGroups;\n+import org.hisp.dhis.analytics.DataQueryParams;\n+import org.hisp.dhis.analytics.DimensionItem;\n+import org.hisp.dhis.analytics.QueryPlanner;\n+import org.hisp.dhis.analytics.QueryPlannerParams;\n+import org.hisp.dhis.analytics.QueryValidator;\n+import org.hisp.dhis.analytics.RawAnalyticsManager;\n+import org.hisp.dhis.analytics.event.EventAnalyticsService;\n+import org.hisp.dhis.analytics.event.EventQueryParams;\n+import org.hisp.dhis.analytics.resolver.ExpressionResolver;\n+import org.hisp.dhis.common.BaseDimensionalObject;\n+import org.hisp.dhis.common.DimensionItemObjectValue;\n+import org.hisp.dhis.common.DimensionalItemObject;\n+import org.hisp.dhis.common.DimensionalObject;\n+import org.hisp.dhis.common.Grid;\n+import org.hisp.dhis.common.ReportingRateMetric;\n+import org.hisp.dhis.constant.Constant;\n+import org.hisp.dhis.constant.ConstantService;\n+import org.hisp.dhis.dataelement.DataElementOperand;\n+import org.hisp.dhis.dataelement.DataElementOperand.TotalType;\n+import org.hisp.dhis.expression.ExpressionService;\n+import org.hisp.dhis.indicator.Indicator;\n+import org.hisp.dhis.indicator.IndicatorValue;\n+import org.hisp.dhis.organisationunit.OrganisationUnit;\n+import org.hisp.dhis.organisationunit.OrganisationUnitGroup;\n+import org.hisp.dhis.organisationunit.OrganisationUnitService;\n+import org.hisp.dhis.period.Period;\n+import org.hisp.dhis.period.PeriodType;\n+import org.hisp.dhis.setting.SystemSettingManager;\n+import org.hisp.dhis.util.Timer;\n+import org.springframework.stereotype.Component;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * This component is responsible for handling and retrieving data based on the\n+ * input provided to the public methods. The main goal is to correctly populate\n+ * the data into the Grid object.\n+ */\n+@Slf4j\n+@Component\n+public class DataHandler\n+{\n+\n+    private static final int MAX_QUERIES = 8;\n+\n+    private static final int PERCENT = 100;\n+\n+    private final EventAnalyticsService eventAnalyticsService;\n+\n+    private final RawAnalyticsManager rawAnalyticsManager;\n+\n+    private final ConstantService constantService;\n+\n+    private final ExpressionResolver resolver;\n+\n+    private final ExpressionService expressionService;\n+\n+    private final QueryPlanner queryPlanner;\n+\n+    private final QueryValidator queryValidator;\n+\n+    private final SystemSettingManager systemSettingManager;\n+\n+    private final AnalyticsManager analyticsManager;\n+\n+    private final OrganisationUnitService organisationUnitService;\n+\n+    private DataAggregator dataAggregator;\n+\n+    public DataHandler( EventAnalyticsService eventAnalyticsService, RawAnalyticsManager rawAnalyticsManager,\n+        ConstantService constantService, ExpressionResolver resolver, ExpressionService expressionService,\n+        QueryPlanner queryPlanner, QueryValidator queryValidator, SystemSettingManager systemSettingManager,\n+        AnalyticsManager analyticsManager, OrganisationUnitService organisationUnitService )\n+    {\n+        checkNotNull( eventAnalyticsService );\n+        checkNotNull( rawAnalyticsManager );\n+        checkNotNull( constantService );\n+        checkNotNull( resolver );\n+        checkNotNull( expressionService );\n+        checkNotNull( queryPlanner );\n+        checkNotNull( queryValidator );\n+        checkNotNull( systemSettingManager );\n+        checkNotNull( analyticsManager );\n+        checkNotNull( organisationUnitService );\n+\n+        this.eventAnalyticsService = eventAnalyticsService;\n+        this.rawAnalyticsManager = rawAnalyticsManager;\n+        this.constantService = constantService;\n+        this.resolver = resolver;\n+        this.expressionService = expressionService;\n+        this.queryPlanner = queryPlanner;\n+        this.queryValidator = queryValidator;\n+        this.systemSettingManager = systemSettingManager;\n+        this.analyticsManager = analyticsManager;\n+        this.organisationUnitService = organisationUnitService;\n+    }\n+\n+    /**\n+     * Adds indicator values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getIndicators().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( INDICATOR )\n+                .withIncludeNumDen( false ).build();\n+\n+            List<Indicator> indicators = asTypedList( dataSourceParams.getIndicators() );\n+\n+            List<Period> filterPeriods = dataSourceParams.getTypedFilterPeriods();\n+\n+            Map<String, Constant> constantMap = constantService.getConstantMap();\n+\n+            // -----------------------------------------------------------------\n+            // Get indicator values\n+            // -----------------------------------------------------------------\n+\n+            Map<String, Map<String, Integer>> permutationOrgUnitTargetMap = getOrgUnitTargetMap( dataSourceParams,\n+                indicators );\n+\n+            List<List<DimensionItem>> dimensionItemPermutations = dataSourceParams.getDimensionItemPermutations();\n+\n+            Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap = getPermutationDimensionItemValueMap(\n+                dataSourceParams );\n+\n+            handleEmptyDimensionItemPermutations( dimensionItemPermutations );\n+\n+            for ( Indicator indicator : indicators )\n+            {\n+                for ( List<DimensionItem> dimensionItems : dimensionItemPermutations )\n+                {\n+                    IndicatorValue value = getIndicatorValue( filterPeriods, constantMap, permutationOrgUnitTargetMap,\n+                        permutationDimensionItemValueMap, indicator, dimensionItems );\n+\n+                    addIndicatorValuesToGrid( params, grid, dataSourceParams, indicator, dimensionItems, value );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Based on the given Indicator plus additional parameters, this method will\n+     * find the respective IndicatorValue.\n+     * \n+     * @param filterPeriods", "originalCommit": "1c656fcb31616a11eeee7e18ae96874dd5cb7bb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMjYwMw==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r465132603", "bodyText": "Done", "author": "maikelarabori", "createdAt": "2020-08-04T15:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMDgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMDkzMA==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464210930", "bodyText": "can we use a primitive (int) here?", "author": "luciano-fiandesio", "createdAt": "2020-08-03T06:08:30Z", "path": "dhis-2/dhis-services/dhis-service-analytics/src/main/java/org/hisp/dhis/analytics/data/handling/DataHandler.java", "diffHunk": "@@ -0,0 +1,1161 @@\n+package org.hisp.dhis.analytics.data.handling;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static java.lang.Math.min;\n+import static java.util.Collections.singletonList;\n+import static org.apache.commons.collections4.CollectionUtils.isEmpty;\n+import static org.apache.commons.lang3.ArrayUtils.remove;\n+import static org.apache.commons.lang3.StringUtils.join;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.COUNT;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.SUM;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.DATA_VALUE;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.ORG_UNIT_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.VALIDATION_RESULT;\n+import static org.hisp.dhis.analytics.DataQueryParams.COMPLETENESS_DIMENSION_TYPES;\n+import static org.hisp.dhis.analytics.DataQueryParams.DISPLAY_NAME_DATA_X;\n+import static org.hisp.dhis.analytics.DataQueryParams.DX_INDEX;\n+import static org.hisp.dhis.analytics.DataQueryParams.NUMERATOR_DENOMINATOR_PROPERTIES_COUNT;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationDimensionalItemValueMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationOrgUnitGroupCountMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.newBuilder;\n+import static org.hisp.dhis.analytics.DimensionItem.asItemKey;\n+import static org.hisp.dhis.analytics.DimensionItem.getItemIdentifiers;\n+import static org.hisp.dhis.analytics.DimensionItem.getOrganisationUnitItem;\n+import static org.hisp.dhis.analytics.DimensionItem.getPeriodItem;\n+import static org.hisp.dhis.analytics.OutputFormat.ANALYTICS;\n+import static org.hisp.dhis.analytics.event.EventQueryParams.fromDataQueryParams;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.convertDxToOperand;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.findDimensionalItems;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getDoubleMap;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValue;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValueObject;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.hasPeriod;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.isPeriodInPeriods;\n+import static org.hisp.dhis.analytics.util.PeriodOffsetUtils.getPeriodOffsetRow;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT_OPERAND;\n+import static org.hisp.dhis.common.DataDimensionItemType.INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_ATTRIBUTE;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.VALIDATION_RULE;\n+import static org.hisp.dhis.common.DimensionType.ATTRIBUTE_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.CATEGORY_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.DATA_X;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT_GROUP;\n+import static org.hisp.dhis.common.DimensionalObject.ATTRIBUTEOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.CATEGORYOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DATA_X_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DIMENSION_SEP;\n+import static org.hisp.dhis.common.DimensionalObject.ORGUNIT_GROUP_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.PERIOD_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.asTypedList;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.convertToDimItemValueMap;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getAttributeOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getCategoryOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDataElements;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDimensionItem;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.replaceOperandTotalsWithDataElements;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS_ON_TIME;\n+import static org.hisp.dhis.common.ReportingRateMetric.EXPECTED_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.REPORTING_RATE_ON_TIME;\n+import static org.hisp.dhis.commons.util.DebugUtils.getStackTrace;\n+import static org.hisp.dhis.commons.util.SystemUtils.getCpuCores;\n+import static org.hisp.dhis.dataelement.DataElementOperand.TotalType.values;\n+import static org.hisp.dhis.period.DailyPeriodType.NAME;\n+import static org.hisp.dhis.period.PeriodType.getPeriodFromIsoString;\n+import static org.hisp.dhis.period.PeriodType.getPeriodTypeFromIsoString;\n+import static org.hisp.dhis.setting.SettingKey.ANALYTICS_MAX_LIMIT;\n+import static org.hisp.dhis.setting.SettingKey.DATABASE_SERVER_CPUS;\n+import static org.hisp.dhis.system.util.MathUtils.getRounded;\n+import static org.hisp.dhis.system.util.MathUtils.getWithin;\n+import static org.hisp.dhis.system.util.MathUtils.isZero;\n+import static org.hisp.dhis.util.ObjectUtils.firstNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.hisp.dhis.analytics.AnalyticsManager;\n+import org.hisp.dhis.analytics.AnalyticsTableType;\n+import org.hisp.dhis.analytics.DataQueryGroups;\n+import org.hisp.dhis.analytics.DataQueryParams;\n+import org.hisp.dhis.analytics.DimensionItem;\n+import org.hisp.dhis.analytics.QueryPlanner;\n+import org.hisp.dhis.analytics.QueryPlannerParams;\n+import org.hisp.dhis.analytics.QueryValidator;\n+import org.hisp.dhis.analytics.RawAnalyticsManager;\n+import org.hisp.dhis.analytics.event.EventAnalyticsService;\n+import org.hisp.dhis.analytics.event.EventQueryParams;\n+import org.hisp.dhis.analytics.resolver.ExpressionResolver;\n+import org.hisp.dhis.common.BaseDimensionalObject;\n+import org.hisp.dhis.common.DimensionItemObjectValue;\n+import org.hisp.dhis.common.DimensionalItemObject;\n+import org.hisp.dhis.common.DimensionalObject;\n+import org.hisp.dhis.common.Grid;\n+import org.hisp.dhis.common.ReportingRateMetric;\n+import org.hisp.dhis.constant.Constant;\n+import org.hisp.dhis.constant.ConstantService;\n+import org.hisp.dhis.dataelement.DataElementOperand;\n+import org.hisp.dhis.dataelement.DataElementOperand.TotalType;\n+import org.hisp.dhis.expression.ExpressionService;\n+import org.hisp.dhis.indicator.Indicator;\n+import org.hisp.dhis.indicator.IndicatorValue;\n+import org.hisp.dhis.organisationunit.OrganisationUnit;\n+import org.hisp.dhis.organisationunit.OrganisationUnitGroup;\n+import org.hisp.dhis.organisationunit.OrganisationUnitService;\n+import org.hisp.dhis.period.Period;\n+import org.hisp.dhis.period.PeriodType;\n+import org.hisp.dhis.setting.SystemSettingManager;\n+import org.hisp.dhis.util.Timer;\n+import org.springframework.stereotype.Component;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * This component is responsible for handling and retrieving data based on the\n+ * input provided to the public methods. The main goal is to correctly populate\n+ * the data into the Grid object.\n+ */\n+@Slf4j\n+@Component\n+public class DataHandler\n+{\n+\n+    private static final int MAX_QUERIES = 8;\n+\n+    private static final int PERCENT = 100;\n+\n+    private final EventAnalyticsService eventAnalyticsService;\n+\n+    private final RawAnalyticsManager rawAnalyticsManager;\n+\n+    private final ConstantService constantService;\n+\n+    private final ExpressionResolver resolver;\n+\n+    private final ExpressionService expressionService;\n+\n+    private final QueryPlanner queryPlanner;\n+\n+    private final QueryValidator queryValidator;\n+\n+    private final SystemSettingManager systemSettingManager;\n+\n+    private final AnalyticsManager analyticsManager;\n+\n+    private final OrganisationUnitService organisationUnitService;\n+\n+    private DataAggregator dataAggregator;\n+\n+    public DataHandler( EventAnalyticsService eventAnalyticsService, RawAnalyticsManager rawAnalyticsManager,\n+        ConstantService constantService, ExpressionResolver resolver, ExpressionService expressionService,\n+        QueryPlanner queryPlanner, QueryValidator queryValidator, SystemSettingManager systemSettingManager,\n+        AnalyticsManager analyticsManager, OrganisationUnitService organisationUnitService )\n+    {\n+        checkNotNull( eventAnalyticsService );\n+        checkNotNull( rawAnalyticsManager );\n+        checkNotNull( constantService );\n+        checkNotNull( resolver );\n+        checkNotNull( expressionService );\n+        checkNotNull( queryPlanner );\n+        checkNotNull( queryValidator );\n+        checkNotNull( systemSettingManager );\n+        checkNotNull( analyticsManager );\n+        checkNotNull( organisationUnitService );\n+\n+        this.eventAnalyticsService = eventAnalyticsService;\n+        this.rawAnalyticsManager = rawAnalyticsManager;\n+        this.constantService = constantService;\n+        this.resolver = resolver;\n+        this.expressionService = expressionService;\n+        this.queryPlanner = queryPlanner;\n+        this.queryValidator = queryValidator;\n+        this.systemSettingManager = systemSettingManager;\n+        this.analyticsManager = analyticsManager;\n+        this.organisationUnitService = organisationUnitService;\n+    }\n+\n+    /**\n+     * Adds indicator values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getIndicators().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( INDICATOR )\n+                .withIncludeNumDen( false ).build();\n+\n+            List<Indicator> indicators = asTypedList( dataSourceParams.getIndicators() );\n+\n+            List<Period> filterPeriods = dataSourceParams.getTypedFilterPeriods();\n+\n+            Map<String, Constant> constantMap = constantService.getConstantMap();\n+\n+            // -----------------------------------------------------------------\n+            // Get indicator values\n+            // -----------------------------------------------------------------\n+\n+            Map<String, Map<String, Integer>> permutationOrgUnitTargetMap = getOrgUnitTargetMap( dataSourceParams,\n+                indicators );\n+\n+            List<List<DimensionItem>> dimensionItemPermutations = dataSourceParams.getDimensionItemPermutations();\n+\n+            Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap = getPermutationDimensionItemValueMap(\n+                dataSourceParams );\n+\n+            handleEmptyDimensionItemPermutations( dimensionItemPermutations );\n+\n+            for ( Indicator indicator : indicators )\n+            {\n+                for ( List<DimensionItem> dimensionItems : dimensionItemPermutations )\n+                {\n+                    IndicatorValue value = getIndicatorValue( filterPeriods, constantMap, permutationOrgUnitTargetMap,\n+                        permutationDimensionItemValueMap, indicator, dimensionItems );\n+\n+                    addIndicatorValuesToGrid( params, grid, dataSourceParams, indicator, dimensionItems, value );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Based on the given Indicator plus additional parameters, this method will\n+     * find the respective IndicatorValue.\n+     * \n+     * @param filterPeriods\n+     * @param constantMap\n+     * @param permutationOrgUnitTargetMap\n+     * @param permutationDimensionItemValueMap\n+     * @param indicator\n+     * @param dimensionItems\n+     * @return the IndicatorValue\n+     */\n+    private IndicatorValue getIndicatorValue( List<Period> filterPeriods, Map<String, Constant> constantMap,\n+        Map<String, Map<String, Integer>> permutationOrgUnitTargetMap,\n+        Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap, Indicator indicator,\n+        List<DimensionItem> dimensionItems )\n+    {\n+        String permKey = asItemKey( dimensionItems );\n+\n+        final List<DimensionItemObjectValue> valueMap = permutationDimensionItemValueMap\n+            .getOrDefault( permKey, new ArrayList<>() );\n+\n+        List<Period> periods = !filterPeriods.isEmpty() ? filterPeriods\n+            : singletonList( (Period) getPeriodItem( dimensionItems ) );\n+\n+        OrganisationUnit unit = (OrganisationUnit) getOrganisationUnitItem( dimensionItems );\n+\n+        String ou = unit != null ? unit.getUid() : null;\n+\n+        Map<String, Integer> orgUnitCountMap = permutationOrgUnitTargetMap != null\n+            ? permutationOrgUnitTargetMap.get( ou )\n+            : null;\n+\n+        return expressionService.getIndicatorValueObject( indicator, periods,\n+            convertToDimItemValueMap( valueMap ), constantMap, orgUnitCountMap );\n+    }\n+\n+    /**\n+     * Adds data element values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDataElementValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getAllDataElements().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( DATA_ELEMENT )\n+                .withIncludeNumDen( false ).build();\n+\n+            Map<String, Object> aggregatedDataMap = getAggregatedDataValueMapObjectTyped( dataSourceParams );\n+\n+            for ( Map.Entry<String, Object> entry : aggregatedDataMap.entrySet() )\n+            {\n+                Object value = getRoundedValueObject( params, entry.getValue() );\n+\n+                grid.addRow()\n+                    .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                    .addValue( value );\n+\n+                if ( params.isIncludeNumDen() )\n+                {\n+                    grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds program data element values to the given grid based on the given data\n+     * query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addProgramDataElementAttributeIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( (!params.getAllProgramDataElementsAndAttributes().isEmpty() || !params.getProgramIndicators().isEmpty())\n+            && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimensions( PROGRAM_DATA_ELEMENT, PROGRAM_ATTRIBUTE, PROGRAM_INDICATOR ).build();\n+\n+            EventQueryParams eventQueryParams = new EventQueryParams.Builder( fromDataQueryParams( dataSourceParams ) )\n+                .withSkipMeta( true ).build();\n+\n+            Grid eventGrid = eventAnalyticsService.getAggregatedEventData( eventQueryParams );\n+\n+            grid.addRows( eventGrid );\n+        }\n+    }\n+\n+    /**\n+     * Adds reporting rates to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addReportingRates( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getReportingRates().isEmpty() && !params.isSkipData() )\n+        {\n+            for ( ReportingRateMetric metric : ReportingRateMetric.values() )\n+            {\n+                DataQueryParams dataSourceParams = newBuilder( params )\n+                    .retainDataDimensionReportingRates( metric )\n+                    .ignoreDataApproval() // No approval for reporting rates\n+                    .withAggregationType( COUNT )\n+                    .withTimely( (REPORTING_RATE_ON_TIME == metric || ACTUAL_REPORTS_ON_TIME == metric) ).build();\n+\n+                addReportingRates( dataSourceParams, grid, metric );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds data element operand values to the given grid based on the given data\n+     * query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDataElementOperandValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getDataElementOperands().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( DATA_ELEMENT_OPERAND ).build();\n+\n+            for ( TotalType type : values() )\n+            {\n+                addDataElementOperandValues( dataSourceParams, grid, type );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds values to the given grid based on dynamic dimensions from the given data\n+     * query parameters. This assumes that no fixed dimensions are part of the\n+     * query.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDynamicDimensionValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( params.getDataDimensionAndFilterOptions().isEmpty() && !params.isSkipData() )\n+        {\n+            Map<String, Double> aggregatedDataMap = getAggregatedDataValueMap( newBuilder( params )\n+                .withIncludeNumDen( false ).build() );\n+\n+            fillGridWithAggregatedDataMap( params, grid, aggregatedDataMap );\n+        }\n+    }\n+\n+    /**\n+     * Adds validation results to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addValidationResultValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getAllValidationResults().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( VALIDATION_RULE )\n+                .withAggregationType( COUNT )\n+                .withIncludeNumDen( false ).build();\n+\n+            Map<String, Double> aggregatedDataMap = getAggregatedValidationResultMapObjectTyped( dataSourceParams );\n+\n+            fillGridWithAggregatedDataMap( params, grid, aggregatedDataMap );\n+        }\n+    }\n+\n+    /**\n+     * Adds raw data to the grid for the given data query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addRawData( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.isSkipData() )\n+        {\n+            QueryPlannerParams plannerParams = QueryPlannerParams.newBuilder()\n+                .withTableType( DATA_VALUE ).build();\n+\n+            params = queryPlanner.withTableNameAndPartitions( params, plannerParams );\n+\n+            rawAnalyticsManager.getRawDataValues( params, grid );\n+        }\n+    }\n+\n+    /**\n+     * Prepares the given data query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     */\n+    DataQueryParams prepareForRawDataQuery( DataQueryParams params )\n+    {\n+        DataQueryParams.Builder builder = newBuilder( params )\n+            .withEarliestStartDateLatestEndDate()\n+            .withPeriodDimensionWithoutOptions()\n+            .withIncludePeriodStartEndDates( true );\n+\n+        if ( params.isShowHierarchy() )\n+        {\n+            builder.withOrgUnitLevels( organisationUnitService.getFilledOrganisationUnitLevels() );\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Generates a mapping between the count of a validation result.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between validation results and counts of them\n+     */\n+    private Map<String, Double> getAggregatedValidationResultMapObjectTyped( DataQueryParams params )\n+    {\n+        return getDoubleMap( getAggregatedValueMap( params, VALIDATION_RESULT, newArrayList() ) );\n+    }\n+\n+    /**\n+     * Fill grid with aggregated data map with key and value\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid\n+     * @param aggregatedDataMap the aggregated data map\n+     */\n+    private void fillGridWithAggregatedDataMap( DataQueryParams params, Grid grid,\n+        Map<String, Double> aggregatedDataMap )\n+    {\n+        for ( Map.Entry<String, Double> entry : aggregatedDataMap.entrySet() )\n+        {\n+            Double value = params.isSkipRounding() ? entry.getValue() : getRounded( entry.getValue() );\n+\n+            grid.addRow()\n+                .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                .addValue( value );\n+\n+            if ( params.isIncludeNumDen() )\n+            {\n+                grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds reporting rates to the given grid based on the given data query\n+     * parameters and reporting rate metric.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     * @param metric the reporting rate metric.\n+     */\n+    private void addReportingRates( DataQueryParams params, Grid grid, ReportingRateMetric metric )\n+    {\n+        if ( !params.getReportingRates().isEmpty() && !params.isSkipData() )\n+        {\n+            if ( !COMPLETENESS_DIMENSION_TYPES.containsAll( params.getDimensionTypes() ) )\n+            {\n+                return;\n+            }\n+\n+            DataQueryParams targetParams = newBuilder( params )\n+                .withSkipPartitioning( true )\n+                .withTimely( false )\n+                .withRestrictByOrgUnitOpeningClosedDate( true )\n+                .withRestrictByCategoryOptionStartEndDate( true )\n+                .withAggregationType( SUM ).build();\n+\n+            Map<String, Double> targetMap = getAggregatedCompletenessTargetMap( targetParams );\n+\n+            Map<String, Double> dataMap = metric != EXPECTED_REPORTS\n+                ? getAggregatedCompletenessValueMap( params )\n+                : new HashMap<>();\n+\n+            Integer periodIndex = params.getPeriodDimensionIndex();", "originalCommit": "1c656fcb31616a11eeee7e18ae96874dd5cb7bb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0MTI3NQ==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464241275", "bodyText": "I'm going to have a look. I didn't want to change any code to avoid any risk of introducing bugs. Let me check if this is safe enough.", "author": "maikelarabori", "createdAt": "2020-08-03T07:33:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMDkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMzYwNw==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r465133607", "bodyText": "I didn't feel confident about this change, as we could have some null checking that would not be the same as 0 (zero). Not sure if this would possible, but I'm afraid it could introduce some bug. I think it's better to leave for another round of refactoring", "author": "maikelarabori", "createdAt": "2020-08-04T15:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMDkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNTQ5MA==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r465135490", "bodyText": "ok", "author": "luciano-fiandesio", "createdAt": "2020-08-04T15:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMDkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMTEwNQ==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464211105", "bodyText": "Add missing javadoc for the method arguments or remove @param", "author": "luciano-fiandesio", "createdAt": "2020-08-03T06:09:08Z", "path": "dhis-2/dhis-services/dhis-service-analytics/src/main/java/org/hisp/dhis/analytics/data/handling/DataHandler.java", "diffHunk": "@@ -0,0 +1,1161 @@\n+package org.hisp.dhis.analytics.data.handling;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static java.lang.Math.min;\n+import static java.util.Collections.singletonList;\n+import static org.apache.commons.collections4.CollectionUtils.isEmpty;\n+import static org.apache.commons.lang3.ArrayUtils.remove;\n+import static org.apache.commons.lang3.StringUtils.join;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.COUNT;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.SUM;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.DATA_VALUE;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.ORG_UNIT_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.VALIDATION_RESULT;\n+import static org.hisp.dhis.analytics.DataQueryParams.COMPLETENESS_DIMENSION_TYPES;\n+import static org.hisp.dhis.analytics.DataQueryParams.DISPLAY_NAME_DATA_X;\n+import static org.hisp.dhis.analytics.DataQueryParams.DX_INDEX;\n+import static org.hisp.dhis.analytics.DataQueryParams.NUMERATOR_DENOMINATOR_PROPERTIES_COUNT;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationDimensionalItemValueMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationOrgUnitGroupCountMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.newBuilder;\n+import static org.hisp.dhis.analytics.DimensionItem.asItemKey;\n+import static org.hisp.dhis.analytics.DimensionItem.getItemIdentifiers;\n+import static org.hisp.dhis.analytics.DimensionItem.getOrganisationUnitItem;\n+import static org.hisp.dhis.analytics.DimensionItem.getPeriodItem;\n+import static org.hisp.dhis.analytics.OutputFormat.ANALYTICS;\n+import static org.hisp.dhis.analytics.event.EventQueryParams.fromDataQueryParams;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.convertDxToOperand;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.findDimensionalItems;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getDoubleMap;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValue;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValueObject;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.hasPeriod;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.isPeriodInPeriods;\n+import static org.hisp.dhis.analytics.util.PeriodOffsetUtils.getPeriodOffsetRow;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT_OPERAND;\n+import static org.hisp.dhis.common.DataDimensionItemType.INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_ATTRIBUTE;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.VALIDATION_RULE;\n+import static org.hisp.dhis.common.DimensionType.ATTRIBUTE_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.CATEGORY_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.DATA_X;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT_GROUP;\n+import static org.hisp.dhis.common.DimensionalObject.ATTRIBUTEOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.CATEGORYOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DATA_X_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DIMENSION_SEP;\n+import static org.hisp.dhis.common.DimensionalObject.ORGUNIT_GROUP_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.PERIOD_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.asTypedList;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.convertToDimItemValueMap;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getAttributeOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getCategoryOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDataElements;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDimensionItem;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.replaceOperandTotalsWithDataElements;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS_ON_TIME;\n+import static org.hisp.dhis.common.ReportingRateMetric.EXPECTED_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.REPORTING_RATE_ON_TIME;\n+import static org.hisp.dhis.commons.util.DebugUtils.getStackTrace;\n+import static org.hisp.dhis.commons.util.SystemUtils.getCpuCores;\n+import static org.hisp.dhis.dataelement.DataElementOperand.TotalType.values;\n+import static org.hisp.dhis.period.DailyPeriodType.NAME;\n+import static org.hisp.dhis.period.PeriodType.getPeriodFromIsoString;\n+import static org.hisp.dhis.period.PeriodType.getPeriodTypeFromIsoString;\n+import static org.hisp.dhis.setting.SettingKey.ANALYTICS_MAX_LIMIT;\n+import static org.hisp.dhis.setting.SettingKey.DATABASE_SERVER_CPUS;\n+import static org.hisp.dhis.system.util.MathUtils.getRounded;\n+import static org.hisp.dhis.system.util.MathUtils.getWithin;\n+import static org.hisp.dhis.system.util.MathUtils.isZero;\n+import static org.hisp.dhis.util.ObjectUtils.firstNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.hisp.dhis.analytics.AnalyticsManager;\n+import org.hisp.dhis.analytics.AnalyticsTableType;\n+import org.hisp.dhis.analytics.DataQueryGroups;\n+import org.hisp.dhis.analytics.DataQueryParams;\n+import org.hisp.dhis.analytics.DimensionItem;\n+import org.hisp.dhis.analytics.QueryPlanner;\n+import org.hisp.dhis.analytics.QueryPlannerParams;\n+import org.hisp.dhis.analytics.QueryValidator;\n+import org.hisp.dhis.analytics.RawAnalyticsManager;\n+import org.hisp.dhis.analytics.event.EventAnalyticsService;\n+import org.hisp.dhis.analytics.event.EventQueryParams;\n+import org.hisp.dhis.analytics.resolver.ExpressionResolver;\n+import org.hisp.dhis.common.BaseDimensionalObject;\n+import org.hisp.dhis.common.DimensionItemObjectValue;\n+import org.hisp.dhis.common.DimensionalItemObject;\n+import org.hisp.dhis.common.DimensionalObject;\n+import org.hisp.dhis.common.Grid;\n+import org.hisp.dhis.common.ReportingRateMetric;\n+import org.hisp.dhis.constant.Constant;\n+import org.hisp.dhis.constant.ConstantService;\n+import org.hisp.dhis.dataelement.DataElementOperand;\n+import org.hisp.dhis.dataelement.DataElementOperand.TotalType;\n+import org.hisp.dhis.expression.ExpressionService;\n+import org.hisp.dhis.indicator.Indicator;\n+import org.hisp.dhis.indicator.IndicatorValue;\n+import org.hisp.dhis.organisationunit.OrganisationUnit;\n+import org.hisp.dhis.organisationunit.OrganisationUnitGroup;\n+import org.hisp.dhis.organisationunit.OrganisationUnitService;\n+import org.hisp.dhis.period.Period;\n+import org.hisp.dhis.period.PeriodType;\n+import org.hisp.dhis.setting.SystemSettingManager;\n+import org.hisp.dhis.util.Timer;\n+import org.springframework.stereotype.Component;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * This component is responsible for handling and retrieving data based on the\n+ * input provided to the public methods. The main goal is to correctly populate\n+ * the data into the Grid object.\n+ */\n+@Slf4j\n+@Component\n+public class DataHandler\n+{\n+\n+    private static final int MAX_QUERIES = 8;\n+\n+    private static final int PERCENT = 100;\n+\n+    private final EventAnalyticsService eventAnalyticsService;\n+\n+    private final RawAnalyticsManager rawAnalyticsManager;\n+\n+    private final ConstantService constantService;\n+\n+    private final ExpressionResolver resolver;\n+\n+    private final ExpressionService expressionService;\n+\n+    private final QueryPlanner queryPlanner;\n+\n+    private final QueryValidator queryValidator;\n+\n+    private final SystemSettingManager systemSettingManager;\n+\n+    private final AnalyticsManager analyticsManager;\n+\n+    private final OrganisationUnitService organisationUnitService;\n+\n+    private DataAggregator dataAggregator;\n+\n+    public DataHandler( EventAnalyticsService eventAnalyticsService, RawAnalyticsManager rawAnalyticsManager,\n+        ConstantService constantService, ExpressionResolver resolver, ExpressionService expressionService,\n+        QueryPlanner queryPlanner, QueryValidator queryValidator, SystemSettingManager systemSettingManager,\n+        AnalyticsManager analyticsManager, OrganisationUnitService organisationUnitService )\n+    {\n+        checkNotNull( eventAnalyticsService );\n+        checkNotNull( rawAnalyticsManager );\n+        checkNotNull( constantService );\n+        checkNotNull( resolver );\n+        checkNotNull( expressionService );\n+        checkNotNull( queryPlanner );\n+        checkNotNull( queryValidator );\n+        checkNotNull( systemSettingManager );\n+        checkNotNull( analyticsManager );\n+        checkNotNull( organisationUnitService );\n+\n+        this.eventAnalyticsService = eventAnalyticsService;\n+        this.rawAnalyticsManager = rawAnalyticsManager;\n+        this.constantService = constantService;\n+        this.resolver = resolver;\n+        this.expressionService = expressionService;\n+        this.queryPlanner = queryPlanner;\n+        this.queryValidator = queryValidator;\n+        this.systemSettingManager = systemSettingManager;\n+        this.analyticsManager = analyticsManager;\n+        this.organisationUnitService = organisationUnitService;\n+    }\n+\n+    /**\n+     * Adds indicator values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getIndicators().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( INDICATOR )\n+                .withIncludeNumDen( false ).build();\n+\n+            List<Indicator> indicators = asTypedList( dataSourceParams.getIndicators() );\n+\n+            List<Period> filterPeriods = dataSourceParams.getTypedFilterPeriods();\n+\n+            Map<String, Constant> constantMap = constantService.getConstantMap();\n+\n+            // -----------------------------------------------------------------\n+            // Get indicator values\n+            // -----------------------------------------------------------------\n+\n+            Map<String, Map<String, Integer>> permutationOrgUnitTargetMap = getOrgUnitTargetMap( dataSourceParams,\n+                indicators );\n+\n+            List<List<DimensionItem>> dimensionItemPermutations = dataSourceParams.getDimensionItemPermutations();\n+\n+            Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap = getPermutationDimensionItemValueMap(\n+                dataSourceParams );\n+\n+            handleEmptyDimensionItemPermutations( dimensionItemPermutations );\n+\n+            for ( Indicator indicator : indicators )\n+            {\n+                for ( List<DimensionItem> dimensionItems : dimensionItemPermutations )\n+                {\n+                    IndicatorValue value = getIndicatorValue( filterPeriods, constantMap, permutationOrgUnitTargetMap,\n+                        permutationDimensionItemValueMap, indicator, dimensionItems );\n+\n+                    addIndicatorValuesToGrid( params, grid, dataSourceParams, indicator, dimensionItems, value );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Based on the given Indicator plus additional parameters, this method will\n+     * find the respective IndicatorValue.\n+     * \n+     * @param filterPeriods\n+     * @param constantMap\n+     * @param permutationOrgUnitTargetMap\n+     * @param permutationDimensionItemValueMap\n+     * @param indicator\n+     * @param dimensionItems\n+     * @return the IndicatorValue\n+     */\n+    private IndicatorValue getIndicatorValue( List<Period> filterPeriods, Map<String, Constant> constantMap,\n+        Map<String, Map<String, Integer>> permutationOrgUnitTargetMap,\n+        Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap, Indicator indicator,\n+        List<DimensionItem> dimensionItems )\n+    {\n+        String permKey = asItemKey( dimensionItems );\n+\n+        final List<DimensionItemObjectValue> valueMap = permutationDimensionItemValueMap\n+            .getOrDefault( permKey, new ArrayList<>() );\n+\n+        List<Period> periods = !filterPeriods.isEmpty() ? filterPeriods\n+            : singletonList( (Period) getPeriodItem( dimensionItems ) );\n+\n+        OrganisationUnit unit = (OrganisationUnit) getOrganisationUnitItem( dimensionItems );\n+\n+        String ou = unit != null ? unit.getUid() : null;\n+\n+        Map<String, Integer> orgUnitCountMap = permutationOrgUnitTargetMap != null\n+            ? permutationOrgUnitTargetMap.get( ou )\n+            : null;\n+\n+        return expressionService.getIndicatorValueObject( indicator, periods,\n+            convertToDimItemValueMap( valueMap ), constantMap, orgUnitCountMap );\n+    }\n+\n+    /**\n+     * Adds data element values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDataElementValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getAllDataElements().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( DATA_ELEMENT )\n+                .withIncludeNumDen( false ).build();\n+\n+            Map<String, Object> aggregatedDataMap = getAggregatedDataValueMapObjectTyped( dataSourceParams );\n+\n+            for ( Map.Entry<String, Object> entry : aggregatedDataMap.entrySet() )\n+            {\n+                Object value = getRoundedValueObject( params, entry.getValue() );\n+\n+                grid.addRow()\n+                    .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                    .addValue( value );\n+\n+                if ( params.isIncludeNumDen() )\n+                {\n+                    grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds program data element values to the given grid based on the given data\n+     * query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addProgramDataElementAttributeIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( (!params.getAllProgramDataElementsAndAttributes().isEmpty() || !params.getProgramIndicators().isEmpty())\n+            && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimensions( PROGRAM_DATA_ELEMENT, PROGRAM_ATTRIBUTE, PROGRAM_INDICATOR ).build();\n+\n+            EventQueryParams eventQueryParams = new EventQueryParams.Builder( fromDataQueryParams( dataSourceParams ) )\n+                .withSkipMeta( true ).build();\n+\n+            Grid eventGrid = eventAnalyticsService.getAggregatedEventData( eventQueryParams );\n+\n+            grid.addRows( eventGrid );\n+        }\n+    }\n+\n+    /**\n+     * Adds reporting rates to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addReportingRates( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getReportingRates().isEmpty() && !params.isSkipData() )\n+        {\n+            for ( ReportingRateMetric metric : ReportingRateMetric.values() )\n+            {\n+                DataQueryParams dataSourceParams = newBuilder( params )\n+                    .retainDataDimensionReportingRates( metric )\n+                    .ignoreDataApproval() // No approval for reporting rates\n+                    .withAggregationType( COUNT )\n+                    .withTimely( (REPORTING_RATE_ON_TIME == metric || ACTUAL_REPORTS_ON_TIME == metric) ).build();\n+\n+                addReportingRates( dataSourceParams, grid, metric );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds data element operand values to the given grid based on the given data\n+     * query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDataElementOperandValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getDataElementOperands().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( DATA_ELEMENT_OPERAND ).build();\n+\n+            for ( TotalType type : values() )\n+            {\n+                addDataElementOperandValues( dataSourceParams, grid, type );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds values to the given grid based on dynamic dimensions from the given data\n+     * query parameters. This assumes that no fixed dimensions are part of the\n+     * query.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDynamicDimensionValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( params.getDataDimensionAndFilterOptions().isEmpty() && !params.isSkipData() )\n+        {\n+            Map<String, Double> aggregatedDataMap = getAggregatedDataValueMap( newBuilder( params )\n+                .withIncludeNumDen( false ).build() );\n+\n+            fillGridWithAggregatedDataMap( params, grid, aggregatedDataMap );\n+        }\n+    }\n+\n+    /**\n+     * Adds validation results to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addValidationResultValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getAllValidationResults().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( VALIDATION_RULE )\n+                .withAggregationType( COUNT )\n+                .withIncludeNumDen( false ).build();\n+\n+            Map<String, Double> aggregatedDataMap = getAggregatedValidationResultMapObjectTyped( dataSourceParams );\n+\n+            fillGridWithAggregatedDataMap( params, grid, aggregatedDataMap );\n+        }\n+    }\n+\n+    /**\n+     * Adds raw data to the grid for the given data query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addRawData( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.isSkipData() )\n+        {\n+            QueryPlannerParams plannerParams = QueryPlannerParams.newBuilder()\n+                .withTableType( DATA_VALUE ).build();\n+\n+            params = queryPlanner.withTableNameAndPartitions( params, plannerParams );\n+\n+            rawAnalyticsManager.getRawDataValues( params, grid );\n+        }\n+    }\n+\n+    /**\n+     * Prepares the given data query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     */\n+    DataQueryParams prepareForRawDataQuery( DataQueryParams params )\n+    {\n+        DataQueryParams.Builder builder = newBuilder( params )\n+            .withEarliestStartDateLatestEndDate()\n+            .withPeriodDimensionWithoutOptions()\n+            .withIncludePeriodStartEndDates( true );\n+\n+        if ( params.isShowHierarchy() )\n+        {\n+            builder.withOrgUnitLevels( organisationUnitService.getFilledOrganisationUnitLevels() );\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Generates a mapping between the count of a validation result.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between validation results and counts of them\n+     */\n+    private Map<String, Double> getAggregatedValidationResultMapObjectTyped( DataQueryParams params )\n+    {\n+        return getDoubleMap( getAggregatedValueMap( params, VALIDATION_RESULT, newArrayList() ) );\n+    }\n+\n+    /**\n+     * Fill grid with aggregated data map with key and value\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid\n+     * @param aggregatedDataMap the aggregated data map\n+     */\n+    private void fillGridWithAggregatedDataMap( DataQueryParams params, Grid grid,\n+        Map<String, Double> aggregatedDataMap )\n+    {\n+        for ( Map.Entry<String, Double> entry : aggregatedDataMap.entrySet() )\n+        {\n+            Double value = params.isSkipRounding() ? entry.getValue() : getRounded( entry.getValue() );\n+\n+            grid.addRow()\n+                .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                .addValue( value );\n+\n+            if ( params.isIncludeNumDen() )\n+            {\n+                grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds reporting rates to the given grid based on the given data query\n+     * parameters and reporting rate metric.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     * @param metric the reporting rate metric.\n+     */\n+    private void addReportingRates( DataQueryParams params, Grid grid, ReportingRateMetric metric )\n+    {\n+        if ( !params.getReportingRates().isEmpty() && !params.isSkipData() )\n+        {\n+            if ( !COMPLETENESS_DIMENSION_TYPES.containsAll( params.getDimensionTypes() ) )\n+            {\n+                return;\n+            }\n+\n+            DataQueryParams targetParams = newBuilder( params )\n+                .withSkipPartitioning( true )\n+                .withTimely( false )\n+                .withRestrictByOrgUnitOpeningClosedDate( true )\n+                .withRestrictByCategoryOptionStartEndDate( true )\n+                .withAggregationType( SUM ).build();\n+\n+            Map<String, Double> targetMap = getAggregatedCompletenessTargetMap( targetParams );\n+\n+            Map<String, Double> dataMap = metric != EXPECTED_REPORTS\n+                ? getAggregatedCompletenessValueMap( params )\n+                : new HashMap<>();\n+\n+            Integer periodIndex = params.getPeriodDimensionIndex();\n+            Integer dataSetIndex = DX_INDEX;\n+            Map<String, PeriodType> dsPtMap = params.getDataSetPeriodTypeMap();\n+            PeriodType filterPeriodType = params.getFilterPeriodType();\n+\n+            int timeUnits = getTimeUnits( params );\n+\n+            for ( Map.Entry<String, Double> entry : targetMap.entrySet() )\n+            {\n+                List<String> dataRow = newArrayList( entry.getKey().split( DIMENSION_SEP ) );\n+\n+                Double target = entry.getValue();\n+                Double actual = firstNonNull( dataMap.get( entry.getKey() ), 0d );\n+\n+                if ( target != null )\n+                {\n+                    // ---------------------------------------------------------\n+                    // Multiply target value by number of periods in time span\n+                    // ---------------------------------------------------------\n+\n+                    PeriodType queryPt = filterPeriodType != null ? filterPeriodType\n+                        : getPeriodTypeFromIsoString( dataRow.get( periodIndex ) );\n+                    PeriodType dataSetPt = dsPtMap.get( dataRow.get( dataSetIndex ) );\n+\n+                    target = getCalculatedTarget( periodIndex, timeUnits, dataRow, target, queryPt, dataSetPt );\n+\n+                    addReportRateToGrid( params, grid, metric, dataRow, target, actual );\n+                }\n+            }\n+        }\n+    }\n+\n+    private int getTimeUnits( DataQueryParams params )\n+    {\n+        return params.hasFilter( PERIOD_DIM_ID ) ? params.getFilterPeriods().size() : 1;\n+    }\n+\n+    /**\n+     * Calculate reporting rate and replace data set with rate and add the rate to\n+     * the Grid.\n+     * \n+     * @param params\n+     * @param grid\n+     * @param metric\n+     * @param dataRow\n+     * @param target\n+     * @param actual\n+     */\n+    private void addReportRateToGrid( DataQueryParams params, Grid grid, ReportingRateMetric metric,\n+        List<String> dataRow, Double target, Double actual )\n+    {\n+        Double value = getReportRate( metric, target, actual );\n+\n+        String reportingRate = getDimensionItem( dataRow.get( DX_INDEX ), metric );\n+        dataRow.set( DX_INDEX, reportingRate );\n+\n+        grid.addRow()\n+            .addValues( dataRow.toArray() )\n+            .addValue( params.isSkipRounding() ? value : getRounded( value ) );\n+\n+        if ( params.isIncludeNumDen() )\n+        {\n+            grid.addValue( actual )\n+                .addValue( target )\n+                .addValue( PERCENT )\n+                .addNullValues( 2 );\n+        }\n+    }\n+\n+    /**\n+     * Use number of days for daily data sets as target, as query periods might\n+     * often span/contain different numbers of days.\n+     * \n+     * @param periodIndex", "originalCommit": "1c656fcb31616a11eeee7e18ae96874dd5cb7bb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMzY3OA==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r465133678", "bodyText": "Done", "author": "maikelarabori", "createdAt": "2020-08-04T15:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMTEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMTE3Nw==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464211177", "bodyText": "Add missing javadoc for the method arguments or remove @param", "author": "luciano-fiandesio", "createdAt": "2020-08-03T06:09:31Z", "path": "dhis-2/dhis-services/dhis-service-analytics/src/main/java/org/hisp/dhis/analytics/data/handling/DataHandler.java", "diffHunk": "@@ -0,0 +1,1161 @@\n+package org.hisp.dhis.analytics.data.handling;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static java.lang.Math.min;\n+import static java.util.Collections.singletonList;\n+import static org.apache.commons.collections4.CollectionUtils.isEmpty;\n+import static org.apache.commons.lang3.ArrayUtils.remove;\n+import static org.apache.commons.lang3.StringUtils.join;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.COUNT;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.SUM;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.DATA_VALUE;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.ORG_UNIT_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.VALIDATION_RESULT;\n+import static org.hisp.dhis.analytics.DataQueryParams.COMPLETENESS_DIMENSION_TYPES;\n+import static org.hisp.dhis.analytics.DataQueryParams.DISPLAY_NAME_DATA_X;\n+import static org.hisp.dhis.analytics.DataQueryParams.DX_INDEX;\n+import static org.hisp.dhis.analytics.DataQueryParams.NUMERATOR_DENOMINATOR_PROPERTIES_COUNT;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationDimensionalItemValueMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationOrgUnitGroupCountMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.newBuilder;\n+import static org.hisp.dhis.analytics.DimensionItem.asItemKey;\n+import static org.hisp.dhis.analytics.DimensionItem.getItemIdentifiers;\n+import static org.hisp.dhis.analytics.DimensionItem.getOrganisationUnitItem;\n+import static org.hisp.dhis.analytics.DimensionItem.getPeriodItem;\n+import static org.hisp.dhis.analytics.OutputFormat.ANALYTICS;\n+import static org.hisp.dhis.analytics.event.EventQueryParams.fromDataQueryParams;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.convertDxToOperand;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.findDimensionalItems;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getDoubleMap;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValue;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValueObject;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.hasPeriod;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.isPeriodInPeriods;\n+import static org.hisp.dhis.analytics.util.PeriodOffsetUtils.getPeriodOffsetRow;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT_OPERAND;\n+import static org.hisp.dhis.common.DataDimensionItemType.INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_ATTRIBUTE;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.VALIDATION_RULE;\n+import static org.hisp.dhis.common.DimensionType.ATTRIBUTE_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.CATEGORY_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.DATA_X;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT_GROUP;\n+import static org.hisp.dhis.common.DimensionalObject.ATTRIBUTEOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.CATEGORYOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DATA_X_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DIMENSION_SEP;\n+import static org.hisp.dhis.common.DimensionalObject.ORGUNIT_GROUP_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.PERIOD_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.asTypedList;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.convertToDimItemValueMap;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getAttributeOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getCategoryOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDataElements;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDimensionItem;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.replaceOperandTotalsWithDataElements;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS_ON_TIME;\n+import static org.hisp.dhis.common.ReportingRateMetric.EXPECTED_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.REPORTING_RATE_ON_TIME;\n+import static org.hisp.dhis.commons.util.DebugUtils.getStackTrace;\n+import static org.hisp.dhis.commons.util.SystemUtils.getCpuCores;\n+import static org.hisp.dhis.dataelement.DataElementOperand.TotalType.values;\n+import static org.hisp.dhis.period.DailyPeriodType.NAME;\n+import static org.hisp.dhis.period.PeriodType.getPeriodFromIsoString;\n+import static org.hisp.dhis.period.PeriodType.getPeriodTypeFromIsoString;\n+import static org.hisp.dhis.setting.SettingKey.ANALYTICS_MAX_LIMIT;\n+import static org.hisp.dhis.setting.SettingKey.DATABASE_SERVER_CPUS;\n+import static org.hisp.dhis.system.util.MathUtils.getRounded;\n+import static org.hisp.dhis.system.util.MathUtils.getWithin;\n+import static org.hisp.dhis.system.util.MathUtils.isZero;\n+import static org.hisp.dhis.util.ObjectUtils.firstNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.hisp.dhis.analytics.AnalyticsManager;\n+import org.hisp.dhis.analytics.AnalyticsTableType;\n+import org.hisp.dhis.analytics.DataQueryGroups;\n+import org.hisp.dhis.analytics.DataQueryParams;\n+import org.hisp.dhis.analytics.DimensionItem;\n+import org.hisp.dhis.analytics.QueryPlanner;\n+import org.hisp.dhis.analytics.QueryPlannerParams;\n+import org.hisp.dhis.analytics.QueryValidator;\n+import org.hisp.dhis.analytics.RawAnalyticsManager;\n+import org.hisp.dhis.analytics.event.EventAnalyticsService;\n+import org.hisp.dhis.analytics.event.EventQueryParams;\n+import org.hisp.dhis.analytics.resolver.ExpressionResolver;\n+import org.hisp.dhis.common.BaseDimensionalObject;\n+import org.hisp.dhis.common.DimensionItemObjectValue;\n+import org.hisp.dhis.common.DimensionalItemObject;\n+import org.hisp.dhis.common.DimensionalObject;\n+import org.hisp.dhis.common.Grid;\n+import org.hisp.dhis.common.ReportingRateMetric;\n+import org.hisp.dhis.constant.Constant;\n+import org.hisp.dhis.constant.ConstantService;\n+import org.hisp.dhis.dataelement.DataElementOperand;\n+import org.hisp.dhis.dataelement.DataElementOperand.TotalType;\n+import org.hisp.dhis.expression.ExpressionService;\n+import org.hisp.dhis.indicator.Indicator;\n+import org.hisp.dhis.indicator.IndicatorValue;\n+import org.hisp.dhis.organisationunit.OrganisationUnit;\n+import org.hisp.dhis.organisationunit.OrganisationUnitGroup;\n+import org.hisp.dhis.organisationunit.OrganisationUnitService;\n+import org.hisp.dhis.period.Period;\n+import org.hisp.dhis.period.PeriodType;\n+import org.hisp.dhis.setting.SystemSettingManager;\n+import org.hisp.dhis.util.Timer;\n+import org.springframework.stereotype.Component;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * This component is responsible for handling and retrieving data based on the\n+ * input provided to the public methods. The main goal is to correctly populate\n+ * the data into the Grid object.\n+ */\n+@Slf4j\n+@Component\n+public class DataHandler\n+{\n+\n+    private static final int MAX_QUERIES = 8;\n+\n+    private static final int PERCENT = 100;\n+\n+    private final EventAnalyticsService eventAnalyticsService;\n+\n+    private final RawAnalyticsManager rawAnalyticsManager;\n+\n+    private final ConstantService constantService;\n+\n+    private final ExpressionResolver resolver;\n+\n+    private final ExpressionService expressionService;\n+\n+    private final QueryPlanner queryPlanner;\n+\n+    private final QueryValidator queryValidator;\n+\n+    private final SystemSettingManager systemSettingManager;\n+\n+    private final AnalyticsManager analyticsManager;\n+\n+    private final OrganisationUnitService organisationUnitService;\n+\n+    private DataAggregator dataAggregator;\n+\n+    public DataHandler( EventAnalyticsService eventAnalyticsService, RawAnalyticsManager rawAnalyticsManager,\n+        ConstantService constantService, ExpressionResolver resolver, ExpressionService expressionService,\n+        QueryPlanner queryPlanner, QueryValidator queryValidator, SystemSettingManager systemSettingManager,\n+        AnalyticsManager analyticsManager, OrganisationUnitService organisationUnitService )\n+    {\n+        checkNotNull( eventAnalyticsService );\n+        checkNotNull( rawAnalyticsManager );\n+        checkNotNull( constantService );\n+        checkNotNull( resolver );\n+        checkNotNull( expressionService );\n+        checkNotNull( queryPlanner );\n+        checkNotNull( queryValidator );\n+        checkNotNull( systemSettingManager );\n+        checkNotNull( analyticsManager );\n+        checkNotNull( organisationUnitService );\n+\n+        this.eventAnalyticsService = eventAnalyticsService;\n+        this.rawAnalyticsManager = rawAnalyticsManager;\n+        this.constantService = constantService;\n+        this.resolver = resolver;\n+        this.expressionService = expressionService;\n+        this.queryPlanner = queryPlanner;\n+        this.queryValidator = queryValidator;\n+        this.systemSettingManager = systemSettingManager;\n+        this.analyticsManager = analyticsManager;\n+        this.organisationUnitService = organisationUnitService;\n+    }\n+\n+    /**\n+     * Adds indicator values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getIndicators().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( INDICATOR )\n+                .withIncludeNumDen( false ).build();\n+\n+            List<Indicator> indicators = asTypedList( dataSourceParams.getIndicators() );\n+\n+            List<Period> filterPeriods = dataSourceParams.getTypedFilterPeriods();\n+\n+            Map<String, Constant> constantMap = constantService.getConstantMap();\n+\n+            // -----------------------------------------------------------------\n+            // Get indicator values\n+            // -----------------------------------------------------------------\n+\n+            Map<String, Map<String, Integer>> permutationOrgUnitTargetMap = getOrgUnitTargetMap( dataSourceParams,\n+                indicators );\n+\n+            List<List<DimensionItem>> dimensionItemPermutations = dataSourceParams.getDimensionItemPermutations();\n+\n+            Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap = getPermutationDimensionItemValueMap(\n+                dataSourceParams );\n+\n+            handleEmptyDimensionItemPermutations( dimensionItemPermutations );\n+\n+            for ( Indicator indicator : indicators )\n+            {\n+                for ( List<DimensionItem> dimensionItems : dimensionItemPermutations )\n+                {\n+                    IndicatorValue value = getIndicatorValue( filterPeriods, constantMap, permutationOrgUnitTargetMap,\n+                        permutationDimensionItemValueMap, indicator, dimensionItems );\n+\n+                    addIndicatorValuesToGrid( params, grid, dataSourceParams, indicator, dimensionItems, value );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Based on the given Indicator plus additional parameters, this method will\n+     * find the respective IndicatorValue.\n+     * \n+     * @param filterPeriods\n+     * @param constantMap\n+     * @param permutationOrgUnitTargetMap\n+     * @param permutationDimensionItemValueMap\n+     * @param indicator\n+     * @param dimensionItems\n+     * @return the IndicatorValue\n+     */\n+    private IndicatorValue getIndicatorValue( List<Period> filterPeriods, Map<String, Constant> constantMap,\n+        Map<String, Map<String, Integer>> permutationOrgUnitTargetMap,\n+        Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap, Indicator indicator,\n+        List<DimensionItem> dimensionItems )\n+    {\n+        String permKey = asItemKey( dimensionItems );\n+\n+        final List<DimensionItemObjectValue> valueMap = permutationDimensionItemValueMap\n+            .getOrDefault( permKey, new ArrayList<>() );\n+\n+        List<Period> periods = !filterPeriods.isEmpty() ? filterPeriods\n+            : singletonList( (Period) getPeriodItem( dimensionItems ) );\n+\n+        OrganisationUnit unit = (OrganisationUnit) getOrganisationUnitItem( dimensionItems );\n+\n+        String ou = unit != null ? unit.getUid() : null;\n+\n+        Map<String, Integer> orgUnitCountMap = permutationOrgUnitTargetMap != null\n+            ? permutationOrgUnitTargetMap.get( ou )\n+            : null;\n+\n+        return expressionService.getIndicatorValueObject( indicator, periods,\n+            convertToDimItemValueMap( valueMap ), constantMap, orgUnitCountMap );\n+    }\n+\n+    /**\n+     * Adds data element values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDataElementValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getAllDataElements().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( DATA_ELEMENT )\n+                .withIncludeNumDen( false ).build();\n+\n+            Map<String, Object> aggregatedDataMap = getAggregatedDataValueMapObjectTyped( dataSourceParams );\n+\n+            for ( Map.Entry<String, Object> entry : aggregatedDataMap.entrySet() )\n+            {\n+                Object value = getRoundedValueObject( params, entry.getValue() );\n+\n+                grid.addRow()\n+                    .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                    .addValue( value );\n+\n+                if ( params.isIncludeNumDen() )\n+                {\n+                    grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds program data element values to the given grid based on the given data\n+     * query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addProgramDataElementAttributeIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( (!params.getAllProgramDataElementsAndAttributes().isEmpty() || !params.getProgramIndicators().isEmpty())\n+            && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimensions( PROGRAM_DATA_ELEMENT, PROGRAM_ATTRIBUTE, PROGRAM_INDICATOR ).build();\n+\n+            EventQueryParams eventQueryParams = new EventQueryParams.Builder( fromDataQueryParams( dataSourceParams ) )\n+                .withSkipMeta( true ).build();\n+\n+            Grid eventGrid = eventAnalyticsService.getAggregatedEventData( eventQueryParams );\n+\n+            grid.addRows( eventGrid );\n+        }\n+    }\n+\n+    /**\n+     * Adds reporting rates to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addReportingRates( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getReportingRates().isEmpty() && !params.isSkipData() )\n+        {\n+            for ( ReportingRateMetric metric : ReportingRateMetric.values() )\n+            {\n+                DataQueryParams dataSourceParams = newBuilder( params )\n+                    .retainDataDimensionReportingRates( metric )\n+                    .ignoreDataApproval() // No approval for reporting rates\n+                    .withAggregationType( COUNT )\n+                    .withTimely( (REPORTING_RATE_ON_TIME == metric || ACTUAL_REPORTS_ON_TIME == metric) ).build();\n+\n+                addReportingRates( dataSourceParams, grid, metric );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds data element operand values to the given grid based on the given data\n+     * query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDataElementOperandValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getDataElementOperands().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( DATA_ELEMENT_OPERAND ).build();\n+\n+            for ( TotalType type : values() )\n+            {\n+                addDataElementOperandValues( dataSourceParams, grid, type );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds values to the given grid based on dynamic dimensions from the given data\n+     * query parameters. This assumes that no fixed dimensions are part of the\n+     * query.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDynamicDimensionValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( params.getDataDimensionAndFilterOptions().isEmpty() && !params.isSkipData() )\n+        {\n+            Map<String, Double> aggregatedDataMap = getAggregatedDataValueMap( newBuilder( params )\n+                .withIncludeNumDen( false ).build() );\n+\n+            fillGridWithAggregatedDataMap( params, grid, aggregatedDataMap );\n+        }\n+    }\n+\n+    /**\n+     * Adds validation results to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addValidationResultValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getAllValidationResults().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( VALIDATION_RULE )\n+                .withAggregationType( COUNT )\n+                .withIncludeNumDen( false ).build();\n+\n+            Map<String, Double> aggregatedDataMap = getAggregatedValidationResultMapObjectTyped( dataSourceParams );\n+\n+            fillGridWithAggregatedDataMap( params, grid, aggregatedDataMap );\n+        }\n+    }\n+\n+    /**\n+     * Adds raw data to the grid for the given data query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addRawData( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.isSkipData() )\n+        {\n+            QueryPlannerParams plannerParams = QueryPlannerParams.newBuilder()\n+                .withTableType( DATA_VALUE ).build();\n+\n+            params = queryPlanner.withTableNameAndPartitions( params, plannerParams );\n+\n+            rawAnalyticsManager.getRawDataValues( params, grid );\n+        }\n+    }\n+\n+    /**\n+     * Prepares the given data query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     */\n+    DataQueryParams prepareForRawDataQuery( DataQueryParams params )\n+    {\n+        DataQueryParams.Builder builder = newBuilder( params )\n+            .withEarliestStartDateLatestEndDate()\n+            .withPeriodDimensionWithoutOptions()\n+            .withIncludePeriodStartEndDates( true );\n+\n+        if ( params.isShowHierarchy() )\n+        {\n+            builder.withOrgUnitLevels( organisationUnitService.getFilledOrganisationUnitLevels() );\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Generates a mapping between the count of a validation result.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between validation results and counts of them\n+     */\n+    private Map<String, Double> getAggregatedValidationResultMapObjectTyped( DataQueryParams params )\n+    {\n+        return getDoubleMap( getAggregatedValueMap( params, VALIDATION_RESULT, newArrayList() ) );\n+    }\n+\n+    /**\n+     * Fill grid with aggregated data map with key and value\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid\n+     * @param aggregatedDataMap the aggregated data map\n+     */\n+    private void fillGridWithAggregatedDataMap( DataQueryParams params, Grid grid,\n+        Map<String, Double> aggregatedDataMap )\n+    {\n+        for ( Map.Entry<String, Double> entry : aggregatedDataMap.entrySet() )\n+        {\n+            Double value = params.isSkipRounding() ? entry.getValue() : getRounded( entry.getValue() );\n+\n+            grid.addRow()\n+                .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                .addValue( value );\n+\n+            if ( params.isIncludeNumDen() )\n+            {\n+                grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds reporting rates to the given grid based on the given data query\n+     * parameters and reporting rate metric.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     * @param metric the reporting rate metric.\n+     */\n+    private void addReportingRates( DataQueryParams params, Grid grid, ReportingRateMetric metric )\n+    {\n+        if ( !params.getReportingRates().isEmpty() && !params.isSkipData() )\n+        {\n+            if ( !COMPLETENESS_DIMENSION_TYPES.containsAll( params.getDimensionTypes() ) )\n+            {\n+                return;\n+            }\n+\n+            DataQueryParams targetParams = newBuilder( params )\n+                .withSkipPartitioning( true )\n+                .withTimely( false )\n+                .withRestrictByOrgUnitOpeningClosedDate( true )\n+                .withRestrictByCategoryOptionStartEndDate( true )\n+                .withAggregationType( SUM ).build();\n+\n+            Map<String, Double> targetMap = getAggregatedCompletenessTargetMap( targetParams );\n+\n+            Map<String, Double> dataMap = metric != EXPECTED_REPORTS\n+                ? getAggregatedCompletenessValueMap( params )\n+                : new HashMap<>();\n+\n+            Integer periodIndex = params.getPeriodDimensionIndex();\n+            Integer dataSetIndex = DX_INDEX;\n+            Map<String, PeriodType> dsPtMap = params.getDataSetPeriodTypeMap();\n+            PeriodType filterPeriodType = params.getFilterPeriodType();\n+\n+            int timeUnits = getTimeUnits( params );\n+\n+            for ( Map.Entry<String, Double> entry : targetMap.entrySet() )\n+            {\n+                List<String> dataRow = newArrayList( entry.getKey().split( DIMENSION_SEP ) );\n+\n+                Double target = entry.getValue();\n+                Double actual = firstNonNull( dataMap.get( entry.getKey() ), 0d );\n+\n+                if ( target != null )\n+                {\n+                    // ---------------------------------------------------------\n+                    // Multiply target value by number of periods in time span\n+                    // ---------------------------------------------------------\n+\n+                    PeriodType queryPt = filterPeriodType != null ? filterPeriodType\n+                        : getPeriodTypeFromIsoString( dataRow.get( periodIndex ) );\n+                    PeriodType dataSetPt = dsPtMap.get( dataRow.get( dataSetIndex ) );\n+\n+                    target = getCalculatedTarget( periodIndex, timeUnits, dataRow, target, queryPt, dataSetPt );\n+\n+                    addReportRateToGrid( params, grid, metric, dataRow, target, actual );\n+                }\n+            }\n+        }\n+    }\n+\n+    private int getTimeUnits( DataQueryParams params )\n+    {\n+        return params.hasFilter( PERIOD_DIM_ID ) ? params.getFilterPeriods().size() : 1;\n+    }\n+\n+    /**\n+     * Calculate reporting rate and replace data set with rate and add the rate to\n+     * the Grid.\n+     * \n+     * @param params", "originalCommit": "1c656fcb31616a11eeee7e18ae96874dd5cb7bb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMTQ2Nw==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464211467", "bodyText": "Add missing javadoc for the method arguments or remove @param", "author": "luciano-fiandesio", "createdAt": "2020-08-03T06:10:23Z", "path": "dhis-2/dhis-services/dhis-service-analytics/src/main/java/org/hisp/dhis/analytics/data/handling/DataHandler.java", "diffHunk": "@@ -0,0 +1,1161 @@\n+package org.hisp.dhis.analytics.data.handling;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static java.lang.Math.min;\n+import static java.util.Collections.singletonList;\n+import static org.apache.commons.collections4.CollectionUtils.isEmpty;\n+import static org.apache.commons.lang3.ArrayUtils.remove;\n+import static org.apache.commons.lang3.StringUtils.join;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.COUNT;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.SUM;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.DATA_VALUE;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.ORG_UNIT_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.VALIDATION_RESULT;\n+import static org.hisp.dhis.analytics.DataQueryParams.COMPLETENESS_DIMENSION_TYPES;\n+import static org.hisp.dhis.analytics.DataQueryParams.DISPLAY_NAME_DATA_X;\n+import static org.hisp.dhis.analytics.DataQueryParams.DX_INDEX;\n+import static org.hisp.dhis.analytics.DataQueryParams.NUMERATOR_DENOMINATOR_PROPERTIES_COUNT;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationDimensionalItemValueMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationOrgUnitGroupCountMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.newBuilder;\n+import static org.hisp.dhis.analytics.DimensionItem.asItemKey;\n+import static org.hisp.dhis.analytics.DimensionItem.getItemIdentifiers;\n+import static org.hisp.dhis.analytics.DimensionItem.getOrganisationUnitItem;\n+import static org.hisp.dhis.analytics.DimensionItem.getPeriodItem;\n+import static org.hisp.dhis.analytics.OutputFormat.ANALYTICS;\n+import static org.hisp.dhis.analytics.event.EventQueryParams.fromDataQueryParams;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.convertDxToOperand;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.findDimensionalItems;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getDoubleMap;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValue;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValueObject;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.hasPeriod;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.isPeriodInPeriods;\n+import static org.hisp.dhis.analytics.util.PeriodOffsetUtils.getPeriodOffsetRow;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT_OPERAND;\n+import static org.hisp.dhis.common.DataDimensionItemType.INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_ATTRIBUTE;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.VALIDATION_RULE;\n+import static org.hisp.dhis.common.DimensionType.ATTRIBUTE_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.CATEGORY_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.DATA_X;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT_GROUP;\n+import static org.hisp.dhis.common.DimensionalObject.ATTRIBUTEOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.CATEGORYOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DATA_X_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DIMENSION_SEP;\n+import static org.hisp.dhis.common.DimensionalObject.ORGUNIT_GROUP_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.PERIOD_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.asTypedList;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.convertToDimItemValueMap;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getAttributeOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getCategoryOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDataElements;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDimensionItem;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.replaceOperandTotalsWithDataElements;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS_ON_TIME;\n+import static org.hisp.dhis.common.ReportingRateMetric.EXPECTED_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.REPORTING_RATE_ON_TIME;\n+import static org.hisp.dhis.commons.util.DebugUtils.getStackTrace;\n+import static org.hisp.dhis.commons.util.SystemUtils.getCpuCores;\n+import static org.hisp.dhis.dataelement.DataElementOperand.TotalType.values;\n+import static org.hisp.dhis.period.DailyPeriodType.NAME;\n+import static org.hisp.dhis.period.PeriodType.getPeriodFromIsoString;\n+import static org.hisp.dhis.period.PeriodType.getPeriodTypeFromIsoString;\n+import static org.hisp.dhis.setting.SettingKey.ANALYTICS_MAX_LIMIT;\n+import static org.hisp.dhis.setting.SettingKey.DATABASE_SERVER_CPUS;\n+import static org.hisp.dhis.system.util.MathUtils.getRounded;\n+import static org.hisp.dhis.system.util.MathUtils.getWithin;\n+import static org.hisp.dhis.system.util.MathUtils.isZero;\n+import static org.hisp.dhis.util.ObjectUtils.firstNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.hisp.dhis.analytics.AnalyticsManager;\n+import org.hisp.dhis.analytics.AnalyticsTableType;\n+import org.hisp.dhis.analytics.DataQueryGroups;\n+import org.hisp.dhis.analytics.DataQueryParams;\n+import org.hisp.dhis.analytics.DimensionItem;\n+import org.hisp.dhis.analytics.QueryPlanner;\n+import org.hisp.dhis.analytics.QueryPlannerParams;\n+import org.hisp.dhis.analytics.QueryValidator;\n+import org.hisp.dhis.analytics.RawAnalyticsManager;\n+import org.hisp.dhis.analytics.event.EventAnalyticsService;\n+import org.hisp.dhis.analytics.event.EventQueryParams;\n+import org.hisp.dhis.analytics.resolver.ExpressionResolver;\n+import org.hisp.dhis.common.BaseDimensionalObject;\n+import org.hisp.dhis.common.DimensionItemObjectValue;\n+import org.hisp.dhis.common.DimensionalItemObject;\n+import org.hisp.dhis.common.DimensionalObject;\n+import org.hisp.dhis.common.Grid;\n+import org.hisp.dhis.common.ReportingRateMetric;\n+import org.hisp.dhis.constant.Constant;\n+import org.hisp.dhis.constant.ConstantService;\n+import org.hisp.dhis.dataelement.DataElementOperand;\n+import org.hisp.dhis.dataelement.DataElementOperand.TotalType;\n+import org.hisp.dhis.expression.ExpressionService;\n+import org.hisp.dhis.indicator.Indicator;\n+import org.hisp.dhis.indicator.IndicatorValue;\n+import org.hisp.dhis.organisationunit.OrganisationUnit;\n+import org.hisp.dhis.organisationunit.OrganisationUnitGroup;\n+import org.hisp.dhis.organisationunit.OrganisationUnitService;\n+import org.hisp.dhis.period.Period;\n+import org.hisp.dhis.period.PeriodType;\n+import org.hisp.dhis.setting.SystemSettingManager;\n+import org.hisp.dhis.util.Timer;\n+import org.springframework.stereotype.Component;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * This component is responsible for handling and retrieving data based on the\n+ * input provided to the public methods. The main goal is to correctly populate\n+ * the data into the Grid object.\n+ */\n+@Slf4j\n+@Component\n+public class DataHandler\n+{\n+\n+    private static final int MAX_QUERIES = 8;\n+\n+    private static final int PERCENT = 100;\n+\n+    private final EventAnalyticsService eventAnalyticsService;\n+\n+    private final RawAnalyticsManager rawAnalyticsManager;\n+\n+    private final ConstantService constantService;\n+\n+    private final ExpressionResolver resolver;\n+\n+    private final ExpressionService expressionService;\n+\n+    private final QueryPlanner queryPlanner;\n+\n+    private final QueryValidator queryValidator;\n+\n+    private final SystemSettingManager systemSettingManager;\n+\n+    private final AnalyticsManager analyticsManager;\n+\n+    private final OrganisationUnitService organisationUnitService;\n+\n+    private DataAggregator dataAggregator;\n+\n+    public DataHandler( EventAnalyticsService eventAnalyticsService, RawAnalyticsManager rawAnalyticsManager,\n+        ConstantService constantService, ExpressionResolver resolver, ExpressionService expressionService,\n+        QueryPlanner queryPlanner, QueryValidator queryValidator, SystemSettingManager systemSettingManager,\n+        AnalyticsManager analyticsManager, OrganisationUnitService organisationUnitService )\n+    {\n+        checkNotNull( eventAnalyticsService );\n+        checkNotNull( rawAnalyticsManager );\n+        checkNotNull( constantService );\n+        checkNotNull( resolver );\n+        checkNotNull( expressionService );\n+        checkNotNull( queryPlanner );\n+        checkNotNull( queryValidator );\n+        checkNotNull( systemSettingManager );\n+        checkNotNull( analyticsManager );\n+        checkNotNull( organisationUnitService );\n+\n+        this.eventAnalyticsService = eventAnalyticsService;\n+        this.rawAnalyticsManager = rawAnalyticsManager;\n+        this.constantService = constantService;\n+        this.resolver = resolver;\n+        this.expressionService = expressionService;\n+        this.queryPlanner = queryPlanner;\n+        this.queryValidator = queryValidator;\n+        this.systemSettingManager = systemSettingManager;\n+        this.analyticsManager = analyticsManager;\n+        this.organisationUnitService = organisationUnitService;\n+    }\n+\n+    /**\n+     * Adds indicator values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getIndicators().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( INDICATOR )\n+                .withIncludeNumDen( false ).build();\n+\n+            List<Indicator> indicators = asTypedList( dataSourceParams.getIndicators() );\n+\n+            List<Period> filterPeriods = dataSourceParams.getTypedFilterPeriods();\n+\n+            Map<String, Constant> constantMap = constantService.getConstantMap();\n+\n+            // -----------------------------------------------------------------\n+            // Get indicator values\n+            // -----------------------------------------------------------------\n+\n+            Map<String, Map<String, Integer>> permutationOrgUnitTargetMap = getOrgUnitTargetMap( dataSourceParams,\n+                indicators );\n+\n+            List<List<DimensionItem>> dimensionItemPermutations = dataSourceParams.getDimensionItemPermutations();\n+\n+            Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap = getPermutationDimensionItemValueMap(\n+                dataSourceParams );\n+\n+            handleEmptyDimensionItemPermutations( dimensionItemPermutations );\n+\n+            for ( Indicator indicator : indicators )\n+            {\n+                for ( List<DimensionItem> dimensionItems : dimensionItemPermutations )\n+                {\n+                    IndicatorValue value = getIndicatorValue( filterPeriods, constantMap, permutationOrgUnitTargetMap,\n+                        permutationDimensionItemValueMap, indicator, dimensionItems );\n+\n+                    addIndicatorValuesToGrid( params, grid, dataSourceParams, indicator, dimensionItems, value );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Based on the given Indicator plus additional parameters, this method will\n+     * find the respective IndicatorValue.\n+     * \n+     * @param filterPeriods\n+     * @param constantMap\n+     * @param permutationOrgUnitTargetMap\n+     * @param permutationDimensionItemValueMap\n+     * @param indicator\n+     * @param dimensionItems\n+     * @return the IndicatorValue\n+     */\n+    private IndicatorValue getIndicatorValue( List<Period> filterPeriods, Map<String, Constant> constantMap,\n+        Map<String, Map<String, Integer>> permutationOrgUnitTargetMap,\n+        Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap, Indicator indicator,\n+        List<DimensionItem> dimensionItems )\n+    {\n+        String permKey = asItemKey( dimensionItems );\n+\n+        final List<DimensionItemObjectValue> valueMap = permutationDimensionItemValueMap\n+            .getOrDefault( permKey, new ArrayList<>() );\n+\n+        List<Period> periods = !filterPeriods.isEmpty() ? filterPeriods\n+            : singletonList( (Period) getPeriodItem( dimensionItems ) );\n+\n+        OrganisationUnit unit = (OrganisationUnit) getOrganisationUnitItem( dimensionItems );\n+\n+        String ou = unit != null ? unit.getUid() : null;\n+\n+        Map<String, Integer> orgUnitCountMap = permutationOrgUnitTargetMap != null\n+            ? permutationOrgUnitTargetMap.get( ou )\n+            : null;\n+\n+        return expressionService.getIndicatorValueObject( indicator, periods,\n+            convertToDimItemValueMap( valueMap ), constantMap, orgUnitCountMap );\n+    }\n+\n+    /**\n+     * Adds data element values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDataElementValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getAllDataElements().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( DATA_ELEMENT )\n+                .withIncludeNumDen( false ).build();\n+\n+            Map<String, Object> aggregatedDataMap = getAggregatedDataValueMapObjectTyped( dataSourceParams );\n+\n+            for ( Map.Entry<String, Object> entry : aggregatedDataMap.entrySet() )\n+            {\n+                Object value = getRoundedValueObject( params, entry.getValue() );\n+\n+                grid.addRow()\n+                    .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                    .addValue( value );\n+\n+                if ( params.isIncludeNumDen() )\n+                {\n+                    grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds program data element values to the given grid based on the given data\n+     * query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addProgramDataElementAttributeIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( (!params.getAllProgramDataElementsAndAttributes().isEmpty() || !params.getProgramIndicators().isEmpty())\n+            && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimensions( PROGRAM_DATA_ELEMENT, PROGRAM_ATTRIBUTE, PROGRAM_INDICATOR ).build();\n+\n+            EventQueryParams eventQueryParams = new EventQueryParams.Builder( fromDataQueryParams( dataSourceParams ) )\n+                .withSkipMeta( true ).build();\n+\n+            Grid eventGrid = eventAnalyticsService.getAggregatedEventData( eventQueryParams );\n+\n+            grid.addRows( eventGrid );\n+        }\n+    }\n+\n+    /**\n+     * Adds reporting rates to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addReportingRates( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getReportingRates().isEmpty() && !params.isSkipData() )\n+        {\n+            for ( ReportingRateMetric metric : ReportingRateMetric.values() )\n+            {\n+                DataQueryParams dataSourceParams = newBuilder( params )\n+                    .retainDataDimensionReportingRates( metric )\n+                    .ignoreDataApproval() // No approval for reporting rates\n+                    .withAggregationType( COUNT )\n+                    .withTimely( (REPORTING_RATE_ON_TIME == metric || ACTUAL_REPORTS_ON_TIME == metric) ).build();\n+\n+                addReportingRates( dataSourceParams, grid, metric );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds data element operand values to the given grid based on the given data\n+     * query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDataElementOperandValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getDataElementOperands().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( DATA_ELEMENT_OPERAND ).build();\n+\n+            for ( TotalType type : values() )\n+            {\n+                addDataElementOperandValues( dataSourceParams, grid, type );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds values to the given grid based on dynamic dimensions from the given data\n+     * query parameters. This assumes that no fixed dimensions are part of the\n+     * query.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDynamicDimensionValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( params.getDataDimensionAndFilterOptions().isEmpty() && !params.isSkipData() )\n+        {\n+            Map<String, Double> aggregatedDataMap = getAggregatedDataValueMap( newBuilder( params )\n+                .withIncludeNumDen( false ).build() );\n+\n+            fillGridWithAggregatedDataMap( params, grid, aggregatedDataMap );\n+        }\n+    }\n+\n+    /**\n+     * Adds validation results to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addValidationResultValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getAllValidationResults().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( VALIDATION_RULE )\n+                .withAggregationType( COUNT )\n+                .withIncludeNumDen( false ).build();\n+\n+            Map<String, Double> aggregatedDataMap = getAggregatedValidationResultMapObjectTyped( dataSourceParams );\n+\n+            fillGridWithAggregatedDataMap( params, grid, aggregatedDataMap );\n+        }\n+    }\n+\n+    /**\n+     * Adds raw data to the grid for the given data query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addRawData( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.isSkipData() )\n+        {\n+            QueryPlannerParams plannerParams = QueryPlannerParams.newBuilder()\n+                .withTableType( DATA_VALUE ).build();\n+\n+            params = queryPlanner.withTableNameAndPartitions( params, plannerParams );\n+\n+            rawAnalyticsManager.getRawDataValues( params, grid );\n+        }\n+    }\n+\n+    /**\n+     * Prepares the given data query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     */\n+    DataQueryParams prepareForRawDataQuery( DataQueryParams params )\n+    {\n+        DataQueryParams.Builder builder = newBuilder( params )\n+            .withEarliestStartDateLatestEndDate()\n+            .withPeriodDimensionWithoutOptions()\n+            .withIncludePeriodStartEndDates( true );\n+\n+        if ( params.isShowHierarchy() )\n+        {\n+            builder.withOrgUnitLevels( organisationUnitService.getFilledOrganisationUnitLevels() );\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Generates a mapping between the count of a validation result.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between validation results and counts of them\n+     */\n+    private Map<String, Double> getAggregatedValidationResultMapObjectTyped( DataQueryParams params )\n+    {\n+        return getDoubleMap( getAggregatedValueMap( params, VALIDATION_RESULT, newArrayList() ) );\n+    }\n+\n+    /**\n+     * Fill grid with aggregated data map with key and value\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid\n+     * @param aggregatedDataMap the aggregated data map\n+     */\n+    private void fillGridWithAggregatedDataMap( DataQueryParams params, Grid grid,\n+        Map<String, Double> aggregatedDataMap )\n+    {\n+        for ( Map.Entry<String, Double> entry : aggregatedDataMap.entrySet() )\n+        {\n+            Double value = params.isSkipRounding() ? entry.getValue() : getRounded( entry.getValue() );\n+\n+            grid.addRow()\n+                .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                .addValue( value );\n+\n+            if ( params.isIncludeNumDen() )\n+            {\n+                grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds reporting rates to the given grid based on the given data query\n+     * parameters and reporting rate metric.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     * @param metric the reporting rate metric.\n+     */\n+    private void addReportingRates( DataQueryParams params, Grid grid, ReportingRateMetric metric )\n+    {\n+        if ( !params.getReportingRates().isEmpty() && !params.isSkipData() )\n+        {\n+            if ( !COMPLETENESS_DIMENSION_TYPES.containsAll( params.getDimensionTypes() ) )\n+            {\n+                return;\n+            }\n+\n+            DataQueryParams targetParams = newBuilder( params )\n+                .withSkipPartitioning( true )\n+                .withTimely( false )\n+                .withRestrictByOrgUnitOpeningClosedDate( true )\n+                .withRestrictByCategoryOptionStartEndDate( true )\n+                .withAggregationType( SUM ).build();\n+\n+            Map<String, Double> targetMap = getAggregatedCompletenessTargetMap( targetParams );\n+\n+            Map<String, Double> dataMap = metric != EXPECTED_REPORTS\n+                ? getAggregatedCompletenessValueMap( params )\n+                : new HashMap<>();\n+\n+            Integer periodIndex = params.getPeriodDimensionIndex();\n+            Integer dataSetIndex = DX_INDEX;\n+            Map<String, PeriodType> dsPtMap = params.getDataSetPeriodTypeMap();\n+            PeriodType filterPeriodType = params.getFilterPeriodType();\n+\n+            int timeUnits = getTimeUnits( params );\n+\n+            for ( Map.Entry<String, Double> entry : targetMap.entrySet() )\n+            {\n+                List<String> dataRow = newArrayList( entry.getKey().split( DIMENSION_SEP ) );\n+\n+                Double target = entry.getValue();\n+                Double actual = firstNonNull( dataMap.get( entry.getKey() ), 0d );\n+\n+                if ( target != null )\n+                {\n+                    // ---------------------------------------------------------\n+                    // Multiply target value by number of periods in time span\n+                    // ---------------------------------------------------------\n+\n+                    PeriodType queryPt = filterPeriodType != null ? filterPeriodType\n+                        : getPeriodTypeFromIsoString( dataRow.get( periodIndex ) );\n+                    PeriodType dataSetPt = dsPtMap.get( dataRow.get( dataSetIndex ) );\n+\n+                    target = getCalculatedTarget( periodIndex, timeUnits, dataRow, target, queryPt, dataSetPt );\n+\n+                    addReportRateToGrid( params, grid, metric, dataRow, target, actual );\n+                }\n+            }\n+        }\n+    }\n+\n+    private int getTimeUnits( DataQueryParams params )\n+    {\n+        return params.hasFilter( PERIOD_DIM_ID ) ? params.getFilterPeriods().size() : 1;\n+    }\n+\n+    /**\n+     * Calculate reporting rate and replace data set with rate and add the rate to\n+     * the Grid.\n+     * \n+     * @param params\n+     * @param grid\n+     * @param metric\n+     * @param dataRow\n+     * @param target\n+     * @param actual\n+     */\n+    private void addReportRateToGrid( DataQueryParams params, Grid grid, ReportingRateMetric metric,\n+        List<String> dataRow, Double target, Double actual )\n+    {\n+        Double value = getReportRate( metric, target, actual );\n+\n+        String reportingRate = getDimensionItem( dataRow.get( DX_INDEX ), metric );\n+        dataRow.set( DX_INDEX, reportingRate );\n+\n+        grid.addRow()\n+            .addValues( dataRow.toArray() )\n+            .addValue( params.isSkipRounding() ? value : getRounded( value ) );\n+\n+        if ( params.isIncludeNumDen() )\n+        {\n+            grid.addValue( actual )\n+                .addValue( target )\n+                .addValue( PERCENT )\n+                .addNullValues( 2 );\n+        }\n+    }\n+\n+    /**\n+     * Use number of days for daily data sets as target, as query periods might\n+     * often span/contain different numbers of days.\n+     * \n+     * @param periodIndex\n+     * @param timeUnits\n+     * @param dataRow\n+     * @param target\n+     * @param queryPt\n+     * @param dataSetPt\n+     * @return the calculate target\n+     */\n+    private Double getCalculatedTarget( Integer periodIndex, int timeUnits, List<String> dataRow, Double target,\n+        PeriodType queryPt, PeriodType dataSetPt )\n+    {\n+        if ( dataSetPt.equalsName( NAME ) )\n+        {\n+            Period period = getPeriodFromIsoString( dataRow.get( periodIndex ) );\n+            target = target * period.getDaysInPeriod() * timeUnits;\n+        }\n+        else\n+        {\n+            target = target * queryPt.getPeriodSpan( dataSetPt ) * timeUnits;\n+        }\n+        return target;\n+    }\n+\n+    private Double getReportRate( ReportingRateMetric metric, Double target, Double actual )\n+    {\n+        Double value = 0d;\n+\n+        if ( EXPECTED_REPORTS == metric )\n+        {\n+            value = target;\n+        }\n+        else if ( ACTUAL_REPORTS == metric || ACTUAL_REPORTS_ON_TIME == metric )\n+        {\n+            value = actual;\n+        }\n+        else if ( !isZero( target ) ) // REPORTING_RATE or REPORTING_RATE_ON_TIME\n+        {\n+            value = min( ((actual * PERCENT) / target), 100d );\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Generates aggregated values for the given query. Creates a mapping between a\n+     * dimension key and the aggregated value. The dimension key is a concatenation\n+     * of the identifiers of the dimension items separated by \"-\".\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between a dimension key and the aggregated value.\n+     */\n+    private Map<String, Double> getAggregatedCompletenessValueMap( DataQueryParams params )\n+    {\n+        return getDoubleMap( getAggregatedValueMap( params, COMPLETENESS, newArrayList() ) );\n+    }\n+\n+    /**\n+     * Generates a mapping between the the data set dimension key and the count of\n+     * expected data sets to report.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between the the data set dimension key and the count of\n+     *         expected data sets to report.\n+     */\n+    private Map<String, Double> getAggregatedCompletenessTargetMap( DataQueryParams params )\n+    {\n+        List<Function<DataQueryParams, List<DataQueryParams>>> queryGroupers = newArrayList();\n+        queryGroupers.add( q -> queryPlanner.groupByStartEndDateRestriction( q ) );\n+\n+        return getDoubleMap( getAggregatedValueMap( params, COMPLETENESS_TARGET, queryGroupers ) );\n+    }\n+\n+    /**\n+     * Adds data element operand values to the given grid.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     * @param totalType the operand {@link TotalType}.\n+     */\n+    private void addDataElementOperandValues( DataQueryParams params, Grid grid, TotalType totalType )\n+    {\n+        List<DataElementOperand> operands = asTypedList( params.getDataElementOperands() );\n+        operands = operands.stream().filter( o -> totalType.equals( o.getTotalType() ) ).collect( Collectors.toList() );\n+\n+        if ( operands.isEmpty() )\n+        {\n+            return;\n+        }\n+\n+        List<DimensionalItemObject> dataElements = newArrayList( getDataElements( operands ) );\n+        List<DimensionalItemObject> categoryOptionCombos = newArrayList( getCategoryOptionCombos( operands ) );\n+        List<DimensionalItemObject> attributeOptionCombos = newArrayList( getAttributeOptionCombos( operands ) );\n+\n+        // TODO Check if data was dim or filter\n+\n+        DataQueryParams.Builder builder = newBuilder( params )\n+            .removeDimension( DATA_X_DIM_ID )\n+            .addDimension( new BaseDimensionalObject( DATA_X_DIM_ID, DATA_X, dataElements ) );\n+\n+        if ( totalType.isCategoryOptionCombo() )\n+        {\n+            builder.addDimension( new BaseDimensionalObject( CATEGORYOPTIONCOMBO_DIM_ID,\n+                CATEGORY_OPTION_COMBO, categoryOptionCombos ) );\n+        }\n+\n+        if ( totalType.isAttributeOptionCombo() )\n+        {\n+            builder.addDimension( new BaseDimensionalObject( ATTRIBUTEOPTIONCOMBO_DIM_ID,\n+                ATTRIBUTE_OPTION_COMBO, attributeOptionCombos ) );\n+        }\n+\n+        DataQueryParams operandParams = builder.build();\n+\n+        Map<String, Object> aggregatedDataMap = getAggregatedDataValueMapObjectTyped( operandParams );\n+\n+        aggregatedDataMap = convertDxToOperand( aggregatedDataMap, totalType );\n+\n+        for ( Map.Entry<String, Object> entry : aggregatedDataMap.entrySet() )\n+        {\n+            Object value = getRoundedValueObject( operandParams, entry.getValue() );\n+\n+            grid.addRow()\n+                .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                .addValue( value );\n+\n+            if ( params.isIncludeNumDen() )\n+            {\n+                grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates aggregated values for the given query. Creates a mapping between a\n+     * dimension key and the aggregated value. The dimension key is a concatenation\n+     * of the identifiers of the dimension items separated by \"-\".\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between a dimension key and the aggregated value.\n+     */\n+    private Map<String, Object> getAggregatedDataValueMapObjectTyped( DataQueryParams params )\n+    {\n+        return getAggregatedValueMap( params, DATA_VALUE, newArrayList() );\n+    }\n+\n+    /**\n+     * Returns a mapping of permutation keys and mappings of data element operands\n+     * and values based on the given query.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     */\n+    private Map<String, List<DimensionItemObjectValue>> getPermutationDimensionItemValueMap( DataQueryParams params )\n+    {\n+        List<Indicator> indicators = asTypedList( params.getIndicators() );\n+\n+        return getPermutationDimensionalItemValueMap( getAggregatedDataValueMap( params, indicators ) );\n+    }\n+\n+    /**\n+     * Checks whether the measure criteria in query parameters is satisfied for the\n+     * given indicator value.\n+     *\n+     * @param params the query parameters.\n+     * @param value the indicator value.\n+     * @param indicator the indicator.\n+     * @return true if all the measure criteria are satisfied for this indicator\n+     *         value, false otherwise.\n+     */\n+    private boolean satisfiesMeasureCriteria( DataQueryParams params, IndicatorValue value, Indicator indicator )\n+    {\n+        if ( !params.hasMeasureCriteria() || value == null )\n+        {\n+            return true;\n+        }\n+\n+        Double indicatorRoundedValue = getRoundedValue( params, indicator.getDecimals(), value.getValue() )\n+            .doubleValue();\n+\n+        return !params.getMeasureCriteria().entrySet().stream()\n+            .anyMatch( measureValue -> !measureValue.getKey()\n+                .measureIsValid( indicatorRoundedValue, measureValue.getValue() ) );\n+    }\n+\n+    /**\n+     * Handles the case where there are no dimension item permutations by adding an\n+     * empty dimension item list to the permutations list. This state occurs where\n+     * there are only data or category option combo dimensions specified.\n+     *\n+     * @param dimensionItemPermutations list of dimension item permutations.\n+     */\n+    private void handleEmptyDimensionItemPermutations( List<List<DimensionItem>> dimensionItemPermutations )\n+    {\n+        if ( dimensionItemPermutations.isEmpty() )\n+        {\n+            dimensionItemPermutations.add( new ArrayList<>() );\n+        }\n+    }\n+\n+    /**\n+     * Generates a mapping of permutations keys (organisation unit id or null) and\n+     * mappings of organisation unit group and counts.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param indicators the indicators for which formulas to scan for organisation\n+     *        unit groups.\n+     * @return a map of maps.\n+     */\n+    private Map<String, Map<String, Integer>> getOrgUnitTargetMap( DataQueryParams params,\n+        Collection<Indicator> indicators )\n+    {\n+        Set<OrganisationUnitGroup> orgUnitGroups = expressionService.getIndicatorOrgUnitGroups( indicators );\n+\n+        if ( orgUnitGroups.isEmpty() )\n+        {\n+            return null;\n+        }\n+\n+        DataQueryParams orgUnitTargetParams = newBuilder( params )\n+            .pruneToDimensionType( ORGANISATION_UNIT )\n+            .addDimension( new BaseDimensionalObject( ORGUNIT_GROUP_DIM_ID,\n+                ORGANISATION_UNIT_GROUP, new ArrayList<DimensionalItemObject>( orgUnitGroups ) ) )\n+            .withOutputFormat( ANALYTICS )\n+            .withSkipPartitioning( true )\n+            .withSkipDataDimensionValidation( true )\n+            .build();\n+\n+        Map<String, Double> orgUnitCountMap = getAggregatedOrganisationUnitTargetMap( orgUnitTargetParams );\n+\n+        return getPermutationOrgUnitGroupCountMap( orgUnitCountMap );\n+    }\n+\n+    /**\n+     * Generates a mapping between the the organisation unit dimension key and the\n+     * count of organisation units inside the subtree of the given organisation\n+     * units and members of the given organisation unit groups.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between the the data set dimension key and the count of\n+     *         expected data sets to report.\n+     */\n+    private Map<String, Double> getAggregatedOrganisationUnitTargetMap( DataQueryParams params )\n+    {\n+        return getDoubleMap( getAggregatedValueMap( params, ORG_UNIT_TARGET, newArrayList() ) );\n+    }\n+\n+    /**\n+     * Resolves the numerator and denominator expressions of the given indicators.\n+     *\n+     * @param indicators the list of indicators.\n+     * @return the given list of indicators.\n+     */\n+    private List<Indicator> resolveIndicatorExpressions( List<Indicator> indicators )\n+    {\n+        for ( Indicator indicator : indicators )\n+        {\n+            indicator.setNumerator( resolver.resolve( indicator.getNumerator() ) );\n+            indicator.setDenominator( resolver.resolve( indicator.getDenominator() ) );\n+        }\n+\n+        return indicators;\n+    }\n+\n+    /**\n+     * Returns a mapping between dimension items and values for the given data query\n+     * and list of indicators. The dimensional items part of the indicator\n+     * numerators and denominators are used as dimensional item for the aggregated\n+     * values being retrieved. In case of circular references between Indicators, an\n+     * exception is thrown.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param indicators the list of indicators.\n+     * @return a dimensional items to aggregate values map.\n+     */\n+    private MultiValuedMap<String, DimensionItemObjectValue> getAggregatedDataValueMap( DataQueryParams params,\n+        List<Indicator> indicators )\n+    {\n+        List<DimensionalItemObject> items = newArrayList(\n+            expressionService.getIndicatorDimensionalItemObjects( resolveIndicatorExpressions( indicators ) ) );\n+\n+        if ( items.isEmpty() )\n+        {\n+            return new ArrayListValuedHashMap<>();\n+        }\n+\n+        items = replaceOperandTotalsWithDataElements( items );\n+\n+        DimensionalObject dimension = new BaseDimensionalObject( DATA_X_DIM_ID, DATA_X, null, DISPLAY_NAME_DATA_X,\n+            items );\n+\n+        DataQueryParams dataSourceParams = newBuilder( params )\n+            .replaceDimension( dimension )\n+            .withMeasureCriteria( new HashMap<>() )\n+            .withIncludeNumDen( false )\n+            .withSkipHeaders( true )\n+            .withOutputFormat( ANALYTICS )\n+            .withSkipMeta( true ).build();\n+\n+        // Each row in the Grid contains: dimension uid | period | value\n+        Grid grid = dataAggregator.getAggregatedDataValueGridInternal( dataSourceParams );\n+        MultiValuedMap<String, DimensionItemObjectValue> result = new ArrayListValuedHashMap<>();\n+\n+        if ( isEmpty( grid.getRows() ) )\n+        {\n+            return result;\n+        }\n+\n+        BiFunction<Integer, Integer, Integer> replaceIndexIfMissing = ( Integer index,\n+            Integer defaultIndex ) -> index == -1 ? defaultIndex : index;\n+\n+        final int dataIndex = replaceIndexIfMissing.apply( grid.getIndexOfHeader( DATA_X_DIM_ID ), 0 );\n+        final int periodIndex = replaceIndexIfMissing.apply( grid.getIndexOfHeader( PERIOD_DIM_ID ), 1 );\n+        final int valueIndex = grid.getWidth() - 1;\n+\n+        final List<DimensionalItemObject> basePeriods = params.getPeriods();\n+\n+        for ( List<Object> row : grid.getRows() )\n+        {\n+            final List<DimensionalItemObject> dimensionalItems = findDimensionalItems( (String) row.get( dataIndex ),\n+                items );\n+\n+            // Check if the current row's Period belongs to the list of periods from the\n+            // original Analytics request.\n+            // The row may not have a Period if Period is used as filter.\n+            if ( hasPeriod( row, periodIndex ) && isPeriodInPeriods( (String) row.get( periodIndex ), basePeriods ) )\n+            {\n+                if ( dimensionalItems.size() == 1 )\n+                {\n+                    addItemBasedOnPeriodOffset( grid, result, periodIndex, valueIndex, row, dimensionalItems );\n+                }\n+            }\n+            else\n+            {\n+                if ( dimensionalItems.size() == 1 )\n+                {\n+                    result.put( dimensionalItems.get( 0 ).getDimensionItem(),\n+                        new DimensionItemObjectValue( dimensionalItems.get( 0 ), (Double) row.get( valueIndex ) ) );\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Add the given Indicator values to the Grid.\n+     * \n+     * @param params", "originalCommit": "1c656fcb31616a11eeee7e18ae96874dd5cb7bb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMzc0MQ==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r465133741", "bodyText": "Done", "author": "maikelarabori", "createdAt": "2020-08-04T15:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMTQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMTUyMQ==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464211521", "bodyText": "Add missing javadoc for the method arguments or remove @param", "author": "luciano-fiandesio", "createdAt": "2020-08-03T06:10:36Z", "path": "dhis-2/dhis-services/dhis-service-analytics/src/main/java/org/hisp/dhis/analytics/data/handling/DataHandler.java", "diffHunk": "@@ -0,0 +1,1161 @@\n+package org.hisp.dhis.analytics.data.handling;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static java.lang.Math.min;\n+import static java.util.Collections.singletonList;\n+import static org.apache.commons.collections4.CollectionUtils.isEmpty;\n+import static org.apache.commons.lang3.ArrayUtils.remove;\n+import static org.apache.commons.lang3.StringUtils.join;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.COUNT;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.SUM;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.DATA_VALUE;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.ORG_UNIT_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.VALIDATION_RESULT;\n+import static org.hisp.dhis.analytics.DataQueryParams.COMPLETENESS_DIMENSION_TYPES;\n+import static org.hisp.dhis.analytics.DataQueryParams.DISPLAY_NAME_DATA_X;\n+import static org.hisp.dhis.analytics.DataQueryParams.DX_INDEX;\n+import static org.hisp.dhis.analytics.DataQueryParams.NUMERATOR_DENOMINATOR_PROPERTIES_COUNT;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationDimensionalItemValueMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationOrgUnitGroupCountMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.newBuilder;\n+import static org.hisp.dhis.analytics.DimensionItem.asItemKey;\n+import static org.hisp.dhis.analytics.DimensionItem.getItemIdentifiers;\n+import static org.hisp.dhis.analytics.DimensionItem.getOrganisationUnitItem;\n+import static org.hisp.dhis.analytics.DimensionItem.getPeriodItem;\n+import static org.hisp.dhis.analytics.OutputFormat.ANALYTICS;\n+import static org.hisp.dhis.analytics.event.EventQueryParams.fromDataQueryParams;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.convertDxToOperand;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.findDimensionalItems;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getDoubleMap;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValue;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValueObject;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.hasPeriod;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.isPeriodInPeriods;\n+import static org.hisp.dhis.analytics.util.PeriodOffsetUtils.getPeriodOffsetRow;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT_OPERAND;\n+import static org.hisp.dhis.common.DataDimensionItemType.INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_ATTRIBUTE;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.VALIDATION_RULE;\n+import static org.hisp.dhis.common.DimensionType.ATTRIBUTE_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.CATEGORY_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.DATA_X;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT_GROUP;\n+import static org.hisp.dhis.common.DimensionalObject.ATTRIBUTEOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.CATEGORYOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DATA_X_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DIMENSION_SEP;\n+import static org.hisp.dhis.common.DimensionalObject.ORGUNIT_GROUP_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.PERIOD_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.asTypedList;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.convertToDimItemValueMap;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getAttributeOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getCategoryOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDataElements;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDimensionItem;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.replaceOperandTotalsWithDataElements;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS_ON_TIME;\n+import static org.hisp.dhis.common.ReportingRateMetric.EXPECTED_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.REPORTING_RATE_ON_TIME;\n+import static org.hisp.dhis.commons.util.DebugUtils.getStackTrace;\n+import static org.hisp.dhis.commons.util.SystemUtils.getCpuCores;\n+import static org.hisp.dhis.dataelement.DataElementOperand.TotalType.values;\n+import static org.hisp.dhis.period.DailyPeriodType.NAME;\n+import static org.hisp.dhis.period.PeriodType.getPeriodFromIsoString;\n+import static org.hisp.dhis.period.PeriodType.getPeriodTypeFromIsoString;\n+import static org.hisp.dhis.setting.SettingKey.ANALYTICS_MAX_LIMIT;\n+import static org.hisp.dhis.setting.SettingKey.DATABASE_SERVER_CPUS;\n+import static org.hisp.dhis.system.util.MathUtils.getRounded;\n+import static org.hisp.dhis.system.util.MathUtils.getWithin;\n+import static org.hisp.dhis.system.util.MathUtils.isZero;\n+import static org.hisp.dhis.util.ObjectUtils.firstNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.hisp.dhis.analytics.AnalyticsManager;\n+import org.hisp.dhis.analytics.AnalyticsTableType;\n+import org.hisp.dhis.analytics.DataQueryGroups;\n+import org.hisp.dhis.analytics.DataQueryParams;\n+import org.hisp.dhis.analytics.DimensionItem;\n+import org.hisp.dhis.analytics.QueryPlanner;\n+import org.hisp.dhis.analytics.QueryPlannerParams;\n+import org.hisp.dhis.analytics.QueryValidator;\n+import org.hisp.dhis.analytics.RawAnalyticsManager;\n+import org.hisp.dhis.analytics.event.EventAnalyticsService;\n+import org.hisp.dhis.analytics.event.EventQueryParams;\n+import org.hisp.dhis.analytics.resolver.ExpressionResolver;\n+import org.hisp.dhis.common.BaseDimensionalObject;\n+import org.hisp.dhis.common.DimensionItemObjectValue;\n+import org.hisp.dhis.common.DimensionalItemObject;\n+import org.hisp.dhis.common.DimensionalObject;\n+import org.hisp.dhis.common.Grid;\n+import org.hisp.dhis.common.ReportingRateMetric;\n+import org.hisp.dhis.constant.Constant;\n+import org.hisp.dhis.constant.ConstantService;\n+import org.hisp.dhis.dataelement.DataElementOperand;\n+import org.hisp.dhis.dataelement.DataElementOperand.TotalType;\n+import org.hisp.dhis.expression.ExpressionService;\n+import org.hisp.dhis.indicator.Indicator;\n+import org.hisp.dhis.indicator.IndicatorValue;\n+import org.hisp.dhis.organisationunit.OrganisationUnit;\n+import org.hisp.dhis.organisationunit.OrganisationUnitGroup;\n+import org.hisp.dhis.organisationunit.OrganisationUnitService;\n+import org.hisp.dhis.period.Period;\n+import org.hisp.dhis.period.PeriodType;\n+import org.hisp.dhis.setting.SystemSettingManager;\n+import org.hisp.dhis.util.Timer;\n+import org.springframework.stereotype.Component;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * This component is responsible for handling and retrieving data based on the\n+ * input provided to the public methods. The main goal is to correctly populate\n+ * the data into the Grid object.\n+ */\n+@Slf4j\n+@Component\n+public class DataHandler\n+{\n+\n+    private static final int MAX_QUERIES = 8;\n+\n+    private static final int PERCENT = 100;\n+\n+    private final EventAnalyticsService eventAnalyticsService;\n+\n+    private final RawAnalyticsManager rawAnalyticsManager;\n+\n+    private final ConstantService constantService;\n+\n+    private final ExpressionResolver resolver;\n+\n+    private final ExpressionService expressionService;\n+\n+    private final QueryPlanner queryPlanner;\n+\n+    private final QueryValidator queryValidator;\n+\n+    private final SystemSettingManager systemSettingManager;\n+\n+    private final AnalyticsManager analyticsManager;\n+\n+    private final OrganisationUnitService organisationUnitService;\n+\n+    private DataAggregator dataAggregator;\n+\n+    public DataHandler( EventAnalyticsService eventAnalyticsService, RawAnalyticsManager rawAnalyticsManager,\n+        ConstantService constantService, ExpressionResolver resolver, ExpressionService expressionService,\n+        QueryPlanner queryPlanner, QueryValidator queryValidator, SystemSettingManager systemSettingManager,\n+        AnalyticsManager analyticsManager, OrganisationUnitService organisationUnitService )\n+    {\n+        checkNotNull( eventAnalyticsService );\n+        checkNotNull( rawAnalyticsManager );\n+        checkNotNull( constantService );\n+        checkNotNull( resolver );\n+        checkNotNull( expressionService );\n+        checkNotNull( queryPlanner );\n+        checkNotNull( queryValidator );\n+        checkNotNull( systemSettingManager );\n+        checkNotNull( analyticsManager );\n+        checkNotNull( organisationUnitService );\n+\n+        this.eventAnalyticsService = eventAnalyticsService;\n+        this.rawAnalyticsManager = rawAnalyticsManager;\n+        this.constantService = constantService;\n+        this.resolver = resolver;\n+        this.expressionService = expressionService;\n+        this.queryPlanner = queryPlanner;\n+        this.queryValidator = queryValidator;\n+        this.systemSettingManager = systemSettingManager;\n+        this.analyticsManager = analyticsManager;\n+        this.organisationUnitService = organisationUnitService;\n+    }\n+\n+    /**\n+     * Adds indicator values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getIndicators().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( INDICATOR )\n+                .withIncludeNumDen( false ).build();\n+\n+            List<Indicator> indicators = asTypedList( dataSourceParams.getIndicators() );\n+\n+            List<Period> filterPeriods = dataSourceParams.getTypedFilterPeriods();\n+\n+            Map<String, Constant> constantMap = constantService.getConstantMap();\n+\n+            // -----------------------------------------------------------------\n+            // Get indicator values\n+            // -----------------------------------------------------------------\n+\n+            Map<String, Map<String, Integer>> permutationOrgUnitTargetMap = getOrgUnitTargetMap( dataSourceParams,\n+                indicators );\n+\n+            List<List<DimensionItem>> dimensionItemPermutations = dataSourceParams.getDimensionItemPermutations();\n+\n+            Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap = getPermutationDimensionItemValueMap(\n+                dataSourceParams );\n+\n+            handleEmptyDimensionItemPermutations( dimensionItemPermutations );\n+\n+            for ( Indicator indicator : indicators )\n+            {\n+                for ( List<DimensionItem> dimensionItems : dimensionItemPermutations )\n+                {\n+                    IndicatorValue value = getIndicatorValue( filterPeriods, constantMap, permutationOrgUnitTargetMap,\n+                        permutationDimensionItemValueMap, indicator, dimensionItems );\n+\n+                    addIndicatorValuesToGrid( params, grid, dataSourceParams, indicator, dimensionItems, value );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Based on the given Indicator plus additional parameters, this method will\n+     * find the respective IndicatorValue.\n+     * \n+     * @param filterPeriods\n+     * @param constantMap\n+     * @param permutationOrgUnitTargetMap\n+     * @param permutationDimensionItemValueMap\n+     * @param indicator\n+     * @param dimensionItems\n+     * @return the IndicatorValue\n+     */\n+    private IndicatorValue getIndicatorValue( List<Period> filterPeriods, Map<String, Constant> constantMap,\n+        Map<String, Map<String, Integer>> permutationOrgUnitTargetMap,\n+        Map<String, List<DimensionItemObjectValue>> permutationDimensionItemValueMap, Indicator indicator,\n+        List<DimensionItem> dimensionItems )\n+    {\n+        String permKey = asItemKey( dimensionItems );\n+\n+        final List<DimensionItemObjectValue> valueMap = permutationDimensionItemValueMap\n+            .getOrDefault( permKey, new ArrayList<>() );\n+\n+        List<Period> periods = !filterPeriods.isEmpty() ? filterPeriods\n+            : singletonList( (Period) getPeriodItem( dimensionItems ) );\n+\n+        OrganisationUnit unit = (OrganisationUnit) getOrganisationUnitItem( dimensionItems );\n+\n+        String ou = unit != null ? unit.getUid() : null;\n+\n+        Map<String, Integer> orgUnitCountMap = permutationOrgUnitTargetMap != null\n+            ? permutationOrgUnitTargetMap.get( ou )\n+            : null;\n+\n+        return expressionService.getIndicatorValueObject( indicator, periods,\n+            convertToDimItemValueMap( valueMap ), constantMap, orgUnitCountMap );\n+    }\n+\n+    /**\n+     * Adds data element values to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDataElementValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getAllDataElements().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( DATA_ELEMENT )\n+                .withIncludeNumDen( false ).build();\n+\n+            Map<String, Object> aggregatedDataMap = getAggregatedDataValueMapObjectTyped( dataSourceParams );\n+\n+            for ( Map.Entry<String, Object> entry : aggregatedDataMap.entrySet() )\n+            {\n+                Object value = getRoundedValueObject( params, entry.getValue() );\n+\n+                grid.addRow()\n+                    .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                    .addValue( value );\n+\n+                if ( params.isIncludeNumDen() )\n+                {\n+                    grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds program data element values to the given grid based on the given data\n+     * query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addProgramDataElementAttributeIndicatorValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( (!params.getAllProgramDataElementsAndAttributes().isEmpty() || !params.getProgramIndicators().isEmpty())\n+            && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimensions( PROGRAM_DATA_ELEMENT, PROGRAM_ATTRIBUTE, PROGRAM_INDICATOR ).build();\n+\n+            EventQueryParams eventQueryParams = new EventQueryParams.Builder( fromDataQueryParams( dataSourceParams ) )\n+                .withSkipMeta( true ).build();\n+\n+            Grid eventGrid = eventAnalyticsService.getAggregatedEventData( eventQueryParams );\n+\n+            grid.addRows( eventGrid );\n+        }\n+    }\n+\n+    /**\n+     * Adds reporting rates to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addReportingRates( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getReportingRates().isEmpty() && !params.isSkipData() )\n+        {\n+            for ( ReportingRateMetric metric : ReportingRateMetric.values() )\n+            {\n+                DataQueryParams dataSourceParams = newBuilder( params )\n+                    .retainDataDimensionReportingRates( metric )\n+                    .ignoreDataApproval() // No approval for reporting rates\n+                    .withAggregationType( COUNT )\n+                    .withTimely( (REPORTING_RATE_ON_TIME == metric || ACTUAL_REPORTS_ON_TIME == metric) ).build();\n+\n+                addReportingRates( dataSourceParams, grid, metric );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds data element operand values to the given grid based on the given data\n+     * query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDataElementOperandValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getDataElementOperands().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( DATA_ELEMENT_OPERAND ).build();\n+\n+            for ( TotalType type : values() )\n+            {\n+                addDataElementOperandValues( dataSourceParams, grid, type );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds values to the given grid based on dynamic dimensions from the given data\n+     * query parameters. This assumes that no fixed dimensions are part of the\n+     * query.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addDynamicDimensionValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( params.getDataDimensionAndFilterOptions().isEmpty() && !params.isSkipData() )\n+        {\n+            Map<String, Double> aggregatedDataMap = getAggregatedDataValueMap( newBuilder( params )\n+                .withIncludeNumDen( false ).build() );\n+\n+            fillGridWithAggregatedDataMap( params, grid, aggregatedDataMap );\n+        }\n+    }\n+\n+    /**\n+     * Adds validation results to the given grid based on the given data query\n+     * parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addValidationResultValues( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.getAllValidationResults().isEmpty() && !params.isSkipData() )\n+        {\n+            DataQueryParams dataSourceParams = newBuilder( params )\n+                .retainDataDimension( VALIDATION_RULE )\n+                .withAggregationType( COUNT )\n+                .withIncludeNumDen( false ).build();\n+\n+            Map<String, Double> aggregatedDataMap = getAggregatedValidationResultMapObjectTyped( dataSourceParams );\n+\n+            fillGridWithAggregatedDataMap( params, grid, aggregatedDataMap );\n+        }\n+    }\n+\n+    /**\n+     * Adds raw data to the grid for the given data query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     */\n+    void addRawData( DataQueryParams params, Grid grid )\n+    {\n+        if ( !params.isSkipData() )\n+        {\n+            QueryPlannerParams plannerParams = QueryPlannerParams.newBuilder()\n+                .withTableType( DATA_VALUE ).build();\n+\n+            params = queryPlanner.withTableNameAndPartitions( params, plannerParams );\n+\n+            rawAnalyticsManager.getRawDataValues( params, grid );\n+        }\n+    }\n+\n+    /**\n+     * Prepares the given data query parameters.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     */\n+    DataQueryParams prepareForRawDataQuery( DataQueryParams params )\n+    {\n+        DataQueryParams.Builder builder = newBuilder( params )\n+            .withEarliestStartDateLatestEndDate()\n+            .withPeriodDimensionWithoutOptions()\n+            .withIncludePeriodStartEndDates( true );\n+\n+        if ( params.isShowHierarchy() )\n+        {\n+            builder.withOrgUnitLevels( organisationUnitService.getFilledOrganisationUnitLevels() );\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Generates a mapping between the count of a validation result.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between validation results and counts of them\n+     */\n+    private Map<String, Double> getAggregatedValidationResultMapObjectTyped( DataQueryParams params )\n+    {\n+        return getDoubleMap( getAggregatedValueMap( params, VALIDATION_RESULT, newArrayList() ) );\n+    }\n+\n+    /**\n+     * Fill grid with aggregated data map with key and value\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid\n+     * @param aggregatedDataMap the aggregated data map\n+     */\n+    private void fillGridWithAggregatedDataMap( DataQueryParams params, Grid grid,\n+        Map<String, Double> aggregatedDataMap )\n+    {\n+        for ( Map.Entry<String, Double> entry : aggregatedDataMap.entrySet() )\n+        {\n+            Double value = params.isSkipRounding() ? entry.getValue() : getRounded( entry.getValue() );\n+\n+            grid.addRow()\n+                .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                .addValue( value );\n+\n+            if ( params.isIncludeNumDen() )\n+            {\n+                grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds reporting rates to the given grid based on the given data query\n+     * parameters and reporting rate metric.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     * @param metric the reporting rate metric.\n+     */\n+    private void addReportingRates( DataQueryParams params, Grid grid, ReportingRateMetric metric )\n+    {\n+        if ( !params.getReportingRates().isEmpty() && !params.isSkipData() )\n+        {\n+            if ( !COMPLETENESS_DIMENSION_TYPES.containsAll( params.getDimensionTypes() ) )\n+            {\n+                return;\n+            }\n+\n+            DataQueryParams targetParams = newBuilder( params )\n+                .withSkipPartitioning( true )\n+                .withTimely( false )\n+                .withRestrictByOrgUnitOpeningClosedDate( true )\n+                .withRestrictByCategoryOptionStartEndDate( true )\n+                .withAggregationType( SUM ).build();\n+\n+            Map<String, Double> targetMap = getAggregatedCompletenessTargetMap( targetParams );\n+\n+            Map<String, Double> dataMap = metric != EXPECTED_REPORTS\n+                ? getAggregatedCompletenessValueMap( params )\n+                : new HashMap<>();\n+\n+            Integer periodIndex = params.getPeriodDimensionIndex();\n+            Integer dataSetIndex = DX_INDEX;\n+            Map<String, PeriodType> dsPtMap = params.getDataSetPeriodTypeMap();\n+            PeriodType filterPeriodType = params.getFilterPeriodType();\n+\n+            int timeUnits = getTimeUnits( params );\n+\n+            for ( Map.Entry<String, Double> entry : targetMap.entrySet() )\n+            {\n+                List<String> dataRow = newArrayList( entry.getKey().split( DIMENSION_SEP ) );\n+\n+                Double target = entry.getValue();\n+                Double actual = firstNonNull( dataMap.get( entry.getKey() ), 0d );\n+\n+                if ( target != null )\n+                {\n+                    // ---------------------------------------------------------\n+                    // Multiply target value by number of periods in time span\n+                    // ---------------------------------------------------------\n+\n+                    PeriodType queryPt = filterPeriodType != null ? filterPeriodType\n+                        : getPeriodTypeFromIsoString( dataRow.get( periodIndex ) );\n+                    PeriodType dataSetPt = dsPtMap.get( dataRow.get( dataSetIndex ) );\n+\n+                    target = getCalculatedTarget( periodIndex, timeUnits, dataRow, target, queryPt, dataSetPt );\n+\n+                    addReportRateToGrid( params, grid, metric, dataRow, target, actual );\n+                }\n+            }\n+        }\n+    }\n+\n+    private int getTimeUnits( DataQueryParams params )\n+    {\n+        return params.hasFilter( PERIOD_DIM_ID ) ? params.getFilterPeriods().size() : 1;\n+    }\n+\n+    /**\n+     * Calculate reporting rate and replace data set with rate and add the rate to\n+     * the Grid.\n+     * \n+     * @param params\n+     * @param grid\n+     * @param metric\n+     * @param dataRow\n+     * @param target\n+     * @param actual\n+     */\n+    private void addReportRateToGrid( DataQueryParams params, Grid grid, ReportingRateMetric metric,\n+        List<String> dataRow, Double target, Double actual )\n+    {\n+        Double value = getReportRate( metric, target, actual );\n+\n+        String reportingRate = getDimensionItem( dataRow.get( DX_INDEX ), metric );\n+        dataRow.set( DX_INDEX, reportingRate );\n+\n+        grid.addRow()\n+            .addValues( dataRow.toArray() )\n+            .addValue( params.isSkipRounding() ? value : getRounded( value ) );\n+\n+        if ( params.isIncludeNumDen() )\n+        {\n+            grid.addValue( actual )\n+                .addValue( target )\n+                .addValue( PERCENT )\n+                .addNullValues( 2 );\n+        }\n+    }\n+\n+    /**\n+     * Use number of days for daily data sets as target, as query periods might\n+     * often span/contain different numbers of days.\n+     * \n+     * @param periodIndex\n+     * @param timeUnits\n+     * @param dataRow\n+     * @param target\n+     * @param queryPt\n+     * @param dataSetPt\n+     * @return the calculate target\n+     */\n+    private Double getCalculatedTarget( Integer periodIndex, int timeUnits, List<String> dataRow, Double target,\n+        PeriodType queryPt, PeriodType dataSetPt )\n+    {\n+        if ( dataSetPt.equalsName( NAME ) )\n+        {\n+            Period period = getPeriodFromIsoString( dataRow.get( periodIndex ) );\n+            target = target * period.getDaysInPeriod() * timeUnits;\n+        }\n+        else\n+        {\n+            target = target * queryPt.getPeriodSpan( dataSetPt ) * timeUnits;\n+        }\n+        return target;\n+    }\n+\n+    private Double getReportRate( ReportingRateMetric metric, Double target, Double actual )\n+    {\n+        Double value = 0d;\n+\n+        if ( EXPECTED_REPORTS == metric )\n+        {\n+            value = target;\n+        }\n+        else if ( ACTUAL_REPORTS == metric || ACTUAL_REPORTS_ON_TIME == metric )\n+        {\n+            value = actual;\n+        }\n+        else if ( !isZero( target ) ) // REPORTING_RATE or REPORTING_RATE_ON_TIME\n+        {\n+            value = min( ((actual * PERCENT) / target), 100d );\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Generates aggregated values for the given query. Creates a mapping between a\n+     * dimension key and the aggregated value. The dimension key is a concatenation\n+     * of the identifiers of the dimension items separated by \"-\".\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between a dimension key and the aggregated value.\n+     */\n+    private Map<String, Double> getAggregatedCompletenessValueMap( DataQueryParams params )\n+    {\n+        return getDoubleMap( getAggregatedValueMap( params, COMPLETENESS, newArrayList() ) );\n+    }\n+\n+    /**\n+     * Generates a mapping between the the data set dimension key and the count of\n+     * expected data sets to report.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between the the data set dimension key and the count of\n+     *         expected data sets to report.\n+     */\n+    private Map<String, Double> getAggregatedCompletenessTargetMap( DataQueryParams params )\n+    {\n+        List<Function<DataQueryParams, List<DataQueryParams>>> queryGroupers = newArrayList();\n+        queryGroupers.add( q -> queryPlanner.groupByStartEndDateRestriction( q ) );\n+\n+        return getDoubleMap( getAggregatedValueMap( params, COMPLETENESS_TARGET, queryGroupers ) );\n+    }\n+\n+    /**\n+     * Adds data element operand values to the given grid.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param grid the grid.\n+     * @param totalType the operand {@link TotalType}.\n+     */\n+    private void addDataElementOperandValues( DataQueryParams params, Grid grid, TotalType totalType )\n+    {\n+        List<DataElementOperand> operands = asTypedList( params.getDataElementOperands() );\n+        operands = operands.stream().filter( o -> totalType.equals( o.getTotalType() ) ).collect( Collectors.toList() );\n+\n+        if ( operands.isEmpty() )\n+        {\n+            return;\n+        }\n+\n+        List<DimensionalItemObject> dataElements = newArrayList( getDataElements( operands ) );\n+        List<DimensionalItemObject> categoryOptionCombos = newArrayList( getCategoryOptionCombos( operands ) );\n+        List<DimensionalItemObject> attributeOptionCombos = newArrayList( getAttributeOptionCombos( operands ) );\n+\n+        // TODO Check if data was dim or filter\n+\n+        DataQueryParams.Builder builder = newBuilder( params )\n+            .removeDimension( DATA_X_DIM_ID )\n+            .addDimension( new BaseDimensionalObject( DATA_X_DIM_ID, DATA_X, dataElements ) );\n+\n+        if ( totalType.isCategoryOptionCombo() )\n+        {\n+            builder.addDimension( new BaseDimensionalObject( CATEGORYOPTIONCOMBO_DIM_ID,\n+                CATEGORY_OPTION_COMBO, categoryOptionCombos ) );\n+        }\n+\n+        if ( totalType.isAttributeOptionCombo() )\n+        {\n+            builder.addDimension( new BaseDimensionalObject( ATTRIBUTEOPTIONCOMBO_DIM_ID,\n+                ATTRIBUTE_OPTION_COMBO, attributeOptionCombos ) );\n+        }\n+\n+        DataQueryParams operandParams = builder.build();\n+\n+        Map<String, Object> aggregatedDataMap = getAggregatedDataValueMapObjectTyped( operandParams );\n+\n+        aggregatedDataMap = convertDxToOperand( aggregatedDataMap, totalType );\n+\n+        for ( Map.Entry<String, Object> entry : aggregatedDataMap.entrySet() )\n+        {\n+            Object value = getRoundedValueObject( operandParams, entry.getValue() );\n+\n+            grid.addRow()\n+                .addValues( entry.getKey().split( DIMENSION_SEP ) )\n+                .addValue( value );\n+\n+            if ( params.isIncludeNumDen() )\n+            {\n+                grid.addNullValues( NUMERATOR_DENOMINATOR_PROPERTIES_COUNT );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates aggregated values for the given query. Creates a mapping between a\n+     * dimension key and the aggregated value. The dimension key is a concatenation\n+     * of the identifiers of the dimension items separated by \"-\".\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between a dimension key and the aggregated value.\n+     */\n+    private Map<String, Object> getAggregatedDataValueMapObjectTyped( DataQueryParams params )\n+    {\n+        return getAggregatedValueMap( params, DATA_VALUE, newArrayList() );\n+    }\n+\n+    /**\n+     * Returns a mapping of permutation keys and mappings of data element operands\n+     * and values based on the given query.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     */\n+    private Map<String, List<DimensionItemObjectValue>> getPermutationDimensionItemValueMap( DataQueryParams params )\n+    {\n+        List<Indicator> indicators = asTypedList( params.getIndicators() );\n+\n+        return getPermutationDimensionalItemValueMap( getAggregatedDataValueMap( params, indicators ) );\n+    }\n+\n+    /**\n+     * Checks whether the measure criteria in query parameters is satisfied for the\n+     * given indicator value.\n+     *\n+     * @param params the query parameters.\n+     * @param value the indicator value.\n+     * @param indicator the indicator.\n+     * @return true if all the measure criteria are satisfied for this indicator\n+     *         value, false otherwise.\n+     */\n+    private boolean satisfiesMeasureCriteria( DataQueryParams params, IndicatorValue value, Indicator indicator )\n+    {\n+        if ( !params.hasMeasureCriteria() || value == null )\n+        {\n+            return true;\n+        }\n+\n+        Double indicatorRoundedValue = getRoundedValue( params, indicator.getDecimals(), value.getValue() )\n+            .doubleValue();\n+\n+        return !params.getMeasureCriteria().entrySet().stream()\n+            .anyMatch( measureValue -> !measureValue.getKey()\n+                .measureIsValid( indicatorRoundedValue, measureValue.getValue() ) );\n+    }\n+\n+    /**\n+     * Handles the case where there are no dimension item permutations by adding an\n+     * empty dimension item list to the permutations list. This state occurs where\n+     * there are only data or category option combo dimensions specified.\n+     *\n+     * @param dimensionItemPermutations list of dimension item permutations.\n+     */\n+    private void handleEmptyDimensionItemPermutations( List<List<DimensionItem>> dimensionItemPermutations )\n+    {\n+        if ( dimensionItemPermutations.isEmpty() )\n+        {\n+            dimensionItemPermutations.add( new ArrayList<>() );\n+        }\n+    }\n+\n+    /**\n+     * Generates a mapping of permutations keys (organisation unit id or null) and\n+     * mappings of organisation unit group and counts.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param indicators the indicators for which formulas to scan for organisation\n+     *        unit groups.\n+     * @return a map of maps.\n+     */\n+    private Map<String, Map<String, Integer>> getOrgUnitTargetMap( DataQueryParams params,\n+        Collection<Indicator> indicators )\n+    {\n+        Set<OrganisationUnitGroup> orgUnitGroups = expressionService.getIndicatorOrgUnitGroups( indicators );\n+\n+        if ( orgUnitGroups.isEmpty() )\n+        {\n+            return null;\n+        }\n+\n+        DataQueryParams orgUnitTargetParams = newBuilder( params )\n+            .pruneToDimensionType( ORGANISATION_UNIT )\n+            .addDimension( new BaseDimensionalObject( ORGUNIT_GROUP_DIM_ID,\n+                ORGANISATION_UNIT_GROUP, new ArrayList<DimensionalItemObject>( orgUnitGroups ) ) )\n+            .withOutputFormat( ANALYTICS )\n+            .withSkipPartitioning( true )\n+            .withSkipDataDimensionValidation( true )\n+            .build();\n+\n+        Map<String, Double> orgUnitCountMap = getAggregatedOrganisationUnitTargetMap( orgUnitTargetParams );\n+\n+        return getPermutationOrgUnitGroupCountMap( orgUnitCountMap );\n+    }\n+\n+    /**\n+     * Generates a mapping between the the organisation unit dimension key and the\n+     * count of organisation units inside the subtree of the given organisation\n+     * units and members of the given organisation unit groups.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @return a mapping between the the data set dimension key and the count of\n+     *         expected data sets to report.\n+     */\n+    private Map<String, Double> getAggregatedOrganisationUnitTargetMap( DataQueryParams params )\n+    {\n+        return getDoubleMap( getAggregatedValueMap( params, ORG_UNIT_TARGET, newArrayList() ) );\n+    }\n+\n+    /**\n+     * Resolves the numerator and denominator expressions of the given indicators.\n+     *\n+     * @param indicators the list of indicators.\n+     * @return the given list of indicators.\n+     */\n+    private List<Indicator> resolveIndicatorExpressions( List<Indicator> indicators )\n+    {\n+        for ( Indicator indicator : indicators )\n+        {\n+            indicator.setNumerator( resolver.resolve( indicator.getNumerator() ) );\n+            indicator.setDenominator( resolver.resolve( indicator.getDenominator() ) );\n+        }\n+\n+        return indicators;\n+    }\n+\n+    /**\n+     * Returns a mapping between dimension items and values for the given data query\n+     * and list of indicators. The dimensional items part of the indicator\n+     * numerators and denominators are used as dimensional item for the aggregated\n+     * values being retrieved. In case of circular references between Indicators, an\n+     * exception is thrown.\n+     *\n+     * @param params the {@link DataQueryParams}.\n+     * @param indicators the list of indicators.\n+     * @return a dimensional items to aggregate values map.\n+     */\n+    private MultiValuedMap<String, DimensionItemObjectValue> getAggregatedDataValueMap( DataQueryParams params,\n+        List<Indicator> indicators )\n+    {\n+        List<DimensionalItemObject> items = newArrayList(\n+            expressionService.getIndicatorDimensionalItemObjects( resolveIndicatorExpressions( indicators ) ) );\n+\n+        if ( items.isEmpty() )\n+        {\n+            return new ArrayListValuedHashMap<>();\n+        }\n+\n+        items = replaceOperandTotalsWithDataElements( items );\n+\n+        DimensionalObject dimension = new BaseDimensionalObject( DATA_X_DIM_ID, DATA_X, null, DISPLAY_NAME_DATA_X,\n+            items );\n+\n+        DataQueryParams dataSourceParams = newBuilder( params )\n+            .replaceDimension( dimension )\n+            .withMeasureCriteria( new HashMap<>() )\n+            .withIncludeNumDen( false )\n+            .withSkipHeaders( true )\n+            .withOutputFormat( ANALYTICS )\n+            .withSkipMeta( true ).build();\n+\n+        // Each row in the Grid contains: dimension uid | period | value\n+        Grid grid = dataAggregator.getAggregatedDataValueGridInternal( dataSourceParams );\n+        MultiValuedMap<String, DimensionItemObjectValue> result = new ArrayListValuedHashMap<>();\n+\n+        if ( isEmpty( grid.getRows() ) )\n+        {\n+            return result;\n+        }\n+\n+        BiFunction<Integer, Integer, Integer> replaceIndexIfMissing = ( Integer index,\n+            Integer defaultIndex ) -> index == -1 ? defaultIndex : index;\n+\n+        final int dataIndex = replaceIndexIfMissing.apply( grid.getIndexOfHeader( DATA_X_DIM_ID ), 0 );\n+        final int periodIndex = replaceIndexIfMissing.apply( grid.getIndexOfHeader( PERIOD_DIM_ID ), 1 );\n+        final int valueIndex = grid.getWidth() - 1;\n+\n+        final List<DimensionalItemObject> basePeriods = params.getPeriods();\n+\n+        for ( List<Object> row : grid.getRows() )\n+        {\n+            final List<DimensionalItemObject> dimensionalItems = findDimensionalItems( (String) row.get( dataIndex ),\n+                items );\n+\n+            // Check if the current row's Period belongs to the list of periods from the\n+            // original Analytics request.\n+            // The row may not have a Period if Period is used as filter.\n+            if ( hasPeriod( row, periodIndex ) && isPeriodInPeriods( (String) row.get( periodIndex ), basePeriods ) )\n+            {\n+                if ( dimensionalItems.size() == 1 )\n+                {\n+                    addItemBasedOnPeriodOffset( grid, result, periodIndex, valueIndex, row, dimensionalItems );\n+                }\n+            }\n+            else\n+            {\n+                if ( dimensionalItems.size() == 1 )\n+                {\n+                    result.put( dimensionalItems.get( 0 ).getDimensionItem(),\n+                        new DimensionItemObjectValue( dimensionalItems.get( 0 ), (Double) row.get( valueIndex ) ) );\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Add the given Indicator values to the Grid.\n+     * \n+     * @param params\n+     * @param grid\n+     * @param dataSourceParams\n+     * @param indicator\n+     * @param dimensionItems\n+     * @param value\n+     */\n+    private void addIndicatorValuesToGrid( DataQueryParams params, Grid grid, DataQueryParams dataSourceParams,\n+        Indicator indicator, List<DimensionItem> dimensionItems, IndicatorValue value )\n+    {\n+        if ( value != null && satisfiesMeasureCriteria( params, value, indicator ) )\n+        {\n+            List<DimensionItem> row = new ArrayList<>( dimensionItems );\n+\n+            row.add( DX_INDEX, new DimensionItem( DATA_X_DIM_ID, indicator ) );\n+\n+            grid.addRow()\n+                .addValues( getItemIdentifiers( row ) )\n+                .addValue( getRoundedValue( dataSourceParams, indicator.getDecimals(),\n+                    value.getValue() ) );\n+\n+            if ( params.isIncludeNumDen() )\n+            {\n+                grid.addValue( getRoundedValue( dataSourceParams, indicator.getDecimals(),\n+                    value.getNumeratorValue() ) )\n+                    .addValue( getRoundedValue( dataSourceParams, indicator.getDecimals(),\n+                        value.getDenominatorValue() ) )\n+                    .addValue( getRoundedValue( dataSourceParams, indicator.getDecimals(),\n+                        value.getFactor() ) )\n+                    .addValue( value.getMultiplier() )\n+                    .addValue( value.getDivisor() );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Calculate the dimensional item offset and adds to the give result map.\n+     * \n+     * @param grid", "originalCommit": "1c656fcb31616a11eeee7e18ae96874dd5cb7bb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMzc5Ng==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r465133796", "bodyText": "Done", "author": "maikelarabori", "createdAt": "2020-08-04T15:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMTUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMjEyMA==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464212120", "bodyText": "A design consideration for this class: have you considered a DataHandler interface with specialized handlers (e.g. IndicatorDataHandler, etc.)? The main advantage I see is \"lowering\" the scope of this class (single responsibility principle) and creating smaller, more focused classes.", "author": "luciano-fiandesio", "createdAt": "2020-08-03T06:12:42Z", "path": "dhis-2/dhis-services/dhis-service-analytics/src/main/java/org/hisp/dhis/analytics/data/handling/DataHandler.java", "diffHunk": "@@ -0,0 +1,1161 @@\n+package org.hisp.dhis.analytics.data.handling;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static java.lang.Math.min;\n+import static java.util.Collections.singletonList;\n+import static org.apache.commons.collections4.CollectionUtils.isEmpty;\n+import static org.apache.commons.lang3.ArrayUtils.remove;\n+import static org.apache.commons.lang3.StringUtils.join;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.COUNT;\n+import static org.hisp.dhis.analytics.AnalyticsAggregationType.SUM;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.COMPLETENESS_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.DATA_VALUE;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.ORG_UNIT_TARGET;\n+import static org.hisp.dhis.analytics.AnalyticsTableType.VALIDATION_RESULT;\n+import static org.hisp.dhis.analytics.DataQueryParams.COMPLETENESS_DIMENSION_TYPES;\n+import static org.hisp.dhis.analytics.DataQueryParams.DISPLAY_NAME_DATA_X;\n+import static org.hisp.dhis.analytics.DataQueryParams.DX_INDEX;\n+import static org.hisp.dhis.analytics.DataQueryParams.NUMERATOR_DENOMINATOR_PROPERTIES_COUNT;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationDimensionalItemValueMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.getPermutationOrgUnitGroupCountMap;\n+import static org.hisp.dhis.analytics.DataQueryParams.newBuilder;\n+import static org.hisp.dhis.analytics.DimensionItem.asItemKey;\n+import static org.hisp.dhis.analytics.DimensionItem.getItemIdentifiers;\n+import static org.hisp.dhis.analytics.DimensionItem.getOrganisationUnitItem;\n+import static org.hisp.dhis.analytics.DimensionItem.getPeriodItem;\n+import static org.hisp.dhis.analytics.OutputFormat.ANALYTICS;\n+import static org.hisp.dhis.analytics.event.EventQueryParams.fromDataQueryParams;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.convertDxToOperand;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.findDimensionalItems;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getDoubleMap;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValue;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.getRoundedValueObject;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.hasPeriod;\n+import static org.hisp.dhis.analytics.util.AnalyticsUtils.isPeriodInPeriods;\n+import static org.hisp.dhis.analytics.util.PeriodOffsetUtils.getPeriodOffsetRow;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.DATA_ELEMENT_OPERAND;\n+import static org.hisp.dhis.common.DataDimensionItemType.INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_ATTRIBUTE;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_DATA_ELEMENT;\n+import static org.hisp.dhis.common.DataDimensionItemType.PROGRAM_INDICATOR;\n+import static org.hisp.dhis.common.DataDimensionItemType.VALIDATION_RULE;\n+import static org.hisp.dhis.common.DimensionType.ATTRIBUTE_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.CATEGORY_OPTION_COMBO;\n+import static org.hisp.dhis.common.DimensionType.DATA_X;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT;\n+import static org.hisp.dhis.common.DimensionType.ORGANISATION_UNIT_GROUP;\n+import static org.hisp.dhis.common.DimensionalObject.ATTRIBUTEOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.CATEGORYOPTIONCOMBO_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DATA_X_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.DIMENSION_SEP;\n+import static org.hisp.dhis.common.DimensionalObject.ORGUNIT_GROUP_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObject.PERIOD_DIM_ID;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.asTypedList;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.convertToDimItemValueMap;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getAttributeOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getCategoryOptionCombos;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDataElements;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.getDimensionItem;\n+import static org.hisp.dhis.common.DimensionalObjectUtils.replaceOperandTotalsWithDataElements;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.ACTUAL_REPORTS_ON_TIME;\n+import static org.hisp.dhis.common.ReportingRateMetric.EXPECTED_REPORTS;\n+import static org.hisp.dhis.common.ReportingRateMetric.REPORTING_RATE_ON_TIME;\n+import static org.hisp.dhis.commons.util.DebugUtils.getStackTrace;\n+import static org.hisp.dhis.commons.util.SystemUtils.getCpuCores;\n+import static org.hisp.dhis.dataelement.DataElementOperand.TotalType.values;\n+import static org.hisp.dhis.period.DailyPeriodType.NAME;\n+import static org.hisp.dhis.period.PeriodType.getPeriodFromIsoString;\n+import static org.hisp.dhis.period.PeriodType.getPeriodTypeFromIsoString;\n+import static org.hisp.dhis.setting.SettingKey.ANALYTICS_MAX_LIMIT;\n+import static org.hisp.dhis.setting.SettingKey.DATABASE_SERVER_CPUS;\n+import static org.hisp.dhis.system.util.MathUtils.getRounded;\n+import static org.hisp.dhis.system.util.MathUtils.getWithin;\n+import static org.hisp.dhis.system.util.MathUtils.isZero;\n+import static org.hisp.dhis.util.ObjectUtils.firstNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.hisp.dhis.analytics.AnalyticsManager;\n+import org.hisp.dhis.analytics.AnalyticsTableType;\n+import org.hisp.dhis.analytics.DataQueryGroups;\n+import org.hisp.dhis.analytics.DataQueryParams;\n+import org.hisp.dhis.analytics.DimensionItem;\n+import org.hisp.dhis.analytics.QueryPlanner;\n+import org.hisp.dhis.analytics.QueryPlannerParams;\n+import org.hisp.dhis.analytics.QueryValidator;\n+import org.hisp.dhis.analytics.RawAnalyticsManager;\n+import org.hisp.dhis.analytics.event.EventAnalyticsService;\n+import org.hisp.dhis.analytics.event.EventQueryParams;\n+import org.hisp.dhis.analytics.resolver.ExpressionResolver;\n+import org.hisp.dhis.common.BaseDimensionalObject;\n+import org.hisp.dhis.common.DimensionItemObjectValue;\n+import org.hisp.dhis.common.DimensionalItemObject;\n+import org.hisp.dhis.common.DimensionalObject;\n+import org.hisp.dhis.common.Grid;\n+import org.hisp.dhis.common.ReportingRateMetric;\n+import org.hisp.dhis.constant.Constant;\n+import org.hisp.dhis.constant.ConstantService;\n+import org.hisp.dhis.dataelement.DataElementOperand;\n+import org.hisp.dhis.dataelement.DataElementOperand.TotalType;\n+import org.hisp.dhis.expression.ExpressionService;\n+import org.hisp.dhis.indicator.Indicator;\n+import org.hisp.dhis.indicator.IndicatorValue;\n+import org.hisp.dhis.organisationunit.OrganisationUnit;\n+import org.hisp.dhis.organisationunit.OrganisationUnitGroup;\n+import org.hisp.dhis.organisationunit.OrganisationUnitService;\n+import org.hisp.dhis.period.Period;\n+import org.hisp.dhis.period.PeriodType;\n+import org.hisp.dhis.setting.SystemSettingManager;\n+import org.hisp.dhis.util.Timer;\n+import org.springframework.stereotype.Component;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * This component is responsible for handling and retrieving data based on the\n+ * input provided to the public methods. The main goal is to correctly populate\n+ * the data into the Grid object.\n+ */\n+@Slf4j\n+@Component\n+public class DataHandler", "originalCommit": "1c656fcb31616a11eeee7e18ae96874dd5cb7bb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0MDg1MQ==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464240851", "bodyText": "Yes, I have considered many other things regarding design actually. But I don't want to make all changes at once. I was thinking about doing gradual changes in order to facilitate the code review and minimize impacts and avoid the risk of introducing bugs.\nI can draft an initial diagram so we can define a goal.", "author": "maikelarabori", "createdAt": "2020-08-03T07:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0NTA2NA==", "url": "https://github.com/dhis2/dhis2-core/pull/5871#discussion_r464245064", "bodyText": "Makes sense", "author": "luciano-fiandesio", "createdAt": "2020-08-03T07:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxMjEyMA=="}], "type": "inlineReview"}, {"oid": "c2ebc547d5ae7f5c88f4fbb44654183396e2bd91", "url": "https://github.com/dhis2/dhis2-core/commit/c2ebc547d5ae7f5c88f4fbb44654183396e2bd91", "message": "fix: Code review fixes and NPE prevention [DHIS2-9212]", "committedDate": "2020-08-03T17:02:13Z", "type": "commit"}, {"oid": "912a33806a4921febea73f91b9046f2b3465f405", "url": "https://github.com/dhis2/dhis2-core/commit/912a33806a4921febea73f91b9046f2b3465f405", "message": "chore: Merging master [DHIS2-9212]", "committedDate": "2020-08-04T08:02:31Z", "type": "commit"}, {"oid": "8de737b19ccdc3b8f6fffa1032d3a7dcd5fd2409", "url": "https://github.com/dhis2/dhis2-core/commit/8de737b19ccdc3b8f6fffa1032d3a7dcd5fd2409", "message": "Code style", "committedDate": "2020-08-05T10:07:51Z", "type": "commit"}, {"oid": "c56e105456f5e99ffbb7f88ca9d448674e533bce", "url": "https://github.com/dhis2/dhis2-core/commit/c56e105456f5e99ffbb7f88ca9d448674e533bce", "message": "Merge with master", "committedDate": "2020-08-05T10:14:05Z", "type": "commit"}]}