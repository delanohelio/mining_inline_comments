{"pr_number": 5945, "pr_title": "6127 create tsk prog run artifacts for windows prefetch data", "pr_createdAt": "2020-06-05T18:07:42Z", "pr_url": "https://github.com/sleuthkit/autopsy/pull/5945", "timeline": [{"oid": "5af4fd93222a404ab593a56bc8f7c2c43bdadb1a", "url": "https://github.com/sleuthkit/autopsy/commit/5af4fd93222a404ab593a56bc8f7c2c43bdadb1a", "message": "Initial prefetch creation\n\nInitial creation of prefetch RA", "committedDate": "2020-06-02T14:15:09Z", "type": "commit"}, {"oid": "0173ca4b36bfbc5409775ac2f3c41a95c2c6bbff", "url": "https://github.com/sleuthkit/autopsy/commit/0173ca4b36bfbc5409775ac2f3c41a95c2c6bbff", "message": "Update mac and linux executable name\n\nUpdate mac and linux executable name", "committedDate": "2020-06-04T15:54:06Z", "type": "commit"}, {"oid": "931e1f83bab74f2e109cc3a23b6ca975d58c3e79", "url": "https://github.com/sleuthkit/autopsy/commit/931e1f83bab74f2e109cc3a23b6ca975d58c3e79", "message": "Update ExtractPrefetch.java\n\nRemove uncommented code and change logger message and remove unused imports.", "committedDate": "2020-06-04T17:34:09Z", "type": "commit"}, {"oid": "fe870bdb46fd66531cfa55ebc6a347ef1d54c89e", "url": "https://github.com/sleuthkit/autopsy/commit/fe870bdb46fd66531cfa55ebc6a347ef1d54c89e", "message": "Update ExtractPrefetch.java\n\nchange strings to final static variables, remove uneeded try and add logger message.", "committedDate": "2020-06-04T18:20:44Z", "type": "commit"}, {"oid": "ca64ed58189c18fe288832c80490bc88f25c2025", "url": "https://github.com/sleuthkit/autopsy/commit/ca64ed58189c18fe288832c80490bc88f25c2025", "message": "Update ExtractPrefetch.java\n\nUpdate comments", "committedDate": "2020-06-05T00:59:44Z", "type": "commit"}, {"oid": "91761cf028c4b812d23b8269657533691178ed76", "url": "https://github.com/sleuthkit/autopsy/commit/91761cf028c4b812d23b8269657533691178ed76", "message": "Update ExtractPrefetch.java\n\nComment and clean up.", "committedDate": "2020-06-05T17:41:30Z", "type": "commit"}, {"oid": "d4c387b7ddc0a09f99351bdb746e44c8903ab6a6", "url": "https://github.com/sleuthkit/autopsy/commit/d4c387b7ddc0a09f99351bdb746e44c8903ab6a6", "message": "Update ExtractPrefetch.java\n\nCodacy fixes", "committedDate": "2020-06-05T18:18:24Z", "type": "commit"}, {"oid": "fe33fc21eaccdca063f3a3b1b997029933b406a7", "url": "https://github.com/sleuthkit/autopsy/commit/fe33fc21eaccdca063f3a3b1b997029933b406a7", "message": "Update ExtractPrefetch.java\n\nAttempt to make codacy happier", "committedDate": "2020-06-05T20:13:47Z", "type": "commit"}, {"oid": "3e6e876df1b0572cfa832abe14ea5f7c60851f2a", "url": "https://github.com/sleuthkit/autopsy/commit/3e6e876df1b0572cfa832abe14ea5f7c60851f2a", "message": "Update ExtractPrefetch.java\n\ncodacy cycleomatic complaint", "committedDate": "2020-06-05T21:07:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NTAyNQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439045025", "bodyText": "The output of this call should be checked and if it's false I think it should bail.", "author": "dannysmyda", "createdAt": "2020-06-11T20:15:47Z", "path": "RecentActivity/src/org/sleuthkit/autopsy/recentactivity/ExtractPrefetch.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ *\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.recentactivity;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Level;\n+import org.openide.modules.InstalledFileLocator;\n+import org.openide.util.NbBundle.Messages;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.casemodule.services.FileManager;\n+import org.sleuthkit.autopsy.coreutils.ExecUtil;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.coreutils.PlatformUtil;\n+import org.sleuthkit.autopsy.coreutils.SQLiteDBConnect;\n+import org.sleuthkit.autopsy.datamodel.ContentUtils;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProcessTerminator;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress;\n+import org.sleuthkit.autopsy.ingest.IngestJobContext;\n+import org.sleuthkit.datamodel.AbstractFile;\n+import org.sleuthkit.datamodel.Blackboard;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE.TSK_ASSOCIATED_OBJECT;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Extract the Prefetch Files and process them thru an External program.  The data will then be added to the \n+ * TSK_PROG_RUN artifact.  Associated artifacts will be created if possible. \n+ */\n+final class ExtractPrefetch extends Extract {\n+\n+    private static final Logger logger = Logger.getLogger(ExtractPrefetch.class.getName());\n+\n+    private IngestJobContext context;\n+\n+\n+    private static final String MODULE_NAME = \"extractPREFETCH\"; //NON-NLS\n+\n+    private static final String PREFETCH_TSK_COMMENT = \"Prefetch File\";\n+    private static final String PREFETCH_FILE_LOCATION = \"/Windows/Prefetch\";\n+    private static final String PREFETCH_TOOL_FOLDER = \"markmckinnon\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_64 = \"parse_prefetch_64.exe\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_32 = \"parse_prefetch_32.exe\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_MACOS = \"parse_prefetch_macos\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_LINUX = \"parse_prefetch_linux\"; //NON-NLS\n+    private static final String PREFETCH_OUTPUT_FILE_NAME = \"Output.txt\"; //NON-NLS\n+    private static final String PREFETCH_ERROR_FILE_NAME = \"Error.txt\"; //NON-NLS\n+    private static final String PREFETCH_PARSER_DB_FILE = \"Autopsy_PF_DB.db3\"; //NON-NLS\n+    private static final String PREFETCH_DIR_NAME = \"prefetch\"; //NON-NLS\n+\n+    @Messages({\n+        \"ExtractPrefetch_module_name=Windows Prefetch Extractor\"\n+    })\n+    ExtractPrefetch() {\n+        this.moduleName = Bundle.ExtractPrefetch_module_name();\n+    }\n+\n+    @Override\n+    void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) {\n+\n+        this.context = context;\n+\n+        String modOutPath = Case.getCurrentCase().getModuleDirectory() + File.separator + PREFETCH_DIR_NAME;\n+        File dir = new File(modOutPath);\n+        if (dir.exists() == false) {\n+            dir.mkdirs();", "originalCommit": "3e6e876df1b0572cfa832abe14ea5f7c60851f2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NzU3MA==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439587570", "bodyText": "Done", "author": "markmckinnon", "createdAt": "2020-06-12T18:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NTAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NzcxNw==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439047717", "bodyText": "Are these files typically named the same across multiple data sources?", "author": "dannysmyda", "createdAt": "2020-06-11T20:19:13Z", "path": "RecentActivity/src/org/sleuthkit/autopsy/recentactivity/ExtractPrefetch.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ *\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.recentactivity;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Level;\n+import org.openide.modules.InstalledFileLocator;\n+import org.openide.util.NbBundle.Messages;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.casemodule.services.FileManager;\n+import org.sleuthkit.autopsy.coreutils.ExecUtil;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.coreutils.PlatformUtil;\n+import org.sleuthkit.autopsy.coreutils.SQLiteDBConnect;\n+import org.sleuthkit.autopsy.datamodel.ContentUtils;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProcessTerminator;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress;\n+import org.sleuthkit.autopsy.ingest.IngestJobContext;\n+import org.sleuthkit.datamodel.AbstractFile;\n+import org.sleuthkit.datamodel.Blackboard;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE.TSK_ASSOCIATED_OBJECT;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Extract the Prefetch Files and process them thru an External program.  The data will then be added to the \n+ * TSK_PROG_RUN artifact.  Associated artifacts will be created if possible. \n+ */\n+final class ExtractPrefetch extends Extract {\n+\n+    private static final Logger logger = Logger.getLogger(ExtractPrefetch.class.getName());\n+\n+    private IngestJobContext context;\n+\n+\n+    private static final String MODULE_NAME = \"extractPREFETCH\"; //NON-NLS\n+\n+    private static final String PREFETCH_TSK_COMMENT = \"Prefetch File\";\n+    private static final String PREFETCH_FILE_LOCATION = \"/Windows/Prefetch\";\n+    private static final String PREFETCH_TOOL_FOLDER = \"markmckinnon\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_64 = \"parse_prefetch_64.exe\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_32 = \"parse_prefetch_32.exe\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_MACOS = \"parse_prefetch_macos\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_LINUX = \"parse_prefetch_linux\"; //NON-NLS\n+    private static final String PREFETCH_OUTPUT_FILE_NAME = \"Output.txt\"; //NON-NLS\n+    private static final String PREFETCH_ERROR_FILE_NAME = \"Error.txt\"; //NON-NLS\n+    private static final String PREFETCH_PARSER_DB_FILE = \"Autopsy_PF_DB.db3\"; //NON-NLS\n+    private static final String PREFETCH_DIR_NAME = \"prefetch\"; //NON-NLS\n+\n+    @Messages({\n+        \"ExtractPrefetch_module_name=Windows Prefetch Extractor\"\n+    })\n+    ExtractPrefetch() {\n+        this.moduleName = Bundle.ExtractPrefetch_module_name();\n+    }\n+\n+    @Override\n+    void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) {\n+\n+        this.context = context;\n+\n+        String modOutPath = Case.getCurrentCase().getModuleDirectory() + File.separator + PREFETCH_DIR_NAME;\n+        File dir = new File(modOutPath);\n+        if (dir.exists() == false) {\n+            dir.mkdirs();\n+        }\n+        \n+        extractPrefetchFiles(dataSource);\n+        \n+        final String prefetchDumper = getPathForPrefetchDumper();\n+        if (prefetchDumper == null) {\n+            logger.log(Level.SEVERE, \"Error finding parse_prefetch program\"); //NON-NLS\n+            return; //If we cannot find the parse_prefetch program we cannot proceed\n+        }\n+\n+        if (context.dataSourceIngestIsCancelled()) {\n+            return;\n+        }\n+\n+        String modOutFile = modOutPath + File.separator + PREFETCH_PARSER_DB_FILE;\n+        try {\n+            String tempDirPath = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), PREFETCH_DIR_NAME );\n+            parsePrefetchFiles(prefetchDumper, tempDirPath, modOutFile, modOutPath);\n+            createAppExecArtifacts(modOutFile);\n+        } catch (IOException ex) {\n+            logger.log(Level.WARNING, \"Error runing parse_prefetch or creating artifacts.\", ex); //NON-NLS             \n+        }\n+    }\n+    \n+    /**\n+     * Extract prefetch file to temp directory to process.  Checks to make sure that the prefetch files only\n+     * come from the /Windows/Prefetch directory\n+     * \n+     * @param dataSource - datasource to search for prefetch files\n+     * \n+     */\n+\n+    void extractPrefetchFiles(Content dataSource) {\n+        List<AbstractFile> pFiles;\n+\n+        FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n+\n+        try {\n+            pFiles = fileManager.findFiles(dataSource, \"%.pf\"); //NON-NLS            ", "originalCommit": "3e6e876df1b0572cfa832abe14ea5f7c60851f2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1OTU0NA==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439159544", "bodyText": "Yes all prefetch files have a extension of PF and should only exist in the C:\\Windows\\Prefetch folder", "author": "markmckinnon", "createdAt": "2020-06-12T01:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NzcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2MDYzOQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439060639", "bodyText": "I'm not sure if the first file would necessarily be from the data source you were expecting.", "author": "dannysmyda", "createdAt": "2020-06-11T20:43:57Z", "path": "RecentActivity/src/org/sleuthkit/autopsy/recentactivity/ExtractPrefetch.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ *\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.recentactivity;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Level;\n+import org.openide.modules.InstalledFileLocator;\n+import org.openide.util.NbBundle.Messages;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.casemodule.services.FileManager;\n+import org.sleuthkit.autopsy.coreutils.ExecUtil;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.coreutils.PlatformUtil;\n+import org.sleuthkit.autopsy.coreutils.SQLiteDBConnect;\n+import org.sleuthkit.autopsy.datamodel.ContentUtils;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProcessTerminator;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress;\n+import org.sleuthkit.autopsy.ingest.IngestJobContext;\n+import org.sleuthkit.datamodel.AbstractFile;\n+import org.sleuthkit.datamodel.Blackboard;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE.TSK_ASSOCIATED_OBJECT;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Extract the Prefetch Files and process them thru an External program.  The data will then be added to the \n+ * TSK_PROG_RUN artifact.  Associated artifacts will be created if possible. \n+ */\n+final class ExtractPrefetch extends Extract {\n+\n+    private static final Logger logger = Logger.getLogger(ExtractPrefetch.class.getName());\n+\n+    private IngestJobContext context;\n+\n+\n+    private static final String MODULE_NAME = \"extractPREFETCH\"; //NON-NLS\n+\n+    private static final String PREFETCH_TSK_COMMENT = \"Prefetch File\";\n+    private static final String PREFETCH_FILE_LOCATION = \"/Windows/Prefetch\";\n+    private static final String PREFETCH_TOOL_FOLDER = \"markmckinnon\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_64 = \"parse_prefetch_64.exe\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_32 = \"parse_prefetch_32.exe\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_MACOS = \"parse_prefetch_macos\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_LINUX = \"parse_prefetch_linux\"; //NON-NLS\n+    private static final String PREFETCH_OUTPUT_FILE_NAME = \"Output.txt\"; //NON-NLS\n+    private static final String PREFETCH_ERROR_FILE_NAME = \"Error.txt\"; //NON-NLS\n+    private static final String PREFETCH_PARSER_DB_FILE = \"Autopsy_PF_DB.db3\"; //NON-NLS\n+    private static final String PREFETCH_DIR_NAME = \"prefetch\"; //NON-NLS\n+\n+    @Messages({\n+        \"ExtractPrefetch_module_name=Windows Prefetch Extractor\"\n+    })\n+    ExtractPrefetch() {\n+        this.moduleName = Bundle.ExtractPrefetch_module_name();\n+    }\n+\n+    @Override\n+    void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) {\n+\n+        this.context = context;\n+\n+        String modOutPath = Case.getCurrentCase().getModuleDirectory() + File.separator + PREFETCH_DIR_NAME;\n+        File dir = new File(modOutPath);\n+        if (dir.exists() == false) {\n+            dir.mkdirs();\n+        }\n+        \n+        extractPrefetchFiles(dataSource);\n+        \n+        final String prefetchDumper = getPathForPrefetchDumper();\n+        if (prefetchDumper == null) {\n+            logger.log(Level.SEVERE, \"Error finding parse_prefetch program\"); //NON-NLS\n+            return; //If we cannot find the parse_prefetch program we cannot proceed\n+        }\n+\n+        if (context.dataSourceIngestIsCancelled()) {\n+            return;\n+        }\n+\n+        String modOutFile = modOutPath + File.separator + PREFETCH_PARSER_DB_FILE;\n+        try {\n+            String tempDirPath = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), PREFETCH_DIR_NAME );\n+            parsePrefetchFiles(prefetchDumper, tempDirPath, modOutFile, modOutPath);\n+            createAppExecArtifacts(modOutFile);\n+        } catch (IOException ex) {\n+            logger.log(Level.WARNING, \"Error runing parse_prefetch or creating artifacts.\", ex); //NON-NLS             \n+        }\n+    }\n+    \n+    /**\n+     * Extract prefetch file to temp directory to process.  Checks to make sure that the prefetch files only\n+     * come from the /Windows/Prefetch directory\n+     * \n+     * @param dataSource - datasource to search for prefetch files\n+     * \n+     */\n+\n+    void extractPrefetchFiles(Content dataSource) {\n+        List<AbstractFile> pFiles;\n+\n+        FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n+\n+        try {\n+            pFiles = fileManager.findFiles(dataSource, \"%.pf\"); //NON-NLS            \n+        } catch (TskCoreException ex) {\n+            logger.log(Level.WARNING, \"Unable to find prefetch files.\", ex); //NON-NLS\n+            return;  // No need to continue\n+        }\n+\n+        for (AbstractFile pFile : pFiles) {\n+\n+            if (context.dataSourceIngestIsCancelled()) {\n+                return;\n+            }\n+\n+            String prefetchFile = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), \"prefetch\") + File.separator + pFile.getName();\n+            if (pFile.getParentPath().contains(PREFETCH_FILE_LOCATION)) {\n+                try {\n+                    ContentUtils.writeToFile(pFile, new File(prefetchFile));\n+                } catch (IOException ex) {\n+                    logger.log(Level.WARNING, String.format(\"Unable to write %s to temp directory. File name: %s\", pFile.getName(), prefetchFile), ex); //NON-NLS\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    /**\n+     * Run the export parse_prefetch program against the prefetch files\n+     *\n+     * @param prefetchExePath - Path to the Executable to run\n+     * @param prefetchDir - Directory where the prefetch files reside to be processed. \n+     * @param tempOutFile - Output database file name and path.\n+     * @param tempOutPath - Directory to store the output and error files.\n+     *\n+     * @throws FileNotFoundException\n+     * @throws IOException\n+     */\n+    void parsePrefetchFiles(String prefetchExePath, String prefetchDir, String tempOutFile, String tempOutPath) throws FileNotFoundException, IOException {\n+        final Path outputFilePath = Paths.get(tempOutPath, PREFETCH_OUTPUT_FILE_NAME);\n+        final Path errFilePath = Paths.get(tempOutPath, PREFETCH_ERROR_FILE_NAME);\n+\n+        List<String> commandLine = new ArrayList<>();\n+        commandLine.add(prefetchExePath);\n+        commandLine.add(prefetchDir);  //NON-NLS\n+        commandLine.add(tempOutFile);\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(commandLine);\n+        processBuilder.redirectOutput(outputFilePath.toFile());\n+        processBuilder.redirectError(errFilePath.toFile());\n+\n+        ExecUtil.execute(processBuilder, new DataSourceIngestModuleProcessTerminator(context));\n+    }\n+    \n+    /**\n+     * Get the path and executable for the parse_prefetch program.  Checks for specific version of OS to\n+     * get proper executable.\n+     * \n+     * @return - path and executable to run.\n+     * \n+     */\n+\n+    private String getPathForPrefetchDumper() {\n+        Path path = null;\n+        if (PlatformUtil.isWindowsOS()) {\n+            if (PlatformUtil.is64BitOS()) {\n+                path = Paths.get(PREFETCH_TOOL_FOLDER, PREFETCH_TOOL_NAME_WINDOWS_64);\n+            } else {\n+                path = Paths.get(PREFETCH_TOOL_FOLDER, PREFETCH_TOOL_NAME_WINDOWS_32);            \n+            }\n+        } else {\n+            if (\"Linux\".equals(PlatformUtil.getOSName())) {\n+                path = Paths.get(PREFETCH_TOOL_FOLDER, PREFETCH_TOOL_NAME_LINUX);\n+            } else {\n+                path = Paths.get(PREFETCH_TOOL_FOLDER, PREFETCH_TOOL_NAME_MACOS);                \n+            }\n+        }\n+        File prefetchToolFile = InstalledFileLocator.getDefault().locate(path.toString(),\n+                ExtractPrefetch.class.getPackage().getName(), false);\n+        if (prefetchToolFile != null) {\n+            return prefetchToolFile.getAbsolutePath();\n+        }\n+\n+        return null;\n+\n+    }\n+    \n+    /**\n+     * Create the artifacts from external run of the parse_prefetch program\n+     * \n+     * @param prefetchDb - Database file to read from running the parse_prefetch program.\n+     * \n+     */\n+\n+    private void createAppExecArtifacts(String prefetchDb) {\n+        List<BlackboardArtifact> bba = new ArrayList<>();\n+\n+        String sqlStatement = \"SELECT prefetch_File_Name, actual_File_Name, file_path, Number_time_file_run, Embeded_date_Time_Unix_1, \" +\n+                              \" Embeded_date_Time_Unix_2, Embeded_date_Time_Unix_3, Embeded_date_Time_Unix_4, Embeded_date_Time_Unix_5,\" +\n+                              \" Embeded_date_Time_Unix_6, Embeded_date_Time_Unix_7, Embeded_date_Time_Unix_8 \" +\n+                              \" FROM prefetch_file_info;\"; //NON-NLS\n+\n+        try (SQLiteDBConnect tempdbconnect = new SQLiteDBConnect(\"org.sqlite.JDBC\", \"jdbc:sqlite:\" + prefetchDb); //NON-NLS\n+                ResultSet resultSet = tempdbconnect.executeQry(sqlStatement)) {\n+\n+            while (resultSet.next()) {\n+\n+                if (context.dataSourceIngestIsCancelled()) {\n+                    logger.log(Level.INFO, \"Cancelled Prefetch Artifact Creation.\"); //NON-NLS\n+                    return;\n+                }\n+\n+                String prefetchFileName = resultSet.getString(\"prefetch_File_Name\");\n+                String applicationName = resultSet.getString(\"actual_File_Name\"); //NON-NLS\n+                List<Long> executionTimes = new ArrayList<>();\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_1\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_2\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_3\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_4\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_5\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_6\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_7\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_8\")));\n+                String timesProgramRun = resultSet.getString(\"Number_time_file_run\"); \n+                String filePath = resultSet.getString(\"file_path\");\n+\n+                AbstractFile pfAbstractFile = getAbstractFile(prefetchFileName, PREFETCH_FILE_LOCATION);\n+               \n+                List<Long> prefetchExecutionTimes = findNonZeroExecutionTimes(executionTimes);\n+                \n+                if (pfAbstractFile != null) {\n+                    for (Long executionTime : prefetchExecutionTimes) {\n+\n+                        // only add prefetch file entries that have an actual date associated with them\n+                            Collection<BlackboardAttribute> bbattributes = Arrays.asList(\n+                                new BlackboardAttribute(\n+                                    BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME, getName(),\n+                                    applicationName),//NON-NLS\n+                                new BlackboardAttribute(\n+                                    BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME, getName(),\n+                                    executionTime),\n+                                new BlackboardAttribute(\n+                                    BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COUNT, getName(), Integer.valueOf(timesProgramRun)),\n+                                new BlackboardAttribute(\n+                                    BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COMMENT, getName(), PREFETCH_TSK_COMMENT));\n+\n+                            try {\n+                                BlackboardArtifact bbart = pfAbstractFile.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_PROG_RUN);\n+                                bbart.addAttributes(bbattributes);\n+                                bba.add(bbart);\n+                                BlackboardArtifact associateBbArtifact = createAssociatedArtifact(applicationName.toLowerCase(), filePath, bbart);\n+                                if (associateBbArtifact != null) {\n+                                    bba.add(associateBbArtifact);\n+                                }\n+                            } catch (TskCoreException ex) {\n+                                logger.log(Level.SEVERE, \"Exception Adding Artifact.\", ex);//NON-NLS\n+                            }\n+                    }\n+                } else {\n+                    logger.log(Level.SEVERE, \"File has a null value \" + prefetchFileName);//NON-NLS\n+                }\n+                    \n+            }\n+        } catch (SQLException ex) {\n+            logger.log(Level.SEVERE, \"Error while trying to read into a sqlite db.\", ex);//NON-NLS\n+        }\n+\n+        if (!bba.isEmpty()) {\n+            try {\n+                blackboard.postArtifacts(bba, MODULE_NAME);\n+            } catch (Blackboard.BlackboardException ex) {\n+                logger.log(Level.SEVERE, \"Error Posting Artifact.\", ex);//NON-NLS\n+            }\n+        }\n+    }\n+\n+   /**\n+    * Cycle thru the execution times list and only return a new list of times that are greater than zero.\n+    * \n+    * @param executionTimes - list of prefetch execution times 8 possible timestamps\n+    * \n+    * @return List of timestamps that are greater than zero\n+    */\n+    \n+   private List<Long> findNonZeroExecutionTimes(List<Long> executionTimes) {\n+       List<Long> prefetchExecutionTimes = new ArrayList<>();  \n+       for (Long executionTime : executionTimes) {                        // only add prefetch file entries that have an actual date associated with them\n+           if (executionTime > 0) {\n+               prefetchExecutionTimes.add(executionTime);\n+           }                 \n+       }\n+       return prefetchExecutionTimes;\n+   }    \n+   /**\n+     * Create associated artifacts using file path name and the artifact it associates with\n+     * \n+     * @param filePathName file and path of object being associated with\n+     * @param bba blackboard artifact to associate with\n+     * \n+     * @returnv BlackboardArtifact or a null value \n+     */  \n+    private BlackboardArtifact createAssociatedArtifact(String fileName, String filePathName, BlackboardArtifact bba) {\n+        AbstractFile sourceFile = getAbstractFile(fileName, filePathName);\n+        if (sourceFile != null) {\n+            Collection<BlackboardAttribute> bbattributes2 = new ArrayList<>();\n+            bbattributes2.addAll(Arrays.asList(\n+                 new BlackboardAttribute(TSK_ASSOCIATED_ARTIFACT, this.getName(),\n+                 bba.getArtifactID())));\n+\n+            BlackboardArtifact associatedObjectBba = createArtifactWithAttributes(TSK_ASSOCIATED_OBJECT, sourceFile, bbattributes2);\n+            if (associatedObjectBba != null) {\n+                return associatedObjectBba;\n+            }\n+        }\n+       \n+        return null;\n+    }\n+    \n+    /**\n+     * Get the abstract file for the prefetch file.\n+     * \n+     * @param fileName - File name of the prefetch file to find.\n+     * @param filePath - Path where the prefetch file is located.\n+     * \n+     * @return Abstract file of the prefetch file.\n+     * \n+     */\n+    \n+    AbstractFile getAbstractFile(String fileName, String filePath) {\n+        List<AbstractFile> files;\n+        \n+        FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n+\n+        try {\n+            files = fileManager.findFiles(fileName, filePath); //NON-NLS            \n+        } catch (TskCoreException ex) {\n+            logger.log(Level.WARNING, \"Unable to find prefetch files.\", ex); //NON-NLS\n+            return null;  // No need to continue\n+        }\n+        \n+        if (!files.isEmpty()) {\n+            return files.get(0);", "originalCommit": "3e6e876df1b0572cfa832abe14ea5f7c60851f2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ1Mzk5NQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439453995", "bodyText": "That is correct, I have added the datasource to the findfiles.", "author": "markmckinnon", "createdAt": "2020-06-12T14:29:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2MDYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMw==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439065903", "bodyText": "Out of curiosity, did you write the prefetch executables?", "author": "dannysmyda", "createdAt": "2020-06-11T20:55:33Z", "path": "RecentActivity/src/org/sleuthkit/autopsy/recentactivity/ExtractPrefetch.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ *\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.recentactivity;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Level;\n+import org.openide.modules.InstalledFileLocator;\n+import org.openide.util.NbBundle.Messages;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.casemodule.services.FileManager;\n+import org.sleuthkit.autopsy.coreutils.ExecUtil;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.coreutils.PlatformUtil;\n+import org.sleuthkit.autopsy.coreutils.SQLiteDBConnect;\n+import org.sleuthkit.autopsy.datamodel.ContentUtils;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProcessTerminator;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress;\n+import org.sleuthkit.autopsy.ingest.IngestJobContext;\n+import org.sleuthkit.datamodel.AbstractFile;\n+import org.sleuthkit.datamodel.Blackboard;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE.TSK_ASSOCIATED_OBJECT;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Extract the Prefetch Files and process them thru an External program.  The data will then be added to the \n+ * TSK_PROG_RUN artifact.  Associated artifacts will be created if possible. \n+ */\n+final class ExtractPrefetch extends Extract {\n+\n+    private static final Logger logger = Logger.getLogger(ExtractPrefetch.class.getName());\n+\n+    private IngestJobContext context;\n+\n+\n+    private static final String MODULE_NAME = \"extractPREFETCH\"; //NON-NLS\n+\n+    private static final String PREFETCH_TSK_COMMENT = \"Prefetch File\";\n+    private static final String PREFETCH_FILE_LOCATION = \"/Windows/Prefetch\";\n+    private static final String PREFETCH_TOOL_FOLDER = \"markmckinnon\"; //NON-NLS", "originalCommit": "3e6e876df1b0572cfa832abe14ea5f7c60851f2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE2MDk1MQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439160951", "bodyText": "Yes, this is the same executable as the third party plugin, once this PR is accepted I will move the code into the following repository https://github.com/markmckinnon/Prefetch_Parser_Autopsy.", "author": "markmckinnon", "createdAt": "2020-06-12T01:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NzM5Mg==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439067392", "bodyText": "Could you make these variable names more descriptive? bbart and bba", "author": "dannysmyda", "createdAt": "2020-06-11T20:58:37Z", "path": "RecentActivity/src/org/sleuthkit/autopsy/recentactivity/ExtractPrefetch.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ *\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.recentactivity;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Level;\n+import org.openide.modules.InstalledFileLocator;\n+import org.openide.util.NbBundle.Messages;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.casemodule.services.FileManager;\n+import org.sleuthkit.autopsy.coreutils.ExecUtil;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.coreutils.PlatformUtil;\n+import org.sleuthkit.autopsy.coreutils.SQLiteDBConnect;\n+import org.sleuthkit.autopsy.datamodel.ContentUtils;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProcessTerminator;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress;\n+import org.sleuthkit.autopsy.ingest.IngestJobContext;\n+import org.sleuthkit.datamodel.AbstractFile;\n+import org.sleuthkit.datamodel.Blackboard;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE.TSK_ASSOCIATED_OBJECT;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Extract the Prefetch Files and process them thru an External program.  The data will then be added to the \n+ * TSK_PROG_RUN artifact.  Associated artifacts will be created if possible. \n+ */\n+final class ExtractPrefetch extends Extract {\n+\n+    private static final Logger logger = Logger.getLogger(ExtractPrefetch.class.getName());\n+\n+    private IngestJobContext context;\n+\n+\n+    private static final String MODULE_NAME = \"extractPREFETCH\"; //NON-NLS\n+\n+    private static final String PREFETCH_TSK_COMMENT = \"Prefetch File\";\n+    private static final String PREFETCH_FILE_LOCATION = \"/Windows/Prefetch\";\n+    private static final String PREFETCH_TOOL_FOLDER = \"markmckinnon\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_64 = \"parse_prefetch_64.exe\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_32 = \"parse_prefetch_32.exe\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_MACOS = \"parse_prefetch_macos\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_LINUX = \"parse_prefetch_linux\"; //NON-NLS\n+    private static final String PREFETCH_OUTPUT_FILE_NAME = \"Output.txt\"; //NON-NLS\n+    private static final String PREFETCH_ERROR_FILE_NAME = \"Error.txt\"; //NON-NLS\n+    private static final String PREFETCH_PARSER_DB_FILE = \"Autopsy_PF_DB.db3\"; //NON-NLS\n+    private static final String PREFETCH_DIR_NAME = \"prefetch\"; //NON-NLS\n+\n+    @Messages({\n+        \"ExtractPrefetch_module_name=Windows Prefetch Extractor\"\n+    })\n+    ExtractPrefetch() {\n+        this.moduleName = Bundle.ExtractPrefetch_module_name();\n+    }\n+\n+    @Override\n+    void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) {\n+\n+        this.context = context;\n+\n+        String modOutPath = Case.getCurrentCase().getModuleDirectory() + File.separator + PREFETCH_DIR_NAME;\n+        File dir = new File(modOutPath);\n+        if (dir.exists() == false) {\n+            dir.mkdirs();\n+        }\n+        \n+        extractPrefetchFiles(dataSource);\n+        \n+        final String prefetchDumper = getPathForPrefetchDumper();\n+        if (prefetchDumper == null) {\n+            logger.log(Level.SEVERE, \"Error finding parse_prefetch program\"); //NON-NLS\n+            return; //If we cannot find the parse_prefetch program we cannot proceed\n+        }\n+\n+        if (context.dataSourceIngestIsCancelled()) {\n+            return;\n+        }\n+\n+        String modOutFile = modOutPath + File.separator + PREFETCH_PARSER_DB_FILE;\n+        try {\n+            String tempDirPath = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), PREFETCH_DIR_NAME );\n+            parsePrefetchFiles(prefetchDumper, tempDirPath, modOutFile, modOutPath);\n+            createAppExecArtifacts(modOutFile);\n+        } catch (IOException ex) {\n+            logger.log(Level.WARNING, \"Error runing parse_prefetch or creating artifacts.\", ex); //NON-NLS             \n+        }\n+    }\n+    \n+    /**\n+     * Extract prefetch file to temp directory to process.  Checks to make sure that the prefetch files only\n+     * come from the /Windows/Prefetch directory\n+     * \n+     * @param dataSource - datasource to search for prefetch files\n+     * \n+     */\n+\n+    void extractPrefetchFiles(Content dataSource) {\n+        List<AbstractFile> pFiles;\n+\n+        FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n+\n+        try {\n+            pFiles = fileManager.findFiles(dataSource, \"%.pf\"); //NON-NLS            \n+        } catch (TskCoreException ex) {\n+            logger.log(Level.WARNING, \"Unable to find prefetch files.\", ex); //NON-NLS\n+            return;  // No need to continue\n+        }\n+\n+        for (AbstractFile pFile : pFiles) {\n+\n+            if (context.dataSourceIngestIsCancelled()) {\n+                return;\n+            }\n+\n+            String prefetchFile = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), \"prefetch\") + File.separator + pFile.getName();\n+            if (pFile.getParentPath().contains(PREFETCH_FILE_LOCATION)) {\n+                try {\n+                    ContentUtils.writeToFile(pFile, new File(prefetchFile));\n+                } catch (IOException ex) {\n+                    logger.log(Level.WARNING, String.format(\"Unable to write %s to temp directory. File name: %s\", pFile.getName(), prefetchFile), ex); //NON-NLS\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    /**\n+     * Run the export parse_prefetch program against the prefetch files\n+     *\n+     * @param prefetchExePath - Path to the Executable to run\n+     * @param prefetchDir - Directory where the prefetch files reside to be processed. \n+     * @param tempOutFile - Output database file name and path.\n+     * @param tempOutPath - Directory to store the output and error files.\n+     *\n+     * @throws FileNotFoundException\n+     * @throws IOException\n+     */\n+    void parsePrefetchFiles(String prefetchExePath, String prefetchDir, String tempOutFile, String tempOutPath) throws FileNotFoundException, IOException {\n+        final Path outputFilePath = Paths.get(tempOutPath, PREFETCH_OUTPUT_FILE_NAME);\n+        final Path errFilePath = Paths.get(tempOutPath, PREFETCH_ERROR_FILE_NAME);\n+\n+        List<String> commandLine = new ArrayList<>();\n+        commandLine.add(prefetchExePath);\n+        commandLine.add(prefetchDir);  //NON-NLS\n+        commandLine.add(tempOutFile);\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(commandLine);\n+        processBuilder.redirectOutput(outputFilePath.toFile());\n+        processBuilder.redirectError(errFilePath.toFile());\n+\n+        ExecUtil.execute(processBuilder, new DataSourceIngestModuleProcessTerminator(context));\n+    }\n+    \n+    /**\n+     * Get the path and executable for the parse_prefetch program.  Checks for specific version of OS to\n+     * get proper executable.\n+     * \n+     * @return - path and executable to run.\n+     * \n+     */\n+\n+    private String getPathForPrefetchDumper() {\n+        Path path = null;\n+        if (PlatformUtil.isWindowsOS()) {\n+            if (PlatformUtil.is64BitOS()) {\n+                path = Paths.get(PREFETCH_TOOL_FOLDER, PREFETCH_TOOL_NAME_WINDOWS_64);\n+            } else {\n+                path = Paths.get(PREFETCH_TOOL_FOLDER, PREFETCH_TOOL_NAME_WINDOWS_32);            \n+            }\n+        } else {\n+            if (\"Linux\".equals(PlatformUtil.getOSName())) {\n+                path = Paths.get(PREFETCH_TOOL_FOLDER, PREFETCH_TOOL_NAME_LINUX);\n+            } else {\n+                path = Paths.get(PREFETCH_TOOL_FOLDER, PREFETCH_TOOL_NAME_MACOS);                \n+            }\n+        }\n+        File prefetchToolFile = InstalledFileLocator.getDefault().locate(path.toString(),\n+                ExtractPrefetch.class.getPackage().getName(), false);\n+        if (prefetchToolFile != null) {\n+            return prefetchToolFile.getAbsolutePath();\n+        }\n+\n+        return null;\n+\n+    }\n+    \n+    /**\n+     * Create the artifacts from external run of the parse_prefetch program\n+     * \n+     * @param prefetchDb - Database file to read from running the parse_prefetch program.\n+     * \n+     */\n+\n+    private void createAppExecArtifacts(String prefetchDb) {\n+        List<BlackboardArtifact> bba = new ArrayList<>();\n+\n+        String sqlStatement = \"SELECT prefetch_File_Name, actual_File_Name, file_path, Number_time_file_run, Embeded_date_Time_Unix_1, \" +\n+                              \" Embeded_date_Time_Unix_2, Embeded_date_Time_Unix_3, Embeded_date_Time_Unix_4, Embeded_date_Time_Unix_5,\" +\n+                              \" Embeded_date_Time_Unix_6, Embeded_date_Time_Unix_7, Embeded_date_Time_Unix_8 \" +\n+                              \" FROM prefetch_file_info;\"; //NON-NLS\n+\n+        try (SQLiteDBConnect tempdbconnect = new SQLiteDBConnect(\"org.sqlite.JDBC\", \"jdbc:sqlite:\" + prefetchDb); //NON-NLS\n+                ResultSet resultSet = tempdbconnect.executeQry(sqlStatement)) {\n+\n+            while (resultSet.next()) {\n+\n+                if (context.dataSourceIngestIsCancelled()) {\n+                    logger.log(Level.INFO, \"Cancelled Prefetch Artifact Creation.\"); //NON-NLS\n+                    return;\n+                }\n+\n+                String prefetchFileName = resultSet.getString(\"prefetch_File_Name\");\n+                String applicationName = resultSet.getString(\"actual_File_Name\"); //NON-NLS\n+                List<Long> executionTimes = new ArrayList<>();\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_1\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_2\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_3\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_4\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_5\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_6\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_7\")));\n+                executionTimes.add(Long.valueOf(resultSet.getInt(\"Embeded_date_Time_Unix_8\")));\n+                String timesProgramRun = resultSet.getString(\"Number_time_file_run\"); \n+                String filePath = resultSet.getString(\"file_path\");\n+\n+                AbstractFile pfAbstractFile = getAbstractFile(prefetchFileName, PREFETCH_FILE_LOCATION);\n+               \n+                List<Long> prefetchExecutionTimes = findNonZeroExecutionTimes(executionTimes);\n+                \n+                if (pfAbstractFile != null) {\n+                    for (Long executionTime : prefetchExecutionTimes) {\n+\n+                        // only add prefetch file entries that have an actual date associated with them\n+                            Collection<BlackboardAttribute> bbattributes = Arrays.asList(\n+                                new BlackboardAttribute(\n+                                    BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME, getName(),\n+                                    applicationName),//NON-NLS\n+                                new BlackboardAttribute(\n+                                    BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME, getName(),\n+                                    executionTime),\n+                                new BlackboardAttribute(\n+                                    BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COUNT, getName(), Integer.valueOf(timesProgramRun)),\n+                                new BlackboardAttribute(\n+                                    BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COMMENT, getName(), PREFETCH_TSK_COMMENT));\n+\n+                            try {\n+                                BlackboardArtifact bbart = pfAbstractFile.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_PROG_RUN);", "originalCommit": "3e6e876df1b0572cfa832abe14ea5f7c60851f2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NzIyMg==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439587222", "bodyText": "Done", "author": "markmckinnon", "createdAt": "2020-06-12T18:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NzM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2ODQ0NA==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439068444", "bodyText": "I think this should use PREFETCH_DIR_NAME instead", "author": "dannysmyda", "createdAt": "2020-06-11T21:00:56Z", "path": "RecentActivity/src/org/sleuthkit/autopsy/recentactivity/ExtractPrefetch.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ *\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.recentactivity;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Level;\n+import org.openide.modules.InstalledFileLocator;\n+import org.openide.util.NbBundle.Messages;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.casemodule.services.FileManager;\n+import org.sleuthkit.autopsy.coreutils.ExecUtil;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.coreutils.PlatformUtil;\n+import org.sleuthkit.autopsy.coreutils.SQLiteDBConnect;\n+import org.sleuthkit.autopsy.datamodel.ContentUtils;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProcessTerminator;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress;\n+import org.sleuthkit.autopsy.ingest.IngestJobContext;\n+import org.sleuthkit.datamodel.AbstractFile;\n+import org.sleuthkit.datamodel.Blackboard;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE.TSK_ASSOCIATED_OBJECT;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Extract the Prefetch Files and process them thru an External program.  The data will then be added to the \n+ * TSK_PROG_RUN artifact.  Associated artifacts will be created if possible. \n+ */\n+final class ExtractPrefetch extends Extract {\n+\n+    private static final Logger logger = Logger.getLogger(ExtractPrefetch.class.getName());\n+\n+    private IngestJobContext context;\n+\n+\n+    private static final String MODULE_NAME = \"extractPREFETCH\"; //NON-NLS\n+\n+    private static final String PREFETCH_TSK_COMMENT = \"Prefetch File\";\n+    private static final String PREFETCH_FILE_LOCATION = \"/Windows/Prefetch\";\n+    private static final String PREFETCH_TOOL_FOLDER = \"markmckinnon\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_64 = \"parse_prefetch_64.exe\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_32 = \"parse_prefetch_32.exe\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_MACOS = \"parse_prefetch_macos\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_LINUX = \"parse_prefetch_linux\"; //NON-NLS\n+    private static final String PREFETCH_OUTPUT_FILE_NAME = \"Output.txt\"; //NON-NLS\n+    private static final String PREFETCH_ERROR_FILE_NAME = \"Error.txt\"; //NON-NLS\n+    private static final String PREFETCH_PARSER_DB_FILE = \"Autopsy_PF_DB.db3\"; //NON-NLS\n+    private static final String PREFETCH_DIR_NAME = \"prefetch\"; //NON-NLS\n+\n+    @Messages({\n+        \"ExtractPrefetch_module_name=Windows Prefetch Extractor\"\n+    })\n+    ExtractPrefetch() {\n+        this.moduleName = Bundle.ExtractPrefetch_module_name();\n+    }\n+\n+    @Override\n+    void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) {\n+\n+        this.context = context;\n+\n+        String modOutPath = Case.getCurrentCase().getModuleDirectory() + File.separator + PREFETCH_DIR_NAME;\n+        File dir = new File(modOutPath);\n+        if (dir.exists() == false) {\n+            dir.mkdirs();\n+        }\n+        \n+        extractPrefetchFiles(dataSource);\n+        \n+        final String prefetchDumper = getPathForPrefetchDumper();\n+        if (prefetchDumper == null) {\n+            logger.log(Level.SEVERE, \"Error finding parse_prefetch program\"); //NON-NLS\n+            return; //If we cannot find the parse_prefetch program we cannot proceed\n+        }\n+\n+        if (context.dataSourceIngestIsCancelled()) {\n+            return;\n+        }\n+\n+        String modOutFile = modOutPath + File.separator + PREFETCH_PARSER_DB_FILE;\n+        try {\n+            String tempDirPath = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), PREFETCH_DIR_NAME );\n+            parsePrefetchFiles(prefetchDumper, tempDirPath, modOutFile, modOutPath);\n+            createAppExecArtifacts(modOutFile);\n+        } catch (IOException ex) {\n+            logger.log(Level.WARNING, \"Error runing parse_prefetch or creating artifacts.\", ex); //NON-NLS             \n+        }\n+    }\n+    \n+    /**\n+     * Extract prefetch file to temp directory to process.  Checks to make sure that the prefetch files only\n+     * come from the /Windows/Prefetch directory\n+     * \n+     * @param dataSource - datasource to search for prefetch files\n+     * \n+     */\n+\n+    void extractPrefetchFiles(Content dataSource) {\n+        List<AbstractFile> pFiles;\n+\n+        FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n+\n+        try {\n+            pFiles = fileManager.findFiles(dataSource, \"%.pf\"); //NON-NLS            \n+        } catch (TskCoreException ex) {\n+            logger.log(Level.WARNING, \"Unable to find prefetch files.\", ex); //NON-NLS\n+            return;  // No need to continue\n+        }\n+\n+        for (AbstractFile pFile : pFiles) {\n+\n+            if (context.dataSourceIngestIsCancelled()) {\n+                return;\n+            }\n+\n+            String prefetchFile = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), \"prefetch\") + File.separator + pFile.getName();", "originalCommit": "3e6e876df1b0572cfa832abe14ea5f7c60851f2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ1NDI2Mg==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r439454262", "bodyText": "Good catch.  Fixed.", "author": "markmckinnon", "createdAt": "2020-06-12T14:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2ODQ0NA=="}], "type": "inlineReview"}, {"oid": "0d0c28e32e331dc82536837c0029f5d62245a456", "url": "https://github.com/sleuthkit/autopsy/commit/0d0c28e32e331dc82536837c0029f5d62245a456", "message": "Update ExtractPrefetch.java\n\nAddress Reviewer comments about PREFETCH_DIR_NAME and File coming from correct dataSource", "committedDate": "2020-06-12T14:28:53Z", "type": "commit"}, {"oid": "e999b66479539bfa08b77fd7096c1fe248e7fc09", "url": "https://github.com/sleuthkit/autopsy/commit/e999b66479539bfa08b77fd7096c1fe248e7fc09", "message": "Update ExtractPrefetch.java\n\nReview comments", "committedDate": "2020-06-12T18:45:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwODUzOA==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r442908538", "bodyText": "I completely missed this the first time around, but my InstalledFileLocator problem was simply because these names don't match whats in thirdparty. They should be:\n'parse_prefetch_x64.exe'\n'parse_prefetch_x86.exe'", "author": "dannysmyda", "createdAt": "2020-06-19T15:33:52Z", "path": "RecentActivity/src/org/sleuthkit/autopsy/recentactivity/ExtractPrefetch.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ *\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.recentactivity;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Level;\n+import org.openide.modules.InstalledFileLocator;\n+import org.openide.util.NbBundle.Messages;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.casemodule.services.FileManager;\n+import org.sleuthkit.autopsy.coreutils.ExecUtil;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.coreutils.PlatformUtil;\n+import org.sleuthkit.autopsy.coreutils.SQLiteDBConnect;\n+import org.sleuthkit.autopsy.datamodel.ContentUtils;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProcessTerminator;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress;\n+import org.sleuthkit.autopsy.ingest.IngestJobContext;\n+import org.sleuthkit.datamodel.AbstractFile;\n+import org.sleuthkit.datamodel.Blackboard;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE.TSK_ASSOCIATED_OBJECT;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Extract the Prefetch Files and process them thru an External program.  The data will then be added to the \n+ * TSK_PROG_RUN artifact.  Associated artifacts will be created if possible. \n+ */\n+final class ExtractPrefetch extends Extract {\n+\n+    private static final Logger logger = Logger.getLogger(ExtractPrefetch.class.getName());\n+\n+    private IngestJobContext context;\n+\n+\n+    private static final String MODULE_NAME = \"extractPREFETCH\"; //NON-NLS\n+\n+    private static final String PREFETCH_TSK_COMMENT = \"Prefetch File\";\n+    private static final String PREFETCH_FILE_LOCATION = \"/Windows/Prefetch\";\n+    private static final String PREFETCH_TOOL_FOLDER = \"markmckinnon\"; //NON-NLS\n+    private static final String PREFETCH_TOOL_NAME_WINDOWS_64 = \"parse_prefetch_64.exe\"; //NON-NLS", "originalCommit": "e999b66479539bfa08b77fd7096c1fe248e7fc09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyMjc1OQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5945#discussion_r442922759", "bodyText": "Not sure what happened there but it is now fixed.", "author": "markmckinnon", "createdAt": "2020-06-19T16:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwODUzOA=="}], "type": "inlineReview"}, {"oid": "146af612e1617171021f11a530fb6ec4d79c0a3f", "url": "https://github.com/sleuthkit/autopsy/commit/146af612e1617171021f11a530fb6ec4d79c0a3f", "message": "Update ExtractPrefetch.java\n\nFIx to parse prefetch program name", "committedDate": "2020-06-19T15:59:37Z", "type": "commit"}]}