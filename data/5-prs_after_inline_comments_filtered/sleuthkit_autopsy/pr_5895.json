{"pr_number": 5895, "pr_title": "6332 annotation viewer", "pr_createdAt": "2020-05-14T12:17:54Z", "pr_url": "https://github.com/sleuthkit/autopsy/pull/5895", "timeline": [{"oid": "984507f2ecc2eed4af50e4d92401d513ff5a3507", "url": "https://github.com/sleuthkit/autopsy/commit/984507f2ecc2eed4af50e4d92401d513ff5a3507", "message": "annotations viewer update for tsk hash hit", "committedDate": "2020-05-06T18:27:48Z", "type": "commit"}, {"oid": "23782a90ccd4e5b8fbc001e09ea48f4cc803ef34", "url": "https://github.com/sleuthkit/autopsy/commit/23782a90ccd4e5b8fbc001e09ea48f4cc803ef34", "message": "updates for comments and formatting", "committedDate": "2020-05-06T19:16:15Z", "type": "commit"}, {"oid": "f6ed6462a2f6be1c7603e71ff9e36e325a1de53e", "url": "https://github.com/sleuthkit/autopsy/commit/f6ed6462a2f6be1c7603e71ff9e36e325a1de53e", "message": "integrating jsoup", "committedDate": "2020-05-07T20:33:27Z", "type": "commit"}, {"oid": "3dce7f528bc36041a3d40f9d3afa45f5ea87bda6", "url": "https://github.com/sleuthkit/autopsy/commit/3dce7f528bc36041a3d40f9d3afa45f5ea87bda6", "message": "Merge branch 'develop' of github.com:sleuthkit/autopsy into 6332-annotationViewer", "committedDate": "2020-05-08T14:46:06Z", "type": "commit"}, {"oid": "b0373a7e612dacedf170a7b73de5203c4cec0ea6", "url": "https://github.com/sleuthkit/autopsy/commit/b0373a7e612dacedf170a7b73de5203c4cec0ea6", "message": "refactoring", "committedDate": "2020-05-08T14:46:27Z", "type": "commit"}, {"oid": "474a1cbede89ce273ca395a756860bab9eeed421", "url": "https://github.com/sleuthkit/autopsy/commit/474a1cbede89ce273ca395a756860bab9eeed421", "message": "finishing comments and some rough edges", "committedDate": "2020-05-08T19:41:34Z", "type": "commit"}, {"oid": "6356a72591c2be46ca7b73302c9c3b885ae5e0f9", "url": "https://github.com/sleuthkit/autopsy/commit/6356a72591c2be46ca7b73302c9c3b885ae5e0f9", "message": "commenting", "committedDate": "2020-05-08T20:02:40Z", "type": "commit"}, {"oid": "df1c1763a8b0ca2875719f7198322382e4e496c5", "url": "https://github.com/sleuthkit/autopsy/commit/df1c1763a8b0ca2875719f7198322382e4e496c5", "message": "update for Artifact Comment", "committedDate": "2020-05-12T16:46:37Z", "type": "commit"}, {"oid": "77f17598ce93281f7b7eae37a9f1603a5a3a27d1", "url": "https://github.com/sleuthkit/autopsy/commit/77f17598ce93281f7b7eae37a9f1603a5a3a27d1", "message": "updates to annotation viewer to not show sections with no data", "committedDate": "2020-05-13T19:40:48Z", "type": "commit"}, {"oid": "e57ab0f0424bebd8505ef3a97b7c905163ae8193", "url": "https://github.com/sleuthkit/autopsy/commit/e57ab0f0424bebd8505ef3a97b7c905163ae8193", "message": "updated annotation viewer comments", "committedDate": "2020-05-13T19:56:44Z", "type": "commit"}, {"oid": "55af9fc3086345328ef21fd95a5db6ff98c090bd", "url": "https://github.com/sleuthkit/autopsy/commit/55af9fc3086345328ef21fd95a5db6ff98c090bd", "message": "Merge branch 'develop' of github.com:sleuthkit/autopsy into 6332-annotationViewer", "committedDate": "2020-05-13T19:57:02Z", "type": "commit"}, {"oid": "c6aaa0aad30a9fc032147b340d584b7a1d152998", "url": "https://github.com/sleuthkit/autopsy/commit/c6aaa0aad30a9fc032147b340d584b7a1d152998", "message": "fixes for CR comments and only render if content", "committedDate": "2020-05-14T12:15:29Z", "type": "commit"}, {"oid": "233acdfbafd887a5d1e64b7e6c29724e1fecfb5e", "url": "https://github.com/sleuthkit/autopsy/commit/233acdfbafd887a5d1e64b7e6c29724e1fecfb5e", "message": "addressing codacy remark", "committedDate": "2020-05-14T12:24:13Z", "type": "commit"}, {"oid": "3c517371a0be3d575627426d4ad988c76932b432", "url": "https://github.com/sleuthkit/autopsy/commit/3c517371a0be3d575627426d4ad988c76932b432", "message": "only non-blank comments for fileset hits", "committedDate": "2020-05-15T11:40:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwNTI3MQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5895#discussion_r425805271", "bodyText": "This type of comment produces doxygen warnings. Please remove all instances.", "author": "APriestman", "createdAt": "2020-05-15T13:34:09Z", "path": "Core/src/org/sleuthkit/autopsy/contentviewers/AnnotationsContentViewer.java", "diffHunk": "@@ -101,279 +272,441 @@ public void setNode(Node node) {\n                     artifact.getDisplayName(), artifact.getArtifactID()), ex);\n         }\n \n+        boolean somethingWasRendered = false;\n         if (artifact != null) {\n-            populateTagData(html, artifact, sourceFile);\n+            somethingWasRendered = renderArtifact(body, artifact, sourceFile);\n         } else {\n-            populateTagData(html, sourceFile);\n+            somethingWasRendered = renderContent(body, sourceFile, false);\n         }\n \n-        if (sourceFile instanceof AbstractFile) {\n-            populateCentralRepositoryData(html, artifact, (AbstractFile) sourceFile);\n+        if (!somethingWasRendered) {\n+            appendMessage(body, Bundle.AnnotationsContentViewer_onEmpty());\n         }\n \n-        setText(html.toString());\n+        jTextPane1.setText(html.html());\n         jTextPane1.setCaretPosition(0);\n     }\n \n     /**\n-     * Populate the \"Selected Item\" sections with tag data for the supplied\n-     * content.\n+     * Renders annotations for an artifact.\n+     *\n+     * @param parent        The html element to render content int.\n+     * @param bba           The blackboard artifact to render.\n+     * @param sourceContent The content from which the blackboard artifact\n+     *                      comes.\n      *\n-     * @param html    The HTML text to update.\n-     * @param content Selected content.\n+     * @return If any content was actually rendered.\n      */\n-    private void populateTagData(StringBuilder html, Content content) {\n-        try {\n-            SleuthkitCase tskCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+    private static boolean renderArtifact(Element parent, BlackboardArtifact bba, Content sourceContent) {\n+        boolean contentRendered = appendEntries(parent, TAG_CONFIG, getTags(bba), false);\n \n-            startSection(html, \"Selected Item\");\n-            List<ContentTag> fileTagsList = tskCase.getContentTagsByContent(content);\n-            if (fileTagsList.isEmpty()) {\n-                addMessage(html, \"There are no tags for the selected content.\");\n-            } else {\n-                for (ContentTag tag : fileTagsList) {\n-                    addTagEntry(html, tag);\n-                }\n+        if (CentralRepository.isEnabled()) {\n+            List<CorrelationAttributeInstance> centralRepoComments = getCentralRepositoryData(bba);\n+            boolean crRendered = appendEntries(parent, CR_COMMENTS_CONFIG, centralRepoComments, false);\n+            contentRendered = contentRendered || crRendered;\n+        }\n+\n+        // if artifact is a hashset hit or interesting file and has a non-blank comment\n+        if ((ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID() == bba.getArtifactTypeID()\n+                || ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT.getTypeID() == bba.getArtifactTypeID())\n+                && (hasTskComment(bba))) {\n+\n+            boolean filesetRendered = appendEntries(parent, ARTIFACT_COMMENT_CONFIG, Arrays.asList(bba), false);\n+            contentRendered = contentRendered || filesetRendered;\n+        }\n+\n+        Element sourceFileSection = appendSection(parent, Bundle.AnnotationsContentViewer_sourceFile_title());\n+        boolean sourceFileRendered = renderContent(sourceFileSection, sourceContent, true);\n+\n+        if (!sourceFileRendered) {\n+            sourceFileSection.remove();\n+        }\n+\n+        return contentRendered || sourceFileRendered;\n+    }\n+\n+    /**\n+     * Renders annotations for a content item.\n+     *\n+     * @param parent        The parent within which to render.\n+     * @param sourceContent The content for which annotations will be gathered.\n+     * @param isSubheader   True if this section should be rendered as a\n+     *                      subheader as opposed to a top-level header.\n+     *\n+     * @return If any content was actually rendered.\n+     */\n+    private static boolean renderContent(Element parent, Content sourceContent, boolean isSubheader) {\n+        boolean contentRendered = appendEntries(parent, TAG_CONFIG, getTags(sourceContent), isSubheader);\n+\n+        if (sourceContent instanceof AbstractFile) {\n+            AbstractFile sourceFile = (AbstractFile) sourceContent;\n+\n+            if (CentralRepository.isEnabled()) {\n+                List<CorrelationAttributeInstance> centralRepoComments = getCentralRepositoryData(sourceFile);\n+                boolean crRendered = appendEntries(parent, CR_COMMENTS_CONFIG, centralRepoComments, isSubheader);\n+                contentRendered = contentRendered || crRendered;\n             }\n-            endSection(html);\n+\n+            boolean hashsetRendered = appendEntries(parent, HASHSET_CONFIG,\n+                    getFileSetHits(sourceFile, ARTIFACT_TYPE.TSK_HASHSET_HIT),\n+                    isSubheader);\n+\n+            boolean interestingFileRendered = appendEntries(parent, INTERESTING_FILE_CONFIG,\n+                    getFileSetHits(sourceFile, ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT),\n+                    isSubheader);\n+\n+            contentRendered = contentRendered || hashsetRendered || interestingFileRendered;\n+        }\n+        return contentRendered;\n+    }\n+\n+    /**\n+     * Retrieves tags associated with a content item.\n+     *\n+     * @param sourceContent The content for which to gather content.\n+     *\n+     * @return The Tags associated with this item.\n+     */\n+    private static List<ContentTag> getTags(Content sourceContent) {\n+        try {\n+            SleuthkitCase tskCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+            return tskCase.getContentTagsByContent(sourceContent);\n         } catch (NoCurrentCaseException ex) {\n             logger.log(Level.SEVERE, \"Exception while getting open case.\", ex); // NON-NLS\n         } catch (TskCoreException ex) {\n             logger.log(Level.SEVERE, \"Exception while getting tags from the case database.\", ex); //NON-NLS\n         }\n+        return new ArrayList<>();\n     }\n \n     /**\n-     * Populate the \"Selected Item\" and \"Source File\" sections with tag data for\n-     * a supplied artifact.\n+     * Retrieves tags for blackboard artifact tags.\n+     *\n+     * @param bba The blackboard artifact for which to retrieve tags.\n      *\n-     * @param html       The HTML text to update.\n-     * @param artifact   A selected artifact.\n-     * @param sourceFile The source content of the selected artifact.\n+     * @return The found tags.\n      */\n-    private void populateTagData(StringBuilder html, BlackboardArtifact artifact, Content sourceFile) {\n+    private static List<BlackboardArtifactTag> getTags(BlackboardArtifact bba) {\n         try {\n             SleuthkitCase tskCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n-\n-            startSection(html, \"Selected Item\");\n-            List<BlackboardArtifactTag> artifactTagsList = tskCase.getBlackboardArtifactTagsByArtifact(artifact);\n-            if (artifactTagsList.isEmpty()) {\n-                addMessage(html, \"There are no tags for the selected artifact.\");\n-            } else {\n-                for (BlackboardArtifactTag tag : artifactTagsList) {\n-                    addTagEntry(html, tag);\n-                }\n-            }\n-            endSection(html);\n-\n-            if (sourceFile != null) {\n-                startSection(html, \"Source File\");\n-                List<ContentTag> fileTagsList = tskCase.getContentTagsByContent(sourceFile);\n-                if (fileTagsList.isEmpty()) {\n-                    addMessage(html, \"There are no tags for the source content.\");\n-                } else {\n-                    for (ContentTag tag : fileTagsList) {\n-                        addTagEntry(html, tag);\n-                    }\n-                }\n-                endSection(html);\n-            }\n+            return tskCase.getBlackboardArtifactTagsByArtifact(bba);\n         } catch (NoCurrentCaseException ex) {\n             logger.log(Level.SEVERE, \"Exception while getting open case.\", ex); // NON-NLS\n         } catch (TskCoreException ex) {\n             logger.log(Level.SEVERE, \"Exception while getting tags from the case database.\", ex); //NON-NLS\n         }\n+        return new ArrayList<>();\n     }\n \n     /**\n-     * Populate the \"Central Repository Comments\" section with data.\n+     * Retrieves the blackboard artifacts for a source file matching a certain\n+     * type that have a non-blank TSK_COMMENT.\n      *\n-     * @param html       The HTML text to update.\n-     * @param artifact   A selected artifact (can be null).\n-     * @param sourceFile A selected file, or a source file of the selected\n-     *                   artifact.\n+     * @param sourceFile The source file for which to fetch artifacts.\n+     * @param type       The type of blackboard artifact to fetch.\n+     *\n+     * @return The artifacts found matching this type.\n      */\n-    private void populateCentralRepositoryData(StringBuilder html, BlackboardArtifact artifact, AbstractFile sourceFile) {\n-        if (CentralRepository.isEnabled()) {\n-            startSection(html, \"Central Repository Comments\");\n-            List<CorrelationAttributeInstance> instancesList = new ArrayList<>();\n-            if (artifact != null) {\n-                instancesList.addAll(CorrelationAttributeUtil.makeCorrAttrsForCorrelation(artifact));\n-            }\n-            try {\n-                List<CorrelationAttributeInstance.Type> artifactTypes = CentralRepository.getInstance().getDefinedCorrelationTypes();\n-                String md5 = sourceFile.getMd5Hash();\n-                if (md5 != null && !md5.isEmpty() && null != artifactTypes && !artifactTypes.isEmpty()) {\n-                    for (CorrelationAttributeInstance.Type attributeType : artifactTypes) {\n-                        if (attributeType.getId() == CorrelationAttributeInstance.FILES_TYPE_ID) {\n-                            CorrelationCase correlationCase = CentralRepository.getInstance().getCase(Case.getCurrentCase());\n-                            instancesList.add(new CorrelationAttributeInstance(\n-                                    attributeType,\n-                                    md5,\n-                                    correlationCase,\n-                                    CorrelationDataSource.fromTSKDataSource(correlationCase, sourceFile.getDataSource()),\n-                                    sourceFile.getParentPath() + sourceFile.getName(),\n-                                    \"\",\n-                                    sourceFile.getKnown(),\n-                                    sourceFile.getId()));\n-                            break;\n-                        }\n-                    }\n-                }\n+    private static List<BlackboardArtifact> getFileSetHits(AbstractFile sourceFile, ARTIFACT_TYPE type) {\n+        try {\n+            SleuthkitCase tskCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+            return tskCase.getBlackboardArtifacts(type, sourceFile.getId()).stream()\n+                    .filter((bba) -> hasTskComment(bba))\n+                    .collect(Collectors.toList());\n+        } catch (NoCurrentCaseException ex) {\n+            logger.log(Level.SEVERE, \"Exception while getting open case.\", ex); // NON-NLS\n+        } catch (TskCoreException ex) {\n+            logger.log(Level.SEVERE, \"Exception while getting file set hits from the case database.\", ex); //NON-NLS\n+        }\n+        return new ArrayList<>();\n+    }\n \n-                boolean commentDataFound = false;\n-\n-                for (CorrelationAttributeInstance instance : instancesList) {\n-                    List<CorrelationAttributeInstance> correlatedInstancesList\n-                            = CentralRepository.getInstance().getArtifactInstancesByTypeValue(instance.getCorrelationType(), instance.getCorrelationValue());\n-                    for (CorrelationAttributeInstance correlatedInstance : correlatedInstancesList) {\n-                        if (correlatedInstance.getComment() != null && correlatedInstance.getComment().isEmpty() == false) {\n-                            commentDataFound = true;\n-                            addCentralRepositoryEntry(html, correlatedInstance);\n-                        }\n-                    }\n-                }\n+    /**\n+     * Returns true if the artifact contains a non-blank TSK_COMMENT attribute.\n+     *\n+     * @param artifact The artifact to check.\n+     *\n+     * @return True if it has a non-blank TSK_COMMENT.\n+     */\n+    private static boolean hasTskComment(BlackboardArtifact artifact) {\n+        return StringUtils.isNotBlank(tryGetAttribute(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COMMENT));\n+    }\n \n-                if (commentDataFound == false) {\n-                    addMessage(html, \"There is no comment data for the selected content in the Central Repository.\");\n-                }\n-            } catch (CentralRepoException | TskCoreException ex) {\n-                logger.log(Level.SEVERE, \"Error connecting to the Central Repository database.\", ex); // NON-NLS\n-            } catch (CorrelationAttributeNormalizationException ex) {\n-                logger.log(Level.SEVERE, \"Error normalizing instance from Central Repository database.\", ex); // NON-NLS\n-            }\n-            endSection(html);\n+    /**\n+     * Attempts to retrieve the attribute of a particular type from a blackboard\n+     * artifact.\n+     *\n+     * @param artifact      The artifact from which to retrieve the information.\n+     * @param attributeType The attribute type to retrieve from the artifact.\n+     *\n+     * @return The string value of the attribute or null if not found.\n+     */\n+    private static String tryGetAttribute(BlackboardArtifact artifact, BlackboardAttribute.ATTRIBUTE_TYPE attributeType) {\n+        if (artifact == null) {\n+            return null;\n+        }\n+\n+        BlackboardAttribute attr = null;\n+        try {\n+            attr = artifact.getAttribute(new BlackboardAttribute.Type(attributeType));\n+        } catch (TskCoreException ex) {\n+            logger.log(Level.WARNING, String.format(\"Unable to fetch attribute of type %s for artifact %s\", attributeType, artifact), ex);\n+        }\n+\n+        if (attr == null) {\n+            return null;\n         }\n+\n+        return attr.getValueString();\n     }\n \n     /**\n-     * Set the text of the text panel.\n+     * Gets the \"Central Repository Comments\" section with data for the\n+     * blackboard artifact.\n+     *\n+     * @param artifact The selected artifact.\n      *\n-     * @param text The text to set to the text panel.\n+     * @return The Correlation Attribute Instances associated with the artifact\n+     *         that have comments.\n      */\n-    private void setText(String text) {\n-        jTextPane1.setText(\"<html><body>\" + text + \"</body></html>\"); //NON-NLS\n+    private static List<CorrelationAttributeInstance> getCentralRepositoryData(BlackboardArtifact artifact) {\n+        if (artifact == null) {\n+            return new ArrayList<>();\n+        }\n+\n+        List<Pair<CorrelationAttributeInstance.Type, String>> lookupKeys = CorrelationAttributeUtil.makeCorrAttrsForCorrelation(artifact)\n+                .stream()\n+                .map(cai -> Pair.of(cai.getCorrelationType(), cai.getCorrelationValue()))\n+                .collect(Collectors.toList());\n+\n+        return getCorrelationAttributeComments(lookupKeys);\n     }\n \n     /**\n-     * Start a new data section.\n+     * Gets the \"Central Repository Comments\" section with data.\n+     *\n+     * @param sourceFile A selected file, or a source file of the selected\n+     *                   artifact.\n      *\n-     * @param html        The HTML text to add the section to.\n-     * @param sectionName The name of the section.\n+     * @return The Correlation Attribute Instances associated with the\n+     *         sourcefile that have comments.\n      */\n-    private void startSection(StringBuilder html, String sectionName) {\n-        html.append(\"<p style=\\\"font-size:14px;font-weight:bold;\\\">\")\n-                .append(sectionName)\n-                .append(\"</p><br>\"); //NON-NLS\n+    private static List<CorrelationAttributeInstance> getCentralRepositoryData(AbstractFile sourceFile) {\n+        if (sourceFile == null || StringUtils.isEmpty(sourceFile.getMd5Hash())) {\n+            return new ArrayList<>();\n+        }\n+\n+        List<CorrelationAttributeInstance.Type> artifactTypes = null;\n+        try {\n+            artifactTypes = CentralRepository.getInstance().getDefinedCorrelationTypes();\n+        } catch (CentralRepoException ex) {\n+            logger.log(Level.SEVERE, \"Error connecting to the Central Repository database.\", ex); // NON-NLS\n+        }\n+\n+        if (artifactTypes == null || artifactTypes.isEmpty()) {\n+            return new ArrayList<>();\n+        }\n+\n+        String md5 = sourceFile.getMd5Hash();\n+\n+        // get key lookups for a file attribute types and the md5 hash\n+        List<Pair<CorrelationAttributeInstance.Type, String>> lookupKeys = artifactTypes.stream()\n+                .filter((attributeType) -> attributeType.getId() == CorrelationAttributeInstance.FILES_TYPE_ID)\n+                .map((attributeType) -> Pair.of(attributeType, md5))\n+                .collect(Collectors.toList());\n+\n+        return getCorrelationAttributeComments(lookupKeys);\n     }\n \n     /**\n-     * Add a message.\n+     * Given a type and a value for that type, does a lookup in the Central\n+     * Repository for matching values that have comments.\n      *\n-     * @param html    The HTML text to add the message to.\n-     * @param message The message text.\n+     * @param lookupKeys The type and value to lookup.\n+     *\n+     * @return The found correlation attribute instances.\n      */\n-    private void addMessage(StringBuilder html, String message) {\n-        html.append(\"<p style=\\\"font-size:11px;font-style:italic;\\\">\")\n-                .append(message)\n-                .append(\"</p><br>\"); //NON-NLS\n+    private static List<CorrelationAttributeInstance> getCorrelationAttributeComments(List<Pair<CorrelationAttributeInstance.Type, String>> lookupKeys) {\n+        List<CorrelationAttributeInstance> instancesToRet = new ArrayList<>();\n+\n+        try {\n+            // use lookup instances to find the actual correlation attributes for the items selected\n+            for (Pair<CorrelationAttributeInstance.Type, String> typeVal : lookupKeys) {\n+                instancesToRet.addAll(CentralRepository.getInstance()\n+                        .getArtifactInstancesByTypeValue(typeVal.getKey(), typeVal.getValue())\n+                        .stream()\n+                        // for each one found, if it has a comment, return\n+                        .filter((cai) -> StringUtils.isNotBlank(cai.getComment()))\n+                        .collect(Collectors.toList()));\n+            }\n+\n+        } catch (CentralRepoException ex) {\n+            logger.log(Level.SEVERE, \"Error connecting to the Central Repository database.\", ex); // NON-NLS\n+        } catch (CorrelationAttributeNormalizationException ex) {\n+            logger.log(Level.SEVERE, \"Error normalizing instance from Central Repository database.\", ex); // NON-NLS\n+        }\n+\n+        return instancesToRet;\n     }\n \n     /**\n-     * Add a data table containing information about a tag.\n+     * Append entries to the parent element in the annotations viewer. Entries\n+     * will be formatted as a table in the format specified in the\n+     * SectionConfig.\n      *\n-     * @param html The HTML text to add the table to.\n-     * @param tag  The tag whose information will be used to populate the table.\n+     * @param <T>          The item type.", "originalCommit": "3c517371a0be3d575627426d4ad988c76932b432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "adf2c5ccb65f28233931d98502d1d9dab0d1fbdd", "url": "https://github.com/sleuthkit/autopsy/commit/adf2c5ccb65f28233931d98502d1d9dab0d1fbdd", "message": "remove method generic parameters", "committedDate": "2020-05-15T13:46:52Z", "type": "commit"}]}