{"pr_number": 6140, "pr_title": "6631 data source summarizer", "pr_createdAt": "2020-07-27T18:44:42Z", "pr_url": "https://github.com/sleuthkit/autopsy/pull/6140", "timeline": [{"oid": "4a2308b9b0af8714bd0234caf8e62adb8c2d3383", "url": "https://github.com/sleuthkit/autopsy/commit/4a2308b9b0af8714bd0234caf8e62adb8c2d3383", "message": "summarizer start", "committedDate": "2020-07-23T14:09:29Z", "type": "commit"}, {"oid": "1ca277aae8be3115ede39dbe596ea4d6335fbec0", "url": "https://github.com/sleuthkit/autopsy/commit/1ca277aae8be3115ede39dbe596ea4d6335fbec0", "message": "panel integration and refactoring", "committedDate": "2020-07-23T19:32:09Z", "type": "commit"}, {"oid": "d519a9d896bac02bc1b2b6a401f9d656a840d58e", "url": "https://github.com/sleuthkit/autopsy/commit/d519a9d896bac02bc1b2b6a401f9d656a840d58e", "message": "panel integration and refactoring", "committedDate": "2020-07-23T19:32:19Z", "type": "commit"}, {"oid": "1eb5fc5a331831b9ae8cbfed15c5c01404e7d1d3", "url": "https://github.com/sleuthkit/autopsy/commit/1eb5fc5a331831b9ae8cbfed15c5c01404e7d1d3", "message": "refactoring", "committedDate": "2020-07-23T21:19:41Z", "type": "commit"}, {"oid": "24e4c80a4c34c75f6df4524b3ea8cc90d2d0fe48", "url": "https://github.com/sleuthkit/autopsy/commit/24e4c80a4c34c75f6df4524b3ea8cc90d2d0fe48", "message": "adding bundles", "committedDate": "2020-07-23T21:25:52Z", "type": "commit"}, {"oid": "820006d9ab1b39195a87bd6de4c1d154b3026494", "url": "https://github.com/sleuthkit/autopsy/commit/820006d9ab1b39195a87bd6de4c1d154b3026494", "message": "code cleanup", "committedDate": "2020-07-24T12:55:42Z", "type": "commit"}, {"oid": "de588e9e5a152d20fc951d419ab9be7fdc50883a", "url": "https://github.com/sleuthkit/autopsy/commit/de588e9e5a152d20fc951d419ab9be7fdc50883a", "message": "acquiring single data source in data layer", "committedDate": "2020-07-24T15:44:59Z", "type": "commit"}, {"oid": "d8f5bcec3a5177a0aaa796316e150e05d3e711fc", "url": "https://github.com/sleuthkit/autopsy/commit/d8f5bcec3a5177a0aaa796316e150e05d3e711fc", "message": "commenting and sql results per data source", "committedDate": "2020-07-27T16:12:29Z", "type": "commit"}, {"oid": "4e7ee4142d3c9a98012e174f9ae92d6e9cb89856", "url": "https://github.com/sleuthkit/autopsy/commit/4e7ee4142d3c9a98012e174f9ae92d6e9cb89856", "message": "bug fixes", "committedDate": "2020-07-27T18:31:12Z", "type": "commit"}, {"oid": "1b5f43fa2b300e658bac0037eb74637da2ce1b3f", "url": "https://github.com/sleuthkit/autopsy/commit/1b5f43fa2b300e658bac0037eb74637da2ce1b3f", "message": "removing files to fix directory issue", "committedDate": "2020-07-27T18:37:03Z", "type": "commit"}, {"oid": "8f967cb2384f56076f62551bab2d75b0569ea08d", "url": "https://github.com/sleuthkit/autopsy/commit/8f967cb2384f56076f62551bab2d75b0569ea08d", "message": "re-adding files to fix directory issue", "committedDate": "2020-07-27T18:37:49Z", "type": "commit"}, {"oid": "b248596598b848c7c9e0079f5bfafe97afc1e85f", "url": "https://github.com/sleuthkit/autopsy/commit/b248596598b848c7c9e0079f5bfafe97afc1e85f", "message": "directory fix", "committedDate": "2020-07-27T18:42:55Z", "type": "commit"}, {"oid": "634c4ecc6e7f0503b8fe5893d6b53818df7864ee", "url": "https://github.com/sleuthkit/autopsy/commit/634c4ecc6e7f0503b8fe5893d6b53818df7864ee", "message": "Merge branch 'develop' of github.com:sleuthkit/autopsy into 6631-DataSourceSummarizer", "committedDate": "2020-07-27T18:43:34Z", "type": "commit"}, {"oid": "3c096cdb2d8143ee22353cd4cd03cf8d626f172e", "url": "https://github.com/sleuthkit/autopsy/commit/3c096cdb2d8143ee22353cd4cd03cf8d626f172e", "message": "addressing codacy remarks and bug fix", "committedDate": "2020-07-27T20:05:53Z", "type": "commit"}, {"oid": "1774ad6cbaf91d848d1ff5ec070158956710bd5f", "url": "https://github.com/sleuthkit/autopsy/commit/1774ad6cbaf91d848d1ff5ec070158956710bd5f", "message": "Merge branch 'develop' of github.com:sleuthkit/autopsy into 6631-DataSourceSummarizer", "committedDate": "2020-07-30T14:59:30Z", "type": "commit"}, {"oid": "34ee2bd5c146d7423868e27f63ac6f8deabe1dbd", "url": "https://github.com/sleuthkit/autopsy/commit/34ee2bd5c146d7423868e27f63ac6f8deabe1dbd", "message": "non editable table model", "committedDate": "2020-07-30T15:15:04Z", "type": "commit"}, {"oid": "1bb530923df9cc4f9003556bc96216b6c7309795", "url": "https://github.com/sleuthkit/autopsy/commit/1bb530923df9cc4f9003556bc96216b6c7309795", "message": "fix for artifact counts table", "committedDate": "2020-07-30T15:51:07Z", "type": "commit"}, {"oid": "dcc134939ec1c65ccb7383c843577248d344ccb6", "url": "https://github.com/sleuthkit/autopsy/commit/dcc134939ec1c65ccb7383c843577248d344ccb6", "message": "tab updates and case updates in IngestJobInfoPanel", "committedDate": "2020-07-31T20:26:20Z", "type": "commit"}, {"oid": "ef1a5840dda79b12522362d20bb9cbbb8f0f7756", "url": "https://github.com/sleuthkit/autopsy/commit/ef1a5840dda79b12522362d20bb9cbbb8f0f7756", "message": "fix for ingest job info panel and tabs", "committedDate": "2020-08-03T12:49:58Z", "type": "commit"}, {"oid": "c8d2e48e2553ec3032af58d10649a111cf5d6c8f", "url": "https://github.com/sleuthkit/autopsy/commit/c8d2e48e2553ec3032af58d10649a111cf5d6c8f", "message": "revert bundle files", "committedDate": "2020-08-03T12:53:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY0NjM3Ng==", "url": "https://github.com/sleuthkit/autopsy/pull/6140#discussion_r463646376", "bodyText": "Unused import", "author": "wschaeferB", "createdAt": "2020-07-31T14:32:11Z", "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/DataSourceInfoUtilities.java", "diffHunk": "@@ -18,6 +18,8 @@\n  */\n package org.sleuthkit.autopsy.casemodule.datasourcesummary;\n \n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n import java.util.ArrayList;", "originalCommit": "1bb530923df9cc4f9003556bc96216b6c7309795", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY1MDM3NA==", "url": "https://github.com/sleuthkit/autopsy/pull/6140#discussion_r463650374", "bodyText": "ResultSet should be closed.", "author": "wschaeferB", "createdAt": "2020-07-31T14:39:03Z", "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/DataSourceInfoUtilities.java", "diffHunk": "@@ -43,6 +45,297 @@\n \n     private static final Logger logger = Logger.getLogger(DataSourceInfoUtilities.class.getName());\n \n+    /**\n+     * Gets a count of files for a particular datasource where it is not a\n+     * virtual directory and has a name.\n+     *\n+     * @param currentDataSource The datasource.\n+     * @param additionalWhere   Additional sql where clauses.\n+     * @param onError           The message to log on error.\n+     *\n+     * @return The count of files or null on error.\n+     */\n+    private static Long getCountOfFiles(DataSource currentDataSource, String additionalWhere, String onError) {\n+        if (currentDataSource != null) {\n+            try {\n+                SleuthkitCase skCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+                return skCase.countFilesWhere(\n+                        \"dir_type<>\" + TskData.TSK_FS_NAME_TYPE_ENUM.VIRT_DIR.getValue()\n+                        + \" AND name<>''\"\n+                        + \" AND data_source_obj_id=\" + currentDataSource.getId()\n+                        + \" AND \" + additionalWhere);\n+            } catch (TskCoreException | NoCurrentCaseException ex) {\n+                logger.log(Level.WARNING, onError, ex);\n+                //unable to get count of files for the specified types cell will be displayed as empty\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get count of files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType(),\n+                \"Unable to get count of files, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of unallocated files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfUnallocatedFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND dir_flags=\" + TskData.TSK_FS_NAME_FLAG_ENUM.UNALLOC.getValue(),\n+                \"Unable to get counts of unallocated files for datasource, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of directories in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfDirectories(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND meta_type=\" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_DIR.getValue(),\n+                \"Unable to get count of directories for datasource, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of slack files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfSlackFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type=\" + TskData.TSK_DB_FILES_TYPE_ENUM.SLACK.getFileType(),\n+                \"Unable to get count of slack files for datasources, providing empty results\");\n+    }\n+\n+    /**\n+     * An interface for handling a result set and returning a value.\n+     */\n+    private interface ResultSetHandler<T> {\n+\n+        T process(ResultSet resultset) throws SQLException;\n+    }\n+\n+    /**\n+     * Retrieves a result based on the provided query.\n+     *\n+     * @param query        The query.\n+     * @param processor    The result set handler.\n+     * @param errorMessage The error message to display if there is an error\n+     *                     retrieving the resultset.\n+     *\n+     * @return The ResultSetHandler value or null if no ResultSet could be\n+     *         obtained.\n+     */\n+    private static <T> T getBaseQueryResult(String query, ResultSetHandler<T> processor, String errorMessage) {\n+        try (SleuthkitCase.CaseDbQuery dbQuery = Case.getCurrentCaseThrows().getSleuthkitCase().executeQuery(query)) {\n+            ResultSet resultSet = dbQuery.getResultSet();", "originalCommit": "1bb530923df9cc4f9003556bc96216b6c7309795", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5MjgyMw==", "url": "https://github.com/sleuthkit/autopsy/pull/6140#discussion_r464492823", "bodyText": "As greg has pointed out to me CaseDbQuery closes the resultSet, so this is not an issue.", "author": "wschaeferB", "createdAt": "2020-08-03T15:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY1MDM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY1OTIwMA==", "url": "https://github.com/sleuthkit/autopsy/pull/6140#discussion_r463659200", "bodyText": "Method name does not really make sense to me since it is getting a string based on results not getting a query itself.", "author": "wschaeferB", "createdAt": "2020-07-31T14:53:57Z", "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/DataSourceInfoUtilities.java", "diffHunk": "@@ -43,6 +45,297 @@\n \n     private static final Logger logger = Logger.getLogger(DataSourceInfoUtilities.class.getName());\n \n+    /**\n+     * Gets a count of files for a particular datasource where it is not a\n+     * virtual directory and has a name.\n+     *\n+     * @param currentDataSource The datasource.\n+     * @param additionalWhere   Additional sql where clauses.\n+     * @param onError           The message to log on error.\n+     *\n+     * @return The count of files or null on error.\n+     */\n+    private static Long getCountOfFiles(DataSource currentDataSource, String additionalWhere, String onError) {\n+        if (currentDataSource != null) {\n+            try {\n+                SleuthkitCase skCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+                return skCase.countFilesWhere(\n+                        \"dir_type<>\" + TskData.TSK_FS_NAME_TYPE_ENUM.VIRT_DIR.getValue()\n+                        + \" AND name<>''\"\n+                        + \" AND data_source_obj_id=\" + currentDataSource.getId()\n+                        + \" AND \" + additionalWhere);\n+            } catch (TskCoreException | NoCurrentCaseException ex) {\n+                logger.log(Level.WARNING, onError, ex);\n+                //unable to get count of files for the specified types cell will be displayed as empty\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get count of files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType(),\n+                \"Unable to get count of files, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of unallocated files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfUnallocatedFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND dir_flags=\" + TskData.TSK_FS_NAME_FLAG_ENUM.UNALLOC.getValue(),\n+                \"Unable to get counts of unallocated files for datasource, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of directories in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfDirectories(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND meta_type=\" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_DIR.getValue(),\n+                \"Unable to get count of directories for datasource, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of slack files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfSlackFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type=\" + TskData.TSK_DB_FILES_TYPE_ENUM.SLACK.getFileType(),\n+                \"Unable to get count of slack files for datasources, providing empty results\");\n+    }\n+\n+    /**\n+     * An interface for handling a result set and returning a value.\n+     */\n+    private interface ResultSetHandler<T> {\n+\n+        T process(ResultSet resultset) throws SQLException;\n+    }\n+\n+    /**\n+     * Retrieves a result based on the provided query.\n+     *\n+     * @param query        The query.\n+     * @param processor    The result set handler.\n+     * @param errorMessage The error message to display if there is an error\n+     *                     retrieving the resultset.\n+     *\n+     * @return The ResultSetHandler value or null if no ResultSet could be\n+     *         obtained.\n+     */\n+    private static <T> T getBaseQueryResult(String query, ResultSetHandler<T> processor, String errorMessage) {\n+        try (SleuthkitCase.CaseDbQuery dbQuery = Case.getCurrentCaseThrows().getSleuthkitCase().executeQuery(query)) {\n+            ResultSet resultSet = dbQuery.getResultSet();\n+            try {\n+                return processor.process(resultSet);\n+            } catch (SQLException ex) {\n+                logger.log(Level.WARNING, errorMessage, ex);\n+            }\n+        } catch (TskCoreException | NoCurrentCaseException ex) {\n+            logger.log(Level.WARNING, errorMessage, ex);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of unallocated files in a particular datasource.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The size or null if the query could not be executed.\n+     */\n+    static Long getSizeOfUnallocatedFiles(DataSource currentDataSource) {\n+        if (currentDataSource == null) {\n+            return null;\n+        }\n+\n+        final String valueParam = \"value\";\n+        final String countParam = \"count\";\n+        String query = \"SELECT SUM(size) AS \" + valueParam + \", COUNT(*) AS \" + countParam\n+                + \" FROM tsk_files WHERE type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND dir_type<>\" + TskData.TSK_FS_NAME_TYPE_ENUM.VIRT_DIR.getValue()\n+                + \" AND dir_flags=\" + TskData.TSK_FS_NAME_FLAG_ENUM.UNALLOC.getValue()\n+                + \" AND name<>''\"\n+                + \" AND data_source_obj_id=\" + currentDataSource.getId();\n+\n+        ResultSetHandler<Long> handler = (resultSet) -> {\n+            if (resultSet.next()) {\n+                // ensure that there is an unallocated count result that is attached to this data source\n+                long resultCount = resultSet.getLong(valueParam);\n+                return (resultCount > 0) ? resultSet.getLong(valueParam) : null;\n+            } else {\n+                return null;\n+            }\n+        };\n+        String errorMessage = \"Unable to get size of unallocated files; returning null.\";\n+\n+        return getBaseQueryResult(query, handler, errorMessage);\n+    }\n+\n+    /**\n+     * Retrieves counts for each artifact type in a data source.\n+     *\n+     * @param selectedDataSource The data source.\n+     *\n+     * @return A mapping of artifact type name to the counts or null if there\n+     *         was an error executing the query.\n+     */\n+    static Map<String, Long> getCountsOfArtifactsByType(DataSource selectedDataSource) {\n+        if (selectedDataSource == null) {\n+            return Collections.emptyMap();\n+        }\n+\n+        final String nameParam = \"name\";\n+        final String valueParam = \"value\";\n+        String query\n+                = \"SELECT bbt.display_name AS \" + nameParam + \", COUNT(*) AS \" + valueParam\n+                + \" FROM blackboard_artifacts bba \"\n+                + \" INNER JOIN blackboard_artifact_types bbt ON bba.artifact_type_id = bbt.artifact_type_id\"\n+                + \" WHERE bba.data_source_obj_id =\" + selectedDataSource.getId()\n+                + \" GROUP BY bbt.display_name\";\n+\n+        ResultSetHandler<Map<String, Long>> handler = (resultSet) -> {\n+            Map<String, Long> toRet = new HashMap<>();\n+            while (resultSet.next()) {\n+                try {\n+                    toRet.put(resultSet.getString(nameParam), resultSet.getLong(valueParam));\n+                } catch (SQLException ex) {\n+                    logger.log(Level.WARNING, \"Failed to get a result pair from the result set.\", ex);\n+                }\n+            }\n+\n+            return toRet;\n+        };\n+\n+        String errorMessage = \"Unable to get artifact type counts; returning null.\";\n+\n+        return getBaseQueryResult(query, handler, errorMessage);\n+    }\n+\n+    /**\n+     * Generates a string which is a concatenation of the value received from\n+     * the result set.\n+     *\n+     * @param query              The query.\n+     * @param valueParam         The parameter for the value in the result set.\n+     * @param separator          The string separator used in concatenation.\n+     * @param errorMessage       The error message if the result set could not\n+     *                           be received.\n+     * @param singleErrorMessage The error message if a single result could not\n+     *                           be obtained.\n+     *\n+     * @return The concatenated string or null if the query could not be\n+     *         executed.\n+     */\n+    private static String getConcattedStringQuery(String query, String valueParam, String separator, String errorMessage, String singleErrorMessage) {", "originalCommit": "1bb530923df9cc4f9003556bc96216b6c7309795", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ1OTI3Mw==", "url": "https://github.com/sleuthkit/autopsy/pull/6140#discussion_r464459273", "bodyText": "add serial id to make codacy and netbeans happy", "author": "wschaeferB", "createdAt": "2020-08-03T14:42:50Z", "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/NonEditableTableModel.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.casemodule.datasourcesummary;\n+\n+import javax.swing.table.DefaultTableModel;\n+\n+/**\n+ * A Table model where cells are not editable.\n+ */\n+class NonEditableTableModel extends DefaultTableModel {", "originalCommit": "c8d2e48e2553ec3032af58d10649a111cf5d6c8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "36145d9c409fe8e4b40f3814d4054a49fa7a82eb", "url": "https://github.com/sleuthkit/autopsy/commit/36145d9c409fe8e4b40f3814d4054a49fa7a82eb", "message": "updated for review remarks", "committedDate": "2020-08-03T15:49:30Z", "type": "commit"}]}