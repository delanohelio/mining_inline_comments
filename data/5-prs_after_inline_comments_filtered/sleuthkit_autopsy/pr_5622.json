{"pr_number": 5622, "pr_title": "1400 geolocation map mouse click improvements", "pr_createdAt": "2020-01-30T16:19:14Z", "pr_url": "https://github.com/sleuthkit/autopsy/pull/5622", "timeline": [{"oid": "b3e45d2e479bfced730de42886ce3865d139d9d9", "url": "https://github.com/sleuthkit/autopsy/commit/b3e45d2e479bfced730de42886ce3865d139d9d9", "message": "Fixed geolocation point clicking issue", "committedDate": "2020-01-30T15:20:38Z", "type": "commit"}, {"oid": "ea3a89b52d2f07aab3d49e2d3a250c8b0727b643", "url": "https://github.com/sleuthkit/autopsy/commit/ea3a89b52d2f07aab3d49e2d3a250c8b0727b643", "message": "Geolocation file cleanup", "committedDate": "2020-01-30T16:08:30Z", "type": "commit"}, {"oid": "1e10b58cffa61b060a6409d5d6d0cb5cc669aae3", "url": "https://github.com/sleuthkit/autopsy/commit/1e10b58cffa61b060a6409d5d6d0cb5cc669aae3", "message": "Addressed easy codacy issues", "committedDate": "2020-01-30T17:11:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2ODk5NQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5622#discussion_r373568995", "bodyText": "\"can return more than numNeighbors\"", "author": "raman-bt", "createdAt": "2020-01-31T16:30:06Z", "path": "Core/src/org/sleuthkit/autopsy/geolocation/KdTree.java", "diffHunk": "@@ -247,258 +163,208 @@ public boolean contains(T value) {\n     /**\n      * Locates T in the tree.\n      *\n-     * @param tree\n-     *            to search.\n-     * @param value\n-     *            to search for.\n+     * @param tree  to search.\n+     * @param value to search for.\n+     *\n      * @return KdNode or NULL if not found\n      */\n-    private static final <T extends KdTree.XYZPoint> KdNode getNode(KdTree<T> tree, T value) {\n-        if (tree == null || tree.root == null || value == null)\n+    private <T extends KdTree.XYZPoint> KdNode getNode(KdTree<T> tree, T value) {\n+        if (tree == null || tree.getRoot() == null || value == null) {\n             return null;\n+        }\n \n-        KdNode node = tree.root;\n+        KdNode node = tree.getRoot();\n         while (true) {\n-            if (node.id.equals(value)) {\n+            if (node.getPoint().equals(value)) {\n                 return node;\n-            } else if (KdNode.compareTo(node.depth, node.k, value, node.id) <= 0) {\n+            } else if (KdNode.compareTo(node.getDepth(), value, node.getPoint()) <= 0) {\n                 // Lesser\n-                if (node.lesser == null) {\n+                if (node.getLesser() == null) {\n                     return null;\n                 }\n-                node = node.lesser;\n+                node = node.getLesser();\n             } else {\n                 // Greater\n-                if (node.greater == null) {\n+                if (node.getGreater() == null) {\n                     return null;\n                 }\n-                node = node.greater;\n+                node = node.getGreater();\n             }\n         }\n     }\n \n     /**\n-     * Removes first occurrence of value in the tree.\n+     * Searches for numNeighbors nearest neighbor.\n      *\n-     * @param value\n-     *            T to remove from the tree.\n-     * @return True if value was removed from the tree.\n-     */\n-    public boolean remove(T value) {\n-        if (value == null || root == null)\n-            return false;\n-\n-        KdNode node = getNode(this, value);\n-        if (node == null)\n-            return false;\n-\n-        KdNode parent = node.parent;\n-        if (parent != null) {\n-            if (parent.lesser != null && node.equals(parent.lesser)) {\n-                List<XYZPoint> nodes = getTree(node);\n-                if (nodes.size() > 0) {\n-                    parent.lesser = createNode(nodes, node.k, node.depth);\n-                    if (parent.lesser != null) {\n-                        parent.lesser.parent = parent;\n-                    }\n-                } else {\n-                    parent.lesser = null;\n-                }\n-            } else {\n-                List<XYZPoint> nodes = getTree(node);\n-                if (nodes.size() > 0) {\n-                    parent.greater = createNode(nodes, node.k, node.depth);\n-                    if (parent.greater != null) {\n-                        parent.greater.parent = parent;\n-                    }\n-                } else {\n-                    parent.greater = null;\n-                }\n-            }\n-        } else {\n-            // root\n-            List<XYZPoint> nodes = getTree(node);\n-            if (nodes.size() > 0)\n-                root = createNode(nodes, node.k, node.depth);\n-            else\n-                root = null;\n-        }\n-\n-        return true;\n-    }\n-\n-    /**\n-     * Gets the (sub) tree rooted at root.\n-     *\n-     * @param root\n-     *            of tree to get nodes for.\n-     * @return points in (sub) tree, not including root.\n-     */\n-    private static final List<XYZPoint> getTree(KdNode root) {\n-        List<XYZPoint> list = new ArrayList<XYZPoint>();\n-        if (root == null)\n-            return list;\n-\n-        if (root.lesser != null) {\n-            list.add(root.lesser.id);\n-            list.addAll(getTree(root.lesser));\n-        }\n-        if (root.greater != null) {\n-            list.add(root.greater.id);\n-            list.addAll(getTree(root.greater));\n-        }\n-\n-        return list;\n-    }\n-\n-    /** \n-     * Searches the K nearest neighbor.\n+     * @param numNeighbors Number of neighbors to retrieve. Can return more than\n+     *                     K, if last nodes are equal distances.", "originalCommit": "1e10b58cffa61b060a6409d5d6d0cb5cc669aae3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU3OTYwMg==", "url": "https://github.com/sleuthkit/autopsy/pull/5622#discussion_r373579602", "bodyText": "Is that a backslash for a reason? Should it simply be x/latitude? makes it hard to read.", "author": "raman-bt", "createdAt": "2020-01-31T16:51:42Z", "path": "Core/src/org/sleuthkit/autopsy/geolocation/KdTree.java", "diffHunk": "@@ -507,173 +373,258 @@ public EuclideanComparator(XYZPoint point) {\n          */\n         @Override\n         public int compare(KdNode o1, KdNode o2) {\n-            Double d1 = point.euclideanDistance(o1.id);\n-            Double d2 = point.euclideanDistance(o2.id);\n-            if (d1.compareTo(d2) < 0)\n+            Double d1 = point.euclideanDistance(o1.getPoint());\n+            Double d2 = point.euclideanDistance(o2.getPoint());\n+            if (d1.compareTo(d2) < 0) {\n                 return -1;\n-            else if (d2.compareTo(d1) < 0)\n+            } else if (d2.compareTo(d1) < 0) {\n                 return 1;\n-            return o1.id.compareTo(o2.id);\n+            }\n+            return o1.getPoint().compareTo(o2.getPoint());\n         }\n     }\n \n-    /** \n+    /**\n      * Searches all entries from the first to the last entry.\n-     * \n-     * @return Iterator \n-     *                  allowing to iterate through a collection containing all found entries.\n+     *\n+     * @return Iterator allowing to iterate through a collection containing all\n+     *         found entries.\n      */\n+    @Override\n     public Iterator<T> iterator() {\n-        final Deque<T> results = new ArrayDeque<T>();\n+        final Deque<T> results = new ArrayDeque<>();\n         search(root, results);\n         return results.iterator();\n     }\n \n-    /** \n+    /**\n      * Searches all entries from the last to the first entry.\n-     * \n-     * @return Iterator \n-     *                  allowing to iterate through a collection containing all found entries.\n+     *\n+     * @return Iterator allowing to iterate through a collection containing all\n+     *         found entries.\n      */\n     public Iterator<T> reverse_iterator() {\n-        final Deque<T> results = new ArrayDeque<T>();\n+        final Deque<T> results = new ArrayDeque<>();\n         search(root, results);\n         return results.descendingIterator();\n     }\n \n+    /**\n+     * A node in the KdTree. Each node has a parent node (unless the node is the\n+     * root) and a lesser and greater child node.\n+     *\n+     * The child nodes are set to \"lesser\" or \"greater\" depending on a\n+     * comparison between the nodes XYZPoint and the child's XYZPoint.\n+     */\n     public static class KdNode implements Comparable<KdNode> {\n \n-        private final XYZPoint id;\n-        private final int k;\n+        private final XYZPoint point;\n         private final int depth;\n+        private final KdNode parent;\n \n-        private KdNode parent = null;\n         private KdNode lesser = null;\n         private KdNode greater = null;\n \n-        public KdNode(XYZPoint id) {\n-            this.id = id;\n-            this.k = 3;\n-            this.depth = 0;\n+        /**\n+         * Constructs a new KdNode.\n+         *\n+         * @param point  Node point\n+         * @param depth  Depth of node in the tree, set to 0 if root node\n+         * @param parent Parent of this node, can be null if root node\n+         */\n+        public KdNode(XYZPoint point, int depth, KdNode parent) {\n+            this.point = point;\n+            this.depth = depth;\n+            this.parent = parent;\n         }\n \n-        public KdNode(XYZPoint id, int k, int depth) {\n-            this.id = id;\n-            this.k = k;\n-            this.depth = depth;\n+        /**\n+         * Compares two XYZPoints. The value used for the comparision is based\n+         * on the depth of the node in the tree and the tree's dimension.\n+         *\n+         * @param depth  Depth of node in the tree\n+         * @param point1 First point to compare\n+         * @param point2 Second point to compare\n+         *\n+         * @return 0 if points are equal -1 if point2 is \"less than\" point1 1 if\n+         *         point1 is \"greater than\" point2\n+         */\n+        public static int compareTo(int depth, XYZPoint point1, XYZPoint point2) {\n+            int axis = depth % DIMENSIONS;\n+            switch (axis) {\n+                case X_AXIS:\n+                    return X_COMPARATOR.compare(point1, point2);\n+                case Y_AXIS:\n+                    return Y_COMPARATOR.compare(point1, point2);\n+                default:\n+                    return Z_COMPARATOR.compare(point1, point2);\n+            }\n+        }\n+\n+        /**\n+         * Returns the nodes depth in the kdtree.\n+         *\n+         * @return Node depth.\n+         */\n+        int getDepth() {\n+            return depth;\n+        }\n+\n+        /**\n+         * Returns the parent of this node. If parent is null, the node is the\n+         * tree root node.\n+         *\n+         * @return Returns the parent of this node, or null if node is tree\n+         *         root.\n+         */\n+        KdNode getParent() {\n+            return parent;\n+        }\n+\n+        /**\n+         * Sets the lesser child of this node.\n+         *\n+         * @param node lesser Child node\n+         */\n+        void setLesser(KdNode node) {\n+            lesser = node;\n+        }\n+\n+        /**\n+         * Returns the nodes lesser child node.\n+         *\n+         * @return Returns KdNode or null if one was not set.\n+         */\n+        KdNode getLesser() {\n+            return lesser;\n+        }\n+\n+        /**\n+         * Sets the greater child of this node.\n+         *\n+         * @param node\n+         */\n+        void setGreater(KdNode node) {\n+            greater = node;\n+        }\n+\n+        /**\n+         * Returns the nodes lesser child node.\n+         *\n+         * @return Returns KdNode or null if one was not set.\n+         */\n+        KdNode getGreater() {\n+            return greater;\n         }\n \n-        public static int compareTo(int depth, int k, XYZPoint o1, XYZPoint o2) {\n-            int axis = depth % k;\n-            if (axis == X_AXIS)\n-                return X_COMPARATOR.compare(o1, o2);\n-            if (axis == Y_AXIS)\n-                return Y_COMPARATOR.compare(o1, o2);\n-            return Z_COMPARATOR.compare(o1, o2);\n+        /**\n+         * Returns the XYZ point of this node which contains the longitude and\n+         * latitude values.\n+         *\n+         * @return XYZPoint\n+         */\n+        XYZPoint getPoint() {\n+            return point;\n         }\n \n         /**\n          * {@inheritDoc}\n          */\n         @Override\n         public int hashCode() {\n-            return 31 * (this.k + this.depth + this.id.hashCode());\n+            return 31 * (DIMENSIONS + this.depth + this.getPoint().hashCode());\n         }\n \n         /**\n          * {@inheritDoc}\n          */\n         @Override\n         public boolean equals(Object obj) {\n-            if (obj == null)\n+            if (obj == null) {\n                 return false;\n-            if (!(obj instanceof KdNode))\n+            }\n+            if (!(obj instanceof KdNode)) {\n                 return false;\n+            }\n \n             KdNode kdNode = (KdNode) obj;\n-            if (this.compareTo(kdNode) == 0)\n-                return true;\n-            return false;\n+            return (this.compareTo(kdNode) == 0);\n         }\n \n         /**\n          * {@inheritDoc}\n          */\n         @Override\n         public int compareTo(KdNode o) {\n-            return compareTo(depth, k, this.id, o.id);\n+            return compareTo(depth, this.getPoint(), o.getPoint());\n         }\n \n         /**\n          * {@inheritDoc}\n          */\n         @Override\n         public String toString() {\n-            StringBuilder builder = new StringBuilder();\n-            builder.append(\"k=\").append(k);\n-            builder.append(\" depth=\").append(depth);\n-            builder.append(\" id=\").append(id.toString());\n+            StringBuilder builder = new StringBuilder(200);\n+            builder.append(\"dimensions=\").append(DIMENSIONS).append(\" depth=\").append(depth).append(\" point=\").append(getPoint().toString());\n             return builder.toString();\n         }\n     }\n \n+    /**\n+     * An XYZPoint is a representation of a three dimensional point.\n+     *\n+     * Z value will always been 0 when using latitude and longitude values.\n+     */\n     public static class XYZPoint implements Comparable<XYZPoint> {\n \n         protected final double x;\n         protected final double y;\n         protected final double z;\n \n         /**\n-         * z is defaulted to zero.\n+         * Constructs a new XYZPoint.\n          *\n-         * @param x\n-         * @param y\n+         * @param latitude\n+         * @param longitude\n          */\n-        public XYZPoint(double x, double y) {\n-            this.x = x;\n-            this.y = y;\n-            this.z = 0;\n+        public XYZPoint(Double latitude, Double longitude) {\n+            x = latitude;\n+            y = longitude;\n+            z = 0;\n         }\n \n         /**\n-         * Default constructor\n+         * Returns the x\\latitude value for the point.", "originalCommit": "1e10b58cffa61b060a6409d5d6d0cb5cc669aae3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU3OTc4MA==", "url": "https://github.com/sleuthkit/autopsy/pull/5622#discussion_r373579780", "bodyText": "same comment regarding backslash.", "author": "raman-bt", "createdAt": "2020-01-31T16:52:03Z", "path": "Core/src/org/sleuthkit/autopsy/geolocation/KdTree.java", "diffHunk": "@@ -507,173 +373,258 @@ public EuclideanComparator(XYZPoint point) {\n          */\n         @Override\n         public int compare(KdNode o1, KdNode o2) {\n-            Double d1 = point.euclideanDistance(o1.id);\n-            Double d2 = point.euclideanDistance(o2.id);\n-            if (d1.compareTo(d2) < 0)\n+            Double d1 = point.euclideanDistance(o1.getPoint());\n+            Double d2 = point.euclideanDistance(o2.getPoint());\n+            if (d1.compareTo(d2) < 0) {\n                 return -1;\n-            else if (d2.compareTo(d1) < 0)\n+            } else if (d2.compareTo(d1) < 0) {\n                 return 1;\n-            return o1.id.compareTo(o2.id);\n+            }\n+            return o1.getPoint().compareTo(o2.getPoint());\n         }\n     }\n \n-    /** \n+    /**\n      * Searches all entries from the first to the last entry.\n-     * \n-     * @return Iterator \n-     *                  allowing to iterate through a collection containing all found entries.\n+     *\n+     * @return Iterator allowing to iterate through a collection containing all\n+     *         found entries.\n      */\n+    @Override\n     public Iterator<T> iterator() {\n-        final Deque<T> results = new ArrayDeque<T>();\n+        final Deque<T> results = new ArrayDeque<>();\n         search(root, results);\n         return results.iterator();\n     }\n \n-    /** \n+    /**\n      * Searches all entries from the last to the first entry.\n-     * \n-     * @return Iterator \n-     *                  allowing to iterate through a collection containing all found entries.\n+     *\n+     * @return Iterator allowing to iterate through a collection containing all\n+     *         found entries.\n      */\n     public Iterator<T> reverse_iterator() {\n-        final Deque<T> results = new ArrayDeque<T>();\n+        final Deque<T> results = new ArrayDeque<>();\n         search(root, results);\n         return results.descendingIterator();\n     }\n \n+    /**\n+     * A node in the KdTree. Each node has a parent node (unless the node is the\n+     * root) and a lesser and greater child node.\n+     *\n+     * The child nodes are set to \"lesser\" or \"greater\" depending on a\n+     * comparison between the nodes XYZPoint and the child's XYZPoint.\n+     */\n     public static class KdNode implements Comparable<KdNode> {\n \n-        private final XYZPoint id;\n-        private final int k;\n+        private final XYZPoint point;\n         private final int depth;\n+        private final KdNode parent;\n \n-        private KdNode parent = null;\n         private KdNode lesser = null;\n         private KdNode greater = null;\n \n-        public KdNode(XYZPoint id) {\n-            this.id = id;\n-            this.k = 3;\n-            this.depth = 0;\n+        /**\n+         * Constructs a new KdNode.\n+         *\n+         * @param point  Node point\n+         * @param depth  Depth of node in the tree, set to 0 if root node\n+         * @param parent Parent of this node, can be null if root node\n+         */\n+        public KdNode(XYZPoint point, int depth, KdNode parent) {\n+            this.point = point;\n+            this.depth = depth;\n+            this.parent = parent;\n         }\n \n-        public KdNode(XYZPoint id, int k, int depth) {\n-            this.id = id;\n-            this.k = k;\n-            this.depth = depth;\n+        /**\n+         * Compares two XYZPoints. The value used for the comparision is based\n+         * on the depth of the node in the tree and the tree's dimension.\n+         *\n+         * @param depth  Depth of node in the tree\n+         * @param point1 First point to compare\n+         * @param point2 Second point to compare\n+         *\n+         * @return 0 if points are equal -1 if point2 is \"less than\" point1 1 if\n+         *         point1 is \"greater than\" point2\n+         */\n+        public static int compareTo(int depth, XYZPoint point1, XYZPoint point2) {\n+            int axis = depth % DIMENSIONS;\n+            switch (axis) {\n+                case X_AXIS:\n+                    return X_COMPARATOR.compare(point1, point2);\n+                case Y_AXIS:\n+                    return Y_COMPARATOR.compare(point1, point2);\n+                default:\n+                    return Z_COMPARATOR.compare(point1, point2);\n+            }\n+        }\n+\n+        /**\n+         * Returns the nodes depth in the kdtree.\n+         *\n+         * @return Node depth.\n+         */\n+        int getDepth() {\n+            return depth;\n+        }\n+\n+        /**\n+         * Returns the parent of this node. If parent is null, the node is the\n+         * tree root node.\n+         *\n+         * @return Returns the parent of this node, or null if node is tree\n+         *         root.\n+         */\n+        KdNode getParent() {\n+            return parent;\n+        }\n+\n+        /**\n+         * Sets the lesser child of this node.\n+         *\n+         * @param node lesser Child node\n+         */\n+        void setLesser(KdNode node) {\n+            lesser = node;\n+        }\n+\n+        /**\n+         * Returns the nodes lesser child node.\n+         *\n+         * @return Returns KdNode or null if one was not set.\n+         */\n+        KdNode getLesser() {\n+            return lesser;\n+        }\n+\n+        /**\n+         * Sets the greater child of this node.\n+         *\n+         * @param node\n+         */\n+        void setGreater(KdNode node) {\n+            greater = node;\n+        }\n+\n+        /**\n+         * Returns the nodes lesser child node.\n+         *\n+         * @return Returns KdNode or null if one was not set.\n+         */\n+        KdNode getGreater() {\n+            return greater;\n         }\n \n-        public static int compareTo(int depth, int k, XYZPoint o1, XYZPoint o2) {\n-            int axis = depth % k;\n-            if (axis == X_AXIS)\n-                return X_COMPARATOR.compare(o1, o2);\n-            if (axis == Y_AXIS)\n-                return Y_COMPARATOR.compare(o1, o2);\n-            return Z_COMPARATOR.compare(o1, o2);\n+        /**\n+         * Returns the XYZ point of this node which contains the longitude and\n+         * latitude values.\n+         *\n+         * @return XYZPoint\n+         */\n+        XYZPoint getPoint() {\n+            return point;\n         }\n \n         /**\n          * {@inheritDoc}\n          */\n         @Override\n         public int hashCode() {\n-            return 31 * (this.k + this.depth + this.id.hashCode());\n+            return 31 * (DIMENSIONS + this.depth + this.getPoint().hashCode());\n         }\n \n         /**\n          * {@inheritDoc}\n          */\n         @Override\n         public boolean equals(Object obj) {\n-            if (obj == null)\n+            if (obj == null) {\n                 return false;\n-            if (!(obj instanceof KdNode))\n+            }\n+            if (!(obj instanceof KdNode)) {\n                 return false;\n+            }\n \n             KdNode kdNode = (KdNode) obj;\n-            if (this.compareTo(kdNode) == 0)\n-                return true;\n-            return false;\n+            return (this.compareTo(kdNode) == 0);\n         }\n \n         /**\n          * {@inheritDoc}\n          */\n         @Override\n         public int compareTo(KdNode o) {\n-            return compareTo(depth, k, this.id, o.id);\n+            return compareTo(depth, this.getPoint(), o.getPoint());\n         }\n \n         /**\n          * {@inheritDoc}\n          */\n         @Override\n         public String toString() {\n-            StringBuilder builder = new StringBuilder();\n-            builder.append(\"k=\").append(k);\n-            builder.append(\" depth=\").append(depth);\n-            builder.append(\" id=\").append(id.toString());\n+            StringBuilder builder = new StringBuilder(200);\n+            builder.append(\"dimensions=\").append(DIMENSIONS).append(\" depth=\").append(depth).append(\" point=\").append(getPoint().toString());\n             return builder.toString();\n         }\n     }\n \n+    /**\n+     * An XYZPoint is a representation of a three dimensional point.\n+     *\n+     * Z value will always been 0 when using latitude and longitude values.\n+     */\n     public static class XYZPoint implements Comparable<XYZPoint> {\n \n         protected final double x;\n         protected final double y;\n         protected final double z;\n \n         /**\n-         * z is defaulted to zero.\n+         * Constructs a new XYZPoint.\n          *\n-         * @param x\n-         * @param y\n+         * @param latitude\n+         * @param longitude\n          */\n-        public XYZPoint(double x, double y) {\n-            this.x = x;\n-            this.y = y;\n-            this.z = 0;\n+        public XYZPoint(Double latitude, Double longitude) {\n+            x = latitude;\n+            y = longitude;\n+            z = 0;\n         }\n \n         /**\n-         * Default constructor\n+         * Returns the x\\latitude value for the point.\n          *\n-         * @param x\n-         * @param y\n-         * @param z\n+         * @return x\\Latitude value for the point", "originalCommit": "1e10b58cffa61b060a6409d5d6d0cb5cc669aae3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU4MjYxMQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5622#discussion_r373582611", "bodyText": "Are we getting 5 nbrs or 1? comment is inconsistent with actual param.", "author": "raman-bt", "createdAt": "2020-01-31T16:58:18Z", "path": "Core/src/org/sleuthkit/autopsy/geolocation/MapPanel.java", "diffHunk": "@@ -434,16 +439,16 @@ private Point getLocationForDetailsPopup() {\n      * @return A waypoint that is within 10 pixels of the given point, or null\n      *         if none was found.\n      */\n-    private List<MapWaypoint> findClosestWaypoint(Point mouseClickPoint) {\n+    private List<MapWaypoint> findClosestWaypoint(Point clickPoint) {\n         if (waypointTree == null) {\n-            return null;\n+            return new ArrayList<>();\n         }\n \n         // Convert the mouse click location to latitude & longitude\n-        GeoPosition geopos = mapViewer.getTileFactory().pixelToGeo(mouseClickPoint, mapViewer.getZoom());\n+        GeoPosition geopos = mapViewer.convertPointToGeoPosition(clickPoint);\n \n         // Get the 5 nearest neightbors to the point\n-        Collection<MapWaypoint> waypoints = waypointTree.nearestNeighbourSearch(10, MapWaypoint.getDummyWaypoint(geopos));\n+        Collection<MapWaypoint> waypoints = waypointTree.nearestNeighbourSearch(1, MapWaypoint.getDummyWaypoint(geopos));", "originalCommit": "1e10b58cffa61b060a6409d5d6d0cb5cc669aae3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "190725b607ed9cefefcb1906df6dbff251c13c9a", "url": "https://github.com/sleuthkit/autopsy/commit/190725b607ed9cefefcb1906df6dbff251c13c9a", "message": "Updated based on review comments", "committedDate": "2020-02-04T16:46:00Z", "type": "commit"}]}