{"pr_number": 6057, "pr_title": "6579: Input from user can cause SQL exceptions in Personas", "pr_createdAt": "2020-07-08T14:49:37Z", "pr_url": "https://github.com/sleuthkit/autopsy/pull/6057", "timeline": [{"oid": "4426bba358c7fa800767300c4903711af7ed9b18", "url": "https://github.com/sleuthkit/autopsy/commit/4426bba358c7fa800767300c4903711af7ed9b18", "message": "6579: Input from user can cause SQL exceptions in Personas\n\nModified persona classes to run SQL as prepared statements.", "committedDate": "2020-07-08T14:48:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NDU5OA==", "url": "https://github.com/sleuthkit/autopsy/pull/6057#discussion_r452374598", "bodyText": "@raman-bt and @gdicristofaro, I think we can hadnle closing of the ResultSet more cleanly using another try with resources.", "author": "rcordovano", "createdAt": "2020-07-09T17:23:02Z", "path": "Core/src/org/sleuthkit/autopsy/centralrepository/datamodel/RdbmsCentralRepo.java", "diffHunk": "@@ -2543,88 +2547,55 @@ public void processSelectClause(String selectClause, InstanceTableCallback insta\n     }\n \n     @Override\n-    public void executeInsertSQL(String insertClause) throws CentralRepoException {\n-\n-        if (insertClause == null) {\n-            throw new CentralRepoException(\"Insert SQL is null\");\n-        }\n-\n-        String sql = getPlatformSpecificInsertSQL(insertClause);\n-        try (Connection conn = connect();\n-                PreparedStatement preparedStatement = conn.prepareStatement(sql);) {\n+    public void executeSqlAsPreparedStatement(String sql, List<Object> params) throws CentralRepoException {\n+      \n+        try (Connection conn = connect();) {\n+            \n+            PreparedStatement preparedStatement = conn.prepareStatement(sql);\n+                \n+             // Fill in the params\n+             if (params != null) {\n+                int paramIndex = 1;\n+                for (Object param : params) {\n+                    preparedStatement.setObject(paramIndex, param);\n+                    paramIndex += 1;\n+                }\n+            }\n+            // execute the prepared statement\n             preparedStatement.executeUpdate();\n         } catch (SQLException ex) {\n-            throw new CentralRepoException(String.format(\"Error running SQL %s, exception = %s\", sql, ex.getMessage()), ex);\n+            throw new CentralRepoException(String.format(\"Error executing prepared statement for SQL %s\", sql), ex);\n         }\n     }\n \n     @Override\n-    public void executeSelectSQL(String selectSQL, CentralRepositoryDbQueryCallback queryCallback) throws CentralRepoException {\n+    public void executeQueryAsPreparedStatement(String sql, List<Object> params, CentralRepositoryDbQueryCallback queryCallback) throws CentralRepoException {\n         if (queryCallback == null) {\n             throw new CentralRepoException(\"Query callback is null\");\n         }\n \n-        if (selectSQL == null) {\n-            throw new CentralRepoException(\"Select SQL is null\");\n-        }\n-\n-        StringBuilder sqlSb = new StringBuilder(QUERY_STR_MAX_LEN);\n-        if (selectSQL.trim().toUpperCase().startsWith(\"SELECT\") == false) {\n-            sqlSb.append(\"SELECT \");\n-        }\n-\n-        sqlSb.append(selectSQL);\n-\n-        try (Connection conn = connect();\n-                PreparedStatement preparedStatement = conn.prepareStatement(sqlSb.toString());\n-                ResultSet resultSet = preparedStatement.executeQuery();) {\n+        ResultSet resultSet = null;\n+        try ( Connection conn = connect();)   {\n+             PreparedStatement preparedStatement = conn.prepareStatement(sql);\n+             \n+            // fill in the params\n+            if (params != null) {\n+                int paramIndex = 1;\n+                for (Object param : params) {\n+                    preparedStatement.setObject(paramIndex, param);\n+                    paramIndex += 1;\n+                }\n+            }\n+            // execute query\n+            resultSet = preparedStatement.executeQuery();\n+           \n             queryCallback.process(resultSet);\n         } catch (SQLException ex) {\n-            throw new CentralRepoException(String.format(\"Error running SQL %s, exception = %s\", selectSQL, ex.getMessage()), ex);\n-        }\n-    }\n-    \n-    @Override\n-    public void executeUpdateSQL(String updateSQL) throws CentralRepoException {\n-\n-        if (updateSQL == null) {\n-            throw new CentralRepoException(\"Update SQL is null\");\n-        }\n-\n-        StringBuilder sqlSb = new StringBuilder(QUERY_STR_MAX_LEN);\n-        if (updateSQL.trim().toUpperCase().startsWith(\"UPDATE\") == false) {\n-            sqlSb.append(\"UPDATE \");\n-        }\n-        \n-        sqlSb.append(updateSQL);\n-        \n-        try (Connection conn = connect();\n-                PreparedStatement preparedStatement = conn.prepareStatement(sqlSb.toString());) {\n-            preparedStatement.executeUpdate();\n-        } catch (SQLException ex) {\n-            throw new CentralRepoException(String.format(\"Error running SQL %s, exception = %s\", updateSQL, ex.getMessage()), ex);\n-        }\n-    }\n-    \n-    @Override\n-    public void executeDeleteSQL(String deleteSQL) throws CentralRepoException {\n-        \n-        if (deleteSQL == null) {\n-            throw new CentralRepoException(\"Delete SQL is null\");\n-        }\n-\n-        StringBuilder sqlSb = new StringBuilder(QUERY_STR_MAX_LEN);\n-        if (deleteSQL.trim().toUpperCase().startsWith(\"DELETE\") == false) {\n-            sqlSb.append(\"DELETE \");\n-        }\n-\n-        sqlSb.append(deleteSQL);\n-\n-        try (Connection conn = connect();\n-                PreparedStatement preparedStatement = conn.prepareStatement(sqlSb.toString());) {\n-            preparedStatement.executeUpdate();\n-        } catch (SQLException ex) {\n-            throw new CentralRepoException(String.format(\"Error running SQL %s, exception = %s\", deleteSQL, ex.getMessage()), ex);\n+            throw new CentralRepoException(String.format(\"Error executing prepared statement for SQL query %s\", sql), ex);\n+        } finally {\n+            if (resultSet != null) {\n+                CentralRepoDbUtil.closeResultSet(resultSet);\n+            }", "originalCommit": "4426bba358c7fa800767300c4903711af7ed9b18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NjE1OQ==", "url": "https://github.com/sleuthkit/autopsy/pull/6057#discussion_r452376159", "bodyText": "@raman-bt and @gdicristofaro, this method is documented as executing an UPDATE/INSERT/DELETE statement. We need to acquire the exclusive (write) lock, not the shared (read) lock.", "author": "rcordovano", "createdAt": "2020-07-09T17:25:51Z", "path": "Core/src/org/sleuthkit/autopsy/centralrepository/datamodel/SqliteCentralRepo.java", "diffHunk": "@@ -832,48 +832,27 @@ public void processSelectClause(String selectClause, InstanceTableCallback insta\n             releaseSharedLock();\n         }        \n     }      \n-\n-    @Override\n-    public void executeInsertSQL(String insertSQL) throws CentralRepoException {\n-        try {\n-            acquireSharedLock();\n-            super.executeInsertSQL(insertSQL);\n-        } finally {\n-            releaseSharedLock();\n-        }\n-    }\n     \n     @Override\n-    public void executeSelectSQL(String selectSQL, CentralRepositoryDbQueryCallback queryCallback) throws CentralRepoException {\n+    public void executeSqlAsPreparedStatement(String sql, List<Object> params) throws CentralRepoException {\n         try {\n             acquireSharedLock();\n-            super.executeSelectSQL(selectSQL, queryCallback);\n+            super.executeSqlAsPreparedStatement(sql, params);", "originalCommit": "4426bba358c7fa800767300c4903711af7ed9b18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MzY4MA==", "url": "https://github.com/sleuthkit/autopsy/pull/6057#discussion_r452383680", "bodyText": "Perhaps we want to call the new methods:\nexecuteCommand\nexecuteQuery\n?", "author": "rcordovano", "createdAt": "2020-07-09T17:39:25Z", "path": "Core/src/org/sleuthkit/autopsy/centralrepository/datamodel/CentralRepository.java", "diffHunk": "@@ -827,78 +825,64 @@ CorrelationAttributeInstance getCorrelationAttributeInstance(CorrelationAttribut\n     /**\n      * Process a SELECT query\n      *\n-     * @param selectClause          query string to execute\n+     * @param selectClause query string to execute\n      * @param instanceTableCallback callback to process the instance\n      *\n      * @throws CentralRepoException\n      */\n-    public void processSelectClause(String selectClause, InstanceTableCallback instanceTableCallback) throws CentralRepoException;     \n-    \n-    \n-    /**\n-     * Executes an INSERT sql statement on the central repository database.\n-     * @param sql INSERT sql to execute.\n-     * \n-     * @throws CentralRepoException  If there is an error.\n-     */\n-    void executeInsertSQL(String sql) throws CentralRepoException;\n-    \n-    /**\n-     * Executes a SELECT sql statement on the central repository database.\n-     * \n-     * @param sql SELECT sql to execute.\n-     * @param queryCallback Query callback to handle the result of the query.\n-     * \n-     * @throws CentralRepoException If there is an error.\n-     */\n-    void executeSelectSQL(String sql, CentralRepositoryDbQueryCallback queryCallback) throws CentralRepoException;\n-    \n+    public void processSelectClause(String selectClause, InstanceTableCallback instanceTableCallback) throws CentralRepoException;\n+\n     /**\n-     * Executes an UPDATE sql statement on the central repository database.\n-     * \n-     * @param sql UPDATE sql to execute.\n-     * \n+     * Executes an INSERT/UPDATE/DELETE sql as a prepared statement, on the\n+     * central repository database.\n+     *\n+     * @param sql sql to execute.\n+     * @param params List of query params to use, may be empty.\n+     *\n      * @throws CentralRepoException If there is an error.\n      */\n-    void executeUpdateSQL(String sql) throws CentralRepoException;\n-    \n+    void executeSqlAsPreparedStatement(String sql, List<Object> params) throws CentralRepoException;\n+\n     /**\n-     * Executes a DELETE sql statement on the central repository database.\n-     * \n-     * @param sql DELETE sql to execute.\n-     * \n+     * Executes a SELECT query sql as a prepared statement, on the central\n+     * repository database.\n+     *\n+     * @param sql sql to execute.\n+     * @param params List of query params to use, may be empty.\n+     * @param queryCallback Query callback to handle the result of the query.\n+     *\n      * @throws CentralRepoException If there is an error.\n      */\n-    void executeDeleteSQL(String sql) throws CentralRepoException;\n-    \n+    void executeQueryAsPreparedStatement(String sql, List<Object> params, CentralRepositoryDbQueryCallback queryCallback) throws CentralRepoException;", "originalCommit": "4426bba358c7fa800767300c4903711af7ed9b18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c19ff6cf960f2dd02919024f64341b1b8e67caa0", "url": "https://github.com/sleuthkit/autopsy/commit/c19ff6cf960f2dd02919024f64341b1b8e67caa0", "message": "Addressed review comments.", "committedDate": "2020-07-09T18:45:58Z", "type": "commit"}]}