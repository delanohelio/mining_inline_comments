{"pr_number": 5771, "pr_title": "6186 horizontal resizing", "pr_createdAt": "2020-04-02T20:14:54Z", "pr_url": "https://github.com/sleuthkit/autopsy/pull/5771", "timeline": [{"oid": "4963daef83a990692582d623f2f91e0ced3b4eb0", "url": "https://github.com/sleuthkit/autopsy/commit/4963daef83a990692582d623f2f91e0ced3b4eb0", "message": "beginnings of horizontal resizing panel in indexed text viewer; needs spacing", "committedDate": "2020-03-31T16:05:34Z", "type": "commit"}, {"oid": "78d1bc1fc042a514adfdc2f2a7048617b5ce6ca9", "url": "https://github.com/sleuthkit/autopsy/commit/78d1bc1fc042a514adfdc2f2a7048617b5ce6ca9", "message": "adding wrap layout", "committedDate": "2020-03-31T16:06:25Z", "type": "commit"}, {"oid": "e070a5dae1a1ad0e2e350dd42c820518e9070066", "url": "https://github.com/sleuthkit/autopsy/commit/e070a5dae1a1ad0e2e350dd42c820518e9070066", "message": "reverting bundle properties", "committedDate": "2020-03-31T16:07:12Z", "type": "commit"}, {"oid": "8dba59edfb724c866f6a72ad7b4df357ead0a011", "url": "https://github.com/sleuthkit/autopsy/commit/8dba59edfb724c866f6a72ad7b4df357ead0a011", "message": "updated spacing", "committedDate": "2020-03-31T17:51:59Z", "type": "commit"}, {"oid": "d6156be0d8293c5d400bcdf21175b3d816a845d9", "url": "https://github.com/sleuthkit/autopsy/commit/d6156be0d8293c5d400bcdf21175b3d816a845d9", "message": "new layout manager", "committedDate": "2020-04-01T02:03:45Z", "type": "commit"}, {"oid": "93e7f6be929a29642ad807966c3350c71e1465ca", "url": "https://github.com/sleuthkit/autopsy/commit/93e7f6be929a29642ad807966c3350c71e1465ca", "message": "package scoping wrap layout", "committedDate": "2020-04-01T20:04:35Z", "type": "commit"}, {"oid": "2614255fe26391c0908991b26e8185bfa6c5037f", "url": "https://github.com/sleuthkit/autopsy/commit/2614255fe26391c0908991b26e8185bfa6c5037f", "message": "working through public api wrap layout", "committedDate": "2020-04-02T14:23:59Z", "type": "commit"}, {"oid": "20281bbf0053930285ec55eff45d6b31977787ba", "url": "https://github.com/sleuthkit/autopsy/commit/20281bbf0053930285ec55eff45d6b31977787ba", "message": "fine tuning of resizing", "committedDate": "2020-04-02T18:05:23Z", "type": "commit"}, {"oid": "5f1c9cc543acb055de9a2ebf29eba7f15ff39fe9", "url": "https://github.com/sleuthkit/autopsy/commit/5f1c9cc543acb055de9a2ebf29eba7f15ff39fe9", "message": "merge from develop", "committedDate": "2020-04-02T18:36:55Z", "type": "commit"}, {"oid": "f54e9dc9ddb64ed980745c7af74ec552a572560f", "url": "https://github.com/sleuthkit/autopsy/commit/f54e9dc9ddb64ed980745c7af74ec552a572560f", "message": "update for fonts", "committedDate": "2020-04-02T20:08:43Z", "type": "commit"}, {"oid": "5036610b55c9e280fffd3ddb4fbf8547e9636f22", "url": "https://github.com/sleuthkit/autopsy/commit/5036610b55c9e280fffd3ddb4fbf8547e9636f22", "message": "addressing some codacy issues", "committedDate": "2020-04-03T14:20:32Z", "type": "commit"}, {"oid": "3c0c42eb65c6e487cfa0bb2a9168c899a8be289c", "url": "https://github.com/sleuthkit/autopsy/commit/3c0c42eb65c6e487cfa0bb2a9168c899a8be289c", "message": "addressing some codacy issues", "committedDate": "2020-04-03T14:35:44Z", "type": "commit"}, {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "url": "https://github.com/sleuthkit/autopsy/commit/1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "message": "commenting fix", "committedDate": "2020-04-03T14:46:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDMzNw==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405214337", "bodyText": "Year is incorrect.\nAlso I am not a fan of having multiple classes with identical names is there anyway we can rename one of our two WrapLayout classes?", "author": "wschaeferB", "createdAt": "2020-04-08T01:57:59Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NzQ0NQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405497445", "bodyText": "I corrected the year and there is a question in Jira for the second concern.", "author": "gdicristofaro", "createdAt": "2020-04-08T12:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDQzMw==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405214433", "bodyText": "separation", "author": "wschaeferB", "createdAt": "2020-04-08T01:58:28Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDQ5Ng==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405214496", "bodyText": "separation", "author": "wschaeferB", "createdAt": "2020-04-08T01:58:39Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQxNA==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215414", "bodyText": "This doesn't feel like something we want to add to the public API a method where it does nothing and just has a note saying it is not used for this layout in the comment.\nAlso codacy doesn't like the empty body being undocumented.", "author": "wschaeferB", "createdAt": "2020-04-08T02:01:58Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1Njg0MA==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405456840", "bodyText": "This is a method of the interface, java.awt.LayoutManager.  I documented that it was not in use in the method body.  Is there a particular way this should be documented?", "author": "gdicristofaro", "createdAt": "2020-04-08T11:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQ0Mg==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215442", "bodyText": "This doesn't feel like something we want to add to the public API a method where it does nothing and just has a note saying it is not used for this layout in the comment.\nAlso codacy doesn't like the empty body being undocumented.", "author": "wschaeferB", "createdAt": "2020-04-08T02:02:03Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1Njg4Nw==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405456887", "bodyText": "This is a method of the interface, java.awt.LayoutManager.  I documented that it was not in use in the method body.  Is there a particular way this should be documented?", "author": "gdicristofaro", "createdAt": "2020-04-08T11:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMjQyNQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405522425", "bodyText": "Putting a comment in the body generally makes codacy happy about its \"Document Empty Body\" suggestion. I usually go with something like //Empty - This method intentionally left blank.  But there is no like required phrasing that I know of.\nMy bigger concern is that maybe these methods are expected to do things when implementing this class and that a user calling them will not quickly realize they are not doing anything when making use of the public API, I almost feel like them throwing an Unsupported exception would be preferable if they are not used by our code.", "author": "wschaeferB", "createdAt": "2020-04-08T13:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTkyNw==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215927", "bodyText": "Should be private with package level getters and no setters.", "author": "wschaeferB", "createdAt": "2020-04-08T02:03:57Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTk1OQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215959", "bodyText": "Should be private with package level getters and no setters.", "author": "wschaeferB", "createdAt": "2020-04-08T02:04:03Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNjQ4Nw==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405216487", "bodyText": "Should be private with package level getters and no setters.", "author": "wschaeferB", "createdAt": "2020-04-08T02:06:04Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNjc3OQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405216779", "bodyText": "Assigned value never used.", "author": "wschaeferB", "createdAt": "2020-04-08T02:07:16Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzAyNg==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217026", "bodyText": "local variable hides field", "author": "wschaeferB", "createdAt": "2020-04-08T02:08:07Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzE5MQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217191", "bodyText": "return of collection field.", "author": "wschaeferB", "createdAt": "2020-04-08T02:08:40Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1OTU2NA==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405459564", "bodyText": "Do you have a preference how this is handled (i.e. returning a new list generated from the original or something else)?", "author": "gdicristofaro", "createdAt": "2020-04-08T11:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzgyNg==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405507826", "bodyText": "Generally we have been using Collections.unmodifiableCollection(...)", "author": "wschaeferB", "createdAt": "2020-04-08T13:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzQ2NA==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217464", "bodyText": "synchronizing inside synchronization seems like a recipe for problems to me but I will let @rcordovano  weigh in on this one.", "author": "wschaeferB", "createdAt": "2020-04-08T02:09:42Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MjMwNw==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405462307", "bodyText": "My aim was to synchronize on both items similar to https://stackoverflow.com/a/4604038.  I wanted the tree lock to avoid problems with altering objects in a container during layout: https://docs.oracle.com/javase/7/docs/api/java/awt/Component.html#getTreeLock(), and I wanted a lock to prevent access to the collection created for objects that will be oppositely aligned to prevent changes during layout operations.", "author": "gdicristofaro", "createdAt": "2020-04-08T11:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxMDI5Mg==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405710292", "bodyText": "@gdicristofaro and @wschaeferB, nested locking is really risky and the consequence of a mistake, now or in maintenance, is a deadlock. Given that this code is UI code that will be thread-confined in the EDT, there should be no need for any synchronization at all in this class. Swing components get their thread safety by thread-confinement by design. Please remove all synchronization.", "author": "rcordovano", "createdAt": "2020-04-08T17:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzc3Nw==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217777", "bodyText": "synchronizing inside synchronization", "author": "wschaeferB", "createdAt": "2020-04-08T02:10:53Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODAwOA==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218008", "bodyText": "public constructor in private class should be package level constructor.", "author": "wschaeferB", "createdAt": "2020-04-08T02:11:38Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;\n+\n+        /**\n+         * The minimum height of the row which is the maximum of the preferred\n+         * heights of the components.\n+         */\n+        final int height;\n+\n+        /**\n+         * The minimum width of the row which is the sum of the preferred widths\n+         * of the subcomponents.\n+         */\n+        final int width;\n+\n+        public WrapLayoutRow(List<Component> components, List<Component> oppositeAligned, int height, int width) {", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODQ3MQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218471", "bodyText": "Should be private with package level getters and no setters.", "author": "wschaeferB", "createdAt": "2020-04-08T02:13:03Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODUwNw==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218507", "bodyText": "Should be private with package level getters and no setters.", "author": "wschaeferB", "createdAt": "2020-04-08T02:13:09Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODUzOA==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218538", "bodyText": "Should be private with package level getters and no setters.", "author": "wschaeferB", "createdAt": "2020-04-08T02:13:15Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;\n+\n+        /**\n+         * The minimum height of the row which is the maximum of the preferred\n+         * heights of the components.\n+         */\n+        final int height;", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODU3Nw==", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218577", "bodyText": "Should be private with package level getters and no setters.", "author": "wschaeferB", "createdAt": "2020-04-08T02:13:22Z", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;\n+\n+        /**\n+         * The minimum height of the row which is the maximum of the preferred\n+         * heights of the components.\n+         */\n+        final int height;\n+\n+        /**\n+         * The minimum width of the row which is the sum of the preferred widths\n+         * of the subcomponents.\n+         */\n+        final int width;", "originalCommit": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c0904d9fa24cfac8739a52d24c5793e50e004a43", "url": "https://github.com/sleuthkit/autopsy/commit/c0904d9fa24cfac8739a52d24c5793e50e004a43", "message": "updated formatting", "committedDate": "2020-04-08T12:21:42Z", "type": "commit"}, {"oid": "876a9870b2d65cf59abc0f4ff9dac1792437ad4d", "url": "https://github.com/sleuthkit/autopsy/commit/876a9870b2d65cf59abc0f4ff9dac1792437ad4d", "message": "fix for assigned value never used", "committedDate": "2020-04-08T12:59:53Z", "type": "commit"}, {"oid": "56cd8fcff69f1832d71456a7f1cb9a7a26a6e421", "url": "https://github.com/sleuthkit/autopsy/commit/56cd8fcff69f1832d71456a7f1cb9a7a26a6e421", "message": "address codacy items", "committedDate": "2020-04-08T14:58:24Z", "type": "commit"}, {"oid": "48d1e08280c13ea276550aed9e1e36f35301b9ec", "url": "https://github.com/sleuthkit/autopsy/commit/48d1e08280c13ea276550aed9e1e36f35301b9ec", "message": "remove synchronization", "committedDate": "2020-04-08T19:11:03Z", "type": "commit"}, {"oid": "8755ba9302a9b27ad524fe9fe21c3056bf70e2b3", "url": "https://github.com/sleuthkit/autopsy/commit/8755ba9302a9b27ad524fe9fe21c3056bf70e2b3", "message": "update for codacy remark", "committedDate": "2020-04-08T20:07:53Z", "type": "commit"}, {"oid": "5a089bae8cf8c7c5daaa631babf2f411f2083628", "url": "https://github.com/sleuthkit/autopsy/commit/5a089bae8cf8c7c5daaa631babf2f411f2083628", "message": "move to new WrapLayout", "committedDate": "2020-04-09T19:21:30Z", "type": "commit"}, {"oid": "f15a2ea712f5391dade596dae076438dc4153b8a", "url": "https://github.com/sleuthkit/autopsy/commit/f15a2ea712f5391dade596dae076438dc4153b8a", "message": "improved commenting", "committedDate": "2020-04-10T15:49:39Z", "type": "commit"}, {"oid": "f1e2bd67f0d2ea78b750914c71c168e207befe31", "url": "https://github.com/sleuthkit/autopsy/commit/f1e2bd67f0d2ea78b750914c71c168e207befe31", "message": "improved commenting", "committedDate": "2020-04-10T15:55:18Z", "type": "commit"}, {"oid": "9a423825adf55ca6f70878387b42d2f3ec91bd81", "url": "https://github.com/sleuthkit/autopsy/commit/9a423825adf55ca6f70878387b42d2f3ec91bd81", "message": "updated hgap to horizontalGap and vgap to verticalGap", "committedDate": "2020-04-16T11:47:32Z", "type": "commit"}, {"oid": "2c3465269346999d1bc8eeca6fd4680bd683c05b", "url": "https://github.com/sleuthkit/autopsy/commit/2c3465269346999d1bc8eeca6fd4680bd683c05b", "message": "isAlignOnBaseline method change", "committedDate": "2020-04-16T13:36:15Z", "type": "commit"}]}