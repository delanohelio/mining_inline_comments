{"pr_number": 6149, "pr_title": "1498 make method to map account to contact book", "pr_createdAt": "2020-07-29T18:49:05Z", "pr_url": "https://github.com/sleuthkit/autopsy/pull/6149", "timeline": [{"oid": "f171de25c6d4785ca5634cfd18c9e284c093a6fe", "url": "https://github.com/sleuthkit/autopsy/commit/f171de25c6d4785ca5634cfd18c9e284c093a6fe", "message": "Added ContactCache", "committedDate": "2020-07-23T20:36:01Z", "type": "commit"}, {"oid": "692b4604fa511fc3ea376a615d48fdd01e69940d", "url": "https://github.com/sleuthkit/autopsy/commit/692b4604fa511fc3ea376a615d48fdd01e69940d", "message": "Address codacy issues", "committedDate": "2020-07-23T20:47:23Z", "type": "commit"}, {"oid": "d028db66dd1e687590e20d56acf05932e3e82fcc", "url": "https://github.com/sleuthkit/autopsy/commit/d028db66dd1e687590e20d56acf05932e3e82fcc", "message": "Modified cvt account cache to be more efficent", "committedDate": "2020-07-29T18:46:52Z", "type": "commit"}, {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd", "url": "https://github.com/sleuthkit/autopsy/commit/1d168f32f4c34399490bda0661c686da9b0975dd", "message": "Simplified algorithum", "committedDate": "2020-08-03T15:04:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMTA1NA==", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465911054", "bodyText": "You may find acctMap.getOrDefault(accountID, new ArrayList<>()) useful here.", "author": "dannysmyda", "createdAt": "2020-08-05T18:09:34Z", "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {\n+\n+    private static final Logger logger = Logger.getLogger(ContactCache.class.getName());\n+\n+    private static ContactCache instance;\n+    \n+    private final LoadingCache<String, Map<String, List<BlackboardArtifact>>> accountMap;\n+\n+    /**\n+     * Returns the list of Contacts for the given Account.\n+     *\n+     * @param account Account instance.\n+     *\n+     * @return List of TSK_CONTACT artifacts that references the given Account.\n+     *         An empty list is returned if no contacts are found.\n+     *\n+     * @throws ExecutionException\n+     */\n+    static synchronized List<BlackboardArtifact> getContacts(Account account) throws ExecutionException {\n+        return getInstance().accountMap.get(\"realMap\").get(account.getTypeSpecificID());\n+    }\n+\n+    /**\n+     * Force the cache to invalidate all entries.\n+     */\n+    static synchronized void invalidateCache() {\n+        getInstance().accountMap.invalidateAll();\n+    }\n+\n+    /**\n+     * Construct a new instance.\n+     */\n+    private ContactCache() {\n+        \n+        accountMap = CacheBuilder.newBuilder().expireAfterAccess(10, TimeUnit.MINUTES).build(\n+                new CacheLoader<String, Map<String, List<BlackboardArtifact>>>() {\n+            @Override\n+            public Map<String, List<BlackboardArtifact>> load(String key) {\n+                try {\n+                    return  buildMap();\n+                } catch (SQLException | TskCoreException ex) {\n+                    logger.log(Level.WARNING, \"Failed to build account to contact map\", ex);\n+                } \n+                return new HashMap<>();  // Return an empty map if there is an exception to avoid NPE and continual trying.\n+            }\n+        });\n+\n+        PropertyChangeListener ingestListener = pce -> {\n+            String eventType = pce.getPropertyName();\n+            if (eventType.equals(DATA_ADDED.toString())) {\n+                ModuleDataEvent eventData = (ModuleDataEvent) pce.getOldValue();\n+                if (eventData.getBlackboardArtifactType().getTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT.getTypeID()) {\n+                    invalidateCache();\n+                }\n+            }\n+        };\n+\n+        IngestManager.getInstance().addIngestModuleEventListener(EnumSet.of(DATA_ADDED), ingestListener);\n+    }\n+\n+    /**\n+     * Returns the singleton instance of the cache object.\n+     *\n+     * @return AccountCache instance.\n+     */\n+    private static synchronized ContactCache getInstance() {\n+        if (instance == null) {\n+            instance = new ContactCache();\n+        }\n+\n+        return instance;\n+    }\n+    \n+    /**\n+     * Builds the map of account IDs to contacts that reference them.\n+     * \n+     * @return A map of account IDs to contact artifacts.\n+     * \n+     * @throws TskCoreException\n+     * @throws SQLException \n+     */\n+    private Map<String, List<BlackboardArtifact>> buildMap() throws TskCoreException, SQLException {\n+        Map<String, List<BlackboardArtifact>> acctMap = new HashMap<>();\n+        List<BlackboardArtifact> contactList = Case.getCurrentCase().getSleuthkitCase().getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT);\n+\n+        for(BlackboardArtifact contactArtifact: contactList) {\n+            List<BlackboardAttribute> contactAttributes = contactArtifact.getAttributes();\n+            for(BlackboardAttribute attribute: contactAttributes) {\n+                String typeName = attribute.getAttributeType().getTypeName();\n+                \n+                if(typeName.startsWith(\"TSK_EMAIL\")\n+                || typeName.startsWith(\"TSK_PHONE\")\n+                || typeName.startsWith(\"TSK_NAME\")\n+                || typeName.startsWith(\"TSK_ID\")) {\n+                    String accountID = attribute.getValueString();\n+                    List<BlackboardArtifact> artifactList = acctMap.get(accountID);", "originalCommit": "1d168f32f4c34399490bda0661c686da9b0975dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMjY4OQ==", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465912689", "bodyText": "In its current state, switching between cases may return old artifacts. Could you invalidate the cache when a case is closed?", "author": "dannysmyda", "createdAt": "2020-08-05T18:12:37Z", "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {\n+\n+    private static final Logger logger = Logger.getLogger(ContactCache.class.getName());\n+\n+    private static ContactCache instance;\n+    \n+    private final LoadingCache<String, Map<String, List<BlackboardArtifact>>> accountMap;\n+\n+    /**\n+     * Returns the list of Contacts for the given Account.\n+     *\n+     * @param account Account instance.\n+     *\n+     * @return List of TSK_CONTACT artifacts that references the given Account.\n+     *         An empty list is returned if no contacts are found.\n+     *\n+     * @throws ExecutionException\n+     */\n+    static synchronized List<BlackboardArtifact> getContacts(Account account) throws ExecutionException {\n+        return getInstance().accountMap.get(\"realMap\").get(account.getTypeSpecificID());\n+    }\n+\n+    /**\n+     * Force the cache to invalidate all entries.\n+     */\n+    static synchronized void invalidateCache() {\n+        getInstance().accountMap.invalidateAll();\n+    }\n+\n+    /**\n+     * Construct a new instance.\n+     */\n+    private ContactCache() {\n+        \n+        accountMap = CacheBuilder.newBuilder().expireAfterAccess(10, TimeUnit.MINUTES).build(\n+                new CacheLoader<String, Map<String, List<BlackboardArtifact>>>() {\n+            @Override\n+            public Map<String, List<BlackboardArtifact>> load(String key) {\n+                try {\n+                    return  buildMap();\n+                } catch (SQLException | TskCoreException ex) {\n+                    logger.log(Level.WARNING, \"Failed to build account to contact map\", ex);\n+                } \n+                return new HashMap<>();  // Return an empty map if there is an exception to avoid NPE and continual trying.\n+            }\n+        });\n+\n+        PropertyChangeListener ingestListener = pce -> {", "originalCommit": "1d168f32f4c34399490bda0661c686da9b0975dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyOTQ5Mg==", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465929492", "bodyText": "Good idea.", "author": "kellykelly3", "createdAt": "2020-08-05T18:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMjY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTY1NA==", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465915654", "bodyText": "I was originally going to post this on the story but I can't find it. But, this class seems to be filling a void in SleuthkitCase, @rcordovano would it make sense to add queries to be able to select artifacts by type and attribute value? I'd imagine this functionality will be needed elsewhere.", "author": "dannysmyda", "createdAt": "2020-08-05T18:18:17Z", "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {", "originalCommit": "1d168f32f4c34399490bda0661c686da9b0975dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyNzc3Nw==", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465927777", "bodyText": "@dannysmyda & @rcordovano For this story Brian told me to put this class in communications.  It moves to guiutils in a later story.", "author": "kellykelly3", "createdAt": "2020-08-05T18:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDU3MA==", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465934570", "bodyText": "Richard sent me a link to the story. Since the requirement is to keep these queries out of public API, we can just ignore this comment.", "author": "dannysmyda", "createdAt": "2020-08-05T18:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTY1NA=="}], "type": "inlineReview"}, {"oid": "5ca4dc6022e5d7ca8c9a8263a7b6c251f2c92b13", "url": "https://github.com/sleuthkit/autopsy/commit/5ca4dc6022e5d7ca8c9a8263a7b6c251f2c92b13", "message": "Updated based on review comments", "committedDate": "2020-08-05T19:12:22Z", "type": "commit"}]}