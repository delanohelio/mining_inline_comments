{"pr_number": 844, "pr_title": "Implement setRoutingData for MetadataStoreDirectoryService", "pr_createdAt": "2020-03-02T23:14:13Z", "pr_url": "https://github.com/apache/helix/pull/844", "timeline": [{"oid": "319bfcb8c9a4be01e6a8fbdaa92e8db824399d42", "url": "https://github.com/apache/helix/commit/319bfcb8c9a4be01e6a8fbdaa92e8db824399d42", "message": "Implement setRoutingData", "committedDate": "2020-03-02T22:40:55Z", "type": "commit"}, {"oid": "955eea975b244652347b02aaab8bf4b1cc6526f6", "url": "https://github.com/apache/helix/commit/955eea975b244652347b02aaab8bf4b1cc6526f6", "message": "nit", "committedDate": "2020-03-02T23:14:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNDQ2Ng==", "url": "https://github.com/apache/helix/pull/844#discussion_r386714466", "bodyText": "Do we want to throw any exception or log this?", "author": "huizhilu", "createdAt": "2020-03-02T23:31:20Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -113,10 +113,14 @@ private void init(String namespace, String zkAddress) throws InvalidRoutingDataE\n           _routingDataWriterMap.put(namespace, new ZkRoutingDataWriter(namespace, zkAddress));\n \n           // Populate realmToShardingKeys with ZkRoutingDataReader\n-          _realmToShardingKeysMap\n-              .put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n-          _routingDataMap\n-              .put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n+          Map<String, List<String>> rawRoutingData =\n+              _routingDataReaderMap.get(namespace).getRoutingData();\n+          _realmToShardingKeysMap.put(namespace, rawRoutingData);\n+          try {\n+            _routingDataMap.put(namespace, new TrieRoutingData(rawRoutingData));\n+          } catch (InvalidRoutingDataException e) {\n+            // Do not create TrieRoutingData if the routing data is invalid", "originalCommit": "955eea975b244652347b02aaab8bf4b1cc6526f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzUxNQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r386743515", "bodyText": "We are not throwing any exception because we allow this to happen. For logs, it's a good point - in my opinion, logging this may pollute the main log because in most cases this situation isn't even qualified as an error (when a namespace is initialized, this exception clause will happen because rawRoutingData is empty, which is a normal situation); however, when this is an actual error situation, it's better to log it. Since this logic is in data change callback, it's very easy to spam logs that are non-essential in this case, hence why I didn't log anything here.\nSince I have conflicting views myself, I'm open to your suggestions.", "author": "NealSun96", "createdAt": "2020-03-03T01:04:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NDg0Mw==", "url": "https://github.com/apache/helix/pull/844#discussion_r386764843", "bodyText": "Great that you've considered possible log pollution! I think a WARN log would be okay to add here. Note that we are not expecting very frequent writes :)", "author": "narendly", "createdAt": "2020-03-03T02:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5MDkyMQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r387190921", "bodyText": "Using WARN is a good middle ground. I'll add logging for this section and also the next. Thank you for the suggestion!", "author": "NealSun96", "createdAt": "2020-03-03T17:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTYyNQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r386715625", "bodyText": "This is like double lock checking. You may also want to check it before synchronized which also improves performance.\nConsidering namespace is not changed, you don\u2019t have to check it in within synchronized block.", "author": "huizhilu", "createdAt": "2020-03-02T23:34:32Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -155,6 +159,19 @@ private void init(String namespace, String zkAddress) throws InvalidRoutingDataE\n     return routingData;\n   }\n \n+  @Override\n+  public boolean setNamespaceRoutingData(String namespace, Map<String, List<String>> routingData) {\n+    synchronized (this) {\n+      if (!_routingDataWriterMap.containsKey(namespace)) {", "originalCommit": "955eea975b244652347b02aaab8bf4b1cc6526f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzU3Mg==", "url": "https://github.com/apache/helix/pull/844#discussion_r386743572", "bodyText": "Sure.", "author": "NealSun96", "createdAt": "2020-03-03T01:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjE0Mg==", "url": "https://github.com/apache/helix/pull/844#discussion_r386716142", "bodyText": "move it before synchronized", "author": "huizhilu", "createdAt": "2020-03-02T23:36:04Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -169,72 +186,102 @@ private void init(String namespace, String zkAddress) throws InvalidRoutingDataE\n \n   @Override\n   public Map<String, String> getAllMappingUnderPath(String namespace, String path) {\n-    if (!_routingDataMap.containsKey(namespace)) {\n+    // Check _routingZkAddressMap first to see if namespace is included\n+    if (!_routingZkAddressMap.containsKey(namespace)) {\n       throw new NoSuchElementException(\n           \"Failed to get all mapping under path: Namespace \" + namespace + \" is not found!\");\n     }\n+    // If namespace is included but not routing data, it means the routing data is invalid\n+    if (!_routingDataMap.containsKey(namespace)) {\n+      throw new IllegalStateException(\"Failed to get all mapping under path: Namespace \" + namespace\n+          + \" contains invalid routing data!\");\n+    }\n     return _routingDataMap.get(namespace).getAllMappingUnderPath(path);\n   }\n \n   @Override\n   public String getMetadataStoreRealm(String namespace, String shardingKey) {\n-    if (!_routingDataMap.containsKey(namespace)) {\n+    // Check _routingZkAddressMap first to see if namespace is included\n+    if (!_routingZkAddressMap.containsKey(namespace)) {\n       throw new NoSuchElementException(\n           \"Failed to get metadata store realm: Namespace \" + namespace + \" is not found!\");\n     }\n+    // If namespace is included but not routing data, it means the routing data is invalid\n+    if (!_routingDataMap.containsKey(namespace)) {\n+      throw new IllegalStateException(\"Failed to get metadata store realm: Namespace \" + namespace\n+          + \" contains invalid routing data!\");\n+    }\n     return _routingDataMap.get(namespace).getMetadataStoreRealm(shardingKey);\n   }\n \n   @Override\n   public boolean addMetadataStoreRealm(String namespace, String realm) {\n-    if (!_routingDataWriterMap.containsKey(namespace)) {\n-      // throwing NoSuchElementException instead of IllegalArgumentException to differentiate the\n-      // status code in the Accessor level\n-      throw new NoSuchElementException(\n-          \"Failed to add metadata store realm: Namespace \" + namespace + \" is not found!\");\n+    synchronized (this) {\n+      if (!_routingDataWriterMap.containsKey(namespace)) {\n+        // throwing NoSuchElementException instead of IllegalArgumentException to differentiate the\n+        // status code in the Accessor level\n+        throw new NoSuchElementException(\n+            \"Failed to add metadata store realm: Namespace \" + namespace + \" is not found!\");\n+      }\n+      boolean result = _routingDataWriterMap.get(namespace).addMetadataStoreRealm(realm);\n+      refreshRoutingData(namespace);\n+      return result;\n     }\n-    return _routingDataWriterMap.get(namespace).addMetadataStoreRealm(realm);\n   }\n \n   @Override\n   public boolean deleteMetadataStoreRealm(String namespace, String realm) {\n-    if (!_routingDataWriterMap.containsKey(namespace)) {\n-      // throwing NoSuchElementException instead of IllegalArgumentException to differentiate the\n-      // status code in the Accessor level\n-      throw new NoSuchElementException(\n-          \"Failed to delete metadata store realm: Namespace \" + namespace + \" is not found!\");\n+    synchronized (this) {\n+      if (!_routingDataWriterMap.containsKey(namespace)) {\n+        // throwing NoSuchElementException instead of IllegalArgumentException to differentiate the\n+        // status code in the Accessor level\n+        throw new NoSuchElementException(\n+            \"Failed to delete metadata store realm: Namespace \" + namespace + \" is not found!\");\n+      }\n+      boolean result = _routingDataWriterMap.get(namespace).deleteMetadataStoreRealm(realm);\n+      refreshRoutingData(namespace);\n+      return result;\n     }\n-    return _routingDataWriterMap.get(namespace).deleteMetadataStoreRealm(realm);\n   }\n \n   @Override\n   public boolean addShardingKey(String namespace, String realm, String shardingKey) {\n-    if (!_routingDataWriterMap.containsKey(namespace) || !_routingDataMap.containsKey(namespace)) {\n-      // throwing NoSuchElementException instead of IllegalArgumentException to differentiate the\n-      // status code in the Accessor level\n-      throw new NoSuchElementException(\n-          \"Failed to add sharding key: Namespace \" + namespace + \" is not found!\");\n-    }\n-    if (_routingDataMap.get(namespace).containsKeyRealmPair(shardingKey, realm)) {\n-      return true;\n-    }\n-    if (!_routingDataMap.get(namespace).isShardingKeyInsertionValid(shardingKey)) {\n-      throw new IllegalArgumentException(\n-          \"Failed to add sharding key: Adding sharding key \" + shardingKey\n-              + \" makes routing data invalid!\");\n+    synchronized (this) {\n+      if (!_routingDataWriterMap.containsKey(namespace)) {\n+        // throwing NoSuchElementException instead of IllegalArgumentException to differentiate the\n+        // status code in the Accessor level\n+        throw new NoSuchElementException(\n+            \"Failed to add sharding key: Namespace \" + namespace + \" is not found!\");\n+      }\n+      if (_routingDataMap.containsKey(namespace) && _routingDataMap.get(namespace)\n+          .containsKeyRealmPair(shardingKey, realm)) {\n+        return true;\n+      }\n+      if (_routingDataMap.containsKey(namespace) && !_routingDataMap.get(namespace)\n+          .isShardingKeyInsertionValid(shardingKey)) {\n+        throw new IllegalArgumentException(\n+            \"Failed to add sharding key: Adding sharding key \" + shardingKey\n+                + \" makes routing data invalid!\");\n+      }\n+      boolean result = _routingDataWriterMap.get(namespace).addShardingKey(realm, shardingKey);\n+      refreshRoutingData(namespace);\n+      return result;\n     }\n-    return _routingDataWriterMap.get(namespace).addShardingKey(realm, shardingKey);\n   }\n \n   @Override\n   public boolean deleteShardingKey(String namespace, String realm, String shardingKey) {\n-    if (!_routingDataWriterMap.containsKey(namespace)) {\n-      // throwing NoSuchElementException instead of IllegalArgumentException to differentiate the\n-      // status code in the Accessor level\n-      throw new NoSuchElementException(\n-          \"Failed to delete sharding key: Namespace \" + namespace + \" is not found!\");\n+    synchronized (this) {\n+      if (!_routingDataWriterMap.containsKey(namespace)) {", "originalCommit": "955eea975b244652347b02aaab8bf4b1cc6526f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjg5OQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r386716899", "bodyText": "Before synchronized", "author": "huizhilu", "createdAt": "2020-03-02T23:38:25Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -169,72 +186,102 @@ private void init(String namespace, String zkAddress) throws InvalidRoutingDataE\n \n   @Override\n   public Map<String, String> getAllMappingUnderPath(String namespace, String path) {\n-    if (!_routingDataMap.containsKey(namespace)) {\n+    // Check _routingZkAddressMap first to see if namespace is included\n+    if (!_routingZkAddressMap.containsKey(namespace)) {\n       throw new NoSuchElementException(\n           \"Failed to get all mapping under path: Namespace \" + namespace + \" is not found!\");\n     }\n+    // If namespace is included but not routing data, it means the routing data is invalid\n+    if (!_routingDataMap.containsKey(namespace)) {\n+      throw new IllegalStateException(\"Failed to get all mapping under path: Namespace \" + namespace\n+          + \" contains invalid routing data!\");\n+    }\n     return _routingDataMap.get(namespace).getAllMappingUnderPath(path);\n   }\n \n   @Override\n   public String getMetadataStoreRealm(String namespace, String shardingKey) {\n-    if (!_routingDataMap.containsKey(namespace)) {\n+    // Check _routingZkAddressMap first to see if namespace is included\n+    if (!_routingZkAddressMap.containsKey(namespace)) {\n       throw new NoSuchElementException(\n           \"Failed to get metadata store realm: Namespace \" + namespace + \" is not found!\");\n     }\n+    // If namespace is included but not routing data, it means the routing data is invalid\n+    if (!_routingDataMap.containsKey(namespace)) {\n+      throw new IllegalStateException(\"Failed to get metadata store realm: Namespace \" + namespace\n+          + \" contains invalid routing data!\");\n+    }\n     return _routingDataMap.get(namespace).getMetadataStoreRealm(shardingKey);\n   }\n \n   @Override\n   public boolean addMetadataStoreRealm(String namespace, String realm) {\n-    if (!_routingDataWriterMap.containsKey(namespace)) {\n-      // throwing NoSuchElementException instead of IllegalArgumentException to differentiate the\n-      // status code in the Accessor level\n-      throw new NoSuchElementException(\n-          \"Failed to add metadata store realm: Namespace \" + namespace + \" is not found!\");\n+    synchronized (this) {\n+      if (!_routingDataWriterMap.containsKey(namespace)) {", "originalCommit": "955eea975b244652347b02aaab8bf4b1cc6526f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "url": "https://github.com/apache/helix/commit/2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "message": "Namespace check outside of synchronized", "committedDate": "2020-03-03T01:08:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NTM0NA==", "url": "https://github.com/apache/helix/pull/844#discussion_r386765344", "bodyText": "Could we rephrase this to say, the routing data is either empty or invalid?", "author": "narendly", "createdAt": "2020-03-03T02:23:41Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -169,19 +186,31 @@ private void init(String namespace, String zkAddress) throws InvalidRoutingDataE\n \n   @Override\n   public Map<String, String> getAllMappingUnderPath(String namespace, String path) {\n-    if (!_routingDataMap.containsKey(namespace)) {\n+    // Check _routingZkAddressMap first to see if namespace is included\n+    if (!_routingZkAddressMap.containsKey(namespace)) {\n       throw new NoSuchElementException(\n           \"Failed to get all mapping under path: Namespace \" + namespace + \" is not found!\");\n     }\n+    // If namespace is included but not routing data, it means the routing data is invalid\n+    if (!_routingDataMap.containsKey(namespace)) {\n+      throw new IllegalStateException(\"Failed to get all mapping under path: Namespace \" + namespace\n+          + \" contains invalid routing data!\");", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5MTM3MQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r387191371", "bodyText": "Agreed.", "author": "NealSun96", "createdAt": "2020-03-03T17:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NTUzMA==", "url": "https://github.com/apache/helix/pull/844#discussion_r386765530", "bodyText": "Same as above :)", "author": "narendly", "createdAt": "2020-03-03T02:24:23Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -169,19 +186,31 @@ private void init(String namespace, String zkAddress) throws InvalidRoutingDataE\n \n   @Override\n   public Map<String, String> getAllMappingUnderPath(String namespace, String path) {\n-    if (!_routingDataMap.containsKey(namespace)) {\n+    // Check _routingZkAddressMap first to see if namespace is included\n+    if (!_routingZkAddressMap.containsKey(namespace)) {\n       throw new NoSuchElementException(\n           \"Failed to get all mapping under path: Namespace \" + namespace + \" is not found!\");\n     }\n+    // If namespace is included but not routing data, it means the routing data is invalid\n+    if (!_routingDataMap.containsKey(namespace)) {\n+      throw new IllegalStateException(\"Failed to get all mapping under path: Namespace \" + namespace\n+          + \" contains invalid routing data!\");\n+    }\n     return _routingDataMap.get(namespace).getAllMappingUnderPath(path);\n   }\n \n   @Override\n   public String getMetadataStoreRealm(String namespace, String shardingKey) {\n-    if (!_routingDataMap.containsKey(namespace)) {\n+    // Check _routingZkAddressMap first to see if namespace is included\n+    if (!_routingZkAddressMap.containsKey(namespace)) {\n       throw new NoSuchElementException(\n           \"Failed to get metadata store realm: Namespace \" + namespace + \" is not found!\");\n     }\n+    // If namespace is included but not routing data, it means the routing data is invalid\n+    if (!_routingDataMap.containsKey(namespace)) {\n+      throw new IllegalStateException(\"Failed to get metadata store realm: Namespace \" + namespace\n+          + \" contains invalid routing data!\");", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NjE1Nw==", "url": "https://github.com/apache/helix/pull/844#discussion_r386766157", "bodyText": "Probably a good idea to add a warn log here?", "author": "narendly", "createdAt": "2020-03-03T02:26:41Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -262,17 +309,22 @@ public void refreshRoutingData(String namespace) {\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\n           \"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n+      return;\n     }\n \n+    Map<String, List<String>> rawRoutingData;\n     try {\n-      Map<String, List<String>> rawRoutingData =\n-          _routingDataReaderMap.get(namespace).getRoutingData();\n+      rawRoutingData = _routingDataReaderMap.get(namespace).getRoutingData();\n       _realmToShardingKeysMap.put(namespace, rawRoutingData);\n-\n-      MetadataStoreRoutingData routingData = new TrieRoutingData(rawRoutingData);\n-      _routingDataMap.put(namespace, routingData);\n     } catch (InvalidRoutingDataException e) {\n       LOG.error(\"Failed to refresh cached routing data for namespace {}\", namespace, e);\n+      return;\n+    }\n+\n+    try {\n+      _routingDataMap.put(namespace, new TrieRoutingData(rawRoutingData));\n+    } catch (InvalidRoutingDataException e) {\n+      // Do not create TrieRoutingData if the routing data is invalid", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NjU2MQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r386766561", "bodyText": "Could we create a constant variable ObjectMapper instead of creating one every time this endpoint is called?\nprivate static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\nand you could use this throughout the class :)", "author": "narendly", "createdAt": "2020-03-03T02:28:23Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -209,8 +214,20 @@ public synchronized boolean setRoutingData(Map<String, List<String>> routingData\n       return true;\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + constructUrlSuffix(\n+        MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+    HttpPut httpPut = new HttpPut(url);\n+    String routingDataJsonString;\n+    try {\n+      routingDataJsonString = new ObjectMapper().writeValueAsString(routingData);", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5MjYwMg==", "url": "https://github.com/apache/helix/pull/844#discussion_r387192602", "bodyText": "Sure.", "author": "NealSun96", "createdAt": "2020-03-03T17:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NjU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NjgwNQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r386766805", "bodyText": "shouldWeUseCamelCaseFor request_method?", "author": "narendly", "createdAt": "2020-03-03T02:29:31Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -332,8 +349,9 @@ private String constructUrlSuffix(String... urlParams) {\n     return String.join(\"\", allUrlParameters);\n   }\n \n-  private boolean forwardRequestToLeader(String urlSuffix, HttpConstants.RestVerbs request_method,\n-      int expectedResponseCode) throws IllegalArgumentException {\n+  private boolean buildAndSendRequestToLeader(String urlSuffix,\n+      HttpConstants.RestVerbs request_method, int expectedResponseCode)", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5Mjg2NA==", "url": "https://github.com/apache/helix/pull/844#discussion_r387192864", "bodyText": "Ah sorry, python habits coming through. Fixing it.", "author": "NealSun96", "createdAt": "2020-03-03T17:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NjgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NzE3Mg==", "url": "https://github.com/apache/helix/pull/844#discussion_r386767172", "bodyText": "Same thing as above. We can create ObjectMapper once and use it over and over.", "author": "narendly", "createdAt": "2020-03-03T02:30:39Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -220,6 +228,24 @@ public Response getRoutingData() {\n     return JSONRepresentation(responseMap);\n   }\n \n+  @PUT\n+  @Path(\"/routing-data\")\n+  @Consumes(MediaType.APPLICATION_JSON)\n+  public Response setRoutingData(String jsonContent) {\n+    try {\n+      Map<String, List<String>> routingData = new ObjectMapper()", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5NDY3MQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r387194671", "bodyText": "Although I agree with the same change in ZkRoutingDataWriter, in this case it's actually unnecessary because MetadataStoreDirectoryAccessor has a per-request cycle. This object mapper will be reconstructed every time anyway. Given that, the object mapper is better a local variable because it's not used anywhere else.", "author": "NealSun96", "createdAt": "2020-03-03T17:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NzE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzMDgyOA==", "url": "https://github.com/apache/helix/pull/844#discussion_r387230828", "bodyText": "On a second thought, the ObjectMapper will be static and is reusable. Making the changes, then.", "author": "NealSun96", "createdAt": "2020-03-03T19:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NzE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NzU4OQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r386767589", "bodyText": "Nit: Outside of helix-core module, we should try to use ZkClient instead of BaseDataAccessor.", "author": "narendly", "createdAt": "2020-03-03T02:32:18Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataReader.java", "diffHunk": "@@ -130,17 +116,11 @@ public void testGetRoutingDataMSRDChildEmptyValue() {\n     }\n   }\n \n-  private void deleteRoutingDataPath() throws Exception {\n-    Assert.assertTrue(TestHelper.verify(() -> {\n-      ZK_SERVER_MAP.get(ZK_ADDR).getZkClient()\n-          .deleteRecursively(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n-\n-      if (ZK_SERVER_MAP.get(ZK_ADDR).getZkClient()\n-          .exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n-        return false;\n-      }\n-\n-      return true;\n-    }, TestHelper.WAIT_DURATION), \"Routing data path should be deleted after the tests.\");\n+  private void clearRoutingDataPath() {\n+    for (String zkRealm : _baseAccessor\n+        .getChildNames(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, AccessOption.PERSISTENT)) {\n+      _baseAccessor.remove(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm,\n+          AccessOption.PERSISTENT);", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5OTk5Ng==", "url": "https://github.com/apache/helix/pull/844#discussion_r387199996", "bodyText": "I believe we talked about this before implementing and decided to use BaseDataAccessor. This is good to know.\nRegardless, how do you feel about using HelixZkClient? It's used in other tests as well (like the one for leader election), but it's a deprecated class. Is it really okay to use it among the tests? I'd expect the general consensus to be avoid using it.", "author": "NealSun96", "createdAt": "2020-03-03T18:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NzU4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNDMyNg==", "url": "https://github.com/apache/helix/pull/844#discussion_r387214326", "bodyText": "Resolved offline. Using HelixZkClient and will migrate later.", "author": "NealSun96", "createdAt": "2020-03-03T18:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NzU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2Nzc2MA==", "url": "https://github.com/apache/helix/pull/844#discussion_r386767760", "bodyText": "Could we use a pre-defined constant instead of \"PUT\"? (Cue: HttpVerbs..) Same applies below.", "author": "narendly", "createdAt": "2020-03-03T02:33:06Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java", "diffHunk": "@@ -132,61 +132,86 @@ public void testSetRoutingData() {\n   public void testAddMetadataStoreRealmNonLeader() {\n     MockWriter mockWriter = new MockWriter(DUMMY_NAMESPACE, ZK_ADDR);\n     mockWriter.addMetadataStoreRealm(DUMMY_REALM);\n-    Assert.assertEquals(\"PUT\", mockWriter.calledRequest.getMethod());\n+    Assert.assertEquals(mockWriter.calledRequest.getMethod(), \"PUT\");", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMDI0OA==", "url": "https://github.com/apache/helix/pull/844#discussion_r387200248", "bodyText": "Sure.", "author": "NealSun96", "createdAt": "2020-03-03T18:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2Nzc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NzkwNA==", "url": "https://github.com/apache/helix/pull/844#discussion_r386767904", "bodyText": "It would be better to stick with ZkClient if possible outside of helix-core module.", "author": "narendly", "createdAt": "2020-03-03T02:33:34Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java", "diffHunk": "@@ -132,61 +132,86 @@ public void testSetRoutingData() {\n   public void testAddMetadataStoreRealmNonLeader() {\n     MockWriter mockWriter = new MockWriter(DUMMY_NAMESPACE, ZK_ADDR);\n     mockWriter.addMetadataStoreRealm(DUMMY_REALM);\n-    Assert.assertEquals(\"PUT\", mockWriter.calledRequest.getMethod());\n+    Assert.assertEquals(mockWriter.calledRequest.getMethod(), \"PUT\");\n     List<String> expectedUrlParams = Arrays\n         .asList(MetadataStoreRoutingConstants.MSDS_NAMESPACES_URL_PREFIX, DUMMY_NAMESPACE,\n             MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, DUMMY_REALM);\n     String expectedUrl =\n         getBaseUri().toString() + String.join(\"/\", expectedUrlParams).replaceAll(\"//\", \"/\")\n             .substring(1);\n-    Assert.assertEquals(expectedUrl, mockWriter.calledRequest.getURI().toString());\n+    Assert.assertEquals(mockWriter.calledRequest.getURI().toString(), expectedUrl);\n     mockWriter.close();\n   }\n \n   @Test(dependsOnMethods = \"testAddMetadataStoreRealmNonLeader\")\n   public void testDeleteMetadataStoreRealmNonLeader() {\n     MockWriter mockWriter = new MockWriter(DUMMY_NAMESPACE, ZK_ADDR);\n     mockWriter.deleteMetadataStoreRealm(DUMMY_REALM);\n-    Assert.assertEquals(\"DELETE\", mockWriter.calledRequest.getMethod());\n+    Assert.assertEquals(mockWriter.calledRequest.getMethod(), \"DELETE\");\n     List<String> expectedUrlParams = Arrays\n         .asList(MetadataStoreRoutingConstants.MSDS_NAMESPACES_URL_PREFIX, DUMMY_NAMESPACE,\n             MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, DUMMY_REALM);\n     String expectedUrl =\n         getBaseUri().toString() + String.join(\"/\", expectedUrlParams).replaceAll(\"//\", \"/\")\n             .substring(1);\n-    Assert.assertEquals(expectedUrl, mockWriter.calledRequest.getURI().toString());\n+    Assert.assertEquals(mockWriter.calledRequest.getURI().toString(), expectedUrl);\n     mockWriter.close();\n   }\n \n   @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmNonLeader\")\n   public void testAddShardingKeyNonLeader() {\n     MockWriter mockWriter = new MockWriter(DUMMY_NAMESPACE, ZK_ADDR);\n     mockWriter.addShardingKey(DUMMY_REALM, DUMMY_SHARDING_KEY);\n-    Assert.assertEquals(\"PUT\", mockWriter.calledRequest.getMethod());\n+    Assert.assertEquals(mockWriter.calledRequest.getMethod(), \"PUT\");\n     List<String> expectedUrlParams = Arrays\n         .asList(MetadataStoreRoutingConstants.MSDS_NAMESPACES_URL_PREFIX, DUMMY_NAMESPACE,\n             MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, DUMMY_REALM,\n             MetadataStoreRoutingConstants.MSDS_GET_ALL_SHARDING_KEYS_ENDPOINT, DUMMY_SHARDING_KEY);\n     String expectedUrl =\n         getBaseUri().toString() + String.join(\"/\", expectedUrlParams).replaceAll(\"//\", \"/\")\n             .substring(1);\n-    Assert.assertEquals(expectedUrl, mockWriter.calledRequest.getURI().toString());\n+    Assert.assertEquals(mockWriter.calledRequest.getURI().toString(), expectedUrl);\n     mockWriter.close();\n   }\n \n   @Test(dependsOnMethods = \"testAddShardingKeyNonLeader\")\n   public void testDeleteShardingKeyNonLeader() {\n     MockWriter mockWriter = new MockWriter(DUMMY_NAMESPACE, ZK_ADDR);\n     mockWriter.deleteShardingKey(DUMMY_REALM, DUMMY_SHARDING_KEY);\n-    Assert.assertEquals(\"DELETE\", mockWriter.calledRequest.getMethod());\n+    Assert.assertEquals(mockWriter.calledRequest.getMethod(), \"DELETE\");\n     List<String> expectedUrlParams = Arrays\n         .asList(MetadataStoreRoutingConstants.MSDS_NAMESPACES_URL_PREFIX, DUMMY_NAMESPACE,\n             MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, DUMMY_REALM,\n             MetadataStoreRoutingConstants.MSDS_GET_ALL_SHARDING_KEYS_ENDPOINT, DUMMY_SHARDING_KEY);\n     String expectedUrl =\n         getBaseUri().toString() + String.join(\"/\", expectedUrlParams).replaceAll(\"//\", \"/\")\n             .substring(1);\n-    Assert.assertEquals(expectedUrl, mockWriter.calledRequest.getURI().toString());\n+    Assert.assertEquals(mockWriter.calledRequest.getURI().toString(), expectedUrl);\n     mockWriter.close();\n   }\n+\n+  @Test(dependsOnMethods = \"testDeleteShardingKeyNonLeader\")\n+  public void testSetRoutingDataNonLeader() {\n+    MockWriter mockWriter = new MockWriter(DUMMY_NAMESPACE, ZK_ADDR);\n+    Map<String, List<String>> testRoutingDataMap =\n+        ImmutableMap.of(DUMMY_REALM, Collections.singletonList(DUMMY_SHARDING_KEY));\n+    mockWriter.setRoutingData(testRoutingDataMap);\n+    Assert.assertEquals(mockWriter.calledRequest.getMethod(), \"PUT\");\n+    List<String> expectedUrlParams = Arrays\n+        .asList(MetadataStoreRoutingConstants.MSDS_NAMESPACES_URL_PREFIX, DUMMY_NAMESPACE,\n+            MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+    String expectedUrl =\n+        getBaseUri().toString() + String.join(\"/\", expectedUrlParams).replaceAll(\"//\", \"/\")\n+            .substring(1);\n+    Assert.assertEquals(mockWriter.calledRequest.getURI().toString(), expectedUrl);\n+    mockWriter.close();\n+  }\n+\n+  private void clearRoutingDataPath() {\n+    for (String zkRealm : _baseAccessor\n+        .getChildNames(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, AccessOption.PERSISTENT)) {\n+      _baseAccessor.remove(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm,\n+          AccessOption.PERSISTENT);", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2ODI2OA==", "url": "https://github.com/apache/helix/pull/844#discussion_r386768268", "bodyText": "We shouldn't remove the TestHelper block. Could we add that back? In general, please try to add a verify() block after cleanup.", "author": "narendly", "createdAt": "2020-03-03T02:35:02Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/MetadataStoreDirectoryAccessorTestBase.java", "diffHunk": "@@ -100,23 +100,19 @@ public void beforeClass() throws Exception {\n   @AfterClass\n   public void afterClass() throws Exception {\n     System.clearProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    _routingDataReader.close();\n     deleteRoutingDataPath();\n   }\n \n-  protected void deleteRoutingDataPath() throws Exception {\n-    Assert.assertTrue(TestHelper.verify(() -> {\n-      _zkList.forEach(zk -> ZK_SERVER_MAP.get(zk).getZkClient()\n-          .deleteRecursively(MetadataStoreRoutingConstants.ROUTING_DATA_PATH));\n-\n-      for (String zk : _zkList) {\n-        if (ZK_SERVER_MAP.get(zk).getZkClient()\n-            .exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n-          return false;\n+  protected void deleteRoutingDataPath() {\n+    for (String zk : _zkList) {\n+      ZkClient zkClient = ZK_SERVER_MAP.get(zk).getZkClient();\n+      if (zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+        for (String zkRealm : zkClient.getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+          zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm);", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMjU0Mg==", "url": "https://github.com/apache/helix/pull/844#discussion_r387202542", "bodyText": "Very good point. I'll try to add the same block to all similar clean ups.", "author": "NealSun96", "createdAt": "2020-03-03T18:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2ODI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2ODQ5NQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r386768495", "bodyText": "Please create a constant OBJECT_MAPPER and use it throughout.", "author": "narendly", "createdAt": "2020-03-03T02:35:51Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -452,6 +454,43 @@ public void testDeleteShardingKey() throws InvalidRoutingDataException {\n     Assert.assertEquals(getAllShardingKeysInTestRealm1(), expectedShardingKeysSet);\n   }\n \n+  @Test(dependsOnMethods = \"testDeleteShardingKey\")\n+  public void testSetRoutingData() throws InvalidRoutingDataException, IOException {\n+    Map<String, List<String>> routingData = new HashMap<>();\n+    routingData.put(TEST_REALM_1, TEST_SHARDING_KEYS_2);\n+    routingData.put(TEST_REALM_2, TEST_SHARDING_KEYS_1);\n+    String routingDataString = new ObjectMapper().writeValueAsString(routingData);\n+\n+    Map<String, String> badFormatRoutingData = new HashMap<>();\n+    badFormatRoutingData.put(TEST_REALM_1, TEST_REALM_2);\n+    badFormatRoutingData.put(TEST_REALM_2, TEST_REALM_1);\n+    String badFormatRoutingDataString = new ObjectMapper().writeValueAsString(badFormatRoutingData);", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzMjQ2MA==", "url": "https://github.com/apache/helix/pull/844#discussion_r387232460", "bodyText": "Reusing the inherited OBJECT_MAPPER. Applies to many other files as well.", "author": "NealSun96", "createdAt": "2020-03-03T19:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2ODQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2ODY4Mw==", "url": "https://github.com/apache/helix/pull/844#discussion_r386768683", "bodyText": "Question: we still want to throw an exception when the data is empty, right?", "author": "narendly", "createdAt": "2020-03-03T02:36:35Z", "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/datamodel/TrieRoutingData.java", "diffHunk": "@@ -167,8 +167,8 @@ private TrieNode getLongestPrefixNodeAlongPath(String path) {\n   }\n \n   /*\n-   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n-   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter.\n+   * When this is the case, the trie is valid and contains only one node, which", "originalCommit": "2a46bd3975f47b6f1d094a0fc763f69e1e1ee819", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzMzMyOQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r387233329", "bodyText": "The comment change here was regarding to the sharding key being either \"/\" or \"\", not routing data being empty. I believe your question is about when the entire routing data is empty: the answer is yes, we throw an exception. That behavior, as we agreed on, will not be changed.", "author": "NealSun96", "createdAt": "2020-03-03T19:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2ODY4Mw=="}], "type": "inlineReview"}, {"oid": "7ccecb57571c93a45c8b854f43577f5d30209789", "url": "https://github.com/apache/helix/commit/7ccecb57571c93a45c8b854f43577f5d30209789", "message": "address comments", "committedDate": "2020-03-03T19:16:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NDEyMA==", "url": "https://github.com/apache/helix/pull/844#discussion_r387274120", "bodyText": "Do we need to log the exception here? Otherwise you'd be failing silently.", "author": "narendly", "createdAt": "2020-03-03T20:27:12Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -209,8 +215,20 @@ public synchronized boolean setRoutingData(Map<String, List<String>> routingData\n       return true;\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + constructUrlSuffix(\n+        MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+    HttpPut httpPut = new HttpPut(url);\n+    String routingDataJsonString;\n+    try {\n+      routingDataJsonString = OBJECT_MAPPER.writeValueAsString(routingData);\n+    } catch (JsonGenerationException | JsonMappingException e) {\n+      throw new IllegalArgumentException(e.getMessage());\n+    } catch (IOException e) {\n+      return false;\n+    }", "originalCommit": "7ccecb57571c93a45c8b854f43577f5d30209789", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxOTk2NA==", "url": "https://github.com/apache/helix/pull/844#discussion_r387319964", "bodyText": "Sure. This block should technically never have a problem though. I'll add a log.", "author": "NealSun96", "createdAt": "2020-03-03T22:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NDEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NDYyMg==", "url": "https://github.com/apache/helix/pull/844#discussion_r387274622", "bodyText": "I think it would be better to throw an exception here because this is not supposed to happen.", "author": "narendly", "createdAt": "2020-03-03T20:28:13Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -332,20 +350,21 @@ private String constructUrlSuffix(String... urlParams) {\n     return String.join(\"\", allUrlParameters);\n   }\n \n-  private boolean forwardRequestToLeader(String urlSuffix, HttpConstants.RestVerbs request_method,\n-      int expectedResponseCode) throws IllegalArgumentException {\n+  private boolean buildAndSendRequestToLeader(String urlSuffix,\n+      HttpConstants.RestVerbs requestMethod, int expectedResponseCode)\n+      throws IllegalArgumentException {\n     String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n     String url = leaderHostName + urlSuffix;\n     HttpUriRequest request;\n-    switch (request_method) {\n+    switch (requestMethod) {\n       case PUT:\n         request = new HttpPut(url);\n         break;\n       case DELETE:\n         request = new HttpDelete(url);\n         break;\n       default:\n-        LOG.error(\"Unsupported request_method: \" + request_method.name());\n+        LOG.error(\"Unsupported requestMethod: \" + requestMethod.name());", "originalCommit": "7ccecb57571c93a45c8b854f43577f5d30209789", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMzM3Nw==", "url": "https://github.com/apache/helix/pull/844#discussion_r387323377", "bodyText": "This is a strange one because it can only go to default because of developer oversights.\nIf some code using the wrong http verb does make it to production, and clients are calling the endpoints with the incorrect code, we definitely want to report 500 to clients (return false) instead of 400 (IllegalArgumentException).\nI'll change it to exception because return false isn't informative enough to developers, but I wish there's a way to limit the values of a parameter.", "author": "NealSun96", "createdAt": "2020-03-03T22:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NDYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NTkyOA==", "url": "https://github.com/apache/helix/pull/844#discussion_r387275928", "bodyText": "Could we add a retry logic on false?", "author": "narendly", "createdAt": "2020-03-03T20:30:52Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/TestZkMetadataStoreDirectory.java", "diffHunk": "@@ -277,4 +315,27 @@ public void testChildChangeCallback() throws Exception {\n       return false;\n     }, TestHelper.WAIT_DURATION));\n   }\n+\n+  private void clearRoutingData() throws Exception {\n+    Assert.assertTrue(TestHelper.verify(() -> {\n+      for (String zk : _zkList) {", "originalCommit": "7ccecb57571c93a45c8b854f43577f5d30209789", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNzkwMg==", "url": "https://github.com/apache/helix/pull/844#discussion_r387317902", "bodyText": "verify() already retries, right?", "author": "NealSun96", "createdAt": "2020-03-03T21:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyNDIwOA==", "url": "https://github.com/apache/helix/pull/844#discussion_r387324208", "bodyText": "For your convenience:\n  public static boolean verify(Verifier verifier, long timeout) throws Exception {\n    long start = System.currentTimeMillis();\n    do {\n      boolean result = verifier.verify();\n      if (result || (System.currentTimeMillis() - start) > timeout) {\n        return result;\n      }\n      Thread.sleep(50);\n    } while (true);\n  }", "author": "NealSun96", "createdAt": "2020-03-03T22:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM1NDYxMA==", "url": "https://github.com/apache/helix/pull/844#discussion_r387354610", "bodyText": "\ud83d\udc4d", "author": "narendly", "createdAt": "2020-03-03T23:22:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NzAxMQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r387277011", "bodyText": "Need a retry while block", "author": "narendly", "createdAt": "2020-03-03T20:33:05Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataReader.java", "diffHunk": "@@ -130,17 +123,14 @@ public void testGetRoutingDataMSRDChildEmptyValue() {\n     }\n   }\n \n-  private void deleteRoutingDataPath() throws Exception {\n+  private void clearRoutingDataPath() throws Exception {\n     Assert.assertTrue(TestHelper.verify(() -> {\n-      ZK_SERVER_MAP.get(ZK_ADDR).getZkClient()\n-          .deleteRecursively(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n-\n-      if (ZK_SERVER_MAP.get(ZK_ADDR).getZkClient()\n-          .exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n-        return false;\n+      for (String zkRealm : _zkClient\n+          .getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+        _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm);", "originalCommit": "7ccecb57571c93a45c8b854f43577f5d30209789", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNzk3OQ==", "url": "https://github.com/apache/helix/pull/844#discussion_r387317979", "bodyText": "Ditto above.", "author": "NealSun96", "createdAt": "2020-03-03T21:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NzAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM1NDY1Ng==", "url": "https://github.com/apache/helix/pull/844#discussion_r387354656", "bodyText": "\ud83d\udc4d", "author": "narendly", "createdAt": "2020-03-03T23:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3NzAxMQ=="}], "type": "inlineReview"}, {"oid": "21c900f8d8ab1a543c9d83de6f766c16c4fda5de", "url": "https://github.com/apache/helix/commit/21c900f8d8ab1a543c9d83de6f766c16c4fda5de", "message": "address comments", "committedDate": "2020-03-03T22:14:38Z", "type": "commit"}]}