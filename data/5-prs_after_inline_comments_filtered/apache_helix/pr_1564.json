{"pr_number": 1564, "pr_title": "Implement Helix lock priority and notification", "pr_createdAt": "2020-11-30T17:22:04Z", "pr_url": "https://github.com/apache/helix/pull/1564", "timeline": [{"oid": "7cce68c3817e0e46feca3d34f0b09bbb8480b946", "url": "https://github.com/apache/helix/commit/7cce68c3817e0e46feca3d34f0b09bbb8480b946", "message": "Implement lock priority and notification", "committedDate": "2020-11-30T19:53:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1ODU2Mg==", "url": "https://github.com/apache/helix/pull/1564#discussion_r533658562", "bodyText": "Shall we have a LockConstant class to hold them? Seemed they are too many in same class with logic code.", "author": "junkaixue", "createdAt": "2020-12-01T19:14:45Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -30,13 +30,23 @@\n   // Default values for each attribute if there are no current values set by user\n   public static final String DEFAULT_OWNER_TEXT = \"\";\n   public static final String DEFAULT_MESSAGE_TEXT = \"\";\n-  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+  public static final long DEFAULT_TIMEOUT_LONG = -1;\n+  public static final int DEFAULT_PRIORITY_INT = -1;\n+  public static final long DEFAULT_WAITING_TIMEOUT_LONG = -1;\n+  public static final long DEFAULT_CLEANUP_TIMEOUT_LONG = -1;\n+  public static final String DEFAULT_REQUESTOR_ID = \"\";\n+  public static final int DEFAULT_REQUESTOR_PRIORITY_INT = -1;\n+  public static final long DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG = -1;\n+  public static final long DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG = -1;", "originalCommit": "7cce68c3817e0e46feca3d34f0b09bbb8480b946", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MjQxMA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r533672410", "bodyText": "Good suggestion! Will do.", "author": "zhangmeng916", "createdAt": "2020-12-01T19:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1ODU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTk2Nw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r533659967", "bodyText": "Usually, if we are waiting for something, we should use while to do the checks here.", "author": "junkaixue", "createdAt": "2020-12-01T19:17:12Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,162 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.DEFAULT_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_ID;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {", "originalCommit": "7cce68c3817e0e46feca3d34f0b09bbb8480b946", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MjQwMQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r533672401", "bodyText": "This boolean variable is used as a flag to distinguish between different scenarios so that we can act differently. The actual functioning part is the following wait().", "author": "zhangmeng916", "createdAt": "2020-12-01T19:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxNDc1NQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534414755", "bodyText": "The reason to put wait in the while loop is to prevent if anyone else updates the content after the notification and before the current thread regains the lock. I think what Junkai said is a valid comment.", "author": "jiajunwang", "createdAt": "2020-12-02T19:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU5OTM0NQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534599345", "bodyText": "If there's another user (whose priority is even higher) acquired the lock, the onDeniedPendingLockNotification will be called, which will terminate the wait. We won't need to worry about this, right?", "author": "zhangmeng916", "createdAt": "2020-12-03T01:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMjQ0Nw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535732447", "bodyText": "Java actually has spurious wake up. If you dont have while, then you may not wait until timeout reaches and failed to acquire the lock. That's the reason of using while.", "author": "junkaixue", "createdAt": "2020-12-03T23:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNDgzNw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r536524837", "bodyText": "I see your point. So here we cannot use while because pending is not the only checking condition. We also have timeout, which can terminate the wait. We cannot easily distinguish between spurious wake up and timeout. Using a timer is not accurate. I changed to use countdown latch, which is more convenient and doesn't have spurious wake up issue.", "author": "zhangmeng916", "createdAt": "2020-12-05T06:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MDU5NQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r533660595", "bodyText": "Are we just waiting until timeout and do a check? Shall we periodically wake up and check whether the lock has been released or not?", "author": "junkaixue", "createdAt": "2020-12-01T19:18:21Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,162 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.DEFAULT_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_ID;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {\n+      try {\n+        wait(_pendingTimeout);", "originalCommit": "7cce68c3817e0e46feca3d34f0b09bbb8480b946", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MjM4Nw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r533672387", "bodyText": "This wait() will be signaled by the following notify(), or if it never receives the notify, it'll wait until timeout.\npublic void onAcquiredLockNotification() {\nsynchronized (ZKDistributedNonblockingLock.this) {\n_isLocked = true;\nZKDistributedNonblockingLock.this.notify();\n}\n}", "author": "zhangmeng916", "createdAt": "2020-12-01T19:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MDU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MTQ5Mg==", "url": "https://github.com/apache/helix/pull/1564#discussion_r533661492", "bodyText": "Can we leverage this handleDataChange to notify the waiting thread? Then we can use some Java internal lock.", "author": "junkaixue", "createdAt": "2020-12-01T19:19:50Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +218,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {", "originalCommit": "7cce68c3817e0e46feca3d34f0b09bbb8480b946", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3Mjg3NA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r533672874", "bodyText": "Yeah, we are using this one to trigger a onAcquiredLockNotification callback, which will notify the waiting thread.", "author": "zhangmeng916", "createdAt": "2020-12-01T19:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MTQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5NzM0MQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534397341", "bodyText": "Should be new LockInfo(); ?", "author": "jiajunwang", "createdAt": "2020-12-02T18:41:18Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,24 +19,24 @@\n  * under the License.\n  */\n \n+import org.apache.helix.lock.helix.LockConstants;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n \n \n /**\n  * Structure represents a lock node information, implemented using ZNRecord\n  */\n public class LockInfo {\n-\n-  // Default values for each attribute if there are no current values set by user\n-  public static final String DEFAULT_OWNER_TEXT = \"\";\n-  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n-  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n-\n   // default lock info represents the status of a unlocked lock\n   public static final LockInfo defaultLockInfo =\n-      new LockInfo(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n-\n-  private static final String ZNODE_ID = \"LOCK\";\n+      new LockInfo(LockConstants.DEFAULT_OWNER_TEXT, LockConstants.DEFAULT_MESSAGE_TEXT,", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0NzgzOA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534547838", "bodyText": "Yeah, you're right. I was following previous pattern.", "author": "zhangmeng916", "createdAt": "2020-12-02T23:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5NzM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5ODM3Mw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534398373", "bodyText": "nit, since you will go through the whole list anyway here, the \"this()\" call is not necessary.\nThe current code will set all the fields twice, which is not necessary at all.", "author": "jiajunwang", "createdAt": "2020-12-02T18:43:01Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -65,34 +77,70 @@ public LockInfo(ZNRecord znRecord) {\n     if (znRecord != null) {\n       String ownerId = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n       String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n-      long timeout = znRecord.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n-      setLockInfoFields(ownerId, message, timeout);\n+      long timeout = znRecord", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU2OTQ3OQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534569479", "bodyText": "This one is actually a bit tricky, the znRecord could be null when there is no lock, and we need to call the private constructor to set the default value. So this() has to be there.", "author": "zhangmeng916", "createdAt": "2020-12-03T00:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5ODM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MDA4OA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r538940088", "bodyText": "It would still be cleaner to just do a simple check instead of initializing the values 2 times.\nFor instance,\nif (znRecord == null) {\nznRecord = new znRecord();\n}\n...\nThen the default value will for sure be set in the same way since this record is empty.", "author": "jiajunwang", "createdAt": "2020-12-09T01:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5ODM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5ODg1OA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534398858", "bodyText": "this() means set all fields 2 times.\nIt could be as simple as \"_record = new ZNRecord(ZNODE_ID);\"", "author": "jiajunwang", "createdAt": "2020-12-02T18:43:52Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -65,34 +77,70 @@ public LockInfo(ZNRecord znRecord) {\n     if (znRecord != null) {\n       String ownerId = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n       String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n-      long timeout = znRecord.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n-      setLockInfoFields(ownerId, message, timeout);\n+      long timeout = znRecord\n+          .getLongField(LockInfoAttribute.TIMEOUT.name(), LockConstants.DEFAULT_TIMEOUT_LONG);\n+      int priority = znRecord\n+          .getIntField(LockInfoAttribute.PRIORITY.name(), LockConstants.DEFAULT_PRIORITY_INT);\n+      long waitingTimeout = znRecord.getLongField(LockInfoAttribute.WAITING_TIMEOUT.name(),\n+          LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+      long cleanupTimeout = znRecord.getLongField(LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+          LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+      String requestorId = znRecord.getSimpleField(LockInfoAttribute.REQUESTOR_ID.name());\n+      int requestorPriority = znRecord.getIntField(LockInfoAttribute.REQUESTOR_PRIORITY.name(),\n+          LockConstants.DEFAULT_REQUESTOR_PRIORITY_INT);\n+      long requestorWaitingTimeout = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTOR_WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG);\n+      long requestorRequestingTimestamp = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTOR_REQUESTING_TIMESTAMP.name(),\n+              LockConstants.DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG);\n+      setLockInfoFields(ownerId, message, timeout, priority, waitingTimeout, cleanupTimeout,\n+          requestorId, requestorPriority, requestorWaitingTimeout, requestorRequestingTimestamp);\n     }\n   }\n \n   /**\n-   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data.\n    * @param ownerId value of OWNER attribute\n    * @param message value of MESSAGE attribute\n    * @param timeout value of TIMEOUT attribute\n+   * @param priority value of PRIORITY attribute\n+   * @param waitingTimout value of WAITING_TIMEOUT attribute\n+   * @param cleanupTimeout value of CLEANUP_TIMEOUT attribute\n+   * @param requestorId value of REQUESTOR_ID attribute\n+   * @param requestorPriority value of REQUESTOR_PRIORITY attribute\n+   * @param requestorWaitingTimeout value of REQUESTOR_WAITING_TIMEOUT attribute\n+   * @param requestorRequestingTimestamp value of REQUESTOR_REQUESTING_TIMESTAMP attribute\n    */\n-  public LockInfo(String ownerId, String message, long timeout) {\n+  public LockInfo(String ownerId, String message, long timeout, int priority, long waitingTimout,\n+      long cleanupTimeout, String requestorId, int requestorPriority, long requestorWaitingTimeout,\n+      long requestorRequestingTimestamp) {\n     this();", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDEzMQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534400131", "bodyText": "For the lock requestor that is going to enforce the lock, there is no requestor information. So what should they put for the requestor fields?\nI suggest either we change to builder pattern, or we make those parameters optional.", "author": "jiajunwang", "createdAt": "2020-12-02T18:45:49Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -65,34 +77,70 @@ public LockInfo(ZNRecord znRecord) {\n     if (znRecord != null) {\n       String ownerId = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n       String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n-      long timeout = znRecord.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n-      setLockInfoFields(ownerId, message, timeout);\n+      long timeout = znRecord\n+          .getLongField(LockInfoAttribute.TIMEOUT.name(), LockConstants.DEFAULT_TIMEOUT_LONG);\n+      int priority = znRecord\n+          .getIntField(LockInfoAttribute.PRIORITY.name(), LockConstants.DEFAULT_PRIORITY_INT);\n+      long waitingTimeout = znRecord.getLongField(LockInfoAttribute.WAITING_TIMEOUT.name(),\n+          LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+      long cleanupTimeout = znRecord.getLongField(LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+          LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+      String requestorId = znRecord.getSimpleField(LockInfoAttribute.REQUESTOR_ID.name());\n+      int requestorPriority = znRecord.getIntField(LockInfoAttribute.REQUESTOR_PRIORITY.name(),\n+          LockConstants.DEFAULT_REQUESTOR_PRIORITY_INT);\n+      long requestorWaitingTimeout = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTOR_WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG);\n+      long requestorRequestingTimestamp = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTOR_REQUESTING_TIMESTAMP.name(),\n+              LockConstants.DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG);\n+      setLockInfoFields(ownerId, message, timeout, priority, waitingTimeout, cleanupTimeout,\n+          requestorId, requestorPriority, requestorWaitingTimeout, requestorRequestingTimestamp);\n     }\n   }\n \n   /**\n-   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data.\n    * @param ownerId value of OWNER attribute\n    * @param message value of MESSAGE attribute\n    * @param timeout value of TIMEOUT attribute\n+   * @param priority value of PRIORITY attribute\n+   * @param waitingTimout value of WAITING_TIMEOUT attribute\n+   * @param cleanupTimeout value of CLEANUP_TIMEOUT attribute\n+   * @param requestorId value of REQUESTOR_ID attribute\n+   * @param requestorPriority value of REQUESTOR_PRIORITY attribute\n+   * @param requestorWaitingTimeout value of REQUESTOR_WAITING_TIMEOUT attribute\n+   * @param requestorRequestingTimestamp value of REQUESTOR_REQUESTING_TIMESTAMP attribute\n    */\n-  public LockInfo(String ownerId, String message, long timeout) {\n+  public LockInfo(String ownerId, String message, long timeout, int priority, long waitingTimout,", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU1MTA1MQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534551051", "bodyText": "When issuing an acquire lock request, client always put their own ID in owner field, and the requestor field is null. If later Helix finds there is already an owner, it'll put the new request into requestor field in case the priority is higher. This is true no matter whether it is a forceful lock or not. Forceful only means if the cleanup work of lower priority lock is not finished during timeout, whether the higher priority forcefully grab the lock.", "author": "zhangmeng916", "createdAt": "2020-12-02T23:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MTc0Nw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r538941747", "bodyText": "I understand logic-wise, the API will always work. But the question is that API is not easy for the users to use. It requires much knowledge and there are invisible dependencies here and there.\nA clean API should be either one of the following cases,\n\nNo matter how the parameters look like, ALL of them works in an intuitive way.\nIf the parameters are not valid, then throw an exception to reject the call.", "author": "jiajunwang", "createdAt": "2020-12-09T01:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwMjk3Nw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539002977", "bodyText": "All the new input parameters added this time are optional. I added a new validation function to throw exception if required field is missing or invalid value is given.", "author": "zhangmeng916", "createdAt": "2020-12-09T04:47:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNDg2MA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539034860", "bodyText": "Sounds good \ud83d\udc4c", "author": "jiajunwang", "createdAt": "2020-12-09T06:07:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NjUxMQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539046511", "bodyText": "I actually added the validation logic in ZKDistributedNonblockingLock in the constructor. Did you suggest to add in this file? I feel it's more of a validation of customer's input.", "author": "zhangmeng916", "createdAt": "2020-12-09T06:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMzUyMw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539633523", "bodyText": "np, I saw it later.", "author": "jiajunwang", "createdAt": "2020-12-09T20:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMTcxNQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534401715", "bodyText": "Empty strings are not self-explainable. I suggest using something like \"NONE\", or \"NA\", or \"UNKNOWN\"", "author": "jiajunwang", "createdAt": "2020-12-02T18:48:16Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/LockConstants.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.apache.helix.lock.helix;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+/*\n+ * Default values for each attribute if there are no current values set by user\n+ */\n+public class LockConstants {\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1;\n+  public static final int DEFAULT_PRIORITY_INT = -1;\n+  public static final long DEFAULT_WAITING_TIMEOUT_LONG = -1;\n+  public static final long DEFAULT_CLEANUP_TIMEOUT_LONG = -1;\n+  public static final String DEFAULT_REQUESTOR_ID = \"\";", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNTA2NA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534405064", "bodyText": "If it is an empty callback, why not just pass null? So the lock won't trigger the callback at all.", "author": "jiajunwang", "createdAt": "2020-12-02T18:53:30Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,155 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNzQ5MA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534407490", "bodyText": "Why not refer to the DEFAULT lock values in the constant class?", "author": "jiajunwang", "createdAt": "2020-12-02T18:57:18Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(), \"\");\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(), \"\");\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(), -1);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(), -1);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(), -1);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(), -1);", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwOTgyOQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534409829", "bodyText": "I didn't see when this subscription is removed. Did I miss anything?", "author": "jiajunwang", "createdAt": "2020-12-02T19:00:53Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,155 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n+    }\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU1NTYxNQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534555615", "bodyText": "Updated with unsubscription.", "author": "zhangmeng916", "createdAt": "2020-12-02T23:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwOTgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMzI2NA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534413264", "bodyText": "Not related to this PR directly, but the isCurrentOwner() call inside the LockUpdater.update() triggers one more ZK call which is not necessary since you already have the current ZNRecord input. Please refine that logic.\nThe logic is not only suboptimal but also buggy since the update logic is not purely relying on the input current znode. This potentially fails when some race condition happens.", "author": "jiajunwang", "createdAt": "2020-12-02T19:06:39Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,155 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n+    }\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMzg5OQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534413899", "bodyText": "If update() fails, it throws Exception, right? Shall we try-catch it and return false instead?", "author": "jiajunwang", "createdAt": "2020-12-02T19:07:41Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,155 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n+    }\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU3MTYyMw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534571623", "bodyText": "If you look at doUpdate in ZkbaseDataAccessor, it actually never throws an exception. All exceptions are caught and a boolean value is returned.", "author": "zhangmeng916", "createdAt": "2020-12-03T00:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMzg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxODk1MQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534418951", "bodyText": "Verbose log. debug?", "author": "jiajunwang", "createdAt": "2020-12-02T19:16:11Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMTQyMw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534421423", "bodyText": "The Default ID is \"\" in this version, right? I guess we should check == null || .isEmpty() ?", "author": "jiajunwang", "createdAt": "2020-12-02T19:20:22Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMjY0Mw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534422643", "bodyText": "Not about code, but this means we don't have control on when the cleanup starts.\nWould it be possible that the cleaner lock holder also updates the node so we are sure that cleaning up has been started?", "author": "jiajunwang", "createdAt": "2020-12-02T19:22:27Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU3NDI0OQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534574249", "bodyText": "We don't know when the customers would start to do the cleanup. Do you mean we require them to update Znode during their cleanup callback? I don't think it's recommended to let them directly update Znode, right?", "author": "zhangmeng916", "createdAt": "2020-12-03T00:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMjY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczNDMzNQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535734335", "bodyText": "Are we notifying them or we give them callback and process clean up here?", "author": "junkaixue", "createdAt": "2020-12-03T23:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMjY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg0Mzc0NA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535843744", "bodyText": "Clients need to implement the cleanup callback in their logic. We only trigger the registered listener.", "author": "zhangmeng916", "createdAt": "2020-12-04T05:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMjY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MjY2NA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r538942664", "bodyText": "My proposal is that do the following steps in our code.\n\nupdate znode about the cleanup start time.\ntrigger clean up callbacks.\n\nSo the cleanup start time is a more accurate sign than guessing.\nI'm fine if we just add a TODO here about step 1.", "author": "jiajunwang", "createdAt": "2020-12-09T01:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMjY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwNjk4NA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539006984", "bodyText": "I agree with you that current time calculation is not accurate enough. But even with recording cleanup start time in znode, we still have a problem letting the requestor know the start time and adjust its waiting. Right now, the waiting time is calculated when requestor updates the znode, and cleanup update znode happens after requestor updates znode. How can we adjust the waiting time for requestor in this case?", "author": "zhangmeng916", "createdAt": "2020-12-09T05:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMjY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MTgyMA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539041820", "bodyText": "The proposal is that the waiting time should start once cleanup starts. But that could be too complicated. So let's just add a TODO here. We shall only do this when it is proved to be required.", "author": "jiajunwang", "createdAt": "2020-12-09T06:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMjY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNTAyOA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534425028", "bodyText": "Could you please elaborate on this part? I didn't get the necessity of reading again.\nYou can relies on the updater to check the ownership for you, right? If the owner has been changed in between, then the update fails and that is OK.", "author": "jiajunwang", "createdAt": "2020-12-02T19:26:35Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU5NzE3OQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534597179", "bodyText": "The reason I was doing another read is that I wasn't using lock updater, but use a normal updater. I feel for these callback cases, we should not use lock updater, which is used during first tryLock. The reason is that we usually know what we are doing in the callback updater, and put all these logic inside lock updater will make that logic very complicated and hard to read.\nFor example, in the lock updater, we always assume there is a normal lock request, which has owner ID, etc. However, the cleanup callback updater actually removes the owner ID. Do you think we should combine all scenarios in one updater?", "author": "zhangmeng916", "createdAt": "2020-12-03T01:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNTAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczNTAyMA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535735020", "bodyText": "As discussed, there is still a chance that we hit a race condition here. So I will suggest we check it in the updater.", "author": "jiajunwang", "createdAt": "2020-12-03T23:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNTAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNjM1OA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534426358", "bodyText": "I cannot match it easily with the if condition above, but they look like the same : )", "author": "jiajunwang", "createdAt": "2020-12-02T19:28:46Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(), \"\");\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(), \"\");\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(), -1);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(), -1);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(), -1);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(), -1);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+        } else {\n+          LOG.info(\"We are not current lock owner\");\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU5ODE0Nw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534598147", "bodyText": "The if condition is:\nif (lockInfo.getOwner().equals(_userId))\nBasically we need to distinguish between requestor and owner. Both of them may receive callback, but they don't need to handle unrelated callback.", "author": "zhangmeng916", "createdAt": "2020-12-03T01:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNjM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyODY4MA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534428680", "bodyText": "Same here, I'm concerned about the isCurrentOwner usage inside the update method.", "author": "jiajunwang", "createdAt": "2020-12-02T19:32:40Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +303,88 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner()) {", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMjg0MA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534412840", "bodyText": "Can we avoid the sleep here? Maybe it is better to use TestHelper methods.", "author": "alirezazamani", "createdAt": "2020-12-02T19:05:55Z", "path": "helix-lock/src/test/java/org/apache/helix/lock/helix/TestZKHelixNonblockingLockWithPriority.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestZKHelixNonblockingLockWithPriority extends ZkTestBase {\n+\n+  private final String _clusterName = TestHelper.getTestClassName();\n+  private String _lockPath;\n+  private HelixLockScope _participantScope;\n+  private AtomicBoolean _isCleanupNotified;\n+\n+  private final LockListener _lockListener = new LockListener() {\n+    @Override\n+    public void onCleanupNotification() {\n+      _isCleanupNotified.set(true);\n+      try {\n+        Thread.sleep(20000);\n+      } catch (Exception e) {\n+\n+      }\n+    }\n+  };\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    System.out.println(\"START \" + _clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(_clusterName, ZK_ADDR, 12918, \"localhost\", \"TestDB\", 1, 10, 5, 3,\n+        \"MasterSlave\", true);\n+\n+    List<String> pathKeys = new ArrayList<>();\n+    pathKeys.add(_clusterName);\n+    pathKeys.add(_clusterName);\n+    _participantScope = new HelixLockScope(HelixLockScope.LockScopeProperty.CLUSTER, pathKeys);\n+    _lockPath = _participantScope.getPath();\n+\n+    _isCleanupNotified = new AtomicBoolean(false);\n+  }\n+\n+  @BeforeMethod\n+  public void beforeMethod() {\n+    _gZkClient.delete(_lockPath);\n+    Assert.assertFalse(_gZkClient.exists(_lockPath));\n+  }\n+\n+  @AfterSuite\n+  public void afterSuite() throws IOException {\n+    super.afterSuite();\n+  }\n+\n+  @Test\n+  public void testLowerPriorityRequestRejected() throws Exception {\n+    ZKDistributedNonblockingLock lock =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L, \"original \"\n+            + \"lock\", \"original_lock\", 1, 1000, 25000, false, _lockListener);\n+\n+    ZKDistributedNonblockingLock lowerLock = new ZKDistributedNonblockingLock(_participantScope,\n+        ZK_ADDR, 3600000L,\n+        \"lower priority lock\", \"low_lock\", 0, 1000, 2000, false, createLockListener());\n+\n+    Thread t = new Thread() {\n+      @Override\n+      public void run() {\n+        lock.tryLock();\n+      }\n+    };\n+\n+    t.start();\n+    t.join();\n+    Assert.assertTrue(lock.isCurrentOwner());\n+\n+    LockHelper lockHelper = new LockHelper(lowerLock);\n+    Thread threadLow = new Thread(lockHelper);\n+    threadLow.start();\n+    threadLow.join();\n+    boolean lowResult = lockHelper.getResult();\n+\n+    Assert.assertFalse(_isCleanupNotified.get());\n+    Assert.assertFalse(lowerLock.isCurrentOwner());\n+    Assert.assertFalse(lowResult);\n+    lock.unlock();\n+    lock.close();\n+    lowerLock.close();\n+  }\n+\n+  @Test\n+  public void testHigherPriorityRequestAcquired() throws Exception {\n+    ZKDistributedNonblockingLock lock =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L, \"original \"\n+            + \"lock\", \"original_lock\", 1, 1000, 25000, false, _lockListener);\n+\n+    // The waitingTimeout of higher priority request is larger than cleanup time of current owner\n+    ZKDistributedNonblockingLock higherLock = new ZKDistributedNonblockingLock(_participantScope,\n+        ZK_ADDR, 3600000L,\n+        \"higher priority lock\", \"high_lock\", 2, 30000, 10000, false, createLockListener());\n+\n+    Thread t = new Thread() {\n+      @Override\n+      public void run() {\n+        lock.tryLock();\n+      }\n+    };\n+\n+    t.start();\n+    t.join();\n+    Assert.assertTrue(lock.isCurrentOwner());\n+\n+    LockHelper lockHelper = new LockHelper(higherLock);\n+    Thread t_higher = new Thread(lockHelper);\n+    t_higher.start();\n+    t_higher.join();\n+    boolean higherResult = lockHelper.getResult();\n+\n+    Assert.assertTrue(_isCleanupNotified.get());\n+    Assert.assertTrue(higherLock.isCurrentOwner());\n+    Assert.assertTrue(higherResult);\n+    _isCleanupNotified.set(false);\n+    higherLock.unlock();\n+    higherLock.close();\n+    lock.close();\n+  }\n+\n+  @Test\n+  public void testHigherPriorityRequestFailedAsCleanupHasNotDone() throws Exception {\n+    ZKDistributedNonblockingLock lock =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L, \"original \"\n+            + \"lock\", \"original_lock\", 1, 1000, 25000, false, _lockListener);\n+\n+    // The waitingTimeout of higher priority request is shorter than cleanup time of current\n+    // owner, and the higher priority request is not forceful.\n+    ZKDistributedNonblockingLock higherLock_short =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L,\n+            \"higher priority lock short\", \"high_lock_short\", 2, 2000, 10000, false, createLockListener());\n+\n+    Thread t = new Thread() {\n+      @Override\n+      public void run() {\n+        lock.tryLock();\n+      }\n+    };\n+\n+    t.start();\n+    t.join();\n+    Assert.assertTrue(lock.isCurrentOwner());\n+\n+    LockHelper lockHelper = new LockHelper(higherLock_short);\n+    Thread t_higher = new Thread(lockHelper);\n+\n+    t_higher.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n+      @Override\n+      public void uncaughtException(Thread th, Throwable ex) {\n+        Assert.assertTrue(ex.getMessage().contains(\"Clean up has not finished by lock owner\"));\n+      }\n+    });\n+    t_higher.start();\n+    t_higher.join();\n+    boolean higherResult = lockHelper.getResult();\n+\n+    Assert.assertTrue(_isCleanupNotified.get());\n+    Assert.assertFalse(higherLock_short.isCurrentOwner());\n+    Assert.assertFalse(higherResult);\n+    _isCleanupNotified.set(false);\n+\n+    Assert.assertTrue(lock.unlock());\n+    Assert.assertFalse(lock.isCurrentOwner());\n+    lock.close();\n+    higherLock_short.close();\n+  }\n+\n+  @Test\n+  public void testHigherPriorityRequestForcefulAcquired() throws Exception {\n+    ZKDistributedNonblockingLock lock =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L, \"original \"\n+            + \"lock\", \"original_lock\", 1, 1000, 25000, false, _lockListener);\n+\n+    // The waitingTimeout of higher priority request is shorter than cleanup time of current\n+    // owner, but the higher priority request is forceful.\n+    ZKDistributedNonblockingLock higherLock_force =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L,\n+            \"higher priority lock force\", \"high_lock_force\", 2, 2000, 10000, true,\n+            new LockListener() {\n+              @Override\n+              public void onCleanupNotification() {\n+              }\n+            });\n+\n+    Thread t = new Thread() {\n+      @Override\n+      public void run() {\n+        lock.tryLock();\n+      }\n+    };\n+\n+    t.start();\n+    t.join();\n+    Assert.assertTrue(lock.isCurrentOwner());\n+\n+    LockHelper lockHelper = new LockHelper(higherLock_force);\n+    Thread t_higher = new Thread(lockHelper);\n+\n+    t_higher.start();\n+    t_higher.join();\n+    boolean higherResult = lockHelper.getResult();\n+\n+    boolean res = TestHelper.verify(() -> {\n+      return _isCleanupNotified.get();\n+    }, TestHelper.WAIT_DURATION);\n+    Assert.assertTrue(res);\n+    Assert.assertTrue(higherLock_force.isCurrentOwner());\n+    Assert.assertTrue(higherResult);\n+    _isCleanupNotified.set(false);\n+\n+    higherLock_force.unlock();\n+    higherLock_force.close();\n+    lock.close();\n+  }\n+\n+  @Test\n+  public void testHigherPriorityRequestPreemptedByAnother() throws Exception {\n+    ZKDistributedNonblockingLock lock =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L, \"original \"\n+            + \"lock\", \"original_lock\", 1, 1000, 25000, false, _lockListener);\n+\n+    ZKDistributedNonblockingLock higherLock = new ZKDistributedNonblockingLock(_participantScope,\n+        ZK_ADDR, 3600000L,\n+        \"higher priority lock\", \"high_lock\", 2, 30000, 10000, false, createLockListener());\n+\n+    ZKDistributedNonblockingLock highestLock = new ZKDistributedNonblockingLock(_participantScope\n+        , ZK_ADDR, 3600000L,\n+        \"highest priority lock\", \"highest_lock\", 3, 30000, 20000, false, createLockListener());\n+\n+    Thread t = new Thread() {\n+      @Override\n+      public void run() {\n+        lock.tryLock();\n+      }\n+    };\n+\n+    Thread t_highest = new Thread() {\n+      @Override\n+      public void run() {\n+        highestLock.tryLock();\n+      }\n+    };\n+\n+    t.start();\n+    t.join();\n+    Assert.assertTrue(lock.isCurrentOwner());\n+\n+    LockHelper lockHelper = new LockHelper(higherLock);\n+    Thread t_higher = new Thread(lockHelper);\n+    t_higher.start();\n+    Thread.sleep(1000);", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMzQ3Nw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534413477", "bodyText": "Can this sleep be avoided?", "author": "alirezazamani", "createdAt": "2020-12-02T19:07:02Z", "path": "helix-lock/src/test/java/org/apache/helix/lock/helix/TestZKHelixNonblockingLockWithPriority.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestZKHelixNonblockingLockWithPriority extends ZkTestBase {\n+\n+  private final String _clusterName = TestHelper.getTestClassName();\n+  private String _lockPath;\n+  private HelixLockScope _participantScope;\n+  private AtomicBoolean _isCleanupNotified;\n+\n+  private final LockListener _lockListener = new LockListener() {\n+    @Override\n+    public void onCleanupNotification() {\n+      _isCleanupNotified.set(true);\n+      try {\n+        Thread.sleep(20000);", "originalCommit": "ede0898440288324c6f687de64852f9bb5b28a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0NDAyOA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r534544028", "bodyText": "This sleep is a real sleep. I would like the thread to run for 20 seconds, and then exit. So this should not cause the problem we saw before, right?", "author": "zhangmeng916", "createdAt": "2020-12-02T23:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMzQ3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQzMzA4NQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535433085", "bodyText": "Ok. Makes sense", "author": "alirezazamani", "createdAt": "2020-12-03T17:23:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMzQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMDI1Ng==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535730256", "bodyText": "This else seems to be unnecessary.\nAnd we need to comment that the order there is important and shall not be changed.", "author": "jiajunwang", "createdAt": "2020-12-03T23:48:14Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,157 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        null, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {\n+      try {\n+        wait(_pendingTimeout);\n+      } catch (InterruptedException e) {\n+        throw new HelixException(\n+            String.format(\"Interruption happened while %s is waiting for the \" + \"lock\", _userId),\n+            e);\n+      }\n+      // We have not acquired the lock yet.\n+      if (!_isLocked) {\n+        // If the reason for not being able to acquire the lock is due to high priority lock\n+        // preemption, directly return false.\n+        if (_isPreempted) {\n+          _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n+          return false;\n+        } else {", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMTA3Ng==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535731076", "bodyText": "As discussed, please double check if the logic is complete here since if islocked == false, it will return in any case without checking the updateResult.", "author": "jiajunwang", "createdAt": "2020-12-03T23:50:08Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,157 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        null, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {\n+      try {\n+        wait(_pendingTimeout);\n+      } catch (InterruptedException e) {\n+        throw new HelixException(\n+            String.format(\"Interruption happened while %s is waiting for the \" + \"lock\", _userId),\n+            e);\n+      }\n+      // We have not acquired the lock yet.\n+      if (!_isLocked) {", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg0MDk0Ng==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535840946", "bodyText": "I modified this part of logic to make it simpler.", "author": "zhangmeng916", "createdAt": "2020-12-04T05:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMTA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMTU2MA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535731560", "bodyText": "Here we have isLocked == true and updateResult == false, is it possible?", "author": "jiajunwang", "createdAt": "2020-12-03T23:51:11Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,157 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        null, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {\n+      try {\n+        wait(_pendingTimeout);\n+      } catch (InterruptedException e) {\n+        throw new HelixException(\n+            String.format(\"Interruption happened while %s is waiting for the \" + \"lock\", _userId),\n+            e);\n+      }\n+      // We have not acquired the lock yet.\n+      if (!_isLocked) {\n+        // If the reason for not being able to acquire the lock is due to high priority lock\n+        // preemption, directly return false.\n+        if (_isPreempted) {\n+          _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n+          return false;\n+        } else {\n+          // Forceful lock request will grab the lock even the current owner has not finished\n+          // cleanup work, while non forceful lock request will get an exception.\n+          if (_isForceful) {\n+            ZNRecord znRecord = composeNewOwnerRecord();\n+            LOG.info(\"Updating Zookeeper with new owner {} information\", _userId);\n+            _baseDataAccessor\n+                .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+            return true;\n+          } else {\n+            _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n+            throw new HelixException(\"Cleanup has not been finished by lock owner\");\n+          }\n+        }\n+      }\n     }\n-    LockUpdater updater = new LockUpdater(new LockInfo(_userId, _lockMsg, deadline));\n-    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+    if (!updateResult) {", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc4NjkxNQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535786915", "bodyText": "Updated.", "author": "zhangmeng916", "createdAt": "2020-12-04T02:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMTU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMjIxNw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535732217", "bodyText": "Can we change to isCurrentOwner(...)", "author": "jiajunwang", "createdAt": "2020-12-03T23:52:42Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczODI2Nw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535738267", "bodyText": "I think _isPending would be better to be updated here.", "author": "jiajunwang", "createdAt": "2020-12-04T00:07:49Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\")|| lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(),\n+              LockConstants.DEFAULT_OWNER_TEXT);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+              LockConstants.DEFAULT_MESSAGE_TEXT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+              LockConstants.DEFAULT_TIMEOUT_LONG);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+              LockConstants.DEFAULT_PRIORITY_INT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+              LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+        } else {\n+          LOG.info(\"We are not current lock owner\");\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {\n+      // In case the owner field is empty, it means previous owner has finished cleanup work.\n+      if (lockInfo.getOwner().equals(\"NONE\")) {\n+        ZNRecord znRecord = composeNewOwnerRecord();\n+        LockUpdater updater = new LockUpdater(new LockInfo(znRecord));\n+        _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+        onAcquiredLockNotification();\n+      } else {\n+        LOG.info(\"We do not need to handle this data change\");\n+      }\n+    } // If we are waiting for the lock, but find we are not the requestor any more, meaning we\n+    // are preempted by an even higher priority request\n+    else if (!lockInfo.getRequestorId().equals(\"NONE\") && !lockInfo.getRequestorId().equals(_userId)\n+        && _isPending) {\n+      onDeniedPendingLockNotification();\n+    }\n+  }\n+\n+  /**\n+   * call back called when the lock is acquired\n+   */\n+  public void onAcquiredLockNotification() {\n+    synchronized (ZKDistributedNonblockingLock.this) {\n+      _isLocked = true;", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg0MzIzMA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535843230", "bodyText": "Please see the comments below. Here the status should be LOCKED.", "author": "zhangmeng916", "createdAt": "2020-12-04T05:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczODI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0Mjk4Ng==", "url": "https://github.com/apache/helix/pull/1564#discussion_r538942986", "bodyText": "Yeah, so _isPending should be false.", "author": "jiajunwang", "createdAt": "2020-12-09T01:49:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczODI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0Mzk1OA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r538943958", "bodyText": "But anyway this should be resolved when you change to use enum instead of booleans, right?", "author": "jiajunwang", "createdAt": "2020-12-09T01:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczODI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwMzcyNw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539003727", "bodyText": "Yeah, it's already changed to an enum. Please see the updated code.", "author": "zhangmeng916", "createdAt": "2020-12-09T04:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczODI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczODY1MQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535738651", "bodyText": "Looks like a lock can only be in one state at a time. I suggest merging these 2 booleans into an enum for the cleanness of the code and the logic.", "author": "jiajunwang", "createdAt": "2020-12-04T00:08:59Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\")|| lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(),\n+              LockConstants.DEFAULT_OWNER_TEXT);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+              LockConstants.DEFAULT_MESSAGE_TEXT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+              LockConstants.DEFAULT_TIMEOUT_LONG);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+              LockConstants.DEFAULT_PRIORITY_INT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+              LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+        } else {\n+          LOG.info(\"We are not current lock owner\");\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {\n+      // In case the owner field is empty, it means previous owner has finished cleanup work.\n+      if (lockInfo.getOwner().equals(\"NONE\")) {\n+        ZNRecord znRecord = composeNewOwnerRecord();\n+        LockUpdater updater = new LockUpdater(new LockInfo(znRecord));\n+        _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+        onAcquiredLockNotification();\n+      } else {\n+        LOG.info(\"We do not need to handle this data change\");\n+      }\n+    } // If we are waiting for the lock, but find we are not the requestor any more, meaning we\n+    // are preempted by an even higher priority request\n+    else if (!lockInfo.getRequestorId().equals(\"NONE\") && !lockInfo.getRequestorId().equals(_userId)\n+        && _isPending) {\n+      onDeniedPendingLockNotification();\n+    }\n+  }\n+\n+  /**\n+   * call back called when the lock is acquired\n+   */\n+  public void onAcquiredLockNotification() {\n+    synchronized (ZKDistributedNonblockingLock.this) {\n+      _isLocked = true;\n+      ZKDistributedNonblockingLock.this.notify();\n+    }\n+  }\n+\n+  /**\n+   * call back called when the pending request is denied due to another higher priority request\n+   */\n+  public void onDeniedPendingLockNotification() {\n+    synchronized (ZKDistributedNonblockingLock.this) {\n+      _isLocked = false;", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MDEzOA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535740138", "bodyText": "As mentioned above, I think this would be better to set in the notification method.", "author": "jiajunwang", "createdAt": "2020-12-04T00:12:43Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +314,91 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n+\n+      // higher priority lock request will preempt current lock owner that is with lower priority\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority() && curLockInfo\n+          .getRequestorId().equals(\"NONE\")) {\n+        // update lock Znode with requestor information\n+        ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+        _isPending = true;", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg0MzExMg==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535843112", "bodyText": "There is no notification that would be received by the requestor before it gets the lock. So we cannot se the pending state for it. The notification it receives is that the previous owner finished the cleanup work and it acquires the lock.", "author": "zhangmeng916", "createdAt": "2020-12-04T05:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MzQzNw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r538943437", "bodyText": "Isn't it receiving notification on preempting?", "author": "jiajunwang", "createdAt": "2020-12-09T01:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwNDM3NA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539004374", "bodyText": "Notification would be received by all listeners. But for requestor, it won't handle its own preempting request. Only owner needs to start cleanup. Requestor only handle data change when owner finishes the cleanup work and remove itself from the owner field.", "author": "zhangmeng916", "createdAt": "2020-12-09T04:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMzIxNA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539633214", "bodyText": "I see. With the enum status instead of booleans, the logic has been clean enough. So I think it is good enough.", "author": "jiajunwang", "createdAt": "2020-12-09T20:43:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MDEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMzY2OA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535733668", "bodyText": "We can just put synchronized (this)", "author": "junkaixue", "createdAt": "2020-12-03T23:56:08Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\")|| lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(),\n+              LockConstants.DEFAULT_OWNER_TEXT);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+              LockConstants.DEFAULT_MESSAGE_TEXT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+              LockConstants.DEFAULT_TIMEOUT_LONG);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+              LockConstants.DEFAULT_PRIORITY_INT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+              LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+        } else {\n+          LOG.info(\"We are not current lock owner\");\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {\n+      // In case the owner field is empty, it means previous owner has finished cleanup work.\n+      if (lockInfo.getOwner().equals(\"NONE\")) {\n+        ZNRecord znRecord = composeNewOwnerRecord();\n+        LockUpdater updater = new LockUpdater(new LockInfo(znRecord));\n+        _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+        onAcquiredLockNotification();\n+      } else {\n+        LOG.info(\"We do not need to handle this data change\");\n+      }\n+    } // If we are waiting for the lock, but find we are not the requestor any more, meaning we\n+    // are preempted by an even higher priority request\n+    else if (!lockInfo.getRequestorId().equals(\"NONE\") && !lockInfo.getRequestorId().equals(_userId)\n+        && _isPending) {\n+      onDeniedPendingLockNotification();\n+    }\n+  }\n+\n+  /**\n+   * call back called when the lock is acquired\n+   */\n+  public void onAcquiredLockNotification() {\n+    synchronized (ZKDistributedNonblockingLock.this) {", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczNTIwOQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535735209", "bodyText": "Can we combine the logic with composeRecordOwner? Let it can pass arguments. Then we can simplify the code. Otherwise, too many places setting the fields.", "author": "junkaixue", "createdAt": "2020-12-03T23:59:56Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\")|| lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(),\n+              LockConstants.DEFAULT_OWNER_TEXT);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+              LockConstants.DEFAULT_MESSAGE_TEXT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+              LockConstants.DEFAULT_TIMEOUT_LONG);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+              LockConstants.DEFAULT_PRIORITY_INT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+              LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg3MTM2MQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535871361", "bodyText": "I should use LockInfo instead of directly setting it in ZNRecord. Updated.", "author": "zhangmeng916", "createdAt": "2020-12-04T06:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczNTIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczOTIzMA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535739230", "bodyText": "The message could be confusing here. We can say the user has failed to acquire the lock.", "author": "junkaixue", "createdAt": "2020-12-04T00:10:32Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +314,91 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n+\n+      // higher priority lock request will preempt current lock owner that is with lower priority\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority() && curLockInfo\n+          .getRequestorId().equals(\"NONE\")) {\n+        // update lock Znode with requestor information\n+        ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+        _isPending = true;\n+        _pendingTimeout = _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                : _waitingTimeout;\n+        return newRecord;\n+      }\n+\n+      // If the requestor field is not empty, and the coming lock request has a even higher\n+      // priority. The new request will replace current requestor field of the lock\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority() && !curLockInfo\n+          .getRequestorId().equals(\"NONE\") && _priority > curLockInfo.getRequestorPriority()) {\n+        ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+        _isPending = true;\n+        long remainingCleanupTime =\n+            curLockInfo.getCleanupTimeout() - (System.currentTimeMillis() - curLockInfo\n+                .getRequestorRequestingTimestamp());\n+        _pendingTimeout =\n+            _waitingTimeout > remainingCleanupTime ? remainingCleanupTime : _waitingTimeout;\n+        return newRecord;\n+      }\n+\n+      // For users who are not the lock owner and the priority is not higher than current lock\n+      // owner, throw an exception. The exception will be caught by data accessor, and return\n+      // false for the update\n       LOG.error(\n           \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n               + \". Lock path: \" + _lockPath);\n+\n       throw new HelixException(\"User is not authorized to perform this operation.\");", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MDE0Ng==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535740146", "bodyText": "This could be a sub branch of previous one since the previous two checks are same. Can we combine them?", "author": "junkaixue", "createdAt": "2020-12-04T00:12:44Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +314,91 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n+\n+      // higher priority lock request will preempt current lock owner that is with lower priority\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority() && curLockInfo\n+          .getRequestorId().equals(\"NONE\")) {\n+        // update lock Znode with requestor information\n+        ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+        _isPending = true;\n+        _pendingTimeout = _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                : _waitingTimeout;\n+        return newRecord;\n+      }\n+\n+      // If the requestor field is not empty, and the coming lock request has a even higher\n+      // priority. The new request will replace current requestor field of the lock\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority() && !curLockInfo\n+          .getRequestorId().equals(\"NONE\") && _priority > curLockInfo.getRequestorPriority()) {", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MTEzNw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535741137", "bodyText": "What if there is no owner at first beginning? Even no ZNode exist?", "author": "junkaixue", "createdAt": "2020-12-04T00:15:19Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +314,91 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc4Njk5MA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535786990", "bodyText": "Yeah, there won't be Znode, and the input value is null.", "author": "zhangmeng916", "createdAt": "2020-12-04T02:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MTEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyNTA0Ng==", "url": "https://github.com/apache/helix/pull/1564#discussion_r537925046", "bodyText": "Sorry. I am asking what if there is no ZNode, will this function breaking? Shall we create one? Because creating could also have race condition happening. How we handle the create fail.", "author": "junkaixue", "createdAt": "2020-12-07T23:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MTEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4MDEwOA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r537980108", "bodyText": "Yeah, it should work. This is the design in MVP, and I think it has been tested by customers.\nThe logic is, if there is no znode existing, we create LockInfo with default value, and take that as current value, update that value with user's requested lock information.", "author": "zhangmeng916", "createdAt": "2020-12-08T02:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MTEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYzMzc3Ng==", "url": "https://github.com/apache/helix/pull/1564#discussion_r538633776", "bodyText": "Also regarding the above question Are we notifying them or we give them callback and process clean up here?\nSeems I cannot directly reply, so just answer here. We provide an interface of cleanup, and clients should implement that cleanup callback.", "author": "zhangmeng916", "createdAt": "2020-12-08T17:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MTEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MTgyMw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535741823", "bodyText": "Do we need to check this _isPending? I think we can notify anyway if it is pending or not pending.", "author": "junkaixue", "createdAt": "2020-12-04T00:17:01Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\")|| lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(),\n+              LockConstants.DEFAULT_OWNER_TEXT);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+              LockConstants.DEFAULT_MESSAGE_TEXT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+              LockConstants.DEFAULT_TIMEOUT_LONG);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+              LockConstants.DEFAULT_PRIORITY_INT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+              LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+        } else {\n+          LOG.info(\"We are not current lock owner\");\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {\n+      // In case the owner field is empty, it means previous owner has finished cleanup work.\n+      if (lockInfo.getOwner().equals(\"NONE\")) {\n+        ZNRecord znRecord = composeNewOwnerRecord();\n+        LockUpdater updater = new LockUpdater(new LockInfo(znRecord));\n+        _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+        onAcquiredLockNotification();\n+      } else {\n+        LOG.info(\"We do not need to handle this data change\");\n+      }\n+    } // If we are waiting for the lock, but find we are not the requestor any more, meaning we\n+    // are preempted by an even higher priority request\n+    else if (!lockInfo.getRequestorId().equals(\"NONE\") && !lockInfo.getRequestorId().equals(_userId)\n+        && _isPending) {", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ5MzcyOQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r536493729", "bodyText": "Actually we need, because this callback can also be received by previous owner (who already cleaned up the ownership), and it should not act since it's not pending.", "author": "zhangmeng916", "createdAt": "2020-12-05T03:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MTgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MjM0OA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535742348", "bodyText": "I would suggest use an enum to represent its current state:\nLOCKED, PENDING, PREEMPTED. Otherwise, three flags can be confusing for mutual usage to present the lock state.", "author": "junkaixue", "createdAt": "2020-12-04T00:18:18Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,157 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1OTEwNA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535859104", "bodyText": "It seems leaseTimeout does not need Long boxing. long is fine?\nAnd, by seeing the list of params, just wow... So many params :)\nCan we encapsulate some of the params into an object, eg. ZkDistributedLockProperties or ZkDistributedLockConfig.", "author": "huizhilu", "createdAt": "2020-12-04T06:08:35Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,157 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        null, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,", "originalCommit": "cbb899dd46b4417ffe93821e1a2953312905a31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NjIxNw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r535866217", "bodyText": "long should be fine, but this is old API. I'm concerned about backward compatibility.\nA wrapping class sounds good. But still, there's backward compatibility concern. I'll see whether I can make it look simpler.", "author": "zhangmeng916", "createdAt": "2020-12-04T06:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1OTEwNA=="}], "type": "inlineReview"}, {"oid": "1013f1bc87e42cc6be9aab2d03ca83713c2098b7", "url": "https://github.com/apache/helix/commit/1013f1bc87e42cc6be9aab2d03ca83713c2098b7", "message": "fix more comments", "committedDate": "2020-12-05T06:49:16Z", "type": "forcePushed"}, {"oid": "8d54c2ec4ac4828ef5e1c0de3007b9b9019ebdce", "url": "https://github.com/apache/helix/commit/8d54c2ec4ac4828ef5e1c0de3007b9b9019ebdce", "message": "fix more comments", "committedDate": "2020-12-06T04:41:39Z", "type": "forcePushed"}, {"oid": "53faea1d8ebfd2a98d7d9e8a7eb52a226f2e32bf", "url": "https://github.com/apache/helix/commit/53faea1d8ebfd2a98d7d9e8a7eb52a226f2e32bf", "message": "fix more comments", "committedDate": "2020-12-06T05:01:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNDU3Mw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539034573", "bodyText": "nit, combine this with line 71, then we can call the constructor directly instead of 2 lines.", "author": "jiajunwang", "createdAt": "2020-12-09T06:07:04Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -45,54 +40,105 @@\n   public enum LockInfoAttribute {\n     OWNER,\n     MESSAGE,\n-    TIMEOUT\n+    TIMEOUT,\n+    PRIORITY,\n+    WAITING_TIMEOUT,\n+    CLEANUP_TIMEOUT,\n+    REQUESTOR_ID,\n+    REQUESTOR_PRIORITY,\n+    REQUESTOR_WAITING_TIMEOUT,\n+    REQUESTING_TIMESTAMP\n   }\n \n   /**\n    * Initialize a default LockInfo instance\n    */\n   private LockInfo() {\n     _record = new ZNRecord(ZNODE_ID);\n-    setLockInfoFields(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+    setLockInfoFields(LockConstants.DEFAULT_USER_ID, LockConstants.DEFAULT_MESSAGE_TEXT,\n+        LockConstants.DEFAULT_TIMEOUT_LONG, LockConstants.DEFAULT_PRIORITY_INT,\n+        LockConstants.DEFAULT_WAITING_TIMEOUT_LONG, LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG,\n+        LockConstants.DEFAULT_USER_ID, LockConstants.DEFAULT_PRIORITY_INT,\n+        LockConstants.DEFAULT_WAITING_TIMEOUT_LONG,\n+        LockConstants.DEFAULT_REQUESTING_TIMESTAMP_LONG);\n   }\n \n   /**\n    * Initialize a LockInfo with a ZNRecord, set all info fields to default data\n    * @param znRecord The ZNRecord contains lock node data that used to initialize the LockInfo\n    */\n   public LockInfo(ZNRecord znRecord) {\n-    this();\n-    if (znRecord != null) {\n-      String ownerId = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n-      String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n-      long timeout = znRecord.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n-      setLockInfoFields(ownerId, message, timeout);\n+    _record = new ZNRecord(ZNODE_ID);\n+    if (znRecord == null) {\n+      znRecord = new ZNRecord(ZNODE_ID);\n     }\n+    String ownerId = znRecord.getSimpleField(LockInfoAttribute.OWNER.name()) == null\n+        ? LockConstants.DEFAULT_USER_ID : znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n+    String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name()) == null\n+        ? LockConstants.DEFAULT_MESSAGE_TEXT\n+        : znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    long timeout =\n+        znRecord.getLongField(LockInfoAttribute.TIMEOUT.name(), LockConstants.DEFAULT_TIMEOUT_LONG);\n+    int priority =\n+        znRecord.getIntField(LockInfoAttribute.PRIORITY.name(), LockConstants.DEFAULT_PRIORITY_INT);\n+      long waitingTimeout = znRecord.getLongField(LockInfoAttribute.WAITING_TIMEOUT.name(),\n+          LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+      long cleanupTimeout = znRecord.getLongField(LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+          LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+      String requestorId = znRecord.getSimpleField(LockInfoAttribute.REQUESTOR_ID.name());\n+      int requestorPriority = znRecord.getIntField(LockInfoAttribute.REQUESTOR_PRIORITY.name(),\n+          LockConstants.DEFAULT_PRIORITY_INT);\n+      long requestorWaitingTimeout = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTOR_WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+      long requestingTimestamp = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTING_TIMESTAMP.name(),\n+              LockConstants.DEFAULT_REQUESTING_TIMESTAMP_LONG);\n+      setLockInfoFields(ownerId, message, timeout, priority, waitingTimeout, cleanupTimeout,", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNTgzNg==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539035836", "bodyText": "nit, please comment on the meaning of these statuses, especially PREEMPTED : )", "author": "jiajunwang", "createdAt": "2020-12-09T06:10:21Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/LockConstants.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.apache.helix.lock.helix;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+/*\n+ * Default values for each attribute if there are no current values set by user\n+ */\n+public class LockConstants {\n+  public static final String DEFAULT_USER_ID = \"NONE\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"NONE\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1;\n+  public static final int DEFAULT_PRIORITY_INT = -1;\n+  public static final long DEFAULT_WAITING_TIMEOUT_LONG = -1;\n+  public static final long DEFAULT_CLEANUP_TIMEOUT_LONG = -1;\n+  public static final long DEFAULT_REQUESTING_TIMESTAMP_LONG = -1;\n+\n+  public enum LockStatus {", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNjY1NA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539036654", "bodyText": "I just noticed that there is zkAddress input. So this is not multi zk supported API, right? Will that be a concern?", "author": "jiajunwang", "createdAt": "2020-12-09T06:12:27Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -32,68 +33,167 @@\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private LockConstants.LockStatus _lockStatus;\n+  private long _pendingTimeout;\n+  private CountDownLatch _countDownLatch = new CountDownLatch(1);\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MDAyNw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539480027", "bodyText": "I believe it does support multi zk. Underlying it calls\n_zkClient = buildRealmAwareZkClientWithDefaultConfigs(\nnew RealmAwareZkClient.RealmAwareZkClientConfig().setZkSerializer(zkSerializer), zkAddress,\nzkClientType);\nIf the zk address is null, it'll use default system property config to build a multi zk client. Right?", "author": "zhangmeng916", "createdAt": "2020-12-09T16:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNjY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzODc3NA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539038774", "bodyText": "nit,\n\nthe \" + \"lock\"\n\nI assume you want to add something in between?", "author": "jiajunwang", "createdAt": "2020-12-09T06:18:22Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -32,68 +33,167 @@\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private LockConstants.LockStatus _lockStatus;\n+  private long _pendingTimeout;\n+  private CountDownLatch _countDownLatch = new CountDownLatch(1);\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false, null,\n+        new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n-   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * Initialize the lock with ZKLockConfig. This is the preferred way to construct the lock.\n+   */\n+  public ZKDistributedNonblockingLock(ZKLockConfig zkLockConfig) {\n+    this(zkLockConfig.getLockScope(), zkLockConfig.getZkAddress(), zkLockConfig.getLeaseTimeout(),\n+        zkLockConfig.getLockMsg(), zkLockConfig.getUserId(), zkLockConfig.getPriority(),\n+        zkLockConfig.getWaitingTimeout(), zkLockConfig.getCleanupTimeout(),\n+        zkLockConfig.getIsForceful(), zkLockConfig.getLockListener());\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, priority,\n+   * different kinds of timeout, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Internal construction of the lock with user provided information, e.g., lock path under\n+   * zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n+    validateInput();\n   }\n \n   @Override\n   public boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Immediately return if the lock statue is not PENDING.\n+    if (_lockStatus != LockConstants.LockStatus.PENDING) {\n+      if (!updateResult) {\n+        _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n+      }\n+      return updateResult;\n     }\n-    LockUpdater updater = new LockUpdater(new LockInfo(_userId, _lockMsg, deadline));\n-    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // When the lock status is still pending, wait for the period recorded in _pendingTimeout.\n+    try {\n+      _countDownLatch.await(_pendingTimeout, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException e) {\n+      throw new HelixException(\n+          String.format(\"Interruption happened while %s is waiting for the \" + \"lock\", _userId), e);", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MjczNA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539042734", "bodyText": "Once we support LOCK node cleanup, then we need to add some logic here, right?\nMaybe some TODO comments would be helpful.", "author": "jiajunwang", "createdAt": "2020-12-09T06:28:25Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,11 +222,72 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (isCurrentOwner(lockInfo)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\") || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        CleanupUpdater cleanupUpdater = new CleanupUpdater();\n+        boolean res = _baseDataAccessor.update(_lockPath, cleanupUpdater, AccessOption.PERSISTENT);\n+        if (!res) {\n+          throw new HelixException(\n+              String.format(\"User %s failed to update lock path %s\", _userId, _lockPath));\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {\n+      // In case the owner field is empty, it means previous owner has finished cleanup work.\n+      if (lockInfo.getOwner().equals(\"NONE\")) {\n+        ZNRecord znRecord = composeNewOwnerRecord();\n+        LockUpdater updater = new LockUpdater(new LockInfo(znRecord));\n+        _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+        onAcquiredLockNotification();\n+      } else {\n+        LOG.info(\"We do not need to handle this data change\");\n+      }\n+    } // If we are waiting for the lock, but find we are not the requestor any more, meaning we\n+    // are preempted by an even higher priority request\n+    else if (!lockInfo.getRequestorId().equals(\"NONE\") && !lockInfo.getRequestorId().equals(_userId)\n+        && _lockStatus == LockConstants.LockStatus.PENDING) {\n+      onDeniedPendingLockNotification();\n+    }\n+  }\n+\n+  /**\n+   * call back called when the lock is acquired\n+   */\n+  public void onAcquiredLockNotification() {\n+    _lockStatus = LockConstants.LockStatus.LOCKED;\n+    _countDownLatch.countDown();\n+  }\n+\n   /**\n-   * Class that specifies how a lock node should be updated with another lock node\n+   * call back called when the pending request is denied due to another higher priority request\n+   */\n+  public void onDeniedPendingLockNotification() {\n+    _lockStatus = LockConstants.LockStatus.PREEMPTED;\n+    _countDownLatch.countDown();\n+  }\n+\n+  @Override\n+  public void handleDataDeleted(String dataPath) throws Exception {\n+  }", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0Mjk1OQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539042959", "bodyText": "Can we avoid hardcode NONE but refer to the default ID?", "author": "jiajunwang", "createdAt": "2020-12-09T06:29:02Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +305,143 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n-      LOG.error(\n-          \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n-              + \". Lock path: \" + _lockPath);\n-      throw new HelixException(\"User is not authorized to perform this operation.\");\n+\n+      // higher priority lock request will try to  preempt current lock owner\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority()) {\n+        if (curLockInfo.getRequestorId().equals(\"NONE\")) {", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NDUyNw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539044527", "bodyText": "There is some duplicate code, can we do this?\nif (curLockInfo.getRequestorId().equals(\"NONE\")) {\n_pendingTimeout = .....\n} else if (_priority > curLockInfo.getRequestorPriority()) {\n_pendingTimeout = ......\n}\nZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\nthrow new HelixException(\"User is not authorized to perform this operation.\");\n_lockStatus = LockConstants.LockStatus.PENDING;\nreturn newRecord;", "author": "jiajunwang", "createdAt": "2020-12-09T06:33:01Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +305,143 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n-      LOG.error(\n-          \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n-              + \". Lock path: \" + _lockPath);\n-      throw new HelixException(\"User is not authorized to perform this operation.\");\n+\n+      // higher priority lock request will try to  preempt current lock owner\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority()) {\n+        if (curLockInfo.getRequestorId().equals(\"NONE\")) {\n+          // update lock Znode with requestor information\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          _pendingTimeout =\n+              _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                  : _waitingTimeout;\n+          return newRecord;\n+        } // If the requestor field is not empty, and the coming lock request has a even higher\n+        // priority. The new request will replace current requestor field of the lock\n+        else if (_priority > curLockInfo.getRequestorPriority()) {\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          long remainingCleanupTime =\n+              curLockInfo.getCleanupTimeout() - (System.currentTimeMillis() - curLockInfo\n+                  .getRequestingTimestamp());\n+          _pendingTimeout = _waitingTimeout > remainingCleanupTime ? remainingCleanupTime :\n+           _waitingTimeout;\n+          return newRecord;\n+        }", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NTUwNQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539045505", "bodyText": "If I just create a new LockInfo(null) object, then I get the same result, right?\nI guess maybe you want to make the LockInfo() constructor public.", "author": "jiajunwang", "createdAt": "2020-12-09T06:35:31Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +305,143 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n-      LOG.error(\n-          \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n-              + \". Lock path: \" + _lockPath);\n-      throw new HelixException(\"User is not authorized to perform this operation.\");\n+\n+      // higher priority lock request will try to  preempt current lock owner\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority()) {\n+        if (curLockInfo.getRequestorId().equals(\"NONE\")) {\n+          // update lock Znode with requestor information\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          _pendingTimeout =\n+              _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                  : _waitingTimeout;\n+          return newRecord;\n+        } // If the requestor field is not empty, and the coming lock request has a even higher\n+        // priority. The new request will replace current requestor field of the lock\n+        else if (_priority > curLockInfo.getRequestorPriority()) {\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          long remainingCleanupTime =\n+              curLockInfo.getCleanupTimeout() - (System.currentTimeMillis() - curLockInfo\n+                  .getRequestingTimestamp());\n+          _pendingTimeout = _waitingTimeout > remainingCleanupTime ? remainingCleanupTime :\n+           _waitingTimeout;\n+          return newRecord;\n+        }\n+      }\n+\n+      // For users who are not the lock owner and the priority is not higher than current lock\n+      // owner, or the priority is higher than current lock, but lower than the requestor, throw\n+      // an exception. The exception will be caught by data accessor, and return false for the\n+      // update operation.\n+      LOG.error(\"User {} failed to acquire lock at Lock path {}.\", _userId, _lockPath);\n+      throw new HelixException(\n+          String.format(\"User %s failed to acquire lock at Lock path %s.\", _userId, _lockPath));\n     }\n   }\n \n+  /**\n+   * Class that specifies how a lock node should be updated after the previous owner finishes the\n+   * cleanup work\n+   */\n+  private class CleanupUpdater implements DataUpdater<ZNRecord> {\n+    public CleanupUpdater() {\n+    }\n+\n+    @Override\n+    public ZNRecord update(ZNRecord current) {\n+      // If we are still the lock owner, clean owner field.\n+      LockInfo curLockInfo = new LockInfo(current);\n+      if (isCurrentOwner(curLockInfo)) {\n+        ZNRecord record = current;", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NTY4OQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539045689", "bodyText": "Or even better, just define a static empty LockInfo object for this usage.", "author": "jiajunwang", "createdAt": "2020-12-09T06:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NTUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4OTIxNQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539489215", "bodyText": "Here we only clean up the owner related fields, but still contain requestor related fields, so that requestor can go ahead to acquire the lock. So we need to get the current lock and update based on that lock, instead of creating a default lock node.", "author": "zhangmeng916", "createdAt": "2020-12-09T17:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NTUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NjYwMQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539046601", "bodyText": "nit,\noldLockInfo => existingLockInfo, and newLockZNRecord => requestorLockZNRecord ?", "author": "jiajunwang", "createdAt": "2020-12-09T06:37:59Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +305,143 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n-      LOG.error(\n-          \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n-              + \". Lock path: \" + _lockPath);\n-      throw new HelixException(\"User is not authorized to perform this operation.\");\n+\n+      // higher priority lock request will try to  preempt current lock owner\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority()) {\n+        if (curLockInfo.getRequestorId().equals(\"NONE\")) {\n+          // update lock Znode with requestor information\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          _pendingTimeout =\n+              _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                  : _waitingTimeout;\n+          return newRecord;\n+        } // If the requestor field is not empty, and the coming lock request has a even higher\n+        // priority. The new request will replace current requestor field of the lock\n+        else if (_priority > curLockInfo.getRequestorPriority()) {\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          long remainingCleanupTime =\n+              curLockInfo.getCleanupTimeout() - (System.currentTimeMillis() - curLockInfo\n+                  .getRequestingTimestamp());\n+          _pendingTimeout = _waitingTimeout > remainingCleanupTime ? remainingCleanupTime :\n+           _waitingTimeout;\n+          return newRecord;\n+        }\n+      }\n+\n+      // For users who are not the lock owner and the priority is not higher than current lock\n+      // owner, or the priority is higher than current lock, but lower than the requestor, throw\n+      // an exception. The exception will be caught by data accessor, and return false for the\n+      // update operation.\n+      LOG.error(\"User {} failed to acquire lock at Lock path {}.\", _userId, _lockPath);\n+      throw new HelixException(\n+          String.format(\"User %s failed to acquire lock at Lock path %s.\", _userId, _lockPath));\n     }\n   }\n \n+  /**\n+   * Class that specifies how a lock node should be updated after the previous owner finishes the\n+   * cleanup work\n+   */\n+  private class CleanupUpdater implements DataUpdater<ZNRecord> {\n+    public CleanupUpdater() {\n+    }\n+\n+    @Override\n+    public ZNRecord update(ZNRecord current) {\n+      // If we are still the lock owner, clean owner field.\n+      LockInfo curLockInfo = new LockInfo(current);\n+      if (isCurrentOwner(curLockInfo)) {\n+        ZNRecord record = current;\n+        record\n+            .setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(), LockConstants.DEFAULT_USER_ID);\n+        record.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+            LockConstants.DEFAULT_MESSAGE_TEXT);\n+        record.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+            LockConstants.DEFAULT_TIMEOUT_LONG);\n+        record.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+            LockConstants.DEFAULT_PRIORITY_INT);\n+        record.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+            LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+        record.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+            LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+        return record;\n+      }\n+      LOG.error(\"User {} is not current lock owner, and does not need to unlock {}\", _userId,\n+          _lockPath);\n+      throw new HelixException(String\n+          .format(\"User %s is not current lock owner, and does not need\" + \" to unlock %s\", _userId,\n+              _lockPath));\n+    }\n+  }\n+\n+  /**\n+   * Class that specifies how a lock node should be updated during a forceful get lock operation\n+   */\n+  private class ForcefulUpdater implements DataUpdater<ZNRecord> {\n+    final ZNRecord _record;\n+\n+    /**\n+     * Initialize a structure for lock user to update a lock node value\n+     * @param lockInfo the lock node value will be used to update the lock\n+     */\n+    public ForcefulUpdater(LockInfo lockInfo) {\n+      _record = lockInfo.getRecord();\n+    }\n+\n+    @Override\n+    public ZNRecord update(ZNRecord current) {\n+      // If we are still the lock requestor, change ourselves to be lock owner.\n+      LockInfo curLockInfo = new LockInfo(current);\n+      if (curLockInfo.getRequestorId().equals(_userId)) {\n+        return _record;\n+      }\n+      LOG.error(\"User {} is not current lock requestor, and cannot forcefully acquire the lock at \"\n+          + \"{}\", _userId, _lockPath);\n+      throw new HelixException(String.format(\"User %s is not current lock requestor, and cannot \"\n+          + \"forcefully acquire the lock at %s\", _userId, _lockPath));\n+    }\n+  }\n+\n+  private ZNRecord composeNewRequestorRecord(LockInfo oldLockInfo, ZNRecord newLockZNRecord) {", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NzI3NA==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539047274", "bodyText": "I do have some concerns about this direct ZkAddress parameter. This won't support multi-zk usage.\nIt might be OK, but the LOCK API will be treated as a special case, I guess.", "author": "jiajunwang", "createdAt": "2020-12-09T06:39:42Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKLockConfig.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package org.apache.helix.lock.helix;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Hold configs used for a ZK distributed nonblocking lock.\n+ */\n+public class ZKLockConfig {\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(org.apache.helix.lock.helix.ZKLockConfig.class.getName());\n+  private LockScope _lockScope;\n+  private String _zkAddress;", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4OTk2Mw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539489963", "bodyText": "Please see the above comment. I feel multi ZK should be implicitly supported. Let me know if that's not the case.", "author": "zhangmeng916", "createdAt": "2020-12-09T17:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NzI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0MDQzNw==", "url": "https://github.com/apache/helix/pull/1564#discussion_r539640437", "bodyText": "I think we want users to use zooscalibility features as far as they can. So shall we hide this constructor? The above one with zkAddress is left because we want to ensure backward compatibility. But this one is newly added. So make it private or get rid of it?", "author": "jiajunwang", "createdAt": "2020-12-09T20:54:49Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -32,68 +33,167 @@\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private LockConstants.LockStatus _lockStatus;\n+  private long _pendingTimeout;\n+  private CountDownLatch _countDownLatch = new CountDownLatch(1);\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false, null,\n+        new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n-   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * Initialize the lock with ZKLockConfig. This is the preferred way to construct the lock.\n+   */\n+  public ZKDistributedNonblockingLock(ZKLockConfig zkLockConfig) {\n+    this(zkLockConfig.getLockScope(), zkLockConfig.getZkAddress(), zkLockConfig.getLeaseTimeout(),\n+        zkLockConfig.getLockMsg(), zkLockConfig.getUserId(), zkLockConfig.getPriority(),\n+        zkLockConfig.getWaitingTimeout(), zkLockConfig.getCleanupTimeout(),\n+        zkLockConfig.getIsForceful(), zkLockConfig.getLockListener());\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, priority,\n+   * different kinds of timeout, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,", "originalCommit": "9e11f56f3bfaad96310f5731afd43fd6c65a7386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MTA5OQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r540571099", "bodyText": "Following lockStatus was protected by latch down. But this check could happening parallel to following lockStatus update. Do we need some synchronization?", "author": "junkaixue", "createdAt": "2020-12-10T23:16:05Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -32,68 +33,167 @@\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private LockConstants.LockStatus _lockStatus;\n+  private long _pendingTimeout;\n+  private CountDownLatch _countDownLatch = new CountDownLatch(1);\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false, null,\n+        new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n-   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * Initialize the lock with ZKLockConfig. This is the preferred way to construct the lock.\n+   */\n+  public ZKDistributedNonblockingLock(ZKLockConfig zkLockConfig) {\n+    this(zkLockConfig.getLockScope(), zkLockConfig.getZkAddress(), zkLockConfig.getLeaseTimeout(),\n+        zkLockConfig.getLockMsg(), zkLockConfig.getUserId(), zkLockConfig.getPriority(),\n+        zkLockConfig.getWaitingTimeout(), zkLockConfig.getCleanupTimeout(),\n+        zkLockConfig.getIsForceful(), zkLockConfig.getLockListener());\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, priority,\n+   * different kinds of timeout, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  private ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Internal construction of the lock with user provided information, e.g., lock path under\n+   * zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n+    validateInput();\n   }\n \n   @Override\n   public boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Immediately return if the lock statue is not PENDING.\n+    if (_lockStatus != LockConstants.LockStatus.PENDING) {", "originalCommit": "81168cfcea02098f8d8a035543dbcfd07de8ce91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYxMzk0OQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r540613949", "bodyText": "If I understand correctly, is the concern regarding the race condition between here and the following part?\npublic void onAcquiredLockNotification() {\n_lockStatus = LockConstants.LockStatus.LOCKED;\n_countDownLatch.countDown();\n}\nIt seems fine. Even the Lock status change and count down happen before await, the await will still exist when timeout, and the lock status is retrieved again after await.\nI tried to leverage synchronized on both parts_lockstatus, but it doesn't work, cause it'll deadlock. Let me know if you still think it's not safe.", "author": "zhangmeng916", "createdAt": "2020-12-11T01:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MTA5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYwNDQ2Ng==", "url": "https://github.com/apache/helix/pull/1564#discussion_r542604466", "bodyText": "Just make sure one thing, this is not shared status between two calls of same path. Then it should be safe for this case.", "author": "junkaixue", "createdAt": "2020-12-14T18:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MTA5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzNDEyNQ==", "url": "https://github.com/apache/helix/pull/1564#discussion_r542634125", "bodyText": "I see your concern. By current logic, it should be safe. If the previous lock was already acquired, subsequent tryLock from the same object will directly acquire the lock. If the previous lock was pending, subsequent tryLock won't check status as they're the same priority.", "author": "zhangmeng916", "createdAt": "2020-12-14T18:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MTA5OQ=="}], "type": "inlineReview"}, {"oid": "e0c1aff3c382e5f12f7b92c52557ac1ca8f3e3d0", "url": "https://github.com/apache/helix/commit/e0c1aff3c382e5f12f7b92c52557ac1ca8f3e3d0", "message": "Implement lock priority and notification", "committedDate": "2020-12-14T20:09:28Z", "type": "commit"}, {"oid": "2387deab9ff591635fab7b386ba1688922591b6f", "url": "https://github.com/apache/helix/commit/2387deab9ff591635fab7b386ba1688922591b6f", "message": "add Lock constants", "committedDate": "2020-12-14T20:09:28Z", "type": "commit"}, {"oid": "7bf3b8119746cf0b7136e1e79a2c11109ea2fcc3", "url": "https://github.com/apache/helix/commit/7bf3b8119746cf0b7136e1e79a2c11109ea2fcc3", "message": "fix comments", "committedDate": "2020-12-14T20:09:28Z", "type": "commit"}, {"oid": "57e932bdb87ccb422a2d592d396cc6aa61f84d2f", "url": "https://github.com/apache/helix/commit/57e932bdb87ccb422a2d592d396cc6aa61f84d2f", "message": "fix more comments", "committedDate": "2020-12-14T20:09:28Z", "type": "commit"}, {"oid": "cfafd44346bbaae65d78bc23addef41b8c1a3444", "url": "https://github.com/apache/helix/commit/cfafd44346bbaae65d78bc23addef41b8c1a3444", "message": "add validation etc", "committedDate": "2020-12-14T20:09:28Z", "type": "commit"}, {"oid": "ae927a3a8f7cf48965fc32f06d81eef54a1e3dba", "url": "https://github.com/apache/helix/commit/ae927a3a8f7cf48965fc32f06d81eef54a1e3dba", "message": "add comments and refactor", "committedDate": "2020-12-14T20:09:28Z", "type": "commit"}, {"oid": "854f48c22869e417367f9d3525c07faa0eead451", "url": "https://github.com/apache/helix/commit/854f48c22869e417367f9d3525c07faa0eead451", "message": "simplify code", "committedDate": "2020-12-14T20:09:28Z", "type": "commit"}, {"oid": "e821424d14e3e269ecd2b7cd4a70819c1a50edf6", "url": "https://github.com/apache/helix/commit/e821424d14e3e269ecd2b7cd4a70819c1a50edf6", "message": "change constructor to private", "committedDate": "2020-12-14T20:09:28Z", "type": "commit"}, {"oid": "e821424d14e3e269ecd2b7cd4a70819c1a50edf6", "url": "https://github.com/apache/helix/commit/e821424d14e3e269ecd2b7cd4a70819c1a50edf6", "message": "change constructor to private", "committedDate": "2020-12-14T20:09:28Z", "type": "forcePushed"}]}