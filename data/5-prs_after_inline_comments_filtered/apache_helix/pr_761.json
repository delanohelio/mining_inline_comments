{"pr_number": 761, "pr_title": "Add REST read endpoints to helix-rest for metadata store directory", "pr_createdAt": "2020-02-14T01:12:56Z", "pr_url": "https://github.com/apache/helix/pull/761", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODAxNw==", "url": "https://github.com/apache/helix/pull/761#discussion_r379208017", "bodyText": "Remove else clause.", "author": "junkaixue", "createdAt": "2020-02-14T01:20:12Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {\n     try {\n-      Collection<String> realms = _metadataStoreDirectory.getAllMetadataStoreRealms(_namespace);\n-\n-      responseMap = new HashMap<>(1);\n-      responseMap.put(MetadataStoreRoutingConstants.METADATA_STORE_REALMS, realms);\n+      if (shardingKey == null) {\n+        Collection<String> realms = _metadataStoreDirectory.getAllMetadataStoreRealms(_namespace);\n+        Map<String, Collection<String>> responseMap =\n+            ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_REALMS, realms);\n+        return JSONRepresentation(responseMap);\n+      } else {", "originalCommit": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODIzNA==", "url": "https://github.com/apache/helix/pull/761#discussion_r379208234", "bodyText": "Shall we define different response object instead of using plain Response.", "author": "junkaixue", "createdAt": "2020-02-14T01:21:05Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {", "originalCommit": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxOTM4NA==", "url": "https://github.com/apache/helix/pull/761#discussion_r379219384", "bodyText": "I've thought about this carefully. As it is necessary, I've defined a POJO class MetadataStoreShardingKey to represent the object mapping. The response will look like:\n{\n\t\"metadataStoreRealms\": [\"realm-0\", \"realm-1\"]\n}\n\nor  single ream with sharding key:\n{\n\t\"shardingKey\": \"/a/b/c\",\n\t\"realm\": \"realm-0\"\n}\n\nI definitely agree that if the response of object is complex (has more fields), we would need POJO classes to represent the responses.\nFor the time being, since the most of the responses are quite simple: a list, I don't think we want to make it complex .  I've tried to make all json responses to have key-value mappings.", "author": "huizhilu", "createdAt": "2020-02-14T02:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQ2NQ==", "url": "https://github.com/apache/helix/pull/761#discussion_r379208465", "bodyText": "This logic is very complex. Can we leverage the default value to simplify the logic?", "author": "junkaixue", "createdAt": "2020-02-14T01:22:02Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -111,41 +132,56 @@ public Response deleteMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n   }\n \n   /**\n-   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n-   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n-   * a realm.\n+   * Gets all sharding keys mapped at paths:\n+   * - \"HTTP GET /sharding-keys\" which returns all sharding keys in a namespace.\n+   * - \"HTTP GET /sharding-keys?realm={realm}\" which returns sharding keys in the realm.\n+   * - \"HTTP GET /sharding-keys?prefix={prefix}\" which returns sharding keys that have the prefix.\n+   * -- JSON response example for this path:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *    }, {\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/e\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/b\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/a\"\n+   *  }]\n+   * }\n+   *\n+   * - \"HTTP GET /sharding-keys?realm={realm}&prefix={prefix}\" which returns sharding keys in the\n+   * realm and that have the prefix.\n    *\n-   * @param realm Query param in endpoint path\n-   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   * @param realm Query param in endpoint path: metadata store realm.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return Json representation for the sharding keys.\n    */\n   @GET\n   @Path(\"/sharding-keys\")\n-  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n-    Map<String, Object> responseMap;\n-    Collection<String> shardingKeys;\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm,\n+      @QueryParam(\"prefix\") String prefix) {\n     try {\n-      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n-      // to get all sharding keys in a namespace.\n-      if (realm == null) {\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeys(_namespace);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS.\n-        responseMap = new HashMap<>(1);\n+      if (realm == null && prefix == null) {\n+        // For endpoint: \"/sharding-keys\" to get all sharding keys in a namespace.\n+        return getAllShardingKeys();\n+      } else if (prefix == null) {\n+        // For endpoint: \"/sharding-keys?realm={realm}\"\n+        return getAllShardingKeysInRealm(realm);\n+      } else if (realm == null) {\n+        // For endpoint: \"/sharding-keys?prefix={prefix}\"\n+        return getAllShardingKeysUnderPath(prefix);\n       } else {\n-        // For endpoint: \"/sharding-keys?realm={realmName}\"\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeysInRealm(_namespace, realm);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS and SINGLE_METADATA_STORE_REALM.\n-        responseMap = new HashMap<>(2);\n-        responseMap.put(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM, realm);\n+        // For endpoint: \"/sharding-keys?realm={realm}&prefix={prefix}\"\n+        return getRealmShardingKeysUnderPath(realm, prefix);", "originalCommit": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxNjg2Mw==", "url": "https://github.com/apache/helix/pull/761#discussion_r379216863", "bodyText": "I've tried to make it as simple as possible. We have 3 different JAVA methods in MetadataDirectory which accept different params. \n  \n    \n      helix/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java\n    \n    \n        Lines 52 to 70\n      in\n      551ed63\n    \n    \n    \n    \n\n        \n          \n             Collection<String> getAllShardingKeys(String namespace); \n        \n\n        \n          \n            \n        \n\n        \n          \n             /** \n        \n\n        \n          \n              * Returns all path-based sharding keys in the given namespace and the realm. \n        \n\n        \n          \n              * @param namespace \n        \n\n        \n          \n              * @param realm \n        \n\n        \n          \n              * @return \n        \n\n        \n          \n              */ \n        \n\n        \n          \n             Collection<String> getAllShardingKeysInRealm(String namespace, String realm); \n        \n\n        \n          \n            \n        \n\n        \n          \n             /** \n        \n\n        \n          \n              * Returns all sharding keys that have the given path as the prefix substring. \n        \n\n        \n          \n              * E.g) Given that there are sharding keys: /a/b/c, /a/b/d, /a/e, \n        \n\n        \n          \n              * getAllShardingKeysUnderPath(namespace, \"/a/b\") returns [\"/a/b/c\": \"realm\", \"/a/b/d\": \"realm]. \n        \n\n        \n          \n              * @param namespace \n        \n\n        \n          \n              * @param path \n        \n\n        \n          \n              * @return \n        \n\n        \n          \n              */ \n        \n\n        \n          \n             Map<String, String> getAllMappingUnderPath(String namespace, String path); \n        \n    \n  \n\n\nSo even we set default values to the query params, we still have to check the values and call the according method.", "author": "huizhilu", "createdAt": "2020-02-14T01:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MzU5OA==", "url": "https://github.com/apache/helix/pull/761#discussion_r379283598", "bodyText": "A new endpoint which is equivalent to GET /sharding-keys?realm={realm}  is added: GET /metadata-store-realms/{realm}/sharding-keys", "author": "huizhilu", "createdAt": "2020-02-14T07:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5NDQxMA==", "url": "https://github.com/apache/helix/pull/761#discussion_r380994410", "bodyText": "There is a good way to simplify the logic here utilizing the default values as @dasahcc has mentioned. If the prefix is not provided, consider assigning \"/\" to the prefix variable and use the same logic as the situation where prefix exists.", "author": "NealSun96", "createdAt": "2020-02-18T23:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1MzY5Nw==", "url": "https://github.com/apache/helix/pull/761#discussion_r381053697", "bodyText": "There is a good way to simplify the logic here utilizing the default values as @dasahcc has mentioned. If the prefix is not provided, consider assigning \"/\" to the prefix variable and use the same logic as the situation where prefix exists.\n\n@NealSun96 I don't think adding \"/\" to the prefix var is a better idea because:\n\nThe Json responses are different for each case here. If you assign \"/\" to a method, the response could have { \"prefix\": \"/\" }\nI've tried to find a good default value for this prefix. If I assign \"/\" as a default value, I've no idea how to differentiate if prefix is not provide or it is \"/\".\nThe code logic to generate response map is different.\n\nIf I don't understand your idea, feel free to clarify it. Thanks for the tip.", "author": "huizhilu", "createdAt": "2020-02-19T03:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ1NjAwNA==", "url": "https://github.com/apache/helix/pull/761#discussion_r381456004", "bodyText": "When the prefix parameter is not provided, it's treated as the caller doesn't care about the prefix - this method is doing \"return all keys regardless of any prefix\". This behavior is functionally the same as if the caller provides \"/\" as the prefix. I think it's reasonable to use \"/\" as a default value.", "author": "NealSun96", "createdAt": "2020-02-19T18:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg2MjUxNA==", "url": "https://github.com/apache/helix/pull/761#discussion_r381862514", "bodyText": "I understand the specific case \u201c/\u201c in  getAllShardingKeysUnderPath could return the same result of getAllShardingKeys. But what if getAllShardingKeysUnderPath changes and returns different result?\n\nThe Json responses are different for each case here. If you assign \"/\" to a method, the response could have { \"prefix\": \"/\" }\nI would like to decouple two cases that having prefix (getAllShardingKeysUnderPath ) and no prefix.", "author": "huizhilu", "createdAt": "2020-02-20T09:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1OTQ2Nw==", "url": "https://github.com/apache/helix/pull/761#discussion_r382859467", "bodyText": "public static final String ROUTING_DATA_PATH = \"/METADATA_STORE_ROUTING_DATA\";\nThis should be the default value.", "author": "narendly", "createdAt": "2020-02-21T23:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxODAyNg==", "url": "https://github.com/apache/helix/pull/761#discussion_r379218026", "bodyText": "SHARDING_KEY_PREFIX's naming got me thinking for a little bit and I couldn't figure it out. Could we rename this?\nI think something like SHARDING_KEY_PATH_PREFIX would be more descriptive. To also help with understanding, could we please add where it's going to be used? (like getAllMappingUnderPath() for example).", "author": "narendly", "createdAt": "2020-02-14T02:03:25Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -28,14 +28,21 @@\n   // Leader election ZNode for ZkRoutingDataWriter\n   public static final String LEADER_ELECTION_ZNODE = \"/_ZK_ROUTING_DATA_WRITER_LEADER\";\n \n+  // Field name in JSON REST response of getting all metadata store namespaces.\n+  public static final String METADATA_STORE_NAMESPACES = \"namespaces\";\n+\n   // Field name in JSON REST response of getting metadata store realms in one namespace.\n   public static final String METADATA_STORE_REALMS = \"metadataStoreRealms\";\n \n   // Field name in JSON REST response of getting sharding keys in one realm.\n-  public static final String SINGLE_METADATA_STORE_REALM = \"metadataStoreRealm\";\n+  public static final String SINGLE_METADATA_STORE_REALM = \"realm\";\n \n   // Field name in JSON REST response of getting sharding keys.\n   public static final String SHARDING_KEYS = \"shardingKeys\";\n \n+  // Field name in JSON REST response related to one single sharding key.\n+  public static final String SINGLE_SHARDING_KEY = \"shardingKey\";\n \n+  // Field name in JSON REST response of getting sharding keys with prefix.\n+  public static final String SHARDING_KEY_PREFIX = \"prefix\";", "originalCommit": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxODM2NQ==", "url": "https://github.com/apache/helix/pull/761#discussion_r379218365", "bodyText": "Is this else needed?", "author": "narendly", "createdAt": "2020-02-14T02:05:06Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {\n     try {\n-      Collection<String> realms = _metadataStoreDirectory.getAllMetadataStoreRealms(_namespace);\n-\n-      responseMap = new HashMap<>(1);\n-      responseMap.put(MetadataStoreRoutingConstants.METADATA_STORE_REALMS, realms);\n+      if (shardingKey == null) {\n+        Collection<String> realms = _metadataStoreDirectory.getAllMetadataStoreRealms(_namespace);\n+        Map<String, Collection<String>> responseMap =\n+            ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_REALMS, realms);\n+        return JSONRepresentation(responseMap);\n+      } else {", "originalCommit": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxODY4NA==", "url": "https://github.com/apache/helix/pull/761#discussion_r379218684", "bodyText": "could we also document the difference in behavior depending on whether the query param is given?", "author": "narendly", "createdAt": "2020-02-14T02:06:40Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"", "originalCommit": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MTEyNQ==", "url": "https://github.com/apache/helix/pull/761#discussion_r379281125", "bodyText": "I think the endpoint already tells the behavior. That's why we need to follow the REST API design principal.", "author": "huizhilu", "createdAt": "2020-02-14T07:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxODY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyMzkyMg==", "url": "https://github.com/apache/helix/pull/761#discussion_r379223922", "bodyText": "Since this path resource seems to be doing two things, should we rename this to getMetadataStoreRealm()?", "author": "narendly", "createdAt": "2020-02-14T02:31:13Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {", "originalCommit": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MjUyMQ==", "url": "https://github.com/apache/helix/pull/761#discussion_r379282521", "bodyText": "?sharding-key= is a query param to filter the result. In this case, a single object being returned is acceptable.\nIt is like\n/employees returns all employees\n/employees?name=david could returns a single employee (assume name is unique).", "author": "huizhilu", "createdAt": "2020-02-14T07:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyMzkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyNzQxMw==", "url": "https://github.com/apache/helix/pull/761#discussion_r382427413", "bodyText": "Fair.", "author": "narendly", "createdAt": "2020-02-21T07:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyMzkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyNzkwOQ==", "url": "https://github.com/apache/helix/pull/761#discussion_r379227909", "bodyText": "Or better yet, should we consider breaking this up into two different path resources to eliminate if-elses?", "author": "narendly", "createdAt": "2020-02-14T02:50:13Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {", "originalCommit": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MzIzMg==", "url": "https://github.com/apache/helix/pull/761#discussion_r379283232", "bodyText": "My explanation above. It is OK to have if-else because we accept query params. A better way to process query param is like we construct a query for DB:\nquery += param1,\nquery += param2\n\nBut we don't have a query layer here so if-else acts as this query layer.", "author": "huizhilu", "createdAt": "2020-02-14T07:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyNzkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyNzUwMw==", "url": "https://github.com/apache/helix/pull/761#discussion_r382427503", "bodyText": "Okay. I'm fine with the current implementation.", "author": "narendly", "createdAt": "2020-02-21T07:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyNzkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyODE3MA==", "url": "https://github.com/apache/helix/pull/761#discussion_r379228170", "bodyText": "I have a feeling that this path resource is again doing too many things. Do you think we should consider breaking this up into different path resources?", "author": "narendly", "createdAt": "2020-02-14T02:51:26Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -111,41 +132,56 @@ public Response deleteMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n   }\n \n   /**\n-   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n-   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n-   * a realm.\n+   * Gets all sharding keys mapped at paths:\n+   * - \"HTTP GET /sharding-keys\" which returns all sharding keys in a namespace.\n+   * - \"HTTP GET /sharding-keys?realm={realm}\" which returns sharding keys in the realm.\n+   * - \"HTTP GET /sharding-keys?prefix={prefix}\" which returns sharding keys that have the prefix.\n+   * -- JSON response example for this path:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *    }, {\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/e\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/b\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/a\"\n+   *  }]\n+   * }\n+   *\n+   * - \"HTTP GET /sharding-keys?realm={realm}&prefix={prefix}\" which returns sharding keys in the\n+   * realm and that have the prefix.\n    *\n-   * @param realm Query param in endpoint path\n-   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   * @param realm Query param in endpoint path: metadata store realm.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return Json representation for the sharding keys.\n    */\n   @GET\n   @Path(\"/sharding-keys\")\n-  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n-    Map<String, Object> responseMap;\n-    Collection<String> shardingKeys;\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm,", "originalCommit": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4NDgyNA==", "url": "https://github.com/apache/helix/pull/761#discussion_r379284824", "bodyText": "A new endpoint which is equivalent to GET /sharding-keys?realm={realm} is added: GET /metadata-store-realms/{realm}/sharding-keys\nIn my opinion, these 2 filters are valid for this resource. If remove one query param, this method would only have 1 query param prefix and 1 if-else: all sharding keys or sharding keys with prefix.\nBut again, I would like to offer this query param option as they are valid, and it is also implemented now.", "author": "huizhilu", "createdAt": "2020-02-14T07:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyODE3MA=="}], "type": "inlineReview"}, {"oid": "2683c3acd706878f78a4d9b9619b122da9b62db8", "url": "https://github.com/apache/helix/commit/2683c3acd706878f78a4d9b9619b122da9b62db8", "message": "Add getRealmShardingKeys endpoint.", "committedDate": "2020-02-14T07:29:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5Mjc0Ng==", "url": "https://github.com/apache/helix/pull/761#discussion_r380992746", "bodyText": "Given my understanding to the status code, badRequest is more suitable than notFound in this situation. What notFound entails is that this url is not matched to anything, however in this situation, the url is correctly connecting to the endpoint. Returning notFound might cause confusion.\nI understand that badRequest is not perfect in this case either, but it should be more suitable than notFound. If you have a better idea, I'm happy to discuss. (Ref: https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)", "author": "NealSun96", "createdAt": "2020-02-18T23:16:37Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -111,41 +135,74 @@ public Response deleteMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n   }\n \n   /**\n-   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n-   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n-   * a realm.\n+   * Gets all sharding keys mapped at paths:\n+   * - \"HTTP GET /sharding-keys\" which returns all sharding keys in a namespace.\n+   * - \"HTTP GET /sharding-keys?realm={realm}\" which returns sharding keys in the realm.\n+   * - \"HTTP GET /sharding-keys?prefix={prefix}\" which returns sharding keys that have the prefix.\n+   * -- JSON response example for this path:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *    }, {\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/e\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/b\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/a\"\n+   *  }]\n+   * }\n    *\n-   * @param realm Query param in endpoint path\n-   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   * - \"HTTP GET /sharding-keys?realm={realm}&prefix={prefix}\" which returns sharding keys in the\n+   * realm and that have the prefix.\n+   *\n+   * @param realm Query param in endpoint path: metadata store realm.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return Json representation for the sharding keys.\n    */\n   @GET\n   @Path(\"/sharding-keys\")\n-  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n-    Map<String, Object> responseMap;\n-    Collection<String> shardingKeys;\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm,\n+      @QueryParam(\"prefix\") String prefix) {\n     try {\n-      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n-      // to get all sharding keys in a namespace.\n-      if (realm == null) {\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeys(_namespace);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS.\n-        responseMap = new HashMap<>(1);\n+      if (realm == null && prefix == null) {\n+        // For endpoint: \"/sharding-keys\" to get all sharding keys in a namespace.\n+        return getAllShardingKeys();\n+      } else if (prefix == null) {\n+        // For endpoint: \"/sharding-keys?realm={realm}\"\n+        return getAllShardingKeysInRealm(realm);\n+      } else if (realm == null) {\n+        // For endpoint: \"/sharding-keys?prefix={prefix}\"\n+        return getAllShardingKeysUnderPath(prefix);\n       } else {\n-        // For endpoint: \"/sharding-keys?realm={realmName}\"\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeysInRealm(_namespace, realm);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS and SINGLE_METADATA_STORE_REALM.\n-        responseMap = new HashMap<>(2);\n-        responseMap.put(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM, realm);\n+        // For endpoint: \"/sharding-keys?realm={realm}&prefix={prefix}\"\n+        return getRealmShardingKeysUnderPath(realm, prefix);\n       }\n     } catch (NoSuchElementException ex) {\n       return notFound(ex.getMessage());\n     }\n+  }\n \n-    responseMap.put(MetadataStoreRoutingConstants.SHARDING_KEYS, shardingKeys);\n-\n-    return JSONRepresentation(responseMap);\n+  /**\n+   * Gets all path-based sharding keys for a queried realm at endpoint:\n+   * \"GET /metadata-store-realms/{realm}/sharding-keys\". This endpoint is equivalent to\n+   * the endpoint: \"GET /sharding-keys?realm={realm}\".\n+   *\n+   * @param realm Queried metadata store realm to get sharding keys.\n+   * @return All path-based sharding keys in the queried realm.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms/{realm}/sharding-keys\")\n+  public Response getRealmShardingKeys(@PathParam(\"realm\") String realm) {\n+    try {\n+      return getAllShardingKeysInRealm(realm);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());", "originalCommit": "f0e4734ac029985e0b82c9e2b9dc03c868b0ea1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAwMDY5MQ==", "url": "https://github.com/apache/helix/pull/761#discussion_r381000691", "bodyText": "@NealSun96 Thanks for reviewing.\nAs you referred in the link, 400 Bad Request: The request could not be understood by the server due to malformed syntax. If you request a POST/PUT with json payload which has syntax error, I believe Bad Request is more suitable.\n404 Not Found means the endpoint is correct but resource is not found in server, which matches exactly our case here NoSuchElementException.  (refs as an examples:\n\nhttps://stackoverflow.com/questions/26968479/404-not-found-or-bad-request;\nhttps://stackoverflow.com/questions/19671317/400-bad-request-http-error-code-meaning)\n\nWhat do you think?", "author": "huizhilu", "createdAt": "2020-02-18T23:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5Mjc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyNTUzMw==", "url": "https://github.com/apache/helix/pull/761#discussion_r381625533", "bodyText": "404 does not mean the endpoint is correct. If I enter an end point \"/metadata-store-realms/test-realm/sharding-keys\" and I receive a 404 in return, my first reaction would be to change \"sharding-keys\" to \"sharding-key\", then \"shardingkeys\".\nOn a second thought, 404 with appropriate message does work better than 400. 400 is not very fitting.", "author": "NealSun96", "createdAt": "2020-02-20T00:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5Mjc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2Mzc5NQ==", "url": "https://github.com/apache/helix/pull/761#discussion_r382763795", "bodyText": "In your example, the endpoint is /metadata-store-realms/{realm}/sharding-keys is already correct. But the resource test-realm does not exist, and 404 is a correct response code. If endpoint is incorrect, you would not get 404 but 400 (bad URI) instead.\nSo if you get 404, the first reaction is definitely checking the requested resource, not changing the endpoint.", "author": "huizhilu", "createdAt": "2020-02-21T19:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5Mjc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5NzYwNQ==", "url": "https://github.com/apache/helix/pull/761#discussion_r380997605", "bodyText": "When verifying a map, I'd make sure that \"it contains the right elements and only the right elements\". Therefore I usually perform a check on map length - without it if the map returns something extra and unexpected, the test cases would still incorrectly pass.", "author": "NealSun96", "createdAt": "2020-02-18T23:32:28Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/resources/zookeeper/TestMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -110,7 +110,33 @@ public void beforeClass() throws Exception {\n     _metadataStoreDirectory = new ZkMetadataStoreDirectory(routingZkAddrMap);\n   }\n \n+  /*\n+   * Tests REST endpoint: \"GET /namespaces/{namespace}/metadata-store-namespaces\"\n+   */\n   @Test\n+  public void testGetAllNamespaces() throws IOException {\n+    String responseBody = get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-namespaces\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // It is safe to cast the object and suppress warnings.\n+    @SuppressWarnings(\"unchecked\")\n+    Map<String, Collection<String>> queriedNamespacesMap =\n+        OBJECT_MAPPER.readValue(responseBody, Map.class);\n+\n+    Assert.assertTrue(\n+        queriedNamespacesMap.containsKey(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES));", "originalCommit": "f0e4734ac029985e0b82c9e2b9dc03c868b0ea1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0NDM0NA==", "url": "https://github.com/apache/helix/pull/761#discussion_r381044344", "bodyText": "Sure. I was checking the response has this field. It is definitely more accurate to check that the response has only expected fields.", "author": "huizhilu", "createdAt": "2020-02-19T02:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5NzYwNQ=="}], "type": "inlineReview"}, {"oid": "71615fc1ed94b60173003e88641a202149899b55", "url": "https://github.com/apache/helix/commit/71615fc1ed94b60173003e88641a202149899b55", "message": "Add REST read endpoints to Helix REST for metada store directory service.", "committedDate": "2020-02-21T02:56:29Z", "type": "commit"}, {"oid": "38b54b45d60892f510b39aae8ba08ac0629ad49d", "url": "https://github.com/apache/helix/commit/38b54b45d60892f510b39aae8ba08ac0629ad49d", "message": "Add getRealmShardingKeys endpoint.", "committedDate": "2020-02-21T02:58:13Z", "type": "commit"}, {"oid": "c5e5b49f8e95db279894ad4572f74266e02bb663", "url": "https://github.com/apache/helix/commit/c5e5b49f8e95db279894ad4572f74266e02bb663", "message": "Format long lines.", "committedDate": "2020-02-21T02:58:13Z", "type": "commit"}, {"oid": "10aa4d6c8a96169374e18786654369ccc5eb123a", "url": "https://github.com/apache/helix/commit/10aa4d6c8a96169374e18786654369ccc5eb123a", "message": "Check exact fields in JSON response in unit tests.", "committedDate": "2020-02-21T02:58:13Z", "type": "commit"}, {"oid": "163c35c81cf770ddabdf355a6bd6c76931f69a17", "url": "https://github.com/apache/helix/commit/163c35c81cf770ddabdf355a6bd6c76931f69a17", "message": "Comment.", "committedDate": "2020-02-21T02:58:13Z", "type": "commit"}, {"oid": "96c7ad934d3b78aabee5fcf215d98e3a470673b8", "url": "https://github.com/apache/helix/commit/96c7ad934d3b78aabee5fcf215d98e3a470673b8", "message": "Close MSD before MetadataStoreDirectoryAccessor is destroyed.", "committedDate": "2020-02-21T02:58:13Z", "type": "forcePushed"}, {"oid": "d2ec40295b11736e68d8da5b51beeae628694962", "url": "https://github.com/apache/helix/commit/d2ec40295b11736e68d8da5b51beeae628694962", "message": "Close MSD before MetadataStoreDirectoryAccessor is destroyed.", "committedDate": "2020-02-21T03:01:43Z", "type": "commit"}, {"oid": "d2ec40295b11736e68d8da5b51beeae628694962", "url": "https://github.com/apache/helix/commit/d2ec40295b11736e68d8da5b51beeae628694962", "message": "Close MSD before MetadataStoreDirectoryAccessor is destroyed.", "committedDate": "2020-02-21T03:01:43Z", "type": "forcePushed"}, {"oid": "d207dd53f1b78caa2c55a6f739a18830900ef6e2", "url": "https://github.com/apache/helix/commit/d207dd53f1b78caa2c55a6f739a18830900ef6e2", "message": "Remove query param realm in endpoint to get all sharding keys.", "committedDate": "2020-02-22T00:51:10Z", "type": "commit"}]}