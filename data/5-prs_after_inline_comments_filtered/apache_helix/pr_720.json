{"pr_number": 720, "pr_title": "Add MetadataStoreDirectory and ZkMetadataStoreDirectory", "pr_createdAt": "2020-02-04T03:54:46Z", "pr_url": "https://github.com/apache/helix/pull/720", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1Njc4Mw==", "url": "https://github.com/apache/helix/pull/720#discussion_r374856783", "bodyText": "Ditto the point above about method naming.", "author": "NealSun96", "createdAt": "2020-02-04T18:50:36Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient.ZkClientConfig;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.Watcher;\n+\n+\n+public class ZkMetadataStoreDirectory implements MetadataStoreDirectory {\n+  // TODO: enable the line below when implementation is complete\n+//  private final MetadataStoreRoutingDataAccessor _routingDataAccessor;\n+  private MetadataStoreRoutingData _routingData;\n+\n+  public ZkMetadataStoreDirectory(String zkAddress) {\n+//    _routingDataAccessor = new ZkRoutingDataAccessor(zkAddress, this); // dependency injection\n+    // 1. Create a RoutingDataTrieNode using routingDataAccessor\n+    // _routingData = constructRoutingData(_routingDataAccessor);\n+  }\n+\n+  @Override\n+  public List<String> getAllNamespaces() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllMetadataStoreRealms(String namespace) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllShardingKeys(String namespace) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllShardingKeysInRealm(String namespace, String realm) {\n+    return null;\n+  }\n+\n+  @Override\n+  public Map<String, String> getAllShardingKeysUnderPath(String namespace, String path) {", "originalCommit": "8409ab87f1c1945b95c3b98967928ea4cda758f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2NzAwMQ==", "url": "https://github.com/apache/helix/pull/720#discussion_r374867001", "bodyText": "Responding to a point raised by @pkuwm earlier during the design phase, the naming of this method should be changed to getAllMappingUnderPath. See https://github.com/apache/helix/pull/706/files#diff-184698fcbd1600d535a7b9f7996ca9f6R37 for reference as it has been changed for the underlying class.\nThe reason behind this proposal is that getAllShardingKeysInRealm returns a list of sharding keys, while this method returns a mapping of sharding keys to realm addresses. If this method has the same prefix of \"getAllShardkingKeys\" it's easy to cause confusion on the usage.", "author": "NealSun96", "createdAt": "2020-02-04T19:10:45Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  List<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  List<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  List<String> getAllShardingKeys(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace and the realm.\n+   * @param namespace\n+   * @param realm\n+   * @return\n+   */\n+  List<String> getAllShardingKeysInRealm(String namespace, String realm);\n+\n+  /**\n+   * Returns all sharding keys that have the given path as the prefix substring.\n+   * E.g) Given that there are sharding keys: /a/b/c, /a/b/d, /a/e,\n+   * getAllShardingKeysUnderPath(namespace, \"/a/b\") returns [\"/a/b/c\", \"/a/b/d\"].\n+   * @param namespace\n+   * @param path\n+   * @return\n+   */\n+  Map<String, String> getAllShardingKeysUnderPath(String namespace, String path);", "originalCommit": "8409ab87f1c1945b95c3b98967928ea4cda758f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1MTQwNw==", "url": "https://github.com/apache/helix/pull/720#discussion_r375051407", "bodyText": "Modified.", "author": "narendly", "createdAt": "2020-02-05T04:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2NzAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTExMg==", "url": "https://github.com/apache/helix/pull/720#discussion_r374895112", "bodyText": "Do we need this?", "author": "junkaixue", "createdAt": "2020-02-04T20:07:24Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient.ZkClientConfig;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.Watcher;\n+\n+\n+public class ZkMetadataStoreDirectory implements MetadataStoreDirectory {\n+  // TODO: enable the line below when implementation is complete\n+//  private final MetadataStoreRoutingDataAccessor _routingDataAccessor;\n+  private MetadataStoreRoutingData _routingData;\n+\n+  public ZkMetadataStoreDirectory(String zkAddress) {\n+//    _routingDataAccessor = new ZkRoutingDataAccessor(zkAddress, this); // dependency injection\n+    // 1. Create a RoutingDataTrieNode using routingDataAccessor\n+    // _routingData = constructRoutingData(_routingDataAccessor);\n+  }\n+\n+  @Override\n+  public List<String> getAllNamespaces() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllMetadataStoreRealms(String namespace) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllShardingKeys(String namespace) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllShardingKeysInRealm(String namespace, String realm) {\n+    return null;\n+  }\n+\n+  @Override\n+  public Map<String, String> getAllShardingKeysUnderPath(String namespace, String path) {\n+    return null;\n+  }\n+\n+  @Override\n+  public String getMetadataStoreRealm(String namespace, String shardingKey) {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean addNamespace(String namespace) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean deleteNamespace(String namespace) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean addMetadataStoreRealm(String namespace, String realm) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean deleteMetadataStoreRealm(String namespace, String realm) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean addShardingKey(String namespace, String realm, String shardingKey) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean deleteShardingKey(String namespace, String realm, String shardingKey) {\n+    return false;\n+  }\n+\n+  @Override\n+  public void updateRoutingData() {\n+    // call constructRoutingData() here.\n+  }\n+\n+//  /**\n+//   * Reconstructs MetadataStoreRoutingData by reading from the metadata store.\n+//   * @param routingDataAccessor\n+//   * @return\n+//   */\n+//  private MetadataStoreRoutingData constructRoutingData(MetadataStoreRoutingDataAccessor routingDataAccessor) {\n+//    /**\n+//     * Trie construction logic\n+//     */\n+//\n+//    // 1. Construct\n+//    // 2. Update the in-memory reference when complete\n+//    _routingData = newRoutingData;\n+//  }", "originalCommit": "8409ab87f1c1945b95c3b98967928ea4cda758f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NzIzNQ==", "url": "https://github.com/apache/helix/pull/720#discussion_r374897235", "bodyText": "If the code is not used, let's remove it.", "author": "junkaixue", "createdAt": "2020-02-04T20:11:56Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient.ZkClientConfig;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.Watcher;\n+\n+\n+public class ZkMetadataStoreDirectory implements MetadataStoreDirectory {\n+  // TODO: enable the line below when implementation is complete\n+//  private final MetadataStoreRoutingDataAccessor _routingDataAccessor;\n+  private MetadataStoreRoutingData _routingData;\n+\n+  public ZkMetadataStoreDirectory(String zkAddress) {\n+//    _routingDataAccessor = new ZkRoutingDataAccessor(zkAddress, this); // dependency injection\n+    // 1. Create a RoutingDataTrieNode using routingDataAccessor\n+    // _routingData = constructRoutingData(_routingDataAccessor);", "originalCommit": "8409ab87f1c1945b95c3b98967928ea4cda758f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NzU0OQ==", "url": "https://github.com/apache/helix/pull/720#discussion_r374897549", "bodyText": "Will this return complete path of keys?", "author": "junkaixue", "createdAt": "2020-02-04T20:12:36Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  List<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  List<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  List<String> getAllShardingKeys(String namespace);", "originalCommit": "8409ab87f1c1945b95c3b98967928ea4cda758f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1MTE3OA==", "url": "https://github.com/apache/helix/pull/720#discussion_r375051178", "bodyText": "Yes. All sharding keys in the namespace.", "author": "narendly", "createdAt": "2020-02-05T04:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NzU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5OTIwMg==", "url": "https://github.com/apache/helix/pull/720#discussion_r374899202", "bodyText": "It is better in the Interface level to explain the namespace, realms and sharding keys. Reviewers may not have context on what are they.", "author": "junkaixue", "createdAt": "2020-02-04T20:15:58Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+public interface MetadataStoreDirectory {", "originalCommit": "8409ab87f1c1945b95c3b98967928ea4cda758f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1MTEyMw==", "url": "https://github.com/apache/helix/pull/720#discussion_r375051123", "bodyText": "Added more explanation.", "author": "narendly", "createdAt": "2020-02-05T04:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5OTIwMg=="}], "type": "inlineReview"}, {"oid": "a23d8e4c3cc413ca2f3976ff0cbeeee8d8aafbf2", "url": "https://github.com/apache/helix/commit/a23d8e4c3cc413ca2f3976ff0cbeeee8d8aafbf2", "message": "Add MetadataStoreDirectory and ZkMetadataStoreDirectory", "committedDate": "2020-02-05T02:05:06Z", "type": "commit"}, {"oid": "b778f78cd13139c0151da9552768656347946255", "url": "https://github.com/apache/helix/commit/b778f78cd13139c0151da9552768656347946255", "message": "Change design", "committedDate": "2020-02-05T02:05:06Z", "type": "commit"}, {"oid": "e50311a39cc5cee392667464065d1c7fbc53662d", "url": "https://github.com/apache/helix/commit/e50311a39cc5cee392667464065d1c7fbc53662d", "message": "Implement listeners", "committedDate": "2020-02-05T04:52:45Z", "type": "commit"}, {"oid": "ffe551c88ba3e298231ac721cd8ccaf658ec248a", "url": "https://github.com/apache/helix/commit/ffe551c88ba3e298231ac721cd8ccaf658ec248a", "message": "finish implementation with tests", "committedDate": "2020-02-05T06:22:43Z", "type": "commit"}, {"oid": "ffe551c88ba3e298231ac721cd8ccaf658ec248a", "url": "https://github.com/apache/helix/commit/ffe551c88ba3e298231ac721cd8ccaf658ec248a", "message": "finish implementation with tests", "committedDate": "2020-02-05T06:22:43Z", "type": "forcePushed"}, {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2", "url": "https://github.com/apache/helix/commit/85aea4d86f569d091212e9e4f35594267a0636b2", "message": "Fix type", "committedDate": "2020-02-05T06:25:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzA0Ng==", "url": "https://github.com/apache/helix/pull/720#discussion_r375113046", "bodyText": "What if it does not exist? Shall we return null String or throw exception? If throw exception, we should have signature here.", "author": "junkaixue", "createdAt": "2020-02-05T08:22:39Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+\n+/**\n+ * MetadataStoreDirectory interface that provides methods that are used to route requests to appropriate metadata store realm.\n+ *\n+ * namespace: tied to a namespace used in Helix REST (Metadata Store Directory Service endpoints will be served by Helix REST deployables)\n+ * realm: a metadata store deployable/ensemble. for example, if an application wishes to use 3 ZK quorums, then each ZK quorum would be considered a realm (ZK realm)\n+ * metadata store path sharding key: assuming the metadata store uses a file system APIs, this sharding key denotes the key that maps to a particular metadata store realm. an example of a key is a cluster name mapping to a particular ZK realm (ZK address)\n+ */\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  Collection<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeys(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace and the realm.\n+   * @param namespace\n+   * @param realm\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeysInRealm(String namespace, String realm);\n+\n+  /**\n+   * Returns all sharding keys that have the given path as the prefix substring.\n+   * E.g) Given that there are sharding keys: /a/b/c, /a/b/d, /a/e,\n+   * getAllShardingKeysUnderPath(namespace, \"/a/b\") returns [\"/a/b/c\": \"realm\", \"/a/b/d\": \"realm].\n+   * @param namespace\n+   * @param path\n+   * @return\n+   */\n+  Map<String, String> getAllMappingUnderPath(String namespace, String path);\n+\n+  /**\n+   * Returns the name of the metadata store realm based on the namespace and the sharding key given.\n+   * @param namespace\n+   * @param shardingKey\n+   * @return\n+   */\n+  String getMetadataStoreRealm(String namespace, String shardingKey);", "originalCommit": "85aea4d86f569d091212e9e4f35594267a0636b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5MzA2MQ==", "url": "https://github.com/apache/helix/pull/720#discussion_r375393061", "bodyText": "If it doesn't exist, yes, we should alert the user with an exception. I'll consider adding that.", "author": "narendly", "createdAt": "2020-02-05T17:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzM0Ng==", "url": "https://github.com/apache/helix/pull/720#discussion_r375113346", "bodyText": "This is not like to be a REST level operation, right? Does REST support this operation now? It would be dangerous that MDSD support add/delete namespaces.", "author": "junkaixue", "createdAt": "2020-02-05T08:23:22Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+\n+/**\n+ * MetadataStoreDirectory interface that provides methods that are used to route requests to appropriate metadata store realm.\n+ *\n+ * namespace: tied to a namespace used in Helix REST (Metadata Store Directory Service endpoints will be served by Helix REST deployables)\n+ * realm: a metadata store deployable/ensemble. for example, if an application wishes to use 3 ZK quorums, then each ZK quorum would be considered a realm (ZK realm)\n+ * metadata store path sharding key: assuming the metadata store uses a file system APIs, this sharding key denotes the key that maps to a particular metadata store realm. an example of a key is a cluster name mapping to a particular ZK realm (ZK address)\n+ */\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  Collection<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeys(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace and the realm.\n+   * @param namespace\n+   * @param realm\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeysInRealm(String namespace, String realm);\n+\n+  /**\n+   * Returns all sharding keys that have the given path as the prefix substring.\n+   * E.g) Given that there are sharding keys: /a/b/c, /a/b/d, /a/e,\n+   * getAllShardingKeysUnderPath(namespace, \"/a/b\") returns [\"/a/b/c\": \"realm\", \"/a/b/d\": \"realm].\n+   * @param namespace\n+   * @param path\n+   * @return\n+   */\n+  Map<String, String> getAllMappingUnderPath(String namespace, String path);\n+\n+  /**\n+   * Returns the name of the metadata store realm based on the namespace and the sharding key given.\n+   * @param namespace\n+   * @param shardingKey\n+   * @return\n+   */\n+  String getMetadataStoreRealm(String namespace, String shardingKey);\n+\n+  /**\n+   * NOTE: The following CRUD methods are idempotent.\n+   */\n+  /**\n+   * Creates a namespace in the routing metadata store.\n+   * @param namespace\n+   * @return true if successful or if the namespace already exists. false if not successful.\n+   */\n+  boolean addNamespace(String namespace);", "originalCommit": "85aea4d86f569d091212e9e4f35594267a0636b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5MTc4OA==", "url": "https://github.com/apache/helix/pull/720#discussion_r375391788", "bodyText": "I'd like to understand the context of your questions -\n\nWhy do you think supporting write operations is dangerous?\nThis will be supported; otherwise, users won't have a safe way to register namespaces and realms. We should add a layer of security (access control), but that would be the roadmap for the future.", "author": "narendly", "createdAt": "2020-02-05T17:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyNTcyOA==", "url": "https://github.com/apache/helix/pull/720#discussion_r375425728", "bodyText": "I think I was confused with existing REST namespace? Because I saw you are subscribing to namespace. Will that be a ZNode?", "author": "junkaixue", "createdAt": "2020-02-05T18:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzODM1Mw==", "url": "https://github.com/apache/helix/pull/720#discussion_r375438353", "bodyText": "@dasahcc I think I see what you're referring to. This was an old design that was copied and pasted. Let me remove these APIs around namespaces. Namespaces will be registered via application-supplied configs.", "author": "narendly", "createdAt": "2020-02-05T18:44:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNDY0Nw==", "url": "https://github.com/apache/helix/pull/720#discussion_r375114647", "bodyText": "Do we consider close operation is idempotent? If yes, we can think about extend the interface AutoCloseable. Then user can use try-with-resources.", "author": "junkaixue", "createdAt": "2020-02-05T08:26:46Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+\n+/**\n+ * MetadataStoreDirectory interface that provides methods that are used to route requests to appropriate metadata store realm.\n+ *\n+ * namespace: tied to a namespace used in Helix REST (Metadata Store Directory Service endpoints will be served by Helix REST deployables)\n+ * realm: a metadata store deployable/ensemble. for example, if an application wishes to use 3 ZK quorums, then each ZK quorum would be considered a realm (ZK realm)\n+ * metadata store path sharding key: assuming the metadata store uses a file system APIs, this sharding key denotes the key that maps to a particular metadata store realm. an example of a key is a cluster name mapping to a particular ZK realm (ZK address)\n+ */\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  Collection<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeys(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace and the realm.\n+   * @param namespace\n+   * @param realm\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeysInRealm(String namespace, String realm);\n+\n+  /**\n+   * Returns all sharding keys that have the given path as the prefix substring.\n+   * E.g) Given that there are sharding keys: /a/b/c, /a/b/d, /a/e,\n+   * getAllShardingKeysUnderPath(namespace, \"/a/b\") returns [\"/a/b/c\": \"realm\", \"/a/b/d\": \"realm].\n+   * @param namespace\n+   * @param path\n+   * @return\n+   */\n+  Map<String, String> getAllMappingUnderPath(String namespace, String path);\n+\n+  /**\n+   * Returns the name of the metadata store realm based on the namespace and the sharding key given.\n+   * @param namespace\n+   * @param shardingKey\n+   * @return\n+   */\n+  String getMetadataStoreRealm(String namespace, String shardingKey);\n+\n+  /**\n+   * NOTE: The following CRUD methods are idempotent.\n+   */\n+  /**\n+   * Creates a namespace in the routing metadata store.\n+   * @param namespace\n+   * @return true if successful or if the namespace already exists. false if not successful.\n+   */\n+  boolean addNamespace(String namespace);\n+\n+  /**\n+   * Deletes a namespace in the routing metadata store.\n+   * @param namespace\n+   * @return true if successful or if the namespace does not exist. false otherwise.\n+   */\n+  boolean deleteNamespace(String namespace);\n+\n+  /**\n+   * Creates a realm. If the namespace does not exist, it creates one.\n+   * @param namespace\n+   * @param realm\n+   * @return true if successful or if the realm already exists. false otherwise.\n+   */\n+  boolean addMetadataStoreRealm(String namespace, String realm);\n+\n+  /**\n+   * Deletes a realm.\n+   * @param namespace\n+   * @param realm\n+   * @return true if successful or the realm or namespace does not exist. false otherwise.\n+   */\n+  boolean deleteMetadataStoreRealm(String namespace, String realm);\n+\n+  /**\n+   * Creates a mapping between the sharding key to the realm in the given namespace.\n+   * @param namespace\n+   * @param realm\n+   * @param shardingKey\n+   * @return false if failed\n+   */\n+  boolean addShardingKey(String namespace, String realm, String shardingKey);\n+\n+  /**\n+   * Deletes the mapping between the sharding key to the realm in the given namespace.\n+   * @param namespace\n+   * @param realm\n+   * @param shardingKey\n+   * @return false if failed; true if the deletion is successful or the key does not exist.\n+   */\n+  boolean deleteShardingKey(String namespace, String realm, String shardingKey);\n+\n+  /**\n+   * Close MetadataStoreDirectory.\n+   */\n+  void close();", "originalCommit": "85aea4d86f569d091212e9e4f35594267a0636b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5MjcwMA==", "url": "https://github.com/apache/helix/pull/720#discussion_r375392700", "bodyText": "Using AutoCloseable could be a good idea. I'll consider adding it.", "author": "narendly", "createdAt": "2020-02-05T17:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNDY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxNzU1Ng==", "url": "https://github.com/apache/helix/pull/720#discussion_r375417556", "bodyText": "What if this namespace key does not exists? Could NPE happens?", "author": "junkaixue", "createdAt": "2020-02-05T18:03:18Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.HelixManagerProperties;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient.ZkClientConfig;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update callback.\n+ */\n+public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n+\n+  // TODO: enable the line below when implementation is complete\n+  // The following maps' keys represent the namespace\n+  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  private final Map<String, String> _routingZkAddressMap;\n+  // <namespace, <realm, <list of sharding keys>> mappings\n+  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+\n+  /**\n+   * Creates a ZkMetadataStoreDirectory based on the given routing ZK addresses.\n+   * @param routingZkAddressMap (namespace, routing ZK connect string)\n+   * @throws InvalidRoutingDataException\n+   */\n+  public ZkMetadataStoreDirectory(Map<String, String> routingZkAddressMap)\n+      throws InvalidRoutingDataException {\n+    if (routingZkAddressMap == null || routingZkAddressMap.isEmpty()) {\n+      throw new InvalidRoutingDataException(\"Routing ZK Addresses given are invalid!\");\n+    }\n+    _routingDataReaderMap = new HashMap<>();\n+    _routingZkAddressMap = routingZkAddressMap;\n+    _realmToShardingKeysMap = new ConcurrentHashMap<>();\n+    _routingDataMap = new ConcurrentHashMap<>();\n+\n+    // Create RoutingDataReaders\n+    for (Map.Entry<String, String> routingEntry : _routingZkAddressMap.entrySet()) {\n+      _routingDataReaderMap.put(routingEntry.getKey(),\n+          new ZkRoutingDataReader(routingEntry.getKey(), routingEntry.getValue(), this));\n+\n+      // Populate realmToShardingKeys with ZkRoutingDataReader\n+      _realmToShardingKeysMap.put(routingEntry.getKey(),\n+          _routingDataReaderMap.get(routingEntry.getKey()).getRoutingData());\n+    }\n+  }\n+\n+  @Override\n+  public Collection<String> getAllNamespaces() {\n+    return Collections.unmodifiableCollection(_routingZkAddressMap.keySet());\n+  }\n+\n+  @Override\n+  public Collection<String> getAllMetadataStoreRealms(String namespace) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    return Collections.unmodifiableCollection(_realmToShardingKeysMap.get(namespace).keySet());\n+  }\n+\n+  @Override\n+  public Collection<String> getAllShardingKeys(String namespace) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    Set<String> allShardingKeys = new HashSet<>();\n+    _realmToShardingKeysMap.get(namespace).values().forEach(keys -> allShardingKeys.addAll(keys));\n+    return allShardingKeys;\n+  }\n+\n+  @Override\n+  public Collection<String> getAllShardingKeysInRealm(String namespace, String realm) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    if (!_realmToShardingKeysMap.get(namespace).containsKey(realm)) {\n+      throw new NoSuchElementException(\n+          \"Realm \" + realm + \" does not exist in namespace \" + namespace);\n+    }\n+    return Collections.unmodifiableCollection(_realmToShardingKeysMap.get(namespace).get(realm));\n+  }\n+\n+  @Override\n+  public Map<String, String> getAllMappingUnderPath(String namespace, String path) {\n+    // TODO: get it from routingData\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public String getMetadataStoreRealm(String namespace, String shardingKey) {\n+    // TODO: get it from routingData\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addNamespace(String namespace) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteNamespace(String namespace) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addMetadataStoreRealm(String namespace, String realm) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteMetadataStoreRealm(String namespace, String realm) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addShardingKey(String namespace, String realm, String shardingKey) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteShardingKey(String namespace, String realm, String shardingKey) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Callback for updating the cached routing data.\n+   * Note: this method should not synchronize on the class or the map. We do not want namespaces blocking each other.\n+   * Threadsafe map is used for _realmToShardingKeysMap.\n+   * The global consistency of the in-memory routing data is not a requirement (eventual consistency is enough).\n+   * @param namespace\n+   */\n+  @Override\n+  public void updateRoutingData(String namespace) {\n+    // Safe to ignore the callback if routingDataMap is null.\n+    // If routingDataMap is null, then it will be populated by the constructor anyway\n+    // If routingDataMap is not null, then it's safe for the callback function to update it\n+    try {\n+      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());", "originalCommit": "85aea4d86f569d091212e9e4f35594267a0636b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ0MjQ5NQ==", "url": "https://github.com/apache/helix/pull/720#discussion_r375442495", "bodyText": "Adding the exists check with a log.", "author": "narendly", "createdAt": "2020-02-05T18:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxNzU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyMTQ4MQ==", "url": "https://github.com/apache/helix/pull/720#discussion_r375421481", "bodyText": "This is more like an internal method to refresh internal cached data? Then refreshRoutingData could be a better name. Otherwise, it will be confused with users operation.", "author": "junkaixue", "createdAt": "2020-02-05T18:11:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.HelixManagerProperties;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient.ZkClientConfig;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update callback.\n+ */\n+public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n+\n+  // TODO: enable the line below when implementation is complete\n+  // The following maps' keys represent the namespace\n+  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  private final Map<String, String> _routingZkAddressMap;\n+  // <namespace, <realm, <list of sharding keys>> mappings\n+  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+\n+  /**\n+   * Creates a ZkMetadataStoreDirectory based on the given routing ZK addresses.\n+   * @param routingZkAddressMap (namespace, routing ZK connect string)\n+   * @throws InvalidRoutingDataException\n+   */\n+  public ZkMetadataStoreDirectory(Map<String, String> routingZkAddressMap)\n+      throws InvalidRoutingDataException {\n+    if (routingZkAddressMap == null || routingZkAddressMap.isEmpty()) {\n+      throw new InvalidRoutingDataException(\"Routing ZK Addresses given are invalid!\");\n+    }\n+    _routingDataReaderMap = new HashMap<>();\n+    _routingZkAddressMap = routingZkAddressMap;\n+    _realmToShardingKeysMap = new ConcurrentHashMap<>();\n+    _routingDataMap = new ConcurrentHashMap<>();\n+\n+    // Create RoutingDataReaders\n+    for (Map.Entry<String, String> routingEntry : _routingZkAddressMap.entrySet()) {\n+      _routingDataReaderMap.put(routingEntry.getKey(),\n+          new ZkRoutingDataReader(routingEntry.getKey(), routingEntry.getValue(), this));\n+\n+      // Populate realmToShardingKeys with ZkRoutingDataReader\n+      _realmToShardingKeysMap.put(routingEntry.getKey(),\n+          _routingDataReaderMap.get(routingEntry.getKey()).getRoutingData());\n+    }\n+  }\n+\n+  @Override\n+  public Collection<String> getAllNamespaces() {\n+    return Collections.unmodifiableCollection(_routingZkAddressMap.keySet());\n+  }\n+\n+  @Override\n+  public Collection<String> getAllMetadataStoreRealms(String namespace) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    return Collections.unmodifiableCollection(_realmToShardingKeysMap.get(namespace).keySet());\n+  }\n+\n+  @Override\n+  public Collection<String> getAllShardingKeys(String namespace) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    Set<String> allShardingKeys = new HashSet<>();\n+    _realmToShardingKeysMap.get(namespace).values().forEach(keys -> allShardingKeys.addAll(keys));\n+    return allShardingKeys;\n+  }\n+\n+  @Override\n+  public Collection<String> getAllShardingKeysInRealm(String namespace, String realm) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    if (!_realmToShardingKeysMap.get(namespace).containsKey(realm)) {\n+      throw new NoSuchElementException(\n+          \"Realm \" + realm + \" does not exist in namespace \" + namespace);\n+    }\n+    return Collections.unmodifiableCollection(_realmToShardingKeysMap.get(namespace).get(realm));\n+  }\n+\n+  @Override\n+  public Map<String, String> getAllMappingUnderPath(String namespace, String path) {\n+    // TODO: get it from routingData\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public String getMetadataStoreRealm(String namespace, String shardingKey) {\n+    // TODO: get it from routingData\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addNamespace(String namespace) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteNamespace(String namespace) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addMetadataStoreRealm(String namespace, String realm) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteMetadataStoreRealm(String namespace, String realm) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addShardingKey(String namespace, String realm, String shardingKey) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteShardingKey(String namespace, String realm, String shardingKey) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Callback for updating the cached routing data.", "originalCommit": "85aea4d86f569d091212e9e4f35594267a0636b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzOTU4Mw==", "url": "https://github.com/apache/helix/pull/720#discussion_r375439583", "bodyText": "I can change the method name.", "author": "narendly", "createdAt": "2020-02-05T18:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyMTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyNDk5OA==", "url": "https://github.com/apache/helix/pull/720#discussion_r375424998", "bodyText": "Can you share why we need to unsubscribe all here?", "author": "junkaixue", "createdAt": "2020-02-05T18:17:57Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkRoutingDataReader.java", "diffHunk": "@@ -22,54 +22,161 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n import org.I0Itec.zkclient.exception.ZkNoNodeException;\n import org.apache.helix.ZNRecord;\n import org.apache.helix.manager.zk.ZNRecordSerializer;\n import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.zookeeper.Watcher;\n \n-public class ZkRoutingDataReader implements MetadataStoreRoutingDataReader {\n-  static final String ROUTING_DATA_PATH = \"/METADATA_STORE_ROUTING_DATA\";\n-  static final String ZNRECORD_LIST_FIELD_KEY = \"ZK_PATH_SHARDING_KEYS\";\n \n+public class ZkRoutingDataReader implements MetadataStoreRoutingDataReader, IZkDataListener, IZkChildListener, IZkStateListener {\n+  private final String _namespace;\n   private final String _zkAddress;\n   private final HelixZkClient _zkClient;\n+  private final RoutingDataListener _routingDataListener;\n+\n+  public ZkRoutingDataReader(String namespace, String zkAddress) {\n+    this(namespace, zkAddress, null);\n+  }\n \n-  public ZkRoutingDataReader(String zkAddress) {\n+  public ZkRoutingDataReader(String namespace, String zkAddress,\n+      RoutingDataListener routingDataListener) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n     _zkAddress = zkAddress;\n-    _zkClient = DedicatedZkClientFactory.getInstance().buildZkClient(\n-        new HelixZkClient.ZkConnectionConfig(zkAddress),\n-        new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+    _routingDataListener = routingDataListener;\n+    if (_routingDataListener != null) {\n+      // Subscribe child changes\n+      _zkClient.subscribeChildChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, this);\n+      // Subscribe data changes\n+      for (String child : _zkClient.getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+        _zkClient\n+            .subscribeDataChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + child,\n+                this);\n+      }\n+    }\n   }\n \n-  public Map<String, List<String>> getRoutingData() throws InvalidRoutingDataException {\n+  /**\n+   * Returns (realm, list of ZK path sharding keys) mappings.\n+   * @return\n+   * @throws InvalidRoutingDataException\n+   */\n+  public Map<String, List<String>> getRoutingData()\n+      throws InvalidRoutingDataException {\n     Map<String, List<String>> routingData = new HashMap<>();\n     List<String> children;\n     try {\n-      children = _zkClient.getChildren(ROUTING_DATA_PATH);\n+      children = _zkClient.getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n     } catch (ZkNoNodeException e) {\n-      throw new InvalidRoutingDataException(\"Routing data directory ZNode \" + ROUTING_DATA_PATH\n-          + \" does not exist. Routing ZooKeeper address: \" + _zkAddress);\n+      throw new InvalidRoutingDataException(\n+          \"Routing data directory ZNode \" + MetadataStoreRoutingConstants.ROUTING_DATA_PATH\n+              + \" does not exist. Routing ZooKeeper address: \" + _zkAddress);\n     }\n     if (children == null || children.isEmpty()) {\n       throw new InvalidRoutingDataException(\n           \"There are no metadata store realms defined. Routing ZooKeeper address: \" + _zkAddress);\n     }\n     for (String child : children) {\n-      ZNRecord record = _zkClient.readData(ROUTING_DATA_PATH + \"/\" + child);\n-      List<String> shardingKeys = record.getListField(ZNRECORD_LIST_FIELD_KEY);\n+      ZNRecord record =\n+          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + child);\n+      List<String> shardingKeys =\n+          record.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n       if (shardingKeys == null || shardingKeys.isEmpty()) {\n-        throw new InvalidRoutingDataException(\"Realm address ZNode \" + ROUTING_DATA_PATH + \"/\"\n-            + child + \" does not have a value for key \" + ZNRECORD_LIST_FIELD_KEY\n-            + \". Routing ZooKeeper address: \" + _zkAddress);\n+        throw new InvalidRoutingDataException(\n+            \"Realm address ZNode \" + MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + child\n+                + \" does not have a value for key \"\n+                + MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY\n+                + \". Routing ZooKeeper address: \" + _zkAddress);\n       }\n       routingData.put(child, shardingKeys);\n     }\n     return routingData;\n   }\n \n-  public void close() {\n+  public synchronized void close() {\n+    _zkClient.unsubscribeAll();\n     _zkClient.close();\n   }\n+\n+  @Override\n+  public synchronized void handleDataChange(String s, Object o)\n+      throws Exception {\n+    if (_zkClient.isClosed()) {\n+      return;\n+    }\n+    _routingDataListener.updateRoutingData(_namespace);\n+  }\n+\n+  @Override\n+  public synchronized void handleDataDeleted(String s)\n+      throws Exception {\n+    if (_zkClient.isClosed()) {\n+      return;\n+    }\n+    _zkClient.unsubscribeAll();", "originalCommit": "85aea4d86f569d091212e9e4f35594267a0636b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ0MzM4OQ==", "url": "https://github.com/apache/helix/pull/720#discussion_r375443389", "bodyText": "This is meant to go under handleChildChange. Good catch!", "author": "narendly", "createdAt": "2020-02-05T18:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyNDk5OA=="}], "type": "inlineReview"}, {"oid": "dfdc6bdb95846b9f9a90223c07935447d70f4db9", "url": "https://github.com/apache/helix/commit/dfdc6bdb95846b9f9a90223c07935447d70f4db9", "message": "Fix test failure and addres comments", "committedDate": "2020-02-05T18:58:42Z", "type": "commit"}]}