{"pr_number": 1165, "pr_title": "Quota calculation based on CurrentState", "pr_createdAt": "2020-07-22T03:20:52Z", "pr_url": "https://github.com/apache/helix/pull/1165", "timeline": [{"oid": "ca6f8b00c8be5d215fb494abfb29d012538440c3", "url": "https://github.com/apache/helix/commit/ca6f8b00c8be5d215fb494abfb29d012538440c3", "message": "Use CurrentState to calculate quota\n\nIn this commit, the new methods has been added to\nAssignableInstanceManager which allow controller\nto calculate quota based on CurrentState and\npending messages.", "committedDate": "2020-07-21T20:13:17Z", "type": "commit"}, {"oid": "6a93aa2f39d193f10b83ca6bc6764b171d2bb5cf", "url": "https://github.com/apache/helix/commit/6a93aa2f39d193f10b83ca6bc6764b171d2bb5cf", "message": "Add comments", "committedDate": "2020-07-22T03:12:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNTM0Mg==", "url": "https://github.com/apache/helix/pull/1165#discussion_r459715342", "bodyText": "Let's combine it:\nif (jobConfig == null || jobConfig.getJobType() == null) {\nreturn AssignableInstance.DEFAULT_QUOTA_TYPE;\n}\nreturn jobConfig.getJobType();", "author": "junkaixue", "createdAt": "2020-07-23T20:40:39Z", "path": "helix-core/src/main/java/org/apache/helix/task/AssignableInstanceManager.java", "diffHunk": "@@ -176,6 +181,178 @@ public void buildAssignableInstances(ClusterConfig clusterConfig, TaskDataCache\n     computeGlobalThreadBasedCapacity();\n   }\n \n+  /**\n+   * Builds AssignableInstances and restores TaskAssignResults from scratch by reading from\n+   * CurrentState. It re-computes current quota profile for each AssignableInstance.\n+   * If a task current state is INIT or RUNNING or if there is a pending message which it's ToState\n+   * is RUNNING, the task/partition will be assigned to AssignableInstances of the instance.\n+   * @param clusterConfig\n+   * @param taskDataCache\n+   * @param liveInstances\n+   * @param instanceConfigs\n+   * @param currentStateOutput\n+   * @param resourceMap\n+   */\n+  public void buildAssignableInstancesFromCurrentState(ClusterConfig clusterConfig,\n+      TaskDataCache taskDataCache, Map<String, LiveInstance> liveInstances,\n+      Map<String, InstanceConfig> instanceConfigs, CurrentStateOutput currentStateOutput,\n+      Map<String, Resource> resourceMap) {\n+    _assignableInstanceMap.clear();\n+    _taskAssignResultMap.clear();\n+\n+    // Create all AssignableInstance objects based on what's in liveInstances\n+    for (Map.Entry<String, LiveInstance> liveInstanceEntry : liveInstances.entrySet()) {\n+      // Prepare instance-specific metadata\n+      String instanceName = liveInstanceEntry.getKey();\n+      LiveInstance liveInstance = liveInstanceEntry.getValue();\n+      if (!instanceConfigs.containsKey(instanceName)) {\n+        continue; // Ill-formatted input; skip over this instance\n+      }\n+      InstanceConfig instanceConfig = instanceConfigs.get(instanceName);\n+\n+      // Create an AssignableInstance\n+      AssignableInstance assignableInstance =\n+          new AssignableInstance(clusterConfig, instanceConfig, liveInstance);\n+      _assignableInstanceMap.put(instanceConfig.getInstanceName(), assignableInstance);\n+      LOG.debug(\"AssignableInstance created for instance: {}\", instanceName);\n+    }\n+\n+    Map<String, JobConfig> jobConfigMap = taskDataCache.getJobConfigMap();\n+\n+    // Update task profiles by traversing all CurrentStates\n+    for (Map.Entry<String, Resource> resourceEntry : resourceMap.entrySet()) {\n+      String resourceName = resourceEntry.getKey();\n+      if (resourceEntry.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n+        JobConfig jobConfig = jobConfigMap.get(resourceName);\n+        JobContext jobContext = taskDataCache.getJobContext(resourceName);\n+        String quotaType = getQuotaType(jobConfig);\n+        Map<Partition, Map<String, String>> currentStateMap =\n+            currentStateOutput.getCurrentStateMap(resourceName);\n+        for (Map.Entry<Partition, Map<String, String>> currentStateMapEntry : currentStateMap\n+            .entrySet()) {\n+          Partition partition = currentStateMapEntry.getKey();\n+          String taskId = getTaskID(jobConfig, jobContext, partition);\n+          for (Map.Entry<String, String> instanceCurrentStateEntry : currentStateMapEntry.getValue()\n+              .entrySet()) {\n+            String assignedInstance = instanceCurrentStateEntry.getKey();\n+            String taskState = instanceCurrentStateEntry.getValue();\n+            // If a task in in INIT or RUNNING state on the instance, this task should occupy one\n+            // quota from this instance.\n+            if (taskState.equals(TaskPartitionState.INIT.name())\n+                || taskState.equals(TaskPartitionState.RUNNING.name())) {\n+              assignTaskToInstance(assignedInstance, jobConfig, taskId, quotaType);\n+            }\n+          }\n+        }\n+        Map<Partition, Map<String, Message>> pendingMessageMap =\n+            currentStateOutput.getPendingMessageMap(resourceName);\n+        for (Map.Entry<Partition, Map<String, Message>> pendingMessageMapEntry : pendingMessageMap\n+            .entrySet()) {\n+          Partition partition = pendingMessageMapEntry.getKey();\n+          String taskId = getTaskID(jobConfig, jobContext, partition);\n+          for (Map.Entry<String, Message> instancePendingMessageEntry : pendingMessageMapEntry\n+              .getValue().entrySet()) {\n+            String assignedInstance = instancePendingMessageEntry.getKey();\n+            String messageToState = instancePendingMessageEntry.getValue().getToState();\n+            // If there is a pending message on the instance which has ToState of RUNNING, the task\n+            // will run on the instance soon. So the task needs to occupy one quota on this instance.\n+            if (messageToState.equals(TaskPartitionState.RUNNING.name())\n+                && !TaskPartitionState.INIT.name().equals(\n+                    currentStateOutput.getCurrentState(resourceName, partition, assignedInstance))\n+                && !TaskPartitionState.RUNNING.name().equals(currentStateOutput\n+                    .getCurrentState(resourceName, partition, assignedInstance))) {\n+              assignTaskToInstance(assignedInstance, jobConfig, taskId, quotaType);\n+            }\n+          }\n+        }\n+      }\n+    }\n+    LOG.info(\n+        \"AssignableInstanceManager built AssignableInstances from scratch based on contexts in TaskDataCache due to Controller switch or ClusterConfig change.\");\n+    computeGlobalThreadBasedCapacity();\n+  }\n+\n+  /**\n+   * Assign the task to the instance's Assignable Instance\n+   * @param instance\n+   * @param jobConfig\n+   * @param taskId\n+   * @param quotaType\n+   */\n+  private void assignTaskToInstance(String instance, JobConfig jobConfig, String taskId,\n+      String quotaType) {\n+    if (_assignableInstanceMap.containsKey(instance)) {\n+      TaskConfig taskConfig = getTaskConfig(jobConfig, taskId);\n+      AssignableInstance assignableInstance = _assignableInstanceMap.get(instance);\n+      TaskAssignResult taskAssignResult =\n+          assignableInstance.restoreTaskAssignResult(taskId, taskConfig, quotaType);\n+      if (taskAssignResult.isSuccessful()) {\n+        _taskAssignResultMap.put(taskId, taskAssignResult);\n+        LOG.debug(\"TaskAssignResult restored for taskId: {}, assigned on instance: {}\", taskId,\n+            instance);\n+      }\n+    } else {\n+      LOG.debug(\n+          \"While building AssignableInstance map, discovered that the instance a task is assigned to is no \"\n+              + \"longer a LiveInstance! TaskAssignResult will not be created and no resource will be taken \"\n+              + \"up for this task. TaskId: {}, Instance: {}\",\n+          taskId, instance);\n+    }\n+  }\n+\n+  /**\n+   * Extract the quota type information of the Job\n+   * @param jobConfig\n+   * @return\n+   */\n+  private String getQuotaType(JobConfig jobConfig) {\n+    // If jobConfig is null (job has been deleted but participant has not dropped the task yet), use\n+    // default quota for the task\n+    if (jobConfig == null) {\n+      return AssignableInstance.DEFAULT_QUOTA_TYPE;\n+    }\n+    String quotaType = jobConfig.getJobType();\n+    if (quotaType == null) {\n+      quotaType = AssignableInstance.DEFAULT_QUOTA_TYPE;\n+    }", "originalCommit": "6a93aa2f39d193f10b83ca6bc6764b171d2bb5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1MzcyMg==", "url": "https://github.com/apache/helix/pull/1165#discussion_r459853722", "bodyText": "Done. Thanks.", "author": "alirezazamani", "createdAt": "2020-07-24T05:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNTM0Mg=="}], "type": "inlineReview"}, {"oid": "3f162822274b16e9aac5de0b35d034caf21d1d3c", "url": "https://github.com/apache/helix/commit/3f162822274b16e9aac5de0b35d034caf21d1d3c", "message": "Address the comments", "committedDate": "2020-07-23T21:40:28Z", "type": "commit"}, {"oid": "61a96b5ab97d959e3907512a0535d78ac52fb2f3", "url": "https://github.com/apache/helix/commit/61a96b5ab97d959e3907512a0535d78ac52fb2f3", "message": "Remove unused import", "committedDate": "2020-07-23T21:48:18Z", "type": "commit"}]}