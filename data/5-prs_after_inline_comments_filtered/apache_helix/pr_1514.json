{"pr_number": 1514, "pr_title": "Add default message handling retry count for state transition messages.", "pr_createdAt": "2020-11-06T19:17:28Z", "pr_url": "https://github.com/apache/helix/pull/1514", "timeline": [{"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "url": "https://github.com/apache/helix/commit/92b72efdc20b83f6393d26f16cc6b86533ae404f", "message": "Add default message handling retry count for state transition messages.\n\nThe retry count will be counted when message handler creation fails or state transition times out.\n\nIn addition, this PR also improves several ambiguous behaviors that may block a normal retry.\n1. The cache of known messages list in HelixTaskExecutor may not be updated correctly if a message is going to be retried.\n2. The retry count is not strictly followed in some conditions.\n3. The to-be-retried message won't be automatically read when there is no other new message changes.\n\nFinally, improve the tests to cover the new changes.", "committedDate": "2020-11-07T00:33:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3NzE3Nw==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520777177", "bodyText": "This function will trigger another event and retry the message, right? Why in the PR it said the message will not be automatically retried?", "author": "zhangmeng916", "createdAt": "2020-11-10T18:26:17Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -1288,6 +1308,19 @@ private void removeMessageFromZK(HelixDataAccessor accessor, Message message,\n     }\n   }\n \n+  private void sendNopMessage(HelixDataAccessor accessor, String instanceName) {", "originalCommit": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyMjEwNA==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520822104", "bodyText": "Oh yeah, good catch. I changed the design since during the test I find that would be a very bad way if we leave the message there and pray for some new messages coming.\nThe PR description is about what has been fixed. Let me make it more clear.", "author": "jiajunwang", "createdAt": "2020-11-10T19:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3NzE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3NzM0Ng==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520777346", "bodyText": "Can we have a more detailed error message here?", "author": "zhangmeng916", "createdAt": "2020-11-10T18:26:32Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -1288,6 +1308,19 @@ private void removeMessageFromZK(HelixDataAccessor accessor, Message message,\n     }\n   }\n \n+  private void sendNopMessage(HelixDataAccessor accessor, String instanceName) {\n+    try {\n+      Message nopMsg = new Message(MessageType.NO_OP, UUID.randomUUID().toString());\n+      nopMsg.setSrcName(instanceName);\n+      nopMsg.setTgtName(instanceName);\n+      accessor\n+          .setProperty(accessor.keyBuilder().message(nopMsg.getTgtName(), nopMsg.getId()), nopMsg);\n+      LOG.info(\"Send NO_OP message to \" + nopMsg.getTgtName() + \", msgId: \" + nopMsg.getId());\n+    } catch (Exception e) {\n+      LOG.error(e.toString());", "originalCommit": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyNDE0Mw==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520824143", "bodyText": "I agree, it was copy-pasted. Let me make it complete.", "author": "jiajunwang", "createdAt": "2020-11-10T19:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3NzM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3OTIwNw==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520779207", "bodyText": "The naming here makes me a bit confusing. This message is updated as NEW because it is cannot be processed right? Maybe call it MessageUpdatedAsNew or something.", "author": "zhangmeng916", "createdAt": "2020-11-10T18:29:49Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -521,29 +523,51 @@ public void finishTask(MessageTask task) {\n     }\n   }\n \n-  private void updateMessageState(List<Message> readMsgs, HelixDataAccessor accessor,\n+  private void updateMessageState(Collection<Message> msgsToBeUpdated, HelixDataAccessor accessor,\n       String instanceName) {\n-    Builder keyBuilder = accessor.keyBuilder();\n-    List<String> readMsgPaths = new ArrayList<>();\n-    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n-    for (Message msg : readMsgs) {\n-      readMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n-      _knownMessageIds.add(msg.getId());\n-      /**\n-       * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n-       * If there is no message at this path, meaning the message is removed so we do not write the message\n-       */\n-      updaters.add(currentData -> {\n-        if (currentData == null) {\n-          LOG.warn(\n-              \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n-              msg.getId(), msg.getTgtName(), instanceName);\n-          return null;\n-        }\n-        return msg.getRecord();\n-      });\n+    if (!msgsToBeUpdated.isEmpty()) {\n+      Builder keyBuilder = accessor.keyBuilder();\n+      List<String> updateMsgPaths = new ArrayList<>();\n+      List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n+      for (Message msg : msgsToBeUpdated) {\n+        updateMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n+        /**\n+         * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n+         * If there is no message at this path, meaning the message is removed so we do not write the message\n+         */\n+        updaters.add(currentData -> {\n+          if (currentData == null) {\n+            LOG.warn(\n+                \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n+                msg.getId(), msg.getTgtName(), instanceName);\n+            return null;\n+          }\n+          return msg.getRecord();\n+        });\n+      }\n+      accessor.updateChildren(updateMsgPaths, updaters, AccessOption.PERSISTENT);\n+    }\n+\n+    // Note that only cache the known message Ids after the update to ZK is successfully done.\n+    // This is to avoid inconsistent cache.\n+\n+    // if a message in \"NEW\" state is updated, then we might need to process it soon.\n+    boolean isNewMessageUpdated = false;", "originalCommit": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyNDU0OQ==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520824549", "bodyText": "Good name, let me change it.", "author": "jiajunwang", "createdAt": "2020-11-10T19:35:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3OTIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3OTQzMQ==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520779431", "bodyText": "same here: what does \"new and updated\" mean?", "author": "zhangmeng916", "createdAt": "2020-11-10T18:30:10Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -521,29 +523,51 @@ public void finishTask(MessageTask task) {\n     }\n   }\n \n-  private void updateMessageState(List<Message> readMsgs, HelixDataAccessor accessor,\n+  private void updateMessageState(Collection<Message> msgsToBeUpdated, HelixDataAccessor accessor,\n       String instanceName) {\n-    Builder keyBuilder = accessor.keyBuilder();\n-    List<String> readMsgPaths = new ArrayList<>();\n-    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n-    for (Message msg : readMsgs) {\n-      readMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n-      _knownMessageIds.add(msg.getId());\n-      /**\n-       * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n-       * If there is no message at this path, meaning the message is removed so we do not write the message\n-       */\n-      updaters.add(currentData -> {\n-        if (currentData == null) {\n-          LOG.warn(\n-              \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n-              msg.getId(), msg.getTgtName(), instanceName);\n-          return null;\n-        }\n-        return msg.getRecord();\n-      });\n+    if (!msgsToBeUpdated.isEmpty()) {\n+      Builder keyBuilder = accessor.keyBuilder();\n+      List<String> updateMsgPaths = new ArrayList<>();\n+      List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n+      for (Message msg : msgsToBeUpdated) {\n+        updateMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n+        /**\n+         * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n+         * If there is no message at this path, meaning the message is removed so we do not write the message\n+         */\n+        updaters.add(currentData -> {\n+          if (currentData == null) {\n+            LOG.warn(\n+                \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n+                msg.getId(), msg.getTgtName(), instanceName);\n+            return null;\n+          }\n+          return msg.getRecord();\n+        });\n+      }\n+      accessor.updateChildren(updateMsgPaths, updaters, AccessOption.PERSISTENT);\n+    }\n+\n+    // Note that only cache the known message Ids after the update to ZK is successfully done.\n+    // This is to avoid inconsistent cache.\n+\n+    // if a message in \"NEW\" state is updated, then we might need to process it soon.\n+    boolean isNewMessageUpdated = false;\n+    for (Message msg : msgsToBeUpdated) {\n+      if (msg.getMsgState().equals(MessageState.NEW)) {\n+        isNewMessageUpdated = true;\n+        // If a message is still \"NEW\", it is not a known message. The message may not be able to\n+        // processed now in an expected way.\n+      } else {\n+        // else, cache the known messages.\n+        _knownMessageIds.add(msg.getId());\n+      }\n+    }\n+    if (isNewMessageUpdated) {\n+      // Sending a NO-OP message to trigger another message callback to re-process the New and\n+      // updated messsages.", "originalCommit": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4MDU1MQ==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520780551", "bodyText": "\"negative\" doesn't match if condition.", "author": "zhangmeng916", "createdAt": "2020-11-10T18:32:14Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -821,32 +843,29 @@ public void onMessage(String instanceName, List<Message> messages,\n         LOG.error(\n             \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n             message.getMsgId(), remainingRetryCount);\n-        // Set the message retry count to avoid infinite retrying.\n+        // Reduce the message retry count to avoid infinite retrying.\n         message.setRetryCount(remainingRetryCount - 1);\n         message.setExecuteSessionId(sessionId);\n-        // continue processing in the next section where handler object is double-checked.\n-      }\n-\n-      if (msgHandler == null) {\n         // Note that we are re-using the retry count of Message that was original designed to control\n         // timeout retries. So it is not checked before the first try in order to ensure consistent\n         // behavior. It is possible that we introduce a new behavior for this method. But it requires\n         // us to split the configuration item so as to avoid confusion.\n-        if (message.getRetryCount() < 0) {\n+        if (message.getRetryCount() <= 0) {\n           // If no more retry count remains, then mark the message to be UNPROCESSABLE.\n-          String errorMsg = String\n-              .format(\"No available message Handler found!\"\n-                      + \" Stop processing message %s since it has a negative remaining retry count %d!\",\n-                  message.getMsgId(), message.getRetryCount());\n+          String errorMsg = String.format(\"No available message Handler found!\"\n+                  + \" Stop processing message %s since it has negative remaining retry count %d!\",", "originalCommit": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyNDkyMw==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520824923", "bodyText": "Good catch, I forget to change the comment after the code change.", "author": "jiajunwang", "createdAt": "2020-11-10T19:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4MDU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTA2Mg==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520811062", "bodyText": "Is this the same thing as the message attribute of retrying? Otherwise, we need an accurate name since it is the retry for state model creation.", "author": "junkaixue", "createdAt": "2020-11-10T19:12:28Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java", "diffHunk": "@@ -70,6 +70,8 @@\n       .getSystemPropertyAsLong(SystemPropertyKeys.CONTROLLER_MESSAGE_PURGE_DELAY, 60 * 1000);\n   private final static String PENDING_MESSAGE = \"pending message\";\n   private final static String STALE_MESSAGE = \"stale message\";\n+  // TODO: Make the message retry count configurable through the Cluster Config or IdealStates.\n+  public final static int DEFAULT_STATE_TRANSITION_MESSAGE_RETRY_COUNT = 3;", "originalCommit": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyNzE3NA==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520827174", "bodyText": "It is the same. So in theory it will be applied to the timeout condition too. Although ST message does not have a timeout setup for now, we may have it in the future. So make this name too explicit may be confusing as well. I propose to make it a general retry count for ST messages. But it is debatable. Let me know what's your thought.", "author": "jiajunwang", "createdAt": "2020-11-10T19:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMzYzMA==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520813630", "bodyText": "Why we dont move this check in the previous block? Since it already does the looping of the msgsToBeUpdated.", "author": "junkaixue", "createdAt": "2020-11-10T19:16:52Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -521,29 +523,51 @@ public void finishTask(MessageTask task) {\n     }\n   }\n \n-  private void updateMessageState(List<Message> readMsgs, HelixDataAccessor accessor,\n+  private void updateMessageState(Collection<Message> msgsToBeUpdated, HelixDataAccessor accessor,\n       String instanceName) {\n-    Builder keyBuilder = accessor.keyBuilder();\n-    List<String> readMsgPaths = new ArrayList<>();\n-    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n-    for (Message msg : readMsgs) {\n-      readMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n-      _knownMessageIds.add(msg.getId());\n-      /**\n-       * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n-       * If there is no message at this path, meaning the message is removed so we do not write the message\n-       */\n-      updaters.add(currentData -> {\n-        if (currentData == null) {\n-          LOG.warn(\n-              \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n-              msg.getId(), msg.getTgtName(), instanceName);\n-          return null;\n-        }\n-        return msg.getRecord();\n-      });\n+    if (!msgsToBeUpdated.isEmpty()) {\n+      Builder keyBuilder = accessor.keyBuilder();\n+      List<String> updateMsgPaths = new ArrayList<>();\n+      List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n+      for (Message msg : msgsToBeUpdated) {\n+        updateMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n+        /**\n+         * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n+         * If there is no message at this path, meaning the message is removed so we do not write the message\n+         */\n+        updaters.add(currentData -> {\n+          if (currentData == null) {\n+            LOG.warn(\n+                \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n+                msg.getId(), msg.getTgtName(), instanceName);\n+            return null;\n+          }\n+          return msg.getRecord();\n+        });\n+      }\n+      accessor.updateChildren(updateMsgPaths, updaters, AccessOption.PERSISTENT);\n+    }\n+\n+    // Note that only cache the known message Ids after the update to ZK is successfully done.\n+    // This is to avoid inconsistent cache.\n+\n+    // if a message in \"NEW\" state is updated, then we might need to process it soon.\n+    boolean isNewMessageUpdated = false;\n+    for (Message msg : msgsToBeUpdated) {", "originalCommit": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNDgxMw==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520834813", "bodyText": "Good point, I don't remember any limitation makes me do this. Let me have a try : )", "author": "jiajunwang", "createdAt": "2020-11-10T19:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMzYzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg1Mzk2NA==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520853964", "bodyText": "It turns out that I can move the check to the loop above, but I cannot remove the loop here after the update call. For the reason, please check the comment in code. Paste it here as well.\n\n// Note that only cache the known message Ids after the update to ZK is successfully done.\n// This is to avoid inconsistent cache.", "author": "jiajunwang", "createdAt": "2020-11-10T20:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMzYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4MzUxMA==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520783510", "bodyText": "We decided to get rid of sleep, right?", "author": "zhangmeng916", "createdAt": "2020-11-10T18:37:29Z", "path": "helix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java", "diffHunk": "@@ -563,23 +564,42 @@ public void testCreateHandlerException() throws InterruptedException {\n     HelixManager manager = new MockClusterManager();\n     HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n     PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n-\n-    TestMessageHandlerFactory factory = new TestMessageHandlerFactory();\n-    for (String type : factory.getMessageTypes()) {\n-      executor.registerMessageHandlerFactory(type, factory);\n-    }\n-\n     NotificationContext changeContext = new NotificationContext(manager);\n+    TestMessageHandlerFactory factory = new TestMessageHandlerFactory();\n \n+    // Sending message without registering the factory.\n+    // The message won't be processed since creating handler returns null.\n     int nMsgs1 = 5;\n+    List<Message> msgList = new ArrayList<>();\n     for (int i = 0; i < nMsgs1; i++) {\n       Message msg = new Message(factory.getMessageTypes().get(0), UUID.randomUUID().toString());\n       msg.setTgtSessionId(manager.getSessionId());\n       msg.setTgtName(\"Localhost_1123\");\n       msg.setSrcName(\"127.101.1.23_2234\");\n       msg.setCorrelationId(UUID.randomUUID().toString());\n       dataAccessor.setProperty(keyBuilder.message(manager.getInstanceName(), msg.getMsgId()), msg);\n+      msgList.add(msg);\n+    }\n+\n+    changeContext.setChangeType(HelixConstants.ChangeType.MESSAGE);\n+    executor.onMessage(manager.getInstanceName(), Collections.emptyList(), changeContext);\n+\n+    Thread.sleep(1000);", "originalCommit": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyOTYyMg==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520829622", "bodyText": "I think removing it will be fine. It was from some old code. Let me have a try.", "author": "jiajunwang", "createdAt": "2020-11-10T19:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4MzUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyNzU4MQ==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520827581", "bodyText": "You mean retried and succeeded finally, right?", "author": "zhangmeng916", "createdAt": "2020-11-10T19:40:56Z", "path": "helix-core/src/test/java/org/apache/helix/integration/paticipant/TestStateTransitionAppFailureHandling.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.integration.paticipant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixDefinedState;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.controller.stages.MessageGenerationPhase;\n+import org.apache.helix.integration.common.ZkStandAloneCMTestBase;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.mock.participant.MockMSStateModel;\n+import org.apache.helix.mock.participant.MockTransition;\n+import org.apache.helix.model.CurrentState;\n+import org.apache.helix.model.Message;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestStateTransitionAppFailureHandling extends ZkStandAloneCMTestBase {\n+  private static Logger LOG = LoggerFactory.getLogger(TestStateTransitionAppFailureHandling.class);\n+  private final static int REPLICAS = 3;\n+\n+  @Override\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    // Clean up the resource that is created in the super cluster beforeClass method.\n+    _gSetupTool.dropResourceFromCluster(CLUSTER_NAME, TEST_DB);\n+    _clusterVerifier.verifyByPolling();\n+  }\n+\n+  public static class RetryStateModelFactory extends StateModelFactory<MockMSStateModel> {\n+    int _retryCountUntilSucceed;\n+\n+    public RetryStateModelFactory(int retryCountUntilSucceed) {\n+      _retryCountUntilSucceed = retryCountUntilSucceed;\n+    }\n+\n+    public int getRemainingRetryCountUntilSucceed() {\n+      return _retryCountUntilSucceed;\n+    }\n+\n+    @Override\n+    public MockMSStateModel createNewStateModel(String resource, String stateUnitKey) {\n+      if (_retryCountUntilSucceed > 0) {\n+        _retryCountUntilSucceed--;\n+        throw new HelixException(\"You Shall Not PASS!!!\");\n+      } else {\n+        return new MockMSStateModel(new MockTransition());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSTHandlerInitFailureRetry() throws Exception {\n+    int retryCountUntilSucceed =\n+        Integer.MAX_VALUE; // ensure the retry count is large so the message retry will fail.\n+    Map<String, RetryStateModelFactory> retryFactoryMap = resetParticipants(retryCountUntilSucceed);\n+\n+    _gSetupTool.addResourceToCluster(CLUSTER_NAME, TEST_DB, _PARTITIONS, STATE_MODEL);\n+    _gSetupTool.rebalanceStorageCluster(CLUSTER_NAME, TEST_DB, REPLICAS);\n+\n+    HelixDataAccessor accessor = _controller.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    // Verify and wait until all messages have been retried and failed.\n+    Map<String, List<Message>> partitionMessageMap = new HashMap<>();\n+    Assert.assertTrue(TestHelper.verify(() -> {\n+      int totalMessageCount = 0;\n+      for (int i = 0; i < NODE_NR; i++) {\n+        String instanceName = _participants[i].getInstanceName();\n+        List<Message> messageList = accessor.getProperty(\n+            accessor.getChildNames(keyBuilder.messages(instanceName)).stream()\n+                .map(childName -> keyBuilder.message(instanceName, childName))\n+                .collect(Collectors.toList()), true);\n+        for (Message message : messageList) {\n+          if (message.getMsgState() != Message.MessageState.UNPROCESSABLE) {\n+            return false;\n+          }\n+        }\n+        partitionMessageMap.put(instanceName, messageList);\n+        totalMessageCount += messageList.size();\n+      }\n+      return totalMessageCount == _PARTITIONS * REPLICAS;\n+    }, TestHelper.WAIT_DURATION));\n+\n+    // Verify that the correct numbers of retry has been done on each node.\n+    for (String instanceName : partitionMessageMap.keySet()) {\n+      List<Message> instanceMessages = partitionMessageMap.get(instanceName);\n+      for (Message message : instanceMessages) {\n+        Assert.assertTrue(message.getRetryCount() <= 0);\n+        Assert.assertEquals(message.getMsgState(), Message.MessageState.UNPROCESSABLE);\n+      }\n+      // Check if the factory has tried enough times before fail the message.\n+      Assert.assertEquals(retryCountUntilSucceed - retryFactoryMap.get(instanceName)\n+          .getRemainingRetryCountUntilSucceed(), instanceMessages.size()\n+          * MessageGenerationPhase.DEFAULT_STATE_TRANSITION_MESSAGE_RETRY_COUNT);\n+    }\n+\n+    // Verify that the partition is not initialized.\n+    for (int i = 0; i < NODE_NR; i++) {\n+      String instanceName = _participants[i].getInstanceName();\n+      String sessionId = _participants[i].getSessionId();\n+      List<CurrentState> currentStates = accessor.getProperty(\n+          accessor.getChildNames(keyBuilder.currentStates(instanceName, sessionId)).stream()\n+              .map(childName -> keyBuilder.currentState(instanceName, sessionId, childName))\n+              .collect(Collectors.toList()), true);\n+      for (CurrentState currentState : currentStates) {\n+        Assert.assertTrue(currentState.getPartitionStateMap().isEmpty());\n+      }\n+    }\n+\n+    _gSetupTool.dropResourceFromCluster(CLUSTER_NAME, TEST_DB);\n+  }\n+\n+  @Test(dependsOnMethods = \"testSTHandlerInitFailureRetry\")\n+  public void testSTHandlerInitFailureRetrySucceed() {\n+    // Make the mock StateModelFactory return handler before last retry. So it will successfully\n+    // finish handler initialization.\n+    int retryCountUntilSucceed =\n+        MessageGenerationPhase.DEFAULT_STATE_TRANSITION_MESSAGE_RETRY_COUNT - 1;\n+    Map<String, RetryStateModelFactory> retryFactoryMap = resetParticipants(retryCountUntilSucceed);\n+\n+    _gSetupTool.addResourceToCluster(CLUSTER_NAME, TEST_DB, _PARTITIONS, STATE_MODEL);\n+    _gSetupTool.rebalanceStorageCluster(CLUSTER_NAME, TEST_DB, REPLICAS);\n+\n+    HelixDataAccessor accessor = _controller.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    // Verify and wait until all messages have been retried and failed.", "originalCommit": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NzY4NA==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520867684", "bodyText": "Fixed.", "author": "jiajunwang", "createdAt": "2020-11-10T20:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyNzU4MQ=="}], "type": "inlineReview"}, {"oid": "e21f924502dd7976dcb1b9ee412c895e2367e1f1", "url": "https://github.com/apache/helix/commit/e21f924502dd7976dcb1b9ee412c895e2367e1f1", "message": "Add default message handling retry count for state transition messages.\n\nThe retry count will be counted when message handler creation fails or state transition times out.\n\nIn addition, this PR also improves several ambiguous behaviors that may block a normal retry.\n1. The cache of known messages list in HelixTaskExecutor may not be updated correctly if a message is going to be retried.\n2. The retry count is not strictly followed in some conditions.\n3. The to-be-retried message won't be automatically read when there is no other new message changes.\n\nFinally, improve the tests to cover the new changes.", "committedDate": "2020-11-10T20:47:17Z", "type": "commit"}, {"oid": "00971c049c0540a0a32e7f27fe553ac578d24ec7", "url": "https://github.com/apache/helix/commit/00971c049c0540a0a32e7f27fe553ac578d24ec7", "message": "Address comment.", "committedDate": "2020-11-10T20:51:57Z", "type": "forcePushed"}, {"oid": "58a04489fcb2dcbf07495708924669a02c2a0c6f", "url": "https://github.com/apache/helix/commit/58a04489fcb2dcbf07495708924669a02c2a0c6f", "message": "Address comment.", "committedDate": "2020-11-10T20:55:34Z", "type": "forcePushed"}, {"oid": "be3f7fab44a209ada7fc21f5de00d0286ef43b0d", "url": "https://github.com/apache/helix/commit/be3f7fab44a209ada7fc21f5de00d0286ef43b0d", "message": "Address comment.", "committedDate": "2020-11-10T21:09:47Z", "type": "forcePushed"}, {"oid": "35aec6dc57057a2aec3d35d2138208235a96289f", "url": "https://github.com/apache/helix/commit/35aec6dc57057a2aec3d35d2138208235a96289f", "message": "Address comment.", "committedDate": "2020-11-10T21:14:27Z", "type": "commit"}, {"oid": "35aec6dc57057a2aec3d35d2138208235a96289f", "url": "https://github.com/apache/helix/commit/35aec6dc57057a2aec3d35d2138208235a96289f", "message": "Address comment.", "committedDate": "2020-11-10T21:14:27Z", "type": "forcePushed"}, {"oid": "aca1653a8639de281a590cd5b62365307ea6a2a6", "url": "https://github.com/apache/helix/commit/aca1653a8639de281a590cd5b62365307ea6a2a6", "message": "Avoid modifying the message update logic.", "committedDate": "2020-11-10T23:22:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjExNQ==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520936115", "bodyText": "On my second thought, I think this is dangerous since changed the behavior unnecessarily. Let me just log in this case instead of modifying the original logic.", "author": "jiajunwang", "createdAt": "2020-11-10T23:19:17Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -525,47 +525,51 @@ public void finishTask(MessageTask task) {\n \n   private void updateMessageState(Collection<Message> msgsToBeUpdated, HelixDataAccessor accessor,\n       String instanceName) {\n-    if (!msgsToBeUpdated.isEmpty()) {\n-      Builder keyBuilder = accessor.keyBuilder();\n-      List<String> updateMsgPaths = new ArrayList<>();\n-      List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n-      for (Message msg : msgsToBeUpdated) {\n-        updateMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n-        /**\n-         * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n-         * If there is no message at this path, meaning the message is removed so we do not write the message\n-         */\n-        updaters.add(currentData -> {\n-          if (currentData == null) {\n-            LOG.warn(\n-                \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n-                msg.getId(), msg.getTgtName(), instanceName);\n-            return null;\n-          }\n-          return msg.getRecord();\n-        });\n-      }\n-      accessor.updateChildren(updateMsgPaths, updaters, AccessOption.PERSISTENT);\n+    if (msgsToBeUpdated.isEmpty()) {\n+      return;\n+    }\n+\n+    Builder keyBuilder = accessor.keyBuilder();\n+    List<Message> updateMsgs = new ArrayList<>();\n+    List<String> updateMsgPaths = new ArrayList<>();\n+    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n+    for (Message msg : msgsToBeUpdated) {\n+      updateMsgs.add(msg);\n+      updateMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n+      /**\n+       * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n+       * If there is no message at this path, meaning the message is removed so we do not write the message\n+       */\n+      updaters.add(currentData -> {\n+        if (currentData == null) {\n+          LOG.warn(\n+              \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n+              msg.getId(), msg.getTgtName(), instanceName);\n+          return null;\n+        }\n+        return msg.getRecord();\n+      });\n     }\n+    boolean[] updateResults =\n+        accessor.updateChildren(updateMsgPaths, updaters, AccessOption.PERSISTENT);\n \n+    boolean isMessageUpdatedAsNew = false;\n     // Note that only cache the known message Ids after the update to ZK is successfully done.\n     // This is to avoid inconsistent cache.\n-\n-    // if a message in \"NEW\" state is updated, then we might need to process it soon.\n-    boolean isNewMessageUpdated = false;\n-    for (Message msg : msgsToBeUpdated) {\n+    for (int i = 0; i < updateMsgs.size(); i++) {\n+      Message msg = updateMsgs.get(i);\n       if (msg.getMsgState().equals(MessageState.NEW)) {\n-        isNewMessageUpdated = true;\n-        // If a message is still \"NEW\", it is not a known message. The message may not be able to\n-        // processed now in an expected way.\n-      } else {\n-        // else, cache the known messages.\n+        // If a message is updated as NEW state, then we might need to process it again soon.\n+        isMessageUpdatedAsNew = true;\n+        // And it shall not be treated as a known messages.\n+      } else if (updateResults[i]) {", "originalCommit": "35aec6dc57057a2aec3d35d2138208235a96289f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3Nzg5Ng==", "url": "https://github.com/apache/helix/pull/1514#discussion_r520977896", "bodyText": "+1  I was thinking that an additional log for this case would be helpful.", "author": "alirezazamani", "createdAt": "2020-11-11T01:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjExNQ=="}], "type": "inlineReview"}]}