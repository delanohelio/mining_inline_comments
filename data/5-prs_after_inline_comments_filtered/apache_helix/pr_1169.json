{"pr_number": 1169, "pr_title": "Dynamically Load Tasks in Task Framework", "pr_createdAt": "2020-07-24T01:52:48Z", "pr_url": "https://github.com/apache/helix/pull/1169", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyODU4Ng==", "url": "https://github.com/apache/helix/pull/1169#discussion_r460228586", "bodyText": "If this path doesn't exist, does it throw exception here or return null? If exception, do we need to handle the exception? If null, we need to do a check in the next line of code to prevent NPE.", "author": "mgao0", "createdAt": "2020-07-24T18:47:21Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +289,36 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads Task and TaskFactory classes for command input\n+   */\n+  private boolean loadNewTask(String command) {\n+    try {\n+      // Read ZNRecord containing task definition information.\n+      ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()", "originalCommit": "7d076de23fbff1cf93b7ebf44715b71f0f1fe94a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI4NDU0NA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r460284544", "bodyText": "Thank you, Molly. Good catch! I think I should add the appropriate option to throw exception and then handle it.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n          \n          \n            \n                  ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n          \n          \n            \n                      .get(\"/\" + _manager.getClusterName() + \"/TASK_DEFINITION\",\n          \n          \n            \n                          null, AccessOption.THROW_EXCEPTION_IFNOTEXIST);", "author": "rabashizade", "createdAt": "2020-07-24T20:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyODU4Ng=="}], "type": "inlineReview"}, {"oid": "a50d49e575919008b023e2af54a908b43143cc72", "url": "https://github.com/apache/helix/commit/a50d49e575919008b023e2af54a908b43143cc72", "message": "[HELIX-1168] Handle ZkNoNodeException in loadNewTask()\n\nIn loadNewTask(), throw and handle ZkNoNodeException for non-existent\ntaskConfig ZNRecord. Additionally, handle HelixException for\n_manager.getHelixDataAccessor() and NullPointerException for file\naccess.", "committedDate": "2020-07-24T21:12:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0MTY3MA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461041670", "bodyText": "Let's use proper scope identifiers like private or final", "author": "narendly", "createdAt": "2020-07-27T17:10:52Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.zookeeper.CreateMode;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  HelixManager _manager;\n+  MockParticipantManager _participant;\n+  ClusterControllerManager _controller;\n+  String _clusterName;", "originalCommit": "a50d49e575919008b023e2af54a908b43143cc72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0MzQ0Nw==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461043447", "bodyText": "It's a code smell and not good style to catch so many types of exceptions. Also, catching a runtime exception like NullPointerException is awkward. A way to work around this is to break up your loadTask function into smaller methods and deal with different failure scenarios there.", "author": "narendly", "createdAt": "2020-07-27T17:14:07Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +292,38 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads Task and TaskFactory classes for command input\n+   */\n+  private boolean loadNewTask(String command) {\n+    try {\n+      // Read ZNRecord containing task definition information.\n+      ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n+          .get(\"/\" + _manager.getClusterName() + \"/TASK_DEFINITION\",\n+              null, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+\n+      // Open the JAR file and import Task(s) and TaskFactory classes.\n+      File taskJar = new File(taskConfig.getSimpleField(\"JAR_FILE\"));\n+      URL taskJarUrl = taskJar.toURI().toURL();\n+\n+      // Import Task(s) and TaskFactory classes.\n+      URLClassLoader classLoader = URLClassLoader.newInstance(new URL[]{taskJarUrl});\n+      for(String taskClass : taskConfig.getListField(\"TASK_CLASSES\")) {\n+        classLoader.loadClass(taskClass);\n+      }\n+      Class cl = classLoader.loadClass(taskConfig.getSimpleField(\"TASKFACTORY\"));\n+\n+      // Register the TaskFactory.\n+      _taskFactoryRegistry.put(command, (TaskFactory) cl.newInstance());\n+    } catch (MalformedURLException | ClassNotFoundException | InstantiationException\n+        | IllegalAccessException | ZkNoNodeException | NullPointerException | HelixException e) {", "originalCommit": "a50d49e575919008b023e2af54a908b43143cc72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0NDQ4NA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461044484", "bodyText": "Is there a better way to design this method signature - instead of returning a boolean?", "author": "narendly", "createdAt": "2020-07-27T17:15:43Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +292,38 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads Task and TaskFactory classes for command input\n+   */\n+  private boolean loadNewTask(String command) {", "originalCommit": "a50d49e575919008b023e2af54a908b43143cc72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0NDU4Mg==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461044582", "bodyText": "Let's use a proper JavaDoc block.", "author": "narendly", "createdAt": "2020-07-27T17:15:54Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +292,38 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads Task and TaskFactory classes for command input\n+   */", "originalCommit": "a50d49e575919008b023e2af54a908b43143cc72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0NTU0NA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461045544", "bodyText": "My suggestion here for you is to read about \"magic strings\" or magic numbers and understand why they could be bad. https://help.semmle.com/wiki/display/JAVA/Magic+strings%3A+use+defined+constant", "author": "narendly", "createdAt": "2020-07-27T17:17:35Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +292,38 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads Task and TaskFactory classes for command input\n+   */\n+  private boolean loadNewTask(String command) {\n+    try {\n+      // Read ZNRecord containing task definition information.\n+      ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n+          .get(\"/\" + _manager.getClusterName() + \"/TASK_DEFINITION\",\n+              null, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+\n+      // Open the JAR file and import Task(s) and TaskFactory classes.\n+      File taskJar = new File(taskConfig.getSimpleField(\"JAR_FILE\"));\n+      URL taskJarUrl = taskJar.toURI().toURL();\n+\n+      // Import Task(s) and TaskFactory classes.\n+      URLClassLoader classLoader = URLClassLoader.newInstance(new URL[]{taskJarUrl});\n+      for(String taskClass : taskConfig.getListField(\"TASK_CLASSES\")) {\n+        classLoader.loadClass(taskClass);\n+      }\n+      Class cl = classLoader.loadClass(taskConfig.getSimpleField(\"TASKFACTORY\"));", "originalCommit": "a50d49e575919008b023e2af54a908b43143cc72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0NzM2OA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461047368", "bodyText": "Instead of doing this, you could check whether taskConfig is null.", "author": "narendly", "createdAt": "2020-07-27T17:20:44Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +292,38 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads Task and TaskFactory classes for command input\n+   */\n+  private boolean loadNewTask(String command) {\n+    try {\n+      // Read ZNRecord containing task definition information.\n+      ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n+          .get(\"/\" + _manager.getClusterName() + \"/TASK_DEFINITION\",\n+              null, AccessOption.THROW_EXCEPTION_IFNOTEXIST);", "originalCommit": "a50d49e575919008b023e2af54a908b43143cc72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDQ1OA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461210458", "bodyText": "Thank you for the comments, Hunter. I'll use them all in the next commit.", "author": "rabashizade", "createdAt": "2020-07-27T22:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0NzM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE2NzMxMQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461167311", "bodyText": "Thanks for the PR. Good job ;-)\nIs there any way to make sure the functionality of this PR? Do we need to have some sort of assert/statement to make sure it works?", "author": "alirezazamani", "createdAt": "2020-07-27T21:01:12Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.zookeeper.CreateMode;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  HelixManager _manager;\n+  MockParticipantManager _participant;\n+  ClusterControllerManager _controller;\n+  String _clusterName;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory.getZKHelixManager(_clusterName, \"Admin\",\n+        InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    String instanceName = \"localhost_12913\";\n+    _gSetupTool.addInstanceToCluster(_clusterName, instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, instanceName);\n+    StateModelFactory<StateModel> stateModelFactory = new MasterSlaveStateModelFactory(instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+\n+    // Add task definition information as a ZNRecord.\n+    ZNRecord configZnRecord = new ZNRecord(_participant.getInstanceName());\n+    configZnRecord.setSimpleField(\"JAR_FILE\", \"src/test/resources/Reindex.jar\");\n+    configZnRecord.setSimpleField(\"VERSION\", \"1.0.0\");\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    configZnRecord.setListField(\"TASK_CLASSES\", taskClasses);\n+    configZnRecord.setSimpleField(\"TASKFACTORY\", \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = String.format(\"/%s/%s\", _clusterName, \"TASK_DEFINITION\");\n+    _participant.getZkClient().create(path, configZnRecord, CreateMode.PERSISTENT);\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    String workflowName = TestHelper.getTestMethodName();\n+    TaskDriver driver = new TaskDriver(_manager);\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+\n+    Thread.sleep(2000);", "originalCommit": "a50d49e575919008b023e2af54a908b43143cc72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDIwMw==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461210203", "bodyText": "Thank you, Ali. Great point, will fix it in the next commit.", "author": "rabashizade", "createdAt": "2020-07-27T22:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE2NzMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcxOTIzNQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461719235", "bodyText": "This method is still doing too many things, and some parts of the inner logic could be refactored out for clarity, conciseness, and testability. I recommend you take a look at some publicly available good programming practices to get a sense of what good, maintainable code looks like as well.", "author": "narendly", "createdAt": "2020-07-28T16:37:04Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +294,63 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and register the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {", "originalCommit": "53fa31da58e4b2af093422c3344839ec300c81b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyMzUxMg==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461723512", "bodyText": "Nit: Rename to something like TASK_JAR_FILE_KEY?", "author": "narendly", "createdAt": "2020-07-28T16:44:03Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -43,6 +49,11 @@\n   private ScheduledFuture timeout_task;\n   private TaskRunner _taskRunner;\n   private final ScheduledExecutorService _timeoutTaskExecutor;\n+  public static final String TASK_JAR_FILE = \"JAR_FILE\";", "originalCommit": "53fa31da58e4b2af093422c3344839ec300c81b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyNDIwNg==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461724206", "bodyText": "This code doesn't seem like it's been formatted properly.", "author": "narendly", "createdAt": "2020-07-28T16:45:10Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +294,63 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and register the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {\n+    // Read ZNRecord containing task definition information.\n+    ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .get(\"/\" + _manager.getClusterName() + \"/\" + TASK_PATH + \"_\" + command,null, 0);\n+    if(taskConfig == null) {\n+      LOG.info(\"Failed to read ZNRecord for task \" + command + \" for instance \" + _manager.getInstanceName()\n+          + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"No ZNRecord for task \" + command);\n+    }\n+\n+    // Open the JAR file containing Task(s) and TaskFactory classes.\n+    File taskJar;\n+    URL taskJarUrl;\n+    try {\n+      taskJar = new File(taskConfig.getSimpleField(TASK_JAR_FILE));\n+      if(taskJar.exists() && !taskJar.isDirectory()) {\n+        taskJarUrl = taskJar.toURI().toURL();\n+      } else {\n+        throw new IllegalStateException(\"No JAR for task \" + command);\n+      }\n+    } catch (MalformedURLException e) {\n+      LOG.info(\"Failed to find/open JAR for new task \" + command + \" for instance \" + _manager.getInstanceName()\n+          + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"Malformed JAR URL for task \" + command);\n+    }\n+\n+    // Import Task(s) and TaskFactory classes.\n+    URLClassLoader classLoader = URLClassLoader.newInstance(new URL[]{taskJarUrl});\n+    for(String taskClass : taskConfig.getListField(TASK_CLASSES)) {\n+      try {\n+        classLoader.loadClass(taskClass);\n+      } catch(ClassNotFoundException e) {\n+        LOG.info(\"Failed to load class(es) for new task \" + command + \" for instance \" + _manager.getInstanceName()\n+            + \" in cluster \" + _manager.getClusterName() + \".\");\n+        throw new IllegalStateException(\"Null class(es) for task \" + command);\n+      }\n+    }\n+    Class cl;\n+    TaskFactory tf;\n+    try {\n+      cl = classLoader.loadClass(taskConfig.getSimpleField(TASK_FACTORY));\n+      tf = (TaskFactory)cl.newInstance();\n+    } catch(ClassNotFoundException | InstantiationException | IllegalAccessException e) {", "originalCommit": "53fa31da58e4b2af093422c3344839ec300c81b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyNDk0MQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461724941", "bodyText": "LOG level should be error instead of info because you're treating this as an exception?", "author": "narendly", "createdAt": "2020-07-28T16:46:25Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +294,63 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and register the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {\n+    // Read ZNRecord containing task definition information.\n+    ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .get(\"/\" + _manager.getClusterName() + \"/\" + TASK_PATH + \"_\" + command,null, 0);\n+    if(taskConfig == null) {\n+      LOG.info(\"Failed to read ZNRecord for task \" + command + \" for instance \" + _manager.getInstanceName()", "originalCommit": "53fa31da58e4b2af093422c3344839ec300c81b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyNzM4MA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461727380", "bodyText": "Since loading the JAR from the local directory is not a permanent solution and rather not very useful, consider using Java Interface to make this pluggable. That's a better design principle and will allow you to extend your code more easily. The way it's hard-coded right now, it will be difficult to change the underlying implementation for the jar loader.", "author": "narendly", "createdAt": "2020-07-28T16:50:05Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +294,63 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and register the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {\n+    // Read ZNRecord containing task definition information.\n+    ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .get(\"/\" + _manager.getClusterName() + \"/\" + TASK_PATH + \"_\" + command,null, 0);\n+    if(taskConfig == null) {\n+      LOG.info(\"Failed to read ZNRecord for task \" + command + \" for instance \" + _manager.getInstanceName()\n+          + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"No ZNRecord for task \" + command);\n+    }\n+\n+    // Open the JAR file containing Task(s) and TaskFactory classes.\n+    File taskJar;", "originalCommit": "53fa31da58e4b2af093422c3344839ec300c81b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyODMyMg==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461728322", "bodyText": "Overall, the code still feels like a \"script\" - to make this more amenable for use in production, let's work on making it maintainable and extendable :)", "author": "narendly", "createdAt": "2020-07-28T16:51:43Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -43,6 +49,11 @@\n   private ScheduledFuture timeout_task;\n   private TaskRunner _taskRunner;\n   private final ScheduledExecutorService _timeoutTaskExecutor;\n+  public static final String TASK_JAR_FILE = \"JAR_FILE\";\n+  public static final String TASK_VERSION = \"VERSION\";\n+  public static final String TASK_CLASSES = \"TASK_CLASSES\";\n+  public static final String TASK_FACTORY = \"TASKFACTORY\";\n+  public static final String TASK_PATH = \"TASK_DEFINITION\";", "originalCommit": "53fa31da58e4b2af093422c3344839ec300c81b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczMDk1Mg==", "url": "https://github.com/apache/helix/pull/1169#discussion_r461730952", "bodyText": "One suggestion here is to make the dynamic Task config a typed ZNRecord. Consider creating a record class that extends ZNRecord (and call it DynamicTaskConfig) that explicitly defines the fields you need to describe a dynamic task.\nHelixProperty is one such example.", "author": "narendly", "createdAt": "2020-07-28T16:55:58Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.zookeeper.CreateMode;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory.getZKHelixManager(_clusterName, \"Admin\",\n+        InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory = new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName,null);\n+    _controller.syncStart();\n+\n+    // Add task definition information as a ZNRecord.\n+    ZNRecord configZnRecord = new ZNRecord(_participant.getInstanceName());", "originalCommit": "53fa31da58e4b2af093422c3344839ec300c81b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA3MTgzMg==", "url": "https://github.com/apache/helix/pull/1169#discussion_r462071832", "bodyText": "Also to add, it might be a good idea to have a separate PR for this new type of ZNRecord.", "author": "narendly", "createdAt": "2020-07-29T06:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczMDk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxNTkxOA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r463815918", "bodyText": "Let's start with this PR. You can create an API folder under task. Move the interface to API module.", "author": "junkaixue", "createdAt": "2020-07-31T20:18:14Z", "path": "helix-core/src/main/java/org/apache/helix/task/JarLoader.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.net.URL;\n+\n+/**\n+ * The interface that is to be implemented by a specific JAR loader.\n+ */\n+public interface JarLoader {", "originalCommit": "522de9b1866f0d3d37f125003198ea268943ccf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxNjI5NA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r463816294", "bodyText": "else clause is not necessary. You can directly put\nLOG.error(\"Failed to find JAR \" + jar + \" for new task.\");\nthrow new IllegalStateException(\"No JAR for task\");\nBecause if the return is not happening, it will reaches the exception part.", "author": "junkaixue", "createdAt": "2020-07-31T20:19:16Z", "path": "helix-core/src/main/java/org/apache/helix/task/LocalJarLoader.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.File;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LocalJarLoader implements JarLoader {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalJarLoader.class);\n+\n+  @Override\n+  public URL openJar(String jar) {\n+    File taskJar;\n+    try {\n+      taskJar = new File(jar);\n+      if (taskJar.exists() && !taskJar.isDirectory()) {\n+        return taskJar.toURI().toURL();\n+      } else {", "originalCommit": "522de9b1866f0d3d37f125003198ea268943ccf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxNjQ2Mg==", "url": "https://github.com/apache/helix/pull/1169#discussion_r463816462", "bodyText": "Let's move these two TaskConstants class.", "author": "junkaixue", "createdAt": "2020-07-31T20:19:41Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -43,6 +46,11 @@\n   private ScheduledFuture timeout_task;\n   private TaskRunner _taskRunner;\n   private final ScheduledExecutorService _timeoutTaskExecutor;\n+  public static final String TASK_JAR_FILE_KEY = \"JAR_FILE\";\n+  public static final String TASK_VERSION_KEY = \"VERSION\";\n+  public static final String TASK_CLASSES_KEY = \"TASK_CLASSES\";\n+  public static final String TASK_FACTORY_KEY = \"TASKFACTORY\";\n+  public static final String TASK_PATH = \"/TASK_DEFINITION\";", "originalCommit": "522de9b1866f0d3d37f125003198ea268943ccf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxODI3OQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r463818279", "bodyText": "I would suggestion to make this feature optional. If there is no folder created for \"TASK_DEFINITON\", let's skip the steps. Otherwise, it could bring potential risks.", "author": "junkaixue", "createdAt": "2020-07-31T20:23:52Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +297,63 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads className using classLoader\n+   * @param classLoader\n+   * @param className\n+   * @return Class className loaded by classLoader\n+   */\n+  private Class loadClass(URLClassLoader classLoader, String className) {\n+    try {\n+      return classLoader.loadClass(className);\n+    } catch (ClassNotFoundException e) {\n+      LOG.error(\"Failed to load Task class \" + className + \" for new task in instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"Null TaskFactory for task\");\n+    }\n+  }\n+\n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and registers the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {\n+    // Read ZNRecord containing task definition information.\n+    ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .get(TASK_PATH + \"/\" + command, null, 0);", "originalCommit": "522de9b1866f0d3d37f125003198ea268943ccf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NTYyMQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r463885621", "bodyText": "Thank you for your comments, Junkai. So do you think something like this at the beginning of the method would do?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n          \n          \n            \n                    .get(TASK_PATH + \"/\" + command, null, 0);\n          \n          \n            \n                // If the path for dynamic tasks doesn't exist, skip loading the task\n          \n          \n            \n                if (!_manager.getHelixDataAccessor().getBaseDataAccessor().exists(TaskConstants.TASK_PATH, 0)) {\n          \n          \n            \n                  return;\n          \n          \n            \n                }\n          \n          \n            \n                ZNRecord taskConfig = _manager.getHelixDataAccessor().getBaseDataAccessor()\n          \n          \n            \n                    .get(TASK_PATH + \"/\" + command, null, 0);", "author": "rabashizade", "createdAt": "2020-07-31T23:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxODI3OQ=="}], "type": "inlineReview"}, {"oid": "159f2448119f868b3a077a048f699f79bbcc6a7e", "url": "https://github.com/apache/helix/commit/159f2448119f868b3a077a048f699f79bbcc6a7e", "message": "[HELIX-1168] Dynamically load tasks in Task Framework\n\nAdd loadNewTask() method to TaskStateModel.java to dynamically load\ntasks that are not already defined in task factory registry.\n\nThis prevents the need to implement task-specific Participants and\nthus, enables numerous use cases with minimal extra coding effort\nbeyond implementing the task logic itself.", "committedDate": "2020-08-04T17:45:16Z", "type": "commit"}, {"oid": "9ae58d301cc4e6db1db9a907463331da89908cc7", "url": "https://github.com/apache/helix/commit/9ae58d301cc4e6db1db9a907463331da89908cc7", "message": "[HELIX-1168] Handle ZkNoNodeException in loadNewTask()\n\nIn loadNewTask(), throw and handle ZkNoNodeException for non-existent\ntaskConfig ZNRecord. Additionally, handle HelixException for\n_manager.getHelixDataAccessor() and NullPointerException for file\naccess.", "committedDate": "2020-08-04T17:45:16Z", "type": "commit"}, {"oid": "8ed8da36d70d0734533e468f766da00994547429", "url": "https://github.com/apache/helix/commit/8ed8da36d70d0734533e468f766da00994547429", "message": "Fix test assert, task ZK path, exception handling\n\nAdd assertion to test to check for task status which indicates success.\n\nFix the task ZNRecord path to be task-specific.\n\nClean the exception handling in loadNewTask().", "committedDate": "2020-08-04T17:45:16Z", "type": "commit"}, {"oid": "0a770a8d9c59e016ef873a0d12410cbf2c76493d", "url": "https://github.com/apache/helix/commit/0a770a8d9c59e016ef873a0d12410cbf2c76493d", "message": "Throw exceptions when loadNewTask() fails\n\nInstead of simply returning from loadNewTask() when it fails, throw\nappropriate exceptions.", "committedDate": "2020-08-04T17:45:16Z", "type": "commit"}, {"oid": "efa48a2299299144c26921ebb7e8de324c298be7", "url": "https://github.com/apache/helix/commit/efa48a2299299144c26921ebb7e8de324c298be7", "message": "Generalize JAR loader, add more tests, fix format\n\nAdds JarLoader interface which generalizes the JAR loading, and adds\nan implementation LocalJarLoader that loads a JAR file from local\ndirectory.\n\nAlso adds more tests for different types of failures. Additionally,\nfixes code formatting issues.", "committedDate": "2020-08-04T17:45:16Z", "type": "commit"}, {"oid": "e47f33315a4bf90ec9b447aba9ef656a0ce6b88a", "url": "https://github.com/apache/helix/commit/e47f33315a4bf90ec9b447aba9ef656a0ce6b88a", "message": "Make dynamic task loading optional, clean up code\n\nMakes dynamically loading tasks optional by skipping the process if the\nfolder for task definitions doesn't exist in ZooKeeper.\n\nAlso cleans up and organizes some code, and reverses some unnecessary\nformatting.", "committedDate": "2020-08-04T17:45:16Z", "type": "commit"}, {"oid": "e47f33315a4bf90ec9b447aba9ef656a0ce6b88a", "url": "https://github.com/apache/helix/commit/e47f33315a4bf90ec9b447aba9ef656a0ce6b88a", "message": "Make dynamic task loading optional, clean up code\n\nMakes dynamically loading tasks optional by skipping the process if the\nfolder for task definitions doesn't exist in ZooKeeper.\n\nAlso cleans up and organizes some code, and reverses some unnecessary\nformatting.", "committedDate": "2020-08-04T17:45:16Z", "type": "forcePushed"}, {"oid": "4eba6047d72e19ec5af25a87d6e7533aee10b4ac", "url": "https://github.com/apache/helix/commit/4eba6047d72e19ec5af25a87d6e7533aee10b4ac", "message": "[HELIX-1168] Dynamically load tasks in Task Framework\n\nAdd loadNewTask() method to TaskStateModel.java to dynamically load\ntasks that are not already defined in task factory registry.\n\nThis prevents the need to implement task-specific Participants and\nthus, enables numerous use cases with minimal extra coding effort\nbeyond implementing the task logic itself.", "committedDate": "2020-08-12T16:36:54Z", "type": "commit"}, {"oid": "a467d1fbab882d7bb092ebe61f4b55a8a77ce2a6", "url": "https://github.com/apache/helix/commit/a467d1fbab882d7bb092ebe61f4b55a8a77ce2a6", "message": "[HELIX-1168] Handle ZkNoNodeException in loadNewTask()\n\nIn loadNewTask(), throw and handle ZkNoNodeException for non-existent\ntaskConfig ZNRecord. Additionally, handle HelixException for\n_manager.getHelixDataAccessor() and NullPointerException for file\naccess.", "committedDate": "2020-08-12T16:36:54Z", "type": "commit"}, {"oid": "0800e1790be624623f32fda73fba06093f1150f0", "url": "https://github.com/apache/helix/commit/0800e1790be624623f32fda73fba06093f1150f0", "message": "Fix test assert, task ZK path, exception handling\n\nAdd assertion to test to check for task status which indicates success.\n\nFix the task ZNRecord path to be task-specific.\n\nClean the exception handling in loadNewTask().", "committedDate": "2020-08-12T16:36:54Z", "type": "commit"}, {"oid": "cb6468f620c38361c03a6f7e2ee27cef5294aa2b", "url": "https://github.com/apache/helix/commit/cb6468f620c38361c03a6f7e2ee27cef5294aa2b", "message": "Throw exceptions when loadNewTask() fails\n\nInstead of simply returning from loadNewTask() when it fails, throw\nappropriate exceptions.", "committedDate": "2020-08-12T16:36:54Z", "type": "commit"}, {"oid": "4e7f68b1c2aa0ebb376ab7d810e3e618c9be6877", "url": "https://github.com/apache/helix/commit/4e7f68b1c2aa0ebb376ab7d810e3e618c9be6877", "message": "Generalize JAR loader, add more tests, fix format\n\nAdds JarLoader interface which generalizes the JAR loading, and adds\nan implementation LocalJarLoader that loads a JAR file from local\ndirectory.\n\nAlso adds more tests for different types of failures. Additionally,\nfixes code formatting issues.", "committedDate": "2020-08-12T16:36:54Z", "type": "commit"}, {"oid": "ef45712aca06032d564e74f673068b590d06ad1d", "url": "https://github.com/apache/helix/commit/ef45712aca06032d564e74f673068b590d06ad1d", "message": "Make dynamic task loading optional, clean up code\n\nMakes dynamically loading tasks optional by skipping the process if the\nfolder for task definitions doesn't exist in ZooKeeper.\n\nAlso cleans up and organizes some code, and reverses some unnecessary\nformatting.", "committedDate": "2020-08-12T16:38:36Z", "type": "commit"}, {"oid": "254c1ce8b8668b274868262d137e3abd75f0c13b", "url": "https://github.com/apache/helix/commit/254c1ce8b8668b274868262d137e3abd75f0c13b", "message": "Rebase to import JarLoader and DynamicTaskConfig", "committedDate": "2020-08-12T16:51:18Z", "type": "commit"}, {"oid": "4f62c9dbbab7ea8d9edc5806547f82fef0fd6a2b", "url": "https://github.com/apache/helix/commit/4f62c9dbbab7ea8d9edc5806547f82fef0fd6a2b", "message": "Fix conflicts for merge", "committedDate": "2020-08-12T16:59:28Z", "type": "commit"}, {"oid": "46f92070b1f8b7c7d7b70b4d4faf07dd9c541231", "url": "https://github.com/apache/helix/commit/46f92070b1f8b7c7d7b70b4d4faf07dd9c541231", "message": "Delete duplicate LocalJarLoader.java", "committedDate": "2020-08-12T18:19:21Z", "type": "commit"}, {"oid": "603bd1c428cbcfd192e3486dfa95a50d89f8f171", "url": "https://github.com/apache/helix/commit/603bd1c428cbcfd192e3486dfa95a50d89f8f171", "message": "Fix some formatting issues", "committedDate": "2020-08-12T18:40:21Z", "type": "commit"}, {"oid": "ea30ec02031394257455b3d2592abc7e46768636", "url": "https://github.com/apache/helix/commit/ea30ec02031394257455b3d2592abc7e46768636", "message": "Merge branch 'master' of https://github.com/rabashizade/helix", "committedDate": "2020-08-12T18:44:04Z", "type": "commit"}, {"oid": "42a0fded9b16b3ede80df8f28ec1673b7b8175b5", "url": "https://github.com/apache/helix/commit/42a0fded9b16b3ede80df8f28ec1673b7b8175b5", "message": "Fix formatting", "committedDate": "2020-08-12T18:47:42Z", "type": "commit"}, {"oid": "ccedbc2154eba578d52315ced93f6d211ea95704", "url": "https://github.com/apache/helix/commit/ccedbc2154eba578d52315ced93f6d211ea95704", "message": "Clarify comments", "committedDate": "2020-08-12T18:55:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3OTc2OQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470079769", "bodyText": "Should you either log here or throw an exception? If you just return, you would be silently failing, which is bad.", "author": "narendly", "createdAt": "2020-08-13T16:34:26Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +287,68 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads className using classLoader\n+   * @param classLoader\n+   * @param className\n+   * @return Class className loaded by classLoader\n+   */\n+  private Class loadClass(URLClassLoader classLoader, String className) {\n+    try {\n+      return classLoader.loadClass(className);\n+    } catch (ClassNotFoundException e) {\n+      LOG.error(\"Failed to load Task class \" + className + \" for new task in instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"Class not found for task\");\n+    }\n+  }\n+\n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and registers the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {\n+    // If the path for dynamic tasks doesn't exist, skip loading the task\n+    if (!_manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .exists(TaskConstants.DYNAMICALLY_LOADED_TASK_PATH, 0)) {\n+      return;", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MDEyMA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470080120", "bodyText": "Instead of 0 (a magic number), please use a static constant that's already defined in the library.", "author": "narendly", "createdAt": "2020-08-13T16:35:01Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +287,68 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads className using classLoader\n+   * @param classLoader\n+   * @param className\n+   * @return Class className loaded by classLoader\n+   */\n+  private Class loadClass(URLClassLoader classLoader, String className) {\n+    try {\n+      return classLoader.loadClass(className);\n+    } catch (ClassNotFoundException e) {\n+      LOG.error(\"Failed to load Task class \" + className + \" for new task in instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"Class not found for task\");\n+    }\n+  }\n+\n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and registers the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {\n+    // If the path for dynamic tasks doesn't exist, skip loading the task\n+    if (!_manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .exists(TaskConstants.DYNAMICALLY_LOADED_TASK_PATH, 0)) {\n+      return;\n+    }\n+\n+    // Read DynamicTaskConfig containing task definition information.\n+    DynamicTaskConfig taskConfig = new DynamicTaskConfig(\n+        _manager.getHelixDataAccessor().getBaseDataAccessor()\n+            .get(TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/\" + command, null, 0));", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDExODMwOA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470118308", "bodyText": "Does it make sense to define constant for Path separator \"/\"?  Not sure if it is defined anywhere else in helix", "author": "manick02", "createdAt": "2020-08-13T17:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MDEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MDQxMw==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470080413", "bodyText": "Make the error message the same for the log and the exception?", "author": "narendly", "createdAt": "2020-08-13T16:35:30Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +287,68 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads className using classLoader\n+   * @param classLoader\n+   * @param className\n+   * @return Class className loaded by classLoader\n+   */\n+  private Class loadClass(URLClassLoader classLoader, String className) {\n+    try {\n+      return classLoader.loadClass(className);\n+    } catch (ClassNotFoundException e) {\n+      LOG.error(\"Failed to load Task class \" + className + \" for new task in instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"Class not found for task\");\n+    }\n+  }\n+\n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and registers the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {\n+    // If the path for dynamic tasks doesn't exist, skip loading the task\n+    if (!_manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .exists(TaskConstants.DYNAMICALLY_LOADED_TASK_PATH, 0)) {\n+      return;\n+    }\n+\n+    // Read DynamicTaskConfig containing task definition information.\n+    DynamicTaskConfig taskConfig = new DynamicTaskConfig(\n+        _manager.getHelixDataAccessor().getBaseDataAccessor()\n+            .get(TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/\" + command, null, 0));\n+    if (taskConfig.getTaskConfigZNRecord() == null) {\n+      LOG.error(\"Failed to read ZNRecord for task \" + command + \" for instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalArgumentException(\"No ZNRecord for task \" + command);", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MDgzMw==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470080833", "bodyText": "nit: this piece of code could sit outside the try-catch?", "author": "narendly", "createdAt": "2020-08-13T16:36:14Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +287,68 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads className using classLoader\n+   * @param classLoader\n+   * @param className\n+   * @return Class className loaded by classLoader\n+   */\n+  private Class loadClass(URLClassLoader classLoader, String className) {\n+    try {\n+      return classLoader.loadClass(className);\n+    } catch (ClassNotFoundException e) {\n+      LOG.error(\"Failed to load Task class \" + className + \" for new task in instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"Class not found for task\");\n+    }\n+  }\n+\n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and registers the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {\n+    // If the path for dynamic tasks doesn't exist, skip loading the task\n+    if (!_manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .exists(TaskConstants.DYNAMICALLY_LOADED_TASK_PATH, 0)) {\n+      return;\n+    }\n+\n+    // Read DynamicTaskConfig containing task definition information.\n+    DynamicTaskConfig taskConfig = new DynamicTaskConfig(\n+        _manager.getHelixDataAccessor().getBaseDataAccessor()\n+            .get(TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/\" + command, null, 0));\n+    if (taskConfig.getTaskConfigZNRecord() == null) {\n+      LOG.error(\"Failed to read ZNRecord for task \" + command + \" for instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalArgumentException(\"No ZNRecord for task \" + command);\n+    }\n+\n+    // Open the JAR file containing Task(s) and TaskFactory classes.\n+    JarLoader jarLoader = new LocalJarLoader();\n+    URL taskJarUrl = jarLoader.loadJar(taskConfig.getJarFilePath());\n+\n+    // Import Task(s) class(es).\n+    URLClassLoader classLoader = URLClassLoader.newInstance(new URL[]{taskJarUrl});\n+    for (String taskClass : taskConfig.getTaskClassesFqns()) {\n+      loadClass(classLoader, taskClass);\n+    }\n+\n+    try {\n+      // Import and instantiate TaskFactory class.\n+      TaskFactory taskFactory =\n+          (TaskFactory) loadClass(classLoader, taskConfig.getTaskFactoryFqn()).newInstance();\n+\n+      // Register the TaskFactory.\n+      _taskFactoryRegistry.put(command, taskFactory);", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MTEyOQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470081129", "bodyText": "Make the error message uniform for logging and the exception for consistency?", "author": "narendly", "createdAt": "2020-08-13T16:36:45Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +287,68 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads className using classLoader\n+   * @param classLoader\n+   * @param className\n+   * @return Class className loaded by classLoader\n+   */\n+  private Class loadClass(URLClassLoader classLoader, String className) {\n+    try {\n+      return classLoader.loadClass(className);\n+    } catch (ClassNotFoundException e) {\n+      LOG.error(\"Failed to load Task class \" + className + \" for new task in instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"Class not found for task\");\n+    }\n+  }\n+\n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and registers the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {\n+    // If the path for dynamic tasks doesn't exist, skip loading the task\n+    if (!_manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .exists(TaskConstants.DYNAMICALLY_LOADED_TASK_PATH, 0)) {\n+      return;\n+    }\n+\n+    // Read DynamicTaskConfig containing task definition information.\n+    DynamicTaskConfig taskConfig = new DynamicTaskConfig(\n+        _manager.getHelixDataAccessor().getBaseDataAccessor()\n+            .get(TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/\" + command, null, 0));\n+    if (taskConfig.getTaskConfigZNRecord() == null) {\n+      LOG.error(\"Failed to read ZNRecord for task \" + command + \" for instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalArgumentException(\"No ZNRecord for task \" + command);\n+    }\n+\n+    // Open the JAR file containing Task(s) and TaskFactory classes.\n+    JarLoader jarLoader = new LocalJarLoader();\n+    URL taskJarUrl = jarLoader.loadJar(taskConfig.getJarFilePath());\n+\n+    // Import Task(s) class(es).\n+    URLClassLoader classLoader = URLClassLoader.newInstance(new URL[]{taskJarUrl});\n+    for (String taskClass : taskConfig.getTaskClassesFqns()) {\n+      loadClass(classLoader, taskClass);\n+    }\n+\n+    try {\n+      // Import and instantiate TaskFactory class.\n+      TaskFactory taskFactory =\n+          (TaskFactory) loadClass(classLoader, taskConfig.getTaskFactoryFqn()).newInstance();\n+\n+      // Register the TaskFactory.\n+      _taskFactoryRegistry.put(command, taskFactory);\n+    } catch (InstantiationException | IllegalAccessException e) {\n+      LOG.error(\"Failed to instantiate TaskFactory class for new task in instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"Failed to instantiate TaskFactory for task\");", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MTcyNQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470081725", "bodyText": "Please add a JavaDoc - a short paragraph about why and what kind of testing will be performed in this test.", "author": "narendly", "createdAt": "2020-08-13T16:37:50Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MjAxMA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470082010", "bodyText": "For constants, use private static final, and the variable name would be all in caps.", "author": "narendly", "createdAt": "2020-08-13T16:38:20Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MjMwOQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470082309", "bodyText": "Please follow the code style guidelines (google how to define Java constants).", "author": "narendly", "createdAt": "2020-08-13T16:38:49Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MjYzMQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470082631", "bodyText": "Do you really want a beforeMethod or a beforeClass?", "author": "narendly", "createdAt": "2020-08-13T16:39:20Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4Mjg0MQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470082841", "bodyText": "Is 0 a magic number?", "author": "narendly", "createdAt": "2020-08-13T16:39:38Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MzAxNw==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470083017", "bodyText": "Don't we already have a static constant defined for \"MasterSlave\"?", "author": "narendly", "createdAt": "2020-08-13T16:39:57Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4Mzk5OQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470083999", "bodyText": "Pull out your strings and name them as a local variable - for example,\nString fullyQualifiedTaskClassName = \"com.mycompany.mocktask.MockTask\"; \nString taskVersion = \"1.0.0\";\n\n...\nfor readability.", "author": "narendly", "createdAt": "2020-08-13T16:41:33Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NDQ4MQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470084481", "bodyText": "Use Assert.assertEquals instead of AssertJUnit? Please remove all usages & import of AssertJUnit.", "author": "narendly", "createdAt": "2020-08-13T16:42:24Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NDYxMg==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470084612", "bodyText": "Assert.fail? Also it's throwing an exception anyway, so why don't we just have it throw an exception instead of doing Assert.fail?", "author": "narendly", "createdAt": "2020-08-13T16:42:35Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NTQ3Nw==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470085477", "bodyText": "<String> is not necessary in new ArrayList<String>(); Are you sure you're coding in Java 8? Please fix up your environment.", "author": "narendly", "createdAt": "2020-08-13T16:44:07Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingJar() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NTY5NQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470085695", "bodyText": "Pull out your strings into local variables with more descriptive names.", "author": "narendly", "createdAt": "2020-08-13T16:44:31Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingJar() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NTk0NQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470085945", "bodyText": "Revise the structure as commented above, and replace AssertJUnit with Assert?", "author": "narendly", "createdAt": "2020-08-13T16:44:53Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingJar() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Random.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NjEyMg==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470086122", "bodyText": "Revise (see above)", "author": "narendly", "createdAt": "2020-08-13T16:45:09Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingJar() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Random.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskConfig() throws Exception {\n+    // Remove task config ZNRecord if it exists.\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NjIwMQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470086201", "bodyText": "Style?", "author": "narendly", "createdAt": "2020-08-13T16:45:18Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingJar() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Random.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskConfig() throws Exception {\n+    // Remove task config ZNRecord if it exists.\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskClass() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyOTM5NA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470129394", "bodyText": "May not be related to this PR, I see a lot of Path building, like this\"TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\"  happening though out, it provides an opportunity to reduce chances of error and on the opportunity to standardize path building by defining a ZNPathBuilder utility ( This comment may be irrelevant - Sorry, am just new to the helix and trying to understand)", "author": "manick02", "createdAt": "2020-08-13T17:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NjIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MTI5OQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470271299", "bodyText": "Thank you for your comment. I agree this might make sense (plus your other comment regarding path building). But I guess it's more appropriate to be addresses in another PR, as you mentioned.", "author": "rabashizade", "createdAt": "2020-08-13T21:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NjIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NjMwNg==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470086306", "bodyText": "Pull out strings.", "author": "narendly", "createdAt": "2020-08-13T16:45:26Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingJar() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Random.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskConfig() throws Exception {\n+    // Remove task config ZNRecord if it exists.\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskClass() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.RandomTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NjM4NA==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470086384", "bodyText": "revise structure", "author": "narendly", "createdAt": "2020-08-13T16:45:33Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingJar() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Random.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskConfig() throws Exception {\n+    // Remove task config ZNRecord if it exists.\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskClass() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.RandomTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NjU2NQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470086565", "bodyText": "Style, structure, AssertJUnit.", "author": "narendly", "createdAt": "2020-08-13T16:45:50Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingJar() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Random.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskConfig() throws Exception {\n+    // Remove task config ZNRecord if it exists.\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskClass() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.RandomTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskFactory() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.RandomTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4Njg3MQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470086871", "bodyText": "Is it possible to use AfterClass instead to avoid redundant work of starting and shutting down threads?", "author": "narendly", "createdAt": "2020-08-13T16:46:23Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestDynamicTaskLoading.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.examples.MasterSlaveStateModelFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.MockTask;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.participant.statemachine.StateModel;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+public class TestDynamicTaskLoading extends ZkTestBase {\n+  private final String _clusterName = CLUSTER_PREFIX + \"_\" + getShortClassName();\n+  private static final String _instanceName = \"localhost_12913\";\n+  private HelixManager _manager;\n+  private MockParticipantManager _participant;\n+  private ClusterControllerManager _controller;\n+\n+  @BeforeMethod\n+  public void beforeMethod() throws Exception {\n+    _gSetupTool.addCluster(_clusterName, true);\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(_clusterName, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _gSetupTool.addInstanceToCluster(_clusterName, _instanceName);\n+    _participant = new MockParticipantManager(ZK_ADDR, _clusterName, _instanceName);\n+    StateModelFactory<StateModel> stateModelFactory =\n+        new MasterSlaveStateModelFactory(_instanceName, 0);\n+    StateMachineEngine stateMach = _participant.getStateMachineEngine();\n+    stateMach.registerStateModelFactory(\"MasterSlave\", stateModelFactory);\n+    Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+    _participant.getStateMachineEngine().registerStateModelFactory(TaskConstants.STATE_MODEL_NAME,\n+        new TaskStateModelFactory(_participant, taskFactoryReg));\n+    _participant.syncStart();\n+\n+    _controller = new ClusterControllerManager(ZK_ADDR, _clusterName, null);\n+    _controller.syncStart();\n+  }\n+\n+  private void removePathIfExists(String path) {\n+    if (_manager.getHelixDataAccessor().getBaseDataAccessor().exists(path, 0)) {\n+      _manager.getHelixDataAccessor().getBaseDataAccessor().remove(path, 0);\n+    }\n+  }\n+\n+  /**\n+   * Submit a workflow consisting of a job with a MockTask task.\n+   * @param workflowName name of the workflow\n+   * @param driver {@link TaskDriver} to submit workflowName to\n+   */\n+  private void submitWorkflow(String workflowName, TaskDriver driver) {\n+    JobConfig.Builder job = new JobConfig.Builder();\n+    job.setJobCommandConfigMap(Collections.singletonMap(MockTask.JOB_DELAY, \"100\"));\n+    Workflow.Builder workflow = new Workflow.Builder(workflowName);\n+    job.setWorkflow(workflowName);\n+    TaskConfig taskConfig =\n+        new TaskConfig(MockTask.TASK_COMMAND, new HashMap<String, String>(), null, null);\n+    job.addTaskConfigMap(Collections.singletonMap(taskConfig.getId(), taskConfig));\n+    job.setJobId(TaskUtil.getNamespacedJobName(workflowName, \"JOB\"));\n+    workflow.addJob(\"JOB\", job);\n+    driver.start(workflow.build());\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoading() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.COMPLETED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingJar() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Random.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskConfig() throws Exception {\n+    // Remove task config ZNRecord if it exists.\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskClass() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.RandomTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.MockTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testDynamicTaskLoadingNonexistingTaskFactory() throws Exception {\n+    // Add task definition information as a DynamicTaskConfig.\n+    List<String> taskClasses = new ArrayList<String>();\n+    taskClasses.add(\"com.mycompany.mocktask.MockTask\");\n+    DynamicTaskConfig taskConfig =\n+        new DynamicTaskConfig(\"Reindex\", \"src/test/resources/Reindex.jar\", \"1.0.0\", taskClasses,\n+            \"com.mycompany.mocktask.RandomTaskFactory\");\n+    String path = TaskConstants.DYNAMICALLY_LOADED_TASK_PATH + \"/Reindex\";\n+    removePathIfExists(path);\n+    _manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .create(path, taskConfig.getTaskConfigZNRecord(), AccessOption.PERSISTENT);\n+\n+    // Submit workflow\n+    TaskDriver driver = new TaskDriver(_manager);\n+    String workflowName = TestHelper.getTestMethodName();\n+    submitWorkflow(workflowName, driver);\n+\n+    try {\n+      // Wait for the workflow to either complete or fail.\n+      TaskState finalState =\n+          driver.pollForWorkflowState(workflowName, TaskState.COMPLETED, TaskState.FAILED);\n+      AssertJUnit.assertEquals(finalState, TaskState.FAILED);\n+    } catch (HelixException e) {\n+      AssertJUnit.fail(e.getMessage());\n+    }\n+  }\n+\n+  @AfterMethod\n+  public void afterMethod() {", "originalCommit": "ccedbc2154eba578d52315ced93f6d211ea95704", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI2OTI4Nw==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470269287", "bodyText": "Regarding this and BeforeMethod vs. BeforeClass, I wanted to make sure no dynamically loaded class remains loaded between the tests. I tried with BeforeClass and AfterClass, and all tests would result in TaskState.COMPLETED whereas only one should complete and the others should fail.", "author": "rabashizade", "createdAt": "2020-08-13T21:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4Njg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5NDkxMw==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470294913", "bodyText": "That's fair. Could you make sure you document the reason in your before method/after method ?", "author": "narendly", "createdAt": "2020-08-13T23:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4Njg3MQ=="}], "type": "inlineReview"}, {"oid": "22e16ff09a0a1924afde59231f5b2d627b99de1a", "url": "https://github.com/apache/helix/commit/22e16ff09a0a1924afde59231f5b2d627b99de1a", "message": "Fix style and formatting", "committedDate": "2020-08-13T21:52:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5NTEzNw==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470295137", "bodyText": "Duplicate strings. Please factor it out to a local String variable throughout the test.", "author": "narendly", "createdAt": "2020-08-13T23:02:39Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +288,75 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads className using classLoader\n+   * @param classLoader\n+   * @param className\n+   * @return Class className loaded by classLoader\n+   */\n+  private Class loadClass(URLClassLoader classLoader, String className) {\n+    try {\n+      return classLoader.loadClass(className);\n+    } catch (ClassNotFoundException e) {\n+      LOG.error(\"Failed to load Task class \" + className + \" for new task in instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"Class not found for task\");\n+    }\n+  }\n+\n+  /**\n+   * Loads Task and TaskFactory classes for command input from\n+   * a JAR file, and registers the TaskFactory in _taskFactoryRegistry.\n+   * @param command The command indicating what task to be loaded\n+   */\n+  private void loadNewTask(String command) {\n+    // If the path for dynamic tasks doesn't exist, skip loading the task\n+    if (!_manager.getHelixDataAccessor().getBaseDataAccessor()\n+        .exists(TaskConstants.DYNAMICALLY_LOADED_TASK_PATH, 0)) {\n+      LOG.error(\"Path for dynamic tasks doesn't exist!\");\n+      throw new IllegalStateException(\"Path for dynamic tasks doesn't exist!\");", "originalCommit": "22e16ff09a0a1924afde59231f5b2d627b99de1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5NTI0Mw==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470295243", "bodyText": "Let's make sure error messages are consistent.", "author": "narendly", "createdAt": "2020-08-13T23:03:01Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModel.java", "diffHunk": "@@ -283,6 +288,75 @@ public void reset() {\n     }\n   }\n \n+  /**\n+   * Loads className using classLoader\n+   * @param classLoader\n+   * @param className\n+   * @return Class className loaded by classLoader\n+   */\n+  private Class loadClass(URLClassLoader classLoader, String className) {\n+    try {\n+      return classLoader.loadClass(className);\n+    } catch (ClassNotFoundException e) {\n+      LOG.error(\"Failed to load Task class \" + className + \" for new task in instance \" + _manager\n+          .getInstanceName() + \" in cluster \" + _manager.getClusterName() + \".\");\n+      throw new IllegalStateException(\"Class not found for task\");", "originalCommit": "22e16ff09a0a1924afde59231f5b2d627b99de1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMxMjY0OQ==", "url": "https://github.com/apache/helix/pull/1169#discussion_r470312649", "bodyText": "Sorry, missed this one in the previous fix.", "author": "rabashizade", "createdAt": "2020-08-14T00:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5NTI0Mw=="}], "type": "inlineReview"}, {"oid": "eb7a9ad1bfbb5f0c848a70d406f59ba950719d1e", "url": "https://github.com/apache/helix/commit/eb7a9ad1bfbb5f0c848a70d406f59ba950719d1e", "message": "Improve documentation and style", "committedDate": "2020-08-14T00:01:55Z", "type": "commit"}, {"oid": "122ed49711d1d1bfb10507bd018786fdbeba9adc", "url": "https://github.com/apache/helix/commit/122ed49711d1d1bfb10507bd018786fdbeba9adc", "message": "Remove unnecessary import", "committedDate": "2020-08-14T14:18:29Z", "type": "commit"}, {"oid": "bbb3bfdd5e0286ebfe3a177a4671c96f9d18b51c", "url": "https://github.com/apache/helix/commit/bbb3bfdd5e0286ebfe3a177a4671c96f9d18b51c", "message": "Fix variable declaration", "committedDate": "2020-08-14T14:33:47Z", "type": "commit"}]}