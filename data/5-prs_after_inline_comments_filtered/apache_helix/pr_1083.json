{"pr_number": 1083, "pr_title": "Fix waitToStop method in TaskDriver", "pr_createdAt": "2020-06-10T21:41:24Z", "pr_url": "https://github.com/apache/helix/pull/1083", "timeline": [{"oid": "ddc52b290acb67c3986299fd953303d52136756d", "url": "https://github.com/apache/helix/commit/ddc52b290acb67c3986299fd953303d52136756d", "message": "Fix waitToStop in TaskDriver\n\nMake sure that queue is stopped in waitToStop method.", "committedDate": "2020-06-10T21:44:55Z", "type": "commit"}, {"oid": "ddc52b290acb67c3986299fd953303d52136756d", "url": "https://github.com/apache/helix/commit/ddc52b290acb67c3986299fd953303d52136756d", "message": "Fix waitToStop in TaskDriver\n\nMake sure that queue is stopped in waitToStop method.", "committedDate": "2020-06-10T21:44:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MjQ4NQ==", "url": "https://github.com/apache/helix/pull/1083#discussion_r438472485", "bodyText": "Is this unused?", "author": "huizhilu", "createdAt": "2020-06-11T00:06:58Z", "path": "helix-core/src/test/java/org/apache/helix/integration/task/TestStoppingQueueFailToStop.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.apache.helix.integration.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.MasterSlaveSMD;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.task.JobConfig;\n+import org.apache.helix.task.JobQueue;\n+import org.apache.helix.task.TaskCallbackContext;\n+import org.apache.helix.task.TaskDriver;\n+import org.apache.helix.task.TaskFactory;\n+import org.apache.helix.task.TaskState;\n+import org.apache.helix.task.TaskStateModelFactory;\n+import org.apache.helix.task.TaskUtil;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Sets;\n+\n+\n+/**\n+ * Test to check if waitToStop method correctly throws an Exception if Queue stuck in STOPPING\n+ * state.\n+ */\n+public class TestStoppingQueueFailToStop extends TaskTestBase {\n+  private static final String DATABASE = WorkflowGenerator.DEFAULT_TGT_DB;\n+  protected HelixDataAccessor _accessor;", "originalCommit": "ddc52b290acb67c3986299fd953303d52136756d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0OTE2Ng==", "url": "https://github.com/apache/helix/pull/1083#discussion_r439549166", "bodyText": "Deleted.", "author": "alirezazamani", "createdAt": "2020-06-12T17:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MjQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3Mjk0NA==", "url": "https://github.com/apache/helix/pull/1083#discussion_r438472944", "bodyText": "Why upper case for a private field?", "author": "huizhilu", "createdAt": "2020-06-11T00:08:38Z", "path": "helix-core/src/test/java/org/apache/helix/integration/task/TestStoppingQueueFailToStop.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.apache.helix.integration.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.MasterSlaveSMD;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.task.JobConfig;\n+import org.apache.helix.task.JobQueue;\n+import org.apache.helix.task.TaskCallbackContext;\n+import org.apache.helix.task.TaskDriver;\n+import org.apache.helix.task.TaskFactory;\n+import org.apache.helix.task.TaskState;\n+import org.apache.helix.task.TaskStateModelFactory;\n+import org.apache.helix.task.TaskUtil;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Sets;\n+\n+\n+/**\n+ * Test to check if waitToStop method correctly throws an Exception if Queue stuck in STOPPING\n+ * state.\n+ */\n+public class TestStoppingQueueFailToStop extends TaskTestBase {\n+  private static final String DATABASE = WorkflowGenerator.DEFAULT_TGT_DB;\n+  protected HelixDataAccessor _accessor;\n+  private boolean TASK_STOPPABLE = false;", "originalCommit": "ddc52b290acb67c3986299fd953303d52136756d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0OTc5Mw==", "url": "https://github.com/apache/helix/pull/1083#discussion_r439549793", "bodyText": "Changed. Thanks.", "author": "alirezazamani", "createdAt": "2020-06-12T17:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3Mjk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3Njk2MQ==", "url": "https://github.com/apache/helix/pull/1083#discussion_r438476961", "bodyText": "This while-loop-sleep doesn't look the best option. Would a countdown solve this wait better?", "author": "huizhilu", "createdAt": "2020-06-11T00:23:29Z", "path": "helix-core/src/test/java/org/apache/helix/integration/task/TestStoppingQueueFailToStop.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.apache.helix.integration.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.MasterSlaveSMD;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.task.JobConfig;\n+import org.apache.helix.task.JobQueue;\n+import org.apache.helix.task.TaskCallbackContext;\n+import org.apache.helix.task.TaskDriver;\n+import org.apache.helix.task.TaskFactory;\n+import org.apache.helix.task.TaskState;\n+import org.apache.helix.task.TaskStateModelFactory;\n+import org.apache.helix.task.TaskUtil;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Sets;\n+\n+\n+/**\n+ * Test to check if waitToStop method correctly throws an Exception if Queue stuck in STOPPING\n+ * state.\n+ */\n+public class TestStoppingQueueFailToStop extends TaskTestBase {\n+  private static final String DATABASE = WorkflowGenerator.DEFAULT_TGT_DB;\n+  protected HelixDataAccessor _accessor;\n+  private boolean TASK_STOPPABLE = false;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    _numPartitions = 1;\n+    _numNodes = 3;\n+    super.beforeClass();\n+    _manager = HelixManagerFactory.getZKHelixManager(CLUSTER_NAME, \"Admin\",\n+        InstanceType.ADMINISTRATOR, ZK_ADDR);\n+\n+    // Stop participants that have been started in super class\n+    for (int i = 0; i < _numNodes; i++) {\n+      super.stopParticipant(i);\n+      Assert.assertFalse(_participants[i].isConnected());\n+    }\n+\n+    // Start new participants that have new TaskStateModel (NewMockTask) information\n+    _participants = new MockParticipantManager[_numNodes];\n+    for (int i = 0; i < _numNodes; i++) {\n+      Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+      taskFactoryReg.put(NewMockTask.TASK_COMMAND, NewMockTask::new);\n+      String instanceName = PARTICIPANT_PREFIX + \"_\" + (_startPort + i);\n+      _participants[i] = new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, instanceName);\n+\n+      // Register a Task state model factory.\n+      StateMachineEngine stateMachine = _participants[i].getStateMachineEngine();\n+      stateMachine.registerStateModelFactory(\"Task\",\n+          new TaskStateModelFactory(_participants[i], taskFactoryReg));\n+      _participants[i].syncStart();\n+    }\n+\n+    _manager.connect();\n+    _driver = new TaskDriver(_manager);\n+  }\n+\n+  @Test\n+  public void testStoppingQueueFailToStop() throws Exception {\n+    String jobQueueName = TestHelper.getTestMethodName();\n+    JobConfig.Builder jobBuilder0 =\n+        new JobConfig.Builder().setWorkflow(jobQueueName).setTargetResource(DATABASE)\n+            .setTargetPartitionStates(Sets.newHashSet(MasterSlaveSMD.States.MASTER.name()))\n+            .setCommand(MockTask.TASK_COMMAND)\n+            .setJobCommandConfigMap(ImmutableMap.of(MockTask.JOB_DELAY, \"100000\"));\n+\n+    JobQueue.Builder jobQueue = TaskTestUtil.buildJobQueue(jobQueueName);\n+    jobQueue.enqueueJob(\"JOB0\", jobBuilder0);\n+    _driver.start(jobQueue.build());\n+    _driver.pollForJobState(jobQueueName, TaskUtil.getNamespacedJobName(jobQueueName, \"JOB0\"),\n+        TaskState.IN_PROGRESS);\n+    boolean exceptionHappened = false;\n+    try {\n+      _driver.waitToStop(jobQueueName, 5000);\n+    } catch (HelixException e) {\n+      exceptionHappened = true;\n+    }\n+    _driver.pollForWorkflowState(jobQueueName, TaskState.STOPPING);\n+    Assert.assertTrue(exceptionHappened);\n+    TASK_STOPPABLE = true;\n+  }\n+\n+  /**\n+   * A mock task that extents MockTask class and stuck in running when cancel is called.\n+   */\n+  private class NewMockTask extends MockTask {\n+\n+    NewMockTask(TaskCallbackContext context) {\n+      super(context);\n+    }\n+\n+    @Override\n+    public void cancel() {\n+      while (!TASK_STOPPABLE) {\n+        try {\n+          Thread.sleep(1000L);", "originalCommit": "ddc52b290acb67c3986299fd953303d52136756d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0OTYwOA==", "url": "https://github.com/apache/helix/pull/1083#discussion_r439549608", "bodyText": "No. We want to be in this loop for a long time until in the main part of the test we want to the task to stop.", "author": "alirezazamani", "createdAt": "2020-06-12T17:24:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3Njk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NzIwMA==", "url": "https://github.com/apache/helix/pull/1083#discussion_r438477200", "bodyText": "It doesn't seem these imports are formatted by helix-style?", "author": "huizhilu", "createdAt": "2020-06-11T00:24:30Z", "path": "helix-core/src/test/java/org/apache/helix/integration/task/TestStoppingQueueFailToStop.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.apache.helix.integration.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.MasterSlaveSMD;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.task.JobConfig;\n+import org.apache.helix.task.JobQueue;\n+import org.apache.helix.task.TaskCallbackContext;\n+import org.apache.helix.task.TaskDriver;\n+import org.apache.helix.task.TaskFactory;\n+import org.apache.helix.task.TaskState;\n+import org.apache.helix.task.TaskStateModelFactory;\n+import org.apache.helix.task.TaskUtil;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.google.common.collect.ImmutableMap;", "originalCommit": "ddc52b290acb67c3986299fd953303d52136756d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0OTA0Mg==", "url": "https://github.com/apache/helix/pull/1083#discussion_r439549042", "bodyText": "I just did reformat.", "author": "alirezazamani", "createdAt": "2020-06-12T17:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NzIwMA=="}], "type": "inlineReview"}, {"oid": "1cdd52597aa4ea9fabfb7f8dee21c4e6282e4823", "url": "https://github.com/apache/helix/commit/1cdd52597aa4ea9fabfb7f8dee21c4e6282e4823", "message": "Address comments", "committedDate": "2020-06-11T17:17:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNzUyMA==", "url": "https://github.com/apache/helix/pull/1083#discussion_r439727520", "bodyText": "If I understand the logic here right, Countdown latch does exactly the job you need and does it better. Countdown latch could await until latch is release. I may not have insisted this since it is a test. But I am curious. Could you help understand why countdown latch doesn\u2019t solve this? Isn\u2019t it better than this high cpu switch  sleep polling?", "author": "huizhilu", "createdAt": "2020-06-13T10:13:19Z", "path": "helix-core/src/test/java/org/apache/helix/integration/task/TestStoppingQueueFailToStop.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.apache.helix.integration.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.MasterSlaveSMD;\n+import org.apache.helix.participant.StateMachineEngine;\n+import org.apache.helix.task.JobConfig;\n+import org.apache.helix.task.JobQueue;\n+import org.apache.helix.task.TaskCallbackContext;\n+import org.apache.helix.task.TaskDriver;\n+import org.apache.helix.task.TaskFactory;\n+import org.apache.helix.task.TaskState;\n+import org.apache.helix.task.TaskStateModelFactory;\n+import org.apache.helix.task.TaskUtil;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * Test to check if waitToStop method correctly throws an Exception if Queue stuck in STOPPING\n+ * state.\n+ */\n+public class TestStoppingQueueFailToStop extends TaskTestBase {\n+  private static final String DATABASE = WorkflowGenerator.DEFAULT_TGT_DB;\n+  private boolean _taskStoppable = false;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    _numPartitions = 1;\n+    _numNodes = 3;\n+    super.beforeClass();\n+    _manager = HelixManagerFactory.getZKHelixManager(CLUSTER_NAME, \"Admin\",\n+        InstanceType.ADMINISTRATOR, ZK_ADDR);\n+\n+    // Stop participants that have been started in super class\n+    for (int i = 0; i < _numNodes; i++) {\n+      super.stopParticipant(i);\n+      Assert.assertFalse(_participants[i].isConnected());\n+    }\n+\n+    // Start new participants that have new TaskStateModel (NewMockTask) information\n+    _participants = new MockParticipantManager[_numNodes];\n+    for (int i = 0; i < _numNodes; i++) {\n+      Map<String, TaskFactory> taskFactoryReg = new HashMap<>();\n+      taskFactoryReg.put(NewMockTask.TASK_COMMAND, NewMockTask::new);\n+      String instanceName = PARTICIPANT_PREFIX + \"_\" + (_startPort + i);\n+      _participants[i] = new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, instanceName);\n+\n+      // Register a Task state model factory.\n+      StateMachineEngine stateMachine = _participants[i].getStateMachineEngine();\n+      stateMachine.registerStateModelFactory(\"Task\",\n+          new TaskStateModelFactory(_participants[i], taskFactoryReg));\n+      _participants[i].syncStart();\n+    }\n+\n+    _manager.connect();\n+    _driver = new TaskDriver(_manager);\n+  }\n+\n+  @Test\n+  public void testStoppingQueueFailToStop() throws Exception {\n+    String jobQueueName = TestHelper.getTestMethodName();\n+    JobConfig.Builder jobBuilder0 =\n+        new JobConfig.Builder().setWorkflow(jobQueueName).setTargetResource(DATABASE)\n+            .setTargetPartitionStates(Sets.newHashSet(MasterSlaveSMD.States.MASTER.name()))\n+            .setCommand(MockTask.TASK_COMMAND)\n+            .setJobCommandConfigMap(ImmutableMap.of(MockTask.JOB_DELAY, \"100000\"));\n+\n+    JobQueue.Builder jobQueue = TaskTestUtil.buildJobQueue(jobQueueName);\n+    jobQueue.enqueueJob(\"JOB0\", jobBuilder0);\n+    _driver.start(jobQueue.build());\n+    _driver.pollForJobState(jobQueueName, TaskUtil.getNamespacedJobName(jobQueueName, \"JOB0\"),\n+        TaskState.IN_PROGRESS);\n+    boolean exceptionHappened = false;\n+    try {\n+      _driver.waitToStop(jobQueueName, 5000L);\n+    } catch (HelixException e) {\n+      exceptionHappened = true;\n+    }\n+    _driver.pollForWorkflowState(jobQueueName, TaskState.STOPPING);\n+    Assert.assertTrue(exceptionHappened);\n+    _taskStoppable = true;\n+  }\n+\n+  /**\n+   * A mock task that extents MockTask class and stuck in running when cancel is called.\n+   */\n+  private class NewMockTask extends MockTask {\n+\n+    NewMockTask(TaskCallbackContext context) {\n+      super(context);\n+    }\n+\n+    @Override\n+    public void cancel() {\n+      while (!_taskStoppable) {\n+        try {\n+          Thread.sleep(1000L);", "originalCommit": "1cdd52597aa4ea9fabfb7f8dee21c4e6282e4823", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg3NDcxMg==", "url": "https://github.com/apache/helix/pull/1083#discussion_r439874712", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-06-14T22:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNzUyMA=="}], "type": "inlineReview"}, {"oid": "702f5f4e0ace7582b4edf981959bb7a03f5b5ff1", "url": "https://github.com/apache/helix/commit/702f5f4e0ace7582b4edf981959bb7a03f5b5ff1", "message": "Address comments", "committedDate": "2020-06-14T21:03:19Z", "type": "forcePushed"}, {"oid": "911a4475c9e7e5d5c2a78fbf8f15b2cbff8c6ee6", "url": "https://github.com/apache/helix/commit/911a4475c9e7e5d5c2a78fbf8f15b2cbff8c6ee6", "message": "Address comments", "committedDate": "2020-06-14T21:07:00Z", "type": "commit"}, {"oid": "911a4475c9e7e5d5c2a78fbf8f15b2cbff8c6ee6", "url": "https://github.com/apache/helix/commit/911a4475c9e7e5d5c2a78fbf8f15b2cbff8c6ee6", "message": "Address comments", "committedDate": "2020-06-14T21:07:00Z", "type": "forcePushed"}]}