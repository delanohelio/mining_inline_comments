{"pr_number": 1592, "pr_title": "Cancel async callback when exception is thrown", "pr_createdAt": "2020-12-10T23:34:28Z", "pr_url": "https://github.com/apache/helix/pull/1592", "timeline": [{"oid": "33e2bd41b85e36dcfeba776ed39dff644ecb8378", "url": "https://github.com/apache/helix/commit/33e2bd41b85e36dcfeba776ed39dff644ecb8378", "message": "Cancel async callback when exception is thrown", "committedDate": "2020-12-10T23:32:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4MjEwNA==", "url": "https://github.com/apache/helix/pull/1592#discussion_r540582104", "bodyText": "Let's cancel in final statement?", "author": "junkaixue", "createdAt": "2020-12-10T23:41:15Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncRetryThread.java", "diffHunk": "@@ -49,7 +49,9 @@ public void run() {\n           context.cancel();\n           interrupt();\n         } catch (Throwable e) {\n-          LOG.error(\"Error retrying callback \" + context, e);\n+          LOG.error(\"Error retrying callback {}, cancelling it\", context, e);\n+          // Cancel the context so the upstream caller can stop waiting\n+          context.cancel();", "originalCommit": "33e2bd41b85e36dcfeba776ed39dff644ecb8378", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NTk3NQ==", "url": "https://github.com/apache/helix/pull/1592#discussion_r540585975", "bodyText": "No, if retry was done successfully, then cancel it prematurely will block the normal logic.", "author": "jiajunwang", "createdAt": "2020-12-10T23:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4MjEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5OTA0OA==", "url": "https://github.com/apache/helix/pull/1592#discussion_r540599048", "bodyText": "As @jiajunwang said, cancel it prematurely in the finally statement will impact the future retries: if this retry fails because of connection loss, it'll continue retrying. If we cancel it in the finally, the operation is marked as done so it won't retry the operation. We only want to cancel it if a non-retryable exception throws.", "author": "huizhilu", "createdAt": "2020-12-11T00:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4MjEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NjE2NA==", "url": "https://github.com/apache/helix/pull/1592#discussion_r540586164", "bodyText": "Why we need these given we have already cancel it in the doRetry()?", "author": "jiajunwang", "createdAt": "2020-12-10T23:51:09Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1927,15 +1927,23 @@ private void doAsyncCreate(final String path, final byte[] data, final CreateMod\n       final long startT, final ZkAsyncCallbacks.CreateCallbackHandler cb,\n       final String expectedSessionId) {\n     retryUntilConnected(() -> {\n-      getExpectedZookeeper(expectedSessionId)\n-          .create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode, cb,\n-              new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n-                @Override\n-                protected void doRetry() {\n-                  doAsyncCreate(path, data, mode, System.currentTimeMillis(), cb,\n-                      expectedSessionId);\n-                }\n-              });\n+      final ZooKeeper zk;\n+      try {\n+        zk = getExpectedZookeeper(expectedSessionId);\n+      } catch (ZkSessionMismatchedException e) {\n+        // Use BADARGUMENTS rc to represent session mismatch error (invalid expectedSession)\n+        // and not retry.\n+        cb.processResult(KeeperException.Code.BADARGUMENTS.intValue(), path,\n+            new ZkAsyncCallMonitorContext(_monitor, startT, 0, false), null);\n+        throw e;\n+      }\n+      zk.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode, cb,\n+          new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+            @Override\n+            protected void doRetry() {\n+              doAsyncCreate(path, data, mode, System.currentTimeMillis(), cb, expectedSessionId);", "originalCommit": "33e2bd41b85e36dcfeba776ed39dff644ecb8378", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5NDk5Mw==", "url": "https://github.com/apache/helix/pull/1592#discussion_r540594993", "bodyText": "It is to handle the first call before it enters doRetry() and asyncThread. For the single thread calling, it is OK as the exception is thrown to the upstream caller and the caller won't be able to call waitForSuccess().\nIf it is multi threading: thread-1 calls asyncCreate(), and thread-2 waitForSuccess(), thread-2 will be waiting forever.\nSo I'd like to process it as when the sessions mismatch, we should treat the operation a failure.", "author": "huizhilu", "createdAt": "2020-12-11T00:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NjE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYxNDg3Mg==", "url": "https://github.com/apache/helix/pull/1592#discussion_r540614872", "bodyText": "It's a good catch!.\nI was thinking if you need to try catch all types of exceptions, then I realize you need to do it depends on which one will be retried by the retryUntilConnect()...\nCan we just wrap the retryUntilConnect() with try-catch so we don't need to think about these dependencies?", "author": "jiajunwang", "createdAt": "2020-12-11T01:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NjE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY3NTA5MQ==", "url": "https://github.com/apache/helix/pull/1592#discussion_r540675091", "bodyText": "@jiajunwang I seriously thought about catching a generic exception, but after digging into the code more, getExpectedZookeeper() is almost impossible to throw an exception other than ZkSessionMismatchedException. That's the reason I think catching ZkSessionMismatchedException is good enough and I just try...catch getExpectedZookeeper other than the whole block below. It's cleaner to understand we just want to handle exception for getExpectedZookeeper, excluding create(). The KeeperException error from create() is handled in the async retry thread.\ntry {\n  getExpectedZookeeper(expectedSessionId).create();\n} catch (Exception e) {\n}\n\nMaybe you could say catching a generic one is safer.", "author": "huizhilu", "createdAt": "2020-12-11T04:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NjE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY5MTY3NQ==", "url": "https://github.com/apache/helix/pull/1592#discussion_r540691675", "bodyText": "I know the logic is absolutely correct. Just like when we first implemented this retry logic and there is no getExpectedZookeeper() call so nothing will go wrong.\nThe point is that we may have other exceptions if the new code is added here. Then this issue might happen if any user is using a different thread to wait.\nBack to my original question, what is the problem of a generic try-catch? To be clear, what I mean is,\ntry {\nretryUntilConnect(....)\n} catch (Exception ex) {\nhandle callback\n}\nIMO, this looks cleaner : )", "author": "jiajunwang", "createdAt": "2020-12-11T04:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NjE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDcyODY0MA==", "url": "https://github.com/apache/helix/pull/1592#discussion_r540728640", "bodyText": "@jiajunwang OK got you. I don't think there is a function problem. I just could not find a good KeeperException code for handling callback. Previously I thought of a similar code to catch the whole private API, which might be a bit cleaner? - same thing, wrapping inside the API vs outside.\npublic void asyncCreate() {\n  try {\n    doAsyncCreate();\n  } catch (RuntimeException e) {\n   // I think we'll need a generic code here but I am not sure what error code is a good one\n    cb.processResult(KeeperException.Code.BADARGUMENTS.intValue());\n    throw e;\n  }\n\nI can't find a generic error code for the generic runtimeException: KeeperException.Code.BADARGUMENTS cannot represent a generic RuntimeException. Maybe a customized one like -255?\nThe reason I put catch for getExpectedZookeeper is we may use BADARGUMENTS to represent session mismatch.\nLet me know your opinions, including what error code number is preferred.", "author": "huizhilu", "createdAt": "2020-12-11T06:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NjE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNDU1NQ==", "url": "https://github.com/apache/helix/pull/1592#discussion_r541224555", "bodyText": "In this case, I think UNKNOWN_RET_CODE is fine. Because you really don't have it, right?", "author": "jiajunwang", "createdAt": "2020-12-11T19:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NjE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI4OTY5MQ==", "url": "https://github.com/apache/helix/pull/1592#discussion_r541289691", "bodyText": "Refactored. @jiajunwang Could you take another look? Thanks.", "author": "huizhilu", "createdAt": "2020-12-11T21:04:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NjE2NA=="}], "type": "inlineReview"}, {"oid": "667964e4cea5e67bee70d68e43161cbd7af3be84", "url": "https://github.com/apache/helix/commit/667964e4cea5e67bee70d68e43161cbd7af3be84", "message": "cancel callback with unknown ret code", "committedDate": "2020-12-11T21:02:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQzNjg4NA==", "url": "https://github.com/apache/helix/pull/1592#discussion_r541436884", "bodyText": "nit, RuntimeException  -> Throwable?", "author": "jiajunwang", "createdAt": "2020-12-12T00:03:41Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1926,18 +1926,25 @@ public void asyncCreate(final String path, Object datat, final CreateMode mode,\n   private void doAsyncCreate(final String path, final byte[] data, final CreateMode mode,\n       final long startT, final ZkAsyncCallbacks.CreateCallbackHandler cb,\n       final String expectedSessionId) {\n-    retryUntilConnected(() -> {\n-      getExpectedZookeeper(expectedSessionId)\n-          .create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode, cb,\n-              new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n-                @Override\n-                protected void doRetry() {\n-                  doAsyncCreate(path, data, mode, System.currentTimeMillis(), cb,\n-                      expectedSessionId);\n-                }\n-              });\n-      return null;\n-    });\n+    try {\n+      retryUntilConnected(() -> {\n+        getExpectedZookeeper(expectedSessionId)\n+            .create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode, cb,\n+                new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+                  @Override\n+                  protected void doRetry() {\n+                    doAsyncCreate(path, data, mode, System.currentTimeMillis(), cb,\n+                        expectedSessionId);\n+                  }\n+                });\n+        return null;\n+      });\n+    } catch (RuntimeException e) {", "originalCommit": "667964e4cea5e67bee70d68e43161cbd7af3be84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ0NzAyMg==", "url": "https://github.com/apache/helix/pull/1592#discussion_r541447022", "bodyText": "I thought about it but I think RuntimeException is good enough. If the RetryUntilConnected is changed to throw a checked exception, all the APIs would have to change and throw the checked exception. I just don't think the behavior would change. Let's keep the RuntimeException as it indicates we know what we are doing.", "author": "huizhilu", "createdAt": "2020-12-12T00:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQzNjg4NA=="}], "type": "inlineReview"}]}