{"pr_number": 1494, "pr_title": "Add admin and Rest API to purge instances that have been offline more than specified period of time", "pr_createdAt": "2020-10-28T17:53:12Z", "pr_url": "https://github.com/apache/helix/pull/1494", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NjAzNA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513786034", "bodyText": "Can we specify the map meaning here? It could be confusing if we dont clarify it in Java doc.", "author": "junkaixue", "createdAt": "2020-10-28T21:56:23Z", "path": "helix-core/src/main/java/org/apache/helix/HelixAdmin.java", "diffHunk": "@@ -228,6 +228,13 @@ void addResource(String clusterName, String resourceName, int numPartitions, Str\n    */\n   void dropInstance(String clusterName, InstanceConfig instanceConfig);\n \n+  /**\n+   * Purge offline instances from a cluster\n+   * @param clusterName\n+   * @param customizedPurgeMap", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4Njc1MQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513786751", "bodyText": "Better to have public constants class to hold this kind of key words.", "author": "junkaixue", "createdAt": "2020-10-28T21:57:58Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -105,6 +106,7 @@\n   public static final String CONNECTION_TIMEOUT = \"helixAdmin.timeOutInSec\";\n   private static final String MAINTENANCE_ZNODE_ID = \"maintenance\";\n   private static final int DEFAULT_SUPERCLUSTER_REPLICA = 3;\n+  public static final String OFFLINE_NODE_PURGE_TIMEOUT = \"purge.timeout\";", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5NjQwNQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513896405", "bodyText": "If this is an API, should not the timeout be specified in the purgeOfflineInstances() call? Why still need to keep this in clusterConfig?", "author": "lei-xia", "createdAt": "2020-10-29T02:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4Njc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1MTEwMg==", "url": "https://github.com/apache/helix/pull/1494#discussion_r514451102", "bodyText": "We provide an option for users to define the default timeout in cluster config, so that they do not need to provide time in every call. If they do give a timeout in purge call, the value will override the default one in cluster config.", "author": "zhangmeng916", "createdAt": "2020-10-29T17:46:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4Njc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NzQwOA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513787408", "bodyText": "I am also confused here. What could other entries other than this timeout?", "author": "junkaixue", "createdAt": "2020-10-28T21:59:22Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2070,45 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,\n+      Map<String, String> customizedPurgeMap) {\n+    String timeout = customizedPurgeMap.get(OFFLINE_NODE_PURGE_TIMEOUT);", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NzgzMQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513787831", "bodyText": "Shall we do a try catch? If the timeout is invalid string by human error, shall we stop it or use default value?", "author": "junkaixue", "createdAt": "2020-10-28T22:00:18Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2070,45 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,\n+      Map<String, String> customizedPurgeMap) {\n+    String timeout = customizedPurgeMap.get(OFFLINE_NODE_PURGE_TIMEOUT);\n+    Long timeoutValue;\n+    // in case there is no customized timeout value, use the one defined in cluster config\n+    if (timeout == null) {\n+      timeoutValue = _configAccessor.getClusterConfig(clusterName).getOfflineNodeTimeOutForPurge();\n+    } else {\n+      timeoutValue = Long.valueOf(timeout);", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU1NTIwOA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r514555208", "bodyText": "With the input changed to Long, now it's not an issue.", "author": "zhangmeng916", "createdAt": "2020-10-29T20:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NzgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4ODYyMA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513788620", "bodyText": "We can create a set and use instanceConfigMap.keySet().removeAll(set).", "author": "junkaixue", "createdAt": "2020-10-28T22:02:10Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2070,45 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,\n+      Map<String, String> customizedPurgeMap) {\n+    String timeout = customizedPurgeMap.get(OFFLINE_NODE_PURGE_TIMEOUT);\n+    Long timeoutValue;\n+    // in case there is no customized timeout value, use the one defined in cluster config\n+    if (timeout == null) {\n+      timeoutValue = _configAccessor.getClusterConfig(clusterName).getOfflineNodeTimeOutForPurge();\n+    } else {\n+      timeoutValue = Long.valueOf(timeout);\n+    }\n+\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    String path = PropertyPathBuilder.instanceConfig(clusterName);\n+    BaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_zkClient);\n+    List<ZNRecord> znRecords = baseAccessor.getChildren(path, null, 0, 0, 0);\n+    for (ZNRecord record : znRecords) {\n+      if (record != null) {\n+        InstanceConfig instanceConfig = new InstanceConfig(record);\n+        instanceConfigMap.put(instanceConfig.getInstanceName(), instanceConfig);\n+      }\n+    }\n+\n+    path = PropertyPathBuilder.liveInstance(clusterName);\n+    List<String> liveNodes = baseAccessor.getChildNames(path, 0);\n+    liveNodes.forEach(liveNode -> instanceConfigMap.remove(liveNode));", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4OTE4OA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513789188", "bodyText": "Same here, we can use instanceConfigMap.keySet().removeAll(toRemoveInstances); It has better performance.", "author": "junkaixue", "createdAt": "2020-10-28T22:03:40Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2070,45 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,\n+      Map<String, String> customizedPurgeMap) {\n+    String timeout = customizedPurgeMap.get(OFFLINE_NODE_PURGE_TIMEOUT);\n+    Long timeoutValue;\n+    // in case there is no customized timeout value, use the one defined in cluster config\n+    if (timeout == null) {\n+      timeoutValue = _configAccessor.getClusterConfig(clusterName).getOfflineNodeTimeOutForPurge();\n+    } else {\n+      timeoutValue = Long.valueOf(timeout);\n+    }\n+\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    String path = PropertyPathBuilder.instanceConfig(clusterName);\n+    BaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_zkClient);\n+    List<ZNRecord> znRecords = baseAccessor.getChildren(path, null, 0, 0, 0);\n+    for (ZNRecord record : znRecords) {\n+      if (record != null) {\n+        InstanceConfig instanceConfig = new InstanceConfig(record);\n+        instanceConfigMap.put(instanceConfig.getInstanceName(), instanceConfig);\n+      }\n+    }\n+\n+    path = PropertyPathBuilder.liveInstance(clusterName);\n+    List<String> liveNodes = baseAccessor.getChildNames(path, 0);\n+    liveNodes.forEach(liveNode -> instanceConfigMap.remove(liveNode));\n+\n+    Set<String> toRemoveInstances = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      String historyPath = PropertyPathBuilder.instanceHistory(clusterName, instanceName);\n+      ZNRecord znRecord = baseAccessor.get(historyPath, null, 0);\n+      ParticipantHistory participantHistory = new ParticipantHistory(znRecord);\n+      long lastOfflineTime = participantHistory.getLastOfflineTime();\n+      if (lastOfflineTime == -1 || timeoutValue < 0\n+          || System.currentTimeMillis() - lastOfflineTime < timeoutValue) {\n+        toRemoveInstances.add(instanceName);\n+      }\n+    }\n+    toRemoveInstances.forEach(instance -> instanceConfigMap.remove(instance));", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0NTM3Nw==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513845377", "bodyText": "If timeoutValue < 0, can we return earlier with an empty map?", "author": "NealSun96", "createdAt": "2020-10-29T00:49:35Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2070,45 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,\n+      Map<String, String> customizedPurgeMap) {\n+    String timeout = customizedPurgeMap.get(OFFLINE_NODE_PURGE_TIMEOUT);\n+    Long timeoutValue;\n+    // in case there is no customized timeout value, use the one defined in cluster config\n+    if (timeout == null) {\n+      timeoutValue = _configAccessor.getClusterConfig(clusterName).getOfflineNodeTimeOutForPurge();\n+    } else {\n+      timeoutValue = Long.valueOf(timeout);\n+    }\n+\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    String path = PropertyPathBuilder.instanceConfig(clusterName);\n+    BaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_zkClient);\n+    List<ZNRecord> znRecords = baseAccessor.getChildren(path, null, 0, 0, 0);\n+    for (ZNRecord record : znRecords) {\n+      if (record != null) {\n+        InstanceConfig instanceConfig = new InstanceConfig(record);\n+        instanceConfigMap.put(instanceConfig.getInstanceName(), instanceConfig);\n+      }\n+    }\n+\n+    path = PropertyPathBuilder.liveInstance(clusterName);\n+    List<String> liveNodes = baseAccessor.getChildNames(path, 0);\n+    liveNodes.forEach(liveNode -> instanceConfigMap.remove(liveNode));\n+\n+    Set<String> toRemoveInstances = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      String historyPath = PropertyPathBuilder.instanceHistory(clusterName, instanceName);\n+      ZNRecord znRecord = baseAccessor.get(historyPath, null, 0);\n+      ParticipantHistory participantHistory = new ParticipantHistory(znRecord);\n+      long lastOfflineTime = participantHistory.getLastOfflineTime();\n+      if (lastOfflineTime == -1 || timeoutValue < 0", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1MzA1OA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r514453058", "bodyText": "Yeah, good catch!", "author": "zhangmeng916", "createdAt": "2020-10-29T17:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0NTM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5Njk3Nw==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513896977", "bodyText": "Should the API looks like:  purgeOfflineInstances(clusterName, long timeout), which will delete all instances that have been offline longer than timeout?", "author": "lei-xia", "createdAt": "2020-10-29T02:46:55Z", "path": "helix-core/src/main/java/org/apache/helix/HelixAdmin.java", "diffHunk": "@@ -228,6 +228,13 @@ void addResource(String clusterName, String resourceName, int numPartitions, Str\n    */\n   void dropInstance(String clusterName, InstanceConfig instanceConfig);\n \n+  /**\n+   * Purge offline instances from a cluster\n+   * @param clusterName\n+   * @param customizedPurgeMap\n+   */\n+  void purgeOfflineInstances(String clusterName, Map<String, String> customizedPurgeMap);", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5NzQ1OQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513897459", "bodyText": "Why a map here, what could be specified other than timeout?", "author": "lei-xia", "createdAt": "2020-10-29T02:47:58Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -250,6 +252,13 @@ public void dropInstance(String clusterName, InstanceConfig instanceConfig) {\n     }\n   }\n \n+  @Override\n+  public void purgeOfflineInstances(String clusterName, Map<String, String> customizedPurgeMap) {", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5OTMyMQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513899321", "bodyText": "value -> instanceConfig to be clearer?", "author": "huizhilu", "createdAt": "2020-10-29T02:51:50Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -250,6 +252,13 @@ public void dropInstance(String clusterName, InstanceConfig instanceConfig) {\n     }\n   }\n \n+  @Override\n+  public void purgeOfflineInstances(String clusterName, Map<String, String> customizedPurgeMap) {\n+    Map<String, InstanceConfig> timeoutOfflineInstances = findTimeoutOfflineInstances(clusterName,\n+        customizedPurgeMap);\n+    timeoutOfflineInstances.values().forEach(value -> dropInstance(clusterName, value));", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkwNjMwNw==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513906307", "bodyText": "Can we have a warning log for why json parsing fails which could help us debug.\nNot sure if we have a unit test to test this kind of failure: content(eg. format) is incorret. Then we should not return OK, but a bad client request.", "author": "huizhilu", "createdAt": "2020-10-29T03:07:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/ClusterAccessor.java", "diffHunk": "@@ -282,6 +282,17 @@ public Response updateCluster(@PathParam(\"clusterId\") String clusterId,\n           return badRequest(e.getMessage());\n         }\n         break;\n+      case purgeOfflineParticipants:\n+        Map<String, String> customizedPurgeMap = new HashMap<>();\n+        try {\n+          customizedPurgeMap =\n+              OBJECT_MAPPER.readValue(content, new TypeReference<HashMap<String, String>>() {\n+              });\n+        } catch (Exception e) {\n+          // NOP", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkxMjUwNg==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513912506", "bodyText": "From the API logic, it seems what is needed is only timeout? Then I think we don't have to pass along the map, but only the timeout value from the rest api layer: timeout = customizedPurgeMap.get(OFFLINE_NODE_PURGE_TIMEOUT);\nThen the APIs only need the timeout param, not a map.", "author": "huizhilu", "createdAt": "2020-10-29T03:20:05Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2070,45 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,\n+      Map<String, String> customizedPurgeMap) {", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkxNTI3NA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r513915274", "bodyText": "It seems only timeout is needed. Anther option is, we can add a QueryParam timeout, instead of putting it a body content? It'd be easier to use.", "author": "huizhilu", "createdAt": "2020-10-29T03:24:15Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/ClusterAccessor.java", "diffHunk": "@@ -282,6 +282,17 @@ public Response updateCluster(@PathParam(\"clusterId\") String clusterId,\n           return badRequest(e.getMessage());\n         }\n         break;\n+      case purgeOfflineParticipants:\n+        Map<String, String> customizedPurgeMap = new HashMap<>();\n+        try {\n+          customizedPurgeMap =\n+              OBJECT_MAPPER.readValue(content, new TypeReference<HashMap<String, String>>() {", "originalCommit": "4c85ed5595bade663965f91fbb9f750823c6103f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5NjYzNA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r514896634", "bodyText": "i think the javadoc here could use more work. we should try to add more context on why and when the interface should be used.\nalso i'm not sure timeout is the right term for this. perhaps rename it to something like offlineDuration? also if you could please add a description as to how this offlineDuration is measured/calculated.", "author": "narendly", "createdAt": "2020-10-30T06:35:05Z", "path": "helix-core/src/main/java/org/apache/helix/HelixAdmin.java", "diffHunk": "@@ -228,6 +228,13 @@ void addResource(String clusterName, String resourceName, int numPartitions, Str\n    */\n   void dropInstance(String clusterName, InstanceConfig instanceConfig);\n \n+  /**\n+   * Purge offline instances from a cluster\n+   * @param clusterName\n+   * @param timeout\n+   */\n+  void purgeOfflineInstances(String clusterName, Long timeout);", "originalCommit": "0729e94c953f2c23272960bd65a828752caf1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5NzAzNA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r514897034", "bodyText": "also is there a strong reason why we don't use a primitive long?", "author": "narendly", "createdAt": "2020-10-30T06:36:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5NjYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MzAyOQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515243029", "bodyText": "The main reason is that user may choose not to input the duration for timeout, and we use the default one in cluster config, which means it is a null. I tried to change Long to long, and check null in cluster accessor. You can take a look and let me know whether you think this is better.", "author": "zhangmeng916", "createdAt": "2020-10-30T17:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5NjYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5NjgyOA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r514896828", "bodyText": "again, timeout might be a bit of a misnomer here.", "author": "narendly", "createdAt": "2020-10-30T06:35:42Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2069,43 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,", "originalCommit": "0729e94c953f2c23272960bd65a828752caf1526", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5NzEzNw==", "url": "https://github.com/apache/helix/pull/1494#discussion_r514897137", "bodyText": "i'd prefer a primitive long here", "author": "narendly", "createdAt": "2020-10-30T06:36:51Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2069,43 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,\n+      Long timeout) {", "originalCommit": "0729e94c953f2c23272960bd65a828752caf1526", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5NzM0NQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r514897345", "bodyText": "instead of doing the null check, maybe you could define a NOT_SET constant of some sort...", "author": "narendly", "createdAt": "2020-10-30T06:37:35Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2069,43 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,\n+      Long timeout) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    // in case there is no customized timeout value, use the one defined in cluster config\n+    if (timeout == null) {\n+      timeout = _configAccessor.getClusterConfig(clusterName).getOfflineNodeTimeOutForPurge();\n+    }", "originalCommit": "0729e94c953f2c23272960bd65a828752caf1526", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5ODE1Mg==", "url": "https://github.com/apache/helix/pull/1494#discussion_r514898152", "bodyText": "nit: is there a strong reason we're using a BaseDataAccessor instance here? for helix-related i/o, it is better taste to use HelixDataAccessor because you can avoid having to cast it to helix data model from znrecord.\nthat way, code will be cleaner and easier to read, shorter, and more concise.", "author": "narendly", "createdAt": "2020-10-30T06:40:35Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2069,43 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,\n+      Long timeout) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    // in case there is no customized timeout value, use the one defined in cluster config\n+    if (timeout == null) {\n+      timeout = _configAccessor.getClusterConfig(clusterName).getOfflineNodeTimeOutForPurge();\n+    }\n+    if (timeout < 0) {\n+      return instanceConfigMap;\n+    }\n+\n+    String path = PropertyPathBuilder.instanceConfig(clusterName);\n+    BaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_zkClient);\n+    List<ZNRecord> znRecords = baseAccessor.getChildren(path, null, 0, 0, 0);\n+    for (ZNRecord record : znRecords) {\n+      if (record != null) {\n+        InstanceConfig instanceConfig = new InstanceConfig(record);\n+        instanceConfigMap.put(instanceConfig.getInstanceName(), instanceConfig);\n+      }\n+    }\n+\n+    path = PropertyPathBuilder.liveInstance(clusterName);\n+    List<String> liveNodes = baseAccessor.getChildNames(path, 0);\n+    instanceConfigMap.keySet().removeAll(liveNodes);\n+\n+    Set<String> toRemoveInstances = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      String historyPath = PropertyPathBuilder.instanceHistory(clusterName, instanceName);\n+      ZNRecord znRecord = baseAccessor.get(historyPath, null, 0);\n+      ParticipantHistory participantHistory = new ParticipantHistory(znRecord);\n+      long lastOfflineTime = participantHistory.getLastOfflineTime();\n+      if (lastOfflineTime == -1 || System.currentTimeMillis() - lastOfflineTime < timeout) {\n+        toRemoveInstances.add(instanceName);\n+      }\n+    }\n+    instanceConfigMap.keySet().removeAll(toRemoveInstances);\n+    return instanceConfigMap;", "originalCommit": "0729e94c953f2c23272960bd65a828752caf1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MzI1Nw==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515243257", "bodyText": "Good catch!", "author": "zhangmeng916", "createdAt": "2020-10-30T17:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5ODE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5ODkxMA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r514898910", "bodyText": "two high-level comments:\n\nare we not using the lock? as discussed offline, i think to complete this feature, it would be a good idea to use the distributed lock here since all sorts of race conditions are possible\nwhat kind of failure handling are we doing in this call? we're making multiple dropInstance calls here and there's no guarantee that all would go through. plus, the method itself isn't returning anything so there's no way for the user to determine whether the purge operation was successful or not", "author": "narendly", "createdAt": "2020-10-30T06:43:19Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -250,6 +251,13 @@ public void dropInstance(String clusterName, InstanceConfig instanceConfig) {\n     }\n   }\n \n+  @Override\n+  public void purgeOfflineInstances(String clusterName, Long timeout) {\n+    Map<String, InstanceConfig> timeoutOfflineInstances = findTimeoutOfflineInstances(clusterName\n+        , timeout);\n+    timeoutOfflineInstances.values().forEach(instance -> dropInstance(clusterName, instance));", "originalCommit": "0729e94c953f2c23272960bd65a828752caf1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MzA3Mw==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515243073", "bodyText": "The API will be only called by users when they need, i.e., Helix will not automatically purge participants. And users will call it when they think it is safe, meaning no instance joining happen. The major concern from user side of having locks in purge function and in instance joining function is that they may have thousands of instances come online at the same time, if each of them tries to read and write the lock, zookeeper will have a burst, and this is dangerous.\ndrop instances in this purge function are synchronous functions, and any exception thrown in the drop in stances will be seen by users. Do you suggest a map return or something?", "author": "zhangmeng916", "createdAt": "2020-10-30T17:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5ODkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MTU1Mw==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515451553", "bodyText": "if this is going to be called by the user, i think it's fair to assume that there would not be race conditions (because we expect the user to do concurrency control). however, i'm still a little confused.\n\n\nThe major concern from user side of having locks in purge function and in instance joining function is that they may have thousands of instances come online at the same time, if each of them tries to read and write the lock, zookeeper will have a burst, and this is dangerous.\n\nas discussed, i think what we ultimately want to achieve is to provide a service or a sidecar controller to do this automatically. for now, we shift the burden of calling this to the user, but we want to automate this eventually. i'm not quite getting the \"dangerous\" part - why is it dangerous to use zk to implement the lock? it's one of the things zk is meant for. having hundreds and thousands of zk clients with zk as the distributed lock is not unheard of? i'm not exactly understanding the situation you're describing.\n\ni was initially thinking maybe it might be better to catch the exception and throw it from this function as a \"purge failure\", with the list of instances that were purged successfully and (optionally) the list of instances that were not due to a failure if there are any. Otherwise, there's no way to know for the user or ourselves what exactly happened. I don't think that would be too hard to implement on top of what you already have now - do you think that would help us debug this better if something goes wrong? (vs just relying on the exception trace/msg bubbled up from the failed dropInstance call?)", "author": "narendly", "createdAt": "2020-10-31T03:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5ODkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTQ1Mw==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515509453", "bodyText": "For question 1, Helix does not plan to integrate this purge logic into controller as it unnecessarily complicates the controller logic. Then it will be up to users to decide whether they would like take the risk for race condition, or afford the traffic in zookeeper. The concern from users was during deployment, zk is already undergoing a lot of traffic, and adding one more read/write per instance in a short time period (e.g. 10 or 20 seconds) for lock makes it worse without adding extra benefit for them.\nI think a possible future work could be Helix provides config to use lock or not during purge and instances come online, and users could choose to turn it on or off depending on their real use case.", "author": "zhangmeng916", "createdAt": "2020-10-31T15:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5ODkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0NjQ0OA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515746448", "bodyText": "@zhangmeng916 let's read that one a little more carefully.\n\nas discussed, i think what we ultimately want to achieve is to provide a service or a sidecar controller to do this automatically\n\nthis doesn't mean that we will include the purge logic into the main controller. it clearly states that it will be a service or a sidecar controller. and i believe we all agreed that this would be the direction.\nthe reason we are shifting the responsibility to the user is for the ease of implementation. ultimately, we want to automate this in our holistic cluster management environment (HaaS).\n\nadding one more read/write per instance in a short time period (e.g. 10 or 20 seconds) for lock makes it worse without adding extra benefit for them.\n\nI'm not sure if i completely agree with the statement. 10-20 sec is a very generous duration where zk server will be handle many read/writes. also I don't agree that there's no extra benefit. the benefit we're talking about here is concurrency control in a distributed setting? it's not like we'd be locking for nothing.\nif you prefer to leave out locking for this API (which is totally fine with the right assumptions), i suggest we give some context in the JavaDoc and clearly state that this operation is not thread-safe and that it should lock in the future when called automatically.", "author": "narendly", "createdAt": "2020-11-02T05:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5ODkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MDcwMQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515450701", "bodyText": "sorry if i didnt make myself more clear. when i said VALUE_NOT_SET, we usually name these constants in a more descriptive manner - e.g.) OFFLINE_DURATION_VALUE_NOT_SET for example. this is ZKHelixAdmin, so it contains a lot of different operations, so it's better to make this crystal clear.\nalso nit: usually longs have an L appended to it. -> -1L;", "author": "narendly", "createdAt": "2020-10-31T03:41:12Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -113,6 +114,7 @@\n   private final boolean _usesExternalZkClient;\n \n   private static Logger logger = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+  private static final long VALUE_NOT_SET = -1;", "originalCommit": "f05ca6f1649141f5bdd64b71fe359efe5659d3e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNjYwOQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515506609", "bodyText": "Interesting, in the other PR, there's a comment asking for generalizing the NOT SET value, and that's why I modified it. c78c7eb\nI separated them into different definitions again. Let me know whether this is good.", "author": "zhangmeng916", "createdAt": "2020-10-31T15:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MDcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0MjQzOA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515742438", "bodyText": "@zhangmeng916 I actually agree with that suggestion that we should combine all NOT SET values into one. Sorry I wasn't aware that there were many other NOT SET bits floating around.\nIt's either or - you could combine all of them into one (just make sure they're all using -1) or leave them all separate and create a separate issue/PR for it.", "author": "narendly", "createdAt": "2020-11-02T05:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MDcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0NDQzOA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515744438", "bodyText": "I will create a new PR for standardize the NOT SET value. Seems there are a lot, and I'll modify together.", "author": "zhangmeng916", "createdAt": "2020-11-02T05:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MDcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MTgxMQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515451811", "bodyText": "-1 is a magic number and we should generally avoid having magic numbers..\nit would look nicer if you could make the not set constant a public constant and use it here - that way it's easy to track what's going on and code is much more readable.", "author": "narendly", "createdAt": "2020-10-31T03:56:54Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/ClusterAccessor.java", "diffHunk": "@@ -282,6 +282,13 @@ public Response updateCluster(@PathParam(\"clusterId\") String clusterId,\n           return badRequest(e.getMessage());\n         }\n         break;\n+      case purgeOfflineParticipants:\n+        if (timeout == null || timeout < 0) {\n+          helixAdmin.purgeOfflineInstances(clusterId, -1);", "originalCommit": "f05ca6f1649141f5bdd64b71fe359efe5659d3e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MTkyOA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515451928", "bodyText": "important: should we clean up all zk resources after the test is done? e.g.) tool.close(), dataAccessor.close(), etc.\notherwise, we'll have a lot of free-floating threads that make the entire test suite unstable and slow.", "author": "narendly", "createdAt": "2020-10-31T03:58:43Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java", "diffHunk": "@@ -1008,4 +1008,58 @@ public void testUpdateCustomizedStateConfig() throws Exception {\n     Assert.assertEquals(listTypesFromZk.get(0), \"mockType2\");\n     Assert.assertEquals(listTypesFromZk.get(1), \"mockType3\");\n   }\n+\n+  @Test\n+  public void testPurgeOfflineInstances() {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    HelixAdmin tool = new ZKHelixAdmin(_gZkClient);\n+    tool.addCluster(clusterName, true);\n+\n+    HelixDataAccessor dataAccessor = new ZKHelixDataAccessor(clusterName, _baseAccessor);\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    // set default offline node timeout for purge in cluster config\n+    ClusterConfig clusterConfig = dataAccessor.getProperty(keyBuilder.clusterConfig());\n+    clusterConfig.setOfflineNodeTimeOutForPurge(100000L);\n+    dataAccessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n+\n+    String hostname = \"host1\";\n+    String port = \"9999\";\n+    String instanceName = hostname + \"_\" + port;\n+    InstanceConfig config = new InstanceConfig(instanceName);\n+    config.setHostName(hostname);\n+    config.setPort(port);\n+    tool.addInstance(clusterName, config);\n+    tool.enableInstance(clusterName, instanceName, true);\n+\n+    LiveInstance liveInstance = new LiveInstance(instanceName);\n+    liveInstance.setSessionId(UUID.randomUUID().toString());\n+    liveInstance.setHelixVersion(UUID.randomUUID().toString());\n+    dataAccessor.setProperty(keyBuilder.liveInstance(instanceName), liveInstance);\n+\n+    dataAccessor.removeProperty(keyBuilder.liveInstance(instanceName));\n+    ZNRecord znRecord = new ZNRecord(instanceName);\n+    znRecord\n+        .setSimpleField(\"LAST_OFFLINE_TIME\", String.valueOf(System.currentTimeMillis() - 50000L));\n+    _baseAccessor.set(PropertyPathBuilder.instanceHistory(clusterName, instanceName), znRecord, 1);\n+\n+    // This purge will not remove the instance since the default timeout is not met yet.\n+    tool.purgeOfflineInstances(clusterName, -1);\n+    Assert.assertTrue(_gZkClient.exists(keyBuilder.instanceConfig(instanceName).getPath()),\n+        \"Instance should still be there\");\n+\n+    // This purge will remove the instance as the customized purge timeout is met.\n+    Map<String, String> purgeMap = new HashMap<>();\n+    tool.purgeOfflineInstances(clusterName, 10000L);\n+    Assert.assertFalse(_gZkClient.exists(keyBuilder.instanceConfig(instanceName).getPath()),\n+        \"Instance should already be dropped\");\n+\n+    tool.dropCluster(clusterName);\n+    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));", "originalCommit": "f05ca6f1649141f5bdd64b71fe359efe5659d3e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNjEyNw==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515506127", "bodyText": "All these close parts are already handled in the aftersuite of base test class.", "author": "zhangmeng916", "createdAt": "2020-10-31T15:07:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjEyMg==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515452122", "bodyText": "could you double-check if this zkclient is a RealmAwareZkClient?", "author": "narendly", "createdAt": "2020-10-31T04:00:55Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -2061,4 +2070,37 @@ public ZKHelixAdmin build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  private Map<String, InstanceConfig> findTimeoutOfflineInstances(String clusterName,\n+      long offlineDuration) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    // in case there is no customized timeout value, use the one defined in cluster config\n+    if (offlineDuration == VALUE_NOT_SET) {\n+      offlineDuration =\n+          _configAccessor.getClusterConfig(clusterName).getOfflineNodeTimeOutForPurge();\n+      if (offlineDuration == VALUE_NOT_SET) {\n+        return instanceConfigMap;\n+      }\n+    }\n+\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_zkClient));", "originalCommit": "f05ca6f1649141f5bdd64b71fe359efe5659d3e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNjE4OA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515506188", "bodyText": "Yeah, confirmed it's a RealmAwareZkClient.", "author": "zhangmeng916", "createdAt": "2020-10-31T15:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjEyMg=="}], "type": "inlineReview"}, {"oid": "a4f236de55198ea09f6e3b7c11b5c2ffb55c0ec1", "url": "https://github.com/apache/helix/commit/a4f236de55198ea09f6e3b7c11b5c2ffb55c0ec1", "message": "more fix", "committedDate": "2020-10-31T15:50:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3MDg3MA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515570870", "bodyText": "Nit: space?", "author": "narendly", "createdAt": "2020-11-01T03:42:18Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -163,7 +165,7 @@\n   private final static int MIN_REBALANCE_PREFERENCE = 0;\n   public final static boolean DEFAULT_GLOBAL_REBALANCE_ASYNC_MODE_ENABLED = true;\n   private static final int GLOBAL_TARGET_TASK_THREAD_POOL_SIZE_NOT_SET = -1;\n-  private static final long VALUE_NOT_SET = -1;\n+  private static final int  OFFLINE_NODE_TIME_OUT_FOR_MAINTENANCE_MODE_NOT_SET = -1;", "originalCommit": "a4f236de55198ea09f6e3b7c11b5c2ffb55c0ec1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3MDg4NA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515570884", "bodyText": "nit: offline \"duration\" for consistency", "author": "narendly", "createdAt": "2020-11-01T03:42:40Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -153,6 +153,8 @@\n \n   public final static String TASK_QUOTA_RATIO_NOT_SET = \"-1\";\n \n+  public static final long OFFLINE_TIMEOUT_FOR_PURGE_NOT_SET = -1L;", "originalCommit": "a4f236de55198ea09f6e3b7c11b5c2ffb55c0ec1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3NDMwNQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515574305", "bodyText": "Actually I changed all other places to offline timeout. I feel timeout could better show the meaning for this duration.", "author": "zhangmeng916", "createdAt": "2020-11-01T04:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3MDg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2NzkyMA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515667920", "bodyText": "i added some more explanation here: https://github.com/apache/helix/pull/1494/files#r515667749\nultimately it's up to you to make the call since you're the owner, but i wanted to make it clear why i think using 'timeout' to describe this could be confusing.", "author": "narendly", "createdAt": "2020-11-01T20:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3MDg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3MDkzMg==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515570932", "bodyText": "generally we avoid static imports. you just import the class, and use it as CLASS.CONSTANT_NAME", "author": "narendly", "createdAt": "2020-11-01T03:43:34Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java", "diffHunk": "@@ -83,6 +83,8 @@\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.Test;\n \n+import static org.apache.helix.model.ClusterConfig.OFFLINE_TIMEOUT_FOR_PURGE_NOT_SET;", "originalCommit": "a4f236de55198ea09f6e3b7c11b5c2ffb55c0ec1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3MTE0OQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515571149", "bodyText": "info -> warn or error", "author": "narendly", "createdAt": "2020-11-01T03:46:35Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -250,6 +253,23 @@ public void dropInstance(String clusterName, InstanceConfig instanceConfig) {\n     }\n   }\n \n+  @Override\n+  public List<String> purgeOfflineInstances(String clusterName, long offlineTimeout) {\n+    Map<String, InstanceConfig> timeoutOfflineInstances = findTimeoutOfflineInstances(clusterName\n+        , offlineTimeout);\n+    List<String> failToPurgeInstances = new ArrayList<>();\n+    timeoutOfflineInstances.values().forEach(instance -> {\n+      try {\n+        dropInstance(clusterName, instance);\n+      } catch (HelixException e) {\n+        logger.info(\"Failed to purge instance {} in cluster {}. Exception: {}\", instance,", "originalCommit": "a4f236de55198ea09f6e3b7c11b5c2ffb55c0ec1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3MTI2Nw==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515571267", "bodyText": "I think it's a bit awkward to return the list of instances whose deletion failed; usually these methods don't return anything, or they return the list of instances whose deletion succeeded.\nhow about we keep it as void, and only log one line at the end if there are any instances whose deletion failed? that way we persist the information we need while being concise.\njust to cut down on back-and-forth, this is what I mean:\nfor-each {\n    try {\n        dropInstance();\n    } catch (Exception e) {\n        failedDeletions.add(instanceName);\n    }\n}\nif (failedDeletions.size > 0) {\n    LOG.error(\"ZKHelixAdmin::purgeOfflineInstances(): failed to drop the following instances: \" + failedDeletions);\n}\n\nquick, concise, has all the information we need, and don't pollute the log if there are a lot of failures. what do you think?", "author": "narendly", "createdAt": "2020-11-01T03:48:49Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -250,6 +253,23 @@ public void dropInstance(String clusterName, InstanceConfig instanceConfig) {\n     }\n   }\n \n+  @Override\n+  public List<String> purgeOfflineInstances(String clusterName, long offlineTimeout) {\n+    Map<String, InstanceConfig> timeoutOfflineInstances = findTimeoutOfflineInstances(clusterName\n+        , offlineTimeout);\n+    List<String> failToPurgeInstances = new ArrayList<>();\n+    timeoutOfflineInstances.values().forEach(instance -> {\n+      try {\n+        dropInstance(clusterName, instance);\n+      } catch (HelixException e) {\n+        logger.info(\"Failed to purge instance {} in cluster {}. Exception: {}\", instance,\n+            clusterName, e);\n+        failToPurgeInstances.add(instance.getInstanceName());\n+      }\n+    });\n+    return failToPurgeInstances;", "originalCommit": "a4f236de55198ea09f6e3b7c11b5c2ffb55c0ec1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2Nzc0OQ==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515667749", "bodyText": "\"the threshold of offline time to\"... -> this is a little confusing. the fact that we are using timeout to describe this could be confusing to the reader.\ntimeout is a term used when one actively counts down to see if an operation completes or not. in this case, as you clarified, we are not actively counting down or waiting on anything. (rather, this api is being called by the user passively) so the use of timeout is still misleading. my suggestion is to use offlineDuration as that wouldn't cause any confusion or give readers a wrong idea.\nfor example, something like this would work:\n@param offlineDuration if an offline instance has been offline for longer than the set offlineDuration, the offline instance becomes eligible for being purged/deleted", "author": "narendly", "createdAt": "2020-11-01T20:26:16Z", "path": "helix-core/src/main/java/org/apache/helix/HelixAdmin.java", "diffHunk": "@@ -228,6 +228,16 @@ void addResource(String clusterName, String resourceName, int numPartitions, Str\n    */\n   void dropInstance(String clusterName, InstanceConfig instanceConfig);\n \n+  /**\n+   * Purge offline instances that have been offline for longer than the offline duration time\n+   * from a cluster\n+   * @param clusterName\n+   * @param offlineTimeout the threshold of offline time to decide whether an offline instance", "originalCommit": "d9aa396ef38bd71832494cf4756056f0a9c95358", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5b1afb2a3e74a28a5a1f312964faa9eb8fbe8674", "url": "https://github.com/apache/helix/commit/5b1afb2a3e74a28a5a1f312964faa9eb8fbe8674", "message": "change timeout to duration", "committedDate": "2020-11-01T22:43:58Z", "type": "forcePushed"}, {"oid": "00baa1d970725e7b8d10635a02eb92067cb6507c", "url": "https://github.com/apache/helix/commit/00baa1d970725e7b8d10635a02eb92067cb6507c", "message": "Implement offline nodes purging", "committedDate": "2020-11-02T00:14:23Z", "type": "commit"}, {"oid": "a5ef4728b5a6f12988dcc9921446c2ae45259eec", "url": "https://github.com/apache/helix/commit/a5ef4728b5a6f12988dcc9921446c2ae45259eec", "message": "fix comment", "committedDate": "2020-11-02T00:14:23Z", "type": "commit"}, {"oid": "60ae86f3c9b5476a8e7efe6f46babd574b830fa7", "url": "https://github.com/apache/helix/commit/60ae86f3c9b5476a8e7efe6f46babd574b830fa7", "message": "fix more comments", "committedDate": "2020-11-02T00:14:23Z", "type": "commit"}, {"oid": "f46bdbd118ea273c8163f2297f803e3db0fe5bc8", "url": "https://github.com/apache/helix/commit/f46bdbd118ea273c8163f2297f803e3db0fe5bc8", "message": "more fix", "committedDate": "2020-11-02T00:14:23Z", "type": "commit"}, {"oid": "f5dbcf94258b8f8c68ba0cd95b4212732337c6ad", "url": "https://github.com/apache/helix/commit/f5dbcf94258b8f8c68ba0cd95b4212732337c6ad", "message": "update", "committedDate": "2020-11-02T00:14:23Z", "type": "commit"}, {"oid": "1e782944006b247afcfd2dda7122369267964810", "url": "https://github.com/apache/helix/commit/1e782944006b247afcfd2dda7122369267964810", "message": "change timeout to duration", "committedDate": "2020-11-02T00:14:23Z", "type": "forcePushed"}, {"oid": "bf01df8cf12bf17711de59cb54f93ca521278535", "url": "https://github.com/apache/helix/commit/bf01df8cf12bf17711de59cb54f93ca521278535", "message": "change timeout to duration", "committedDate": "2020-11-02T00:51:35Z", "type": "forcePushed"}, {"oid": "18ca1483f0550961bce67a019d1a4c8ba3736ddd", "url": "https://github.com/apache/helix/commit/18ca1483f0550961bce67a019d1a4c8ba3736ddd", "message": "change timeout to duration", "committedDate": "2020-11-02T01:31:38Z", "type": "forcePushed"}, {"oid": "7a922194553c4563bc3177eacfbac224f88bb920", "url": "https://github.com/apache/helix/commit/7a922194553c4563bc3177eacfbac224f88bb920", "message": "change timeout to duration", "committedDate": "2020-11-02T01:33:07Z", "type": "commit"}, {"oid": "7a922194553c4563bc3177eacfbac224f88bb920", "url": "https://github.com/apache/helix/commit/7a922194553c4563bc3177eacfbac224f88bb920", "message": "change timeout to duration", "committedDate": "2020-11-02T01:33:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0MTYwMg==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515741602", "bodyText": "Optional: usually I see people do OFFLINE_DURATION_FOR_PURGE_MS but either way is fine, really.", "author": "narendly", "createdAt": "2020-11-02T05:04:08Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -134,7 +134,7 @@\n     // offline for more than this specified time period, and users call purge participant API,\n     // then the node will be removed.\n     // The unit is milliseconds.\n-    OFFLINE_NODE_TIME_OUT_FOR_PURGE\n+    OFFLINE_DURATION_FOR_PURGE", "originalCommit": "7a922194553c4563bc3177eacfbac224f88bb920", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0MTkzMA==", "url": "https://github.com/apache/helix/pull/1494#discussion_r515741930", "bodyText": "Nit: would it be possible to avoid static imports? i think i've already commented on something similar...", "author": "narendly", "createdAt": "2020-11-02T05:05:33Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -98,6 +99,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.helix.model.ClusterConfig.OFFLINE_DURATION_FOR_PURGE_NOT_SET;", "originalCommit": "7a922194553c4563bc3177eacfbac224f88bb920", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d33febca2cf96e16f6827534d5d5c659d47719ae", "url": "https://github.com/apache/helix/commit/d33febca2cf96e16f6827534d5d5c659d47719ae", "message": "more update", "committedDate": "2020-11-02T05:17:04Z", "type": "commit"}, {"oid": "e7070a045233a47bdd5907f1a638b496976cb0e7", "url": "https://github.com/apache/helix/commit/e7070a045233a47bdd5907f1a638b496976cb0e7", "message": "add comment", "committedDate": "2020-11-02T05:41:33Z", "type": "commit"}]}