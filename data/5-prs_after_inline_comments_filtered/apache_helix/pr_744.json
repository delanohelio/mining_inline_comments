{"pr_number": 744, "pr_title": "Add read endpoints of metadata store directory service to helix rest", "pr_createdAt": "2020-02-11T02:13:45Z", "pr_url": "https://github.com/apache/helix/pull/744", "timeline": [{"oid": "074260f062189c76e46ebe61f580d699de2217c9", "url": "https://github.com/apache/helix/commit/074260f062189c76e46ebe61f580d699de2217c9", "message": "Add read REST endpoints for metadata store directory service.", "committedDate": "2020-02-11T01:56:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMDkxNA==", "url": "https://github.com/apache/helix/pull/744#discussion_r377420914", "bodyText": "Could we put these in MetadataStoreDirectoryConstants class?", "author": "narendly", "createdAt": "2020-02-11T02:18:03Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";", "originalCommit": "074260f062189c76e46ebe61f580d699de2217c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ1Mzk4Mg==", "url": "https://github.com/apache/helix/pull/744#discussion_r377453982", "bodyText": "Resolved.", "author": "huizhilu", "createdAt": "2020-02-11T05:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMDkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTQ4Mg==", "url": "https://github.com/apache/helix/pull/744#discussion_r377421482", "bodyText": "I think we use CamelCase for resource names:\n\n\"/clusters/{clusterName}/resources/{resourceName}/externalView\"\n\nShould we follow the Helix REST convention?", "author": "narendly", "createdAt": "2020-02-11T02:21:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")", "originalCommit": "074260f062189c76e46ebe61f580d699de2217c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyNTc5MQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377425791", "bodyText": "There are at least 2 naming conventions for helix-rest:\nall lowercase: \"/clusters/{clusterName}/instances/{instanceName}/healthreports\"\ncamelCase: \"/clusters/{clusterName}/propertyStore/{path}\"\n\nThere are a lot of comparisons for naming conventions in rest api.\nI personally like spinal-case because:\n\nit feels right for URLs: URLs are case sensitive, best practice is to use lower case wherever possible\nhas better readability than camelCase, especially for a long URI.\ncamelCase is ineffective in contexts which are not case sensitive\netc..", "author": "huizhilu", "createdAt": "2020-02-11T02:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MTMzMQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377461331", "bodyText": "I don't have a strong opinion. In fact, \"-\" is used for most public APIs. The only reason to go with camelCase is because Helix REST is already using it.\nSince we plan on breaking this out into a separate module/service, I am fine with either unless others can make a case one way or the other.", "author": "narendly", "createdAt": "2020-02-11T06:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2ODMzNQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377468335", "bodyText": "Agreed.", "author": "huizhilu", "createdAt": "2020-02-11T07:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTg1Mg==", "url": "https://github.com/apache/helix/pull/744#discussion_r377421852", "bodyText": "Just do a new HashMap()? Why do you need to put an empty list here? You override it anyways?", "author": "narendly", "createdAt": "2020-02-11T02:23:12Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());", "originalCommit": "074260f062189c76e46ebe61f580d699de2217c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTk4MQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377421981", "bodyText": "CamelCase?", "author": "narendly", "createdAt": "2020-02-11T02:23:49Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(_namespace.getName());\n+      responseMap.put(METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  @GET\n+  @Path(\"/sharding-keys\")", "originalCommit": "074260f062189c76e46ebe61f580d699de2217c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyOTE1NQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377429155", "bodyText": "Same thought above.", "author": "huizhilu", "createdAt": "2020-02-11T03:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMjA2MQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377422061", "bodyText": "Also add realm.isEmpty()?", "author": "narendly", "createdAt": "2020-02-11T02:24:22Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(_namespace.getName());\n+      responseMap.put(METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getAllShardingKeysInRealm(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      if (realm == null) {", "originalCommit": "074260f062189c76e46ebe61f580d699de2217c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyODY2Nw==", "url": "https://github.com/apache/helix/pull/744#discussion_r377428667", "bodyText": "If param realm is not set (ream == null), all sharding keys of the namespace are returned. My initial thought is, if ream.isEmpty(), it means query param ?ream= is set to empty, this empty realm does not exit so NOT_FOUND is returned.\nI added comments to clear the confusion.", "author": "huizhilu", "createdAt": "2020-02-11T03:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMjA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MjAzNw==", "url": "https://github.com/apache/helix/pull/744#discussion_r377462037", "bodyText": "The comment helps. OK to resolve.", "author": "narendly", "createdAt": "2020-02-11T06:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMjA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMjI2NQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377422265", "bodyText": "Why are we doing this for realm == null? Wouldn't this be considered an implicit behavior? Shouldn't we return notFound for the realm or bad arg exception?", "author": "narendly", "createdAt": "2020-02-11T02:25:36Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(_namespace.getName());\n+      responseMap.put(METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getAllShardingKeysInRealm(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      if (realm == null) {\n+        shardingKeys = getMetadataStoreDirectory().getAllShardingKeys(_namespace.getName());", "originalCommit": "074260f062189c76e46ebe61f580d699de2217c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyODM3MQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377428371", "bodyText": "I should have added more comments for this. This actually provides two options:\n\n\"/sharding-keys\": returns all sharding keys in this namespace.\n\"/sharding-keys?realm=zk-0\": this adds a filter and returns sharding keys of the realm zk-0", "author": "huizhilu", "createdAt": "2020-02-11T03:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMjI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMjQ0MA==", "url": "https://github.com/apache/helix/pull/744#discussion_r377422440", "bodyText": "if we return early, this else won't be necessary.", "author": "narendly", "createdAt": "2020-02-11T02:26:32Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(_namespace.getName());\n+      responseMap.put(METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getAllShardingKeysInRealm(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      if (realm == null) {\n+        shardingKeys = getMetadataStoreDirectory().getAllShardingKeys(_namespace.getName());\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME.\n+        responseMap = new HashMap<>(1);\n+      } else {\n+        shardingKeys =", "originalCommit": "074260f062189c76e46ebe61f580d699de2217c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "url": "https://github.com/apache/helix/commit/7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "message": "Add unit tests.", "committedDate": "2020-02-11T06:04:41Z", "type": "commit"}, {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "url": "https://github.com/apache/helix/commit/7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "message": "Add unit tests.", "committedDate": "2020-02-11T06:04:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MDIwMA==", "url": "https://github.com/apache/helix/pull/744#discussion_r377460200", "bodyText": "Why does this show up as a new file? We already have this. Could you rebase from apache/zooscalability?", "author": "narendly", "createdAt": "2020-02-11T06:21:03Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/constant/MetadataStoreDirectoryConstants.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.apache.helix.rest.metadatastore.constant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Constants for metadata store directory service.\n+ */\n+public class MetadataStoreDirectoryConstants {", "originalCommit": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2NzQ1Nw==", "url": "https://github.com/apache/helix/pull/744#discussion_r377467457", "bodyText": "I've rebased. Maybe you meant file MetadataStoreRoutingConstants? I thought that is a different one for routing data.. I can move these constants to that file.", "author": "huizhilu", "createdAt": "2020-02-11T06:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MDIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MDMwMA==", "url": "https://github.com/apache/helix/pull/744#discussion_r377460300", "bodyText": "Nit: in the \"JSON\" REST response...", "author": "narendly", "createdAt": "2020-02-11T06:21:41Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/constant/MetadataStoreDirectoryConstants.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.apache.helix.rest.metadatastore.constant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Constants for metadata store directory service.\n+ */\n+public class MetadataStoreDirectoryConstants {\n+  // Field name in the response of getting metadata store realms.\n+  public static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";", "originalCommit": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MDQ3Mg==", "url": "https://github.com/apache/helix/pull/744#discussion_r377460472", "bodyText": "We should put this in a different package.\nHow about ...server.resources.metadatastore; ?", "author": "narendly", "createdAt": "2020-02-11T06:22:44Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;", "originalCommit": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2ODA5Mw==", "url": "https://github.com/apache/helix/pull/744#discussion_r377468093", "bodyText": "Well, I was a bit confused as I also thought about it. I thought since we will move these accessors to zookeeper, I could just put it in zookeeper folder.. Thanks for confirmation.", "author": "huizhilu", "createdAt": "2020-02-11T06:59:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MDQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MTM4MA==", "url": "https://github.com/apache/helix/pull/744#discussion_r377461380", "bodyText": "Nit: empty line?", "author": "narendly", "createdAt": "2020-02-11T06:27:24Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreDirectoryConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private HelixRestNamespace _namespace;\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  /**\n+   * Gets all metadata store realms in a namespace with the endpoint.\n+   *\n+   * @return Json representation of all realms.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap = new HashMap<>(1);\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(getHelixNamespace().getName());", "originalCommit": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MTY2OQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377461669", "bodyText": "I feel that using \"..._KEY\" might be more intuitive than \"_NAME\". What do you think?", "author": "narendly", "createdAt": "2020-02-11T06:28:38Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/constant/MetadataStoreDirectoryConstants.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.apache.helix.rest.metadatastore.constant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Constants for metadata store directory service.\n+ */\n+public class MetadataStoreDirectoryConstants {\n+  // Field name in the response of getting metadata store realms.\n+  public static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+\n+  // Field name in the response of getting sharding keys.\n+  public static final String SHARDING_KEYS_NAME = \"shardingKeys\";", "originalCommit": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2NzgwOQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377467809", "bodyText": "Sure. I also thought about it. I am not the only one to have that feel..", "author": "huizhilu", "createdAt": "2020-02-11T06:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MTY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MjIzMg==", "url": "https://github.com/apache/helix/pull/744#discussion_r377462232", "bodyText": "Should we make this a constant as well?", "author": "narendly", "createdAt": "2020-02-11T06:31:11Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreDirectoryConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private HelixRestNamespace _namespace;\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  /**\n+   * Gets all metadata store realms in a namespace with the endpoint.\n+   *\n+   * @return Json representation of all realms.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap = new HashMap<>(1);\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(getHelixNamespace().getName());\n+      responseMap.put(\n+          MetadataStoreDirectoryConstants.METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n+   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n+   * a realm.\n+   *\n+   * @param realm Query param in endpoint path\n+   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   */\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n+      // to get all sharding keys in a namespace.\n+      if (realm == null) {\n+        shardingKeys =\n+            getMetadataStoreDirectory().getAllShardingKeys(getHelixNamespace().getName());\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME.\n+        responseMap = new HashMap<>(1);\n+      } else {\n+        // For endpoint: \"/sharding-keys?realm={realmName}\"\n+        shardingKeys = getMetadataStoreDirectory()\n+            .getAllShardingKeysInRealm(getHelixNamespace().getName(), realm);\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME and \"metadataStoreRealm\".\n+        responseMap = new HashMap<>(2);\n+        responseMap.put(\"metadataStoreRealm\", realm);", "originalCommit": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTU5NQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377471595", "bodyText": "I am fine with either.. I just did not wanted to put every string into constants.", "author": "huizhilu", "createdAt": "2020-02-11T07:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MjIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MjQ1Ng==", "url": "https://github.com/apache/helix/pull/744#discussion_r377462456", "bodyText": "I believe you want to make _metadataStoreDirectory volatile for a correct implementation of double-checked locking.", "author": "narendly", "createdAt": "2020-02-11T06:32:07Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreDirectoryConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private HelixRestNamespace _namespace;\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  /**\n+   * Gets all metadata store realms in a namespace with the endpoint.\n+   *\n+   * @return Json representation of all realms.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap = new HashMap<>(1);\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(getHelixNamespace().getName());\n+      responseMap.put(\n+          MetadataStoreDirectoryConstants.METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n+   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n+   * a realm.\n+   *\n+   * @param realm Query param in endpoint path\n+   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   */\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n+      // to get all sharding keys in a namespace.\n+      if (realm == null) {\n+        shardingKeys =\n+            getMetadataStoreDirectory().getAllShardingKeys(getHelixNamespace().getName());\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME.\n+        responseMap = new HashMap<>(1);\n+      } else {\n+        // For endpoint: \"/sharding-keys?realm={realmName}\"\n+        shardingKeys = getMetadataStoreDirectory()\n+            .getAllShardingKeysInRealm(getHelixNamespace().getName(), realm);\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME and \"metadataStoreRealm\".\n+        responseMap = new HashMap<>(2);\n+        responseMap.put(\"metadataStoreRealm\", realm);\n+      }\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    responseMap.put(MetadataStoreDirectoryConstants.SHARDING_KEYS_NAME, shardingKeys);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  private MetadataStoreDirectory getMetadataStoreDirectory() {\n+    if (_metadataStoreDirectory == null) {", "originalCommit": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MjY4OA==", "url": "https://github.com/apache/helix/pull/744#discussion_r377462688", "bodyText": "routing \"ZK\" address?", "author": "narendly", "createdAt": "2020-02-11T06:33:27Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreDirectoryConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private HelixRestNamespace _namespace;\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  /**\n+   * Gets all metadata store realms in a namespace with the endpoint.\n+   *\n+   * @return Json representation of all realms.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap = new HashMap<>(1);\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(getHelixNamespace().getName());\n+      responseMap.put(\n+          MetadataStoreDirectoryConstants.METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n+   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n+   * a realm.\n+   *\n+   * @param realm Query param in endpoint path\n+   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   */\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n+      // to get all sharding keys in a namespace.\n+      if (realm == null) {\n+        shardingKeys =\n+            getMetadataStoreDirectory().getAllShardingKeys(getHelixNamespace().getName());\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME.\n+        responseMap = new HashMap<>(1);\n+      } else {\n+        // For endpoint: \"/sharding-keys?realm={realmName}\"\n+        shardingKeys = getMetadataStoreDirectory()\n+            .getAllShardingKeysInRealm(getHelixNamespace().getName(), realm);\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME and \"metadataStoreRealm\".\n+        responseMap = new HashMap<>(2);\n+        responseMap.put(\"metadataStoreRealm\", realm);\n+      }\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    responseMap.put(MetadataStoreDirectoryConstants.SHARDING_KEYS_NAME, shardingKeys);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  private MetadataStoreDirectory getMetadataStoreDirectory() {\n+    if (_metadataStoreDirectory == null) {\n+      synchronized (this) {\n+        if (_metadataStoreDirectory == null) {\n+          Map<String, String> routingZkAddressMap = ImmutableMap\n+              .of(getHelixNamespace().getName(), getHelixNamespace().getMetadataStoreAddress());\n+          try {\n+            _metadataStoreDirectory = new ZkMetadataStoreDirectory(routingZkAddressMap);\n+          } catch (InvalidRoutingDataException ex) {\n+            // In this case, the InvalidRoutingDataException should not happen because routing\n+            // ZK address is always valid here.\n+            LOG.warn(\"Unable to create metadata store directory for routing address: {}\",", "originalCommit": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2Mjc2NA==", "url": "https://github.com/apache/helix/pull/744#discussion_r377462764", "bodyText": "how so? what if for some reason routingZkAddressMap gives some weird value like \"hellotest\"?", "author": "narendly", "createdAt": "2020-02-11T06:33:52Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreDirectoryConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private HelixRestNamespace _namespace;\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  /**\n+   * Gets all metadata store realms in a namespace with the endpoint.\n+   *\n+   * @return Json representation of all realms.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap = new HashMap<>(1);\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(getHelixNamespace().getName());\n+      responseMap.put(\n+          MetadataStoreDirectoryConstants.METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n+   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n+   * a realm.\n+   *\n+   * @param realm Query param in endpoint path\n+   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   */\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n+      // to get all sharding keys in a namespace.\n+      if (realm == null) {\n+        shardingKeys =\n+            getMetadataStoreDirectory().getAllShardingKeys(getHelixNamespace().getName());\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME.\n+        responseMap = new HashMap<>(1);\n+      } else {\n+        // For endpoint: \"/sharding-keys?realm={realmName}\"\n+        shardingKeys = getMetadataStoreDirectory()\n+            .getAllShardingKeysInRealm(getHelixNamespace().getName(), realm);\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME and \"metadataStoreRealm\".\n+        responseMap = new HashMap<>(2);\n+        responseMap.put(\"metadataStoreRealm\", realm);\n+      }\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    responseMap.put(MetadataStoreDirectoryConstants.SHARDING_KEYS_NAME, shardingKeys);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  private MetadataStoreDirectory getMetadataStoreDirectory() {\n+    if (_metadataStoreDirectory == null) {\n+      synchronized (this) {\n+        if (_metadataStoreDirectory == null) {\n+          Map<String, String> routingZkAddressMap = ImmutableMap\n+              .of(getHelixNamespace().getName(), getHelixNamespace().getMetadataStoreAddress());\n+          try {\n+            _metadataStoreDirectory = new ZkMetadataStoreDirectory(routingZkAddressMap);\n+          } catch (InvalidRoutingDataException ex) {\n+            // In this case, the InvalidRoutingDataException should not happen because routing", "originalCommit": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MDExNg==", "url": "https://github.com/apache/helix/pull/744#discussion_r377470116", "bodyText": "The reason I put this comment is because below code only checks  routingZkAddressMap is null or empty, but not weird value like \"hellotest\". So the InvalidRoutingDataException here will not happen...\n  public ZkMetadataStoreDirectory(Map<String, String> routingZkAddressMap)\n      throws InvalidRoutingDataException {\n    if (routingZkAddressMap == null || routingZkAddressMap.isEmpty()) {\n      throw new InvalidRoutingDataException(\"Routing ZK Addresses given are invalid!\");\n    }", "author": "huizhilu", "createdAt": "2020-02-11T07:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2Mjc2NA=="}], "type": "inlineReview"}, {"oid": "4b7a5f0a903d0da9be118b8a83f288d584c225f3", "url": "https://github.com/apache/helix/commit/4b7a5f0a903d0da9be118b8a83f288d584c225f3", "message": "Address comments.", "committedDate": "2020-02-11T07:46:25Z", "type": "commit"}, {"oid": "0621315d9db56a08dc97b621561f15fd7cf65051", "url": "https://github.com/apache/helix/commit/0621315d9db56a08dc97b621561f15fd7cf65051", "message": "Comments.", "committedDate": "2020-02-11T08:44:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxODg0Mg==", "url": "https://github.com/apache/helix/pull/744#discussion_r377818842", "bodyText": "It looks like there are a few endpoints missing such as:\ngetAllNamespaces\ngetAllMappingUnderPath\ngetMetadataStoreRealm\netc..\nIs there a reason these endpoints were left out? If they are unsupported, we could create the resource endpoints and but a TODO for them.", "author": "narendly", "createdAt": "2020-02-11T18:31:23Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.apache.helix.rest.server.resources.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {", "originalCommit": "0621315d9db56a08dc97b621561f15fd7cf65051", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNjA3MQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377836071", "bodyText": "Right, theses APIs are unsupported in the implementation. I don't think it is meaningful to just put the endpoints that are unsupported, because:\n\nresponse with status code 501 has to return, which is extra work and unnecessary\ncan not test the endpoints in the unit tests\n\nMy plan is to create an issue to track the left-over endpoints and complete it once the read operations are implemented. It will only take 1 ~ 2 days to complete the left-over endpoints.", "author": "huizhilu", "createdAt": "2020-02-11T19:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxODg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0ODM5Mg==", "url": "https://github.com/apache/helix/pull/744#discussion_r377848392", "bodyText": "Sounds good. Please link your new issue in this PR so that we have a paper trail.", "author": "narendly", "createdAt": "2020-02-11T19:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxODg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzA5Mg==", "url": "https://github.com/apache/helix/pull/744#discussion_r377933092", "bodyText": "I am OK to have this Accessor extend AbstractResource from REST module. But keep in mind, when we starts split this metadata store module out from REST, how you handle the dependencies.", "author": "junkaixue", "createdAt": "2020-02-11T22:17:44Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.apache.helix.rest.server.resources.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {", "originalCommit": "0621315d9db56a08dc97b621561f15fd7cf65051", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2NDU4Ng==", "url": "https://github.com/apache/helix/pull/744#discussion_r377964586", "bodyText": "Did we agree to put metadatastore service in a separate module?", "author": "lei-xia", "createdAt": "2020-02-11T23:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2NzIyMw==", "url": "https://github.com/apache/helix/pull/744#discussion_r377967223", "bodyText": "@lei-xia\nThat depends on zookeeper-api module separation. That does not need to be included in the scope of this PR.", "author": "narendly", "createdAt": "2020-02-11T23:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2OTc2OQ==", "url": "https://github.com/apache/helix/pull/744#discussion_r377969769", "bodyText": "@lei-xia We agreed to refactor the module later and put MSDS REST into zookeeper-api module.", "author": "huizhilu", "createdAt": "2020-02-11T23:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NjI5Ng==", "url": "https://github.com/apache/helix/pull/744#discussion_r377986296", "bodyText": "I am OK to have this Accessor extend AbstractResource from REST module. But keep in mind, when we starts split this metadata store module out from REST, how you handle the dependencies.\n\n@dasahcc I've created an issue #755 to create a new abstract resource for this when we move it out of helix-rest.", "author": "huizhilu", "createdAt": "2020-02-12T00:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzA5Mg=="}], "type": "inlineReview"}, {"oid": "d0d5cc0f183291959e7e5e6d875803dc52efddb5", "url": "https://github.com/apache/helix/commit/d0d5cc0f183291959e7e5e6d875803dc52efddb5", "message": "Use PostConstruct annotation to init namespace and metadataStoreDirectory.", "committedDate": "2020-02-11T23:51:04Z", "type": "commit"}]}