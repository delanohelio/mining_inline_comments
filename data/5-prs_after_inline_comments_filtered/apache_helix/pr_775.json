{"pr_number": 775, "pr_title": "Add HttpRoutingDataReader", "pr_createdAt": "2020-02-18T07:09:51Z", "pr_url": "https://github.com/apache/helix/pull/775", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAwODAwNg==", "url": "https://github.com/apache/helix/pull/775#discussion_r381008006", "bodyText": "Nit, wrap long line.", "author": "huizhilu", "createdAt": "2020-02-19T00:05:17Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of \"metadata store sharding keys\", where the sharding keys in a value list all route to the realm address in the key disallows a meaningful mapping to be returned", "originalCommit": "6ef735e462755a38b5f2ca53416e6dd3abd1935f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1Njc1Nw==", "url": "https://github.com/apache/helix/pull/775#discussion_r382956757", "bodyText": "Fixed", "author": "narendly", "createdAt": "2020-02-23T02:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAwODAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxNDgzMg==", "url": "https://github.com/apache/helix/pull/775#discussion_r381014832", "bodyText": "Since this is a blocking IO, my thought is it may add more time for zkclient init/creation. Would it help if the request is async while creating a new zkclient?\nDo we need to consider timeout for this request?", "author": "huizhilu", "createdAt": "2020-02-19T00:30:07Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of \"metadata store sharding keys\", where the sharding keys in a value list all route to the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRoutingData(String msdsEndpoint) {\n+\n+    Map<String, List<String>> rawRoutingData = new HashMap<>();\n+\n+    HttpGet requestAllRealmNames =\n+        new HttpGet(msdsEndpoint); //TODO: construct an endpoint once REST endpoint is finalized\n+    try (CloseableHttpClient httpClient = HttpClients.createDefault();\n+        CloseableHttpResponse response = httpClient.execute(requestAllRealmNames)) {", "originalCommit": "6ef735e462755a38b5f2ca53416e6dd3abd1935f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNzI3Mw==", "url": "https://github.com/apache/helix/pull/775#discussion_r382317273", "bodyText": "Does not matter, right? If you don't have the data, how can you proceeds?", "author": "kaisun2000", "createdAt": "2020-02-20T23:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxNDgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxODQzMQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r382318431", "bodyText": "My thinking is that do we have a singleton class that would use this class of HttpRoutingDataReader upon application initialization to read and cache the routing data. So that later zkclient (shared, dedicated) will all use this cached data? or we will just use this class itself to do the cache?", "author": "kaisun2000", "createdAt": "2020-02-20T23:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxNDgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4OTQ4OA==", "url": "https://github.com/apache/helix/pull/775#discussion_r382289488", "bodyText": "Is that possible to have comment module to hold these http related functions in general? I do see these kind of operations here and there in different modules.", "author": "junkaixue", "createdAt": "2020-02-20T22:17:51Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {", "originalCommit": "6ef735e462755a38b5f2ca53416e6dd3abd1935f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzOTM4MA==", "url": "https://github.com/apache/helix/pull/775#discussion_r382339380", "bodyText": "I think this might be a good idea, but the current implementation makes it a little difficult (for example, CustomRestClient in helix-rest is too closely coupled with Stoppable checks).\nI have created an issue to track this: #793 - please take a look to see if our thoughts are aligned :)", "author": "narendly", "createdAt": "2020-02-21T00:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4OTQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTg5MA==", "url": "https://github.com/apache/helix/pull/775#discussion_r382319890", "bodyText": "The application config should provide (via system property) the namespace of endpoint. This is the input to construct msdsEndpoint.\nThis construction logic should be outside this class?  Or we want to put it inside this class?", "author": "kaisun2000", "createdAt": "2020-02-20T23:37:23Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of \"metadata store sharding keys\", where the sharding keys in a value list all route to the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRoutingData(String msdsEndpoint) {\n+\n+    Map<String, List<String>> rawRoutingData = new HashMap<>();\n+\n+    HttpGet requestAllRealmNames =\n+        new HttpGet(msdsEndpoint); //TODO: construct an endpoint once REST endpoint is finalized", "originalCommit": "6ef735e462755a38b5f2ca53416e6dd3abd1935f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0da52012d34b651e48df98e9b68b204a5266bf90", "url": "https://github.com/apache/helix/commit/0da52012d34b651e48df98e9b68b204a5266bf90", "message": "sadf", "committedDate": "2020-02-21T01:33:45Z", "type": "forcePushed"}, {"oid": "137f163f2e312858b7d4f145831a9221d32e8121", "url": "https://github.com/apache/helix/commit/137f163f2e312858b7d4f145831a9221d32e8121", "message": "WIP: Add HttpRoutingDataReader\n\nHttpRoutingDataReader is a component used by new ZkClient APIs to make an HTTP read request to the metadata store directory service to retrieve routing data. ZkClient APIs will construct an internal MetadataStoreRoutingData instance based on the raw routing data retrieved from MSDS.", "committedDate": "2020-02-24T02:24:26Z", "type": "commit"}, {"oid": "34be4ac2b66daa0e77326a2ab0d1fee7a489ee2c", "url": "https://github.com/apache/helix/commit/34be4ac2b66daa0e77326a2ab0d1fee7a489ee2c", "message": "sadf", "committedDate": "2020-02-24T02:26:08Z", "type": "commit"}, {"oid": "163e0d6b0c7eebe01e9f4789b5777f8589585b8a", "url": "https://github.com/apache/helix/commit/163e0d6b0c7eebe01e9f4789b5777f8589585b8a", "message": "asdf", "committedDate": "2020-02-24T02:26:08Z", "type": "commit"}, {"oid": "3fcb234be227687656bbbee3ab7af683be89b5e9", "url": "https://github.com/apache/helix/commit/3fcb234be227687656bbbee3ab7af683be89b5e9", "message": "finish", "committedDate": "2020-02-24T02:26:08Z", "type": "commit"}, {"oid": "50bd3537673a4e9233c12e19dd9652d6cef18eac", "url": "https://github.com/apache/helix/commit/50bd3537673a4e9233c12e19dd9652d6cef18eac", "message": "refactor", "committedDate": "2020-02-24T02:26:08Z", "type": "commit"}, {"oid": "17f759d6366cdb267b85a5c8ed421c9ddd89fac3", "url": "https://github.com/apache/helix/commit/17f759d6366cdb267b85a5c8ed421c9ddd89fac3", "message": "Fix test", "committedDate": "2020-02-24T02:26:08Z", "type": "commit"}, {"oid": "fb7364cb4365289c5de9b3866ca73dc6eeb961ad", "url": "https://github.com/apache/helix/commit/fb7364cb4365289c5de9b3866ca73dc6eeb961ad", "message": "javadoc", "committedDate": "2020-02-24T02:26:08Z", "type": "commit"}, {"oid": "8c8bf71db4b8b314cf0d235c04a34a5f4c74d848", "url": "https://github.com/apache/helix/commit/8c8bf71db4b8b314cf0d235c04a34a5f4c74d848", "message": "FSAD", "committedDate": "2020-02-24T02:26:08Z", "type": "commit"}, {"oid": "535d328d2b6bccbf6bf4e8620cbf7e2a9cdf5dbe", "url": "https://github.com/apache/helix/commit/535d328d2b6bccbf6bf4e8620cbf7e2a9cdf5dbe", "message": "SADf", "committedDate": "2020-02-24T02:26:08Z", "type": "commit"}, {"oid": "d551119f141662b751cdf8e3abb9a5c0f6724fc4", "url": "https://github.com/apache/helix/commit/d551119f141662b751cdf8e3abb9a5c0f6724fc4", "message": "Change endpoint", "committedDate": "2020-02-24T06:08:37Z", "type": "commit"}, {"oid": "d551119f141662b751cdf8e3abb9a5c0f6724fc4", "url": "https://github.com/apache/helix/commit/d551119f141662b751cdf8e3abb9a5c0f6724fc4", "message": "Change endpoint", "committedDate": "2020-02-24T06:08:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzExMTg1Mw==", "url": "https://github.com/apache/helix/pull/775#discussion_r383111853", "bodyText": "Endpoint path is incorrect. You may want \u201crouting-data\u201d", "author": "huizhilu", "createdAt": "2020-02-24T07:27:11Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();\n+          // Update the reference\n+          _rawRoutingData = getAllRoutingData(httpClient, msdsEndpoint);\n+          // Close any open resources\n+          httpClient.close();\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @param httpClient\n+   * @param msdsEndpoint\n+   * @return\n+   * @throws IOException\n+   */\n+  private static Map<String, List<String>> getAllRoutingData(CloseableHttpClient httpClient,\n+      String msdsEndpoint)\n+      throws IOException {\n+    HttpGet requestAllData =\n+        new HttpGet(msdsEndpoint + \"/\" + MetadataStoreRoutingConstants.ROUTING_DATA);", "originalCommit": "d551119f141662b751cdf8e3abb9a5c0f6724fc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4MTk2Ng==", "url": "https://github.com/apache/helix/pull/775#discussion_r383381966", "bodyText": "Good catch - updated.", "author": "narendly", "createdAt": "2020-02-24T16:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzExMTg1Mw=="}], "type": "inlineReview"}, {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900", "url": "https://github.com/apache/helix/commit/0780818b1c0a28e595523373e7bae249f6a7c900", "message": "update endpoint", "committedDate": "2020-02-24T16:44:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNDU4Ng==", "url": "https://github.com/apache/helix/pull/775#discussion_r383434586", "bodyText": "What is this RetryOnFailture notation? My understanding of this part is kind of weak. More important, what does this buy for us?", "author": "kaisun2000", "createdAt": "2020-02-24T18:24:40Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)", "originalCommit": "0780818b1c0a28e595523373e7bae249f6a7c900", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNzU4Ng==", "url": "https://github.com/apache/helix/pull/775#discussion_r383437586", "bodyText": "will httpCient.execute throw other exceptions aside from IOException?", "author": "kaisun2000", "createdAt": "2020-02-24T18:30:23Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();\n+          // Update the reference\n+          _rawRoutingData = getAllRoutingData(httpClient, msdsEndpoint);\n+          // Close any open resources\n+          httpClient.close();\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @param httpClient\n+   * @param msdsEndpoint\n+   * @return\n+   * @throws IOException\n+   */\n+  private static Map<String, List<String>> getAllRoutingData(CloseableHttpClient httpClient,\n+      String msdsEndpoint)\n+      throws IOException {\n+    HttpGet requestAllData = new HttpGet(\n+        msdsEndpoint + MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+    CloseableHttpResponse response = httpClient.execute(requestAllData);", "originalCommit": "0780818b1c0a28e595523373e7bae249f6a7c900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1NzU2Mw==", "url": "https://github.com/apache/helix/pull/775#discussion_r383457563", "bodyText": "The other more important thing is that I assume that the user needs to configure multiple host to msdsEndPoint? Similar like DNS return IP address set?\nOtherwise, this is a single point of failure.\nHow doe it work currently in rest client? We can leverage the same mechanism to avoid SPOF.", "author": "kaisun2000", "createdAt": "2020-02-24T19:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNzU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MTc0Ng==", "url": "https://github.com/apache/helix/pull/775#discussion_r383461746", "bodyText": "I don't think so.", "author": "narendly", "createdAt": "2020-02-24T19:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNzU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3NDQ0MA==", "url": "https://github.com/apache/helix/pull/775#discussion_r383474440", "bodyText": "It's a VIP so we have different hosts that are mapped to the single endpoint. But this is an implementation detail for Helix applications/enterprises, so let us now discuss those details here.", "author": "narendly", "createdAt": "2020-02-24T19:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNzU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MDkxMQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r383490911", "bodyText": "Either I did not get what you mean by VIP or you did not get what I mean here. What really concerns me is that some rest servers may not be available for whatever reason, say network partition. Then we should retry for another rest server. Otherwise, mission critical application may not be able to start.\nSo the retry logic is very critical. We don't have this retry logic. You can think of this retry logic similar to Zookeeper native client retry different quorum node.\nPut it another way, I believe the retry different server logic should be here. Is the code (httpclient) here smart enough to retry different IP from the VIP DNS name?", "author": "kaisun2000", "createdAt": "2020-02-24T20:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNzU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzODY0OQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r383638649", "bodyText": "Discussed offline. VIP is just an example - different network vendors will provide different abstraction layers.", "author": "narendly", "createdAt": "2020-02-25T03:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNzU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzODk2NA==", "url": "https://github.com/apache/helix/pull/775#discussion_r383438964", "bodyText": "Why this is a public API? Do we intend to provide this one outside users? Is there such a case?", "author": "kaisun2000", "createdAt": "2020-02-24T18:33:02Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()", "originalCommit": "0780818b1c0a28e595523373e7bae249f6a7c900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2NTIxOA==", "url": "https://github.com/apache/helix/pull/775#discussion_r383465218", "bodyText": "Not yet - but let's keep this public for now because I believe we might need this soon for tooling and testing.", "author": "narendly", "createdAt": "2020-02-24T19:24:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzODk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTk3Mg==", "url": "https://github.com/apache/helix/pull/775#discussion_r383441972", "bodyText": "Here, getRawRoutingData would throw illegalStateException which is unchecked. Think you are a user, how do you plan to handle this one? Also, IOException, and InvalidRoutingDataException?\nOr do we really want user to handle these exceptions?\nIt seems to me the user only need to understand that 1/ configuration issue 2/ MSDS for some reason not working.\nSo they can either change the code or trouble shoot for communication issues to MSDS", "author": "kaisun2000", "createdAt": "2020-02-24T18:39:00Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();\n+          // Update the reference\n+          _rawRoutingData = getAllRoutingData(httpClient, msdsEndpoint);\n+          // Close any open resources\n+          httpClient.close();\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());", "originalCommit": "0780818b1c0a28e595523373e7bae249f6a7c900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MTUwMw==", "url": "https://github.com/apache/helix/pull/775#discussion_r383461503", "bodyText": "That's correct. I believe we still want to float these exceptions up as you said.\nIOException means MSDS isn't working for some reason.\nInvalidRoutingDataException means their routing data is not configured correctly.", "author": "narendly", "createdAt": "2020-02-24T19:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjY3OA==", "url": "https://github.com/apache/helix/pull/775#discussion_r383442678", "bodyText": "This close can be leaked. use try, catch? so simply let getAllRoutingData handle this httpclient creation.", "author": "kaisun2000", "createdAt": "2020-02-24T18:40:23Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();\n+          // Update the reference\n+          _rawRoutingData = getAllRoutingData(httpClient, msdsEndpoint);\n+          // Close any open resources\n+          httpClient.close();", "originalCommit": "0780818b1c0a28e595523373e7bae249f6a7c900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2NjEwOQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r383466109", "bodyText": "Good point. Let me do some refactoring here.", "author": "narendly", "createdAt": "2020-02-24T19:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0OTcyOQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r383449729", "bodyText": "Suggest you add a comment as why use volatile here. https://en.wikipedia.org/wiki/Double-checked_locking. Otherwise, later people changing the code may remove them.", "author": "kaisun2000", "createdAt": "2020-02-24T18:54:04Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;", "originalCommit": "0780818b1c0a28e595523373e7bae249f6a7c900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1NjExNw==", "url": "https://github.com/apache/helix/pull/775#discussion_r383456117", "bodyText": "Sure.", "author": "narendly", "createdAt": "2020-02-24T19:06:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0OTcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNDQxMw==", "url": "https://github.com/apache/helix/pull/775#discussion_r383434413", "bodyText": "What is the benefit of introducing new lib: jcabi. I think HttpClients' already provides retry mechanism: HttpRequestInterceptor or setRetryHandler(new DefaultHttpRequestRetryHandler())", "author": "huizhilu", "createdAt": "2020-02-24T18:24:21Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)", "originalCommit": "0780818b1c0a28e595523373e7bae249f6a7c900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2NDk3MA==", "url": "https://github.com/apache/helix/pull/775#discussion_r383464970", "bodyText": "The benefit of using jcabi is that it allows us to retry in a more succinct way. Defining a retry handler every time would incur repeated code.\nI want to use https://http.jcabi.com/ (Fluent HttpClient) over Apache's at some point once we refactor all HttpClients out into a new module because it provides useful annotations for caching and logging, but this is more like an ad-hoc retry here. Let me remove this library import. I'll just use the retry handler.\nThanks for the suggestion!", "author": "narendly", "createdAt": "2020-02-24T19:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNDQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTk2OA==", "url": "https://github.com/apache/helix/pull/775#discussion_r383441968", "bodyText": "I am considering setting this in constructor. At least we can move it out of synchronized block.", "author": "huizhilu", "createdAt": "2020-02-24T18:39:00Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);", "originalCommit": "0780818b1c0a28e595523373e7bae249f6a7c900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2NTM0NA==", "url": "https://github.com/apache/helix/pull/775#discussion_r383465344", "bodyText": "I agree - I want to pull this out of the block and fail early if it doesn't exist.", "author": "narendly", "createdAt": "2020-02-24T19:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MzA3Mg==", "url": "https://github.com/apache/helix/pull/775#discussion_r383443072", "bodyText": "@RetryOnFailure is applied to this whole method. It seems we are going to call this reader each time we create a RealmAwareZkClient? The heavy work is one the first time we call to get routing data.\nI would use HttpClients' retry so we don't have to acquire lock and create HttpClient 3 times (a bit heavier) if attempting. Instead, http client could just retry on exception within the locking block, which I think is easier.\nAnd one more benefit is we could use try-with-resource and auto close httpClient.\nWhat do you think?\nWhen is reader supposed to be created, each time when creating zkClient, or a singleton is maintained ?", "author": "huizhilu", "createdAt": "2020-02-24T18:41:09Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();", "originalCommit": "0780818b1c0a28e595523373e7bae249f6a7c900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2NTkxMg==", "url": "https://github.com/apache/helix/pull/775#discussion_r383465912", "bodyText": "Let me refactor the code here so that httpClient gets closed properly.\nHttpRoutingDataReader is a singleton and the data is read lazily when it's called the first time, hence the double checked locking.", "author": "narendly", "createdAt": "2020-02-24T19:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MzA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MTkyMw==", "url": "https://github.com/apache/helix/pull/775#discussion_r383451923", "bodyText": "Maybe I would decouple fetch http json response and parse json to map:\n\nresponse = httpClient.execute(routing-data-endpoint) // Easier to just retry and timeout http request.\nMap<String, List<>> parseRoutingData(response) {}", "author": "huizhilu", "createdAt": "2020-02-24T18:58:20Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();\n+          // Update the reference\n+          _rawRoutingData = getAllRoutingData(httpClient, msdsEndpoint);\n+          // Close any open resources\n+          httpClient.close();\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @param httpClient\n+   * @param msdsEndpoint\n+   * @return\n+   * @throws IOException\n+   */\n+  private static Map<String, List<String>> getAllRoutingData(CloseableHttpClient httpClient,", "originalCommit": "0780818b1c0a28e595523373e7bae249f6a7c900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MTYzOQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r383461639", "bodyText": "I agree. Let me split the logic into two.", "author": "narendly", "createdAt": "2020-02-24T19:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MTkyMw=="}], "type": "inlineReview"}, {"oid": "c130620a404292554d67a989bca47736f67278f0", "url": "https://github.com/apache/helix/commit/c130620a404292554d67a989bca47736f67278f0", "message": "Address comments", "committedDate": "2020-02-25T03:21:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1Mzg3NQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r383653875", "bodyText": "Nit, we had a change for helix style IntelliJ. With the new change, this line should not be wrapped. Can you update your style and format it?", "author": "huizhilu", "createdAt": "2020-02-25T04:34:01Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/util/TestHttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableSet;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestHttpRoutingDataReader extends ZkTestBase {\n+  private MockMetadataStoreDirectoryServer _msdsServer;\n+  private Map<String, Collection<String>> _testRawRoutingData;\n+  private final String _host = \"localhost\";\n+  private final int _port = 1991;\n+  private final String _namespace = \"TestHttpRoutingDataReader\";\n+\n+  @BeforeClass\n+  public void beforeClass()\n+      throws IOException {\n+    // Create fake routing data\n+    _testRawRoutingData = new HashMap<>();\n+    _testRawRoutingData\n+        .put(\"zk-0\", ImmutableSet.of(\"/sharding-key-0\", \"/sharding-key-1\", \"/sharding-key-2\"));\n+    _testRawRoutingData\n+        .put(\"zk-1\", ImmutableSet.of(\"/sharding-key-3\", \"/sharding-key-4\", \"/sharding-key-5\"));\n+    _testRawRoutingData\n+        .put(\"zk-2\", ImmutableSet.of(\"/sharding-key-6\", \"/sharding-key-7\", \"/sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    _msdsServer =\n+        new MockMetadataStoreDirectoryServer(_host, _port, _namespace, _testRawRoutingData);\n+    _msdsServer.startServer();\n+\n+    // Register the endpoint as a System property\n+    String msdsEndpoint = \"http://\" + _host + \":\" + _port + \"/admin/v2/namespaces/\" + _namespace;\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY, msdsEndpoint);\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _msdsServer.stopServer();\n+  }\n+\n+  @Test\n+  public void testGetRawRoutingData()\n+      throws IOException {", "originalCommit": "c130620a404292554d67a989bca47736f67278f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxMzk3OQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r383713979", "bodyText": "Updated", "author": "narendly", "createdAt": "2020-02-25T08:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1Mzg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1Njg0Nw==", "url": "https://github.com/apache/helix/pull/775#discussion_r383656847", "bodyText": "Just a question: Do we need to set encoding like UTF-8 ? As jersey uses UTF-8 by default, while EntityUtils.toString uses \"ISO-8859-1\" if encoding is not set is header. Maybe just need to confirm at least our rest server includes \"UTF-8\" in header.", "author": "huizhilu", "createdAt": "2020-02-25T04:48:14Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException if there is an issue connecting to MSDS\n+   * @throws InvalidRoutingDataException if the raw routing data is not valid\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @return\n+   * @throws IOException\n+   */\n+  private static CloseableHttpResponse getAllRoutingData()\n+      throws IOException {\n+    // Retry count is 3 by default\n+    HttpGet requestAllData = new HttpGet(\n+        MSDS_ENDPOINT + MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+    try (CloseableHttpClient httpClient = HttpClients.custom()\n+        .setConnectionBackoffStrategy(new DefaultBackoffStrategy())\n+        .setRetryHandler(new DefaultHttpRequestRetryHandler()).build()) {\n+      return httpClient.execute(requestAllData);\n+    }\n+  }\n+\n+  /**\n+   * Returns the raw routing data in a Map< ZkRealm, List of shardingKeys > format.\n+   * @param routingDataResponse\n+   * @return\n+   */\n+  private static Map<String, List<String>> parseRoutingData(\n+      CloseableHttpResponse routingDataResponse)\n+      throws IOException {\n+    HttpEntity entity = routingDataResponse.getEntity();\n+    if (entity != null) {\n+      String resultStr = EntityUtils.toString(entity);", "originalCommit": "c130620a404292554d67a989bca47736f67278f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxMzAxNg==", "url": "https://github.com/apache/helix/pull/775#discussion_r383713016", "bodyText": "Either way seems to work. But setting it as UTF-8 just in case.", "author": "narendly", "createdAt": "2020-02-25T08:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1Njg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2ODkwNA==", "url": "https://github.com/apache/helix/pull/775#discussion_r383668904", "bodyText": "I don't see a timeout setting. If we don't set timeout, it may use system defined timeout or infinite timeout. To make the system responsive and stable, are we considering timeout: connectTimeout, socketTimeout, etc.?", "author": "huizhilu", "createdAt": "2020-02-25T05:42:47Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException if there is an issue connecting to MSDS\n+   * @throws InvalidRoutingDataException if the raw routing data is not valid\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @return\n+   * @throws IOException\n+   */\n+  private static CloseableHttpResponse getAllRoutingData()\n+      throws IOException {\n+    // Retry count is 3 by default\n+    HttpGet requestAllData = new HttpGet(\n+        MSDS_ENDPOINT + MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+    try (CloseableHttpClient httpClient = HttpClients.custom()\n+        .setConnectionBackoffStrategy(new DefaultBackoffStrategy())", "originalCommit": "c130620a404292554d67a989bca47736f67278f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxMzA2OQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r383713069", "bodyText": "Set.", "author": "narendly", "createdAt": "2020-02-25T08:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2ODkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY5OTYzNw==", "url": "https://github.com/apache/helix/pull/775#discussion_r383699637", "bodyText": "Minor as it is a test: maybe we would use try...finally to close the server and client, in case exception or assertion fails and server is still running?", "author": "huizhilu", "createdAt": "2020-02-25T07:31:10Z", "path": "metadata-store-directory-common/src/test/java/org/apache/helix/msdcommon/mock/TestMockMetadataStoreDirectoryServer.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.msdcommon.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.junit.Test;\n+import org.testng.Assert;\n+\n+\n+public class TestMockMetadataStoreDirectoryServer {\n+  @Test\n+  public void testMockMetadataStoreDirectoryServer()\n+      throws IOException {\n+    // Create fake routing data\n+    Map<String, Collection<String>> routingData = new HashMap<>();\n+    routingData.put(\"zk-0\", ImmutableList.of(\"sharding-key-0\", \"sharding-key-1\", \"sharding-key-2\"));\n+    routingData.put(\"zk-1\", ImmutableList.of(\"sharding-key-3\", \"sharding-key-4\", \"sharding-key-5\"));\n+    routingData.put(\"zk-2\", ImmutableList.of(\"sharding-key-6\", \"sharding-key-7\", \"sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    String host = \"localhost\";\n+    int port = 11000;\n+    String endpoint = \"http://\" + host + \":\" + port;\n+    String namespace = \"MY-HELIX-NAMESPACE\";\n+    MockMetadataStoreDirectoryServer server =\n+        new MockMetadataStoreDirectoryServer(host, port, namespace, routingData);\n+    server.startServer();\n+    CloseableHttpClient httpClient = HttpClients.createDefault();\n+\n+    // Send a GET request for all routing data\n+    HttpGet getRequest = new HttpGet(\n+        endpoint + MockMetadataStoreDirectoryServer.REST_PREFIX + namespace\n+            + MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+\n+    CloseableHttpResponse getResponse = httpClient.execute(getRequest);\n+    Map<String, Object> resultMap = MockMetadataStoreDirectoryServer.OBJECT_MAPPER\n+        .readValue(getResponse.getEntity().getContent(), Map.class);\n+    List<Map<String, Object>> routingDataList =\n+        (List<Map<String, Object>>) resultMap.get(MetadataStoreRoutingConstants.ROUTING_DATA);\n+    Collection<String> allRealms = routingDataList.stream().map(mapEntry -> (String) mapEntry\n+        .get(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM))\n+        .collect(Collectors.toSet());\n+    Assert.assertEquals(allRealms, routingData.keySet());\n+    Map<String, List<String>> retrievedRoutingData = routingDataList.stream().collect(Collectors\n+        .toMap(mapEntry -> (String) mapEntry\n+                .get(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM),\n+            mapEntry -> (List<String>) mapEntry.get(MetadataStoreRoutingConstants.SHARDING_KEYS)));\n+    Assert.assertEquals(retrievedRoutingData, routingData);\n+\n+    // Send a GET request for all realms\n+    getRequest = new HttpGet(endpoint + MockMetadataStoreDirectoryServer.REST_PREFIX + namespace\n+        + MockMetadataStoreDirectoryServer.ZK_REALM_ENDPOINT);\n+    getResponse = httpClient.execute(getRequest);\n+    Map<String, Collection<String>> allRealmsMap = MockMetadataStoreDirectoryServer.OBJECT_MAPPER\n+        .readValue(getResponse.getEntity().getContent(), Map.class);\n+    Assert\n+        .assertTrue(allRealmsMap.containsKey(MetadataStoreRoutingConstants.METADATA_STORE_REALMS));\n+    allRealms = allRealmsMap.get(MetadataStoreRoutingConstants.METADATA_STORE_REALMS);\n+    Assert.assertEquals(allRealms, routingData.keySet());\n+\n+    // Send a GET request for testZkRealm\n+    String testZkRealm = \"zk-0\";\n+    getRequest = new HttpGet(endpoint + MockMetadataStoreDirectoryServer.REST_PREFIX + namespace\n+        + MockMetadataStoreDirectoryServer.ZK_REALM_ENDPOINT + \"/\" + testZkRealm);\n+    getResponse = httpClient.execute(getRequest);\n+    Map<String, Object> shardingKeysMap = MockMetadataStoreDirectoryServer.OBJECT_MAPPER\n+        .readValue(getResponse.getEntity().getContent(), Map.class);\n+    Assert.assertTrue(\n+        shardingKeysMap.containsKey(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM));\n+    Assert.assertTrue(shardingKeysMap.containsKey(MetadataStoreRoutingConstants.SHARDING_KEYS));\n+    String zkRealm =\n+        (String) shardingKeysMap.get(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM);\n+    Collection<String> shardingKeyList =\n+        (Collection) shardingKeysMap.get(MetadataStoreRoutingConstants.SHARDING_KEYS);\n+    Assert.assertEquals(zkRealm, testZkRealm);\n+    Assert.assertEquals(shardingKeyList, routingData.get(testZkRealm));\n+\n+    // Try sending a POST request (not supported)\n+    HttpPost postRequest = new HttpPost(\n+        endpoint + MockMetadataStoreDirectoryServer.REST_PREFIX + namespace\n+            + MockMetadataStoreDirectoryServer.ZK_REALM_ENDPOINT + \"/\" + testZkRealm);\n+    CloseableHttpResponse postResponse = httpClient.execute(postRequest);\n+\n+    // Shutdown\n+    server.stopServer();\n+    httpClient.close();", "originalCommit": "c130620a404292554d67a989bca47736f67278f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxNjQ0MQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r383716441", "bodyText": "Sure. updated.", "author": "narendly", "createdAt": "2020-02-25T08:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY5OTYzNw=="}], "type": "inlineReview"}, {"oid": "c09373c36acec7044b9a378d230e6a44e828582b", "url": "https://github.com/apache/helix/commit/c09373c36acec7044b9a378d230e6a44e828582b", "message": "address comments", "committedDate": "2020-02-25T08:22:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAyODAxNA==", "url": "https://github.com/apache/helix/pull/775#discussion_r384028014", "bodyText": "Nit, maybe start server before try?", "author": "huizhilu", "createdAt": "2020-02-25T17:42:51Z", "path": "metadata-store-directory-common/src/test/java/org/apache/helix/msdcommon/mock/TestMockMetadataStoreDirectoryServer.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package org.apache.helix.msdcommon.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.junit.Test;\n+import org.testng.Assert;\n+\n+\n+public class TestMockMetadataStoreDirectoryServer {\n+  @Test\n+  public void testMockMetadataStoreDirectoryServer() throws IOException {\n+    // Create fake routing data\n+    Map<String, Collection<String>> routingData = new HashMap<>();\n+    routingData.put(\"zk-0\", ImmutableList.of(\"sharding-key-0\", \"sharding-key-1\", \"sharding-key-2\"));\n+    routingData.put(\"zk-1\", ImmutableList.of(\"sharding-key-3\", \"sharding-key-4\", \"sharding-key-5\"));\n+    routingData.put(\"zk-2\", ImmutableList.of(\"sharding-key-6\", \"sharding-key-7\", \"sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    String host = \"localhost\";\n+    int port = 11000;\n+    String endpoint = \"http://\" + host + \":\" + port;\n+    String namespace = \"MY-HELIX-NAMESPACE\";\n+\n+    MockMetadataStoreDirectoryServer server =\n+        new MockMetadataStoreDirectoryServer(host, port, namespace, routingData);\n+    try (CloseableHttpClient httpClient = HttpClients.createDefault()) {\n+      server.startServer();", "originalCommit": "c09373c36acec7044b9a378d230e6a44e828582b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3NzM1MA==", "url": "https://github.com/apache/helix/pull/775#discussion_r384077350", "bodyText": "OK", "author": "narendly", "createdAt": "2020-02-25T19:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAyODAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0MjkzOA==", "url": "https://github.com/apache/helix/pull/775#discussion_r384042938", "bodyText": "Can Assert correctly check a list and a collection (a set instance) ? I doubt it.", "author": "huizhilu", "createdAt": "2020-02-25T18:25:56Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/util/TestHttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableSet;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestHttpRoutingDataReader extends ZkTestBase {\n+  private MockMetadataStoreDirectoryServer _msdsServer;\n+  private Map<String, Collection<String>> _testRawRoutingData;\n+  private final String _host = \"localhost\";\n+  private final int _port = 1991;\n+  private final String _namespace = \"TestHttpRoutingDataReader\";\n+\n+  @BeforeClass\n+  public void beforeClass() throws IOException {\n+    // Create fake routing data\n+    _testRawRoutingData = new HashMap<>();\n+    _testRawRoutingData\n+        .put(\"zk-0\", ImmutableSet.of(\"/sharding-key-0\", \"/sharding-key-1\", \"/sharding-key-2\"));\n+    _testRawRoutingData\n+        .put(\"zk-1\", ImmutableSet.of(\"/sharding-key-3\", \"/sharding-key-4\", \"/sharding-key-5\"));\n+    _testRawRoutingData\n+        .put(\"zk-2\", ImmutableSet.of(\"/sharding-key-6\", \"/sharding-key-7\", \"/sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    _msdsServer =\n+        new MockMetadataStoreDirectoryServer(_host, _port, _namespace, _testRawRoutingData);\n+    _msdsServer.startServer();\n+\n+    // Register the endpoint as a System property\n+    String msdsEndpoint = \"http://\" + _host + \":\" + _port + \"/admin/v2/namespaces/\" + _namespace;\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY, msdsEndpoint);\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _msdsServer.stopServer();\n+  }\n+\n+  @Test\n+  public void testGetRawRoutingData() throws IOException {\n+    Map<String, List<String>> rawRoutingData = HttpRoutingDataReader.getRawRoutingData();\n+    _testRawRoutingData\n+        .forEach((realm, keys) -> Assert.assertEquals(rawRoutingData.get(realm), keys));", "originalCommit": "c09373c36acec7044b9a378d230e6a44e828582b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4Njg1OA==", "url": "https://github.com/apache/helix/pull/775#discussion_r384086858", "bodyText": "Would you feel more comfortable if I wrapped it as a HashMap? done.", "author": "narendly", "createdAt": "2020-02-25T19:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0MjkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0NzUzMg==", "url": "https://github.com/apache/helix/pull/775#discussion_r384047532", "bodyText": "What do you mean here? My understanding is, if neither set is null, Assert could check them, regardless ordering of elements: set[\"a\", \"b\", \"c\"], set[\"c\", \"b\", \"a\"] should be equal. What is the case they are not equal: \"if the ordering of elements is not equal\"?", "author": "huizhilu", "createdAt": "2020-02-25T18:34:17Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/util/TestHttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableSet;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestHttpRoutingDataReader extends ZkTestBase {\n+  private MockMetadataStoreDirectoryServer _msdsServer;\n+  private Map<String, Collection<String>> _testRawRoutingData;\n+  private final String _host = \"localhost\";\n+  private final int _port = 1991;\n+  private final String _namespace = \"TestHttpRoutingDataReader\";\n+\n+  @BeforeClass\n+  public void beforeClass() throws IOException {\n+    // Create fake routing data\n+    _testRawRoutingData = new HashMap<>();\n+    _testRawRoutingData\n+        .put(\"zk-0\", ImmutableSet.of(\"/sharding-key-0\", \"/sharding-key-1\", \"/sharding-key-2\"));\n+    _testRawRoutingData\n+        .put(\"zk-1\", ImmutableSet.of(\"/sharding-key-3\", \"/sharding-key-4\", \"/sharding-key-5\"));\n+    _testRawRoutingData\n+        .put(\"zk-2\", ImmutableSet.of(\"/sharding-key-6\", \"/sharding-key-7\", \"/sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    _msdsServer =\n+        new MockMetadataStoreDirectoryServer(_host, _port, _namespace, _testRawRoutingData);\n+    _msdsServer.startServer();\n+\n+    // Register the endpoint as a System property\n+    String msdsEndpoint = \"http://\" + _host + \":\" + _port + \"/admin/v2/namespaces/\" + _namespace;\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY, msdsEndpoint);\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _msdsServer.stopServer();\n+  }\n+\n+  @Test\n+  public void testGetRawRoutingData() throws IOException {\n+    Map<String, List<String>> rawRoutingData = HttpRoutingDataReader.getRawRoutingData();\n+    _testRawRoutingData\n+        .forEach((realm, keys) -> Assert.assertEquals(rawRoutingData.get(realm), keys));\n+  }\n+\n+  @Test(dependsOnMethods = \"testGetRawRoutingData\")\n+  public void testGetMetadataStoreRoutingData() throws IOException, InvalidRoutingDataException {\n+    MetadataStoreRoutingData data = HttpRoutingDataReader.getMetadataStoreRoutingData();\n+    Map<String, String> allMappings = data.getAllMappingUnderPath(\"/\");\n+    Map<String, Set<String>> groupedMappings = allMappings.entrySet().stream().collect(Collectors\n+        .groupingBy(Map.Entry::getValue,\n+            Collectors.mapping(Map.Entry::getKey, Collectors.toSet())));\n+    _testRawRoutingData.forEach((realm, keys) -> {\n+      // Two way containsAll because AssertEquals on two set collections is buggy in that", "originalCommit": "c09373c36acec7044b9a378d230e6a44e828582b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MjcxMg==", "url": "https://github.com/apache/helix/pull/775#discussion_r384072712", "bodyText": "I'm not quite sure I understand what you're asking. Two-way containsAll is basically an equality check. .", "author": "narendly", "createdAt": "2020-02-25T19:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0NzUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4OTMxNg==", "url": "https://github.com/apache/helix/pull/775#discussion_r384089316", "bodyText": "I understand Two-way containsAll is basically an equality check.\nMy point is, if the 2 sets have the same string elements, assertEqual() should pass, no matter the ordering of elements is equal or not.", "author": "huizhilu", "createdAt": "2020-02-25T19:50:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0NzUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2MDQyMQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r384060421", "bodyText": "If you say \"should still return old data because it's static\", I think it is important to check we could still check the old data is actually returned. assert rawRoutingData equals to _rawRoutingData?", "author": "huizhilu", "createdAt": "2020-02-25T18:57:11Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/util/TestHttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableSet;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestHttpRoutingDataReader extends ZkTestBase {\n+  private MockMetadataStoreDirectoryServer _msdsServer;\n+  private Map<String, Collection<String>> _testRawRoutingData;\n+  private final String _host = \"localhost\";\n+  private final int _port = 1991;\n+  private final String _namespace = \"TestHttpRoutingDataReader\";\n+\n+  @BeforeClass\n+  public void beforeClass() throws IOException {\n+    // Create fake routing data\n+    _testRawRoutingData = new HashMap<>();\n+    _testRawRoutingData\n+        .put(\"zk-0\", ImmutableSet.of(\"/sharding-key-0\", \"/sharding-key-1\", \"/sharding-key-2\"));\n+    _testRawRoutingData\n+        .put(\"zk-1\", ImmutableSet.of(\"/sharding-key-3\", \"/sharding-key-4\", \"/sharding-key-5\"));\n+    _testRawRoutingData\n+        .put(\"zk-2\", ImmutableSet.of(\"/sharding-key-6\", \"/sharding-key-7\", \"/sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    _msdsServer =\n+        new MockMetadataStoreDirectoryServer(_host, _port, _namespace, _testRawRoutingData);\n+    _msdsServer.startServer();\n+\n+    // Register the endpoint as a System property\n+    String msdsEndpoint = \"http://\" + _host + \":\" + _port + \"/admin/v2/namespaces/\" + _namespace;\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY, msdsEndpoint);\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _msdsServer.stopServer();\n+  }\n+\n+  @Test\n+  public void testGetRawRoutingData() throws IOException {\n+    Map<String, List<String>> rawRoutingData = HttpRoutingDataReader.getRawRoutingData();\n+    _testRawRoutingData\n+        .forEach((realm, keys) -> Assert.assertEquals(rawRoutingData.get(realm), keys));\n+  }\n+\n+  @Test(dependsOnMethods = \"testGetRawRoutingData\")\n+  public void testGetMetadataStoreRoutingData() throws IOException, InvalidRoutingDataException {\n+    MetadataStoreRoutingData data = HttpRoutingDataReader.getMetadataStoreRoutingData();\n+    Map<String, String> allMappings = data.getAllMappingUnderPath(\"/\");\n+    Map<String, Set<String>> groupedMappings = allMappings.entrySet().stream().collect(Collectors\n+        .groupingBy(Map.Entry::getValue,\n+            Collectors.mapping(Map.Entry::getKey, Collectors.toSet())));\n+    _testRawRoutingData.forEach((realm, keys) -> {\n+      // Two way containsAll because AssertEquals on two set collections is buggy in that\n+      // it will fail if the ordering of elements is not equal (we just want to compare contents)\n+      Assert.assertTrue(groupedMappings.get(realm).containsAll(keys));\n+      Assert.assertTrue(keys.containsAll(groupedMappings.get(realm)));\n+    });\n+  }\n+\n+  /**\n+   * Test that the static methods in HttpRoutingDataReader returns consistent results even though MSDS's data have been updated.\n+   */\n+  @Test(dependsOnMethods = \"testGetMetadataStoreRoutingData\")\n+  public void testStaticMapping() throws IOException, InvalidRoutingDataException {\n+    // Modify routing data\n+    String newRealm = \"newRealm\";\n+    _testRawRoutingData.put(newRealm, ImmutableSet.of(\"/newKey\"));\n+\n+    // Kill MSDS and restart with a new mapping\n+    _msdsServer.stopServer();\n+    _msdsServer =\n+        new MockMetadataStoreDirectoryServer(_host, _port, _namespace, _testRawRoutingData);\n+    _msdsServer.startServer();\n+\n+    // HttpRoutingDataReader should still return old data because it's static\n+    // Make sure the results don't contain the new realm\n+    Map<String, List<String>> rawRoutingData = HttpRoutingDataReader.getRawRoutingData();\n+    Assert.assertFalse(rawRoutingData.containsKey(newRealm));", "originalCommit": "c09373c36acec7044b9a378d230e6a44e828582b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4Njk4Ng==", "url": "https://github.com/apache/helix/pull/775#discussion_r384086986", "bodyText": "I could do that check too.", "author": "narendly", "createdAt": "2020-02-25T19:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2MDQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2MTY2MA==", "url": "https://github.com/apache/helix/pull/775#discussion_r384061660", "bodyText": "Where is retry count set? Also, shall we make the retry count configurable? I think configurable can be good idea. 3 still seems to me not very safe. If this part not working well, the whole cluster may not bootup.", "author": "kaisun2000", "createdAt": "2020-02-25T18:59:22Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+  private static final int HTTP_TIMEOUT_IN_MS = 5000;\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData() throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException if there is an issue connecting to MSDS\n+   * @throws InvalidRoutingDataException if the raw routing data is not valid\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @return\n+   * @throws IOException\n+   */\n+  private static CloseableHttpResponse getAllRoutingData() throws IOException {\n+    // Retry count is 3 by default", "originalCommit": "c09373c36acec7044b9a378d230e6a44e828582b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MzA3NA==", "url": "https://github.com/apache/helix/pull/775#discussion_r384073074", "bodyText": "@kaisun2000 Please create an issue for this - retry is set as the default HttpClient behavior.", "author": "narendly", "createdAt": "2020-02-25T19:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2MTY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NDQ0MA==", "url": "https://github.com/apache/helix/pull/775#discussion_r384064440", "bodyText": "_parseRoutingData can return an empty map. Then the empty map can be return to user.  This is basically telling user we find nothing. This is error condition.\nIf we make this method public, we should let user know this error condition by throwing exception.", "author": "kaisun2000", "createdAt": "2020-02-25T19:04:21Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+  private static final int HTTP_TIMEOUT_IN_MS = 5000;\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData() throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);", "originalCommit": "c09373c36acec7044b9a378d230e6a44e828582b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3ODI5OQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r384078299", "bodyText": "If we find nothing, we should return an empty map. Users should handle it. Helix Java APIs are the users, and they will handle this scenario as well.\nIn other situations (IOException, invalidRoutingDataExceptions), appropriate exceptions are thrown.", "author": "narendly", "createdAt": "2020-02-25T19:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NDQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NTY3Mw==", "url": "https://github.com/apache/helix/pull/775#discussion_r384065673", "bodyText": "I did not examine the TrieRoutingData implementation. Can we make sure _metaDataStoreRoutingData will not be empty map after this line?\nThis is important. Otherwise, with empty map, you are not going to retry getRawRoutingData. The result is disaster then.", "author": "kaisun2000", "createdAt": "2020-02-25T19:06:46Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+  private static final int HTTP_TIMEOUT_IN_MS = 5000;\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData() throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException if there is an issue connecting to MSDS\n+   * @throws InvalidRoutingDataException if the raw routing data is not valid\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());", "originalCommit": "c09373c36acec7044b9a378d230e6a44e828582b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3OTU2OQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r384079569", "bodyText": "_metaDataStoreRoutingData is not a map. It may have empty content, but if it does have an empty content, the users will fail (basically fail to instantiate).\nThis RoutingDataReader only reads - and from its perspective, it can read something that's empty. That's valid. Error checking should be done by the user. Separation of responsibility.", "author": "narendly", "createdAt": "2020-02-25T19:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NTY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExMDc3Ng==", "url": "https://github.com/apache/helix/pull/775#discussion_r384110776", "bodyText": "Better to throw if _metaDataStoreRoutingData upon instantiation successfully still have empty (invalid data). Throw early easy for user to identify the problem.", "author": "kaisun2000", "createdAt": "2020-02-25T20:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NTY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2ODU5NQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r384068595", "bodyText": "Let us add a comment here.\nWe avoid this point to be SPOF by relying on VIP LB and retry mechanism. This dependency is important. We may revisit this dependency assumption later.", "author": "kaisun2000", "createdAt": "2020-02-25T19:12:30Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+  private static final int HTTP_TIMEOUT_IN_MS = 5000;\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData() throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException if there is an issue connecting to MSDS\n+   * @throws InvalidRoutingDataException if the raw routing data is not valid\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @return\n+   * @throws IOException\n+   */\n+  private static CloseableHttpResponse getAllRoutingData() throws IOException {", "originalCommit": "c09373c36acec7044b9a378d230e6a44e828582b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3NzA3OQ==", "url": "https://github.com/apache/helix/pull/775#discussion_r384077079", "bodyText": "OK.", "author": "narendly", "createdAt": "2020-02-25T19:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2ODU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3OTcwNA==", "url": "https://github.com/apache/helix/pull/775#discussion_r384079704", "bodyText": "OK. I will add clarifying comment next to MSDS endpoint.", "author": "narendly", "createdAt": "2020-02-25T19:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2ODU5NQ=="}], "type": "inlineReview"}, {"oid": "540ca738c0474772d74c5e9c0c568a1f5c82d50c", "url": "https://github.com/apache/helix/commit/540ca738c0474772d74c5e9c0c568a1f5c82d50c", "message": "asdb", "committedDate": "2020-02-25T19:39:53Z", "type": "commit"}, {"oid": "0e348f4ce3efc1e8d2d9d10fd10f498cb321ea0b", "url": "https://github.com/apache/helix/commit/0e348f4ce3efc1e8d2d9d10fd10f498cb321ea0b", "message": "update", "committedDate": "2020-02-25T20:14:32Z", "type": "commit"}, {"oid": "be17869d9e6a9178188dbf7f8cc9611972453a40", "url": "https://github.com/apache/helix/commit/be17869d9e6a9178188dbf7f8cc9611972453a40", "message": "up", "committedDate": "2020-02-25T20:23:26Z", "type": "commit"}]}