{"pr_number": 727, "pr_title": "Add MetadataStoreRoutingDataWriter with DistributedLeaderElection", "pr_createdAt": "2020-02-06T02:30:52Z", "pr_url": "https://github.com/apache/helix/pull/727", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3MTI0OA==", "url": "https://github.com/apache/helix/pull/727#discussion_r375671248", "bodyText": "Fundamentally, I think this is not an efficient way for purpose of control of centralized work. This may increase the traffic to ZK.\nIt will be better to work as Helix leader controller. One of the REST server become write REST server (acquire the lock once). Write request to read-only server forward the request to write server for write purpose.", "author": "junkaixue", "createdAt": "2020-02-06T07:16:32Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.DistributedLock;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLock;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.ZkLockException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final String _zkAddress;\n+  private final HelixZkClient _zkClient;\n+  private final DistributedLock _routingDataLock;", "originalCommit": "cff9c2ed7eeb861d707f4c019c4ec88fad627182", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3NTUwMg==", "url": "https://github.com/apache/helix/pull/727#discussion_r375675502", "bodyText": "@dasahcc\nI agree that making Helix API service (Helix REST) an Helix application is a clever solution, but I have some concerns about that approach - wouldn't we be creating a circular dependency? As in, Helix cluster has problems, which causes problems with REST's single writer invariant, and you need to use REST endpoints to fix Helix cluster but REST has problems... and so on.\nAlso, there was an agreement on this approach with users of Helix because we have an assumption that write operations are rare. Ideally, all operations provided by the writer would be ACL-ed and will only be done by admin. In that sense, I believe this is an appropriate approach since it is simple, self-contained without any other dependency (say Helix controller), and it follows the distributed lock recipe that ZooKeeper is very well-known and tested for.", "author": "narendly", "createdAt": "2020-02-06T07:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3MTI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgyNjQ3NQ==", "url": "https://github.com/apache/helix/pull/727#discussion_r376826475", "bodyText": "Update: using distributed leader election.", "author": "narendly", "createdAt": "2020-02-09T23:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3MTI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1OTk4Mw==", "url": "https://github.com/apache/helix/pull/727#discussion_r376659983", "bodyText": "Did you mean to get the hostname here instead of using the dummy hostname?", "author": "mgao0", "createdAt": "2020-02-07T23:53:12Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.ZkLockException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final String _zkAddress;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkAddress = zkAddress;\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");", "originalCommit": "b6214bf75d25adabe3bb947382f6cee94e6072c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MjE2OQ==", "url": "https://github.com/apache/helix/pull/727#discussion_r376662169", "bodyText": "This item is a TODO: I'll have to get this from Systems property. Dummy is good for now.", "author": "narendly", "createdAt": "2020-02-08T00:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1OTk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MDY2MQ==", "url": "https://github.com/apache/helix/pull/727#discussion_r376660661", "bodyText": "Can you create a variable for the path so you don't need to repeatedly type it out?", "author": "mgao0", "createdAt": "2020-02-07T23:56:17Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.ZkLockException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final String _zkAddress;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkAddress = zkAddress;\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      if (!_zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm)) {", "originalCommit": "b6214bf75d25adabe3bb947382f6cee94e6072c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MjM0NA==", "url": "https://github.com/apache/helix/pull/727#discussion_r376662344", "bodyText": "Will do.", "author": "narendly", "createdAt": "2020-02-08T00:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MDY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MzQwNg==", "url": "https://github.com/apache/helix/pull/727#discussion_r376663406", "bodyText": "try catch so no need to check if the path exists?", "author": "mgao0", "createdAt": "2020-02-08T00:10:05Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.ZkLockException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final String _zkAddress;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkAddress = zkAddress;\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      if (!_zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm)) {\n+        // Create the realm\n+        if (!createZkRealm(realm)) {\n+          // Failed to create the realm - log and return false\n+          LOG.error(\n+              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+              _namespace, realm, shardingKey);\n+          return false;\n+        }\n+      }\n+\n+      // Add the sharding key to an empty ZNRecord\n+      ZNRecord znRecord;\n+      try {\n+        znRecord =\n+            _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          Collections.singletonList(shardingKey));\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      ZNRecord znRecord =\n+          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+      if (znRecord == null || !znRecord\n+          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .contains(shardingKey)) {\n+        // This realm does not exist or shardingKey doesn't exist. Return true!\n+        return true;\n+      }\n+      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .remove(shardingKey);\n+      // Overwrite this ZNRecord with the sharding key removed\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean setRoutingData(Map<String, List<String>> routingData) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      if (routingData == null) {\n+        throw new IllegalArgumentException(\"routingData given is null!\");\n+      }\n+\n+      // Remove existing routing data\n+      for (String zkRealm : _zkClient\n+          .getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+        if (!_zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm)) {\n+          LOG.error(\n+              \"Failed to delete existing routing data in setRoutingData()! Namespace: {}, Realm: {}\",\n+              _namespace, zkRealm);\n+          return false;\n+        }\n+      }\n+\n+      // For each ZkRealm, write the given routing data to ZooKeeper\n+      for (Map.Entry<String, List<String>> routingDataEntry : routingData.entrySet()) {\n+        String zkRealm = routingDataEntry.getKey();\n+        List<String> shardingKeyList = routingDataEntry.getValue();\n+\n+        ZNRecord znRecord = new ZNRecord(zkRealm);\n+        znRecord\n+            .setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeyList);\n+        try {\n+          if (!_zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm)) {", "originalCommit": "b6214bf75d25adabe3bb947382f6cee94e6072c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3NTM3MA==", "url": "https://github.com/apache/helix/pull/727#discussion_r376675370", "bodyText": "I believe @narendly 's logic here is to not write on top of an existing node, therefore the if statement is necessary even with try catch.\nHowever, this check is unnecessary for another reason: this is a synchronized function and each loop of routingData guarantees a different zkRealm, therefore the node will never already exist here. Correct me if I'm wrong, please.", "author": "NealSun96", "createdAt": "2020-02-08T01:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MzQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgyMzQwMQ==", "url": "https://github.com/apache/helix/pull/727#discussion_r376823401", "bodyText": "It's not completely necessary, but it's better to be safe since exists() calls are relatively cheap. I'd rather have an exist() call here than risk getting a ZkNoNodeException.", "author": "narendly", "createdAt": "2020-02-09T22:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MzQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3NDkxMg==", "url": "https://github.com/apache/helix/pull/727#discussion_r376674912", "bodyText": "Nit: can we recursively delete MetadataStoreRoutingConstants.ROUTING_DATA_PATH here?", "author": "NealSun96", "createdAt": "2020-02-08T01:27:30Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.ZkLockException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final String _zkAddress;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkAddress = zkAddress;\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      if (!_zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm)) {\n+        // Create the realm\n+        if (!createZkRealm(realm)) {\n+          // Failed to create the realm - log and return false\n+          LOG.error(\n+              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+              _namespace, realm, shardingKey);\n+          return false;\n+        }\n+      }\n+\n+      // Add the sharding key to an empty ZNRecord\n+      ZNRecord znRecord;\n+      try {\n+        znRecord =\n+            _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          Collections.singletonList(shardingKey));\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      ZNRecord znRecord =\n+          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+      if (znRecord == null || !znRecord\n+          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .contains(shardingKey)) {\n+        // This realm does not exist or shardingKey doesn't exist. Return true!\n+        return true;\n+      }\n+      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .remove(shardingKey);\n+      // Overwrite this ZNRecord with the sharding key removed\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean setRoutingData(Map<String, List<String>> routingData) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      if (routingData == null) {\n+        throw new IllegalArgumentException(\"routingData given is null!\");\n+      }\n+\n+      // Remove existing routing data\n+      for (String zkRealm : _zkClient\n+          .getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {", "originalCommit": "b6214bf75d25adabe3bb947382f6cee94e6072c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgyMzAzNw==", "url": "https://github.com/apache/helix/pull/727#discussion_r376823037", "bodyText": "No: Deletion of MetadataStoreRoutingConstants.ROUTING_DATA_PATH is not necessary, and it could cause ZkNoNodeException.", "author": "narendly", "createdAt": "2020-02-09T22:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3NDkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3NTc2Mw==", "url": "https://github.com/apache/helix/pull/727#discussion_r376675763", "bodyText": "IMO the test cases are not complete. Each of the test cases should at least cover both true and false situations. The test for setRoutingData needs to make sure it overwrites.", "author": "NealSun96", "createdAt": "2020-02-08T01:35:49Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.server.AbstractTestClass;\n+import org.junit.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestZkRoutingDataWriter extends AbstractTestClass {", "originalCommit": "b6214bf75d25adabe3bb947382f6cee94e6072c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgyMzkwMw==", "url": "https://github.com/apache/helix/pull/727#discussion_r376823903", "bodyText": "setRoutingData now checks for strict equality.", "author": "narendly", "createdAt": "2020-02-09T22:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3NTc2Mw=="}], "type": "inlineReview"}, {"oid": "4c09e1fd298985277d1c1e004d5412630e3e8523", "url": "https://github.com/apache/helix/commit/4c09e1fd298985277d1c1e004d5412630e3e8523", "message": "Fix tests", "committedDate": "2020-02-09T23:09:47Z", "type": "forcePushed"}, {"oid": "fe35863d0be0b07edd40631b14cdbac60bcda0c4", "url": "https://github.com/apache/helix/commit/fe35863d0be0b07edd40631b14cdbac60bcda0c4", "message": "Fix tests", "committedDate": "2020-02-09T23:11:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1OTk1OA==", "url": "https://github.com/apache/helix/pull/727#discussion_r377259958", "bodyText": "This logic looks good to me. I just would like to ask a further question. Let's say user failed to add realm due to non-exists namespace. Then the user would like to add the namespace, how they can do it?", "author": "junkaixue", "createdAt": "2020-02-10T19:10:08Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -132,26 +131,38 @@ public String getMetadataStoreRealm(String namespace, String shardingKey) {\n \n   @Override\n   public boolean addMetadataStoreRealm(String namespace, String realm) {\n-    // TODO implement when MetadataStoreRoutingDataWriter is ready\n-    throw new UnsupportedOperationException();\n+    if (!_routingDataWriterMap.containsKey(namespace)) {", "originalCommit": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM0MDQ3OA==", "url": "https://github.com/apache/helix/pull/727#discussion_r377340478", "bodyText": "Namespaces are defined in the System config and therefore are static throughout the lifecycle of the deployment.\nIt would require a restart of the service.", "author": "narendly", "createdAt": "2020-02-10T21:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1OTk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2MDQ1NA==", "url": "https://github.com/apache/helix/pull/727#discussion_r377260454", "bodyText": "Is there possible an operation to rename realm/sharding key?", "author": "junkaixue", "createdAt": "2020-02-10T19:11:07Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/MetadataStoreRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An interface for a DAO that writes to the metadata store that stores routing data.\n+ * Note: Each data writer connects to a single namespace.\n+ */\n+public interface MetadataStoreRoutingDataWriter {", "originalCommit": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM0MTAxNQ==", "url": "https://github.com/apache/helix/pull/727#discussion_r377341015", "bodyText": "That is not allowed. One would have to delete and create with a new name.", "author": "narendly", "createdAt": "2020-02-10T21:57:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2MDQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2MTU2Ng==", "url": "https://github.com/apache/helix/pull/727#discussion_r377261566", "bodyText": "If you got ZkNodeExistsException, it means creation failed. Would you like to add it again? Why not use _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, true) to create its parent?", "author": "junkaixue", "createdAt": "2020-02-10T19:13:20Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay", "originalCommit": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM0MTkzNQ==", "url": "https://github.com/apache/helix/pull/727#discussion_r377341935", "bodyText": "MetadataStoreRoutingConstants.ROUTING_DATA_PATH is not a nested path and does not have a parent path.\nIf ZkNodeExistsException occurs, that means the path exists already.", "author": "narendly", "createdAt": "2020-02-10T21:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2MTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxMTQzMw==", "url": "https://github.com/apache/helix/pull/727#discussion_r377311433", "bodyText": "Can we combine these try catches into one and handle the problem by different exceptions?", "author": "junkaixue", "createdAt": "2020-02-10T20:56:17Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    // TODO: Fill in when Helix REST implementations are ready\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+      if (!_zkClient.exists(realmPath)) {\n+        // Create the realm\n+        if (!createZkRealm(realm)) {\n+          // Failed to create the realm - log and return false\n+          LOG.error(\n+              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+              _namespace, realm, shardingKey);\n+          return false;\n+        }\n+      }\n+\n+      // Add the sharding key to an empty ZNRecord\n+      ZNRecord znRecord;\n+      try {\n+        znRecord = _zkClient.readData(realmPath);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          Collections.singletonList(shardingKey));\n+      try {\n+        _zkClient.writeData(realmPath, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }", "originalCommit": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1NjQ1Mg==", "url": "https://github.com/apache/helix/pull/727#discussion_r377356452", "bodyText": "This was considered, but raw zookeeper is not very clear about the kind of exceptions it throws (it throws Exception).\nNote that as soon as we encounter an exception, we need to return and should not proceed. Otherwise, we might risk getting an NPE.", "author": "narendly", "createdAt": "2020-02-10T22:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxMTQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM3MzAwMA==", "url": "https://github.com/apache/helix/pull/727#discussion_r377373000", "bodyText": "Then let's have a todo here. Since we are working the ZKClient module. Let's have clear different exceptions for different errors. It will benefit the coding convention with that.", "author": "junkaixue", "createdAt": "2020-02-10T23:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxMTQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxODE2OQ==", "url": "https://github.com/apache/helix/pull/727#discussion_r377318169", "bodyText": "else clause may not need for this case.", "author": "junkaixue", "createdAt": "2020-02-10T21:10:34Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    // TODO: Fill in when Helix REST implementations are ready\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+      if (!_zkClient.exists(realmPath)) {\n+        // Create the realm\n+        if (!createZkRealm(realm)) {\n+          // Failed to create the realm - log and return false\n+          LOG.error(\n+              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+              _namespace, realm, shardingKey);\n+          return false;\n+        }\n+      }\n+\n+      // Add the sharding key to an empty ZNRecord\n+      ZNRecord znRecord;\n+      try {\n+        znRecord = _zkClient.readData(realmPath);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          Collections.singletonList(shardingKey));\n+      try {\n+        _zkClient.writeData(realmPath, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      ZNRecord znRecord =\n+          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+      if (znRecord == null || !znRecord\n+          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .contains(shardingKey)) {\n+        // This realm does not exist or shardingKey doesn't exist. Return true!\n+        return true;\n+      }\n+      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .remove(shardingKey);\n+      // Overwrite this ZNRecord with the sharding key removed\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean setRoutingData(Map<String, List<String>> routingData) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      if (routingData == null) {\n+        throw new IllegalArgumentException(\"routingData given is null!\");\n+      }\n+\n+      // Remove existing routing data\n+      for (String zkRealm : _zkClient\n+          .getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+        if (!_zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm)) {\n+          LOG.error(\n+              \"Failed to delete existing routing data in setRoutingData()! Namespace: {}, Realm: {}\",\n+              _namespace, zkRealm);\n+          return false;\n+        }\n+      }\n+\n+      // For each ZkRealm, write the given routing data to ZooKeeper\n+      for (Map.Entry<String, List<String>> routingDataEntry : routingData.entrySet()) {\n+        String zkRealm = routingDataEntry.getKey();\n+        List<String> shardingKeyList = routingDataEntry.getValue();\n+\n+        ZNRecord znRecord = new ZNRecord(zkRealm);\n+        znRecord\n+            .setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeyList);\n+\n+        String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm;\n+        try {\n+          if (!_zkClient.exists(realmPath)) {\n+            _zkClient.createPersistent(realmPath);\n+          }\n+          _zkClient.writeData(realmPath, znRecord);\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to write data in setRoutingData()! Namespace: {}, Realm: {}\",\n+              _namespace, zkRealm, e);\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized void close() {\n+    _zkClient.close();\n+  }\n+\n+  /**\n+   * Creates a ZK realm ZNode and populates it with an empty ZNRecord if it doesn't exist already.\n+   * @param realm\n+   * @return\n+   */\n+  private boolean createZkRealm(String realm) {\n+    if (_zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm)) {\n+      LOG.warn(\"createZkRealm() called for realm: {}, but this realm already exists! Namespace: {}\",\n+          realm, _namespace);\n+      return true;\n+    } else {\n+      try {\n+        _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+        _zkClient.writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm,\n+            new ZNRecord(realm));\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to create ZkRealm: {}, Namespace: \", realm, _namespace);\n+        return false;\n+      }\n+    }", "originalCommit": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM0MjI1Mg==", "url": "https://github.com/apache/helix/pull/727#discussion_r377342252", "bodyText": "Will remove.", "author": "narendly", "createdAt": "2020-02-10T22:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxODE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMDAzOA==", "url": "https://github.com/apache/helix/pull/727#discussion_r377320038", "bodyText": "Shall we make it as singleton?", "author": "junkaixue", "createdAt": "2020-02-10T21:14:31Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/concurrency/ZkDistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.rest.metadatastore.concurrency;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkDistributedLeaderElection implements IZkDataListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkDistributedLeaderElection.class);\n+  private static final String PREFIX = \"MSDS_SERVER_\";\n+\n+  private final HelixZkClient _zkClient;\n+  private final String _basePath;\n+  private final ZNRecord _participantInfo;\n+  private ZNRecord _currentLeaderInfo;\n+\n+  private String _myEphemeralSequentialPath;\n+  private volatile boolean _isLeader;\n+\n+  public ZkDistributedLeaderElection(HelixZkClient zkClient, String basePath,", "originalCommit": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MzE3Ng==", "url": "https://github.com/apache/helix/pull/727#discussion_r377393176", "bodyText": "Discussed offline. This class doesn't need to be a singleton because we could use it elsewhere.", "author": "narendly", "createdAt": "2020-02-11T00:18:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMDAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTIwMA==", "url": "https://github.com/apache/helix/pull/727#discussion_r377321200", "bodyText": "Shall we create this ephemeral node first instead of creating storing structure?", "author": "junkaixue", "createdAt": "2020-02-10T21:16:58Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/concurrency/ZkDistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.rest.metadatastore.concurrency;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkDistributedLeaderElection implements IZkDataListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkDistributedLeaderElection.class);\n+  private static final String PREFIX = \"MSDS_SERVER_\";\n+\n+  private final HelixZkClient _zkClient;\n+  private final String _basePath;\n+  private final ZNRecord _participantInfo;\n+  private ZNRecord _currentLeaderInfo;\n+\n+  private String _myEphemeralSequentialPath;\n+  private volatile boolean _isLeader;\n+\n+  public ZkDistributedLeaderElection(HelixZkClient zkClient, String basePath,\n+      ZNRecord participantInfo) {\n+    synchronized (this) {\n+      if (zkClient == null || zkClient.isClosed()) {\n+        throw new IllegalArgumentException(\"ZkClient cannot be null or closed!\");\n+      }\n+      _zkClient = zkClient;\n+      _zkClient.setZkSerializer(new ZNRecordSerializer());\n+      if (basePath == null || basePath.isEmpty()) {\n+        throw new IllegalArgumentException(\"lockBasePath cannot be null or empty!\");\n+      }\n+      _basePath = basePath;\n+      _participantInfo = participantInfo;\n+      _isLeader = false;\n+    }\n+    init();\n+  }\n+\n+  /**\n+   * Create the base path if it doesn't exist and create an ephemeral sequential ZNode.\n+   */\n+  private void init() {\n+    try {\n+      _zkClient.createPersistent(_basePath, true);\n+    } catch (ZkNodeExistsException e) {\n+      // Okay if it exists already\n+    }\n+\n+    // Create my ephemeral sequential node with my information\n+    _myEphemeralSequentialPath = _zkClient", "originalCommit": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM3ODI1NQ==", "url": "https://github.com/apache/helix/pull/727#discussion_r377378255", "bodyText": "What do you mean by storing structure?", "author": "narendly", "createdAt": "2020-02-10T23:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5NDkzMw==", "url": "https://github.com/apache/helix/pull/727#discussion_r377394933", "bodyText": "Clarified offline. This is needed.", "author": "narendly", "createdAt": "2020-02-11T00:24:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM3MDQ0Nw==", "url": "https://github.com/apache/helix/pull/727#discussion_r377370447", "bodyText": "Should this be state change? There should not be any case of ZNode data change, right?", "author": "junkaixue", "createdAt": "2020-02-10T23:05:11Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/concurrency/ZkDistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.rest.metadatastore.concurrency;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkDistributedLeaderElection implements IZkDataListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkDistributedLeaderElection.class);\n+  private static final String PREFIX = \"MSDS_SERVER_\";\n+\n+  private final HelixZkClient _zkClient;\n+  private final String _basePath;\n+  private final ZNRecord _participantInfo;\n+  private ZNRecord _currentLeaderInfo;\n+\n+  private String _myEphemeralSequentialPath;\n+  private volatile boolean _isLeader;\n+\n+  public ZkDistributedLeaderElection(HelixZkClient zkClient, String basePath,\n+      ZNRecord participantInfo) {\n+    synchronized (this) {\n+      if (zkClient == null || zkClient.isClosed()) {\n+        throw new IllegalArgumentException(\"ZkClient cannot be null or closed!\");\n+      }\n+      _zkClient = zkClient;\n+      _zkClient.setZkSerializer(new ZNRecordSerializer());\n+      if (basePath == null || basePath.isEmpty()) {\n+        throw new IllegalArgumentException(\"lockBasePath cannot be null or empty!\");\n+      }\n+      _basePath = basePath;\n+      _participantInfo = participantInfo;\n+      _isLeader = false;\n+    }\n+    init();\n+  }\n+\n+  /**\n+   * Create the base path if it doesn't exist and create an ephemeral sequential ZNode.\n+   */\n+  private void init() {\n+    try {\n+      _zkClient.createPersistent(_basePath, true);\n+    } catch (ZkNodeExistsException e) {\n+      // Okay if it exists already\n+    }\n+\n+    // Create my ephemeral sequential node with my information\n+    _myEphemeralSequentialPath = _zkClient\n+        .create(_basePath + \"/\" + PREFIX, _participantInfo, CreateMode.EPHEMERAL_SEQUENTIAL);\n+    if (_myEphemeralSequentialPath == null) {\n+      throw new IllegalStateException(\n+          \"Unable to create ephemeral sequential node at path: \" + _basePath);\n+    }\n+    tryAcquiringLeadership();\n+  }\n+\n+  private void tryAcquiringLeadership() {\n+    List<String> children = _zkClient.getChildren(_basePath);\n+    Collections.sort(children);\n+    String leaderName = children.get(0);\n+    ZNRecord leaderInfo = _zkClient.readData(_basePath + \"/\" + leaderName, true);\n+\n+    String[] myNameArray = _myEphemeralSequentialPath.split(\"/\");\n+    String myName = myNameArray[myNameArray.length - 1];\n+\n+    if (leaderName.equals(myName)) {\n+      // My turn for leadership\n+      _isLeader = true;\n+      _currentLeaderInfo = leaderInfo;\n+      LOG.info(\"{} acquired leadership! Info: {}\", myName, leaderInfo);\n+    } else {\n+      // Watch the ephemeral ZNode before me for a deletion event\n+      String beforeMe = children.get(children.indexOf(myName) - 1);\n+      _zkClient.subscribeDataChanges(_basePath + \"/\" + beforeMe, this);", "originalCommit": "8302d3f8df671f18cfe39dce668cccd4a75cfcbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5NTAyNg==", "url": "https://github.com/apache/helix/pull/727#discussion_r377395026", "bodyText": "DataChange includes deletion event as noted in the comment below.", "author": "narendly", "createdAt": "2020-02-11T00:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM3MDQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM3MzY3NQ==", "url": "https://github.com/apache/helix/pull/727#discussion_r377373675", "bodyText": "Was data delete referring the content of ZNode instead of ZNode it self?", "author": "junkaixue", "createdAt": "2020-02-10T23:14:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/concurrency/ZkDistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.rest.metadatastore.concurrency;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkDistributedLeaderElection implements IZkDataListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkDistributedLeaderElection.class);\n+  private static final String PREFIX = \"MSDS_SERVER_\";\n+\n+  private final HelixZkClient _zkClient;\n+  private final String _basePath;\n+  private final ZNRecord _participantInfo;\n+  private ZNRecord _currentLeaderInfo;\n+\n+  private String _myEphemeralSequentialPath;\n+  private volatile boolean _isLeader;\n+\n+  public ZkDistributedLeaderElection(HelixZkClient zkClient, String basePath,\n+      ZNRecord participantInfo) {\n+    synchronized (this) {\n+      if (zkClient == null || zkClient.isClosed()) {\n+        throw new IllegalArgumentException(\"ZkClient cannot be null or closed!\");\n+      }\n+      _zkClient = zkClient;\n+      _zkClient.setZkSerializer(new ZNRecordSerializer());\n+      if (basePath == null || basePath.isEmpty()) {\n+        throw new IllegalArgumentException(\"lockBasePath cannot be null or empty!\");\n+      }\n+      _basePath = basePath;\n+      _participantInfo = participantInfo;\n+      _isLeader = false;\n+    }\n+    init();\n+  }\n+\n+  /**\n+   * Create the base path if it doesn't exist and create an ephemeral sequential ZNode.\n+   */\n+  private void init() {\n+    try {\n+      _zkClient.createPersistent(_basePath, true);\n+    } catch (ZkNodeExistsException e) {\n+      // Okay if it exists already\n+    }\n+\n+    // Create my ephemeral sequential node with my information\n+    _myEphemeralSequentialPath = _zkClient\n+        .create(_basePath + \"/\" + PREFIX, _participantInfo, CreateMode.EPHEMERAL_SEQUENTIAL);\n+    if (_myEphemeralSequentialPath == null) {\n+      throw new IllegalStateException(\n+          \"Unable to create ephemeral sequential node at path: \" + _basePath);\n+    }\n+    tryAcquiringLeadership();\n+  }\n+\n+  private void tryAcquiringLeadership() {\n+    List<String> children = _zkClient.getChildren(_basePath);\n+    Collections.sort(children);\n+    String leaderName = children.get(0);\n+    ZNRecord leaderInfo = _zkClient.readData(_basePath + \"/\" + leaderName, true);\n+\n+    String[] myNameArray = _myEphemeralSequentialPath.split(\"/\");\n+    String myName = myNameArray[myNameArray.length - 1];\n+\n+    if (leaderName.equals(myName)) {\n+      // My turn for leadership\n+      _isLeader = true;\n+      _currentLeaderInfo = leaderInfo;\n+      LOG.info(\"{} acquired leadership! Info: {}\", myName, leaderInfo);\n+    } else {\n+      // Watch the ephemeral ZNode before me for a deletion event\n+      String beforeMe = children.get(children.indexOf(myName) - 1);\n+      _zkClient.subscribeDataChanges(_basePath + \"/\" + beforeMe, this);\n+    }\n+  }\n+\n+  public synchronized boolean isLeader() {\n+    return _isLeader;\n+  }\n+\n+  public synchronized ZNRecord getCurrentLeaderInfo() {\n+    return _currentLeaderInfo;\n+  }\n+\n+  @Override\n+  public synchronized void handleStateChanged(Watcher.Event.KeeperState state) {\n+    if (state == Watcher.Event.KeeperState.SyncConnected) {\n+      init();\n+    }\n+  }\n+\n+  @Override\n+  public void handleNewSession(String sessionId) {\n+    return;\n+  }\n+\n+  @Override\n+  public void handleSessionEstablishmentError(Throwable error) {\n+    return;\n+  }\n+\n+  @Override\n+  public void handleDataChange(String s, Object o) {\n+    return;\n+  }\n+\n+  @Override\n+  public void handleDataDeleted(String s) {", "originalCommit": "8302d3f8df671f18cfe39dce668cccd4a75cfcbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM3ODAwNg==", "url": "https://github.com/apache/helix/pull/727#discussion_r377378006", "bodyText": "I'm not sure what you're asking about exactly...\n\nprivate void fireDataChangedEvents(final String path, Set listeners,\nfinal OptionalLong notificationTime) {\ntry {\nfinal ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n// Trigger listener callbacks\nfor (final IZkDataListenerEntry listener : listeners) {\n_eventThread.send(new ZkEvent(\"Data of \" + path + \" changed sent to \"\n+ listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n@OverRide\npublic void run() throws Exception {\n// Reinstall watch before listener callbacks to check the znode status\nif (!pathStatRecord.pathChecked()) {\npathStatRecord.recordPathStat(getStat(path, true), notificationTime);\n}\nif (!pathStatRecord.pathExists()) {\n// no znode found at the path, trigger data deleted handler.\nlistener.getDataListener().handleDataDeleted(path);\n} else {\nObject data = null;\nif (listener.isPrefetchData()) {\nif (LOG.isDebugEnabled()) {\nLOG.debug(\"Prefetch data for path: {}\", path);\n}\ntry {\ndata = readData(path, null, true);\n} catch (ZkNoNodeException e) {\nLOG.warn(\"Prefetch data for path: {} failed.\", path, e);\nlistener.getDataListener().handleDataDeleted(path);\nreturn;\n}\n}\nlistener.getDataListener().handleDataChange(path, data);\n}\n}\n});\n}\n\nDoes this help?", "author": "narendly", "createdAt": "2020-02-10T23:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM3MzY3NQ=="}], "type": "inlineReview"}, {"oid": "8f031375b63c0beaa1c70aa352e80f5031f06583", "url": "https://github.com/apache/helix/commit/8f031375b63c0beaa1c70aa352e80f5031f06583", "message": "Add MetadataStoreRoutingDataWriter and its ZK implementation", "committedDate": "2020-02-11T00:46:55Z", "type": "commit"}, {"oid": "c52b7b4b31292e6ece44a68a34bc0be4097bfd57", "url": "https://github.com/apache/helix/commit/c52b7b4b31292e6ece44a68a34bc0be4097bfd57", "message": "Complete implementation with lock", "committedDate": "2020-02-11T00:46:55Z", "type": "commit"}, {"oid": "c7f4543ab1fb138333b4192d171b0c2e583197ce", "url": "https://github.com/apache/helix/commit/c7f4543ab1fb138333b4192d171b0c2e583197ce", "message": "Fix typo and add more comments", "committedDate": "2020-02-11T00:46:55Z", "type": "commit"}, {"oid": "13167dd9a8369523ed91d67a28f67d33747a3051", "url": "https://github.com/apache/helix/commit/13167dd9a8369523ed91d67a28f67d33747a3051", "message": "Fix typo", "committedDate": "2020-02-11T00:46:55Z", "type": "commit"}, {"oid": "0db0ffbb0e8bf89cd624d70921ae158f56f0ae3e", "url": "https://github.com/apache/helix/commit/0db0ffbb0e8bf89cd624d70921ae158f56f0ae3e", "message": "Integrate with MetadataStoreDirectory", "committedDate": "2020-02-11T00:52:22Z", "type": "commit"}, {"oid": "070a2de721ede141d216bb5691971fba22ccc260", "url": "https://github.com/apache/helix/commit/070a2de721ede141d216bb5691971fba22ccc260", "message": "Add tests and fix tests", "committedDate": "2020-02-11T00:52:23Z", "type": "commit"}, {"oid": "6655992bf9ef72ab9dab424e5b84d33cd7ffa1b9", "url": "https://github.com/apache/helix/commit/6655992bf9ef72ab9dab424e5b84d33cd7ffa1b9", "message": "Use DistributedLeaderElection instead", "committedDate": "2020-02-11T00:52:23Z", "type": "commit"}, {"oid": "bd085a225eb81533586dfedd9407aafca58eb51f", "url": "https://github.com/apache/helix/commit/bd085a225eb81533586dfedd9407aafca58eb51f", "message": "Remove unused import", "committedDate": "2020-02-11T00:52:23Z", "type": "commit"}, {"oid": "3505d1355b9cb0c35ada895581fd3088bf2746fb", "url": "https://github.com/apache/helix/commit/3505d1355b9cb0c35ada895581fd3088bf2746fb", "message": "address comments", "committedDate": "2020-02-11T00:52:23Z", "type": "commit"}, {"oid": "3530a627677b7e46bec13506e4bd3eb72d141486", "url": "https://github.com/apache/helix/commit/3530a627677b7e46bec13506e4bd3eb72d141486", "message": "Fix tests", "committedDate": "2020-02-11T00:52:23Z", "type": "commit"}, {"oid": "1da51e1cce24ad7631b3c1c9f9f594c10c687aaf", "url": "https://github.com/apache/helix/commit/1da51e1cce24ad7631b3c1c9f9f594c10c687aaf", "message": "clean up code", "committedDate": "2020-02-11T00:52:23Z", "type": "commit"}, {"oid": "63c67e7c11ab2158e380a4d9536f06e19f4f865a", "url": "https://github.com/apache/helix/commit/63c67e7c11ab2158e380a4d9536f06e19f4f865a", "message": "remove unncessary else", "committedDate": "2020-02-11T00:52:23Z", "type": "commit"}, {"oid": "879ab5a4d8c1d6533a8a0d1f95ed73128d0b7e06", "url": "https://github.com/apache/helix/commit/879ab5a4d8c1d6533a8a0d1f95ed73128d0b7e06", "message": "remove unnecessary throw exception", "committedDate": "2020-02-11T00:52:23Z", "type": "commit"}, {"oid": "879ab5a4d8c1d6533a8a0d1f95ed73128d0b7e06", "url": "https://github.com/apache/helix/commit/879ab5a4d8c1d6533a8a0d1f95ed73128d0b7e06", "message": "remove unnecessary throw exception", "committedDate": "2020-02-11T00:52:23Z", "type": "forcePushed"}]}