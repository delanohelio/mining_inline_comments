{"pr_number": 1540, "pr_title": "Move subscribeForChange out of critical section", "pr_createdAt": "2020-11-17T19:56:56Z", "pr_url": "https://github.com/apache/helix/pull/1540", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYxOTkxOQ==", "url": "https://github.com/apache/helix/pull/1540#discussion_r525619919", "bodyText": "nit, \"the listener\" -> \"the Helix Manager\"?\nAlso, let's add a TODO here since it might be overkill as we discussed.", "author": "jiajunwang", "createdAt": "2020-11-18T00:42:11Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -340,26 +340,28 @@ public void enqueueTask(NotificationContext changeContext) throws Exception {\n   public void invoke(NotificationContext changeContext) throws Exception {\n     Type type = changeContext.getType();\n     long start = System.currentTimeMillis();\n+    if (logger.isInfoEnabled()) {\n+      logger.info(\"{} START: CallbackHandler {}, INVOKE {} listener: {} type: {}\",\n+          Thread.currentThread().getId(), _uid, _path, _listener, type);\n+    }\n \n-    // This allows the listener to work with one change at a time\n-    synchronized (_manager) {\n-      if (logger.isInfoEnabled()) {\n-        logger\n-            .info(\"{} START: CallbackHandler {}, INVOKE {} listener: {} type: {}\", Thread.currentThread().getId(),\n-                _uid, _path, _listener, type);\n-      }\n+    synchronized (this) {\n \n       if (!_expectTypes.contains(type)) {\n         logger.warn(\"Callback handler {} received event in wrong order. Listener: {}, path: {}, \"\n             + \"expected types: {}, but was {}\", _uid, _listener, _path, _expectTypes, type);\n         return;\n-\n       }\n       _expectTypes = nextNotificationType.get(type);\n \n       if (type == Type.INIT || type == Type.FINALIZE || changeContext.getIsChildChange()) {\n         subscribeForChanges(changeContext.getType(), _path, _watchChild);\n       }\n+    }\n+\n+    // This allows the listener to work with one change at a time", "originalCommit": "e1451a63843ba5250ff03f5ba0412b240a95d379", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ1NjA3OQ==", "url": "https://github.com/apache/helix/pull/1540#discussion_r526456079", "bodyText": "TFTR. Updated.", "author": "xyuanlu", "createdAt": "2020-11-18T22:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYxOTkxOQ=="}], "type": "inlineReview"}, {"oid": "442d88190819b0c918dc2e49fba01880a8bc5970", "url": "https://github.com/apache/helix/commit/442d88190819b0c918dc2e49fba01880a8bc5970", "message": "move subscribeForChange out of critical section", "committedDate": "2020-11-18T22:08:32Z", "type": "commit"}, {"oid": "c461e4443e606428d6ac1de5699e897ce330c668", "url": "https://github.com/apache/helix/commit/c461e4443e606428d6ac1de5699e897ce330c668", "message": "address comment", "committedDate": "2020-11-18T22:08:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMDM1NA==", "url": "https://github.com/apache/helix/pull/1540#discussion_r526500354", "bodyText": "Why do we sync on this here? In fact, how do we reason it?\nAssuming no batch, the calling path would be from enqueueTask(), which is called by handleXXX from ZkClient event thread. And also init() and reset()\nAssuming batch, the calling path would be from _batchCallbackProcessor and also init() and reset().\ninit() is further called by either first time CallbackHandler construction or ZK session change.\nIt seems that  ZK session change is the only places that there would be race condition, right?", "author": "kaisun2000", "createdAt": "2020-11-18T23:53:58Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -340,26 +340,28 @@ public void enqueueTask(NotificationContext changeContext) throws Exception {\n   public void invoke(NotificationContext changeContext) throws Exception {\n     Type type = changeContext.getType();\n     long start = System.currentTimeMillis();\n+    if (logger.isInfoEnabled()) {\n+      logger.info(\"{} START: CallbackHandler {}, INVOKE {} listener: {} type: {}\",\n+          Thread.currentThread().getId(), _uid, _path, _listener, type);\n+    }\n \n-    // This allows the listener to work with one change at a time\n-    synchronized (_manager) {\n-      if (logger.isInfoEnabled()) {\n-        logger\n-            .info(\"{} START: CallbackHandler {}, INVOKE {} listener: {} type: {}\", Thread.currentThread().getId(),\n-                _uid, _path, _listener, type);\n-      }\n-\n+    // TODO: Having subscribeForChanges here might be overkill. Maybe it could be moved out later.", "originalCommit": "c461e4443e606428d6ac1de5699e897ce330c668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNTg1Ng==", "url": "https://github.com/apache/helix/pull/1540#discussion_r526505856", "bodyText": "I guess it is possible for callBackHandler gets Finalize and a callBack at the same time. So the type checking and the subscribe should be in the same synced block..?", "author": "xyuanlu", "createdAt": "2020-11-19T00:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMDM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMDUzOQ==", "url": "https://github.com/apache/helix/pull/1540#discussion_r526520539", "bodyText": "Please correct me if I am wrong. With batch enabled, it is possible that we get 'Finalize' and a 'callback' at the same time. If there is no lock in line 348 to 358, then it is possible that we do\n\ntype check first for 'callback' and passed,\ntype check for 'Finalize' and passed,\nunsubscribe for 'Finalize'\nSubscribe for 'callback'\n\nThere won't be such issue with the lock here.", "author": "xyuanlu", "createdAt": "2020-11-19T00:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMDM1NA=="}], "type": "inlineReview"}, {"oid": "73102d7c2f75fc8083fe9223a8e6c1b1d32574ea", "url": "https://github.com/apache/helix/commit/73102d7c2f75fc8083fe9223a8e6c1b1d32574ea", "message": "address comment", "committedDate": "2020-11-18T23:58:08Z", "type": "forcePushed"}, {"oid": "4c778c5032940a941f01eb54213f123c7be991e2", "url": "https://github.com/apache/helix/commit/4c778c5032940a941f01eb54213f123c7be991e2", "message": "address comment", "committedDate": "2020-11-19T00:02:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNDI0OA==", "url": "https://github.com/apache/helix/pull/1540#discussion_r526504248", "bodyText": "Why do we sync on this here? In fact, how do we reason it?\nAssuming no batch, the calling path would be from enqueueTask(), which is called by handleXXX from ZkClient event thread. And also init() and reset()\nAssuming batch, the calling path would be from _batchCallbackProcessor and also init() and reset().\ninit() is further called by either first time CallbackHandler construction or ZK session change.\nIt seems that ZK session change is the only places that there would be race condition, right?", "author": "kaisun2000", "createdAt": "2020-11-19T00:04:33Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -340,26 +340,29 @@ public void enqueueTask(NotificationContext changeContext) throws Exception {\n   public void invoke(NotificationContext changeContext) throws Exception {\n     Type type = changeContext.getType();\n     long start = System.currentTimeMillis();\n+    if (logger.isInfoEnabled()) {\n+      logger.info(\"{} START: CallbackHandler {}, INVOKE {} listener: {} type: {}\",\n+          Thread.currentThread().getId(), _uid, _path, _listener, type);\n+    }\n \n-    // This allows the listener to work with one change at a time\n-    synchronized (_manager) {\n-      if (logger.isInfoEnabled()) {\n-        logger\n-            .info(\"{} START: CallbackHandler {}, INVOKE {} listener: {} type: {}\", Thread.currentThread().getId(),\n-                _uid, _path, _listener, type);\n-      }\n-\n+    // TODO: Having subscribeForChanges in critical section might be overkill.\n+    // Maybe it could be moved out later.\n+    synchronized (this) {", "originalCommit": "4c778c5032940a941f01eb54213f123c7be991e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMjIyMg==", "url": "https://github.com/apache/helix/pull/1540#discussion_r526532222", "bodyText": "I think you already answered the question yourself.", "author": "jiajunwang", "createdAt": "2020-11-19T01:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNDI0OA=="}], "type": "inlineReview"}, {"oid": "81e23d1bd1c9a193f0ebafe34293f60899668a25", "url": "https://github.com/apache/helix/commit/81e23d1bd1c9a193f0ebafe34293f60899668a25", "message": "address comment", "committedDate": "2020-11-19T00:04:43Z", "type": "commit"}, {"oid": "81e23d1bd1c9a193f0ebafe34293f60899668a25", "url": "https://github.com/apache/helix/commit/81e23d1bd1c9a193f0ebafe34293f60899668a25", "message": "address comment", "committedDate": "2020-11-19T00:04:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNTM4MA==", "url": "https://github.com/apache/helix/pull/1540#discussion_r526505380", "bodyText": "why sync on _manager?\nby the same argument as sync(this) above, it seems that there is no across _manager race condition, aside from ZK session change. Or am I missing something?", "author": "kaisun2000", "createdAt": "2020-11-19T00:07:44Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -340,26 +340,28 @@ public void enqueueTask(NotificationContext changeContext) throws Exception {\n   public void invoke(NotificationContext changeContext) throws Exception {\n     Type type = changeContext.getType();\n     long start = System.currentTimeMillis();\n+    if (logger.isInfoEnabled()) {\n+      logger.info(\"{} START: CallbackHandler {}, INVOKE {} listener: {} type: {}\",\n+          Thread.currentThread().getId(), _uid, _path, _listener, type);\n+    }\n \n-    // This allows the listener to work with one change at a time\n-    synchronized (_manager) {\n-      if (logger.isInfoEnabled()) {\n-        logger\n-            .info(\"{} START: CallbackHandler {}, INVOKE {} listener: {} type: {}\", Thread.currentThread().getId(),\n-                _uid, _path, _listener, type);\n-      }\n-\n+    synchronized (this) {\n       if (!_expectTypes.contains(type)) {\n         logger.warn(\"Callback handler {} received event in wrong order. Listener: {}, path: {}, \"\n             + \"expected types: {}, but was {}\", _uid, _listener, _path, _expectTypes, type);\n         return;\n-\n       }\n       _expectTypes = nextNotificationType.get(type);\n \n       if (type == Type.INIT || type == Type.FINALIZE || changeContext.getIsChildChange()) {\n         subscribeForChanges(changeContext.getType(), _path, _watchChild);\n       }\n+    }\n+\n+    // This allows the Helix Manager to work with one change at a time\n+    // TODO: Maybe we don't need to sync on _manager for all types of listener. PCould be a\n+    // potential improvement candidate.\n+    synchronized (_manager) {", "originalCommit": "81e23d1bd1c9a193f0ebafe34293f60899668a25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNjM1NQ==", "url": "https://github.com/apache/helix/pull/1540#discussion_r526506355", "bodyText": "Yes In my understanding, I think it is possible that we don't need to make all different onXXXChange to be sequential. So this TODO is added..", "author": "xyuanlu", "createdAt": "2020-11-19T00:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNTM4MA=="}], "type": "inlineReview"}]}