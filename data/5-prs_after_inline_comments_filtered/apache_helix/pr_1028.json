{"pr_number": 1028, "pr_title": "Add Abnormal States Resolver interface and configuration item.", "pr_createdAt": "2020-05-26T20:38:09Z", "pr_url": "https://github.com/apache/helix/pull/1028", "timeline": [{"oid": "e590e34112025d14e1bc5ebaec96c7c7a46966b4", "url": "https://github.com/apache/helix/commit/e590e34112025d14e1bc5ebaec96c7c7a46966b4", "message": "Add Abnormal States Resolver interface and configuration item.\n\nThe Abnormal States Resolver defines a generic interface to find and recover if the partition has any abnormal current states. For example,\n- double masters\n- application data out of sync\nThe interface shall be implemented according to the requirement.\n\nThe resolver is applied in the rebalance process according to the corresponding cluster config item. For example,\n\"ABNORMAL_STATES_RESOLVER_MAP\" : {\n \"MASTERSLAVE\" : \"org.apache.helix.api.rebalancer.constraint.MasterSlaveAbnormalStateReslovler\"\n}\nThe default behavior without any configuration is not doing any recovery work.", "committedDate": "2020-05-26T19:45:58Z", "type": "commit"}, {"oid": "ed4bc2d1136213c227771be33fab9c7042ae26ae", "url": "https://github.com/apache/helix/commit/ed4bc2d1136213c227771be33fab9c7042ae26ae", "message": "Add license info.", "committedDate": "2020-05-27T18:14:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxNDAwMg==", "url": "https://github.com/apache/helix/pull/1028#discussion_r431414002", "bodyText": "We can let it be info since I will not see ClusterConfig change so frequently.", "author": "junkaixue", "createdAt": "2020-05-27T20:11:15Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -723,6 +729,43 @@ public void setAsyncTasksThreadPool(ExecutorService asyncTasksThreadPool) {\n     _asyncTasksThreadPool = asyncTasksThreadPool;\n   }\n \n+\n+  public AbnormalStateResolver getAbnormalStateResolver(String stateModel) {\n+    return _abnormalStateResolverMap\n+        .getOrDefault(stateModel, AbnormalStateResolver.DUMMY_STATE_RESOLVER);\n+  }\n+\n+  private void refreshAbnormalStateResolverMap(ClusterConfig clusterConfig) {\n+    if (clusterConfig == null) {\n+      logger.debug(\"Skip refreshing abnormal state resolvers because the ClusterConfig is missing\");\n+      return;\n+    }\n+    Map<String, String> resolverMap = clusterConfig.getAbnormalStateResolverMap();\n+    logger.debug(\"Start loading the abnormal state resolvers with configuration {}\", resolverMap);\n+    // Remove any resolver configuration that does not exist anymore.\n+    _abnormalStateResolverMap.keySet().retainAll(resolverMap.keySet());\n+    // Reload the resolver classes into cache based on the configuration.\n+    for (String stateModel : resolverMap.keySet()) {\n+      String resolverClassName = resolverMap.get(stateModel);\n+      if (resolverClassName == null || resolverClassName.isEmpty()) {\n+        // skip the empty definition.\n+        continue;\n+      }\n+      if (!resolverClassName.equals(getAbnormalStateResolver(stateModel).getClass().getName())) {\n+        try {\n+          AbnormalStateResolver resolver = AbnormalStateResolver.class\n+              .cast(HelixUtil.loadClass(getClass(), resolverClassName).newInstance());\n+          _abnormalStateResolverMap.put(stateModel, resolver);\n+        } catch (Exception e) {\n+          throw new HelixException(String\n+              .format(\"Failed to instantiate the abnormal state resolver %s for state model %s\",\n+                  resolverClassName, stateModel));\n+        }\n+      } // else, nothing to update since the same resolver class has been loaded.\n+    }\n+    logger.debug(\"Finish loading the abnormal state resolvers {}\", _abnormalStateResolverMap);", "originalCommit": "ed4bc2d1136213c227771be33fab9c7042ae26ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0MjczOQ==", "url": "https://github.com/apache/helix/pull/1028#discussion_r431442739", "bodyText": "Sure", "author": "jiajunwang", "createdAt": "2020-05-27T21:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxNDAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxODY1Nw==", "url": "https://github.com/apache/helix/pull/1028#discussion_r431418657", "bodyText": "Are we changing the logic? For this change, we add optionalOverwrittenStates.isPresent(). This result could come from IS dropping or preference list is null. In this case, it will direct return.\nIf you are not returning, it will execute following code, which may have NPE or some errors?", "author": "junkaixue", "createdAt": "2020-05-27T20:20:40Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java", "diffHunk": "@@ -276,39 +278,20 @@ public ResourceAssignment computeBestPossiblePartitionState(ResourceControllerDa\n     return partitionMapping;\n   }\n \n-  /**\n-   * compute best state for resource in AUTO ideal state mode\n-   * @param liveInstances\n-   * @param stateModelDef\n-   * @param preferenceList\n-   * @param currentStateOutput\n-   *          : instance->state for each partition\n-   * @param disabledInstancesForPartition\n-   * @param idealState\n-   * @param  clusterConfig\n-   * @param  partition\n-   * @return\n-   */\n   @Override\n   protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n       StateModelDefinition stateModelDef, List<String> preferenceList,\n       CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n-      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n-\n+      IdealState idealState, ClusterConfig clusterConfig, Partition partition,\n+      AbnormalStateResolver resolver) {\n+    Optional<Map<String, String>> optionalOverwrittenStates =\n+        computeStatesOverwriteForPartition(stateModelDef, preferenceList, currentStateOutput,\n+            idealState, partition, resolver);\n+    if (optionalOverwrittenStates.isPresent()) {", "originalCommit": "ed4bc2d1136213c227771be33fab9c7042ae26ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0NDg0Nw==", "url": "https://github.com/apache/helix/pull/1028#discussion_r431444847", "bodyText": "If the IS drops or preference list is null, optionalOverwrittenStates will also be filled, and it will return directly.\nThe intention here is to keep the original behavior. Did you see any exception?", "author": "jiajunwang", "createdAt": "2020-05-27T21:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxODY1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ2NjUzMg==", "url": "https://github.com/apache/helix/pull/1028#discussion_r431466532", "bodyText": "I see. I was worrying about the Optional.empty(). But since this is not part of those two functions. The logic should be same.", "author": "junkaixue", "createdAt": "2020-05-27T21:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxODY1Nw=="}], "type": "inlineReview"}, {"oid": "515ff5b45b4da718cca7476f17eb7f8ebf3c5396", "url": "https://github.com/apache/helix/commit/515ff5b45b4da718cca7476f17eb7f8ebf3c5396", "message": "Address comment.", "committedDate": "2020-05-27T21:13:06Z", "type": "commit"}]}