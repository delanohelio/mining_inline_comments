{"pr_number": 765, "pr_title": "Add DedicatedZkClient and update DedicatedZkClientFactory", "pr_createdAt": "2020-02-14T21:42:12Z", "pr_url": "https://github.com/apache/helix/pull/765", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1NzI0OA==", "url": "https://github.com/apache/helix/pull/765#discussion_r380857248", "bodyText": "This is PR for dedicated zkclient factory, right?", "author": "junkaixue", "createdAt": "2020-02-18T18:32:53Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "diffHunk": "@@ -44,15 +44,17 @@ protected SharedZkClientFactory() {\n   @Override\n   public RealmAwareZkClient buildZkClient(\n       RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n-      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,", "originalCommit": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2MjA1MA==", "url": "https://github.com/apache/helix/pull/765#discussion_r380862050", "bodyText": "There was a change in the interface. SharedZkClient implements that interface. So this change is just a signature change, not logical change.\nThis change is necessary.", "author": "narendly", "createdAt": "2020-02-18T18:42:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1NzI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1ODMwMA==", "url": "https://github.com/apache/helix/pull/765#discussion_r380858300", "bodyText": "Is this new code or refactor? If refactor, we should remove the old code in REST module, right?", "author": "junkaixue", "createdAt": "2020-02-18T18:34:56Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,277 @@\n+package org.apache.helix.zookeeper.impl.factory;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * TODO: remove when there's a separate module.\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {", "originalCommit": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2MjgyMw==", "url": "https://github.com/apache/helix/pull/765#discussion_r380862823", "bodyText": "This class will be part of metadata-store-directory-common module.\nOnce #771 is checked in, this class will be removed as noted in the JavaDoc.\nWe cannot directly use this class because that would create a circular dependency.", "author": "narendly", "createdAt": "2020-02-18T18:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1ODMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzYzMQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r380963631", "bodyText": "If we don't want users to directly use this class, shall we consider refactoring the code structure so we can make this class protected? I think that may be better than just commenting not to use it directly.", "author": "huizhilu", "createdAt": "2020-02-18T22:05:32Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,592 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {", "originalCommit": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQzMDc5MQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r381430791", "bodyText": "Good thinking. But we agreed to make the code structure so that factory classes and implementation classes in separate packages, so we cannot make this protected. This was done to better organize the code.", "author": "narendly", "createdAt": "2020-02-19T17:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2ODczOA==", "url": "https://github.com/apache/helix/pull/765#discussion_r380968738", "bodyText": "It seems duplicate code. We can also put the exception throwing into checkIfPathBelongsToZkRealm or validateZkRealmPath() so we don't have to have the duplicate exception throwing in each method.\nUpdate: Maybe I would just wrap this into a method getZkClient(path) and put this check logic in it. So just getZkClient(path).operation()", "author": "huizhilu", "createdAt": "2020-02-18T22:16:39Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,592 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    return create(path, datat, acl, mode, null);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n+      }\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      data = readData(path, stat);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n+      }\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object object) {\n+    writeData(path, object, -1);\n+  }\n+\n+  @Override\n+  public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.updateDataSerialized(path, updater);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object datat, int expectedVersion) {\n+    writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n+    return writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,\n+      ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.asyncCreate(path, datat, mode, cb);\n+  }\n+\n+  @Override\n+  public void asyncSetData(String path, Object datat, int version,\n+      ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.asyncSetData(path, datat, version, cb);\n+  }\n+\n+  @Override\n+  public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.asyncGetData(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.asyncExists(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.asyncDelete(path, cb);\n+  }\n+\n+  @Override\n+  public void watchForData(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "originalCommit": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQzMTkwMw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381431903", "bodyText": "We do not modify the raw ZkClient, even though it might save some duplicate code.\nWe have different logic for checking whether a request is valid, so there is less duplication now.", "author": "narendly", "createdAt": "2020-02-19T17:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2ODczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNzg4Nw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381037887", "bodyText": "@narendly, as discussed offline. I don't think we need this as the connectionConfig have all the information to construct a rest call to MSDS.\nThe checking of a dedicated ZKCLient and dedicated ShareZKClient should all limit to path underlying the sharding key.\nYes, two different sharding keys (cluster) can reside on the same shareded Zookeeper server. But the zkClient constructed with sharding key one should not really be able to access zk path underlying the second sharding key (space). The reason is that later we may need to reshard the keys to different zookeeper servers,  that would be a problem then.  \"future backward compatibility problem\".", "author": "kaisun2000", "createdAt": "2020-02-19T01:55:21Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "diffHunk": "@@ -44,15 +44,17 @@ protected SharedZkClientFactory() {\n   @Override\n   public RealmAwareZkClient buildZkClient(\n       RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n-      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n     // TODO: Implement the logic\n     // Return an instance of SharedZkClient\n     return null;\n   }\n \n   @Override\n   public RealmAwareZkClient buildZkClient(\n-      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig) {\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {", "originalCommit": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4OTU4NA==", "url": "https://github.com/apache/helix/pull/765#discussion_r381489584", "bodyText": "@kaisun2000 Good point. As we discussed in person, this is only put in here to make the code build. We will remove this from the constructor in a future PR when the global routing data is available.", "author": "narendly", "createdAt": "2020-02-19T19:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNzg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2MzQ1NA==", "url": "https://github.com/apache/helix/pull/765#discussion_r381463454", "bodyText": "Why change this access modifier in ZkClient? This is interface change.", "author": "kaisun2000", "createdAt": "2020-02-19T18:30:54Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -636,7 +636,7 @@ public String create(final String path, Object datat, final List<ACL> acl, final\n    * @throws IllegalArgumentException if called from anything else except the ZooKeeper event thread\n    * @throws ZkException if any zookeeper exception occurs\n    */\n-  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+   public String create(final String path, final Object dataObject, final List<ACL> acl,", "originalCommit": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ3MzE4Nw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381473187", "bodyText": "@kaisun2000 This is not an interface change. This method is the base method for node creation. When I implemented it, I intentionally made it private not to allow direct call of create(CreateMode.persistent, expectedSessionId).\nI also had the question for changing it public. But here, the implementation needs to call rawZkClient.create() in DedicatedZkClient which is put in a different package. And this needs public. If we could put DedicatedZkClient in a same package with ZkClient, we don't need it public.", "author": "huizhilu", "createdAt": "2020-02-19T18:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2MzQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ3NTQ4MQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r381475481", "bodyText": "This was old code. Let me update.", "author": "narendly", "createdAt": "2020-02-19T18:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2MzQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4ODU5NQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r381488595", "bodyText": "Nit: could assign to _zkRealmAddress first and then perform the check", "author": "NealSun96", "createdAt": "2020-02-19T19:16:36Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,488 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);", "originalCommit": "b03e0da4c4e096a0e81de640f50bc7a1938e589c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwNzQ0NQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r381707445", "bodyText": "This will be removed as noted in the TODO", "author": "narendly", "createdAt": "2020-02-20T03:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4ODU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5NzAyNw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381497027", "bodyText": "This is no longer the latest TrieRoutingdata after the changes introduced in: 8c050b3 .", "author": "NealSun96", "createdAt": "2020-02-19T19:32:05Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,277 @@\n+package org.apache.helix.zookeeper.impl.factory;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * TODO: remove when there's a separate module.\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjg5OA==", "url": "https://github.com/apache/helix/pull/765#discussion_r381536898", "bodyText": "This class will be removed after the module separation. Please see the TODO.", "author": "narendly", "createdAt": "2020-02-19T20:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5NzAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxODM1Mw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381518353", "bodyText": "It seems IllegalArgumentException will be thrown for createPersistent(), and there is no check for writeData(). If we want to test writeData() as well, shall we have another validation for writeData() to be more accurate?", "author": "huizhilu", "createdAt": "2020-02-19T20:13:20Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestDedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.impl.factory.TrieRoutingData;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDedicatedZkClient extends ZkTestBase {\n+  private static final String ZK_SHARDING_KEY_PREFIX = \"/TEST_SHARDING_KEY_\";\n+  private static final String TEST_VALID_PATH = ZK_SHARDING_KEY_PREFIX + \"_\" + 0 + \"/a/b/c\";\n+  private static final String TEST_INVALID_PATH = ZK_SHARDING_KEY_PREFIX + \"_invalid\" + \"/a/b/c\";\n+\n+  // <Realm, List of sharding keys> Mapping\n+  private static final Map<String, List<String>> RAW_ROUTING_DATA = new HashMap<>();\n+\n+  private RealmAwareZkClient _realmAwareZkClient;\n+  private MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  @BeforeClass\n+  public void beforeClass()\n+      throws Exception {\n+    // Populate RAW_ROUTING_DATA\n+    for (int i = 0; i < _numZk; i++) {\n+      List<String> shardingKeyList = new ArrayList<>();\n+      shardingKeyList.add(ZK_SHARDING_KEY_PREFIX + \"_\" + i);\n+      String realmName = ZK_PREFIX + (ZK_START_PORT + i);\n+      RAW_ROUTING_DATA.put(realmName, shardingKeyList);\n+    }\n+\n+    // Feed the raw routing data into TrieRoutingData to construct an in-memory representation of routing information\n+    _metadataStoreRoutingData = new TrieRoutingData(RAW_ROUTING_DATA);\n+  }\n+\n+  /**\n+   * 1. Create a DedicatedZkClient with a non-existing sharding key (for which there is no valid ZK realm)\n+   * -> This should fail with an exception\n+   * 2. Create a DedicatedZkClient with a valid sharding key\n+   * -> This should pass\n+   */\n+  @Test\n+  public void testDedicatedZkClientCreation() {\n+    // Create a DedicatedZkClient\n+    String invalidShardingKey = \"InvalidShardingKey\";\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    // Create a connection config with the invalid sharding key\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig(invalidShardingKey);\n+\n+    try {\n+      _realmAwareZkClient = DedicatedZkClientFactory.getInstance()\n+          .buildZkClient(connectionConfig, clientConfig, _metadataStoreRoutingData);\n+      Assert.fail(\"Should not succeed with an invalid sharding key!\");\n+    } catch (IllegalArgumentException e) {\n+      // Expected\n+    }\n+\n+    // Use a valid sharding key this time around\n+    String validShardingKey = ZK_SHARDING_KEY_PREFIX + \"_\" + 0; // Use TEST_SHARDING_KEY_0\n+    connectionConfig = new RealmAwareZkClient.RealmAwareZkConnectionConfig(validShardingKey);\n+    _realmAwareZkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(connectionConfig, clientConfig, _metadataStoreRoutingData);\n+  }\n+\n+  /**\n+   * Test the persistent create() call against a valid path and an invalid path.\n+   * Valid path is one that belongs to the realm designated by the sharding key.\n+   * Invalid path is one that does not belong to the realm designated by the sharding key.\n+   */\n+  @Test(dependsOnMethods = \"testDedicatedZkClientCreation\")\n+  public void testDedicatedZkClientCreatePersistent() {\n+    _realmAwareZkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // Create a dummy ZNRecord\n+    ZNRecord znRecord = new ZNRecord(\"DummyRecord\");\n+    znRecord.setSimpleField(\"Dummy\", \"Value\");\n+\n+    // Test writing and reading against the validPath\n+    _realmAwareZkClient.createPersistent(TEST_VALID_PATH, true);\n+    _realmAwareZkClient.writeData(TEST_VALID_PATH, znRecord);\n+    Assert.assertEquals(_realmAwareZkClient.readData(TEST_VALID_PATH), znRecord);\n+\n+    // Test writing and reading against the invalid path\n+    try {\n+      _realmAwareZkClient.createPersistent(TEST_INVALID_PATH, true);\n+      _realmAwareZkClient.writeData(TEST_INVALID_PATH, znRecord);\n+      Assert.fail(\"Create() should not succeed on an invalid path!\");\n+    } catch (IllegalArgumentException e) {\n+      // Okay - expected", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTIwMw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381539203", "bodyText": "This is a test for createPersistent(). I added _realmAwareZkClient.writeData(TEST_INVALID_PATH, znRecord); for parity with the test I did for the valid path.\n_realmAwareZkClient.writeData(TEST_INVALID_PATH, znRecord); doesn't make sense anyway because the ZNode should never be created at that path.", "author": "narendly", "createdAt": "2020-02-19T20:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxODM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyNzUxOA==", "url": "https://github.com/apache/helix/pull/765#discussion_r381627518", "bodyText": "Shall we just call _rawZkClient.readData(path, returnNullIfPathNotExists), so it is easier to maintain the code because it relies on raw ZkClient, which is our initial purpose?", "author": "huizhilu", "createdAt": "2020-02-20T00:35:50Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n+      }\n+    }\n+    return data;", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyNzY1OQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r381627659", "bodyText": "Same, to call raw zkClient?", "author": "huizhilu", "createdAt": "2020-02-20T00:36:18Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n+      }\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      data = readData(path, stat);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n+      }\n+    }\n+    return data;", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyODMxNA==", "url": "https://github.com/apache/helix/pull/765#discussion_r381628314", "bodyText": "Typo? _rawZkClient.countChildren() Otherwise, a stack overflow :)", "author": "huizhilu", "createdAt": "2020-02-20T00:38:27Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return countChildren(path);", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwNzk0MA==", "url": "https://github.com/apache/helix/pull/765#discussion_r381707940", "bodyText": "Good catch!", "author": "narendly", "createdAt": "2020-02-20T03:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyODMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NDMwNA==", "url": "https://github.com/apache/helix/pull/765#discussion_r381644304", "bodyText": "create(path, null, acl, CreateMode.EPHEMERAL, sessionId); to re-use the code and minimize the code branches to reduce duplicate code and maintenance effort? For example, if we want to change the behavior, we just need to change create().\nUpdate: I didn't realize that you wanted to keep zkclient's create() private until seeing the change you made to revert public -> private. I think there are 2 options then: 1. make that private to public. 2. call its own  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId)", "author": "huizhilu", "createdAt": "2020-02-20T01:24:25Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwNzcwMw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381707703", "bodyText": "As discussed offline, we'll just leave it as is. This is to completely mimic what the raw ZkClient is doing.", "author": "narendly", "createdAt": "2020-02-20T03:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NDMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NTc0MQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r381645741", "bodyText": "Same: call its owncreate()?", "author": "huizhilu", "createdAt": "2020-02-20T01:26:49Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwNzgxNA==", "url": "https://github.com/apache/helix/pull/765#discussion_r381707814", "bodyText": "Replied above", "author": "narendly", "createdAt": "2020-02-20T03:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NTc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NTg4OQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r381645889", "bodyText": "Same: call its owncreate()?", "author": "huizhilu", "createdAt": "2020-02-20T01:27:05Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, acl, sessionId);", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwNzg1OA==", "url": "https://github.com/apache/helix/pull/765#discussion_r381707858", "bodyText": "Replied above", "author": "narendly", "createdAt": "2020-02-20T03:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NTg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY4NjMwMg==", "url": "https://github.com/apache/helix/pull/765#discussion_r381686302", "bodyText": "Nit, it seems each time concatenating the path, underscore is added and so the paths would be /TEST_SHARDING_KEY__0/a/b, which does not affect the results but it may not be what you wanted to have in comment?\nString validShardingKey = ZK_SHARDING_KEY_PREFIX + \"_\" + 0; // Use TEST_SHARDING_KEY_0", "author": "huizhilu", "createdAt": "2020-02-20T02:39:45Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestDedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.impl.factory.TrieRoutingData;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDedicatedZkClient extends ZkTestBase {\n+  private static final String ZK_SHARDING_KEY_PREFIX = \"/TEST_SHARDING_KEY_\";", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwNjgwMw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381706803", "bodyText": "Fixed.", "author": "narendly", "createdAt": "2020-02-20T03:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY4NjMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY5ODgxMg==", "url": "https://github.com/apache/helix/pull/765#discussion_r381698812", "bodyText": "Current ZkTestBase in helix-core is occupying this port. If we run the tests in the whole project and port 2183 is already occupied by ZK started by helix-core, can we still start a ZK at this port 2183? If not, we may want to use another port.", "author": "huizhilu", "createdAt": "2020-02-20T03:03:55Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/ZkTestBase.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.management.MBeanServerConnection;\n+import javax.management.ObjectName;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.helix.zookeeper.zkclient.IDefaultNameSpace;\n+import org.apache.helix.zookeeper.zkclient.ZkServer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeSuite;\n+\n+\n+/**\n+ * Test base class for various integration tests with an in-memory ZooKeeper.\n+ */\n+public class ZkTestBase {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkTestBase.class);\n+  private static final MBeanServerConnection MBEAN_SERVER =\n+      ManagementFactory.getPlatformMBeanServer();\n+\n+  // maven surefire-plugin's multiple ZK config keys\n+  private static final String MULTI_ZK_PROPERTY_KEY = \"multiZk\";\n+  private static final String NUM_ZK_PROPERTY_KEY = \"numZk\";\n+\n+  protected static final String ZK_PREFIX = \"localhost:\";\n+  protected static final int ZK_START_PORT = 2183;", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwNzE4Mw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381707183", "bodyText": "Changed it to a different port.", "author": "narendly", "createdAt": "2020-02-20T03:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY5ODgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgxNDE4Ng==", "url": "https://github.com/apache/helix/pull/765#discussion_r381814186", "bodyText": "Double checked to verify my concern is valid. I think if we don't change the port, this zk could not be started at this port, because testng.xml in helix-core includes all helix packages: <package name=\"org.apache.helix.*\"/>\nI think there are 3 options to solve this:\n\nchange the port to use a different one -- OK. but could create more zk servers during the tests.\nif the port is already occupied by a running zk, we don't assert fail it but use current zk. -- Not that good. Could not get the zk server reference.\nexclude zookeeper and also rest module in helix-core's testng.xml so all ZK servers would be shut down after all helix-core's tests. So zookeeper module can create its own ZK servers on the port 2183. -- I prefer this one so we don't create more zk servers during the tests. Cons: it takes time when restarting zk servers.", "author": "huizhilu", "createdAt": "2020-02-20T07:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY5ODgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgxOTM1Nw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381819357", "bodyText": "Changed the port so this is no longer a concern.", "author": "narendly", "createdAt": "2020-02-20T07:16:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY5ODgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwMDY3Ng==", "url": "https://github.com/apache/helix/pull/765#discussion_r381700676", "bodyText": "Nit, Do you want it to be public or private? If private, no need to add the space.", "author": "huizhilu", "createdAt": "2020-02-20T03:07:39Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -636,7 +636,7 @@ public String create(final String path, Object datat, final List<ACL> acl, final\n    * @throws IllegalArgumentException if called from anything else except the ZooKeeper event thread\n    * @throws ZkException if any zookeeper exception occurs\n    */\n-  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+   private String create(final String path, final Object dataObject, final List<ACL> acl,", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwNjc0Nw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381706747", "bodyText": "Fixed", "author": "narendly", "createdAt": "2020-02-20T03:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwMDY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwODEwMw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381708103", "bodyText": "Is this client supposed to be close after class?", "author": "huizhilu", "createdAt": "2020-02-20T03:22:21Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestDedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.impl.factory.TrieRoutingData;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDedicatedZkClient extends ZkTestBase {\n+  private static final String ZK_SHARDING_KEY_PREFIX = \"/TEST_SHARDING_KEY_\";\n+  private static final String TEST_VALID_PATH = ZK_SHARDING_KEY_PREFIX + \"_\" + 0 + \"/a/b/c\";\n+  private static final String TEST_INVALID_PATH = ZK_SHARDING_KEY_PREFIX + \"_invalid\" + \"/a/b/c\";\n+\n+  // <Realm, List of sharding keys> Mapping\n+  private static final Map<String, List<String>> RAW_ROUTING_DATA = new HashMap<>();\n+\n+  private RealmAwareZkClient _realmAwareZkClient;\n+  private MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  @BeforeClass\n+  public void beforeClass()\n+      throws Exception {\n+    // Populate RAW_ROUTING_DATA\n+    for (int i = 0; i < _numZk; i++) {\n+      List<String> shardingKeyList = new ArrayList<>();\n+      shardingKeyList.add(ZK_SHARDING_KEY_PREFIX + \"_\" + i);\n+      String realmName = ZK_PREFIX + (ZK_START_PORT + i);\n+      RAW_ROUTING_DATA.put(realmName, shardingKeyList);\n+    }\n+\n+    // Feed the raw routing data into TrieRoutingData to construct an in-memory representation of routing information\n+    _metadataStoreRoutingData = new TrieRoutingData(RAW_ROUTING_DATA);\n+  }\n+\n+  /**\n+   * 1. Create a DedicatedZkClient with a non-existing sharding key (for which there is no valid ZK realm)\n+   * -> This should fail with an exception\n+   * 2. Create a DedicatedZkClient with a valid sharding key\n+   * -> This should pass\n+   */\n+  @Test\n+  public void testDedicatedZkClientCreation() {\n+    // Create a DedicatedZkClient\n+    String invalidShardingKey = \"InvalidShardingKey\";\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    // Create a connection config with the invalid sharding key\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig(invalidShardingKey);\n+\n+    try {\n+      _realmAwareZkClient = DedicatedZkClientFactory.getInstance()\n+          .buildZkClient(connectionConfig, clientConfig, _metadataStoreRoutingData);\n+      Assert.fail(\"Should not succeed with an invalid sharding key!\");\n+    } catch (IllegalArgumentException e) {\n+      // Expected\n+    }\n+\n+    // Use a valid sharding key this time around\n+    String validShardingKey = ZK_SHARDING_KEY_PREFIX + \"_\" + 0; // Use TEST_SHARDING_KEY_0\n+    connectionConfig = new RealmAwareZkClient.RealmAwareZkConnectionConfig(validShardingKey);\n+    _realmAwareZkClient = DedicatedZkClientFactory.getInstance()", "originalCommit": "3b80fec1b63590eae1d1d262d27249e7d959e488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwOTc4Ng==", "url": "https://github.com/apache/helix/pull/765#discussion_r381709786", "bodyText": "Yes. Will close.", "author": "narendly", "createdAt": "2020-02-20T03:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwODEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzMzc4MA==", "url": "https://github.com/apache/helix/pull/765#discussion_r381833780", "bodyText": "Since checkIfPathContainsShardingKey() is critical, can we add a test to cover this: valid path and all invalid path cases?", "author": "huizhilu", "createdAt": "2020-02-20T07:57:20Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestDedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.impl.factory.TrieRoutingData;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDedicatedZkClient extends ZkTestBase {", "originalCommit": "2f01c9937c2133af6b6bb57bc1bae1cc66308465", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2NzI2NA==", "url": "https://github.com/apache/helix/pull/765#discussion_r382167264", "bodyText": "We will be using MetadataStoreRoutingData (the trie-like data structure) for that check. We have test coverage on this component already, so we won't need to test here again.", "author": "narendly", "createdAt": "2020-02-20T18:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzMzc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzNDcxMw==", "url": "https://github.com/apache/helix/pull/765#discussion_r381834713", "bodyText": "If sharding key is /abcde, are these paths expected to pass this check and supposed to use this zkclient:\n\n/abcde_0/xxx\n/abcde/abcde-0/xxx", "author": "huizhilu", "createdAt": "2020-02-20T07:59:38Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,465 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readData(path, returnNullIfPathNotExists);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readDataAndStat(path, stat, returnNullIfPathNotExists);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object object) {\n+    writeData(path, object, -1);\n+  }\n+\n+  @Override\n+  public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.updateDataSerialized(path, updater);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object datat, int expectedVersion) {\n+    writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n+    return writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,\n+      ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.asyncCreate(path, datat, mode, cb);\n+  }\n+\n+  @Override\n+  public void asyncSetData(String path, Object datat, int version,\n+      ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.asyncSetData(path, datat, version, cb);\n+  }\n+\n+  @Override\n+  public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.asyncGetData(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.asyncExists(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.asyncDelete(path, cb);\n+  }\n+\n+  @Override\n+  public void watchForData(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.watchForData(path);\n+  }\n+\n+  @Override\n+  public List<String> watchForChilds(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.watchForChilds(path);\n+  }\n+\n+  @Override\n+  public long getCreationTime(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getCreationTime(path);\n+  }\n+\n+  @Override\n+  public List<OpResult> multi(Iterable<Op> ops) {\n+    return _rawZkClient.multi(ops);\n+  }\n+\n+  @Override\n+  public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    return _rawZkClient.waitUntilConnected(time, timeUnit);\n+  }\n+\n+  @Override\n+  public String getServers() {\n+    return _rawZkClient.getServers();\n+  }\n+\n+  @Override\n+  public long getSessionId() {\n+    return _rawZkClient.getSessionId();\n+  }\n+\n+  @Override\n+  public void close() {\n+    _rawZkClient.close();\n+  }\n+\n+  @Override\n+  public boolean isClosed() {\n+    return _rawZkClient.isClosed();\n+  }\n+\n+  @Override\n+  public byte[] serialize(Object data, String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.serialize(data, path);\n+  }\n+\n+  @Override\n+  public <T> T deserialize(byte[] data, String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.deserialize(data, path);\n+  }\n+\n+  @Override\n+  public void setZkSerializer(ZkSerializer zkSerializer) {\n+    _rawZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n+    _rawZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public PathBasedZkSerializer getZkSerializer() {\n+    return _rawZkClient.getZkSerializer();\n+  }\n+\n+  /**\n+   * Checks whether the given path belongs matches the ZK path sharding key this DedicatedZkClient is designated to at initialization.\n+   * @param path\n+   * @return\n+   */\n+  private void checkIfPathContainsShardingKey(String path) {\n+    if (!path.startsWith(_zkRealmShardingKey)) {", "originalCommit": "2f01c9937c2133af6b6bb57bc1bae1cc66308465", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2NTk2Nw==", "url": "https://github.com/apache/helix/pull/765#discussion_r382165967", "bodyText": "Good catch - will fix this up. @kaisun2000 Because of this, I think it's better to use the Metadata Store Routing Data here (TrieRoutingData).\nI'll add a TODO here because we don't have the module separated yet.", "author": "narendly", "createdAt": "2020-02-20T18:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzNDcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIxNDkxOQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r382214919", "bodyText": "There are other possible way to fix it and reason it would work.\nFor example the prefix must be normalized to end with \"/\" before the match against input.\nEither way, this implementation detail can be fix later.", "author": "kaisun2000", "createdAt": "2020-02-20T19:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzNDcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1NTgwOQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r382255809", "bodyText": "We don't have all the components implemented to make this work yet.\n@kaisun2000\n\nFor example the prefix must be normalized to end with \"/\" before the match against input.\n\nThis may not be necessary since we'll have the trie-like routing data already. That way, we don't implement another line of the check logic and we are able to re-use a tested component.\nAt any rate, I'll put a TODO and let's revisit this method when we have all the components ready.", "author": "narendly", "createdAt": "2020-02-20T21:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzNDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIxMDExOQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r382210119", "bodyText": "Nit. We can provide a default implementation of this one. The default implementation would call the above one by constructing an default  RealmAwareZkClient.RealmAwareZkClientConfig.", "author": "kaisun2000", "createdAt": "2020-02-20T19:27:58Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/factory/RealmAwareZkClientFactory.java", "diffHunk": "@@ -30,16 +31,21 @@\n    * Build a RealmAwareZkClient using specified connection config and client config.\n    * @param connectionConfig\n    * @param clientConfig\n+   * @param metadataStoreRoutingData\n    * @return HelixZkClient\n    */\n+  // TODO: remove MetadataStoreRoutingData\n   RealmAwareZkClient buildZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n-      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig);\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData);\n \n   /**\n    * Builds a RealmAwareZkClient using specified connection config and default client config.\n    * @param connectionConfig\n+   * @param metadataStoreRoutingData\n    * @return RealmAwareZkClient\n    */\n-  RealmAwareZkClient buildZkClient(\n-      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig);\n+  // TODO: remove MetadataStoreRoutingData\n+  RealmAwareZkClient buildZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,", "originalCommit": "2221562ffc5eb4742e91c584f887661461ffb7c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1NDY0MQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r382254641", "bodyText": "Added the default implementation.", "author": "narendly", "createdAt": "2020-02-20T20:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIxMDExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIxODE0Ng==", "url": "https://github.com/apache/helix/pull/765#discussion_r382218146", "bodyText": "There is ZkTestBase in Helix common before. So what is the strategy here.\n1/ Are we going to remove that ZkTestBase from Helix common and associated test?\n2/ Move ZkTestBase in Helix common and associated test here?\n3/ Have two ZKTestBase s and their related test in parallel?", "author": "kaisun2000", "createdAt": "2020-02-20T19:43:01Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/ZkTestBase.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.apache.helix.zookeeper.impl;", "originalCommit": "2221562ffc5eb4742e91c584f887661461ffb7c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1MzM5Ng==", "url": "https://github.com/apache/helix/pull/765#discussion_r382253396", "bodyText": "No, this is a ZkTestBase for zookeeper-api module. The name of the class is the same, but it does different things.\nNo.\nYes. zookeeper-api needs to have tests and this ZkTestBase contains the ZK environment setup logic.", "author": "narendly", "createdAt": "2020-02-20T20:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIxODE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MDUxOQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r382290519", "bodyText": "As a general comment. As we took the approach to composition (aka create new class DedicatedZkClient), theoretically, it would be ideal to test the new method even it is a thin wrapper.\nIf we choose the approach of modifying the ZKClient, since the code is not change, we can reason that limiting our testing to only the modified part, namely the checkingPath validity part would be enough.\nConsidering composition is only a thin wrapper, I don't see the necessity to do it right now. However, later if we change the code of DedicatedZkClient implementation more, we should add more test then.", "author": "kaisun2000", "createdAt": "2020-02-20T22:20:10Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/RealmAwareZkClientTestBase.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.apache.helix.zookeeper.impl.client;", "originalCommit": "b6b6a6ec2b1ee8d961c857e8fcbfeea888611236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NDk5NA==", "url": "https://github.com/apache/helix/pull/765#discussion_r382294994", "bodyText": "Do you think you'd be able to help with enhancing the tests to our RealmAwareZkClientTestBase.java after SharedZkClient is complete? @kaisun2000", "author": "narendly", "createdAt": "2020-02-20T22:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyODc1NA==", "url": "https://github.com/apache/helix/pull/765#discussion_r382328754", "bodyText": "Discussed offline; @kaisun2000  to add more test cases for SharedZkClient (regarding ephemeral node cases).", "author": "narendly", "createdAt": "2020-02-21T00:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MzIyMQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r382293221", "bodyText": "This is same class as helix-core, right? Since helix-core refers this module, can we remove the test base in the core?", "author": "junkaixue", "createdAt": "2020-02-20T22:26:38Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/ZkTestBase.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.apache.helix.zookeeper.impl;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.management.MBeanServerConnection;\n+import javax.management.ObjectName;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.helix.zookeeper.zkclient.IDefaultNameSpace;\n+import org.apache.helix.zookeeper.zkclient.ZkServer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeSuite;\n+\n+\n+/**\n+ * Test base class for various integration tests with an in-memory ZooKeeper.\n+ */\n+public class ZkTestBase {", "originalCommit": "b6b6a6ec2b1ee8d961c857e8fcbfeea888611236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NTM4Mw==", "url": "https://github.com/apache/helix/pull/765#discussion_r382295383", "bodyText": "@dasahcc\ntheir names are the same but these are two different test bases.\nhelix-core's TestBase contains a lot of Helix logic. this ZkTestBase is only for zookeeper-related tests and therefore has no Helix-related logic.\nIn short, we shouldn't remove the test base in the core.", "author": "narendly", "createdAt": "2020-02-20T22:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MzIyMQ=="}], "type": "inlineReview"}, {"oid": "b2661825aa94cd1465763201eaf6172bf4bbd5e6", "url": "https://github.com/apache/helix/commit/b2661825aa94cd1465763201eaf6172bf4bbd5e6", "message": "WIP: Add DedicatedZkClient and update DedicatedZkClientFactory", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "9c86d1d148d4a45c250915756de6cb7c53e6366b", "url": "https://github.com/apache/helix/commit/9c86d1d148d4a45c250915756de6cb7c53e6366b", "message": "Add Javadoc", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "673a9754d05d61387b3b9f880f22282f924ed375", "url": "https://github.com/apache/helix/commit/673a9754d05d61387b3b9f880f22282f924ed375", "message": "Fix", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "bcff9fc8e903227ce548951e82f551d8c9a55dba", "url": "https://github.com/apache/helix/commit/bcff9fc8e903227ce548951e82f551d8c9a55dba", "message": "Add MetadataStoreRoutingData temporarily", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "b132cf30a6c804a90d53d70aec40707c43021fc8", "url": "https://github.com/apache/helix/commit/b132cf30a6c804a90d53d70aec40707c43021fc8", "message": "Add tests", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "19326d32ee50faac686e4e4d3b24ade3a2d23d31", "url": "https://github.com/apache/helix/commit/19326d32ee50faac686e4e4d3b24ade3a2d23d31", "message": "Just do a sharding key check", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "c2195260328d7afb018c75658ef88debe35e95eb", "url": "https://github.com/apache/helix/commit/c2195260328d7afb018c75658ef88debe35e95eb", "message": "Update and address comments", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "29a16eb34f0a4ec45b65b4cf7acdff8756153c88", "url": "https://github.com/apache/helix/commit/29a16eb34f0a4ec45b65b4cf7acdff8756153c88", "message": "Add Javadoc", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "9629737e60e5f2f2a710747db082bf8b76dca29b", "url": "https://github.com/apache/helix/commit/9629737e60e5f2f2a710747db082bf8b76dca29b", "message": "address comments", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "ad1d251de83a66072cd9cd87ea2b5c2606a155df", "url": "https://github.com/apache/helix/commit/ad1d251de83a66072cd9cd87ea2b5c2606a155df", "message": "Update tests", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "7345f8a3a243ec3bf2019c706c6dbccef92de801", "url": "https://github.com/apache/helix/commit/7345f8a3a243ec3bf2019c706c6dbccef92de801", "message": "Update", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "c4535ed69f491816efe4997110cdfc4a26178317", "url": "https://github.com/apache/helix/commit/c4535ed69f491816efe4997110cdfc4a26178317", "message": "asdf", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "16940e2c0adcee53f8d1e9dc03b68db65afd8d65", "url": "https://github.com/apache/helix/commit/16940e2c0adcee53f8d1e9dc03b68db65afd8d65", "message": "Fix'\ngit", "committedDate": "2020-02-21T00:07:15Z", "type": "commit"}, {"oid": "f8ed4a63d927f3859a99cef3126c6ae5e9403c9c", "url": "https://github.com/apache/helix/commit/f8ed4a63d927f3859a99cef3126c6ae5e9403c9c", "message": "Rebase onto apache zooscalability", "committedDate": "2020-02-21T00:13:16Z", "type": "commit"}, {"oid": "f8ed4a63d927f3859a99cef3126c6ae5e9403c9c", "url": "https://github.com/apache/helix/commit/f8ed4a63d927f3859a99cef3126c6ae5e9403c9c", "message": "Rebase onto apache zooscalability", "committedDate": "2020-02-21T00:13:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYxNzIyNQ==", "url": "https://github.com/apache/helix/pull/765#discussion_r383617225", "bodyText": "checkIfPathContainsShardingKey(path); _rawZkClient.createPersistent(path, createParents); \nDelegate to other public API is anti-pattern of composition and delegation or sometime called PIMPL in C++ world. It make harder to reason if this is keeping the _rawZkClient's behavior or not. In fact, if later _rawZkClient implementation is changed, you may have unexpected behavior.\nThere are other places like this.", "author": "kaisun2000", "createdAt": "2020-02-25T01:51:47Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,473 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);", "originalCommit": "f8ed4a63d927f3859a99cef3126c6ae5e9403c9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}