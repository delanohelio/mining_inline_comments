{"pr_number": 789, "pr_title": "Add FederatedZkClient", "pr_createdAt": "2020-02-20T22:26:03Z", "pr_url": "https://github.com/apache/helix/pull/789", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NDEzOQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r382294139", "bodyText": "Let's try to have changes like this in a separate PR. Or you could create an issue and we could batch process them later.", "author": "narendly", "createdAt": "2020-02-20T22:28:37Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -65,6 +66,11 @@ private void postConstruct() {\n     buildMetadataStoreDirectory(_namespace, helixRestNamespace.getMetadataStoreAddress());\n   }\n \n+  @PreDestroy", "originalCommit": "0657a6c5c083b74941f821cc482f3bdcef22d808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NzQ3OA==", "url": "https://github.com/apache/helix/pull/789#discussion_r382297478", "bodyText": "Forgot to remove it. Not supposed to include it.", "author": "huizhilu", "createdAt": "2020-02-20T22:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NDEzOQ=="}], "type": "inlineReview"}, {"oid": "d7667b3ac39e303ea56d400cee03513ebcedb9c1", "url": "https://github.com/apache/helix/commit/d7667b3ac39e303ea56d400cee03513ebcedb9c1", "message": "Add FederatedZkClient.", "committedDate": "2020-02-20T22:38:20Z", "type": "forcePushed"}, {"oid": "ebdb7b631e4b693c9a938138ba88582786db7bcc", "url": "https://github.com/apache/helix/commit/ebdb7b631e4b693c9a938138ba88582786db7bcc", "message": "Add FederatedZkClient.", "committedDate": "2020-02-20T22:41:02Z", "type": "forcePushed"}, {"oid": "0abb6dfd8a5e74b2234029d31ccb219bc98d16d3", "url": "https://github.com/apache/helix/commit/0abb6dfd8a5e74b2234029d31ccb219bc98d16d3", "message": "Add FederatedZkClient.", "committedDate": "2020-02-21T01:19:35Z", "type": "forcePushed"}, {"oid": "54e5b5ace21e0ad807e14c2094672d2824dbc901", "url": "https://github.com/apache/helix/commit/54e5b5ace21e0ad807e14c2094672d2824dbc901", "message": "Add FederatedZkClient.", "committedDate": "2020-02-21T01:42:49Z", "type": "forcePushed"}, {"oid": "33b6d21115de8abc8038384d717b563c74ae8c63", "url": "https://github.com/apache/helix/commit/33b6d21115de8abc8038384d717b563c74ae8c63", "message": "Add FederatedZkClient.", "committedDate": "2020-02-21T02:43:40Z", "type": "forcePushed"}, {"oid": "10929a3ab4124beea4fdae7aa88e0501c159c0fb", "url": "https://github.com/apache/helix/commit/10929a3ab4124beea4fdae7aa88e0501c159c0fb", "message": "Add FederatedZkClient.", "committedDate": "2020-02-21T08:11:31Z", "type": "commit"}, {"oid": "10929a3ab4124beea4fdae7aa88e0501c159c0fb", "url": "https://github.com/apache/helix/commit/10929a3ab4124beea4fdae7aa88e0501c159c0fb", "message": "Add FederatedZkClient.", "committedDate": "2020-02-21T08:11:31Z", "type": "forcePushed"}, {"oid": "19cb6d10d71e204193305f85fe4ed59aca4eebc3", "url": "https://github.com/apache/helix/commit/19cb6d10d71e204193305f85fe4ed59aca4eebc3", "message": "Polish close()", "committedDate": "2020-02-21T08:32:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2ODY1MA==", "url": "https://github.com/apache/helix/pull/789#discussion_r382868650", "bodyText": "We will remove this metadata store routing data in param once http routing data reader is ready.", "author": "huizhilu", "createdAt": "2020-02-22T00:54:59Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,486 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {", "originalCommit": "19cb6d10d71e204193305f85fe4ed59aca4eebc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNjY5Ng==", "url": "https://github.com/apache/helix/pull/789#discussion_r382936696", "bodyText": "Nit: Should we tell people to use DedicatdZkClient instead of DedicatedZkClientFactory?", "author": "narendly", "createdAt": "2020-02-22T19:47:45Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,486 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;\n+    try {\n+      zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+    } catch (NoSuchElementException ex) {\n+      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    }\n+\n+    if (zkRealm == null || zkRealm.isEmpty()) {\n+      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    }\n+\n+    return zkRealm;\n+  }\n+\n+  private ZkClient createZkClient(String zkAddress) {\n+    LOG.debug(\"Creating ZkClient for realm: {}.\", zkAddress);\n+    return new ZkClient(new ZkConnection(zkAddress), (int) _clientConfig.getConnectInitTimeout(),\n+        _clientConfig.getOperationRetryTimeout(), _pathBasedZkSerializer,\n+        _clientConfig.getMonitorType(), _clientConfig.getMonitorKey(),\n+        _clientConfig.getMonitorInstanceName(), _clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  private void throwUnsupportedOperationException() {\n+    throw new UnsupportedOperationException(\n+        \"Session-aware operation is not supported by \" + FEDERATED_ZK_CLIENT\n+            + \". Instead, please use \" + DEDICATED_ZK_CLIENT_FACTORY + \" for this operation\");", "originalCommit": "19cb6d10d71e204193305f85fe4ed59aca4eebc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MTYyMg==", "url": "https://github.com/apache/helix/pull/789#discussion_r382951622", "bodyText": "DedicatedZkClientFactory is what we provide and recommend users to create a RealmAwareZkClient which is a DedicatedZkClient instance. DedicatedZkClient  is protected and we don't want users to directly use it, right?", "author": "huizhilu", "createdAt": "2020-02-23T00:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNjY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NDE0MQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r382954141", "bodyText": "I see what you're saying, but the way it's phrased here may confuse users.\nSay this:\n\"Instead, please use DedicatedZkClientFactory to create an instance of dedicated RealmAwareZkClient for ephemeral operations\".\nThis is because we don't use the factory for ephemeral operations.", "author": "narendly", "createdAt": "2020-02-23T01:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNjY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNzI2Mg==", "url": "https://github.com/apache/helix/pull/789#discussion_r382937262", "bodyText": "Great job on writing tests cases to cover all unsupported operations! This test looks great.\nOne more test case if I may suggest adding for FederatedZkClient is doing two writes to two different paths (path A and path B) where the two paths map to different ZK realms.\nFirst, instrument the MetadataStoreRoutingData so that paths A and B have sharding keys that map to two different ZK realms. Then use the same FederatedZkClient to write to paths A and B.\nThen create two single-realm ZkClients connected to the two realms respectively, and check that the data/ZNode you wrote to path A is in one ZK realm and not in the other, and vice versa.\nDo you think that would be a good test case that tests FederatedZkClient's multi-realm functionality? :)", "author": "narendly", "createdAt": "2020-02-22T19:56:07Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestFederatedZkClient.java", "diffHunk": "@@ -0,0 +1,252 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestFederatedZkClient extends ZkTestBase {", "originalCommit": "19cb6d10d71e204193305f85fe4ed59aca4eebc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzODE4MQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r382938181", "bodyText": "This is correct. We would definitely need this test to very it is actual a multi realm client. I\u2019ve considered it and it is in progress. Because in the previous version there is only one zk server running, I could not  run multi realms. I was planning to start a zk server just for this test but was waiting to see if we want to start one more zk in zk tests base. I will push a test. Thanks for the review and suggestion!", "author": "huizhilu", "createdAt": "2020-02-22T20:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzODY4OQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r382938689", "bodyText": "@pkuwm\nOur ZkTestBase already starts multiple ZKs and you could reference them in _zkServerMap :)\nYou could look in our pom.xml file and search for \"multiZk\" keyword. I believe I have it set at 3. And you could use a protected variable _numZk to check how many ZKs have been started. That should make writing a test case for this much easier (start by doing a check - if (_numZk > 1) )", "author": "narendly", "createdAt": "2020-02-22T20:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MTUzNg==", "url": "https://github.com/apache/helix/pull/789#discussion_r382951536", "bodyText": "@narendly I've noticed that multi-zk execution is included in pom. But actually I not clear why we are running two times of tests. And actually in Intellij the test runs the default-tests but not multi-zk (maybe I need to config my Intellij).\nAnyway, I've added a test for multi realm.", "author": "huizhilu", "createdAt": "2020-02-23T00:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1Mzk0MQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r382953941", "bodyText": "I don't think IntelliJ supports this - you could run it in command line with maven directly. That way, it will execute twice.", "author": "narendly", "createdAt": "2020-02-23T00:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NTkxMA==", "url": "https://github.com/apache/helix/pull/789#discussion_r382955910", "bodyText": "if (_numZk > 1) to check multi-zk env in each multi-realm test doesn't look natural to me: I can't make my test successful in Intellij but have to use maven. Why can we not just keep one execution which just initially starts multi ZK? Does it hurt the default tests which don't need multi-zk env? (maybe we can sync offline as it is not mainly related to this PR.)", "author": "huizhilu", "createdAt": "2020-02-23T01:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NzA5Mw==", "url": "https://github.com/apache/helix/pull/789#discussion_r382957093", "bodyText": "We could make an exception to tests written for ZkClient APIs, but in general, we want to run all tests in two environments: single-realm and multi-realm.\nIf we only keep one execution with multiple ZKs, then we lose test coverage for the single-realm case.", "author": "narendly", "createdAt": "2020-02-23T02:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNzI2Mg=="}], "type": "inlineReview"}, {"oid": "d0395a77e2e6feae854278253737470e48266896", "url": "https://github.com/apache/helix/commit/d0395a77e2e6feae854278253737470e48266896", "message": "Test multi realm", "committedDate": "2020-02-23T00:00:16Z", "type": "forcePushed"}, {"oid": "8c73e3baf79bb5869626a93e023a830fc1b67305", "url": "https://github.com/apache/helix/commit/8c73e3baf79bb5869626a93e023a830fc1b67305", "message": "Test multi realm", "committedDate": "2020-02-23T00:12:17Z", "type": "forcePushed"}, {"oid": "f8ebe9d1e38fca6c95a568448a290ad8f6b0f944", "url": "https://github.com/apache/helix/commit/f8ebe9d1e38fca6c95a568448a290ad8f6b0f944", "message": "Test multi realm", "committedDate": "2020-02-23T00:23:51Z", "type": "forcePushed"}, {"oid": "f5c0213723dc88e8d14061a886ea6fbc72b3ddec", "url": "https://github.com/apache/helix/commit/f5c0213723dc88e8d14061a886ea6fbc72b3ddec", "message": "Test multi realm", "committedDate": "2020-02-23T00:28:30Z", "type": "commit"}, {"oid": "f5c0213723dc88e8d14061a886ea6fbc72b3ddec", "url": "https://github.com/apache/helix/commit/f5c0213723dc88e8d14061a886ea6fbc72b3ddec", "message": "Test multi realm", "committedDate": "2020-02-23T00:28:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NDA3NA==", "url": "https://github.com/apache/helix/pull/789#discussion_r382954074", "bodyText": "This is not necessary when the tests are being run by maven's surefire-plugin (what runs your mvn test's). Writing this block of code would be just for IntelliJ, so I wouldn't bother creating logic like this in your future tests.\nYou can have 2 or more ZKs in your tests, but we have two runs for a reason - we want to test it in a single ZK environment and also test it in a multi-ZK environment.", "author": "narendly", "createdAt": "2020-02-23T01:02:10Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestFederatedZkClient.java", "diffHunk": "@@ -0,0 +1,310 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.ZkServer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestFederatedZkClient extends ZkTestBase {\n+  private static final String TEST_SHARDING_KEY_PREFIX = \"/test_sharding_key_\";\n+  private static final String TEST_REALM_ONE_VALID_PATH = TEST_SHARDING_KEY_PREFIX + \"1/a/b/c\";\n+  private static final String TEST_REALM_TWO_VALID_PATH = TEST_SHARDING_KEY_PREFIX + \"2/x/y/z\";\n+  private static final String TEST_INVALID_PATH = TEST_SHARDING_KEY_PREFIX + \"invalid/a/b/c\";\n+  private static final String UNSUPPORTED_OPERATION_MESSAGE =\n+      \"Session-aware operation is not supported by FederatedZkClient.\";\n+\n+  private RealmAwareZkClient _realmAwareZkClient;\n+  // Need to start an extra ZK server for multi-realm test, if only one ZK server is running.\n+  private String _extraZkRealm;\n+  private ZkServer _extraZkServer;\n+\n+  @BeforeClass\n+  public void beforeClass() throws InvalidRoutingDataException {\n+    System.out.println(\"Starting \" + TestFederatedZkClient.class.getSimpleName());\n+\n+    // Populate rawRoutingData\n+    // <Realm, List of sharding keys> Mapping\n+    Map<String, List<String>> rawRoutingData = new HashMap<>();\n+    for (int i = 0; i < _numZk; i++) {\n+      List<String> shardingKeyList = Collections.singletonList(TEST_SHARDING_KEY_PREFIX + (i + 1));\n+      String realmName = ZK_PREFIX + (ZK_START_PORT + i);\n+      rawRoutingData.put(realmName, shardingKeyList);\n+    }\n+\n+    if (rawRoutingData.size() < 2) {\n+      System.out.println(\"There is only one ZK realm. Starting one more ZK to test multi-realm.\");\n+      _extraZkRealm = ZK_PREFIX + (ZK_START_PORT + 1);\n+      _extraZkServer = startZkServer(_extraZkRealm);\n+      // RealmTwo's sharding key: /test_sharding_key_2\n+      List<String> shardingKeyList = Collections.singletonList(TEST_SHARDING_KEY_PREFIX + \"2\");\n+      rawRoutingData.put(_extraZkRealm, shardingKeyList);\n+    }", "originalCommit": "f5c0213723dc88e8d14061a886ea6fbc72b3ddec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NjExNQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r382956115", "bodyText": "Same reply above.", "author": "huizhilu", "createdAt": "2020-02-23T01:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NDA3NA=="}], "type": "inlineReview"}, {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "url": "https://github.com/apache/helix/commit/05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "message": "Make _numZk static", "committedDate": "2020-02-23T02:03:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NDMzNQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r382294335", "bodyText": "Could the _metadataStoreDirectory to be null?", "author": "junkaixue", "createdAt": "2020-02-20T22:29:04Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -65,6 +66,11 @@ private void postConstruct() {\n     buildMetadataStoreDirectory(_namespace, helixRestNamespace.getMetadataStoreAddress());\n   }\n \n+  @PreDestroy\n+  private void preDestroy() {\n+    _metadataStoreDirectory.close();", "originalCommit": "0657a6c5c083b74941f821cc482f3bdcef22d808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MDMzMw==", "url": "https://github.com/apache/helix/pull/789#discussion_r384160333", "bodyText": "initialize this variable.\nmaybe to null?", "author": "kaisun2000", "createdAt": "2020-02-25T22:17:19Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;", "originalCommit": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NTM4MQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384195381", "bodyText": "It's null by default", "author": "narendly", "createdAt": "2020-02-25T23:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MDMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MDA4OQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384290089", "bodyText": "Initializing it with null is redundant.", "author": "huizhilu", "createdAt": "2020-02-26T06:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MDMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzMjM3OQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r385432379", "bodyText": "Up to you. If I were you, I would initialize it to null, easy for readers and easy to reason", "author": "kaisun2000", "createdAt": "2020-02-27T23:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MDMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUyMTQ3Mw==", "url": "https://github.com/apache/helix/pull/789#discussion_r385521473", "bodyText": "Like I said, it would be redundant here because there are only 2 possibilities:\n\nit is assigned a value: zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\nor an exception is thrown. So an uninitialized zkRealm would NOT happen or be used.\n\nthrow new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n\nIt must be be initialized in below case:\nString zkRealm;\ntry {\n       zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\nThis conversation was marked as resolved by pkuwm  Show conversation\n} catch (NoSuchElementException ex) {\n       // throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n       LOG.error();\n}\n// It may not have been initialized if exception is thrown.\nSystem.out.println(zkRealm);", "author": "huizhilu", "createdAt": "2020-02-28T06:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MDMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjI3NA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384162274", "bodyText": "concurrentMap, we should use  PutIfAbsent(), no need to reinvent the wheel, which may not be right.\nSee here. https://stackoverflow.com/questions/10743622/concurrenthashmap-avoid-extra-object-creation-with-putifabsent", "author": "kaisun2000", "createdAt": "2020-02-25T22:21:36Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {", "originalCommit": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwNzQ0Nw==", "url": "https://github.com/apache/helix/pull/789#discussion_r384307447", "bodyText": "@kaisun2000 Thanks for the suggestion. I am glad we got to this point.\n\nDid you mean putIfAbsent(zkRealm, createZkClient(zkRealm))? I did thought about it. However, it actually does not satisfy my expectation. putIfAbsent(zkRealm, createZkClient(zkRealm)) runs createZkClient(zkRealm) every time, no matter if zkRealm presents or not. As you already know, creating a zkclient costs a lot of overhead: creating native zk instance, zk event thread, wait until connected, etc.. We definitely don't want to create a zkclient every time even one is already available, right?\nThen is there another API that could solve the pain we have above so no new zkclient is created if there is already one? Yes, that is computeIfAbsent(). We can make one time init and get() together as clean as map.computeIfAbsent(zkRealm, zkclient -> createZkClient()). This looks pretty good, right? But my only concern is that the get performance of computeIfAbsent() is not as good as simply a get(zkRealm). Because internally in ConcurrentHashMap's implementation, computeIfAbsent() always synchronized the node/table, while get() directly reads the transient volatile table without synchonized/lock, which has a better performance over computeIfAbsent().\n'get()' + synchronized. Back to our use case, read is much much more than create/write because creation is only one time for each ZkClient. And I think the synchronized code block here is correct. This way makes sure creation/put is thread-safe, one time initialization does not hurt too much performance because read much heavier than write in our case.\n\nSo I believe get() + synchronized satisfy us better. What do you think?", "author": "huizhilu", "createdAt": "2020-02-26T07:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5OTY4OQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384699689", "bodyText": "Good point. ComputeifAbsent() is better. This guarantees no leaking of DedicatedZkClient. Note, client created must be close(). PutIfAbsent has a small chance of leaking though.\nGet() + synchronized has its pitfall too. This is double-locking pattern. If test a simple value null or not, you need to make the value volatile. But for this one, I am not sure.\nSo my suggestion is to use ComputeIfAbsent, and if possible, add a test case to make sure we don't leak zkClient (garbage collected, but did not call close())", "author": "kaisun2000", "createdAt": "2020-02-26T19:03:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNzM1OA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384817358", "bodyText": "As we discussed, we will keep current implementation, because:\n\ndouble-check lock here for the concurrent map is thread safe, as computeIfAbsent(). A discussion reference as an example: https://stackoverflow.com/questions/7003239/double-checked-locking-with-concurrentmap\nget() is faster than computeIfAbsent() for getting an existing key, as we analyzed the code and did performance experiments to prove it.\n\npublic static void main(String[] args) {\n    Map<String, String> map = new ConcurrentHashMap<>();\n    for (int i = 0; i < 300; i++) {\n      String s = String.valueOf(i);\n      map.put(s, s);\n    }\n    long startTime = System.currentTimeMillis();\n    for (int i = 0; i < 100000; i++) {\n      map.get(\"200\");\n    }\n    System.out.println(System.currentTimeMillis() - startTime);\n    startTime = System.currentTimeMillis();\n    for (int i = 0; i < 100000; i++) {\n      map.computeIfAbsent(\"200\", k -> \"1000\");\n    }\n    System.out.println(System.currentTimeMillis() - startTime);\n}\n\nResult:\n5  // get()\n53 // computeIfAbsent()\n\n\nAnother workable option is below. But the downside of this option is, it could not sync with close(). We have to make sure all clients are closed and the map is totally cleared when close() is called. synchronized _zkRealmToZkClientMap has the benefit of protecting the map from adding new zkclient, when close() is called.\n\nif (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n  return map.computeIfAbsent(zkRealm, createZkClient(zkRealm));\n}\nreturn map.get(zkRealm);", "author": "huizhilu", "createdAt": "2020-02-26T22:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTQ3Mg==", "url": "https://github.com/apache/helix/pull/789#discussion_r384869472", "bodyText": "This good implementation.  Please add a comment here why this is safe and performant ( https://stackoverflow.com/questions/7003239/double-checked-locking-with-concurrentmap)", "author": "kaisun2000", "createdAt": "2020-02-27T01:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NDg5MQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384164891", "bodyText": "Is this _metadataStoreRoutingData query thread safe?\n@narendly, @dasahcc.\nThis need to be validated.", "author": "kaisun2000", "createdAt": "2020-02-25T22:27:43Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;\n+    try {\n+      zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);", "originalCommit": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NTc1NA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384195754", "bodyText": "Does this need to be thread-safe? This data is statically populated at the very beginning and no one is updating this data, right (update not allowed)?", "author": "narendly", "createdAt": "2020-02-25T23:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NDg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTM1OA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384201358", "bodyText": "_metadataStoreRoutingData.getMetadataStoreRealm for sure should be thread safe. All the public API in this one should be as they will be called by multiple thread.\nWe probably should raise this point in the diff implementing this code. I just forget to look careful there.\nThat said, it is not hard to make it thread safe as you said, think they are immutable once published. Wrapping the data to be published in a immutable collection seems to be the easiest way to me.", "author": "kaisun2000", "createdAt": "2020-02-26T00:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NDg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNzgyMQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384227821", "bodyText": "Could you look at how _metadataStoreRoutingData is implemented? It sounds like you think it's returning a map - it's actually an interface that does not provide any APIs that can modify the underlying data structure.", "author": "narendly", "createdAt": "2020-02-26T01:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NDg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MDk5NQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384290995", "bodyText": "Like @narendly said, _metadataStoreRoutingData does not allow modification/write once it is built. So multi-threading read is safe.", "author": "huizhilu", "createdAt": "2020-02-26T06:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NDg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODE1NA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384168154", "bodyText": "Nit, this can be done in the declaration place and make the _zkRealmToZkClientMap final.", "author": "kaisun2000", "createdAt": "2020-02-25T22:35:06Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();", "originalCommit": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MzIxNQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384193215", "bodyText": "^ You could still make the reference final and initialize in the constructor :)", "author": "narendly", "createdAt": "2020-02-25T23:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4OTAwNg==", "url": "https://github.com/apache/helix/pull/789#discussion_r384289006", "bodyText": "Like @narendly said, It is final.", "author": "huizhilu", "createdAt": "2020-02-26T06:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyNDk4OQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r385424989", "bodyText": "up to you. Most other codes does it my suggested way, though.", "author": "kaisun2000", "createdAt": "2020-02-27T23:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUxMzE4Mg==", "url": "https://github.com/apache/helix/pull/789#discussion_r385513182", "bodyText": "@kaisun2000 I can't find concrete proof for \"Most other codes does it my suggested way, though\".\nThe benefits of initializing it in constructor:\n\nIt is clearer to know how this variable is initialized. If it is initialized at declaration like you said, we still don't know its init state, until checking the constructor if this variable adds any elements or not. So I think initializing it in constructor is clearer, cleaner and more readable.\nhaving it in the constructor gives more flexibility to add logic in the future if needed.", "author": "huizhilu", "createdAt": "2020-02-28T05:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2OTY3Nw==", "url": "https://github.com/apache/helix/pull/789#discussion_r384169677", "bodyText": "Using this way to collect stats, we have individual internal dedicated zkclient stats. We can't have aggregated stats.\nThe question is that do we want to have collective status for one federatedZkClient?", "author": "kaisun2000", "createdAt": "2020-02-25T22:38:28Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;\n+    try {\n+      zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+    } catch (NoSuchElementException ex) {\n+      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    }\n+\n+    if (zkRealm == null || zkRealm.isEmpty()) {\n+      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    }\n+\n+    return zkRealm;\n+  }\n+\n+  private ZkClient createZkClient(String zkAddress) {\n+    LOG.debug(\"Creating ZkClient for realm: {}.\", zkAddress);", "originalCommit": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NjMzOQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384196339", "bodyText": "Are you referring to ZkClient metrics?\nWe've discussed this and I think it's worth considering, but that should be a TODO. Can we create an issue for it and tackle it at a later time?", "author": "narendly", "createdAt": "2020-02-25T23:47:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2OTY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMDA5MA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384200090", "bodyText": "TODO seems to be good choice now. But exactly what needs to be done let us think about it.", "author": "kaisun2000", "createdAt": "2020-02-25T23:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2OTY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MTY5OA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384291698", "bodyText": "Issue is created for tracking: #812", "author": "huizhilu", "createdAt": "2020-02-26T06:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2OTY3Nw=="}], "type": "inlineReview"}, {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "url": "https://github.com/apache/helix/commit/05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "message": "Make _numZk static", "committedDate": "2020-02-23T02:03:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2MzQzMQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384863431", "bodyText": "Document the threading model change here. Namely that listeners (data/children) for ZKpath in different realm potentially can be invoked concurrently.  This means user should take care of currency issue in the listener implementation.", "author": "kaisun2000", "createdAt": "2020-02-27T01:19:30Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**", "originalCommit": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MzEwOQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384883109", "bodyText": "Added.", "author": "huizhilu", "createdAt": "2020-02-27T02:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2MzQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODcyOQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384868729", "bodyText": "Nit: usually we put the log at the very end. So move to the end of this method and say FederatedZkClient closed successfully?", "author": "narendly", "createdAt": "2020-02-27T01:39:57Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);", "originalCommit": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MzA1MA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384883050", "bodyText": "I thought about that when I was adding the log. The reason why I add logging here is because it gives us timestamp when its starts to close the clients and could potentially help us with troubleshooting (if there was any race condition related to close()). And actually each raw zkclient has has its own closed log after it is closed. So I prefer to put it at the very beginning.", "author": "huizhilu", "createdAt": "2020-02-27T02:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTYxOA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384869618", "bodyText": "This is not thread safe way to closing. As discussed. We need to fix it.", "author": "kaisun2000", "createdAt": "2020-02-27T01:43:18Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {", "originalCommit": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4NTk4MQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384885981", "bodyText": "Resolved.\n\nWe check closed state again before creating a new zkclient in the synchronized block. This helps with the case: the thread B starts to execute the createZkClient() synchronized block right after thread A executes close(). With current code now, check closed state again to avoid creating a new zkclient.\nWe use a zkclient reference ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm); to avoid race condition:\n\nif (containsKey()) { // true\n // clear() could happen in this time gap.\n return get()  // returns null\n}", "author": "huizhilu", "createdAt": "2020-02-27T02:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTYxOA=="}], "type": "inlineReview"}, {"oid": "a373edc786324cbfc917fe8d51f8b28718c08b90", "url": "https://github.com/apache/helix/commit/a373edc786324cbfc917fe8d51f8b28718c08b90", "message": "Make close() and getZkClient() thread safe.", "committedDate": "2020-02-27T02:23:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MDU4MQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384890581", "bodyText": "Nit. remove empty line", "author": "narendly", "createdAt": "2020-02-27T03:06:02Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,506 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.\n+    ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm);\n+\n+    if (zkClient == null) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        // Check closed state again to avoid race condition and creating a new ZkClient\n+        // after FederatedZkClient is already closed.\n+        checkClosedState();\n+\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          zkClient = createZkClient(zkRealm);\n+          _zkRealmToZkClientMap.put(zkRealm, zkClient);\n+        }\n+      }\n+    }\n+", "originalCommit": "a373edc786324cbfc917fe8d51f8b28718c08b90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MDg1MQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384890851", "bodyText": "This is good. Makes sense. This will help us avoid zkClient leaks. Good work!", "author": "narendly", "createdAt": "2020-02-27T03:07:13Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,506 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.\n+    ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm);\n+\n+    if (zkClient == null) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        // Check closed state again to avoid race condition and creating a new ZkClient\n+        // after FederatedZkClient is already closed.\n+        checkClosedState();\n+\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          zkClient = createZkClient(zkRealm);\n+          _zkRealmToZkClientMap.put(zkRealm, zkClient);\n+        }\n+      }\n+    }", "originalCommit": "a373edc786324cbfc917fe8d51f8b28718c08b90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MTkzMA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384891930", "bodyText": "It will never return null though right? There are only 2 outcomes that are possible - 1) we return a newly created ZkClient or 2) we throw an exception and not return anything.\nIf you actually create a reference here, you might end up returning null. Consider the following scenario:\n\nZkClient hasn't been created, so zkClient is null.\nSince zkClient is null, it waits for the lock for _zkRealmToZkClientMap\nWhile waiting, some other thread creates the zkClient and puts it in the map\nI finally get the lock, enter the critical section, FederatedZkClient not closed, and reach the containsKey block.\ncontainsKey returns true (because some other thread created and put it in the map already), so you skip the entire creation block without updating the reference to zkClient.\nyou return zkClient, which is still null\n\nEither 1) you go back to using ConcurrentHashMap's containsKey primitive or 2) you'll have to add an else clause that updates the reference by doing\nelse {\n  zkClient = _zkRealmToZkClientMap.get(zkRealm);\n}\n\nOr 3) you could use computeIfAbsent but this option is slow, so not desirable.", "author": "narendly", "createdAt": "2020-02-27T03:12:07Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,506 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.", "originalCommit": "a373edc786324cbfc917fe8d51f8b28718c08b90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkwMTE1OQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r384901159", "bodyText": "You are correct. Thanks for the catch.\nWhat I initially did was\n    if (zkClient != null) {\n      return zkClient;\n    }\n    \n    // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n    synchronized (_zkRealmToZkClientMap) {\n      // Check closed state again to avoid race condition and creating a new ZkClient\n      // after FederatedZkClient is already closed.\n      checkClosedState();\n\n      if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n        _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n      }\n\n      return _zkRealmToZkClientMap.get(zkRealm);\n    }\n\nAnd I wanted to take _zkRealmToZkClientMap.get(zkRealm) out of synchronized block to make a bit more optimization. And changed the code but forgot the else which introduced the potential NPE..\nUsing else to get is optimal considering performance. If it is not performance critical, I would just use computeIfAbsent to make it easier to understand and maintain..", "author": "huizhilu", "createdAt": "2020-02-27T03:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MTkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MDc0OA==", "url": "https://github.com/apache/helix/pull/789#discussion_r384940748", "bodyText": "The three options I listed are all fair game. I also agree that adding the else clause should do it :)", "author": "narendly", "createdAt": "2020-02-27T06:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MTkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0OTIyNw==", "url": "https://github.com/apache/helix/pull/789#discussion_r385249227", "bodyText": "Option 1 you listed does not work 100% . It could still return null. That\u2019s why I would like this way to have a zkclient reference.", "author": "huizhilu", "createdAt": "2020-02-27T17:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MTkzMA=="}], "type": "inlineReview"}, {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44", "url": "https://github.com/apache/helix/commit/451276a1f31c046fabcc9770e3f3b8b5034aaf44", "message": "Fix potential NPE for returning zkclient.", "committedDate": "2020-02-27T04:06:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyNDQyOA==", "url": "https://github.com/apache/helix/pull/789#discussion_r385424428", "bodyText": "This has nothing to do with \"order\" or sequential consistency in Zookeeper term. Let us don't confuse user with this consistency guarantee.\nFrom the user's perspective, they need to be aware their callback listerner can be invoked concurrently and should prepare to handle this concurrency accordingly, which is not the case before. Something like:\nFederated ZKClient is designed to perform CRUD operation across different zookeeper realms. It would handle data and node change notification. It does not support ephemeral node operation.\nFrom concurrency point of view, the callback notification can be invoked concurrently for ZK path in different zookeeper realm. This is different from other ZkClient which will invoke the callback in one thread. Thus, it is the user's responsibility to take care this concurrency.", "author": "kaisun2000", "createdAt": "2020-02-27T23:11:39Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,508 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is", "originalCommit": "451276a1f31c046fabcc9770e3f3b8b5034aaf44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ0NDExNA==", "url": "https://github.com/apache/helix/pull/789#discussion_r385444114", "bodyText": "Also explicitly mention that \"the users should use thread-safe data structures if they wish to handle change callbacks\".", "author": "narendly", "createdAt": "2020-02-28T00:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyNDQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNTI1OA==", "url": "https://github.com/apache/helix/pull/789#discussion_r385435258", "bodyText": "Please add a comment here that why this kind of double locking is working. The stackoverflow thread you found. Also, explain why here this is faster. This help people later maintaining the code understand why it is done this way.", "author": "kaisun2000", "createdAt": "2020-02-27T23:46:28Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,508 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.\n+    ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm);", "originalCommit": "451276a1f31c046fabcc9770e3f3b8b5034aaf44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ0NTM5Ng==", "url": "https://github.com/apache/helix/pull/789#discussion_r385445396", "bodyText": "I don't agree that we should add the link to the stack overflow post, but feel free to explain here why you know this would work.", "author": "narendly", "createdAt": "2020-02-28T00:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUxNzIxMg==", "url": "https://github.com/apache/helix/pull/789#discussion_r385517212", "bodyText": "@kaisun2000\n\nWe don't add stack overflow links to comments.\nI don't think this is a right place to explain \"why this kind of double locking is working\". If they don't understand, they should go to the right place to find out why.\nThis reference/cache is not for making it faster, but making it safe to return a non-null ZkClient, as commented.", "author": "huizhilu", "createdAt": "2020-02-28T05:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNTI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNjM3NQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r385436375", "bodyText": "Change the comment to state that this synchronize() is pair with close() synchronized. This is to avoid creating another internal dedicated ZkClient by thread A when thread B invoked close() which subsequently close all internal dedicated ZkClient.", "author": "kaisun2000", "createdAt": "2020-02-27T23:50:12Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,508 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.\n+    ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm);\n+\n+    if (zkClient == null) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.", "originalCommit": "451276a1f31c046fabcc9770e3f3b8b5034aaf44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUxODExNQ==", "url": "https://github.com/apache/helix/pull/789#discussion_r385518115", "bodyText": "The one you mentioned is one of the reasons but not the only one.\n\nSynchronized to avoid creating duplicate ZkClient for the same ZkRealm.\nSynchronized to avoid creating creating new ZkClients when close() is called, all zkclients are being closed and the _zkRealmToZkClientMap is being cleared. Regarding this, the code already obviously explains itself because both here and close() synchronized on the same object _zkRealmToZkClientMap.\n\nAnyway I will make it clearer.", "author": "huizhilu", "createdAt": "2020-02-28T05:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNjM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNzc1Nw==", "url": "https://github.com/apache/helix/pull/789#discussion_r385437757", "bodyText": "Seems to me this is ok.\nWe can reason it this way. The code in this synchronized() is paired with code in close() synchronized block. Thus, there are only two possibilities.\nCase 1/ this block run first, the block in closed() run next. In this case, the newly created dedicated ZkClient in this block would be closed in the closed() block\nCase 2/ this block run after the block in close(). In this case, we would not create dedicated ZkClient due to the flag of closed is set.", "author": "kaisun2000", "createdAt": "2020-02-27T23:54:38Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,508 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.\n+    ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm);\n+\n+    if (zkClient == null) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {", "originalCommit": "451276a1f31c046fabcc9770e3f3b8b5034aaf44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUxODU2Ng==", "url": "https://github.com/apache/helix/pull/789#discussion_r385518566", "bodyText": "It IS working.", "author": "huizhilu", "createdAt": "2020-02-28T05:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNzc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNzk3MA==", "url": "https://github.com/apache/helix/pull/789#discussion_r385437970", "bodyText": "See the reasoning bellow, this is not necessary. Isn't it?", "author": "kaisun2000", "createdAt": "2020-02-27T23:55:19Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,508 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();", "originalCommit": "451276a1f31c046fabcc9770e3f3b8b5034aaf44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ0NTEzNw==", "url": "https://github.com/apache/helix/pull/789#discussion_r385445137", "bodyText": "My opinion is that it's fine either way -\n\nwe can fail early here\nreturning a closed ZkClient is also okay because the raw ZkClient will fail if it's closed anyway.\n\nI am slightly in favor of option 2) because that would look more natural to users. (as in they continue getting the message from the raw ZkClient, as if they were using the raw ZkClient)", "author": "narendly", "createdAt": "2020-02-28T00:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNzk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUxNTQyOA==", "url": "https://github.com/apache/helix/pull/789#discussion_r385515428", "bodyText": "Of course it is necessary:\n\nIf this FederatedZkClient is closed, it won't re-open and its internal _zkRealmToZkClientMap is clear for garbage collection.\nWithout this check, it continues to aquire the lock. If we know we can not serve the request, why don't we fail it earlier but let them acquire the lock which costs overhead?\nSince the map is empty, we won't return a closed ZkClient. This FederatedZkClient is explicitly closed by you, why do you still want this closed  FederatedZkClient? What can a user do with a closed ZkClient? I don't think it is meaningful to return a closed ZkClient.", "author": "huizhilu", "createdAt": "2020-02-28T05:36:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNzk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU0MDY5Nw==", "url": "https://github.com/apache/helix/pull/789#discussion_r385540697", "bodyText": "I didn't realize that we're clearing the map. I'm fine with doing the check and failing early here then so as not to return null. Returning null is bad.", "author": "narendly", "createdAt": "2020-02-28T07:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNzk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzODQ4MA==", "url": "https://github.com/apache/helix/pull/789#discussion_r385438480", "bodyText": "Can we add a test case that one thread close the FederatedZKClient and then another thread use it, which would generate exception?", "author": "kaisun2000", "createdAt": "2020-02-27T23:56:46Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestFederatedZkClient.java", "diffHunk": "@@ -0,0 +1,310 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.ZkServer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestFederatedZkClient extends ZkTestBase {\n+  private static final String TEST_SHARDING_KEY_PREFIX = \"/test_sharding_key_\";\n+  private static final String TEST_REALM_ONE_VALID_PATH = TEST_SHARDING_KEY_PREFIX + \"1/a/b/c\";\n+  private static final String TEST_REALM_TWO_VALID_PATH = TEST_SHARDING_KEY_PREFIX + \"2/x/y/z\";\n+  private static final String TEST_INVALID_PATH = TEST_SHARDING_KEY_PREFIX + \"invalid/a/b/c\";\n+  private static final String UNSUPPORTED_OPERATION_MESSAGE =\n+      \"Session-aware operation is not supported by FederatedZkClient.\";\n+\n+  private RealmAwareZkClient _realmAwareZkClient;\n+  // Need to start an extra ZK server for multi-realm test, if only one ZK server is running.\n+  private String _extraZkRealm;\n+  private ZkServer _extraZkServer;\n+\n+  @BeforeClass\n+  public void beforeClass() throws InvalidRoutingDataException {\n+    System.out.println(\"Starting \" + TestFederatedZkClient.class.getSimpleName());\n+\n+    // Populate rawRoutingData\n+    // <Realm, List of sharding keys> Mapping\n+    Map<String, List<String>> rawRoutingData = new HashMap<>();\n+    for (int i = 0; i < _numZk; i++) {\n+      List<String> shardingKeyList = Collections.singletonList(TEST_SHARDING_KEY_PREFIX + (i + 1));\n+      String realmName = ZK_PREFIX + (ZK_START_PORT + i);\n+      rawRoutingData.put(realmName, shardingKeyList);\n+    }\n+\n+    if (rawRoutingData.size() < 2) {\n+      System.out.println(\"There is only one ZK realm. Starting one more ZK to test multi-realm.\");\n+      _extraZkRealm = ZK_PREFIX + (ZK_START_PORT + 1);\n+      _extraZkServer = startZkServer(_extraZkRealm);\n+      // RealmTwo's sharding key: /test_sharding_key_2\n+      List<String> shardingKeyList = Collections.singletonList(TEST_SHARDING_KEY_PREFIX + \"2\");\n+      rawRoutingData.put(_extraZkRealm, shardingKeyList);\n+    }\n+\n+    // Feed the raw routing data into TrieRoutingData to construct an in-memory representation\n+    // of routing information.\n+    _realmAwareZkClient = new FederatedZkClient(new RealmAwareZkClient.RealmAwareZkClientConfig(),\n+        new TrieRoutingData(rawRoutingData));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    // Close it as it is created in before class.\n+    _realmAwareZkClient.close();\n+\n+    // Close the extra zk server.\n+    if (_extraZkServer != null) {\n+      _extraZkServer.shutdown();\n+    }\n+\n+    System.out.println(\"Ending \" + TestFederatedZkClient.class.getSimpleName());\n+  }\n+\n+  /*\n+   * Tests that an unsupported operation should throw an UnsupportedOperationException.\n+   */\n+  @Test\n+  public void testUnsupportedOperations() {\n+    // Test creating ephemeral.\n+    try {\n+      _realmAwareZkClient.create(TEST_REALM_ONE_VALID_PATH, \"Hello\", CreateMode.EPHEMERAL);\n+      Assert.fail(\"Ephemeral node should not be created.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    // Test creating ephemeral sequential.\n+    try {\n+      _realmAwareZkClient\n+          .create(TEST_REALM_ONE_VALID_PATH, \"Hello\", CreateMode.EPHEMERAL_SEQUENTIAL);\n+      Assert.fail(\"Ephemeral node should not be created.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    List<Op> ops = Arrays.asList(\n+        Op.create(TEST_REALM_ONE_VALID_PATH, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+            CreateMode.PERSISTENT), Op.delete(TEST_REALM_ONE_VALID_PATH, -1));\n+    try {\n+      _realmAwareZkClient.multi(ops);\n+      Assert.fail(\"multi() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    try {\n+      _realmAwareZkClient.getSessionId();\n+      Assert.fail(\"getSessionId() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    try {\n+      _realmAwareZkClient.getServers();\n+      Assert.fail(\"getServers() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    try {\n+      _realmAwareZkClient.waitUntilConnected(5L, TimeUnit.SECONDS);\n+      Assert.fail(\"getServers() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    // Test state change subscription.\n+    IZkStateListener listener = new IZkStateListener() {\n+      @Override\n+      public void handleStateChanged(Watcher.Event.KeeperState state) {\n+        System.out.println(\"Handle new state: \" + state);\n+      }\n+\n+      @Override\n+      public void handleNewSession(String sessionId) {\n+        System.out.println(\"Handle new session: \" + sessionId);\n+      }\n+\n+      @Override\n+      public void handleSessionEstablishmentError(Throwable error) {\n+        System.out.println(\"Handle session establishment error: \" + error);\n+      }\n+    };\n+\n+    try {\n+      _realmAwareZkClient.subscribeStateChanges(listener);\n+      Assert.fail(\"getServers() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    try {\n+      _realmAwareZkClient.unsubscribeStateChanges(listener);\n+      Assert.fail(\"getServers() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+  }\n+\n+  /*\n+   * Tests the persistent create() call against a valid path and an invalid path.\n+   * Valid path is one that belongs to the realm designated by the sharding key.\n+   * Invalid path is one that does not belong to the realm designated by the sharding key.\n+   */\n+  @Test(dependsOnMethods = \"testUnsupportedOperations\")\n+  public void testCreatePersistent() {\n+    _realmAwareZkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // Create a dummy ZNRecord\n+    ZNRecord znRecord = new ZNRecord(\"DummyRecord\");\n+    znRecord.setSimpleField(\"Dummy\", \"Value\");\n+\n+    // Test writing and reading against the validPath\n+    _realmAwareZkClient.createPersistent(TEST_REALM_ONE_VALID_PATH, true);\n+    _realmAwareZkClient.writeData(TEST_REALM_ONE_VALID_PATH, znRecord);\n+    Assert.assertEquals(_realmAwareZkClient.readData(TEST_REALM_ONE_VALID_PATH), znRecord);\n+\n+    // Test writing and reading against the invalid path\n+    try {\n+      _realmAwareZkClient.createPersistent(TEST_INVALID_PATH, true);\n+      Assert.fail(\"Create() should not succeed on an invalid path!\");\n+    } catch (NoSuchElementException ex) {\n+      Assert\n+          .assertEquals(ex.getMessage(), \"Cannot find ZK realm for the path: \" + TEST_INVALID_PATH);\n+    }\n+  }\n+\n+  /*\n+   * Tests that exists() works on valid path and fails on invalid path.\n+   */\n+  @Test(dependsOnMethods = \"testCreatePersistent\")\n+  public void testExists() {\n+    Assert.assertTrue(_realmAwareZkClient.exists(TEST_REALM_ONE_VALID_PATH));\n+\n+    try {\n+      _realmAwareZkClient.exists(TEST_INVALID_PATH);\n+      Assert.fail(\"Exists() should not succeed on an invalid path!\");\n+    } catch (NoSuchElementException ex) {\n+      Assert\n+          .assertEquals(ex.getMessage(), \"Cannot find ZK realm for the path: \" + TEST_INVALID_PATH);\n+    }\n+  }\n+\n+  /*\n+   * Tests that delete() works on valid path and fails on invalid path.\n+   */\n+  @Test(dependsOnMethods = \"testExists\")\n+  public void testDelete() {\n+    try {\n+      _realmAwareZkClient.delete(TEST_INVALID_PATH);\n+      Assert.fail(\"Exists() should not succeed on an invalid path!\");\n+    } catch (NoSuchElementException ex) {\n+      Assert\n+          .assertEquals(ex.getMessage(), \"Cannot find ZK realm for the path: \" + TEST_INVALID_PATH);\n+    }\n+\n+    Assert.assertTrue(_realmAwareZkClient.delete(TEST_REALM_ONE_VALID_PATH));\n+    Assert.assertFalse(_realmAwareZkClient.exists(TEST_REALM_ONE_VALID_PATH));\n+  }\n+\n+  /*\n+   * Tests that multi-realm feature.\n+   */\n+  @Test(dependsOnMethods = \"testDelete\")\n+  public void testMultiRealmCRUD() {\n+    ZNRecord realmOneZnRecord = new ZNRecord(\"realmOne\");\n+    realmOneZnRecord.setSimpleField(\"realmOne\", \"Value\");\n+\n+    ZNRecord realmTwoZnRecord = new ZNRecord(\"realmTwo\");\n+    realmTwoZnRecord.setSimpleField(\"realmTwo\", \"Value\");\n+\n+    // Writing on realmOne.\n+    _realmAwareZkClient.createPersistent(TEST_REALM_ONE_VALID_PATH, true);\n+    _realmAwareZkClient.writeData(TEST_REALM_ONE_VALID_PATH, realmOneZnRecord);\n+\n+    // RealmOne path is created but realmTwo path is not.\n+    Assert.assertTrue(_realmAwareZkClient.exists(TEST_REALM_ONE_VALID_PATH));\n+    Assert.assertFalse(_realmAwareZkClient.exists(TEST_REALM_TWO_VALID_PATH));\n+\n+    // Writing on realmTwo.\n+    _realmAwareZkClient.createPersistent(TEST_REALM_TWO_VALID_PATH, true);\n+    _realmAwareZkClient.writeData(TEST_REALM_TWO_VALID_PATH, realmTwoZnRecord);\n+\n+    // RealmTwo path is created.\n+    Assert.assertTrue(_realmAwareZkClient.exists(TEST_REALM_TWO_VALID_PATH));\n+\n+    // Reading on both realms.\n+    Assert.assertEquals(_realmAwareZkClient.readData(TEST_REALM_ONE_VALID_PATH), realmOneZnRecord);\n+    Assert.assertEquals(_realmAwareZkClient.readData(TEST_REALM_TWO_VALID_PATH), realmTwoZnRecord);\n+\n+    Assert.assertTrue(_realmAwareZkClient.delete(TEST_REALM_ONE_VALID_PATH));\n+    Assert.assertFalse(_realmAwareZkClient.exists(TEST_REALM_ONE_VALID_PATH));\n+\n+    // Deleting on realmOne does not delete on realmTwo.\n+    Assert.assertTrue(_realmAwareZkClient.exists(TEST_REALM_TWO_VALID_PATH));\n+\n+    // Deleting on realmTwo.\n+    Assert.assertTrue(_realmAwareZkClient.delete(TEST_REALM_TWO_VALID_PATH));\n+    Assert.assertFalse(_realmAwareZkClient.exists(TEST_REALM_TWO_VALID_PATH));\n+  }\n+\n+  /*\n+   * Tests that close() works.\n+   */\n+  @Test(dependsOnMethods = \"testMultiRealmCRUD\")\n+  public void testClose() {\n+    Assert.assertFalse(_realmAwareZkClient.isClosed());\n+\n+    _realmAwareZkClient.close();\n+\n+    Assert.assertTrue(_realmAwareZkClient.isClosed());\n+\n+    // Client is closed, so operation should not be executed.\n+    try {\n+      _realmAwareZkClient.createPersistent(TEST_REALM_ONE_VALID_PATH);\n+      Assert\n+          .fail(\"createPersistent() should not be executed because RealmAwareZkClient is closed.\");\n+    } catch (IllegalStateException ex) {\n+      Assert.assertEquals(ex.getMessage(), \"FederatedZkClient is closed!\");\n+    }\n+  }", "originalCommit": "451276a1f31c046fabcc9770e3f3b8b5034aaf44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUyNzM5Ng==", "url": "https://github.com/apache/helix/pull/789#discussion_r385527396", "bodyText": "Since the first check is already tested here, I would say you wanted to test the second check within the synchronized, right? I would appreciate it if you could help and show me how to implement it.", "author": "huizhilu", "createdAt": "2020-02-28T06:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzODQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU0MTc3MA==", "url": "https://github.com/apache/helix/pull/789#discussion_r385541770", "bodyText": "Testing multi-threaded code for race condition might not be so easy to do it here. I vote to create a separate issue for testing this sort of stuff if it's necessary. @kaisun2000 could provide more insight on that issue if he's willing.\nFor the purposes of adding FederatedZkClient, I do not think we need to create that test here.", "author": "narendly", "createdAt": "2020-02-28T07:22:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzODQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MjA1NA==", "url": "https://github.com/apache/helix/pull/789#discussion_r385962054", "bodyText": "yeah, testing multi-thread version is probably not easy. More into thinking test no leak of internal zkClient. Specifically here, can we assert that the internal map from realm to zkclient is empty? And if possible the opened internal zkclient do get a close call. This is to ensure normal flow we don't leak Zookeeper session.", "author": "kaisun2000", "createdAt": "2020-02-28T23:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzODQ4MA=="}], "type": "inlineReview"}, {"oid": "8107874cd53ecab8a26a135587ff9f5e43a521ed", "url": "https://github.com/apache/helix/commit/8107874cd53ecab8a26a135587ff9f5e43a521ed", "message": "Add neccessary comments.", "committedDate": "2020-02-28T07:09:44Z", "type": "forcePushed"}, {"oid": "2426c64efa980f6acb2d923dcee1136316ea7dd9", "url": "https://github.com/apache/helix/commit/2426c64efa980f6acb2d923dcee1136316ea7dd9", "message": "Add neccessary comments.", "committedDate": "2020-02-28T07:14:56Z", "type": "commit"}, {"oid": "2426c64efa980f6acb2d923dcee1136316ea7dd9", "url": "https://github.com/apache/helix/commit/2426c64efa980f6acb2d923dcee1136316ea7dd9", "message": "Add neccessary comments.", "committedDate": "2020-02-28T07:14:56Z", "type": "forcePushed"}, {"oid": "a42e2823bdd23b3e148c47c94fda110318d5f583", "url": "https://github.com/apache/helix/commit/a42e2823bdd23b3e148c47c94fda110318d5f583", "message": "Set closed state before closing all zkClients.", "committedDate": "2020-02-29T01:25:09Z", "type": "forcePushed"}, {"oid": "182f1d3810896a7111aa4f4c5ec576fe6cea22cd", "url": "https://github.com/apache/helix/commit/182f1d3810896a7111aa4f4c5ec576fe6cea22cd", "message": "Set closed state before closing all zkClients.", "committedDate": "2020-02-29T01:26:14Z", "type": "forcePushed"}, {"oid": "5410ef50a3133f613f2bbf8ce681345963562466", "url": "https://github.com/apache/helix/commit/5410ef50a3133f613f2bbf8ce681345963562466", "message": "Set closed state before closing all zkClients.", "committedDate": "2020-02-29T01:27:00Z", "type": "forcePushed"}, {"oid": "4215b699f835e92f6797e49dcb5a32814fc7e5a0", "url": "https://github.com/apache/helix/commit/4215b699f835e92f6797e49dcb5a32814fc7e5a0", "message": "Set closed state before closing all zkClients.", "committedDate": "2020-02-29T01:28:46Z", "type": "commit"}, {"oid": "4215b699f835e92f6797e49dcb5a32814fc7e5a0", "url": "https://github.com/apache/helix/commit/4215b699f835e92f6797e49dcb5a32814fc7e5a0", "message": "Set closed state before closing all zkClients.", "committedDate": "2020-02-29T01:28:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5OTAzMg==", "url": "https://github.com/apache/helix/pull/789#discussion_r385999032", "bodyText": "Good!", "author": "kaisun2000", "createdAt": "2020-02-29T04:09:02Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -19,345 +19,535 @@\n  * under the License.\n  */\n \n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import com.sun.istack.internal.NotNull;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: each Zk realm has its own event queue to handle listeners. So listeners from different ZK\n+ * realms could be handled concurrently because listeners of a ZK realm are handled in its own\n+ * queue. The concurrency of listeners should be aware of when implementing listeners for different\n+ * ZK realms. The users should use thread-safe data structures if they wish to handle change\n+ * callbacks.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    _isClosed = true;\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      Iterator<Map.Entry<String, ZkClient>> iterator = _zkRealmToZkClientMap.entrySet().iterator();\n+\n+      while (iterator.hasNext()) {\n+        Map.Entry<String, ZkClient> entry = iterator.next();\n+        String zkRealm = entry.getKey();\n+        ZkClient zkClient = entry.getValue();\n+\n+        // Catch any exception from ZkClient's close() to avoid that there is leakage of\n+        // remaining unclosed ZkClient.\n+        try {\n+          zkClient.close();", "originalCommit": "4215b699f835e92f6797e49dcb5a32814fc7e5a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMDM5Ng==", "url": "https://github.com/apache/helix/pull/789#discussion_r386010396", "bodyText": "Can we not include this? I understand what you're trying to do here, but I don't think you're using this particular annotation the right way.\nSee https://stackoverflow.com/questions/42576760/where-is-notnull-in-java\nWe don't have to use that annotation here...", "author": "narendly", "createdAt": "2020-02-29T07:52:53Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -19,345 +19,535 @@\n  * under the License.\n  */\n \n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import com.sun.istack.internal.NotNull;", "originalCommit": "4215b699f835e92f6797e49dcb5a32814fc7e5a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "79be545249f5b571b488ff4657ba51ff4f595e9e", "url": "https://github.com/apache/helix/commit/79be545249f5b571b488ff4657ba51ff4f595e9e", "message": "Remove NotNull", "committedDate": "2020-02-29T08:07:33Z", "type": "commit"}]}