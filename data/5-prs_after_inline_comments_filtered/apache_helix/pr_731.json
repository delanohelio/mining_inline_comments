{"pr_number": 731, "pr_title": "Add TrieRoutingData constructor", "pr_createdAt": "2020-02-06T20:16:28Z", "pr_url": "https://github.com/apache/helix/pull/731", "timeline": [{"oid": "de49756ed287c28edb6072fc299802a0c31b8c7b", "url": "https://github.com/apache/helix/commit/de49756ed287c28edb6072fc299802a0c31b8c7b", "message": "add TrieRoutingData constructor", "committedDate": "2020-02-06T20:10:47Z", "type": "commit"}, {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "url": "https://github.com/apache/helix/commit/ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "message": "fix formating", "committedDate": "2020-02-06T20:14:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNjgzNw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376126837", "bodyText": "If the code is not necessary, let's remove it.", "author": "junkaixue", "createdAt": "2020-02-06T22:51:53Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -179,10 +179,10 @@ public void refreshRoutingData(String namespace) {\n     }\n \n     if (_routingDataMap != null) {\n-      MetadataStoreRoutingData newRoutingData =\n-          new TrieRoutingData(new TrieRoutingData.TrieNode(null, null, false, null));\n+//      MetadataStoreRoutingData newRoutingData =\n+//          new TrieRoutingData(new TrieRoutingData.TrieNode(null, null, false, null));\n       // TODO call constructRoutingData() here.\n-      _routingDataMap.put(namespace, newRoutingData);\n+//      _routingDataMap.put(namespace, newRoutingData);", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MjMyNA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376162324", "bodyText": "It's not unnecessary, it just doesn't work anymore after the changes I made in the PR. @narendly Letting you know that this no longer compiles because TrieNode is converted to private as planned. I'm not entirely sure on how to change it so I'm leaving it up to you.", "author": "NealSun96", "createdAt": "2020-02-07T00:47:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNjgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2NTEyMQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376165121", "bodyText": "The code was just left in there for demonstration purposes. Let's implement this part of the logic to complete ZkMetadataStoreDirectory.", "author": "narendly", "createdAt": "2020-02-07T00:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNjgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2ODAwMA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376168000", "bodyText": "@narendly I didn't entirely understand the refresh logic here, actually. That's why I didn't make the change. Let's sync up so I know what to do here.", "author": "NealSun96", "createdAt": "2020-02-07T01:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNjgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NDExNw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376244117", "bodyText": "@NealSun96 You just need to re-construct a fresh instance of TrieRoutingData here. If that's still not clear, we could work together offline :)", "author": "narendly", "createdAt": "2020-02-07T07:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNjgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxNzI3Ng==", "url": "https://github.com/apache/helix/pull/731#discussion_r376617276", "bodyText": "Resolved by offline discussion.", "author": "NealSun96", "createdAt": "2020-02-07T21:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNjgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNzY2Mg==", "url": "https://github.com/apache/helix/pull/731#discussion_r376127662", "bodyText": "Is this necessary to special handling? following constructTrie logic will not handle the root sharding key?", "author": "junkaixue", "createdAt": "2020-02-06T22:54:10Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -37,12 +39,14 @@\n \n   private final TrieNode _rootNode;\n \n-  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n-  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n-  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n-  // will therefore be implemented later.\n-  public TrieRoutingData(TrieNode rootNode) {\n-    _rootNode = rootNode;\n+  public TrieRoutingData(Map<String, List<String>> routingData) throws InvalidRoutingDataException {\n+    if (isRootShardingKey(routingData)) {", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2Mjg2OQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376162869", "bodyText": "Yes it is necessary. TrieNodes' fields are mostly final, such as _isLeaf. Therefore, we always need to determine if the root node is leaf or not (and construct it) before any of the constructTrie code runs. Since it's always the first step, performing a check here is the cleanest way in my opinion.", "author": "NealSun96", "createdAt": "2020-02-07T00:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNzY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyODA1NQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376128055", "bodyText": "Better not call variables directly.", "author": "junkaixue", "createdAt": "2020-02-06T22:55:10Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode._children.get(keySection);", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MTU1OA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376641558", "bodyText": "Agree with @dasahcc . Should have an api getChildren().", "author": "huizhilu", "createdAt": "2020-02-07T22:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyODA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0NjA0MQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376646041", "bodyText": "Adding accessors.", "author": "NealSun96", "createdAt": "2020-02-07T22:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyODA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2MzU2OQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376063569", "bodyText": "shardingKeys.get(0).equals(\"\") could be shardingKeys.get(0).isEmpty()", "author": "huizhilu", "createdAt": "2020-02-06T20:26:30Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MzcwNA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376163704", "bodyText": "Sure.", "author": "NealSun96", "createdAt": "2020-02-07T00:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2MzU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA4MDg1MA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376080850", "bodyText": "substring(0, 1) -> charAt(0) could improve performance O(N) -> O(1) and less string objects.", "author": "huizhilu", "createdAt": "2020-02-06T21:04:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2NDQ5OA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376164498", "bodyText": "But if I want to compare it with a String, I'd have to cast it back into a string. I'm not sure if this is worth sacrificing cleanness of the code.", "author": "NealSun96", "createdAt": "2020-02-07T00:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA4MDg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MTM0NQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376171345", "bodyText": "I meant, you can compare two chars (DELIMITER could have a char variable?) so you don't have to create this single string each time. But actually, considering overall performance, it is still like O(7 * N) vs O(2 * N). So, up to you.", "author": "huizhilu", "createdAt": "2020-02-07T01:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA4MDg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NjEwNw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376666107", "bodyText": "I really don't think this justifies it. There's barely any cost. Thanks for the suggestion, though. Resolving the conversation.", "author": "NealSun96", "createdAt": "2020-02-08T00:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA4MDg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MjU5MQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376142591", "bodyText": "It seems helpful if new TrieNode could create the HashMap so you don't have to always create and pass an empty map? I would hide the map data structure from external view.", "author": "huizhilu", "createdAt": "2020-02-06T23:36:53Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode._children.get(keySection);\n+\n+        // If the key section is not the last section yet, perform the following\n+        while (nextDelimiterIndex > 0) {\n+          // If the node is already a leaf node, the current sharding key is invalid\n+          if (nextNode != null && nextNode._isLeaf) {\n+            throw new InvalidRoutingDataException(shardingKey.substring(0, nextDelimiterIndex)\n+                + \" is already a sharding key. \" + shardingKey + \" cannot be a sharding key.\");\n+          } else if (nextNode == null) {\n+            nextNode = new TrieNode(new HashMap<>(), shardingKey.substring(0, nextDelimiterIndex),\n+                false, \"\");\n+            curNode._children.put(keySection, nextNode);\n+          }\n+          prevDelimiterIndex = nextDelimiterIndex;\n+          nextDelimiterIndex = shardingKey.indexOf(DELIMITER, prevDelimiterIndex + 1);\n+          keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+              nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+          curNode = nextNode;\n+          nextNode = curNode._children.get(keySection);\n+        }\n+\n+        // If the last node already exists, it's a part of another sharding key, making the current\n+        // sharding key invalid\n+        if (nextNode != null) {\n+          throw new InvalidRoutingDataException(shardingKey\n+              + \" is a part of another sharding key, therefore it cannot be a sharding key.\");\n+        }\n+        nextNode = new TrieNode(new HashMap<>(), shardingKey, true, entry.getKey());", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2NTE2Ng==", "url": "https://github.com/apache/helix/pull/731#discussion_r376165166", "bodyText": "I think it's more flexible to allow the direct assignment of children. If somehow we need to assign existing children in the future as we are constructing, taking the parameter out now means I have to modify the constructor later.", "author": "NealSun96", "createdAt": "2020-02-07T00:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MjU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0ODkxMw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376148913", "bodyText": "isLeaf is not necessary in the constructor because you can expose an API isLeaf() to check if this node has children or not, right? Save one field for the TrieNode.", "author": "huizhilu", "createdAt": "2020-02-06T23:58:29Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode._children.get(keySection);\n+\n+        // If the key section is not the last section yet, perform the following\n+        while (nextDelimiterIndex > 0) {\n+          // If the node is already a leaf node, the current sharding key is invalid\n+          if (nextNode != null && nextNode._isLeaf) {\n+            throw new InvalidRoutingDataException(shardingKey.substring(0, nextDelimiterIndex)\n+                + \" is already a sharding key. \" + shardingKey + \" cannot be a sharding key.\");\n+          } else if (nextNode == null) {\n+            nextNode = new TrieNode(new HashMap<>(), shardingKey.substring(0, nextDelimiterIndex),", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2NjAyMQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376166021", "bodyText": "There was a discussion I had with @narendly before about this. I thought that we didn't need _isLeaf here also, but _isLeaf is a meaningful field. For any trie node, it's either a leaf or not; for regular trie nodes, whether it's a leaf is unrelated to whether it has children. For our trie, it just happens that _isLeaf == children.isEmpty(), but it doesn't render the field useless - it's still a property of a trie node.", "author": "NealSun96", "createdAt": "2020-02-07T01:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0ODkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3NDExNg==", "url": "https://github.com/apache/helix/pull/731#discussion_r376174116", "bodyText": "If a node is leaf, then it shouldn't have any children.  This is enough.  In my opinion, _isLeaf is redundant.", "author": "huizhilu", "createdAt": "2020-02-07T01:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0ODkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NzMwOQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376667309", "bodyText": "_isLeaf is a key field for any trie node. If we are treating this data structure as a trie, a trie node should have such a property. Also, it just happens that _isLeaf == children.isEmpty() for now - this might change in the future.", "author": "NealSun96", "createdAt": "2020-02-08T00:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0ODkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM4MTI1Mg==", "url": "https://github.com/apache/helix/pull/731#discussion_r377381252", "bodyText": "Per offline discussion, I renamed the fields to reduce confusion on their functionalities.", "author": "NealSun96", "createdAt": "2020-02-10T23:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0ODkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDg0NA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376150844", "bodyText": "You can check this first isEmpty(), throw exception before you add DELIMITER to the shardingKey. Could've saved one string object for this loop.", "author": "huizhilu", "createdAt": "2020-02-07T00:05:07Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2Njc5Mg==", "url": "https://github.com/apache/helix/pull/731#discussion_r376166792", "bodyText": "That is untrue, because shardingKey could be either empty or \"/\". Adding delimiter first makes the logic easy to understand - after adding the delimiter, all logic applies to sharding keys with leading delimiters.", "author": "NealSun96", "createdAt": "2020-02-07T01:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0NDQ2Nw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376644467", "bodyText": "Behaviour has changed. No leading slash is an exception now. Closing conversation.", "author": "NealSun96", "createdAt": "2020-02-07T22:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MjgzNw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376152837", "bodyText": "For this part, it seems you can just get a string array shardingKey.split(DELIMITER)  and use the array? This would reduce time complexity. Notice that string.substring() takes O(N) time.", "author": "huizhilu", "createdAt": "2020-02-07T00:12:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2NzM2Nw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376167367", "bodyText": "That was the original design but note on line 191 that I'll need to obtain the \"prefix sharding key\", or in other words \"the section of sharding key that has been processed\". If I do the split approach, I'll need to reconstruct the \"prefix sharding key\", which costs more time.", "author": "NealSun96", "createdAt": "2020-02-07T01:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MjgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTE0Mw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376245143", "bodyText": "@NealSun96\nCan you do a quick analysis here - one method would require the reader/traverser to keep track of the nodes it's traversing and construct a path, and the implementation you're providing here is \"caching\" the path in the name. Which one makes more sense? Think in the context of what kind of operations would be called more frequently - as in is there a real benefit to caching?", "author": "narendly", "createdAt": "2020-02-07T07:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MjgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU4NDAzNQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376584035", "bodyText": "After an offline discussion with  @pkuwm , I've realized that the \"storing sharding keys prefixes in nodes\" approach is not as good as I used to think, and therefore I'm opening up a discussion on this. A quick analysis of two approaches:\n\n\n\n\nStore sharding key prefixes in nodes (\"/a\", \"/a/b\", \"/a/b/c\")\nStore sharding key sections in nodes (\"/a\", \"/b\", \"/c\")\n\n\n\n\nEfficiency to return full sharding keys in getAllMappingUnderPath\nO(1) accessing operations\nO(N) joining operations; O(1) to add/remove key sections while traversing the trie; O(N) size map used to keep track whether a trie node has been visited\n\n\nMemory consumption to store the keys in nodes\nStrictly larger than the combined sizes of all keys (usually several times larger)\nEqual or lower than the combined sizes of all keys\n\n\nEfficiency to construct the trie\nO(N) to get the prefix substring of sharding keys\nO(1) since we already have the key sections\n\n\n\nSeveral additional points:\n\nThe efficiency of getAllMappingUnderPath is more important than the efficiency of construction for two reasons: 1. the frequency of getAllMappingUnderPath is likely higher than construction; 2. the efficiency of getAllMappingUnderPath matters more because it's serving a REST endpoint.\nIn the discussion with @pkuwm , we came to a conclusion: if we are storing sharding keys prefixes, why don't we just use a hashmap instead, because a hashmap consumes less memory? This is false because hashmap provides slower string searching than trie. Even if sharding key prefixs are stored, a trie is still better.\n\nPlease provide your opinion and I'll make a decision based on the discussion. Thanks! @dasahcc @narendly @pkuwm", "author": "NealSun96", "createdAt": "2020-02-07T20:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MjgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MDA1OA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376640058", "bodyText": "Thank you all for the discussion. A rare conclusion: no one has a strong opinion. Therefore it'll be kept as is.", "author": "NealSun96", "createdAt": "2020-02-07T22:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MjgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1NzQ4OQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376157489", "bodyText": "With the complete implementation of TrieRoutingData, you should be able to implement the logic here, correct?", "author": "narendly", "createdAt": "2020-02-07T00:30:00Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -179,10 +179,10 @@ public void refreshRoutingData(String namespace) {\n     }\n \n     if (_routingDataMap != null) {\n-      MetadataStoreRoutingData newRoutingData =\n-          new TrieRoutingData(new TrieRoutingData.TrieNode(null, null, false, null));\n+//      MetadataStoreRoutingData newRoutingData =\n+//          new TrieRoutingData(new TrieRoutingData.TrieNode(null, null, false, null));\n       // TODO call constructRoutingData() here.\n-      _routingDataMap.put(namespace, newRoutingData);\n+//      _routingDataMap.put(namespace, newRoutingData);", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MDEyMQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376160121", "bodyText": "Null check on routingData?", "author": "narendly", "createdAt": "2020-02-07T00:39:48Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -37,12 +39,14 @@\n \n   private final TrieNode _rootNode;\n \n-  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n-  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n-  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n-  // will therefore be implemented later.\n-  public TrieRoutingData(TrieNode rootNode) {\n-    _rootNode = rootNode;\n+  public TrieRoutingData(Map<String, List<String>> routingData) throws InvalidRoutingDataException {\n+    if (isRootShardingKey(routingData)) {", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2ODI3MQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376168271", "bodyText": "Good point, I should do null check and also empty list check.", "author": "NealSun96", "createdAt": "2020-02-07T01:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MDEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTM1OQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376245359", "bodyText": "\"There exist\"", "author": "narendly", "createdAt": "2020-02-07T07:23:34Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxNTE0NA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376515144", "bodyText": "Ack", "author": "NealSun96", "createdAt": "2020-02-07T17:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTQ0OA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376245448", "bodyText": "constructs", "author": "narendly", "createdAt": "2020-02-07T07:23:54Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxNTM1Mg==", "url": "https://github.com/apache/helix/pull/731#discussion_r376515352", "bodyText": "Ack", "author": "NealSun96", "createdAt": "2020-02-07T17:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTgwNw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376245807", "bodyText": "Why is it possible to have two different cases? What does it mean to have just \"/\", and what does it mean to have an empty string?", "author": "narendly", "createdAt": "2020-02-07T07:25:32Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNDI1Nw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376624257", "bodyText": "As discussed, the \"missing leading slash\" case is treated as invalid. Similar other checks are put in place.", "author": "NealSun96", "createdAt": "2020-02-07T21:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NjYzOA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376246638", "bodyText": "\"the following\" ? Can you spell it out?", "author": "narendly", "createdAt": "2020-02-07T07:28:23Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode._children.get(keySection);\n+\n+        // If the key section is not the last section yet, perform the following", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxODA2OQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376518069", "bodyText": "This comment is really trying to explain the while condition only. The detailed logic of the loop is explained further inside the loop. Modifying this comment to not make it seem incomplete.", "author": "NealSun96", "createdAt": "2020-02-07T17:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NjYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NzEyNg==", "url": "https://github.com/apache/helix/pull/731#discussion_r376247126", "bodyText": "Do you think you could add more descriptions about each test case?", "author": "narendly", "createdAt": "2020-02-07T07:30:12Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/TestTrieRoutingData.java", "diffHunk": "@@ -19,146 +19,180 @@\n  * under the License.\n  */\n \n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.NoSuchElementException;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n import org.testng.Assert;\n import org.testng.annotations.Test;\n \n public class TestTrieRoutingData {\n-  // TODO: add constructor related tests after constructor is finished\n+  private TrieRoutingData _trie;\n \n   @Test\n-  public void testGetAllMappingUnderPathFromRoot() {\n-    TrieRoutingData trie = constructTestTrie();\n-    Map<String, String> result = trie.getAllMappingUnderPath(\"/\");\n-    Assert.assertEquals(result.size(), 4);\n-    Assert.assertEquals(result.get(\"/b/c/d\"), \"realmAddressD\");\n-    Assert.assertEquals(result.get(\"/b/c/e\"), \"realmAddressE\");\n-    Assert.assertEquals(result.get(\"/b/f\"), \"realmAddressF\");\n-    Assert.assertEquals(result.get(\"/g\"), \"realmAddressG\");\n+  public void testConstructionSpecialCase() {", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NjMwNA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376666304", "bodyText": "Ack", "author": "NealSun96", "createdAt": "2020-02-08T00:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NzEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MjUyMw==", "url": "https://github.com/apache/helix/pull/731#discussion_r376172523", "bodyText": "Nit, routingData.size() is enough.", "author": "huizhilu", "createdAt": "2020-02-07T01:27:14Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {", "originalCommit": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NjQ0OA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376666448", "bodyText": "Ack", "author": "NealSun96", "createdAt": "2020-02-08T00:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MjUyMw=="}], "type": "inlineReview"}, {"oid": "b5078724e1583828b9ffbc9801cf423ba0560cf9", "url": "https://github.com/apache/helix/commit/b5078724e1583828b9ffbc9801cf423ba0560cf9", "message": "Address all comments", "committedDate": "2020-02-08T00:18:37Z", "type": "commit"}, {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195", "url": "https://github.com/apache/helix/commit/d3e433f8b2547da01e0522ca5a718fd92e535195", "message": "fix nit", "committedDate": "2020-02-08T00:27:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDI0MA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376730240", "bodyText": "Nit: say exactly what's happening. It helps to put yourself in the user's shoes - \"routingData cannot be null or empty!\".", "author": "narendly", "createdAt": "2020-02-08T19:54:03Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -37,15 +39,26 @@\n \n   private final TrieNode _rootNode;\n \n-  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n-  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n-  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n-  // will therefore be implemented later.\n-  public TrieRoutingData(TrieNode rootNode) {\n-    _rootNode = rootNode;\n+  public TrieRoutingData(Map<String, List<String>> routingData) throws InvalidRoutingDataException {\n+    if (routingData == null || routingData.isEmpty()) {\n+      throw new InvalidRoutingDataException(\"Missing routing data\");", "originalCommit": "d3e433f8b2547da01e0522ca5a718fd92e535195", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMDM2OA==", "url": "https://github.com/apache/helix/pull/731#discussion_r377210368", "bodyText": "Ack", "author": "NealSun96", "createdAt": "2020-02-10T17:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDI1OA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376730258", "bodyText": "Nit: also add that delimiter means \"/\"", "author": "narendly", "createdAt": "2020-02-08T19:54:42Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -37,15 +39,26 @@\n \n   private final TrieNode _rootNode;\n \n-  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n-  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n-  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n-  // will therefore be implemented later.\n-  public TrieRoutingData(TrieNode rootNode) {\n-    _rootNode = rootNode;\n+  public TrieRoutingData(Map<String, List<String>> routingData) throws InvalidRoutingDataException {\n+    if (routingData == null || routingData.isEmpty()) {\n+      throw new InvalidRoutingDataException(\"Missing routing data\");\n+    }\n+\n+    if (isRootShardingKey(routingData)) {\n+      Map.Entry<String, List<String>> entry = routingData.entrySet().iterator().next();\n+      _rootNode = new TrieNode(Collections.emptyMap(), \"/\", true, entry.getKey());\n+    } else {\n+      _rootNode = new TrieNode(new HashMap<>(), \"/\", false, \"\");\n+      constructTrie(routingData);\n+    }\n   }\n \n-  public Map<String, String> getAllMappingUnderPath(String path) {\n+  public Map<String, String> getAllMappingUnderPath(String path) throws IllegalArgumentException {\n+    if (path.isEmpty() || !path.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided path is empty or does not have a leading delimiter: \" + path);", "originalCommit": "d3e433f8b2547da01e0522ca5a718fd92e535195", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMDk4Ng==", "url": "https://github.com/apache/helix/pull/731#discussion_r377210986", "bodyText": "I'll replace the \"delimiter\" text with the actual delimiter character to make it more clear.", "author": "NealSun96", "createdAt": "2020-02-10T17:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDI2OQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376730269", "bodyText": "delimiter = \"/\"", "author": "narendly", "createdAt": "2020-02-08T19:55:00Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -58,20 +71,26 @@ public TrieRoutingData(TrieNode rootNode) {\n     nodeStack.push(curNode);\n     while (!nodeStack.isEmpty()) {\n       curNode = nodeStack.pop();\n-      if (curNode._isLeaf) {\n-        resultMap.put(curNode._name, curNode._realmAddress);\n+      if (curNode.isLeaf()) {\n+        resultMap.put(curNode.getName(), curNode.getRealmAddress());\n       } else {\n-        for (TrieNode child : curNode._children.values()) {\n+        for (TrieNode child : curNode.getChildren().values()) {\n           nodeStack.push(child);\n         }\n       }\n     }\n     return resultMap;\n   }\n \n-  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+  public String getMetadataStoreRealm(String path)\n+      throws IllegalArgumentException, NoSuchElementException {\n+    if (path.isEmpty() || !path.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided path is empty or does not have a leading delimiter: \" + path);", "originalCommit": "d3e433f8b2547da01e0522ca5a718fd92e535195", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMzI0OQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r377213249", "bodyText": "ditto", "author": "NealSun96", "createdAt": "2020-02-10T17:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQxNA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376730414", "bodyText": "Nit: \"X cannot be a sharding key since one of its parent nodes (parent) is already a sharding key!\"", "author": "narendly", "createdAt": "2020-02-08T19:57:14Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -88,72 +107,174 @@ public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n    */\n   private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n       throws NoSuchElementException {\n-    if (path.equals(DELIMITER) || path.equals(\"\")) {\n-      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+    if (path.equals(DELIMITER)) {\n+      if (findLeafAlongPath && !_rootNode.isLeaf()) {\n         throw new NoSuchElementException(\"No leaf node found along the path. Path: \" + path);\n       }\n       return _rootNode;\n     }\n \n-    String[] splitPath;\n-    if (path.substring(0, 1).equals(DELIMITER)) {\n-      splitPath = path.substring(1).split(DELIMITER, 0);\n-    } else {\n-      splitPath = path.split(DELIMITER, 0);\n-    }\n-\n     TrieNode curNode = _rootNode;\n-    if (findLeafAlongPath && curNode._isLeaf) {\n+    if (findLeafAlongPath && curNode.isLeaf()) {\n       return curNode;\n     }\n-    Map<String, TrieNode> curChildren = curNode._children;\n-    for (String pathSection : splitPath) {\n+    Map<String, TrieNode> curChildren = curNode.getChildren();\n+    for (String pathSection : path.substring(1).split(DELIMITER, 0)) {\n       curNode = curChildren.get(pathSection);\n       if (curNode == null) {\n         throw new NoSuchElementException(\n             \"The provided path is missing from the trie. Path: \" + path);\n       }\n-      if (findLeafAlongPath && curNode._isLeaf) {\n+      if (findLeafAlongPath && curNode.isLeaf()) {\n         return curNode;\n       }\n-      curChildren = curNode._children;\n+      curChildren = curNode.getChildren();\n     }\n     if (findLeafAlongPath) {\n       throw new NoSuchElementException(\"No leaf node found along the path. Path: \" + path);\n     }\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1 && shardingKeys.get(0).equals(DELIMITER);\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * constructs the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      if (entry.getValue().isEmpty()) {\n+        throw new InvalidRoutingDataException(\n+            \"Realm address does not have associating sharding keys: \" + entry.getKey());\n+      }\n+      for (String shardingKey : entry.getValue()) {\n+        // Missing leading delimiter is invalid\n+        if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"Sharding key does not have a leading delimiter: \" + shardingKey);\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exist other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode.getChildren().get(keySection);\n+\n+        // If the key section is not the last section yet, go in the loop; if the key section is the\n+        // last section, exit\n+        while (nextDelimiterIndex > 0) {\n+          // If the node is already a leaf node, the current sharding key is invalid; if the node\n+          // doesn't exist, construct a node and continue\n+          if (nextNode != null && nextNode.isLeaf()) {\n+            throw new InvalidRoutingDataException(shardingKey.substring(0, nextDelimiterIndex)\n+                + \" is already a sharding key. \" + shardingKey + \" cannot be a sharding key.\");", "originalCommit": "d3e433f8b2547da01e0522ca5a718fd92e535195", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxNjUxOA==", "url": "https://github.com/apache/helix/pull/731#discussion_r377216518", "bodyText": "I think this is actually less clear for users that do not know the implementation details of TrieRoutingData. Saying \"parent nodes\" does not directly state the problem with \"X\" being a sharding key; saying \"a substring of X is already a sharding key\" is more clear.", "author": "NealSun96", "createdAt": "2020-02-10T17:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxNzY5Nw==", "url": "https://github.com/apache/helix/pull/731#discussion_r377217697", "bodyText": "I can explain further in that direction to make it clearer, such as \"having a substring being a sharding key makes the path ambiguous\".", "author": "NealSun96", "createdAt": "2020-02-10T17:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1NjE3MA==", "url": "https://github.com/apache/helix/pull/731#discussion_r377256170", "bodyText": "Using \"parent key\" as the clearer terminology for exception messages.", "author": "NealSun96", "createdAt": "2020-02-10T19:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQ0Ng==", "url": "https://github.com/apache/helix/pull/731#discussion_r376730446", "bodyText": "Nit: make this clearer - see above", "author": "narendly", "createdAt": "2020-02-08T19:57:52Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -88,72 +107,174 @@ public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n    */\n   private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n       throws NoSuchElementException {\n-    if (path.equals(DELIMITER) || path.equals(\"\")) {\n-      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+    if (path.equals(DELIMITER)) {\n+      if (findLeafAlongPath && !_rootNode.isLeaf()) {\n         throw new NoSuchElementException(\"No leaf node found along the path. Path: \" + path);\n       }\n       return _rootNode;\n     }\n \n-    String[] splitPath;\n-    if (path.substring(0, 1).equals(DELIMITER)) {\n-      splitPath = path.substring(1).split(DELIMITER, 0);\n-    } else {\n-      splitPath = path.split(DELIMITER, 0);\n-    }\n-\n     TrieNode curNode = _rootNode;\n-    if (findLeafAlongPath && curNode._isLeaf) {\n+    if (findLeafAlongPath && curNode.isLeaf()) {\n       return curNode;\n     }\n-    Map<String, TrieNode> curChildren = curNode._children;\n-    for (String pathSection : splitPath) {\n+    Map<String, TrieNode> curChildren = curNode.getChildren();\n+    for (String pathSection : path.substring(1).split(DELIMITER, 0)) {\n       curNode = curChildren.get(pathSection);\n       if (curNode == null) {\n         throw new NoSuchElementException(\n             \"The provided path is missing from the trie. Path: \" + path);\n       }\n-      if (findLeafAlongPath && curNode._isLeaf) {\n+      if (findLeafAlongPath && curNode.isLeaf()) {\n         return curNode;\n       }\n-      curChildren = curNode._children;\n+      curChildren = curNode.getChildren();\n     }\n     if (findLeafAlongPath) {\n       throw new NoSuchElementException(\"No leaf node found along the path. Path: \" + path);\n     }\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1 && shardingKeys.get(0).equals(DELIMITER);\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * constructs the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      if (entry.getValue().isEmpty()) {\n+        throw new InvalidRoutingDataException(\n+            \"Realm address does not have associating sharding keys: \" + entry.getKey());\n+      }\n+      for (String shardingKey : entry.getValue()) {\n+        // Missing leading delimiter is invalid\n+        if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"Sharding key does not have a leading delimiter: \" + shardingKey);\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exist other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode.getChildren().get(keySection);\n+\n+        // If the key section is not the last section yet, go in the loop; if the key section is the\n+        // last section, exit\n+        while (nextDelimiterIndex > 0) {\n+          // If the node is already a leaf node, the current sharding key is invalid; if the node\n+          // doesn't exist, construct a node and continue\n+          if (nextNode != null && nextNode.isLeaf()) {\n+            throw new InvalidRoutingDataException(shardingKey.substring(0, nextDelimiterIndex)\n+                + \" is already a sharding key. \" + shardingKey + \" cannot be a sharding key.\");\n+          } else if (nextNode == null) {\n+            nextNode = new TrieNode(new HashMap<>(), shardingKey.substring(0, nextDelimiterIndex),\n+                false, \"\");\n+            curNode.addChild(keySection, nextNode);\n+          }\n+          prevDelimiterIndex = nextDelimiterIndex;\n+          nextDelimiterIndex = shardingKey.indexOf(DELIMITER, prevDelimiterIndex + 1);\n+          keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+              nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+          curNode = nextNode;\n+          nextNode = curNode.getChildren().get(keySection);\n+        }\n+\n+        // If the last node already exists, it's a part of another sharding key, making the current\n+        // sharding key invalid\n+        if (nextNode != null) {\n+          throw new InvalidRoutingDataException(shardingKey\n+              + \" is a part of another sharding key, therefore it cannot be a sharding key.\");", "originalCommit": "d3e433f8b2547da01e0522ca5a718fd92e535195", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxNjYxMw==", "url": "https://github.com/apache/helix/pull/731#discussion_r377216613", "bodyText": "Ditto above.", "author": "NealSun96", "createdAt": "2020-02-10T17:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQ4OQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376730489", "bodyText": "Let's use {} instead of \"+\" for Loggers.", "author": "narendly", "createdAt": "2020-02-08T19:58:36Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -170,20 +170,21 @@ public void refreshRoutingData(String namespace) {\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);", "originalCommit": "d3e433f8b2547da01e0522ca5a718fd92e535195", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIyMTM1Mg==", "url": "https://github.com/apache/helix/pull/731#discussion_r377221352", "bodyText": "Ok.", "author": "NealSun96", "createdAt": "2020-02-10T17:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDU0NQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376730545", "bodyText": "As we discussed offline, consider renaming this to \"rawRoutingData\" and add some comment here because it could be confusing later.", "author": "narendly", "createdAt": "2020-02-08T19:59:44Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -170,20 +170,21 @@ public void refreshRoutingData(String namespace) {\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n+      return;\n     }\n \n     try {\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      Map<String, List<String>> routingData = _routingDataReaderMap.get(namespace).getRoutingData();", "originalCommit": "d3e433f8b2547da01e0522ca5a718fd92e535195", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxODExNQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r377218115", "bodyText": "Right, changing it.", "author": "NealSun96", "createdAt": "2020-02-10T17:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDU5MQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r376730591", "bodyText": "Null check  on _realmToShardingKeysMap since method is not necessarily threadsafe.", "author": "narendly", "createdAt": "2020-02-08T20:00:48Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -170,20 +170,21 @@ public void refreshRoutingData(String namespace) {\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n+      return;\n     }\n \n     try {\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      Map<String, List<String>> routingData = _routingDataReaderMap.get(namespace).getRoutingData();\n+      _realmToShardingKeysMap.put(namespace, routingData);", "originalCommit": "d3e433f8b2547da01e0522ca5a718fd92e535195", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDcxNA==", "url": "https://github.com/apache/helix/pull/731#discussion_r376730714", "bodyText": "As a matter of fact, let's do this check right in the beginning of this method.\nIf any of the maps (_routingZkAddressMap, _routingZkAddressMap, _routingDataMap) are null, just return.", "author": "narendly", "createdAt": "2020-02-08T20:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIzMjc4OQ==", "url": "https://github.com/apache/helix/pull/731#discussion_r377232789", "bodyText": "Question: if the method is not threadsafe, is a null check at beginning really enough? For example, by the time it gets to _routingDataMap.put(), _routingDataMap can still be null, same thing applies to _realmToShardingKeysMap.\nOn the other hand, all map fields are final and they are initialized to be not null. In what situations will they actually become null?", "author": "NealSun96", "createdAt": "2020-02-10T18:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1MDI3Ng==", "url": "https://github.com/apache/helix/pull/731#discussion_r377250276", "bodyText": "Interesting Java gotcha! Thank you for explaining offline @narendly !", "author": "NealSun96", "createdAt": "2020-02-10T18:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDg1Ng==", "url": "https://github.com/apache/helix/pull/731#discussion_r376730856", "bodyText": "Not necessarily. There are a few different places where you could get this exception, so your log could be misleading.\nYou should do LOG.error(\"Failed to refresh cached routing data for namespace {}, namespace, e); This propagates the correct exception message.", "author": "narendly", "createdAt": "2020-02-08T20:04:23Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -170,20 +170,21 @@ public void refreshRoutingData(String namespace) {\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n+      return;\n     }\n \n     try {\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      Map<String, List<String>> routingData = _routingDataReaderMap.get(namespace).getRoutingData();\n+      _realmToShardingKeysMap.put(namespace, routingData);\n+\n+      if (_routingDataMap != null) {\n+        MetadataStoreRoutingData newRoutingData = new TrieRoutingData(routingData);\n+        _routingDataMap.put(namespace, newRoutingData);\n+      }\n     } catch (InvalidRoutingDataException e) {\n-      LOG.error(\"Failed to get routing data for namespace: \" + namespace + \"!\");\n+      LOG.error(\"Routing data construction has failed for namespace: \" + namespace + \"!\");", "originalCommit": "d3e433f8b2547da01e0522ca5a718fd92e535195", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIzMzA5Mg==", "url": "https://github.com/apache/helix/pull/731#discussion_r377233092", "bodyText": "Good point. I wasn't sure how to phrase this message because there are multiple reasons. I'll use your advised one.", "author": "NealSun96", "createdAt": "2020-02-10T18:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDg1Ng=="}], "type": "inlineReview"}, {"oid": "964b45fde44404203e3f186698d1ec07cea8bc0c", "url": "https://github.com/apache/helix/commit/964b45fde44404203e3f186698d1ec07cea8bc0c", "message": "modify exception messages and naming", "committedDate": "2020-02-10T18:23:30Z", "type": "commit"}, {"oid": "6f9b1fe29aac3503df78d0784439be118e113841", "url": "https://github.com/apache/helix/commit/6f9b1fe29aac3503df78d0784439be118e113841", "message": "change exception messages and add null checks", "committedDate": "2020-02-10T19:06:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2MDM2NA==", "url": "https://github.com/apache/helix/pull/731#discussion_r377260364", "bodyText": "Nit: usually passing the error itself is enough:\nLOG.error(\"Failed to refresh cached routing data for namespace {}\", namespace, e);", "author": "narendly", "createdAt": "2020-02-10T19:10:57Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -156,34 +156,42 @@ public boolean deleteShardingKey(String namespace, String realm, String sharding\n \n   /**\n    * Callback for updating the cached routing data.\n-   * Note: this method should not synchronize on the class or the map. We do not want namespaces blocking each other.\n+   * Note: this method should not synchronize on the class or the map. We do not want namespaces\n+   * blocking each other.\n    * Threadsafe map is used for _realmToShardingKeysMap.\n-   * The global consistency of the in-memory routing data is not a requirement (eventual consistency is enough).\n+   * The global consistency of the in-memory routing data is not a requirement (eventual consistency\n+   * is enough).\n    * @param namespace\n    */\n   @Override\n   public void refreshRoutingData(String namespace) {\n-    // Safe to ignore the callback if routingDataMap is null.\n+    // Safe to ignore the callback if any of the mapping is null.\n     // If routingDataMap is null, then it will be populated by the constructor anyway\n     // If routingDataMap is not null, then it's safe for the callback function to update it\n+    if (_routingZkAddressMap == null || _routingDataMap == null || _realmToShardingKeysMap == null) {\n+      LOG.error(\"Construction is not completed! \");\n+      return;\n+    }\n \n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n-      LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n+      LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: {}\",\n+          namespace);\n+      return;\n     }\n \n     try {\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      Map<String, List<String>> rawRoutingData =\n+          _routingDataReaderMap.get(namespace).getRoutingData();\n+      _realmToShardingKeysMap.put(namespace, rawRoutingData);\n+\n+      MetadataStoreRoutingData routingData = new TrieRoutingData(rawRoutingData);\n+      _routingDataMap.put(namespace, routingData);\n     } catch (InvalidRoutingDataException e) {\n-      LOG.error(\"Failed to get routing data for namespace: \" + namespace + \"!\");\n+      LOG.error(\"Failed to refresh cached routing data for namespace {}, exception: {}\", namespace,\n+          e.getMessage());", "originalCommit": "6f9b1fe29aac3503df78d0784439be118e113841", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4OTEwMg==", "url": "https://github.com/apache/helix/pull/731#discussion_r377289102", "bodyText": "Changed.", "author": "NealSun96", "createdAt": "2020-02-10T20:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2MDM2NA=="}], "type": "inlineReview"}, {"oid": "47281ba31a23615e644fbfda489ea400f0e3e3b3", "url": "https://github.com/apache/helix/commit/47281ba31a23615e644fbfda489ea400f0e3e3b3", "message": "change logging parameters", "committedDate": "2020-02-10T20:07:52Z", "type": "commit"}, {"oid": "0418ffa310372602e471f1042cbd86ea16aad1b8", "url": "https://github.com/apache/helix/commit/0418ffa310372602e471f1042cbd86ea16aad1b8", "message": "rename TrieNode fields to reduce confusion", "committedDate": "2020-02-10T23:36:58Z", "type": "commit"}]}