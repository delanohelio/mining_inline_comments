{"pr_number": 1468, "pr_title": "Implement deleteTask API", "pr_createdAt": "2020-10-15T19:48:22Z", "pr_url": "https://github.com/apache/helix/pull/1468", "timeline": [{"oid": "13cbfffeadeae7a56c06eecfebbec1f9b5412944", "url": "https://github.com/apache/helix/commit/13cbfffeadeae7a56c06eecfebbec1f9b5412944", "message": "Implement deleteTask API\n\nIn this commit, the changes that needed to delete an existing\ntask from a general job has been added to TaskDriver.\nAlso, the changes that needed on the controller side to drop\nthe task from the instances and removing the task from the\ncontext have been implemented.", "committedDate": "2020-10-15T19:46:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk2NjkyNw==", "url": "https://github.com/apache/helix/pull/1468#discussion_r506966927", "bodyText": "Helix exception? While illegal argument exception is caught.", "author": "huizhilu", "createdAt": "2020-10-17T17:49:00Z", "path": "helix-core/src/test/java/org/apache/helix/integration/task/TestAddDeleteTask.java", "diffHunk": "@@ -89,9 +100,16 @@ public void testAddJobMissing() throws Exception {\n     } catch (IllegalArgumentException e) {\n       // Helix Exception is expected because job config is missing\n     }\n+\n+    try {\n+      _driver.deleteTask(workflowName, jobName, task.getId());\n+      Assert.fail(\"Exception is expected because job config is missing\");\n+    } catch (IllegalArgumentException e) {\n+      // Helix Exception is expected because job config is missing", "originalCommit": "13cbfffeadeae7a56c06eecfebbec1f9b5412944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk2OTUzNw==", "url": "https://github.com/apache/helix/pull/1468#discussion_r506969537", "bodyText": "Good catch. Let me fix the comments.", "author": "alirezazamani", "createdAt": "2020-10-17T18:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk2NjkyNw=="}], "type": "inlineReview"}, {"oid": "41b49d2420fee177a9015bedc7e9d6b3c90579b6", "url": "https://github.com/apache/helix/commit/41b49d2420fee177a9015bedc7e9d6b3c90579b6", "message": "Change the comments", "committedDate": "2020-10-19T03:10:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwMjY3Mw==", "url": "https://github.com/apache/helix/pull/1468#discussion_r509802673", "bodyText": "I think we introduced these \"new\" path patterns for the purpose of refactoring TF structure. While I believe this is still the future design, I agree that we want to make them work first. Can we add a TODO here?", "author": "jiajunwang", "createdAt": "2020-10-22T00:01:56Z", "path": "helix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java", "diffHunk": "@@ -169,17 +170,16 @@\n         \"/{clusterName}/PROPERTYSTORE/TaskRebalancer/{workflowName}/Context\"); // Old\n     // WorkflowContext\n     // path\n-    addEntry(PropertyType.TASK_CONFIG_ROOT, 1, \"/{clusterName}/CONFIGS/TASK\");\n-    addEntry(PropertyType.WORKFLOW_CONFIG, 3,\n-        \"/{clusterName}/CONFIGS/TASK/{workflowName}/{workflowName}\");\n-    addEntry(PropertyType.JOB_CONFIG, 4,\n-        \"/{clusterName}/CONFIGS/TASK/{workflowName}/{jobName}/{jobName}\");\n+    addEntry(PropertyType.TASK_CONFIG_ROOT, 1, \"/{clusterName}/CONFIGS/RESOURCE\");", "originalCommit": "b25e9a6a81976fe4403064f4be4d871d0c1735e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NzQ4NQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r510297485", "bodyText": "Added a TODO in case we want to change it in the future. I think for performance reasons, we want to keep the structure as it is.", "author": "alirezazamani", "createdAt": "2020-10-22T16:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwMjY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwMjgwOA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r509802808", "bodyText": "nit, taskSeqNumber?", "author": "jiajunwang", "createdAt": "2020-10-22T00:02:27Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobContext.java", "diffHunk": "@@ -313,4 +313,12 @@ public long getExecutionStartTime() {\n     }\n     return map;\n   }\n+\n+  /**\n+   * Remove the task from the map field of job context.\n+   * @param taskNumber\n+   */\n+  public void removeTask(int taskNumber) {", "originalCommit": "b25e9a6a81976fe4403064f4be4d871d0c1735e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwMzYzNA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r509803634", "bodyText": "Moreover, according to the naming convention of this class, I guess we are using \"partition\" instead of \"task\".", "author": "jiajunwang", "createdAt": "2020-10-22T00:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwMjgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NzUzMA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r510297530", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-10-22T16:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwMjgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxMDg1MA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r509810850", "bodyText": "ass => add", "author": "jiajunwang", "createdAt": "2020-10-22T00:29:39Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -478,4 +482,61 @@ private TaskAssignmentCalculator getAssignmentCalculator(JobConfig jobConfig,\n     }\n     return new FixedTargetTaskAssignmentCalculator(assignableInstanceManager);\n   }\n+\n+  /**\n+   * Find the tasks that have been removed from job config, ass them to tasksToDrop. If task's", "originalCommit": "b25e9a6a81976fe4403064f4be4d871d0c1735e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NzU4MA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r510297580", "bodyText": "Fixed.", "author": "alirezazamani", "createdAt": "2020-10-22T16:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxMDg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxMzI4NQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r509813285", "bodyText": "I think the calculation should be done in the taskAssignmentCal, so that allPartitions won't contains the removed tasks at all. Then the following logic is simple and we only match the current assignment with the expected task list. Anything mismatch, then we add or remove accordingly.", "author": "jiajunwang", "createdAt": "2020-10-22T00:39:00Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -238,6 +238,10 @@ private ResourceAssignment computeResourceMapping(String jobResource,\n \n     updateInstanceToTaskAssignmentsFromContext(jobCtx, currentInstanceToTaskAssignments);\n \n+    // Find the tasks that have been removed form the config, add them to TasksToDrop\n+    handleDeletedTasks(jobResource, jobCfg, jobCtx, currentInstanceToTaskAssignments, tasksToDrop,", "originalCommit": "b25e9a6a81976fe4403064f4be4d871d0c1735e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMzMzUzNA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r510333534", "bodyText": "The issue with moving it as part of taskAssignmentCal.getAllTaskPartitions is that the outcome of that function would have some effect on the job and workflow status. We need to consider all the tasks unless it is completely DROPPED from the current state, then we can make sure that currentState has been cleaned up and it will not cause quota leakage later. So I think it makes more sense to have the task in allPartitions, and when we are sure that currentState is DROPPED then we just remove the task from context. In the future pipelines then it will not have any effect because tasks would not show up in allPartitions.", "author": "alirezazamani", "createdAt": "2020-10-22T17:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxMzI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUxMDE3OA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r510510178", "bodyText": "High-levelly, my motivation is to simplify the logic here. The dispatcher logic looks like a series of if-else blocks. And there are redundencies and very easy for devs to introduce bugs. I understand it cannot be done in one day. So what I suggested is just want to prevent us adding another if-else block to the already long list.\n\n\nit seems that allPartitions is not used by \"addGivenUpPartitions\" which is after your new method. So no matter how you modify the allPartitions list, it will impact the existing use cases anyway.\nThe only exception is the empty target partitions check. If the user removed all the tasks, then I think it is OK we mark this job as failure. Or we just prevent user from deleting all tasks. This is not our target use case.\n\n\nOn my understanding, handleDeletedTasks is mainly for 3 tasks.\n\n\n\n\nAdd the deleted tasks to tasksToDrop.\nFirst of all, I do believe we need a generic logic to check for all dropping tasks in a single place. It is a major issue if we have this kind of logic everywhere in different methods. One example of the pain is that you actually need to change the comment of tasksToDrop to fit this new usage.\nBut that is nice to have for now.\nBack to this case, it shall be easy to fill the tasksToDrop list immediately after we have the filtered allPartitions list, I think. Or you can let the taskAssignmentCal to do it. Based on it's name, I guess the original design is to let this class finish such a work.\n\n\nRemove the deleted tasks from allPartitions.\nAs I mentioned, this can be done in the taskAssignmentCal logic.\n\n\nRemove the deleted tasks from jobContext.\nI haven't fully understand this part. But I don't see there is a way to remove a task from the jobContext before. So I guess the previous assumption is that a task can be cancelled but not removed directly. Then is it safe to allow removing the task now? It seems to trigger race condition. For example, if a task has been running, and it is requested to be removed at the same time. We deleted it from the context directly. What will happen? Is it safer just to cancel it?\nI might not understand the workflow here completely. Feel free to set up a meeting so we can discuss about it.", "author": "jiajunwang", "createdAt": "2020-10-22T23:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxMzI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY4NDMwNA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r511684304", "bodyText": "As we discussed offline, moved the detection part in taskAssignmentCalculator. Now it works for targeted jobs as well in case the target DB shrinks. Now the logic is more general.", "author": "alirezazamani", "createdAt": "2020-10-26T01:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxMzI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxNzI2Nw==", "url": "https://github.com/apache/helix/pull/1468#discussion_r509817267", "bodyText": "Simple code is what I like : ) It also applies to addTask().\nif (workflowContext != null && jobContext != null (maybe remove the 2nd condition?)) {\n TaskState jobState = workflowContext.getJobState(nameSpaceJobName);\n  if (jobState != null && ILLEGAL_JOB_STATES_FOR_TASK_MODIFICATION.contains(jobState)) {\n      throw new HelixException(\"Job \" + nameSpaceJobName\n          + \" is in illegal state for task deletion. Job State is \" + jobState);\n  }\n}\ndeleteTaskFromJobConfig(workflowName, jobName, taskID, endTime);", "author": "jiajunwang", "createdAt": "2020-10-22T00:53:24Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskDriver.java", "diffHunk": "@@ -607,14 +615,101 @@ public void addTask(String workflowName, String jobName, TaskConfig taskConfig,\n     addTaskToJobConfig(workflowName, jobName, taskConfig, endTime);\n   }\n \n+  /**\n+   * Delete an existing task from a running (IN-PROGRESS) job or a job which has not started yet.\n+   * Timeout for this operation is the default timeout which is 5 minutes.\n+   * {@link TaskDriver#DEFAULT_TIMEOUT}\n+   * Note1: Task cannot be deleted from the job which is in an illegal state. Task can be deleted\n+   * from the job if the job is in-progress or it has not started yet.\n+   * Note2: The tasks can only be deleted from non-targeted jobs.\n+   * Note3: In case of timeout exception, it is the user's responsibility to check whether the task\n+   * has been successfully deleted or not.\n+   * Note4: timeout is the time that this API checks whether the task has been successfully deleted\n+   * or not.\n+   * @param workflowName\n+   * @param jobName\n+   * @param taskID\n+   * @throws TimeoutException if the outcome of the task deletion is unknown and cannot be verified\n+   * @throws IllegalArgumentException if the inputs are invalid\n+   * @throws HelixException if the job is not in the states to accept a new task or if there is any\n+   *           issue in updating jobConfig.\n+   */\n+  public void deleteTask(String workflowName, String jobName, String taskID)\n+      throws TimeoutException, InterruptedException {\n+    deleteTask(workflowName, jobName, taskID, DEFAULT_TIMEOUT);\n+  }\n+\n+  /**\n+   * Delete an existing task from a running (IN-PROGRESS) job or a job which has not started yet.\n+   * Note1: Task cannot be deleted from the job which is in an illegal state. Task can be deleted\n+   * from the job if the job is in-progress or it has not started yet.\n+   * Note2: The tasks can only be deleted from non-targeted jobs.\n+   * Note3: In case of timeout exception, it is the user's responsibility to check whether the task\n+   * has been successfully deleted or not.\n+   * Note4: timeout is the time that this API checks whether the task has been successfully deleted\n+   * or not.\n+   * @param workflowName\n+   * @param jobName\n+   * @param taskID\n+   * @param timeoutMs\n+   * @throws TimeoutException if the outcome of the task deletion is unknown and cannot be verified\n+   * @throws IllegalArgumentException if the inputs are invalid\n+   * @throws HelixException if the job is not in the states to accept a new task or if there is any\n+   *           issue in updating jobConfig.\n+   */\n+  public void deleteTask(String workflowName, String jobName, String taskID, long timeoutMs)\n+      throws TimeoutException, InterruptedException {\n+    long endTime = System.currentTimeMillis() + timeoutMs;\n+\n+    String nameSpaceJobName = TaskUtil.getNamespacedJobName(workflowName, jobName);\n+    JobConfig jobConfig = getJobConfig(nameSpaceJobName);\n+    if (jobConfig == null) {\n+      throw new IllegalArgumentException(\"Job \" + nameSpaceJobName + \" config does not exist!\");\n+    }\n+\n+    TaskConfig taskConfig = null;\n+    Map<String, TaskConfig> allTaskConfigs = jobConfig.getTaskConfigMap();\n+    for (Map.Entry<String, TaskConfig> entry : allTaskConfigs.entrySet()) {\n+      if (entry.getKey().equals(taskID)) {\n+        taskConfig = entry.getValue();\n+      }\n+    }\n+\n+    validateConfigsForTaskModifications(workflowName, jobName, taskConfig);\n+\n+    WorkflowContext workflowContext = getWorkflowContext(workflowName);", "originalCommit": "b25e9a6a81976fe4403064f4be4d871d0c1735e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM0MzcwMA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r510343700", "bodyText": "Very good suggestion. Changed in both add and delete. Thanks.", "author": "alirezazamani", "createdAt": "2020-10-22T17:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxNzI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxODMzMQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r509818331", "bodyText": "I haven't reviewed these code completely. But my guess is that this method is different from addTaskToJobConfig() for only the updater part. All the rest are the same. Could you please merge?", "author": "jiajunwang", "createdAt": "2020-10-22T00:57:16Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskDriver.java", "diffHunk": "@@ -699,6 +798,73 @@ private void addTaskToJobConfig(String workflowName, String jobName, TaskConfig\n     throw new TimeoutException(\"An unexpected issue happened while task being added to the job!\");\n   }\n \n+  /**\n+   * A helper method which deletes an existing task from the job config and verifies if task is\n+   * deleted from the context by the controller.\n+   * @param workflowName\n+   * @param jobName\n+   * @param taskID\n+   * @param endTime\n+   * @throws InterruptedException\n+   * @throws TimeoutException\n+   */\n+  private void deleteTaskFromJobConfig(String workflowName, String jobName, String taskID,", "originalCommit": "b25e9a6a81976fe4403064f4be4d871d0c1735e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM1MzM4MQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r510353381", "bodyText": "So they seem to be similar but they are different. Aside from the logs and updaters which are different, in one of them we add a task to config and then check if it is being added to context by the controller by polling. In another one, we delete from config and make sure it is being deleted by the controller from the context by polling. Anyways following your comment I did a few simplifications on add API. Thanks.", "author": "alirezazamani", "createdAt": "2020-10-22T17:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxODMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NzgyOQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r510487829", "bodyText": "Logs can be changed to \"failed to update the task from the job...\", etc.\nThe updater can be changed to be a parameter.\nAs for the additional check you mentioned, is it necessary? Since the updater is done, task modification has to be finished in the ZK. If the rebalancer runs slow, then the timeout will fail the operation even the task has been added/removed correctly.\nEven we do want to wait, it is still doable by passing a verifier-style callback and then we can merge the private methods.\nOr, alternatively, you can check the jobContext in the upper layer method after calls this generic task modification method. Note that since you are calling the accessor 2 times for the jobcontext and workflowcontext, there is no guarantee that the result is consistent anyway. So moving the jobcontext check outside will not introduce more issues.", "author": "jiajunwang", "createdAt": "2020-10-22T22:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxODMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5MTcxOQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r510491719", "bodyText": "Ok. Yeah, we do want to check before returning the call. However, I think your comment makes sense. Let me try that and see how it goes.", "author": "alirezazamani", "createdAt": "2020-10-22T22:22:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxODMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY4NDAzOQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r511684039", "bodyText": "Done. Merged the update part in one method.", "author": "alirezazamani", "createdAt": "2020-10-26T01:51:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxODMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4MzY0MA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r511083640", "bodyText": "\"from\"", "author": "junkaixue", "createdAt": "2020-10-23T18:54:51Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -238,6 +238,10 @@ private ResourceAssignment computeResourceMapping(String jobResource,\n \n     updateInstanceToTaskAssignmentsFromContext(jobCtx, currentInstanceToTaskAssignments);\n \n+    // Find the tasks that have been removed form the config, add them to TasksToDrop", "originalCommit": "b97c6a569a49ab50c5e1a0bc2a009f6fd02a7787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2Mjk5Mw==", "url": "https://github.com/apache/helix/pull/1468#discussion_r513062993", "bodyText": "Fixed.", "author": "alirezazamani", "createdAt": "2020-10-27T22:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4MzY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA5NDYyNA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r511094624", "bodyText": "We dont need to loop everything. We can do\nSet partitionRemoved = new HashSet<>(jobContext.getPartitionSet());\npartitionRemoved.removeAll(jobConfig.getTaskConfigMap().keySet());\nIn this case, we save some checks and some loops.", "author": "junkaixue", "createdAt": "2020-10-23T19:14:08Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -478,4 +482,61 @@ private TaskAssignmentCalculator getAssignmentCalculator(JobConfig jobConfig,\n     }\n     return new FixedTargetTaskAssignmentCalculator(assignableInstanceManager);\n   }\n+\n+  /**\n+   * Find the tasks that have been removed from job config, add them to tasksToDrop. If task's\n+   * currentState and pending message have been removed, delete the task from job context.\n+   * @param jobName\n+   * @param jobConfig\n+   * @param jobContext\n+   * @param currentInstanceToTaskAssignments\n+   * @param tasksToDrop\n+   * @param currStateOutput\n+   * @param allPartitions\n+   */\n+  private void handleDeletedTasks(String jobName, JobConfig jobConfig, JobContext jobContext,\n+      Map<String, SortedSet<Integer>> currentInstanceToTaskAssignments,\n+      Map<String, Set<Integer>> tasksToDrop, CurrentStateOutput currStateOutput,\n+      Set<Integer> allPartitions) {\n+    if (TaskUtil.isGenericTaskJob(jobConfig)) {\n+      // Get all partitions existed in the context\n+      Set<Integer> contextPartitions = jobContext.getPartitionSet();\n+      // Check whether the tasks have been deleted from jobConfig\n+      for (Integer partition : contextPartitions) {\n+        String partitionID = jobContext.getTaskIdForPartition(partition);\n+        if (!jobConfig.getTaskConfigMap().containsKey(partitionID)) {", "originalCommit": "b97c6a569a49ab50c5e1a0bc2a009f6fd02a7787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2NjU3OQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r513066579", "bodyText": "I moved this logic to taskAssignmentCalculator class. However, we cannot avoid some of the loops because we need to get the partitionID using jobContext.getTaskIdForPartition(partition) and find the one which has been removed from the config.\nWe basically find the partitionID in the context and see if such taskID existed in the config it not now.\n  @Override\n  public Set<Integer> getRemovedPartitions(JobConfig jobConfig, JobContext jobContext, Set<Integer> allPartitions) {\n    // Get all partitions existed in the context\n    Set<Integer> deletedPartitions = new HashSet<>();\n    // Check whether the tasks have been deleted from jobConfig\n    for (Integer partition : jobContext.getPartitionSet()) {\n      String partitionID = jobContext.getTaskIdForPartition(partition);\n      if (!jobConfig.getTaskConfigMap().containsKey(partitionID)) {\n        deletedPartitions.add(partition);\n      }\n    }\n    return deletedPartitions;\n  }", "author": "alirezazamani", "createdAt": "2020-10-27T22:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA5NDYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA5NTc4MQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r511095781", "bodyText": "Can we do some pre process work? Make it as task -> list instances. So we dont have to loop all the instances again and again.", "author": "junkaixue", "createdAt": "2020-10-23T19:15:28Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -478,4 +482,61 @@ private TaskAssignmentCalculator getAssignmentCalculator(JobConfig jobConfig,\n     }\n     return new FixedTargetTaskAssignmentCalculator(assignableInstanceManager);\n   }\n+\n+  /**\n+   * Find the tasks that have been removed from job config, add them to tasksToDrop. If task's\n+   * currentState and pending message have been removed, delete the task from job context.\n+   * @param jobName\n+   * @param jobConfig\n+   * @param jobContext\n+   * @param currentInstanceToTaskAssignments\n+   * @param tasksToDrop\n+   * @param currStateOutput\n+   * @param allPartitions\n+   */\n+  private void handleDeletedTasks(String jobName, JobConfig jobConfig, JobContext jobContext,\n+      Map<String, SortedSet<Integer>> currentInstanceToTaskAssignments,\n+      Map<String, Set<Integer>> tasksToDrop, CurrentStateOutput currStateOutput,\n+      Set<Integer> allPartitions) {\n+    if (TaskUtil.isGenericTaskJob(jobConfig)) {\n+      // Get all partitions existed in the context\n+      Set<Integer> contextPartitions = jobContext.getPartitionSet();\n+      // Check whether the tasks have been deleted from jobConfig\n+      for (Integer partition : contextPartitions) {\n+        String partitionID = jobContext.getTaskIdForPartition(partition);\n+        if (!jobConfig.getTaskConfigMap().containsKey(partitionID)) {\n+          boolean hasCurrentState = false;\n+          for (Map.Entry<String, SortedSet<Integer>> instanceToPartitions : currentInstanceToTaskAssignments", "originalCommit": "b97c6a569a49ab50c5e1a0bc2a009f6fd02a7787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3NTYzNQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r513075635", "bodyText": "I think that would make sense. However, I changed the structure of the code. If we assume that there won't be many removed tasks, then my new code would make more sense. In the new structure, if there is no task being removed, we don't loop at all. So overall, if not much task is being removed (which is mostly the case), the current implementation would be faster.", "author": "alirezazamani", "createdAt": "2020-10-27T22:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA5NTc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI5NDMxMQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r512294311", "bodyText": "The method is private, we may not bother to add the param with empty descriptions? I suggest we just remove them.", "author": "huizhilu", "createdAt": "2020-10-26T21:58:49Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -478,4 +485,52 @@ private TaskAssignmentCalculator getAssignmentCalculator(JobConfig jobConfig,\n     }\n     return new FixedTargetTaskAssignmentCalculator(assignableInstanceManager);\n   }\n+\n+  /**\n+   * Add the removed task to tasksToDrop to drop its current state. If task's currentState and\n+   * pending message have been removed, delete the task from job context.\n+   * @param jobName", "originalCommit": "59054675fbfe93752e5db090ece47a0a26a8c018", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDg3Nw==", "url": "https://github.com/apache/helix/pull/1468#discussion_r513060877", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-10-27T22:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI5NDMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI5NDk3Nw==", "url": "https://github.com/apache/helix/pull/1468#discussion_r512294977", "bodyText": "If !hasCurrentState is also added to this if condition, when it is true, we don't need to new Partition() for later checks?", "author": "huizhilu", "createdAt": "2020-10-26T22:00:03Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -478,4 +485,52 @@ private TaskAssignmentCalculator getAssignmentCalculator(JobConfig jobConfig,\n     }\n     return new FixedTargetTaskAssignmentCalculator(assignableInstanceManager);\n   }\n+\n+  /**\n+   * Add the removed task to tasksToDrop to drop its current state. If task's currentState and\n+   * pending message have been removed, delete the task from job context.\n+   * @param jobName\n+   * @param jobContext\n+   * @param currentInstanceToTaskAssignments\n+   * @param tasksToDrop\n+   * @param currStateOutput\n+   * @param allPartitions\n+   */\n+  private void handleDeletedTasks(String jobName, JobContext jobContext,\n+      Map<String, SortedSet<Integer>> currentInstanceToTaskAssignments,\n+      Map<String, Set<Integer>> tasksToDrop, CurrentStateOutput currStateOutput,\n+      Set<Integer> allPartitions, Set<Integer> removedPartitions) {\n+    for (Integer partition : removedPartitions) {\n+      boolean hasCurrentState = false;\n+      for (Map.Entry<String, SortedSet<Integer>> instanceToPartitions : currentInstanceToTaskAssignments\n+          .entrySet()) {\n+        String instance = instanceToPartitions.getKey();\n+        if (instanceToPartitions.getValue().contains(partition)) {\n+          LOG.info(\n+              \"Task {} should be removed from job {}. Current State should be removed from instance {} as well!\",\n+              partition, jobName, instance);\n+          if (!tasksToDrop.containsKey(instance)) {\n+            tasksToDrop.put(instance, new HashSet<>());\n+          }\n+          tasksToDrop.get(instance).add(partition);\n+\n+          // If current state or pending message have not been removed yet, we should not\n+          // delete the context and leave unclean currentState\n+          String pName = pName(jobName, partition);\n+          if (currStateOutput.getCurrentState(jobName, new Partition(pName), instance) != null", "originalCommit": "59054675fbfe93752e5db090ece47a0a26a8c018", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MjEyOA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r513062128", "bodyText": "No. In order to get currentState, we need to create a partition with pName. Later on for the deletion, we just need an integer/partition number to delete it from context.", "author": "alirezazamani", "createdAt": "2020-10-27T22:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI5NDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0NjY2OA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r513846668", "bodyText": "nit: can probably be condensed to one line.", "author": "NealSun96", "createdAt": "2020-10-29T00:54:13Z", "path": "helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java", "diffHunk": "@@ -123,6 +124,17 @@ public FixedTargetTaskAssignmentCalculator(AssignableInstanceManager assignableI\n     return taskPartitions;\n   }\n \n+  @Override\n+  public Set<Integer> getRemovedPartitions(JobConfig jobConfig, JobContext jobContext, Set<Integer> allPartitions) {\n+    Set<Integer> deletedPartitions = new HashSet<>();\n+    for (Integer partition : jobContext.getPartitionSet()) {\n+      if (!allPartitions.contains(partition)) {\n+        deletedPartitions.add(partition);\n+      }\n+    }\n+    return deletedPartitions;", "originalCommit": "ac7a787a807249d2eddf9df9bd6d8c7dddd671d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxMjQ3NQ==", "url": "https://github.com/apache/helix/pull/1468#discussion_r514612475", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-10-29T22:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0NjY2OA=="}], "type": "inlineReview"}, {"oid": "a5e7e6476876abd5c89438e7390e7d6ae942bc26", "url": "https://github.com/apache/helix/commit/a5e7e6476876abd5c89438e7390e7d6ae942bc26", "message": "Implement deleteTask API\n\nIn this commit, the changes that needed to delete an existing\ntask from a general job has been added to TaskDriver.\nAlso, the changes that needed on the controller side to drop\nthe task from the instances and removing the task from the\ncontext have been implemented.", "committedDate": "2020-10-30T05:58:49Z", "type": "commit"}, {"oid": "a5f1c41f43915dbbc438df2554e1096a2ac7c340", "url": "https://github.com/apache/helix/commit/a5f1c41f43915dbbc438df2554e1096a2ac7c340", "message": "Change the comments", "committedDate": "2020-10-30T05:58:49Z", "type": "commit"}, {"oid": "f3204001e03c025e4cc03ad0d837943ba7358737", "url": "https://github.com/apache/helix/commit/f3204001e03c025e4cc03ad0d837943ba7358737", "message": "Fix Task related paths", "committedDate": "2020-10-30T05:58:49Z", "type": "commit"}, {"oid": "df3beba55774db6e4d449ea13a8866ba9be31613", "url": "https://github.com/apache/helix/commit/df3beba55774db6e4d449ea13a8866ba9be31613", "message": "Address the comments", "committedDate": "2020-10-30T05:58:49Z", "type": "commit"}, {"oid": "36802bd3d42809fd641e3b6151c885a2b661b3bf", "url": "https://github.com/apache/helix/commit/36802bd3d42809fd641e3b6151c885a2b661b3bf", "message": "Address comments", "committedDate": "2020-10-30T05:58:49Z", "type": "commit"}, {"oid": "e9429e219367e1832a79781879b98b24c2c96069", "url": "https://github.com/apache/helix/commit/e9429e219367e1832a79781879b98b24c2c96069", "message": "Address comments", "committedDate": "2020-10-30T05:58:49Z", "type": "commit"}, {"oid": "7a490a44b4c5584f6c59f3ac1c2a970454275363", "url": "https://github.com/apache/helix/commit/7a490a44b4c5584f6c59f3ac1c2a970454275363", "message": "new comments being addressed", "committedDate": "2020-10-30T05:58:49Z", "type": "commit"}, {"oid": "fc331157fbbf3b1935af075f4ca11cfcbcb58c99", "url": "https://github.com/apache/helix/commit/fc331157fbbf3b1935af075f4ca11cfcbcb58c99", "message": "Address comment", "committedDate": "2020-10-30T05:58:49Z", "type": "commit"}, {"oid": "fc331157fbbf3b1935af075f4ca11cfcbcb58c99", "url": "https://github.com/apache/helix/commit/fc331157fbbf3b1935af075f4ca11cfcbcb58c99", "message": "Address comment", "committedDate": "2020-10-30T05:58:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwNTcwNg==", "url": "https://github.com/apache/helix/pull/1468#discussion_r516205706", "bodyText": "We can save the loop operation by set operation as:\nSet deletedPartitions = new HashSet<>(jobContext.getPartitionSet());\ndeletedPartitions.removeAll(jobConfig.getTaskConfigMap().keySet());", "author": "junkaixue", "createdAt": "2020-11-02T19:29:22Z", "path": "helix-core/src/main/java/org/apache/helix/task/GenericTaskAssignmentCalculator.java", "diffHunk": "@@ -95,6 +97,20 @@\n     return placement.computeMapping(jobCfg, jobContext, partitionNums, resourceId);\n   }\n \n+  @Override\n+  public Set<Integer> getRemovedPartitions(JobConfig jobConfig, JobContext jobContext, Set<Integer> allPartitions) {\n+    // Get all partitions existed in the context\n+    Set<Integer> deletedPartitions = new HashSet<>();\n+    // Check whether the tasks have been deleted from jobConfig\n+    for (Integer partition : jobContext.getPartitionSet()) {\n+      String partitionID = jobContext.getTaskIdForPartition(partition);\n+      if (!jobConfig.getTaskConfigMap().containsKey(partitionID)) {\n+        deletedPartitions.add(partition);\n+      }\n+    }", "originalCommit": "fc331157fbbf3b1935af075f4ca11cfcbcb58c99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2NTM0NA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r516265344", "bodyText": "I will sync up with you on this offline.", "author": "alirezazamani", "createdAt": "2020-11-02T21:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwNTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzUzNg==", "url": "https://github.com/apache/helix/pull/1468#discussion_r516273536", "bodyText": "Synced offline. Resolved.", "author": "alirezazamani", "createdAt": "2020-11-02T21:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwNTcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMjUzNw==", "url": "https://github.com/apache/helix/pull/1468#discussion_r516212537", "bodyText": "Since this is same implementation as generic one, can we have this implementation as default implement in abstract class? Then if we need difference implementation, let override it.", "author": "junkaixue", "createdAt": "2020-11-02T19:42:47Z", "path": "helix-core/src/main/java/org/apache/helix/task/ThreadCountBasedTaskAssignmentCalculator.java", "diffHunk": "@@ -146,6 +147,20 @@ public ThreadCountBasedTaskAssignmentCalculator(TaskAssigner taskAssigner,\n     return taskAssignment;\n   }\n \n+  @Override\n+  public Set<Integer> getRemovedPartitions(JobConfig jobConfig, JobContext jobContext, Set<Integer> allPartitions) {", "originalCommit": "fc331157fbbf3b1935af075f4ca11cfcbcb58c99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2NTEyNg==", "url": "https://github.com/apache/helix/pull/1468#discussion_r516265126", "bodyText": "I think it is safe to keep it as it is because for other methods the same rule is applied. For example, getAllTaskPartiotions are the same in both classes.", "author": "alirezazamani", "createdAt": "2020-11-02T21:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMjUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzgyMw==", "url": "https://github.com/apache/helix/pull/1468#discussion_r516273823", "bodyText": "As we discussed offline, I will address this.", "author": "alirezazamani", "createdAt": "2020-11-02T21:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMjUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxNTE2MA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r516215160", "bodyText": "Please make sure user understand it. If they have the delay scheduling between tasks or if there are dependencies, this add may fail. Also we do not do \"rollback\" for added tasks.", "author": "junkaixue", "createdAt": "2020-11-02T19:47:35Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskDriver.java", "diffHunk": "@@ -585,36 +585,195 @@ public void addTask(String workflowName, String jobName, TaskConfig taskConfig,\n \n     long endTime = System.currentTimeMillis() + timeoutMs;\n \n-    validateAddTaskConfigs(workflowName, jobName, taskConfig);\n+    validateConfigsForTaskModifications(workflowName, jobName, taskConfig);\n \n     String nameSpaceJobName = TaskUtil.getNamespacedJobName(workflowName, jobName);\n+    JobConfig jobConfig = TaskUtil.getJobConfig(_accessor, nameSpaceJobName);\n+    for (String taskEntry : jobConfig.getMapConfigs().keySet()) {\n+      if (taskEntry.equals(taskConfig.getId())) {\n+        throw new HelixException(\n+            \"Task cannot be added because another task with the same ID already exists!\");\n+      }\n+    }\n+\n     WorkflowContext workflowContext = getWorkflowContext(workflowName);\n     JobContext jobContext = getJobContext(nameSpaceJobName);\n+    // If workflow context or job context is null. It means job has not been started. Hence task can\n+    // be added to the job\n+    if (workflowContext != null && jobContext != null) {\n+      TaskState jobState = workflowContext.getJobState(nameSpaceJobName);\n+      if (jobState != null && ILLEGAL_JOB_STATES_FOR_TASK_MODIFICATION.contains(jobState)) {\n+        throw new HelixException(\"Job \" + nameSpaceJobName\n+            + \" is in illegal state for task addition. Job State is \" + jobState);\n+      }\n+    }\n+\n+    DataUpdater<ZNRecord> updater = currentData -> {\n+      if (currentData != null) {\n+        currentData.setMapField(taskConfig.getId(), taskConfig.getConfigMap());\n+      } else {\n+        LOG.error(\"JobConfig DataUpdater: Fails to update JobConfig. CurrentData is null.\");\n+      }\n+      return currentData;\n+    };\n+\n+    updateTaskInJobConfig(workflowName, jobName, updater);\n+\n+    workflowContext =\n+        _accessor.getProperty(_accessor.keyBuilder().workflowContextZNode(workflowName));\n+    jobContext =\n+        _accessor.getProperty(_accessor.keyBuilder().jobContextZNode(workflowName, jobName));\n+\n     if (workflowContext == null || jobContext == null) {\n-      // Workflow context or job context is null. It means job has not been started. Hence task can\n-      // be added to the job\n-      addTaskToJobConfig(workflowName, jobName, taskConfig, endTime);\n       return;\n     }\n \n-    TaskState jobState = workflowContext.getJobState(nameSpaceJobName);\n+    String taskID = taskConfig.getId();\n+    while (System.currentTimeMillis() <= endTime) {\n+      jobContext =\n+          _accessor.getProperty(_accessor.keyBuilder().jobContextZNode(workflowName, jobName));\n+      workflowContext =\n+          _accessor.getProperty(_accessor.keyBuilder().workflowContextZNode(workflowName));\n+      if (jobContext.getTaskIdPartitionMap().containsKey(taskID)\n+          && workflowContext.getJobState(nameSpaceJobName) == TaskState.IN_PROGRESS) {", "originalCommit": "fc331157fbbf3b1935af075f4ca11cfcbcb58c99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MTE2Mw==", "url": "https://github.com/apache/helix/pull/1468#discussion_r516271163", "bodyText": "Added some java docs note. Thanks.", "author": "alirezazamani", "createdAt": "2020-11-02T21:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxNTE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxNTg1OA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r516215858", "bodyText": "This condition may not be correct. If this is the only task, job can be completed or something.", "author": "junkaixue", "createdAt": "2020-11-02T19:48:58Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskDriver.java", "diffHunk": "@@ -585,36 +585,195 @@ public void addTask(String workflowName, String jobName, TaskConfig taskConfig,\n \n     long endTime = System.currentTimeMillis() + timeoutMs;\n \n-    validateAddTaskConfigs(workflowName, jobName, taskConfig);\n+    validateConfigsForTaskModifications(workflowName, jobName, taskConfig);\n \n     String nameSpaceJobName = TaskUtil.getNamespacedJobName(workflowName, jobName);\n+    JobConfig jobConfig = TaskUtil.getJobConfig(_accessor, nameSpaceJobName);\n+    for (String taskEntry : jobConfig.getMapConfigs().keySet()) {\n+      if (taskEntry.equals(taskConfig.getId())) {\n+        throw new HelixException(\n+            \"Task cannot be added because another task with the same ID already exists!\");\n+      }\n+    }\n+\n     WorkflowContext workflowContext = getWorkflowContext(workflowName);\n     JobContext jobContext = getJobContext(nameSpaceJobName);\n+    // If workflow context or job context is null. It means job has not been started. Hence task can\n+    // be added to the job\n+    if (workflowContext != null && jobContext != null) {\n+      TaskState jobState = workflowContext.getJobState(nameSpaceJobName);\n+      if (jobState != null && ILLEGAL_JOB_STATES_FOR_TASK_MODIFICATION.contains(jobState)) {\n+        throw new HelixException(\"Job \" + nameSpaceJobName\n+            + \" is in illegal state for task addition. Job State is \" + jobState);\n+      }\n+    }\n+\n+    DataUpdater<ZNRecord> updater = currentData -> {\n+      if (currentData != null) {\n+        currentData.setMapField(taskConfig.getId(), taskConfig.getConfigMap());\n+      } else {\n+        LOG.error(\"JobConfig DataUpdater: Fails to update JobConfig. CurrentData is null.\");\n+      }\n+      return currentData;\n+    };\n+\n+    updateTaskInJobConfig(workflowName, jobName, updater);\n+\n+    workflowContext =\n+        _accessor.getProperty(_accessor.keyBuilder().workflowContextZNode(workflowName));\n+    jobContext =\n+        _accessor.getProperty(_accessor.keyBuilder().jobContextZNode(workflowName, jobName));\n+\n     if (workflowContext == null || jobContext == null) {\n-      // Workflow context or job context is null. It means job has not been started. Hence task can\n-      // be added to the job\n-      addTaskToJobConfig(workflowName, jobName, taskConfig, endTime);\n       return;\n     }\n \n-    TaskState jobState = workflowContext.getJobState(nameSpaceJobName);\n+    String taskID = taskConfig.getId();\n+    while (System.currentTimeMillis() <= endTime) {\n+      jobContext =\n+          _accessor.getProperty(_accessor.keyBuilder().jobContextZNode(workflowName, jobName));\n+      workflowContext =\n+          _accessor.getProperty(_accessor.keyBuilder().workflowContextZNode(workflowName));\n+      if (jobContext.getTaskIdPartitionMap().containsKey(taskID)\n+          && workflowContext.getJobState(nameSpaceJobName) == TaskState.IN_PROGRESS) {\n+        return;\n+      }\n \n-    if (ILLEGAL_JOB_STATES_FOR_TASK_MODIFICATION.contains(jobState)) {\n-      throw new HelixException(\n-          String.format(\"Job %s is in illegal state to accept new task. Job State is %s\",\n-              nameSpaceJobName, jobState));\n+      Thread.sleep(DEFAULT_SLEEP);\n+    }\n+    throw new TimeoutException(\"An unexpected issue happened while task being added to the job!\");\n+  }\n+\n+  /**\n+   * Delete an existing task from a running (IN-PROGRESS) job or a job which has not started yet.\n+   * Timeout for this operation is the default timeout which is 5 minutes.\n+   * {@link TaskDriver#DEFAULT_TIMEOUT}\n+   * Note1: Task cannot be deleted from the job which is in an illegal state. Task can be deleted\n+   * from the job if the job is in-progress or it has not started yet.\n+   * Note2: The tasks can only be deleted from non-targeted jobs.\n+   * Note3: In case of timeout exception, it is the user's responsibility to check whether the task\n+   * has been successfully deleted or not.\n+   * Note4: timeout is the time that this API checks whether the task has been successfully deleted\n+   * or not.\n+   * @param workflowName\n+   * @param jobName\n+   * @param taskID\n+   * @throws TimeoutException if the outcome of the task deletion is unknown and cannot be verified\n+   * @throws IllegalArgumentException if the inputs are invalid\n+   * @throws HelixException if the job is not in the states to accept a new task or if there is any\n+   *           issue in updating jobConfig.\n+   */\n+  public void deleteTask(String workflowName, String jobName, String taskID)\n+      throws TimeoutException, InterruptedException {\n+    deleteTask(workflowName, jobName, taskID, DEFAULT_TIMEOUT);\n+  }\n+\n+  /**\n+   * Delete an existing task from a running (IN-PROGRESS) job or a job which has not started yet.\n+   * Note1: Task cannot be deleted from the job which is in an illegal state. Task can be deleted\n+   * from the job if the job is in-progress or it has not started yet.\n+   * Note2: The tasks can only be deleted from non-targeted jobs.\n+   * Note3: In case of timeout exception, it is the user's responsibility to check whether the task\n+   * has been successfully deleted or not.\n+   * Note4: timeout is the time that this API checks whether the task has been successfully deleted\n+   * or not.\n+   * @param workflowName\n+   * @param jobName\n+   * @param taskID\n+   * @param timeoutMs\n+   * @throws TimeoutException if the outcome of the task deletion is unknown and cannot be verified\n+   * @throws IllegalArgumentException if the inputs are invalid\n+   * @throws HelixException if the job is not in the states to accept a new task or if there is any\n+   *           issue in updating jobConfig.\n+   */\n+  public void deleteTask(String workflowName, String jobName, String taskID, long timeoutMs)\n+      throws TimeoutException, InterruptedException {\n+    long endTime = System.currentTimeMillis() + timeoutMs;\n+\n+    String nameSpaceJobName = TaskUtil.getNamespacedJobName(workflowName, jobName);\n+    JobConfig jobConfig = getJobConfig(nameSpaceJobName);\n+    if (jobConfig == null) {\n+      throw new IllegalArgumentException(\"Job \" + nameSpaceJobName + \" config does not exist!\");\n+    }\n+\n+    TaskConfig taskConfig = null;\n+    Map<String, TaskConfig> allTaskConfigs = jobConfig.getTaskConfigMap();\n+    for (Map.Entry<String, TaskConfig> entry : allTaskConfigs.entrySet()) {\n+      if (entry.getKey().equals(taskID)) {\n+        taskConfig = entry.getValue();\n+      }\n+    }\n+\n+    validateConfigsForTaskModifications(workflowName, jobName, taskConfig);\n+\n+    WorkflowContext workflowContext = getWorkflowContext(workflowName);\n+    JobContext jobContext = getJobContext(nameSpaceJobName);\n+    // If workflow context or job context is null. It means job has not been started. Hence task can\n+    // be deleted from the job\n+    if (workflowContext != null && jobContext != null) {\n+      TaskState jobState = workflowContext.getJobState(nameSpaceJobName);\n+      if (jobState != null && ILLEGAL_JOB_STATES_FOR_TASK_MODIFICATION.contains(jobState)) {\n+        throw new HelixException(\"Job \" + nameSpaceJobName\n+            + \" is in illegal state for task deletion. Job State is \" + jobState);\n+      }\n+    }\n+\n+    DataUpdater<ZNRecord> taskRemover = new DataUpdater<ZNRecord>() {\n+      @Override\n+      public ZNRecord update(ZNRecord currentData) {\n+        if (currentData != null) {\n+          Map<String, Map<String, String>> taskMap = currentData.getMapFields();\n+          if (taskMap == null) {\n+            LOG.warn(\"Could not update the jobConfig: \" + jobName + \" Znode MapField is null.\");\n+            return null;\n+          }\n+          Map<String, Map<String, String>> newTaskMap = new HashMap<String, Map<String, String>>();\n+          for (Map.Entry<String, Map<String, String>> entry : taskMap.entrySet()) {\n+            if (!entry.getKey().equals(taskID)) {\n+              newTaskMap.put(entry.getKey(), entry.getValue());\n+            }\n+          }\n+          currentData.setMapFields(newTaskMap);\n+        }\n+        return currentData;\n+      }\n+    };\n+\n+    updateTaskInJobConfig(workflowName, jobName, taskRemover);\n+\n+    workflowContext =\n+        _accessor.getProperty(_accessor.keyBuilder().workflowContextZNode(workflowName));\n+    jobContext =\n+        _accessor.getProperty(_accessor.keyBuilder().jobContextZNode(workflowName, jobName));\n+\n+    if (workflowContext == null || jobContext == null) {\n+      return;\n     }\n-    addTaskToJobConfig(workflowName, jobName, taskConfig, endTime);\n+\n+    while (System.currentTimeMillis() <= endTime) {\n+      jobContext =\n+          _accessor.getProperty(_accessor.keyBuilder().jobContextZNode(workflowName, jobName));\n+      workflowContext =\n+          _accessor.getProperty(_accessor.keyBuilder().workflowContextZNode(workflowName));\n+      if (!jobContext.getTaskIdPartitionMap().containsKey(taskID)\n+          && workflowContext.getJobState(nameSpaceJobName) == TaskState.IN_PROGRESS) {", "originalCommit": "fc331157fbbf3b1935af075f4ca11cfcbcb58c99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2NjU1NA==", "url": "https://github.com/apache/helix/pull/1468#discussion_r516266554", "bodyText": "Yeah, I agree. removed the IN_PROGRESS condition.", "author": "alirezazamani", "createdAt": "2020-11-02T21:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxNTg1OA=="}], "type": "inlineReview"}, {"oid": "dd07ee47e2f429da154b58eb97a3ac9c69609120", "url": "https://github.com/apache/helix/commit/dd07ee47e2f429da154b58eb97a3ac9c69609120", "message": "Address final comments", "committedDate": "2020-11-02T22:32:12Z", "type": "commit"}]}