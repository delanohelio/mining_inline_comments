{"pr_number": 1119, "pr_title": "Add sync() call first for new session handling", "pr_createdAt": "2020-06-24T00:43:24Z", "pr_url": "https://github.com/apache/helix/pull/1119", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTI1OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r444641258", "bodyText": "You mentioned we will have more changes here. Will we make it optional? If so, I think we should have the change in this PR.", "author": "jiajunwang", "createdAt": "2020-06-24T04:45:17Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -185,6 +188,7 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n     if (zkConnection == null) {\n       throw new NullPointerException(\"Zookeeper connection is null!\");\n     }\n+    _syncOnNewSession = true;", "originalCommit": "c5866f0e9daab9af120953672c4c7ae44faf40b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzMTQ5Mw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r446431493", "bodyText": "I would say, let us don't make it optional. This is across session \"sequential consistency\"\n@pkuwm, what is your take?", "author": "kaisun2000", "createdAt": "2020-06-26T22:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg4OTY3NQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447889675", "bodyText": "It is worth making it configurable. For all Helix related component, we can turn it on. Otherwise, every user operation can be delay a little bit for sync. It changed our current behavior for user.", "author": "junkaixue", "createdAt": "2020-06-30T18:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NzA5Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447897092", "bodyText": "This is a good idea.", "author": "kaisun2000", "createdAt": "2020-06-30T18:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNjE4MA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447906180", "bodyText": "Good point. Will add a system property then.", "author": "kaisun2000", "createdAt": "2020-06-30T18:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTUyMQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r444641521", "bodyText": "Please extract a method for sync.", "author": "jiajunwang", "createdAt": "2020-06-24T04:46:24Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {", "originalCommit": "c5866f0e9daab9af120953672c4c7ae44faf40b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzMTA5Mw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r446431093", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-06-26T22:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTY3Ng==", "url": "https://github.com/apache/helix/pull/1119#discussion_r444641676", "bodyText": "remove", "author": "jiajunwang", "createdAt": "2020-06-24T04:47:07Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {\n+                  throw new IllegalStateException(\n+                      \"ZkConnection is in invalid state! Please close this ZkClient and create new client.\");\n+                }\n+                final String syncPath = new String(\"/\");\n+                zkConnection.getZookeeper().sync(syncPath, new AsyncCallback.VoidCallback() {\n+                  @Override\n+                  public void processResult(int rt, String s, Object ctx) {\n+                    //System.out.println(\"sycnOnNewSession with sessionID \" + sessionId + \" async return code:\" + rt);", "originalCommit": "c5866f0e9daab9af120953672c4c7ae44faf40b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0NDI0NA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r444644244", "bodyText": "I think zkConnection is not possible to be null here. Maybe zkConnection.getZookeeper() won't be null as well.\nBut check it is a valid thing to do.\nOne point is that line 1193 should use the same ZK object as it is checked here. Or it might become null later.", "author": "jiajunwang", "createdAt": "2020-06-24T04:57:53Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {", "originalCommit": "c5866f0e9daab9af120953672c4c7ae44faf40b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTEyNA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r444671124", "bodyText": "I don't think this null check is necessary, as zkConnection/zk won't be null once zkClient object is constructed. Only chance zk being null is this zkClient.close() is called, then zk is null. I would say this may be overcheck for nulls.", "author": "huizhilu", "createdAt": "2020-06-24T06:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0NDI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzMDk5Ng==", "url": "https://github.com/apache/helix/pull/1119#discussion_r446430996", "bodyText": "removed.", "author": "kaisun2000", "createdAt": "2020-06-26T22:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0NDI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY2ODI0OQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r444668249", "bodyText": "Remove commented debugging code?", "author": "huizhilu", "createdAt": "2020-06-24T06:18:57Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);", "originalCommit": "c5866f0e9daab9af120953672c4c7ae44faf40b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY2OTg1Nw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r444669857", "bodyText": "Whats the purpose of using such new String(\"/\")? This brings in extra unnecessary string object creation. I think a constant would be nicer SYNC_ROOT_PATH = \"/\".", "author": "huizhilu", "createdAt": "2020-06-24T06:23:06Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {\n+                  throw new IllegalStateException(\n+                      \"ZkConnection is in invalid state! Please close this ZkClient and create new client.\");\n+                }\n+                final String syncPath = new String(\"/\");", "originalCommit": "c5866f0e9daab9af120953672c4c7ae44faf40b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTkyNw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r444671927", "bodyText": "Do we also need to log time on this sync?", "author": "huizhilu", "createdAt": "2020-06-24T06:28:13Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {\n+                  throw new IllegalStateException(\n+                      \"ZkConnection is in invalid state! Please close this ZkClient and create new client.\");\n+                }\n+                final String syncPath = new String(\"/\");\n+                zkConnection.getZookeeper().sync(syncPath, new AsyncCallback.VoidCallback() {\n+                  @Override\n+                  public void processResult(int rt, String s, Object ctx) {\n+                    //System.out.println(\"sycnOnNewSession with sessionID \" + sessionId + \" async return code:\" + rt);\n+                    LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", sessionId,", "originalCommit": "c5866f0e9daab9af120953672c4c7ae44faf40b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4MDY5OQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454680699", "bodyText": "Not applying anymore.", "author": "kaisun2000", "createdAt": "2020-07-14T22:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3NjAxNA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r444676014", "bodyText": "We only call sync but don't check the return code it's successful or not? It doesn't guarantee data is synced. What if sync fails?", "author": "huizhilu", "createdAt": "2020-06-24T06:39:07Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {\n+                  throw new IllegalStateException(\n+                      \"ZkConnection is in invalid state! Please close this ZkClient and create new client.\");\n+                }\n+                final String syncPath = new String(\"/\");\n+                zkConnection.getZookeeper().sync(syncPath, new AsyncCallback.VoidCallback() {\n+                  @Override\n+                  public void processResult(int rt, String s, Object ctx) {\n+                    //System.out.println(\"sycnOnNewSession with sessionID \" + sessionId + \" async return code:\" + rt);\n+                    LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", sessionId,\n+                        rt);", "originalCommit": "c5866f0e9daab9af120953672c4c7ae44faf40b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTcyMg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r445031722", "bodyText": "See my comment to JJ who asked the same question. This one worth further discussion. Either way has its pro and con.  Feel free to comment. Let us make a decision before proceeding.", "author": "kaisun2000", "createdAt": "2020-06-24T16:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3NjAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMTk0Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447311942", "bodyText": "private static?", "author": "jiajunwang", "createdAt": "2020-06-29T23:16:08Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -103,6 +111,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  final String _syncPath = new String(\"/\");", "originalCommit": "7fbd24345d3222483e6532d07295afc0df65af47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMjU4MA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447312580", "bodyText": "Directly do _syncPath = \"/\"; shall help to avoid unnecessary object creating.", "author": "jiajunwang", "createdAt": "2020-06-29T23:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMTk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0MjE5Nw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r457642197", "bodyText": "Could you please also make it static? And follow our naming convention, SYNC_PATH.", "author": "jiajunwang", "createdAt": "2020-07-20T19:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMTk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMzg4MQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447313881", "bodyText": "Please add the callback logic to ZkAsyncCallbacks.java if possible.\n\nThis file has been very large. We shall avoid adding more optional content here.\nZkAsyncCallbacks.java has all the callback defines there. We might be able to avoid some duplicated code if the class is defined there and extending the default callback class.", "author": "jiajunwang", "createdAt": "2020-06-29T23:21:58Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1165,20 +1177,92 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncContext {", "originalCommit": "7fbd24345d3222483e6532d07295afc0df65af47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzM3OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447903378", "bodyText": "Before this pull request, I already had a look. THe reason not to use ZkAsyncCallbacks are two fold:\n1/ Upon failure, the syncContext need to block the current ZkEvent queue. ZkAsyncCallbacks does not block the ZkEvent queue or the _asycThread event queue, but retry from _asyncThread. ---- Thread modeling difference.\n2/ ZkAsyncCallbacks upon session expiration, would still retry. For this SyncContext, it did not retry session expiration. -- Error handling difference.\nEspecially for thread modeling difference, it is hard to merge them together.", "author": "kaisun2000", "createdAt": "2020-06-30T18:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMzg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDExMTc4Ng==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454111786", "bodyText": "I might miss some points here. But if we call DefaultCallback.waitForSuccess() in the new session handling method at where you call the latch.await(), will it do the same trick?\nRegarding the retry logic, it is simple to extend the DefaultCallback.needRetry() in the SyncCallbackHandler.\n\nmake needRetry() protected.\noverride it in the new SyncCallbackHandler class.", "author": "jiajunwang", "createdAt": "2020-07-14T05:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMzg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDM5NQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447314395", "bodyText": "As commented, please check out the other callback implementations. I think the main logic is in common. So we don't need to re-define everything.", "author": "jiajunwang", "createdAt": "2020-06-29T23:23:31Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1165,20 +1177,92 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncContext {\n+    private CountDownLatch _latch;\n+    private AtomicInteger _rc;\n+\n+    public SyncContext(CountDownLatch latch) {\n+      _latch = latch;\n+    }\n+\n+    AtomicInteger getRc() {\n+      return _rc;\n+    }\n+\n+    void setRc(AtomicInteger rc) {\n+      _rc = rc;\n+    }\n+\n+    CountDownLatch getLatch() {\n+      return _latch;\n+    }\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+    while (true) {", "originalCommit": "7fbd24345d3222483e6532d07295afc0df65af47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDY0OQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447314649", "bodyText": "Do we need to do this for every single state listener?\nWe shall only do it once, right?", "author": "jiajunwang", "createdAt": "2020-06-29T23:24:23Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1165,20 +1177,92 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncContext {\n+    private CountDownLatch _latch;\n+    private AtomicInteger _rc;\n+\n+    public SyncContext(CountDownLatch latch) {\n+      _latch = latch;\n+    }\n+\n+    AtomicInteger getRc() {\n+      return _rc;\n+    }\n+\n+    void setRc(AtomicInteger rc) {\n+      _rc = rc;\n+    }\n+\n+    CountDownLatch getLatch() {\n+      return _latch;\n+    }\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+    while (true) {\n+      CountDownLatch latch = new CountDownLatch(1);\n+      SyncContext ctx = new SyncContext(latch);\n+\n+      final ZkConnection zkConnection = (ZkConnection) getConnection();\n+      zkConnection.getZookeeper().sync(_syncPath, new AsyncCallback.VoidCallback() {\n+        @Override\n+        public void processResult(int rt, String s, Object ctx) {\n+          LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", sessionId, rt);\n+          SyncContext synCtx = ((SyncContext) ctx);\n+          synCtx.setRc(new AtomicInteger(rt));\n+          synCtx.getLatch().countDown();\n+        }\n+      }, ctx);\n+\n+      try {\n+        latch.await();\n+      } catch (InterruptedException e) {\n+        LOG.info(\"retrySync latch waiting got interrrupted with sessionId {} \", sessionId);\n+        throw new ZkInterruptedException(e);\n+      }\n+\n+      KeeperException.Code code = KeeperException.Code.get(ctx.getRc().get());\n+      if (code == OK) {\n+        LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+            code);\n+        break;\n+      }\n+      if (code == CONNECTIONLOSS || code == SESSIONMOVED) {\n+        LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and retry\", sessionId,\n+            code);\n+        continue;\n+      }\n+      // Not retryable, including session expiration; but having error. Log the error and return\n+      LOG.error(\n+          \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+          sessionId, code);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              boolean proceed = retrySync(sessionId);", "originalCommit": "7fbd24345d3222483e6532d07295afc0df65af47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5Mjc2MA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447892760", "bodyText": "+1. This is not necessary doing sync for each of listener. Although once the first one retry complete rest will not cost much time, this is redundant logic. We should avoid it.", "author": "junkaixue", "createdAt": "2020-06-30T18:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNTM0NA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447905344", "bodyText": "This is a very good catch. Will change it to be per session, only once.", "author": "kaisun2000", "createdAt": "2020-06-30T18:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5MTgyMw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447891823", "bodyText": "Except these three types of code, is there any other code need to be handled?", "author": "junkaixue", "createdAt": "2020-06-30T18:24:28Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1165,20 +1177,92 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncContext {\n+    private CountDownLatch _latch;\n+    private AtomicInteger _rc;\n+\n+    public SyncContext(CountDownLatch latch) {\n+      _latch = latch;\n+    }\n+\n+    AtomicInteger getRc() {\n+      return _rc;\n+    }\n+\n+    void setRc(AtomicInteger rc) {\n+      _rc = rc;\n+    }\n+\n+    CountDownLatch getLatch() {\n+      return _latch;\n+    }\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+    while (true) {\n+      CountDownLatch latch = new CountDownLatch(1);\n+      SyncContext ctx = new SyncContext(latch);\n+\n+      final ZkConnection zkConnection = (ZkConnection) getConnection();\n+      zkConnection.getZookeeper().sync(_syncPath, new AsyncCallback.VoidCallback() {\n+        @Override\n+        public void processResult(int rt, String s, Object ctx) {\n+          LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", sessionId, rt);\n+          SyncContext synCtx = ((SyncContext) ctx);\n+          synCtx.setRc(new AtomicInteger(rt));\n+          synCtx.getLatch().countDown();\n+        }\n+      }, ctx);\n+\n+      try {\n+        latch.await();\n+      } catch (InterruptedException e) {\n+        LOG.info(\"retrySync latch waiting got interrrupted with sessionId {} \", sessionId);\n+        throw new ZkInterruptedException(e);\n+      }\n+\n+      KeeperException.Code code = KeeperException.Code.get(ctx.getRc().get());\n+      if (code == OK) {\n+        LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+            code);\n+        break;\n+      }\n+      if (code == CONNECTIONLOSS || code == SESSIONMOVED) {", "originalCommit": "7fbd24345d3222483e6532d07295afc0df65af47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNDM4OQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r447904389", "bodyText": "We intentionally not to handle others, including session expiration. See comment on line 1238", "author": "kaisun2000", "createdAt": "2020-06-30T18:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5MTgyMw=="}], "type": "inlineReview"}, {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "url": "https://github.com/apache/helix/commit/2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "message": "minor fix of return value.", "committedDate": "2020-07-14T22:59:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5NjU5NQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454696595", "bodyText": "How about just call it \"zk.autosync.enabled\"", "author": "jiajunwang", "createdAt": "2020-07-14T23:10:54Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/ZkSystemPropertyKeys.java", "diffHunk": "@@ -50,4 +50,14 @@\n    */\n   public static final String ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES =\n       \"zk.serializer.znrecord.write.size.limit.bytes\";\n+\n+  /**\n+   * This property determines the behavior of ZkClient issuing an sync() to server upon new session\n+   * established.\n+   *\n+   * <p>\n+   *   The default value is \"true\" (issuing sync)\n+   */\n+  public static final String ZK_SYNC_UPON_NEWSESSION =", "originalCommit": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczODU5Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454738592", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-07-15T01:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5NjU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMjg2Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454702862", "bodyText": "nit, shall we define the default value of ZK_SYNC_UPON_NEWSESSION in the ZkSystemPropertyKeys instead of hardcode it here?", "author": "jiajunwang", "createdAt": "2020-07-14T23:29:50Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -187,6 +199,10 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n     if (zkConnection == null) {\n       throw new NullPointerException(\"Zookeeper connection is null!\");\n     }\n+\n+    String syncUpOnNewSession = System.getProperty(ZkSystemPropertyKeys.ZK_SYNC_UPON_NEWSESSION, \"true\");", "originalCommit": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczODg3MA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454738870", "bodyText": "This seems not to be the normal pattern. ZkSystemPropertyKeys contains only keys, not default value.", "author": "kaisun2000", "createdAt": "2020-07-15T01:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMjg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0MjkzNg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454742936", "bodyText": "Or can you scratch the code or give an example?", "author": "kaisun2000", "createdAt": "2020-07-15T01:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMjg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc5MjgzOQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454792839", "bodyText": "You are right, the keys class is just for keys. For now, we can just define a default value in this ZkClient.java (at least not hardcode).\nBut moving forward, we discussed that we shall have a property provider that contains the keys and default values and also reads the configuration too.", "author": "jiajunwang", "createdAt": "2020-07-15T05:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMjg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxNjc4MQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454816781", "bodyText": "ZK_AUTOSYNC_ENABLED_DEFAUL is define as \"true\"", "author": "kaisun2000", "createdAt": "2020-07-15T06:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMjg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzM4Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454703382", "bodyText": "private static final String SYNC_PATH = \"/\" ?", "author": "jiajunwang", "createdAt": "2020-07-14T23:31:30Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -105,6 +114,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  final String _syncPath = \"/\";", "originalCommit": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNDE0Mw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454704143", "bodyText": "Can we move it to the ZkAsyncCallbacks file so all the callbacks can be found there?", "author": "jiajunwang", "createdAt": "2020-07-14T23:33:53Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {", "originalCommit": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0MjUzNw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454742537", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-07-15T01:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNDE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTIwMQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454705201", "bodyText": "Pass the current system time or the metric number will be messed up.", "author": "jiajunwang", "createdAt": "2020-07-14T23:37:11Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);", "originalCommit": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0MDMxNw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454740317", "bodyText": "good catch.", "author": "kaisun2000", "createdAt": "2020-07-15T01:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTY3NQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454705675", "bodyText": "Is sync counted as write operations? Just to confirm.\nI know it is kind of happening in order like a write, but does it actually update anything on the server-side? Note if we record the type differently, then the server-side metric and client-side metric will have different numbers.", "author": "jiajunwang", "createdAt": "2020-07-14T23:38:36Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {", "originalCommit": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczOTY1Ng==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454739656", "bodyText": "Sync() does not update any data in the server. However it blocks any read arriving later than it.\nSo your point is that if server metrics does not report it as write, nor should we do it here. Otherwise, both should report it as write?", "author": "kaisun2000", "createdAt": "2020-07-15T01:40:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc5NDEwMw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454794103", "bodyText": "As long as they are treated the same on both sides, I'm good.\nBut it seems to be a read op.", "author": "jiajunwang", "createdAt": "2020-07-15T05:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwMjg2Nw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454802867", "bodyText": "But it seems to be a read op.\n\nDo you mean the server side metrics treat sync() as read, so this one here should be treated as read? Put it another way, we don't record it?\nWhat is your proposal?", "author": "kaisun2000", "createdAt": "2020-07-15T05:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNTQxMQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454805411", "bodyText": "As I said, \"As long as they are treated the same on both sides, I'm good.\"\nNote this is not a major concern for the opensource world. Because the official Zookeeper server does not treat read/write differently. It only applies to the modified ZK version. Could you please double-check and confirm we are recording them with the same type?", "author": "jiajunwang", "createdAt": "2020-07-15T05:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxNDE2Mw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454814163", "bodyText": "Just checked, internal ZK metrics, sync() is treated as read.\nwill change to new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true)", "author": "kaisun2000", "createdAt": "2020-07-15T06:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNjI4Mw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454706283", "bodyText": "Can we move this check to the caller of retrySync()? So the method will do exactly what it is named.", "author": "jiajunwang", "createdAt": "2020-07-14T23:40:18Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);\n+          }\n+        });\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {", "originalCommit": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNzI4OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454737288", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-07-15T01:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNjI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNzU0Mw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454707543", "bodyText": "As mentioned above, the check of _syncOnNewSession can be put here to avoid the unnecessary ZK event.", "author": "jiajunwang", "createdAt": "2020-07-14T23:44:18Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);\n+          }\n+        });\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+\n+    SyncCallbackHandler callbackHandler = new SyncCallbackHandler(sessionId);\n+\n+    final ZkConnection zkConnection = (ZkConnection) getConnection();\n+    final ZooKeeper zk = zkConnection.getZookeeper();\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, _syncPath, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; Log the error and return\n+    LOG.warn(\n+        \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+        sessionId, code);\n+    return false;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n+\n+    _eventThread.send(", "originalCommit": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNzc4Ng==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454707786", "bodyText": "nit, to be compact,\nif (retrySync(sessionId) == false) {\n...\n}", "author": "jiajunwang", "createdAt": "2020-07-14T23:44:58Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);\n+          }\n+        });\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+\n+    SyncCallbackHandler callbackHandler = new SyncCallbackHandler(sessionId);\n+\n+    final ZkConnection zkConnection = (ZkConnection) getConnection();\n+    final ZooKeeper zk = zkConnection.getZookeeper();\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, _syncPath, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; Log the error and return\n+    LOG.warn(\n+        \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+        sessionId, code);\n+    return false;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n+\n+    _eventThread.send(\n+        new ZkEventThread.ZkEvent(\"Sync call before new session event of session \" + sessionId,\n+            sessionId) {\n+          @Override\n+          public void run() throws Exception {\n+            boolean syncStatus = retrySync(sessionId);", "originalCommit": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNjQzMA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454736430", "bodyText": "fixed.", "author": "kaisun2000", "createdAt": "2020-07-15T01:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNzc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454708714", "bodyText": "I think you can just refer the ZkClient object itself in the doAsyncSync call to simplify these codes. Or is there any concern of reading the Zookeeper inside doAsyncSync where it is really used?", "author": "jiajunwang", "createdAt": "2020-07-14T23:48:06Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);\n+          }\n+        });\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+\n+    SyncCallbackHandler callbackHandler = new SyncCallbackHandler(sessionId);\n+\n+    final ZkConnection zkConnection = (ZkConnection) getConnection();", "originalCommit": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwOTc0MQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454709741", "bodyText": "I guess you concern if the Zookeeper object is changed if new session established. But I think we can still keep retrying the sync call, although it is in theory not possible because we stop retrying on session expiring.\nOr is there anything else?", "author": "jiajunwang", "createdAt": "2020-07-14T23:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNTk1Nw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454735957", "bodyText": "You got the point. One zookeeper object one session, This is the invariant.\nFor this fixed session/zookeeper object, if sync() failed, let it be. The next time session reconnected, a new fire all event would be issued and a new retrySync() would be used with the new session.", "author": "kaisun2000", "createdAt": "2020-07-15T01:26:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc5NDU4OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454794588", "bodyText": "You mean it is ok to NOT pass the Zookeeper? The interface is awkward in the current way. You shall be able to get the Zookeeper inside the doSync call.", "author": "jiajunwang", "createdAt": "2020-07-15T05:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwMjEyNg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454802126", "bodyText": "I mean we should pass in ZooKeeper object for doAsyncSync().\nThis is different from other doAsyc{verb}.\nOthers have auto retry after session changes (thus ZooKeeper object change). But this one we need to use the same ZooKeeper object.\nThis is the reason why this doAsycSync() has one more parameter as Zookeeper zk. It looks different from others.", "author": "kaisun2000", "createdAt": "2020-07-15T05:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNDg5MQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454804891", "bodyText": "This is my confusing part. Your retry will stop if session expired. Then even you get the zk from ZkClient every time, you will get the same one, no?", "author": "jiajunwang", "createdAt": "2020-07-15T05:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwOTI3NQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454809275", "bodyText": "This is how I look at it.\nLet us say the code is like this\nvoid doAsyncSync( final String path, final long startT,\n      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n\n     final ZooKeeper zk = (ZkConnection) getConnection()).getZookeeper();\n     zk.sync(path, cb,\n        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n          @Override\n          protected void doRetry() throws Exception {\n            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n          }\n        });\n  }\n\n\nThen, there is chance that when connection_loss, we have retry request from the asyncThread of ZkClient. The retry request is finally doAsyncSync(). Then, it would retrieve the ZooKeeper object from connection again. Note, by this time, the session can be changed (thus ZooKeeper object with a new session ID) is used.\nThis is not what we want. At least this sync() call is wasted for the reason the new session would invoke another fireAllEvent().", "author": "kaisun2000", "createdAt": "2020-07-15T05:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxNDIyNQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r454814225", "bodyText": "I got what you said, and I agree with the idea. But this is hard to achieve, even with your current work, the zookeeper object could be changed just before this selected line.\nTo make it solid,\n\nWe need to check the session Id after you get the zk object. If session does not match then skip the operation.\nYou might want to try-catch the line 1260 since if the zk already becomes invalid at the first call, it might throw an exception and we can just return false.\n\nIn addition, I think it is a good point to comment on the code so new devs won't \"simplify\" this part. And let's have a test to cover this case to ensure the callback wait won't be stuck. In detail, the zk object is changed during the retry.", "author": "jiajunwang", "createdAt": "2020-07-15T06:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIzMDY3Ng==", "url": "https://github.com/apache/helix/pull/1119#discussion_r455230676", "bodyText": "We need to check the session Id after you get the zk object. If session does not match then skip the operation.\n\n\nThe first ZooKeeper object extracted from connection (line 1259) is up in the stack in processStateChange() and then passed into doAsync(). Note, procesStateChange() is inside the lock of getEventLock(). I think under the lock, there is not possibility of changing another ZooKeeper object of different session, right? So this is not a concern in this case.\n\n\nYou might want to try-catch the line 1260 since if the zk already becomes invalid at the first call, it might throw an exception and we can just return false.\n\n\nSee the reply above. Am I missing something here? Can you give an example?", "author": "kaisun2000", "createdAt": "2020-07-15T17:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1MjY0NQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r455252645", "bodyText": "processStateChange() and fireNewSessionEvents() is in the lock for sure.\nHowever, your retrySync() is in the event thread. When it is running, it is not in any ZkEventLock protection. If you have 2 consequence new session establishments, then you might have 2 events in the queue if the processing is stuck. And when you process the first new session event, you are using the latest zk object (the wrong one).\nThat is exactly why we check the session Id in the ZkHelixManager.handleNewSession().\nFeel free to refer to the related new session handling test cases for the similar logic.", "author": "jiajunwang", "createdAt": "2020-07-15T18:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2NTA4NA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r455265084", "bodyText": "This is a good point. My intention is actually to get the Zookeeper object from Zookeeper event thread (not ZkClient even thread) and pass it to retrySync().\nMore specifically the code should be like the following:\n    if (_syncOnNewSession) {\n\n      final ZkConnection zkConnection = (ZkConnection) getConnection();\n      final ZooKeeper zk = zkConnection.getZookeeper();\n      _eventThread.send(new ZkEventThread.ZkEvent(\"Sync call before new session event of session \" + sessionId,\n          sessionId) {\n        @Override\n        public void run() throws Exception {\n          if (retrySync(sessionId, zk) == false) {\n            LOG.warn(\"sync on session {} failed\", sessionId);\n          }\n        }\n      });\n    }", "author": "kaisun2000", "createdAt": "2020-07-15T18:42:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2NzA4Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r455267082", "bodyText": "That works. But you already have sessionId. You can check and decide whether to skip the run or not. Why bother passing the redundant information?", "author": "jiajunwang", "createdAt": "2020-07-15T18:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM4MjQwMQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r455382401", "bodyText": "Check sessionId is after the fact. It can incur unnecessary sync() to server. For the new session, there may be two sync() in a row.\nIn this case we are asserting that for each new session, we have exactly one sync() going to server.", "author": "kaisun2000", "createdAt": "2020-07-15T21:50:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxNDU5Ng==", "url": "https://github.com/apache/helix/pull/1119#discussion_r455414596", "bodyText": "Added test and comments", "author": "kaisun2000", "createdAt": "2020-07-15T23:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0OTU1NQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r457649555", "bodyText": "Sorry that I cannot follow the comment that \"Check sessionId is after the fact...\".\nCould you please give me examples that how this invokes multiple sync() to the server? And how your current design prevent it.\nTO be clear what I meant by adding the session check is that check session Id in retrySync() before doAsyncSync.\nfinal ZkConnection zkConnection = (ZkConnection) getConnection();\nfinal ZooKeeper zk = zkConnection.getZookeeper();\nif (zk.getSessionId().equals(sessionId)) {\ndoAsyncSync(zk, _syncPath, startT, callbackHandler);\n} else {\nreturn false; // or throw exception\n}", "author": "jiajunwang", "createdAt": "2020-07-20T19:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTg5OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459111898", "bodyText": "Just saw this comment.\nThe gist is that the checking of sessionId and doAsyncSync() is not atomic. After if (zk.getSessionId().equals(sessionId)) succeed, the Zookeeper object may be changed due to a new session established. This would make the current doAsyncSync() work for the new session. Since the new session would trigger another fireNewSession(), which would put another  retrySync(). Then we will have another sync() to the Zookeeper for the new session. So in sum, the new session can be two sync() in a row.", "author": "kaisun2000", "createdAt": "2020-07-22T22:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMzI0Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459113242", "bodyText": "I will argue that it won't be an issue even it is not atomic. Since you get the zk object first. So if the zk object is changed, the later check will not be applied to the newer zk object.", "author": "jiajunwang", "createdAt": "2020-07-22T22:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2NzAwNA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r455967004", "bodyText": "Will there be potential sync on different code? If not, \"if\" statement will be much simpler than this.", "author": "junkaixue", "createdAt": "2020-07-16T17:52:54Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -120,6 +122,41 @@ public void handle() {\n     }\n   }\n \n+  public static class SyncCallbackHandler extends DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    public SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;", "originalCommit": "d001716f4e00deb7e07676eb031f519164dae800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5NzExMg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r456597112", "bodyText": "Previously, I added SESSIONMOVED. That is the only potential one. But I feel that one should fail (return to false). Currently it only follow the format of the parent class needRetry(). Maybe it is a good idea to just change it to \"if\".", "author": "kaisun2000", "createdAt": "2020-07-17T18:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2NzAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2MjI2NQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r457662265", "bodyText": "+1 on if-else to be cleaner/simpler.", "author": "huizhilu", "createdAt": "2020-07-20T20:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2NzAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0NjM5OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459046398", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-07-22T19:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2NzAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2NzkzMw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r455967933", "bodyText": "The only usage for zkConnection is to get Zookeeper. Why not combine these two in oneline:\nfinal ZooKeeper zk = (ZkConnection) getConnection().getZookeeper();", "author": "junkaixue", "createdAt": "2020-07-16T17:54:31Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1238,85 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, retrySync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  retrySync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean retrySync(String sessionId, ZooKeeper zk) throws ZkInterruptedException {\n+    ZkAsyncCallbacks.SyncCallbackHandler callbackHandler =\n+        new ZkAsyncCallbacks.SyncCallbackHandler(sessionId);\n+\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, _syncPath, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; Log the error and return\n+    LOG.warn(\n+        \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+        sessionId, code);\n+    return false;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n-    for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n+    if (_syncOnNewSession) {\n+      final ZkConnection zkConnection = (ZkConnection) getConnection();", "originalCommit": "d001716f4e00deb7e07676eb031f519164dae800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0MTc3MA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459041770", "bodyText": "changed.", "author": "kaisun2000", "createdAt": "2020-07-22T19:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2NzkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2OTE0OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r455969148", "bodyText": "If there is a lot of connect/disconnect, could this zk.sync be called multiple times at same time? Would that cause potential problems?\nSince Zookeeper event thread is not dedup thread, are we just assuming the sync call could be short?", "author": "junkaixue", "createdAt": "2020-07-16T17:56:29Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1238,85 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, retrySync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly", "originalCommit": "d001716f4e00deb7e07676eb031f519164dae800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5NTg2OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r456595868", "bodyText": "Exactly one zk.sync() for one new session if successful.  Otherwise, the retry would fail before the next \"retrySync\" is inserted to zkclient event queue.\nBasically, for one retrySync(), it would only be invoked preceding the current new session. It would only retry connectionloss and would fail (thus not retry) if there is other exception. Thus, we don't need to worry this event clogging the event queue. Nor will any two of them run at the same time.", "author": "kaisun2000", "createdAt": "2020-07-17T18:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2OTE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2OTUzOA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r455969538", "bodyText": "Let rename it. We dont have retry right now. It could cause reader confusing.", "author": "junkaixue", "createdAt": "2020-07-16T17:57:09Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1238,85 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, retrySync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  retrySync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean retrySync(String sessionId, ZooKeeper zk) throws ZkInterruptedException {", "originalCommit": "d001716f4e00deb7e07676eb031f519164dae800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0MDM4MQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459040381", "bodyText": "changed it to issue sync()", "author": "kaisun2000", "createdAt": "2020-07-22T19:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2OTUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2NTAyMA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r457665020", "bodyText": "Don't forget to remove these unused static imports.\nFYI, actually I would prefer not to import the static constant. You could just use KeeperException.Code.CONNECTIONLOSS for better readability. Ref: https://docs.oracle.com/javase/7/docs/technotes/guides/language/static-import.html", "author": "huizhilu", "createdAt": "2020-07-20T20:14:03Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -63,6 +68,10 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.zookeeper.KeeperException.Code.CONNECTIONLOSS;\n+import static org.apache.zookeeper.KeeperException.Code.OK;\n+import static org.apache.zookeeper.KeeperException.Code.SESSIONMOVED;", "originalCommit": "d001716f4e00deb7e07676eb031f519164dae800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0NDA0MQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459044041", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-07-22T19:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2NTAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2NTI1OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r457665258", "bodyText": "static final?", "author": "huizhilu", "createdAt": "2020-07-20T20:14:30Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -74,6 +83,7 @@\n public class ZkClient implements Watcher {\n   private static Logger LOG = LoggerFactory.getLogger(ZkClient.class);\n   private static long MAX_RECONNECT_INTERVAL_MS = 30000; // 30 seconds\n+  private static String ZK_AUTOSYNC_ENABLED_DEFAULT = \"true\";", "originalCommit": "d001716f4e00deb7e07676eb031f519164dae800", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2NTYwNA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r457665604", "bodyText": "I think it is better to make it a constant: static final SYNC_PATH?", "author": "huizhilu", "createdAt": "2020-07-20T20:15:06Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -105,6 +115,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  private final String _syncPath = \"/\";", "originalCommit": "d001716f4e00deb7e07676eb031f519164dae800", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTg0MA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459111840", "bodyText": "I think I have commented before the name convention of static final field is SYNC_PATH.", "author": "jiajunwang", "createdAt": "2020-07-22T22:08:59Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -105,6 +111,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  private static final String _syncPath = \"/\";", "originalCommit": "9468e5d9e774dd1c79cae48d66e94d3287522a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDU5OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459124598", "bodyText": "fixed.", "author": "kaisun2000", "createdAt": "2020-07-22T22:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwNjg3Nw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459106877", "bodyText": "_syncPath -> SYNC_PATH?", "author": "huizhilu", "createdAt": "2020-07-22T21:56:10Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -105,6 +111,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  private static final String _syncPath = \"/\";", "originalCommit": "9468e5d9e774dd1c79cae48d66e94d3287522a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMzQ4OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459123488", "bodyText": "fixed.", "author": "kaisun2000", "createdAt": "2020-07-22T22:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwNjg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTU4Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459109582", "bodyText": "Actually this is no need. If exception is thrown here, test will fail.", "author": "huizhilu", "createdAt": "2020-07-22T22:03:10Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {\n+    final String path = \"/\" + TestHelper.getTestMethodName();\n+    final String data = \"Hello Helix 2\";\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper\n+        .verify(() -> _zkClient.getConnection().getZookeeperState().isConnected(), 1000L));\n+\n+    final long originalSessionId = _zkClient.getSessionId();\n+\n+    try {\n+      // Create node.\n+      _zkClient.create(path, data, CreateMode.PERSISTENT);\n+    } catch (Exception ex) {\n+      Assert.fail(\"Failed to create ephemeral node.\", ex);\n+    }\n+\n+    // Expire the original session.\n+    ZkTestHelper.expireSession(_zkClient);\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper.verify(() -> {\n+      try {\n+        // New session id should not equal to expired session id.\n+        return _zkClient.getSessionId() != originalSessionId;\n+      } catch (ZkClientException ex) {\n+        return false;\n+      }\n+    }, 1000L));\n+\n+    // Verify the node is created and its data is correct.\n+    Stat stat = new Stat();\n+    String nodeData = null;\n+    try {\n+       nodeData = _zkClient.readData(path, stat, true);\n+    } catch (ZkException e) {\n+      Assert.fail(\"fail to read data\");", "originalCommit": "9468e5d9e774dd1c79cae48d66e94d3287522a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDMzMg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459124332", "bodyText": "As sync-ed, I found other case, not resolved. Let me validate this. Currently, this does not hurt.", "author": "kaisun2000", "createdAt": "2020-07-22T22:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTYzMw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459165633", "bodyText": "I meant, it is not about it doesn't hurt. ZkTestHelper.expireSession(_zkClient) could also possibly throw exception. Are you going to do this try...catch...fail?\nIf this test throws exception, it definitely will fail from the point where exception is thrown.", "author": "huizhilu", "createdAt": "2020-07-23T01:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTY2NA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459109664", "bodyText": "Same. Actually this is no need. If exception is thrown here, test will fail.\nRealizing this will also help you with later tests implement.", "author": "huizhilu", "createdAt": "2020-07-22T22:03:23Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {\n+    final String path = \"/\" + TestHelper.getTestMethodName();\n+    final String data = \"Hello Helix 2\";\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper\n+        .verify(() -> _zkClient.getConnection().getZookeeperState().isConnected(), 1000L));\n+\n+    final long originalSessionId = _zkClient.getSessionId();\n+\n+    try {\n+      // Create node.\n+      _zkClient.create(path, data, CreateMode.PERSISTENT);\n+    } catch (Exception ex) {\n+      Assert.fail(\"Failed to create ephemeral node.\", ex);", "originalCommit": "9468e5d9e774dd1c79cae48d66e94d3287522a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDQ2MQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459124461", "bodyText": "same. For safety for now.", "author": "kaisun2000", "createdAt": "2020-07-22T22:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTkxNw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459111917", "bodyText": "I wonder how NullPointerException is thrown?\nI think KeeperException.Code.get(rc) returns null if rc is not a valid KeeperException code.\nSo if it returns null, I think we log it as unknot return code?", "author": "huizhilu", "createdAt": "2020-07-22T22:09:08Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -120,6 +122,39 @@ public void handle() {\n     }\n   }\n \n+  public static class SyncCallbackHandler extends DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    public SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        // Connection to the server has been lost\n+        if (KeeperException.Code.get(rc) == Code.CONNECTIONLOSS) {\n+          return true;\n+        } \n+        return false;\n+      } catch (ClassCastException | NullPointerException ex) {", "originalCommit": "9468e5d9e774dd1c79cae48d66e94d3287522a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNjUxNQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459126515", "bodyText": "Copied from base class. @jiajunwang, what is your take?", "author": "kaisun2000", "createdAt": "2020-07-22T22:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyODIyMg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459128222", "bodyText": "Haven't you checked the reason before copy the code, Kai : )\nThis method may return null.", "author": "jiajunwang", "createdAt": "2020-07-22T22:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MDMxMw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459140313", "bodyText": "KeeperException.Code.get() can throw null point exception.", "author": "kaisun2000", "createdAt": "2020-07-22T23:30:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NjczNw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459166737", "bodyText": "@kaisun2000 Could you help understand this: KeeperException.Code.get() can throw null point exception. Underneath the lookup is a map. map.get(rc) returns null if rc doesn't exist.\n/**\n         * Get the Code value for a particular integer error code\n         * @param code int error code\n         * @return Code value corresponding to specified int code, or null\n         */\n        public static Code get(int code) {\n            return lookup.get(code);\n        }\n\nThe code should be like\nif (KeeperException.Code.get(rc) == Code.CONNECTIONLOSS) {\n     return true;\n}\nLOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying.\",\n             _sessionId, rc);\nreturn false;", "author": "huizhilu", "createdAt": "2020-07-23T01:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2NDAxNA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459264014", "bodyText": "@kaisun2000 I just realized you said the code is copied from \n  \n    \n      helix/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java\n    \n    \n        Lines 255 to 266\n      in\n      9e6dafa\n    \n    \n    \n    \n\n        \n          \n             switch (Code.get(rc)) { \n        \n\n        \n          \n             /** Connection to the server has been lost */ \n        \n\n        \n          \n             case CONNECTIONLOSS: \n        \n\n        \n          \n               /** The session has been expired by the server */ \n        \n\n        \n          \n             case SESSIONEXPIRED: \n        \n\n        \n          \n               /** Session moved to another server, so operation is ignored */ \n        \n\n        \n          \n             case SESSIONMOVED: \n        \n\n        \n          \n               return true; \n        \n\n        \n          \n             default: \n        \n\n        \n          \n               return false; \n        \n\n        \n          \n             } \n        \n\n        \n          \n           } catch (ClassCastException | NullPointerException ex) { \n        \n    \n  \n\n\nLet me explain: Code.get(rc) could return null, and switch(null) gives NPE. That's why the code needs to catch NPE. But for your code here, I don't think NPE would happen.", "author": "huizhilu", "createdAt": "2020-07-23T07:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MjcwNg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459692706", "bodyText": "This is a good point. I revert back to switch() same as JJ's original style. Logging unknown code due to NPE is important for us to troubleshooting if it happens in the field.", "author": "kaisun2000", "createdAt": "2020-07-23T19:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNDU0Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459114542", "bodyText": "I still think Zookeeper is not required here. Please see my reply to the original thread. If we put the check logic here, it will work.\nThe reason I insist on doing this is that, when you put the old zk object here, if any new session created, then the old zk object will throw exceptions when you call it. That would be a ZK exception. And then we rely on our exception handling logic to ensure everything works fine.\nIf we check the current zk object with the session Id, then we can end this operation with explicit logic and with a very clean warning or error log.\nMoreover, as I mentioned in the first comment, the session Id and the input zk contain redundant information. You only need one of them.", "author": "jiajunwang", "createdAt": "2020-07-22T22:16:08Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1234,84 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(String sessionId, ZooKeeper zk) throws ZkInterruptedException {", "originalCommit": "9468e5d9e774dd1c79cae48d66e94d3287522a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMzAxNQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459123015", "bodyText": "See my reply (just now) of the after fact checking cons here:\n\nJust saw this comment.\nThe gist is that the checking of sessionId and doAsyncSync() is not atomic. After if (zk.getSessionId().equals(sessionId)) succeed, the Zookeeper object may be changed due to a new session established. This would make the current doAsyncSync() work for the new session. Since the new session would trigger another fireNewSession(), which would put another retrySync(). Then we will have another sync() to the Zookeeper for the new session. So in sum, the new session can be two sync() in a row.\n\nBack to your concern about old Zk object throw exceptions, here is how I look at it:\nFirst, async call (sync() in this case), would not throw exception. The error code would from the callback (invoked in eventthread of ZooKeeper) would tell what is wrong. The checking is in protected boolean needRetry(int rc).", "author": "kaisun2000", "createdAt": "2020-07-22T22:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNDU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDAwMQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459124001", "bodyText": "\u201cPlease see my reply to the original thread.\u201d, where I mentioned that this con is not real : )\nWhen you get the zk first then compared it with the session Id, you will have the right zk to use for sure. Or the check will fail and we will not really send sync request.", "author": "jiajunwang", "createdAt": "2020-07-22T22:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNDU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzOTIwMQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459139201", "bodyText": "As synced offline, we will not pass redundant data to issueAsync(). Only add zk.", "author": "kaisun2000", "createdAt": "2020-07-22T23:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNDU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NDY5Mw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459164693", "bodyText": "Nit. This could be a constant: static final boolean SYNC_ON_NEW_SESSION = Boolean.parseBoolean(System.getProperty(ZkSystemPropertyKeys.ZK_AUTOSYNC_ENABLED, ZK_AUTOSYNC_ENABLED_DEFAULT))", "author": "huizhilu", "createdAt": "2020-07-23T01:01:52Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -187,6 +196,10 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n     if (zkConnection == null) {\n       throw new NullPointerException(\"Zookeeper connection is null!\");\n     }\n+\n+    String syncUpOnNewSession = System.getProperty(ZkSystemPropertyKeys.ZK_AUTOSYNC_ENABLED, ZK_AUTOSYNC_ENABLED_DEFAULT);\n+    _syncOnNewSession = Boolean.parseBoolean(syncUpOnNewSession);", "originalCommit": "9e6dafa1f4151613f5537f4a49e18254620bc40d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1NjA0MA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459656040", "bodyText": "_syncOnNewSession is final not static as this allows per zkclient different _syncOnNewSession behavior. We may later support this from the ZkClient constructor. Let us just keep it this way.", "author": "kaisun2000", "createdAt": "2020-07-23T18:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NDY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2NjE5MA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459266190", "bodyText": "Nit, I think assertTrue(_zkClient.waitUntilConnected(1, TimeUnit.Second)); would be better than polling", "author": "huizhilu", "createdAt": "2020-07-23T07:38:46Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {\n+    final String path = \"/\" + TestHelper.getTestMethodName();\n+    final String data = \"Hello Helix 2\";\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper", "originalCommit": "9e6dafa1f4151613f5537f4a49e18254620bc40d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0NTAzOA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459645038", "bodyText": "fixed.", "author": "kaisun2000", "createdAt": "2020-07-23T18:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2NjE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2NzE1Mw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459267153", "bodyText": "No need for this check, as it is already verified new session is established in ZkTestHelper.expireSession().", "author": "huizhilu", "createdAt": "2020-07-23T07:40:49Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {\n+    final String path = \"/\" + TestHelper.getTestMethodName();\n+    final String data = \"Hello Helix 2\";\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper\n+        .verify(() -> _zkClient.getConnection().getZookeeperState().isConnected(), 1000L));\n+\n+    final long originalSessionId = _zkClient.getSessionId();\n+\n+    try {\n+      // Create node.\n+      _zkClient.create(path, data, CreateMode.PERSISTENT);\n+    } catch (Exception ex) {\n+      Assert.fail(\"Failed to create ephemeral node.\", ex);\n+    }\n+\n+    // Expire the original session.\n+    ZkTestHelper.expireSession(_zkClient);\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper.verify(() -> {", "originalCommit": "9e6dafa1f4151613f5537f4a49e18254620bc40d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYzOTg1OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459639858", "bodyText": "delete.", "author": "kaisun2000", "createdAt": "2020-07-23T18:17:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2NzE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3MTAxMg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459271012", "bodyText": "Do I understand correctly? This test actually doesn't really test sync, because:\nit is only one zk. It doesn't have to propagate data to other zk learners. So even without sync, this test will always pass, as the zkclient always connects to the same zk so it always sees the latest data.\nI actually think it may be difficult to test sync here. We could see how zk tests sync, which is more complicated: https://github.com/apache/zookeeper/blob/master/zookeeper-server/src/test/java/org/apache/zookeeper/test/SyncCallTest.java", "author": "huizhilu", "createdAt": "2020-07-23T07:49:12Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.", "originalCommit": "9e6dafa1f4151613f5537f4a49e18254620bc40d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0NjI2OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459646268", "bodyText": "Test the change won't make normal flow hanging.\nAgree It is hard to test sync() works when follower ZK lags leader. We have to trust ZK is right in this regard.", "author": "kaisun2000", "createdAt": "2020-07-23T18:28:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3MTAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI5MjkwOQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459292909", "bodyText": "From your comment The sync() would fail with a stale session., I understand that if the session expires, the following events with the expired session calls handleNewSession but they are skipped.\nI think there is other case other than sessionExpired that causes issueSync() to fail. If it fails, warn msg is logged. But stateListener still calls handleNewSession. It conflicts the log \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\". Then there is still a possibility handleNewSession reads stale data. Do I miss anything?", "author": "huizhilu", "createdAt": "2020-07-23T08:31:28Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1234,85 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(ZooKeeper zk) {\n+    String sessionId = Long.toHexString(zk.getSessionId());\n+    ZkAsyncCallbacks.SyncCallbackHandler callbackHandler =\n+        new ZkAsyncCallbacks.SyncCallbackHandler(sessionId);\n+\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, SYNC_PATH, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == KeeperException.Code.OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; Log the error and return\n+    LOG.warn(\n+        \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+        sessionId, code);\n+    return false;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n-    for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n+    if (_syncOnNewSession) {\n+      final ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+      _eventThread.send(new ZkEventThread.ZkEvent(\"Sync call before new session event of session \" + sessionId,\n+          sessionId) {\n         @Override\n         public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n+          if (issueSync(zk) == false) {", "originalCommit": "9e6dafa1f4151613f5537f4a49e18254620bc40d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1MjQzNA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459652434", "bodyText": "As synced offline, we can consider the current approach is a best effort one. The main trade-off is that waiting for succeeds of async sync() actually also has performance hit. (That is the reason why the sync() only has async version.) The designer of this API seems to envision that one can issue an asyc sync() without checking results and issue all the other read knowing they would see only updates after the sycn().\nFeel free to add another issue/request, if this turns out to be problematic in the field, let us revisit it.", "author": "kaisun2000", "createdAt": "2020-07-23T18:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI5MjkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI5NDI5NQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459294295", "bodyText": "I think this log should be outside of issueSync as \"stop calling handleNewSession\" is outside logic. This issueSync jus tells sync succeeds or not. But it doesn't have to determine handleNewSession or not, right?", "author": "huizhilu", "createdAt": "2020-07-23T08:34:01Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1234,85 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(ZooKeeper zk) {\n+    String sessionId = Long.toHexString(zk.getSessionId());\n+    ZkAsyncCallbacks.SyncCallbackHandler callbackHandler =\n+        new ZkAsyncCallbacks.SyncCallbackHandler(sessionId);\n+\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, SYNC_PATH, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == KeeperException.Code.OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; Log the error and return\n+    LOG.warn(\n+        \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",", "originalCommit": "9e6dafa1f4151613f5537f4a49e18254620bc40d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1MjgzMw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459652833", "bodyText": "As discussed, will remove this one.", "author": "kaisun2000", "createdAt": "2020-07-23T18:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI5NDI5NQ=="}], "type": "inlineReview"}, {"oid": "166ef21e2c53f9614081b89a5f1eaf570f835c7a", "url": "https://github.com/apache/helix/commit/166ef21e2c53f9614081b89a5f1eaf570f835c7a", "message": "Add sync() call first for new session handling (#1118)\n\nHelix may see stale data when session expires and get reconnected to\na slower ZKServer. This would cause various correctness problem.\nWe would call sync() to ZKserver first. This ensures Helix would\nnot see data that saw before.", "committedDate": "2020-07-23T19:07:22Z", "type": "commit"}, {"oid": "7ed63d4cc8f491eb47a9907e8c2225d39ff02ec7", "url": "https://github.com/apache/helix/commit/7ed63d4cc8f491eb47a9907e8c2225d39ff02ec7", "message": "format code with style sheet", "committedDate": "2020-07-23T19:07:32Z", "type": "commit"}, {"oid": "fc3b91ae65417a621dc2c30c2d9ed0bc7c62c633", "url": "https://github.com/apache/helix/commit/fc3b91ae65417a621dc2c30c2d9ed0bc7c62c633", "message": "blocking version.", "committedDate": "2020-07-23T19:07:32Z", "type": "commit"}, {"oid": "542e29304e5e6bee0a5e1f68d369be1bb08d8fac", "url": "https://github.com/apache/helix/commit/542e29304e5e6bee0a5e1f68d369be1bb08d8fac", "message": "leverage AsyncCallbacks pattern; rebased", "committedDate": "2020-07-23T19:07:32Z", "type": "commit"}, {"oid": "645cf93c9ceab44e54738c6e87a2ffbd5a6c0d17", "url": "https://github.com/apache/helix/commit/645cf93c9ceab44e54738c6e87a2ffbd5a6c0d17", "message": "minor fix of return value.", "committedDate": "2020-07-23T19:07:32Z", "type": "commit"}, {"oid": "0bfdfeabece7419d8ba4b9a37b0d33b37c57f36f", "url": "https://github.com/apache/helix/commit/0bfdfeabece7419d8ba4b9a37b0d33b37c57f36f", "message": "some further refactor based on feedback.", "committedDate": "2020-07-23T19:07:32Z", "type": "commit"}, {"oid": "16333a32276a111b1cfe9119c1ea4af413fe3bf3", "url": "https://github.com/apache/helix/commit/16333a32276a111b1cfe9119c1ea4af413fe3bf3", "message": "treat sync() metric the same as Zk server metric", "committedDate": "2020-07-23T19:08:50Z", "type": "commit"}, {"oid": "2ef1888f9d4890cef0343711cd5328bffae5749a", "url": "https://github.com/apache/helix/commit/2ef1888f9d4890cef0343711cd5328bffae5749a", "message": "added tests", "committedDate": "2020-07-23T19:08:53Z", "type": "commit"}, {"oid": "89bf13fb5cd710bd1b7026288759f47782c1cf33", "url": "https://github.com/apache/helix/commit/89bf13fb5cd710bd1b7026288759f47782c1cf33", "message": "mintor style fix.", "committedDate": "2020-07-23T19:09:59Z", "type": "commit"}, {"oid": "cb1eaac31e63031c8905891d9b454059c664816e", "url": "https://github.com/apache/helix/commit/cb1eaac31e63031c8905891d9b454059c664816e", "message": "remove redundant params to issueSync()", "committedDate": "2020-07-23T19:10:02Z", "type": "commit"}, {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "url": "https://github.com/apache/helix/commit/3a564e1805dafa3323ba1370843e6a0b4102a8c2", "message": "some change based on huizhi's feedback.", "committedDate": "2020-07-23T19:10:02Z", "type": "commit"}, {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "url": "https://github.com/apache/helix/commit/3a564e1805dafa3323ba1370843e6a0b4102a8c2", "message": "some change based on huizhi's feedback.", "committedDate": "2020-07-23T19:10:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NTg4MA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459675880", "bodyText": "should we name it \"zk.zkclient.autosync.enabled\"?  zk is higher namespace, it includes configs not only applies to zkClient, it could be all zk-related configs in Helix.", "author": "lei-xia", "createdAt": "2020-07-23T19:23:17Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/ZkSystemPropertyKeys.java", "diffHunk": "@@ -50,4 +50,14 @@\n    */\n   public static final String ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES =\n       \"zk.serializer.znrecord.write.size.limit.bytes\";\n+\n+  /**\n+   * This property determines the behavior of ZkClient issuing an sync() to server upon new session\n+   * established.\n+   *\n+   * <p>\n+   *   The default value is \"true\" (issuing sync)\n+   */\n+  public static final String ZK_AUTOSYNC_ENABLED =\n+      \"zk.autosync.enabled\";", "originalCommit": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNjI0Nw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459736247", "bodyText": "good point. changed.", "author": "kaisun2000", "createdAt": "2020-07-23T21:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NTg4MA=="}], "type": "inlineReview"}, {"oid": "7d59ff16a27f7f424a415b9412f7f171727973ef", "url": "https://github.com/apache/helix/commit/7d59ff16a27f7f424a415b9412f7f171727973ef", "message": "change to make sure not understanding return code is logged.", "committedDate": "2020-07-23T19:27:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3ODg3Ng==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459678876", "bodyText": "Should this config per zkClient or globally in one JVM? If it is globally, the syncUpOnNewSession should be static and initiated at place it is defined?", "author": "lei-xia", "createdAt": "2020-07-23T19:29:04Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -200,6 +211,10 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n     if (zkConnection == null) {\n       throw new NullPointerException(\"Zookeeper connection is null!\");\n     }\n+\n+    String syncUpOnNewSession = System.getProperty(ZkSystemPropertyKeys.ZK_AUTOSYNC_ENABLED, ZK_AUTOSYNC_ENABLED_DEFAULT);\n+    _syncOnNewSession = Boolean.parseBoolean(syncUpOnNewSession);", "originalCommit": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3OTE0MQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459679141", "bodyText": "Otherwise, if it is per-zkClient, should we add this as one parameter in the constructor?", "author": "lei-xia", "createdAt": "2020-07-23T19:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3ODg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5NzM5Ng==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459697396", "bodyText": "For now, it is globally unique. _syncOnNewSession as instance variable can help the change later if we want to make it instance configurable.\nAnyway, let me change it to global unique since huizhi also point it out.", "author": "kaisun2000", "createdAt": "2020-07-23T20:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3ODg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczODQ3NQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459738475", "bodyText": "fixed.", "author": "kaisun2000", "createdAt": "2020-07-23T21:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3ODg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4ODQxMA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459688410", "bodyText": "If we do not plan to change doAsynSync as a public API, i.e, it will use internally in this case, why not merge this two methods together to one?", "author": "lei-xia", "createdAt": "2020-07-23T19:48:07Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1256,21 +1271,82 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(ZooKeeper zk) {", "originalCommit": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5OTU5Nw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459699597", "bodyText": "doAsyncSync() follows the pattern of other doAsync{verb} in terms of threading pattern.\nIssueSync actually waits for the result of doAsyncSync(). See the waitForSuccess().\nSeems to me It is not easy to merge them together, or maybe I did not fully grab what you mean here. So maybe you can scratch the code of how to do it?", "author": "kaisun2000", "createdAt": "2020-07-23T20:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4ODQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4OTU0Nw==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459689547", "bodyText": "getHexSessionId()?", "author": "lei-xia", "createdAt": "2020-07-23T19:50:23Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1256,21 +1271,82 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(ZooKeeper zk) {\n+    String sessionId = Long.toHexString(zk.getSessionId());", "originalCommit": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5NTEyNQ==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459695125", "bodyText": "We can't use getHexSessionID() as it use current ZooKeeper object from ZK.\nSee this discussion for detail\n#1119 (comment)\nBasically we want to achieve for each session, only one issueSync() is called before everything else. This is built on the invariant that each ZooKeeper object has only one session in its life.", "author": "kaisun2000", "createdAt": "2020-07-23T20:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4OTU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MDI0Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459690242", "bodyText": "suggest to change to \"Failed to call sync() on new session {}\" to be more specific.", "author": "lei-xia", "createdAt": "2020-07-23T19:51:50Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1256,21 +1271,82 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(ZooKeeper zk) {\n+    String sessionId = Long.toHexString(zk.getSessionId());\n+    ZkAsyncCallbacks.SyncCallbackHandler callbackHandler =\n+        new ZkAsyncCallbacks.SyncCallbackHandler(sessionId);\n+\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, SYNC_PATH, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == KeeperException.Code.OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; return false.\n+    return false;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n-    for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n+    if (_syncOnNewSession) {\n+      final ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+      _eventThread.send(new ZkEventThread.ZkEvent(\"Sync call before new session event of session \" + sessionId,\n+          sessionId) {\n         @Override\n         public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n+          if (issueSync(zk) == false) {\n+            LOG.warn(\"sync on session {} failed\", sessionId);", "originalCommit": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNDI1NA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459734254", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-07-23T21:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MDI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MTY2NA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459691664", "bodyText": "Do we need a info log here if return success?  Also \"syncOnNewSession\" is not accurate, it should be \"sync() call\", right?", "author": "lei-xia", "createdAt": "2020-07-23T19:54:36Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -120,6 +122,39 @@ public void handle() {\n     }\n   }\n \n+  public static class SyncCallbackHandler extends DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    public SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);", "originalCommit": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTQ5MA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459735490", "bodyText": "This is per session. Changed to debug and also the log text.", "author": "kaisun2000", "createdAt": "2020-07-23T21:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MTY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5Mjc5Mg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459692792", "bodyText": "This test seems is not quite relevant, how can we at least make sure the sync call success from this test?", "author": "lei-xia", "createdAt": "2020-07-23T19:56:43Z", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -558,6 +558,41 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {", "originalCommit": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMTUxMg==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459701512", "bodyText": "This test is just to make sure the normal flow will work. Namely no hanging. This is to make sure the change will not fail in the field after session expiration. This is a \"safety\" test.\nThe other side is to make sure not seeing outdate data if a follower Zk lagging leader. This can't be easily done without touch code of ZK server. Here, we have to trust sync() implementation is right.", "author": "kaisun2000", "createdAt": "2020-07-23T20:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5Mjc5Mg=="}], "type": "inlineReview"}, {"oid": "f9658e39799d8279989e6de73eb09a91e1ad9442", "url": "https://github.com/apache/helix/commit/f9658e39799d8279989e6de73eb09a91e1ad9442", "message": "address some further comment from Lei", "committedDate": "2020-07-23T21:30:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc1NzM4OA==", "url": "https://github.com/apache/helix/pull/1119#discussion_r459757388", "bodyText": "Unnecessary extra comma @kaisun2000", "author": "huizhilu", "createdAt": "2020-07-23T22:13:03Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -118,6 +126,12 @@\n     NUM_CHILDREN_LIMIT = 100 * 1000;\n   }\n \n+  private static final boolean SYNC_ON_SESSION = Boolean.parseBoolean(\n+      System.getProperty(ZkSystemPropertyKeys.ZK_AUTOSYNC_ENABLED, ZK_AUTOSYNC_ENABLED_DEFAULT));\n+  ;", "originalCommit": "f9658e39799d8279989e6de73eb09a91e1ad9442", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}