{"pr_number": 718, "pr_title": "Implement Helix nonblocking lock", "pr_createdAt": "2020-02-03T23:08:21Z", "pr_url": "https://github.com/apache/helix/pull/718", "timeline": [{"oid": "2cec92fdb2a602edb18d37cbbe3cccada27348af", "url": "https://github.com/apache/helix/commit/2cec92fdb2a602edb18d37cbbe3cccada27348af", "message": "Created Helix distributed lock design (apache#702)", "committedDate": "2020-02-03T22:39:12Z", "type": "commit"}, {"oid": "7d1b912aab6efc6eb9ef3b41f1cc5acb1eab90d5", "url": "https://github.com/apache/helix/commit/7d1b912aab6efc6eb9ef3b41f1cc5acb1eab90d5", "message": "Added LockInfo interface", "committedDate": "2020-02-03T22:41:10Z", "type": "commit"}, {"oid": "8b6f38db03c36fdb158e6d367ec6a55449f84680", "url": "https://github.com/apache/helix/commit/8b6f38db03c36fdb158e6d367ec6a55449f84680", "message": "Added details in comments", "committedDate": "2020-02-03T22:41:10Z", "type": "commit"}, {"oid": "9c84a155cb78581d3bc3bee0a8daa7b0ad3a9e72", "url": "https://github.com/apache/helix/commit/9c84a155cb78581d3bc3bee0a8daa7b0ad3a9e72", "message": "created Helix nonblocking lock based on zk", "committedDate": "2020-02-03T22:41:10Z", "type": "commit"}, {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "url": "https://github.com/apache/helix/commit/28218ea4bc100fe864da68c9794e35b0132b7cc6", "message": "Added unit tests for Helix nonblocking lock", "committedDate": "2020-02-03T22:54:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwNjIwNQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r374506205", "bodyText": "suggest to change \"userID\" to \"userId\", and add the param of \"userId\" here.", "author": "zhangmeng916", "createdAt": "2020-02-04T07:17:31Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock", "originalCommit": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwNjkwMQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r374506901", "bodyText": "same here, add \"userId\"", "author": "zhangmeng916", "createdAt": "2020-02-04T07:19:50Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock", "originalCommit": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwNzQxOA==", "url": "https://github.com/apache/helix/pull/718#discussion_r374507418", "bodyText": "formatting?", "author": "zhangmeng916", "createdAt": "2020-02-04T07:21:40Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userID) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userID = userID;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to acquire a lock\n+   * @return true if the lock was successfully acquired,\n+   * false if the lock could not be acquired\n+   */ public boolean acquireLock() {", "originalCommit": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAwMTI5Ng==", "url": "https://github.com/apache/helix/pull/718#discussion_r375001296", "bodyText": "This is dangling comment, I deleted it since there is already a same comment in the interface.", "author": "mgao0", "createdAt": "2020-02-05T00:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwNzQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxMDg2OQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r374510869", "bodyText": "Better to add comment for this \"set\" operation, and when it may fail.", "author": "zhangmeng916", "createdAt": "2020-02-04T07:32:42Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userID) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userID = userID;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to acquire a lock\n+   * @return true if the lock was successfully acquired,\n+   * false if the lock could not be acquired\n+   */ public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);", "originalCommit": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxMTgyMw==", "url": "https://github.com/apache/helix/pull/718#discussion_r374511823", "bodyText": "Is ownerId null a valid scenario? In this case, the lock has no owner. You mean want to add some validation logic for lock info.\nAlso, suggest to change ownerID to ownerId.", "author": "zhangmeng916", "createdAt": "2020-02-04T07:35:46Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userID) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userID = userID;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to acquire a lock\n+   * @return true if the lock was successfully acquired,\n+   * false if the lock could not be acquired\n+   */ public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to release a lock\n+   * @return true if the lock was successfully released,\n+   * false if the locked is not locked or is not locked by the user,\n+   * or the lock could not be released\n+   */ public boolean releaseLock() {\n+    if (isOwner()) {\n+      return _baseDataAccessor.remove(_lockPath, AccessOption.PERSISTENT);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  /**\n+   * Retrieve the lock information, e.g. lock timeout, lock message, etc.\n+   * @return lock metadata information, return null if there is no lock node for the path provided\n+   */ public LockInfo<String> getLockInfo() {\n+    if (!_baseDataAccessor.exists(_lockPath, AccessOption.PERSISTENT)) {\n+      return null;\n+    }\n+    ZKHelixNonblockingLockInfo<String> lockInfo = new ZKHelixNonblockingLockInfo<>();\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    lockInfo.setLockInfoFields(curLockInfo);\n+    return lockInfo;\n+  }\n+\n+  @Override\n+  /**\n+   * Check if the user is current lock owner\n+   * @return true if the user is the lock owner,\n+   * false if the user is not the lock owner or the lock doesn't have a owner\n+   */ public boolean isOwner() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    if (curLockInfo == null) {\n+      return false;\n+    }\n+    String ownerID = curLockInfo.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name());\n+    if (ownerID == null) {", "originalCommit": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxOTUyNQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r375019525", "bodyText": "I changed the logic and now the user Id is validated in the constructor so there is no need to check if the ownerId is null, even if there is no current owner of the lock, the ownerId would be DEFAULT_OWNER_TEXT which is an empty string.", "author": "mgao0", "createdAt": "2020-02-05T01:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxMTgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxMzIxNQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r374513215", "bodyText": "Could you also test the case when two threads both try to acquire the lock, independently, and one of them succeed, and the other fail?", "author": "zhangmeng916", "createdAt": "2020-02-04T07:40:08Z", "path": "helix-lock/src/test/java/org/apache/helix/lock/TestZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*", "originalCommit": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxODk4Ng==", "url": "https://github.com/apache/helix/pull/718#discussion_r375018986", "bodyText": "Test added. Please see testSimultaneousAcquire().", "author": "mgao0", "createdAt": "2020-02-05T01:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxMzIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0OTI2MA==", "url": "https://github.com/apache/helix/pull/718#discussion_r374849260", "bodyText": "Discussed offline, if this one is not for our customer to use immediately, please use private.", "author": "jiajunwang", "createdAt": "2020-02-04T18:36:20Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,", "originalCommit": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDgzOQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r374850839", "bodyText": "Format", "author": "jiajunwang", "createdAt": "2020-02-04T18:39:24Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userID) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userID = userID;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to acquire a lock\n+   * @return true if the lock was successfully acquired,\n+   * false if the lock could not be acquired\n+   */ public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to release a lock\n+   * @return true if the lock was successfully released,\n+   * false if the locked is not locked or is not locked by the user,\n+   * or the lock could not be released\n+   */ public boolean releaseLock() {", "originalCommit": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyMDAzMw==", "url": "https://github.com/apache/helix/pull/718#discussion_r375020033", "bodyText": "Deleted the comment since it is duplicated with comments in interface", "author": "mgao0", "createdAt": "2020-02-05T01:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MjYxNQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r374852615", "bodyText": "It could be a race condition. We should never remove the node while releasing it. Simply update the timeout to -1 or so using the update(). So there won't be a chance someone releases the lock at the same time, and the lock is removed unexpectedly.", "author": "jiajunwang", "createdAt": "2020-02-04T18:42:50Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userID) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userID = userID;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to acquire a lock\n+   * @return true if the lock was successfully acquired,\n+   * false if the lock could not be acquired\n+   */ public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to release a lock\n+   * @return true if the lock was successfully released,\n+   * false if the locked is not locked or is not locked by the user,\n+   * or the lock could not be released\n+   */ public boolean releaseLock() {\n+    if (isOwner()) {", "originalCommit": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyMjU3NA==", "url": "https://github.com/apache/helix/pull/718#discussion_r375022574", "bodyText": "I changed the logic of release according to your suggestion to avoid the race condition. I created a LockUpdater which checks if the current user is the lock owner (so here I'm keeping the design of only lock owner can release a lock). If a non-owner tries to delete the lock, an exception will be thrown from the LockUpdater so when data accessor does update, it can return false.", "author": "mgao0", "createdAt": "2020-02-05T01:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MjYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MzUyOQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r374853529", "bodyText": "How we prevent 2 clients using the same ID?\nI thing GUID is easier and they should not be specified by our user.", "author": "jiajunwang", "createdAt": "2020-02-04T18:44:35Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;", "originalCommit": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyMDU3Mw==", "url": "https://github.com/apache/helix/pull/718#discussion_r375020573", "bodyText": "The purpose of this is to let user save a user Id locally, so even they lost session with Zk, after reconnect they will have the same user Id, so they can still check the lock owner and know if the lock belongs to them, as well as maintain authorizations to release their own lock.", "author": "mgao0", "createdAt": "2020-02-05T01:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MzUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1Mzk4NA==", "url": "https://github.com/apache/helix/pull/718#discussion_r374853984", "bodyText": "format", "author": "jiajunwang", "createdAt": "2020-02-04T18:45:23Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;\n+\n+  enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+  }\n+\n+  @Override\n+  /**\n+   * Create a single filed of LockInfo, or update the value of the field if it already exists\n+   * @param infoKey the key of the LockInfo field\n+   * @param infoValue the value of the LockInfo field\n+   */ public void setInfoValue(String infoKey, String infoValue) {", "originalCommit": "7eb25e8daee8d57d90f612442ece294e9f39a857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NDM3Nw==", "url": "https://github.com/apache/helix/pull/718#discussion_r374854377", "bodyText": "setInforValue (InfoKey key,  String infoValue)", "author": "jiajunwang", "createdAt": "2020-02-04T18:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1Mzk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NDI4NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r374854285", "bodyText": "getInforValue (InfoKey key)", "author": "jiajunwang", "createdAt": "2020-02-04T18:45:57Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;\n+\n+  enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+  }\n+\n+  @Override\n+  /**\n+   * Create a single filed of LockInfo, or update the value of the field if it already exists\n+   * @param infoKey the key of the LockInfo field\n+   * @param infoValue the value of the LockInfo field\n+   */ public void setInfoValue(String infoKey, String infoValue) {\n+    lockInfo.put(infoKey, infoValue);\n+  }\n+\n+  @Override\n+  /**\n+   * Get the value of a field in LockInfo\n+   * @param infoKey the key of the LockInfo field\n+   * @return the value of the field or null if this key does not exist\n+   */ public T getInfoValue(String infoKey) {", "originalCommit": "7eb25e8daee8d57d90f612442ece294e9f39a857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NDUyNA==", "url": "https://github.com/apache/helix/pull/718#discussion_r374854524", "bodyText": "Map<InfoKey, String>", "author": "jiajunwang", "createdAt": "2020-02-04T18:46:21Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;", "originalCommit": "7eb25e8daee8d57d90f612442ece294e9f39a857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NDY5Mw==", "url": "https://github.com/apache/helix/pull/718#discussion_r374854693", "bodyText": "Should be public if you want strong control on the types.", "author": "jiajunwang", "createdAt": "2020-02-04T18:46:38Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;\n+\n+  enum InfoKey {", "originalCommit": "7eb25e8daee8d57d90f612442ece294e9f39a857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NTAwOA==", "url": "https://github.com/apache/helix/pull/718#discussion_r374855008", "bodyText": "What's the usage? The Helix convention is creating a copy constructor for this scenario.", "author": "jiajunwang", "createdAt": "2020-02-04T18:47:16Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;\n+\n+  enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+  }\n+\n+  @Override\n+  /**\n+   * Create a single filed of LockInfo, or update the value of the field if it already exists\n+   * @param infoKey the key of the LockInfo field\n+   * @param infoValue the value of the LockInfo field\n+   */ public void setInfoValue(String infoKey, String infoValue) {\n+    lockInfo.put(infoKey, infoValue);\n+  }\n+\n+  @Override\n+  /**\n+   * Get the value of a field in LockInfo\n+   * @param infoKey the key of the LockInfo field\n+   * @return the value of the field or null if this key does not exist\n+   */ public T getInfoValue(String infoKey) {\n+    return (T) lockInfo.get(infoKey);\n+  }\n+\n+  /**\n+   * Update the lock info with information in a ZNRecord\n+   * @param record Information about the lock that stored as ZNRecord format\n+   */\n+  public void setLockInfoFields(ZNRecord record) {", "originalCommit": "7eb25e8daee8d57d90f612442ece294e9f39a857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyMDg1MA==", "url": "https://github.com/apache/helix/pull/718#discussion_r375020850", "bodyText": "I deleted this method, and created a copy constructor in ZKHelixNonblockingLockInfo to copy fields from ZNRecord.", "author": "mgao0", "createdAt": "2020-02-05T01:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NTAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMDI5NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r374900295", "bodyText": "Let's make separator to be consistent either \"/\" or '/'. And it is better to have a constant for it.", "author": "junkaixue", "createdAt": "2020-02-04T20:18:18Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userId);", "originalCommit": "7eb25e8daee8d57d90f612442ece294e9f39a857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyMTA3NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r375021075", "bodyText": "I created a constant for path delimiter. Please see updated version.", "author": "mgao0", "createdAt": "2020-02-05T01:48:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMDI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMDQ4MA==", "url": "https://github.com/apache/helix/pull/718#discussion_r374900480", "bodyText": "Do not hard code it. Make it as a constant.", "author": "junkaixue", "createdAt": "2020-02-04T20:18:45Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (userId.matches(\"[a-f0-9]{8}-[a-f0-9]{4}-4[0-9]{3}-[89ab][a-f0-9]{3}-[0-9a-f]{12}\")) {", "originalCommit": "7eb25e8daee8d57d90f612442ece294e9f39a857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyMTEwNw==", "url": "https://github.com/apache/helix/pull/718#discussion_r375021107", "bodyText": "Done.", "author": "mgao0", "createdAt": "2020-02-05T01:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMDQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMDkwOA==", "url": "https://github.com/apache/helix/pull/718#discussion_r374900908", "bodyText": "you can refactor code like:\nif (!userId.matches(...)) {\nthrow new IllegalArgumentException();\n}\n_userId = userId;", "author": "junkaixue", "createdAt": "2020-02-04T20:19:43Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (userId.matches(\"[a-f0-9]{8}-[a-f0-9]{4}-4[0-9]{3}-[89ab][a-f0-9]{3}-[0-9a-f]{12}\")) {\n+      _userId = userId;\n+    } else {\n+      throw new IllegalArgumentException();\n+    }", "originalCommit": "7eb25e8daee8d57d90f612442ece294e9f39a857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMTMzNA==", "url": "https://github.com/apache/helix/pull/718#discussion_r374901334", "bodyText": "Is this formatted?", "author": "junkaixue", "createdAt": "2020-02-04T20:20:36Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (userId.matches(\"[a-f0-9]{8}-[a-f0-9]{4}-4[0-9]{3}-[89ab][a-f0-9]{3}-[0-9a-f]{12}\")) {\n+      _userId = userId;\n+    } else {\n+      throw new IllegalArgumentException();\n+    }\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));", "originalCommit": "7eb25e8daee8d57d90f612442ece294e9f39a857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5OTg4MA==", "url": "https://github.com/apache/helix/pull/718#discussion_r374999880", "bodyText": "It is formatted", "author": "mgao0", "createdAt": "2020-02-05T00:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMTMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMjQzNg==", "url": "https://github.com/apache/helix/pull/718#discussion_r374902436", "bodyText": "If you dont need to return Stat data, then you can pass null as argument. If you need it, set it in the ZNRecord.", "author": "junkaixue", "createdAt": "2020-02-04T20:22:52Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (userId.matches(\"[a-f0-9]{8}-[a-f0-9]{4}-4[0-9]{3}-[89ab][a-f0-9]{3}-[0-9a-f]{12}\")) {\n+      _userId = userId;\n+    } else {\n+      throw new IllegalArgumentException();\n+    }\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);", "originalCommit": "7eb25e8daee8d57d90f612442ece294e9f39a857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyMTY0NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r375021645", "bodyText": "I use this Stat data to get the version number for the set operation later. It is one time use so i didn't set it in the ZNRecord.", "author": "mgao0", "createdAt": "2020-02-05T01:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMjQzNg=="}], "type": "inlineReview"}, {"oid": "28db99ce4c384dee130067c45415f80fc8358eb1", "url": "https://github.com/apache/helix/commit/28db99ce4c384dee130067c45415f80fc8358eb1", "message": "Fixed logic of release and isOwner", "committedDate": "2020-02-05T00:25:55Z", "type": "commit"}, {"oid": "28db99ce4c384dee130067c45415f80fc8358eb1", "url": "https://github.com/apache/helix/commit/28db99ce4c384dee130067c45415f80fc8358eb1", "message": "Fixed logic of release and isOwner", "committedDate": "2020-02-05T00:25:55Z", "type": "forcePushed"}, {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "url": "https://github.com/apache/helix/commit/22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "message": "Added test to acquire lock simultaneously", "committedDate": "2020-02-05T01:38:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNDYxNA==", "url": "https://github.com/apache/helix/pull/718#discussion_r375524614", "bodyText": "Use a string join method? FYI, https://www.geeksforgeeks.org/java-string-join-examples/", "author": "jiajunwang", "createdAt": "2020-02-05T21:43:09Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNTQyOA==", "url": "https://github.com/apache/helix/pull/718#discussion_r375525428", "bodyText": "I'm not sure why a random string won't work? Given this will be provided by the caller anyway.\nMoreover, if doing so, we will need to document this in detail.", "author": "jiajunwang", "createdAt": "2020-02-05T21:45:00Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MDAwNQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r375590005", "bodyText": "You are right, as long as we ask caller to provide user id themselves, we don't have control over it. But it works for our current use cases. So I'll remove the user id validation for now, since we don't want to make it harder for users to use.", "author": "mgao0", "createdAt": "2020-02-06T00:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNTQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNTg4Mw==", "url": "https://github.com/apache/helix/pull/718#discussion_r375525883", "bodyText": "Use factory. I think the constructor is deprecated and will be private in the new ZK module.", "author": "jiajunwang", "createdAt": "2020-02-05T21:45:47Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNjQyMA==", "url": "https://github.com/apache/helix/pull/718#discussion_r375526420", "bodyText": "Since this is the only access method you need, why we create a ZkClient first? Note that the accessor constructor will create an instance of zkclient internally.", "author": "jiajunwang", "createdAt": "2020-02-05T21:46:58Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNzQ0Mw==", "url": "https://github.com/apache/helix/pull/718#discussion_r375527443", "bodyText": "new LockUpdater(); is doing the same operation, right?", "author": "jiajunwang", "createdAt": "2020-02-05T21:49:15Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyODAyNQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r375528025", "bodyText": "I'm not 100% sure, but it seems to be better if we have the default value here given the ZnRecord is not complete, znRecord.getSimpleField(InfoKey.OWNER.name(),DEFAULT_OWNER_TEXT );\nSame for the other 2 fields.", "author": "jiajunwang", "createdAt": "2020-02-05T21:50:29Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<K extends ZKHelixNonblockingLockInfo.InfoKey, V extends String> implements LockInfo<K, V> {\n+\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final String DEFAULT_TIMEOUT_TEXT = String.valueOf(-1);\n+  private Map<InfoKey, String> lockInfo;\n+\n+  public enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+    lockInfo.put(InfoKey.OWNER, DEFAULT_OWNER_TEXT);\n+    lockInfo.put(InfoKey.MESSAGE, DEFAULT_MESSAGE_TEXT);\n+    lockInfo.put(InfoKey.TIMEOUT, DEFAULT_TIMEOUT_TEXT);\n+  }\n+\n+  public ZKHelixNonblockingLockInfo(ZNRecord znRecord) {\n+    this();\n+    lockInfo.put(InfoKey.OWNER, znRecord.getSimpleField(InfoKey.OWNER.name()));", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyODY2OQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r375528669", "bodyText": "Record the current user Id here for debug.", "author": "jiajunwang", "createdAt": "2020-02-05T21:51:53Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_MESSAGE_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_TEXT);\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public ZKHelixNonblockingLockInfo getLockInfo() {\n+    if (!_baseDataAccessor.exists(_lockPath, AccessOption.PERSISTENT)) {\n+      return new ZKHelixNonblockingLockInfo();\n+    }\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new ZKHelixNonblockingLockInfo(curLockInfo);\n+  }\n+\n+  @Override\n+  public boolean isOwner() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    if (curLockInfo == null) {\n+      return false;\n+    }\n+    return userIdMatches(curLockInfo) && !hasTimedOut(curLockInfo);\n+  }\n+\n+  /**\n+   * Check if a lock has timed out\n+   * @param record the current lock information in ZNRecord format\n+   * @return return true if the lock has timed out, otherwise return false.\n+   */\n+  private boolean hasTimedOut(ZNRecord record) {\n+    String timeoutStr = record.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name());\n+    return System.currentTimeMillis() >= Long.parseLong(timeoutStr);\n+  }\n+\n+  /**\n+   * Check if the current user Id matches with the owner Id in a lock info\n+   * @param record the lock information in ZNRecord format\n+   * @return return true if the two ids match, otherwise return false.\n+   */\n+  private boolean userIdMatches(ZNRecord record) {\n+    String ownerId = record.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name());\n+    return ownerId.equals(_userId);\n+  }\n+\n+  /**\n+   * Class that specifies how a lock node should be updated with another lock node for a lock owner only\n+   */\n+  private class LockUpdater implements DataUpdater<ZNRecord> {\n+    final ZNRecord _record;\n+\n+    /**\n+     * Initialize a structure for lock owner to update a lock node value\n+     * @param record the lock node value will be updated in ZNRecord format\n+     */\n+    public LockUpdater(ZNRecord record) {\n+      _record = record;\n+    }\n+\n+    @Override\n+    public ZNRecord update(ZNRecord current) {\n+      if (current != null && userIdMatches(current) && !hasTimedOut(current)) {\n+        return _record;\n+      }\n+      throw new HelixException(\"User is not authorized to perform this operation.\");", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTA2MQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r375529061", "bodyText": "Try catch on the update? If the update fails because of use Id mismatch or timeout, the release operation is done.\nNote that ZK exception should still be thrown.", "author": "jiajunwang", "createdAt": "2020-02-05T21:52:48Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_MESSAGE_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_TEXT);\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxMDM2MA==", "url": "https://github.com/apache/helix/pull/718#discussion_r375610360", "bodyText": "Let's discuss about this further.\nIn my current implementation, we allow a user to update a lock that currently has no owner or currently belongs to this person with the usage of the updater, data accessor will handle the NoNode or WrongVersion situations, and retry until the node exists and version is correct. And the release call will return a true.\nHowever, after comparison we determine it is the correct version, and find out that a lock user try to update a lock that is currently held by someone else, the updater throws an exception which is to be caught by the data accessor, so data accessor will return an error retCode and return false immediately (no more retries) for the update call, but no exception will be thrown from the update call.\nSo there shouldn't be any exceptions I could catch when calling the update with data accessor.", "author": "mgao0", "createdAt": "2020-02-06T02:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTQ5NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r375529495", "bodyText": "Call it the deadline or something else. timeout and _timeout together are too confusing...", "author": "jiajunwang", "createdAt": "2020-02-05T21:53:45Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTg4NA==", "url": "https://github.com/apache/helix/pull/718#discussion_r375529884", "bodyText": "Or, you can also update the _timeout to some name else. Might be easier. Either way.", "author": "jiajunwang", "createdAt": "2020-02-05T21:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMDA2Nw==", "url": "https://github.com/apache/helix/pull/718#discussion_r375530067", "bodyText": "setLongField", "author": "jiajunwang", "createdAt": "2020-02-05T21:54:59Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMTAwOA==", "url": "https://github.com/apache/helix/pull/718#discussion_r375531008", "bodyText": "try catch instead of calling twice?", "author": "jiajunwang", "createdAt": "2020-02-05T21:57:11Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_MESSAGE_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_TEXT);\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public ZKHelixNonblockingLockInfo getLockInfo() {\n+    if (!_baseDataAccessor.exists(_lockPath, AccessOption.PERSISTENT)) {\n+      return new ZKHelixNonblockingLockInfo();\n+    }\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5NzY4NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r375597685", "bodyText": "I changed it to only call get once, and didn't use try catch. Instead, if the node doesn't exist, curLockInfo would be null, and I chose to handle it in the constructor of ZKHelixNonblockingLockInfo(ZNRecord).", "author": "mgao0", "createdAt": "2020-02-06T01:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMTAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMTY4Ng==", "url": "https://github.com/apache/helix/pull/718#discussion_r375531686", "bodyText": "getLongField", "author": "jiajunwang", "createdAt": "2020-02-05T21:58:25Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_MESSAGE_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_TEXT);\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public ZKHelixNonblockingLockInfo getLockInfo() {\n+    if (!_baseDataAccessor.exists(_lockPath, AccessOption.PERSISTENT)) {\n+      return new ZKHelixNonblockingLockInfo();\n+    }\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new ZKHelixNonblockingLockInfo(curLockInfo);\n+  }\n+\n+  @Override\n+  public boolean isOwner() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    if (curLockInfo == null) {\n+      return false;\n+    }\n+    return userIdMatches(curLockInfo) && !hasTimedOut(curLockInfo);\n+  }\n+\n+  /**\n+   * Check if a lock has timed out\n+   * @param record the current lock information in ZNRecord format\n+   * @return return true if the lock has timed out, otherwise return false.\n+   */\n+  private boolean hasTimedOut(ZNRecord record) {\n+    String timeoutStr = record.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name());", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMjY1MA==", "url": "https://github.com/apache/helix/pull/718#discussion_r375532650", "bodyText": "I don't have a strong preference. But it might be easier for our customers if we return the remaining time instead of a boolean. If the lock owner changed, we just return -1.", "author": "jiajunwang", "createdAt": "2020-02-05T22:00:38Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_MESSAGE_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_TEXT);\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public ZKHelixNonblockingLockInfo getLockInfo() {\n+    if (!_baseDataAccessor.exists(_lockPath, AccessOption.PERSISTENT)) {\n+      return new ZKHelixNonblockingLockInfo();\n+    }\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new ZKHelixNonblockingLockInfo(curLockInfo);\n+  }\n+\n+  @Override\n+  public boolean isOwner() {", "originalCommit": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MTQ1Mw==", "url": "https://github.com/apache/helix/pull/718#discussion_r375591453", "bodyText": "I personally prefer to have it return a boolean because it is more intuitive with the method name. But what you mentioned is a valid point, for now customers can call getLockInfo and get the expire time of the lock. If we see any future needs from customer, we can add a method to get the remaining time of the lock.", "author": "mgao0", "createdAt": "2020-02-06T00:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMjY1MA=="}], "type": "inlineReview"}, {"oid": "cc3a5333c905be1f6b7f9767c70a994567de9277", "url": "https://github.com/apache/helix/commit/cc3a5333c905be1f6b7f9767c70a994567de9277", "message": "A few fixes on syntax", "committedDate": "2020-02-06T19:59:05Z", "type": "commit"}, {"oid": "cdb109d0f39e9a1a13c5a56a982b29742be72a54", "url": "https://github.com/apache/helix/commit/cdb109d0f39e9a1a13c5a56a982b29742be72a54", "message": "Changed method doc for releaseLock in HelixLock interface", "committedDate": "2020-02-06T20:02:00Z", "type": "commit"}, {"oid": "cdb109d0f39e9a1a13c5a56a982b29742be72a54", "url": "https://github.com/apache/helix/commit/cdb109d0f39e9a1a13c5a56a982b29742be72a54", "message": "Changed method doc for releaseLock in HelixLock interface", "committedDate": "2020-02-06T20:02:00Z", "type": "forcePushed"}, {"oid": "0607bcdfd34cf4901eba3d7b0f10e6c5e8743a86", "url": "https://github.com/apache/helix/commit/0607bcdfd34cf4901eba3d7b0f10e6c5e8743a86", "message": "Fixed lock path generation", "committedDate": "2020-02-07T01:44:38Z", "type": "commit"}, {"oid": "f1590f59f85d235929459910152999d17aa3a236", "url": "https://github.com/apache/helix/commit/f1590f59f85d235929459910152999d17aa3a236", "message": "simplified acquireLock logic", "committedDate": "2020-02-07T04:40:50Z", "type": "commit"}, {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a", "url": "https://github.com/apache/helix/commit/0b95d02b3873861dd3a71554e65c56f012035e6a", "message": "Added cluster level to HelixLockScope and convert lock path to uppercase", "committedDate": "2020-02-07T22:53:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1MjkyNw==", "url": "https://github.com/apache/helix/pull/718#discussion_r377352927", "bodyText": "It could be cleaner if we have an abstract HelixScope class. Then there should be no duplicate code at all.\nThen things we can put into the parent class:\n\nStringTemplate template\nclusterName\nzkPath\ntype\ntheir get methods\nparticipant name is also something in common. But I think this one is not generic enough for the parent abstract class.", "author": "jiajunwang", "createdAt": "2020-02-10T22:23:31Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/HelixLockScope.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.List;\n+\n+import org.apache.helix.util.StringTemplate;\n+\n+\n+/**\n+ *  Defines the various scopes of Helix locks, and how they are represented on Zookeeper\n+ */\n+public class HelixLockScope {", "originalCommit": "0b95d02b3873861dd3a71554e65c56f012035e6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgyOTA0Mw==", "url": "https://github.com/apache/helix/pull/718#discussion_r377829043", "bodyText": "You are right, it would be cleaner if we have an abstract class. But I decided not to do it at this time because\n\nHelixLockScope and HelixConfigScope don't share the same logic for most part, for example: HelixConfigScope takes a mapKey as a variable in the constructor while HelixLockScope does not, and these two classes don't define same zkPath argument number for each level so the getZkPath logic is different too.\nWe want to decouple Helix Lock module from Helix core module, so in the future if needed we can freely extend the lock scope for other usages of the lock module.", "author": "mgao0", "createdAt": "2020-02-11T18:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1MjkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3MjAyNw==", "url": "https://github.com/apache/helix/pull/718#discussion_r377872027", "bodyText": "Discussed offline. Will make this LockScope more generic so user can define the properties themselves.", "author": "mgao0", "createdAt": "2020-02-11T20:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1MjkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1Mzk0NA==", "url": "https://github.com/apache/helix/pull/718#discussion_r377353944", "bodyText": "Should this be part of the lock scope?", "author": "jiajunwang", "createdAt": "2020-02-10T22:25:48Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT;\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_LONG;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"/LOCK\";", "originalCommit": "0b95d02b3873861dd3a71554e65c56f012035e6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1Njc3MA==", "url": "https://github.com/apache/helix/pull/718#discussion_r377356770", "bodyText": "Comment that the default constructor creates an unlocked lock.", "author": "jiajunwang", "createdAt": "2020-02-10T22:31:56Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT;\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_LONG;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"/LOCK\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixLockScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName.toUpperCase() + LOCK_ROOT + scope.getZkPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo.setLongField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), deadline);\n+\n+    LockUpdater updater = new LockUpdater(lockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZKHelixNonblockingLockInfo<>().toZNRecord();", "originalCommit": "0b95d02b3873861dd3a71554e65c56f012035e6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1NzI1NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r377357255", "bodyText": "Should be true? If there is no such lock node, we can assume timeout == true, right?", "author": "jiajunwang", "createdAt": "2020-02-10T22:33:00Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT;\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_LONG;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"/LOCK\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixLockScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName.toUpperCase() + LOCK_ROOT + scope.getZkPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo.setLongField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), deadline);\n+\n+    LockUpdater updater = new LockUpdater(lockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZKHelixNonblockingLockInfo<>().toZNRecord();\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public ZKHelixNonblockingLockInfo getLockInfo() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new ZKHelixNonblockingLockInfo(curLockInfo);\n+  }\n+\n+  @Override\n+  public boolean isOwner() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return userIdMatches(curLockInfo) && !hasTimedOut(curLockInfo);\n+  }\n+\n+  /**\n+   * Check if a lock has timed out\n+   * @param record the current lock information in ZNRecord format\n+   * @return return true if the lock has timed out, otherwise return false.\n+   */\n+  private boolean hasTimedOut(ZNRecord record) {\n+    if (record == null) {\n+      return false;", "originalCommit": "0b95d02b3873861dd3a71554e65c56f012035e6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1ODMzMA==", "url": "https://github.com/apache/helix/pull/718#discussion_r377358330", "bodyText": "This logic should belong to the ZKHelixNonblockingLockInfo class. Considering in the near future, we want to add several more fields into ZKHelixNonblockingLockInfo. You will find we need to update ZKHelixNonblockingLockInfo class and this section.", "author": "jiajunwang", "createdAt": "2020-02-10T22:35:32Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT;\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_LONG;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"/LOCK\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixLockScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName.toUpperCase() + LOCK_ROOT + scope.getZkPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields", "originalCommit": "0b95d02b3873861dd3a71554e65c56f012035e6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgyOTczOA==", "url": "https://github.com/apache/helix/pull/718#discussion_r377829738", "bodyText": "Very good suggestion. I moved all the set lock info logic to LockInfo class.", "author": "mgao0", "createdAt": "2020-02-11T18:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1ODMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1ODkyMQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r377358921", "bodyText": "As I commented above, there should be a default constructor that builds instance with strongly typed parameters. And the other 2 constructors can call that one inside.", "author": "jiajunwang", "createdAt": "2020-02-10T22:36:52Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<K extends ZKHelixNonblockingLockInfo.InfoKey, V extends String> implements LockInfo<K, V> {\n+\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+  public static final String DEFAULT_TIMEOUT_TEXT = String.valueOf(DEFAULT_TIMEOUT_LONG);\n+  private Map<InfoKey, String> lockInfo;\n+\n+  public enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Constructor of ZKHelixNonblockingLockInfo that set each field to default data\n+   */\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+    lockInfo.put(InfoKey.OWNER, DEFAULT_OWNER_TEXT);\n+    lockInfo.put(InfoKey.MESSAGE, DEFAULT_MESSAGE_TEXT);\n+    lockInfo.put(InfoKey.TIMEOUT, DEFAULT_TIMEOUT_TEXT);\n+  }\n+\n+  /**\n+   * Construct a ZKHelixNonblockingLockInfo using a ZNRecord format of data\n+   * @param znRecord A ZNRecord that contains lock information in its simple fields\n+   */\n+  public ZKHelixNonblockingLockInfo(ZNRecord znRecord) {", "originalCommit": "0b95d02b3873861dd3a71554e65c56f012035e6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzMjU2Nw==", "url": "https://github.com/apache/helix/pull/718#discussion_r377832567", "bodyText": "I added the strongly typed parameter constructor. But currently I'm not calling this method using the other 2 constructors since I made the LockInfo class extend HelixProperty, and I used the super(). With super(), a ZNRecord is already created so we only need to update the values in the ZNRecord.", "author": "mgao0", "createdAt": "2020-02-11T18:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1ODkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1OTI4NA==", "url": "https://github.com/apache/helix/pull/718#discussion_r377359284", "bodyText": "This could be confusing. I suggest having a static method for building unlocked lock. And you can keep an static final object internal, and we don't need to create new object every time.", "author": "jiajunwang", "createdAt": "2020-02-10T22:37:46Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<K extends ZKHelixNonblockingLockInfo.InfoKey, V extends String> implements LockInfo<K, V> {\n+\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+  public static final String DEFAULT_TIMEOUT_TEXT = String.valueOf(DEFAULT_TIMEOUT_LONG);\n+  private Map<InfoKey, String> lockInfo;\n+\n+  public enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Constructor of ZKHelixNonblockingLockInfo that set each field to default data\n+   */\n+  public ZKHelixNonblockingLockInfo() {", "originalCommit": "0b95d02b3873861dd3a71554e65c56f012035e6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1OTczNA==", "url": "https://github.com/apache/helix/pull/718#discussion_r377359734", "bodyText": "This class should extend HelixProperty? In that case, you have everything you need regarding ZnRecord.", "author": "jiajunwang", "createdAt": "2020-02-10T22:38:47Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<K extends ZKHelixNonblockingLockInfo.InfoKey, V extends String> implements LockInfo<K, V> {", "originalCommit": "0b95d02b3873861dd3a71554e65c56f012035e6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzMzQ2NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r377833465", "bodyText": "Made it extend HelixPropery. I also handled it to ensure there are no null values in the LockInfo, so there are some methods or logics to set the null values in ZNRecord to the default values I defined for the LockInfo.", "author": "mgao0", "createdAt": "2020-02-11T18:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1OTczNA=="}], "type": "inlineReview"}, {"oid": "0ab82e6fd94d7e46a81b37e79b5008b8500849cf", "url": "https://github.com/apache/helix/commit/0ab82e6fd94d7e46a81b37e79b5008b8500849cf", "message": "refactor LockInfo and some updates on the HelixLockScope", "committedDate": "2020-02-11T18:39:00Z", "type": "commit"}, {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "url": "https://github.com/apache/helix/commit/4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "message": "Created LockScope interface", "committedDate": "2020-02-14T21:28:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NjY2NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r379656665", "bodyText": "Should this one be the ownerId? Or what is the use case of this default constructor?", "author": "jiajunwang", "createdAt": "2020-02-14T21:39:04Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord id, set all info fields to default data\n+   */\n+  public LockInfo(String id) {\n+    super(id);", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzAwNg==", "url": "https://github.com/apache/helix/pull/718#discussion_r379657006", "bodyText": "Another option, just keep all lock node's ZNRecord id to be \"LOCK\"", "author": "jiajunwang", "createdAt": "2020-02-14T21:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NjY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwNDg5Ng==", "url": "https://github.com/apache/helix/pull/718#discussion_r379704896", "bodyText": "I has changed the ZNRecord id to \"LOCK\".", "author": "mgao0", "createdAt": "2020-02-15T01:06:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NjY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzU2OA==", "url": "https://github.com/apache/helix/pull/718#discussion_r379657568", "bodyText": "Should accept LockInfo object.", "author": "jiajunwang", "createdAt": "2020-02-14T21:41:14Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord id, set all info fields to default data\n+   */\n+  public LockInfo(String id) {\n+    super(id);\n+    resetLockInfo();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord, set all info fields to default data\n+   * @param znRecord The ZNRecord contains lock node data that used to initialize the LockInfo\n+   */\n+  public LockInfo(ZNRecord znRecord) {\n+    super(znRecord);\n+    setNullLockInfoFieldsToDefault();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public LockInfo(String ownerId, String message, long timeout) {\n+    this(ownerId);\n+    setLockInfoFields(ownerId, message, timeout);\n+  }\n+\n+  /**\n+   * Build a LOCKINFO instance that represents an unlocked lock states\n+   * @return the unlocked lock node LockInfo instance\n+   */\n+  public static LockInfo buildUnlockedLockInfo() {\n+    return new LockInfo(\"\");\n+  }\n+\n+  /**\n+   * Set each field of lock info to user provided values if the values are not null, null values are set to default values\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public void setLockInfoFields(String ownerId, String message, Long timeout) {\n+    _record.setSimpleField(LockInfoAttribute.OWNER.name(),\n+        ownerId == null ? DEFAULT_OWNER_TEXT : ownerId);\n+    _record.setSimpleField(LockInfoAttribute.MESSAGE.name(),\n+        message == null ? DEFAULT_MESSAGE_TEXT : message);\n+    _record.setLongField(LockInfoAttribute.TIMEOUT.name(),\n+        timeout == null ? DEFAULT_TIMEOUT_LONG : timeout);\n+  }\n+\n+  /**\n+   * Set all null values to default values in LockInfo, keep non-null values\n+   */\n+  private void setNullLockInfoFieldsToDefault() {\n+    setLockInfoFields(getOwner(), getMessage(), getTimeout());\n+  }\n+\n+  /**\n+   * Reset the lock info to unlocked lock state\n+   */\n+  public void resetLockInfo() {\n+    setLockInfoFields(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public String getOwner() {\n+    String owner = _record.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public String getMessage() {\n+    String message = _record.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    return message == null ? DEFAULT_MESSAGE_TEXT : message;\n+  }\n+\n+  /**\n+   * Get the value for TIMEOUT attribute of the lock\n+   * @return the expiring time of the lock, -1 if there is no timeout set\n+   */\n+  public Long getTimeout() {\n+    return _record.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock from a ZNRecord\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public static String getOwner(ZNRecord znRecord) {", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzkzNA==", "url": "https://github.com/apache/helix/pull/718#discussion_r379657934", "bodyText": "And then you can avoid the duplicate code by calling the instance method.", "author": "jiajunwang", "createdAt": "2020-02-14T21:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzYxMg==", "url": "https://github.com/apache/helix/pull/718#discussion_r379657612", "bodyText": "Should accept LockInfo object.", "author": "jiajunwang", "createdAt": "2020-02-14T21:41:20Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord id, set all info fields to default data\n+   */\n+  public LockInfo(String id) {\n+    super(id);\n+    resetLockInfo();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord, set all info fields to default data\n+   * @param znRecord The ZNRecord contains lock node data that used to initialize the LockInfo\n+   */\n+  public LockInfo(ZNRecord znRecord) {\n+    super(znRecord);\n+    setNullLockInfoFieldsToDefault();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public LockInfo(String ownerId, String message, long timeout) {\n+    this(ownerId);\n+    setLockInfoFields(ownerId, message, timeout);\n+  }\n+\n+  /**\n+   * Build a LOCKINFO instance that represents an unlocked lock states\n+   * @return the unlocked lock node LockInfo instance\n+   */\n+  public static LockInfo buildUnlockedLockInfo() {\n+    return new LockInfo(\"\");\n+  }\n+\n+  /**\n+   * Set each field of lock info to user provided values if the values are not null, null values are set to default values\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public void setLockInfoFields(String ownerId, String message, Long timeout) {\n+    _record.setSimpleField(LockInfoAttribute.OWNER.name(),\n+        ownerId == null ? DEFAULT_OWNER_TEXT : ownerId);\n+    _record.setSimpleField(LockInfoAttribute.MESSAGE.name(),\n+        message == null ? DEFAULT_MESSAGE_TEXT : message);\n+    _record.setLongField(LockInfoAttribute.TIMEOUT.name(),\n+        timeout == null ? DEFAULT_TIMEOUT_LONG : timeout);\n+  }\n+\n+  /**\n+   * Set all null values to default values in LockInfo, keep non-null values\n+   */\n+  private void setNullLockInfoFieldsToDefault() {\n+    setLockInfoFields(getOwner(), getMessage(), getTimeout());\n+  }\n+\n+  /**\n+   * Reset the lock info to unlocked lock state\n+   */\n+  public void resetLockInfo() {\n+    setLockInfoFields(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public String getOwner() {\n+    String owner = _record.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public String getMessage() {\n+    String message = _record.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    return message == null ? DEFAULT_MESSAGE_TEXT : message;\n+  }\n+\n+  /**\n+   * Get the value for TIMEOUT attribute of the lock\n+   * @return the expiring time of the lock, -1 if there is no timeout set\n+   */\n+  public Long getTimeout() {\n+    return _record.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock from a ZNRecord\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public static String getOwner(ZNRecord znRecord) {\n+    if (znRecord == null) {\n+      return DEFAULT_OWNER_TEXT;\n+    }\n+    String owner = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock from a ZNRecord\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public static String getMessage(ZNRecord znRecord) {", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzY5MA==", "url": "https://github.com/apache/helix/pull/718#discussion_r379657690", "bodyText": "Should accept LockInfo object.", "author": "jiajunwang", "createdAt": "2020-02-14T21:41:31Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord id, set all info fields to default data\n+   */\n+  public LockInfo(String id) {\n+    super(id);\n+    resetLockInfo();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord, set all info fields to default data\n+   * @param znRecord The ZNRecord contains lock node data that used to initialize the LockInfo\n+   */\n+  public LockInfo(ZNRecord znRecord) {\n+    super(znRecord);\n+    setNullLockInfoFieldsToDefault();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public LockInfo(String ownerId, String message, long timeout) {\n+    this(ownerId);\n+    setLockInfoFields(ownerId, message, timeout);\n+  }\n+\n+  /**\n+   * Build a LOCKINFO instance that represents an unlocked lock states\n+   * @return the unlocked lock node LockInfo instance\n+   */\n+  public static LockInfo buildUnlockedLockInfo() {\n+    return new LockInfo(\"\");\n+  }\n+\n+  /**\n+   * Set each field of lock info to user provided values if the values are not null, null values are set to default values\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public void setLockInfoFields(String ownerId, String message, Long timeout) {\n+    _record.setSimpleField(LockInfoAttribute.OWNER.name(),\n+        ownerId == null ? DEFAULT_OWNER_TEXT : ownerId);\n+    _record.setSimpleField(LockInfoAttribute.MESSAGE.name(),\n+        message == null ? DEFAULT_MESSAGE_TEXT : message);\n+    _record.setLongField(LockInfoAttribute.TIMEOUT.name(),\n+        timeout == null ? DEFAULT_TIMEOUT_LONG : timeout);\n+  }\n+\n+  /**\n+   * Set all null values to default values in LockInfo, keep non-null values\n+   */\n+  private void setNullLockInfoFieldsToDefault() {\n+    setLockInfoFields(getOwner(), getMessage(), getTimeout());\n+  }\n+\n+  /**\n+   * Reset the lock info to unlocked lock state\n+   */\n+  public void resetLockInfo() {\n+    setLockInfoFields(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public String getOwner() {\n+    String owner = _record.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public String getMessage() {\n+    String message = _record.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    return message == null ? DEFAULT_MESSAGE_TEXT : message;\n+  }\n+\n+  /**\n+   * Get the value for TIMEOUT attribute of the lock\n+   * @return the expiring time of the lock, -1 if there is no timeout set\n+   */\n+  public Long getTimeout() {\n+    return _record.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock from a ZNRecord\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public static String getOwner(ZNRecord znRecord) {\n+    if (znRecord == null) {\n+      return DEFAULT_OWNER_TEXT;\n+    }\n+    String owner = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock from a ZNRecord\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public static String getMessage(ZNRecord znRecord) {\n+    if (znRecord == null) {\n+      return DEFAULT_MESSAGE_TEXT;\n+    }\n+    String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    return message == null ? DEFAULT_MESSAGE_TEXT : message;\n+  }\n \n   /**\n-   * Create a single filed of LockInfo, or update the value of the field if it already exists\n-   * @param infoKey the key of the LockInfo field\n-   * @param infoValue the value of the LockInfo field\n+   * Get the value for TIMEOUT attribute of the lock from a ZNRecord\n+   * @return the expiring time of the lock, -1 if there is no timeout set\n    */\n-  void setInfoValue(String infoKey, T infoValue);\n+  public static long getTimeout(ZNRecord znRecord) {", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1ODk5MQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r379658991", "bodyText": "If not necessary, let's don't adding these get methods for now.", "author": "jiajunwang", "createdAt": "2020-02-14T21:44:36Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/HelixLockScope.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.List;\n+\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.util.StringTemplate;\n+\n+\n+/**\n+ *  Defines the various scopes of Helix locks, and how they are represented on Zookeeper\n+ */\n+public class HelixLockScope implements LockScope {\n+\n+  /**\n+   * Define various properties of Helix lock, and associate them with the number of arguments required for getting znode path\n+   */\n+  public enum LockScopeProperty {\n+\n+    CLUSTER(1),\n+\n+    PARTICIPANT(2),\n+\n+    RESOURCE(3),\n+\n+    PARTITION(4);\n+\n+    //the number of arguments required to generate a full path for the specific scope\n+    final int _pathArgNum;\n+\n+    /**\n+     * Initialize a LockScopeProperty\n+     * @param pathArgNum the number of arguments required to generate a full path for the specific scope\n+    \\     */\n+    private LockScopeProperty(int pathArgNum) {\n+      _pathArgNum = pathArgNum;\n+    }\n+\n+    /**\n+     * Get the number of template arguments required to generate a full path\n+     * @return number of template arguments in the path\n+     */\n+    public int getPathArgNum() {\n+      return _pathArgNum;\n+    }\n+\n+    /**\n+     * Get the position of this argument from the input that used to generate the scope\n+     * @return the number of position of value for this property in the list of keys input\n+     */\n+    public int getArgPos() {\n+      return _pathArgNum - 1;\n+    }\n+  }\n+\n+  /**\n+   * string templates to generate znode path\n+   */\n+  private static final StringTemplate template = new StringTemplate();\n+\n+  static {\n+    template.addEntry(LockScopeProperty.CLUSTER, 1, \"/{clusterName}/LOCK\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.PARTICIPANT, 2,\n+        \"/{clusterName}/LOCK/{participantName}\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.RESOURCE, 3,\n+        \"/{clusterName}/LOCK/{participantName}/{resourceName}\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.PARTITION, 4,\n+        \"/{clusterName}/LOCK/{participantName}/{resourceName}/{partitionName}\");\n+  }\n+\n+  private final HelixLockScope.LockScopeProperty _type;\n+  private final String _clusterName;\n+  private final String _participantName;\n+  private final String _resourceName;\n+  private final String _partitionName;\n+\n+  private final String _zkPath;\n+\n+  /**\n+   * Initialize with a type of scope and unique identifiers\n+   * @param type the scope\n+   * @param zkPathKeys keys identifying a ZNode location\n+   */\n+  private HelixLockScope(HelixLockScope.LockScopeProperty type, List<String> zkPathKeys) {\n+\n+    if (zkPathKeys.size() != type.getPathArgNum()) {\n+      throw new IllegalArgumentException(\n+          type + \" requires \" + type.getPathArgNum() + \" arguments to get znode, but was: \"\n+              + zkPathKeys);\n+    }\n+\n+    _type = type;\n+\n+    //Initialize the name fields for various scope\n+    _clusterName = zkPathKeys.get(LockScopeProperty.CLUSTER.getArgPos());\n+\n+    if (type.getPathArgNum() >= LockScopeProperty.PARTICIPANT.getPathArgNum()) {\n+      _participantName = zkPathKeys.get(LockScopeProperty.PARTICIPANT.getArgPos());\n+    } else {\n+      _participantName = null;\n+    }\n+\n+    if (type.getPathArgNum() >= LockScopeProperty.RESOURCE.getPathArgNum()) {\n+      _resourceName = zkPathKeys.get(LockScopeProperty.RESOURCE.getArgPos());\n+    } else {\n+      _resourceName = null;\n+    }\n+\n+    if (type.getPathArgNum() >= LockScopeProperty.PARTITION.getPathArgNum()) {\n+      _partitionName = zkPathKeys.get(LockScopeProperty.PARTITION.getArgPos());\n+    } else {\n+      _partitionName = null;\n+    }\n+\n+    _zkPath = template.instantiate(type, zkPathKeys.toArray(new String[0])).toUpperCase();\n+  }\n+\n+  /**\n+   * Get the scope\n+   * @return the type of scope\n+   */\n+  public HelixLockScope.LockScopeProperty getType() {\n+    return _type;\n+  }\n+\n+  /**\n+   * Get the cluster name if it exists\n+   * @return the cluster name\n+   */\n+  public String getClusterName() {", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1OTI5MQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r379659291", "bodyText": "This will be a shared path with the other scope types. I think it might cause some conflicts.", "author": "jiajunwang", "createdAt": "2020-02-14T21:45:27Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/HelixLockScope.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.List;\n+\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.util.StringTemplate;\n+\n+\n+/**\n+ *  Defines the various scopes of Helix locks, and how they are represented on Zookeeper\n+ */\n+public class HelixLockScope implements LockScope {\n+\n+  /**\n+   * Define various properties of Helix lock, and associate them with the number of arguments required for getting znode path\n+   */\n+  public enum LockScopeProperty {\n+\n+    CLUSTER(1),\n+\n+    PARTICIPANT(2),\n+\n+    RESOURCE(3),\n+\n+    PARTITION(4);\n+\n+    //the number of arguments required to generate a full path for the specific scope\n+    final int _pathArgNum;\n+\n+    /**\n+     * Initialize a LockScopeProperty\n+     * @param pathArgNum the number of arguments required to generate a full path for the specific scope\n+    \\     */\n+    private LockScopeProperty(int pathArgNum) {\n+      _pathArgNum = pathArgNum;\n+    }\n+\n+    /**\n+     * Get the number of template arguments required to generate a full path\n+     * @return number of template arguments in the path\n+     */\n+    public int getPathArgNum() {\n+      return _pathArgNum;\n+    }\n+\n+    /**\n+     * Get the position of this argument from the input that used to generate the scope\n+     * @return the number of position of value for this property in the list of keys input\n+     */\n+    public int getArgPos() {\n+      return _pathArgNum - 1;\n+    }\n+  }\n+\n+  /**\n+   * string templates to generate znode path\n+   */\n+  private static final StringTemplate template = new StringTemplate();\n+\n+  static {\n+    template.addEntry(LockScopeProperty.CLUSTER, 1, \"/{clusterName}/LOCK\");", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMjg4Nw==", "url": "https://github.com/apache/helix/pull/718#discussion_r379712887", "bodyText": "Changed it to the same format as path for cluster in HelixConfigScope, should not have conflicts now.", "author": "mgao0", "createdAt": "2020-02-15T02:57:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1OTI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1OTU4NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r379659585", "bodyText": "Can I lock the whole resource regardless of which participant holding it?", "author": "jiajunwang", "createdAt": "2020-02-14T21:46:17Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/HelixLockScope.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.List;\n+\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.util.StringTemplate;\n+\n+\n+/**\n+ *  Defines the various scopes of Helix locks, and how they are represented on Zookeeper\n+ */\n+public class HelixLockScope implements LockScope {\n+\n+  /**\n+   * Define various properties of Helix lock, and associate them with the number of arguments required for getting znode path\n+   */\n+  public enum LockScopeProperty {\n+\n+    CLUSTER(1),\n+\n+    PARTICIPANT(2),\n+\n+    RESOURCE(3),\n+\n+    PARTITION(4);\n+\n+    //the number of arguments required to generate a full path for the specific scope\n+    final int _pathArgNum;\n+\n+    /**\n+     * Initialize a LockScopeProperty\n+     * @param pathArgNum the number of arguments required to generate a full path for the specific scope\n+    \\     */\n+    private LockScopeProperty(int pathArgNum) {\n+      _pathArgNum = pathArgNum;\n+    }\n+\n+    /**\n+     * Get the number of template arguments required to generate a full path\n+     * @return number of template arguments in the path\n+     */\n+    public int getPathArgNum() {\n+      return _pathArgNum;\n+    }\n+\n+    /**\n+     * Get the position of this argument from the input that used to generate the scope\n+     * @return the number of position of value for this property in the list of keys input\n+     */\n+    public int getArgPos() {\n+      return _pathArgNum - 1;\n+    }\n+  }\n+\n+  /**\n+   * string templates to generate znode path\n+   */\n+  private static final StringTemplate template = new StringTemplate();\n+\n+  static {\n+    template.addEntry(LockScopeProperty.CLUSTER, 1, \"/{clusterName}/LOCK\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.PARTICIPANT, 2,\n+        \"/{clusterName}/LOCK/{participantName}\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.RESOURCE, 3,\n+        \"/{clusterName}/LOCK/{participantName}/{resourceName}\");", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwOTY3Mw==", "url": "https://github.com/apache/helix/pull/718#discussion_r379709673", "bodyText": "Yes, as discussed, I'll make it flat path for now.", "author": "mgao0", "createdAt": "2020-02-15T02:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1OTU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1OTc1MA==", "url": "https://github.com/apache/helix/pull/718#discussion_r379659750", "bodyText": "Same here, the participant should not be part of the path.", "author": "jiajunwang", "createdAt": "2020-02-14T21:46:47Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/HelixLockScope.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.List;\n+\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.util.StringTemplate;\n+\n+\n+/**\n+ *  Defines the various scopes of Helix locks, and how they are represented on Zookeeper\n+ */\n+public class HelixLockScope implements LockScope {\n+\n+  /**\n+   * Define various properties of Helix lock, and associate them with the number of arguments required for getting znode path\n+   */\n+  public enum LockScopeProperty {\n+\n+    CLUSTER(1),\n+\n+    PARTICIPANT(2),\n+\n+    RESOURCE(3),\n+\n+    PARTITION(4);\n+\n+    //the number of arguments required to generate a full path for the specific scope\n+    final int _pathArgNum;\n+\n+    /**\n+     * Initialize a LockScopeProperty\n+     * @param pathArgNum the number of arguments required to generate a full path for the specific scope\n+    \\     */\n+    private LockScopeProperty(int pathArgNum) {\n+      _pathArgNum = pathArgNum;\n+    }\n+\n+    /**\n+     * Get the number of template arguments required to generate a full path\n+     * @return number of template arguments in the path\n+     */\n+    public int getPathArgNum() {\n+      return _pathArgNum;\n+    }\n+\n+    /**\n+     * Get the position of this argument from the input that used to generate the scope\n+     * @return the number of position of value for this property in the list of keys input\n+     */\n+    public int getArgPos() {\n+      return _pathArgNum - 1;\n+    }\n+  }\n+\n+  /**\n+   * string templates to generate znode path\n+   */\n+  private static final StringTemplate template = new StringTemplate();\n+\n+  static {\n+    template.addEntry(LockScopeProperty.CLUSTER, 1, \"/{clusterName}/LOCK\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.PARTICIPANT, 2,\n+        \"/{clusterName}/LOCK/{participantName}\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.RESOURCE, 3,\n+        \"/{clusterName}/LOCK/{participantName}/{resourceName}\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.PARTITION, 4,\n+        \"/{clusterName}/LOCK/{participantName}/{resourceName}/{partitionName}\");", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MDQ5Mg==", "url": "https://github.com/apache/helix/pull/718#discussion_r379660492", "bodyText": "This is fine. But if timeout cannot be negative, we should check this in the constructor.", "author": "jiajunwang", "createdAt": "2020-02-14T21:48:48Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.lock.HelixLock;\n+import org.apache.helix.lock.LockInfo;\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(LockScope scope, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    this(scope.getPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwNTI0NQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r379705245", "bodyText": "Added the check in the constructor.", "author": "mgao0", "createdAt": "2020-02-15T01:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MDQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MDgzMA==", "url": "https://github.com/apache/helix/pull/718#discussion_r379660830", "bodyText": "This can be a private constructor if this is the only caller.", "author": "jiajunwang", "createdAt": "2020-02-14T21:49:45Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MTQ2OQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r379661469", "bodyText": "GetCurrentLockInfo? Since this method is not returning this instance's lock info.\nActually, keep it a static method could be cleaner.\nAlso for the following method isOwner().", "author": "jiajunwang", "createdAt": "2020-02-14T21:51:37Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.lock.HelixLock;\n+import org.apache.helix.lock.LockInfo;\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(LockScope scope, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    this(scope.getPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    LockInfo lockInfo = new LockInfo(_userId);\n+    lockInfo.setLockInfoFields(_userId, _lockMsg, deadline);\n+\n+    LockUpdater updater = new LockUpdater(lockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    // Initialize the lock updater with a default lock info represents the state of a unlocked lock\n+    LockUpdater updater = new LockUpdater(LockInfo.defaultLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public LockInfo getLockInfo() {", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMjgyNQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r379712825", "bodyText": "To call getCurrentLockInfo would need a lockPath defined. So here I will not change it to a static method.", "author": "mgao0", "createdAt": "2020-02-15T02:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MTQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MTc5OQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r379661799", "bodyText": "Humm... These two are really confusing.", "author": "jiajunwang", "createdAt": "2020-02-14T21:52:33Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.lock.HelixLock;\n+import org.apache.helix.lock.LockInfo;\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(LockScope scope, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    this(scope.getPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    LockInfo lockInfo = new LockInfo(_userId);\n+    lockInfo.setLockInfoFields(_userId, _lockMsg, deadline);\n+\n+    LockUpdater updater = new LockUpdater(lockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    // Initialize the lock updater with a default lock info represents the state of a unlocked lock\n+    LockUpdater updater = new LockUpdater(LockInfo.defaultLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public LockInfo getLockInfo() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new LockInfo(curLockInfo);\n+  }\n+\n+  @Override\n+  public boolean isOwner() {\n+    LockInfo lockInfo = getLockInfo();\n+    return userIdMatches(lockInfo) && !hasTimedOut(lockInfo);\n+  }\n+\n+  /**\n+   * Check if a lock has timed out\n+   * @return return true if the lock has timed out, otherwise return false.\n+   */\n+  private boolean hasTimedOut(LockInfo lockInfo) {\n+    return System.currentTimeMillis() >= lockInfo.getTimeout();\n+  }\n+\n+  /**\n+   * Check if a lock has timed out with lock information stored in a ZNRecord\n+   * @return return true if the lock has timed out, otherwise return false.\n+   */\n+  private boolean hasTimedOut(ZNRecord znRecord) {\n+    return System.currentTimeMillis() >= LockInfo.getTimeout(znRecord);\n+  }\n+\n+  /**\n+   * Check if the current user Id matches with the owner Id in a lock info", "originalCommit": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwNjc1MA==", "url": "https://github.com/apache/helix/pull/718#discussion_r379706750", "bodyText": "I tried to split methods into smaller logic so that it can be reused. But since now I'm only using once for each method, I guess this is not necessary to do that. I've rearranged the methods so it is less confusing.", "author": "mgao0", "createdAt": "2020-02-15T01:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MTc5OQ=="}], "type": "inlineReview"}, {"oid": "586f717340751420594750a17dfcfca16781865c", "url": "https://github.com/apache/helix/commit/586f717340751420594750a17dfcfca16781865c", "message": "Clean up code", "committedDate": "2020-02-18T17:48:14Z", "type": "commit"}, {"oid": "586f717340751420594750a17dfcfca16781865c", "url": "https://github.com/apache/helix/commit/586f717340751420594750a17dfcfca16781865c", "message": "Clean up code", "committedDate": "2020-02-18T17:48:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNTc3Mg==", "url": "https://github.com/apache/helix/pull/718#discussion_r380915772", "bodyText": "Put a TODO here. This Helix Property will be replaced since distributed lock will be a module independent from Helix.", "author": "junkaixue", "createdAt": "2020-02-18T20:26:20Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,109 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {", "originalCommit": "586f717340751420594750a17dfcfca16781865c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2NDMzMg==", "url": "https://github.com/apache/helix/pull/718#discussion_r380964332", "bodyText": "In this case I can remove the \"extends HelixProperty\" to make it independent from Helix. The LockInfo is barely a ZNRecord, and currently I'm not using any properties and methods exclusively provided by HelixProperty.", "author": "mgao0", "createdAt": "2020-02-18T22:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMTI0OA==", "url": "https://github.com/apache/helix/pull/718#discussion_r381031248", "bodyText": "Sounds good.", "author": "junkaixue", "createdAt": "2020-02-19T01:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNTc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNjI3MQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r380916271", "bodyText": "Why we dont delete the node instead of updating it?", "author": "junkaixue", "createdAt": "2020-02-18T20:27:20Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.lock.HelixLock;\n+import org.apache.helix.lock.LockInfo;\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(LockScope scope, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    this(scope.getPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    if (timeout < 0) {\n+      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    }\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    LockUpdater updater = new LockUpdater(new LockInfo(_userId, _lockMsg, deadline));\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    // Initialize the lock updater with a default lock info represents the state of a unlocked lock\n+    LockUpdater updater = new LockUpdater(LockInfo.defaultLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);", "originalCommit": "586f717340751420594750a17dfcfca16781865c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2Mjg1Nw==", "url": "https://github.com/apache/helix/pull/718#discussion_r380962857", "bodyText": "Directly deleting it can cause race conditions. For example, when we call delete to delete lock node A, but during the process someone else acquired the lock or the current lock owner updated the lock, so currently it's lock node B, as a result the delete call deletes lock node B instead of lock node A, and both the caller and the lock owner wouldn't be aware of this mistake. The update method checks the version of the znode, so it can prevent this situation.", "author": "mgao0", "createdAt": "2020-02-18T22:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNjI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY3Mzk1Ng==", "url": "https://github.com/apache/helix/pull/718#discussion_r381673956", "bodyText": "Keeping this way for now. Added TODO to change it in the future.", "author": "mgao0", "createdAt": "2020-02-20T02:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNjI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNjgzMw==", "url": "https://github.com/apache/helix/pull/718#discussion_r380916833", "bodyText": "What if the path does not exists?", "author": "junkaixue", "createdAt": "2020-02-18T20:28:31Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.lock.HelixLock;\n+import org.apache.helix.lock.LockInfo;\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(LockScope scope, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    this(scope.getPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    if (timeout < 0) {\n+      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    }\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    LockUpdater updater = new LockUpdater(new LockInfo(_userId, _lockMsg, deadline));\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    // Initialize the lock updater with a default lock info represents the state of a unlocked lock\n+    LockUpdater updater = new LockUpdater(LockInfo.defaultLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public LockInfo getCurrentLockInfo() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new LockInfo(curLockInfo);", "originalCommit": "586f717340751420594750a17dfcfca16781865c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MDA5Nw==", "url": "https://github.com/apache/helix/pull/718#discussion_r380960097", "bodyText": "Data accessor returns a null, and when converting it to the LockInfo, a LockInfo instance with all the fields filled with default values (which is also the value we use to represent an unlocked lock node) will be returned.", "author": "mgao0", "createdAt": "2020-02-18T21:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNjgzMw=="}], "type": "inlineReview"}, {"oid": "cdc7d3474099071dbd30ecf57f76aae31e197a8f", "url": "https://github.com/apache/helix/commit/cdc7d3474099071dbd30ecf57f76aae31e197a8f", "message": "Remove dependency of LockInfo on HelixProperty", "committedDate": "2020-02-18T22:21:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMTgxNg==", "url": "https://github.com/apache/helix/pull/718#discussion_r381031816", "bodyText": "Let's have the interface as DistributedLock or something. Name it HelixLock still seemed to be sticking to Helix.", "author": "junkaixue", "createdAt": "2020-02-19T01:32:11Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/HelixLock.java", "diffHunk": "@@ -22,7 +22,7 @@\n /**\n  * Generic interface for Helix distributed lock\n  */\n-public interface HelixLock<T> {\n+public interface HelixLock {", "originalCommit": "cdc7d3474099071dbd30ecf57f76aae31e197a8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMTg3MQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r381031871", "bodyText": "Make one element per line.", "author": "junkaixue", "createdAt": "2020-02-19T01:32:24Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,106 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo =\n+      new LockInfo(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+\n+  private ZNRecord record;\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT", "originalCommit": "cdc7d3474099071dbd30ecf57f76aae31e197a8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMjAxMQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r381032011", "bodyText": "Make \"LOCK\" to be a constant instead of hard coding here.", "author": "junkaixue", "createdAt": "2020-02-19T01:32:56Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,106 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo =\n+      new LockInfo(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+\n+  private ZNRecord record;\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a default LockInfo instance\n+   */\n+  private LockInfo() {\n+    record = new ZNRecord(\"LOCK\");", "originalCommit": "cdc7d3474099071dbd30ecf57f76aae31e197a8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMjY1OQ==", "url": "https://github.com/apache/helix/pull/718#discussion_r381032659", "bodyText": "naming convention: _record;", "author": "junkaixue", "createdAt": "2020-02-19T01:35:26Z", "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,106 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo =\n+      new LockInfo(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+\n+  private ZNRecord record;", "originalCommit": "cdc7d3474099071dbd30ecf57f76aae31e197a8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "790845a8dfccd7f08fe9b2ced263684dfdf4f580", "url": "https://github.com/apache/helix/commit/790845a8dfccd7f08fe9b2ced263684dfdf4f580", "message": "Rename interface HelixLock to DistributedLock", "committedDate": "2020-02-19T23:56:28Z", "type": "commit"}]}