{"pr_number": 924, "pr_title": "Fix ZkHelixPropertyStore loses Zookeeper notification issue", "pr_createdAt": "2020-03-31T19:07:11Z", "pr_url": "https://github.com/apache/helix/pull/924", "timeline": [{"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "url": "https://github.com/apache/helix/commit/0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "message": "WIP: fix ZkHelixPropertyStore loses Zookeeper notification issue\n\nZkHelixPropertyStore loses ZK notification after session expires.\nTHe issue was caused by a bug in Share ZkClient code path. More\nspecifically, Share ZkClient would not call fireAllEvent when ZK\nsession expires. Thus, ZkHelixPropertyStore would not install\nwatches for corresponding ZkPath. Thus, lose Zookeeper\nnofiticaition when changes happens.", "committedDate": "2020-03-31T18:42:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NTY4OQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401155689", "bodyText": "sleep() doesn't look solid and makes the test unstable. I suggest using TestHelper.varify() to replace sleep().", "author": "huizhilu", "createdAt": "2020-03-31T19:19:43Z", "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();\n+    ZkTestHelper.expireSession(testClient);\n+\n+\n+    // kill the session one more time to cover Shared ZkClient resetting flag\n+    // indicating first time synconnect happened.\n+    ZkTestHelper.expireSession(testClient);\n+\n+    listener.reset();\n+    int expectDeleteNodes = 1 + firstLevelNr + firstLevelNr * secondLevelNr;\n+    store.remove(\"/\", 0);\n+    // wait until all callbacks have been received\n+    for (int i = 0; i < 10; i++) {\n+      if (listener._deleteKeys.size() == expectDeleteNodes)\n+        break;\n+      Thread.sleep(500);", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzE2Ng==", "url": "https://github.com/apache/helix/pull/924#discussion_r401173166", "bodyText": "+1. This is not a show of good craftsmanship..", "author": "narendly", "createdAt": "2020-03-31T19:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NTY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTk4OA==", "url": "https://github.com/apache/helix/pull/924#discussion_r401175988", "bodyText": "This is copied from the other test in this file. I know you guys will pick it up. Let us draw a line here. I will only change this one, not the other test for now.", "author": "kaisun2000", "createdAt": "2020-03-31T19:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NTY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQwNzg0NQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401407845", "bodyText": "New approach use TestHelper.verifyWithTimeout().", "author": "kaisun2000", "createdAt": "2020-04-01T07:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NTY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1OTQ0Mg==", "url": "https://github.com/apache/helix/pull/924#discussion_r401159442", "bodyText": "This should not be introduced. If getZkClient() is really necessary, you can make _zkClient as protected.", "author": "huizhilu", "createdAt": "2020-03-31T19:26:12Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -72,6 +72,11 @@\n \n   private HelixZkClient _zkClient = null;\n \n+  // test only\n+  public HelixZkClient getZkClient() {", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MjU2OQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401172569", "bodyText": "This should not be introduced.", "author": "narendly", "createdAt": "2020-03-31T19:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1OTQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3ODE3Mw==", "url": "https://github.com/apache/helix/pull/924#discussion_r401178173", "bodyText": "Protect is not going to work, as the test case live in another package.\nJava has not way to access otherwise private members in the class. In this case, we have to expire the session inside this class. This is a common problem I did not see addressed in our code base. Unless you guys can identify another pattern, I guess we have to leave it this way.", "author": "kaisun2000", "createdAt": "2020-03-31T19:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1OTQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MzA3OA==", "url": "https://github.com/apache/helix/pull/924#discussion_r401183078", "bodyText": "+1, we should not add a public method to a public class just for testing, specially this is a public API.  If you test class is sitting in the same module with this class, protected will work.  Another way is to make it protected, and wrap ZkCacheBaseDataAccessor to a new test class.", "author": "lei-xia", "createdAt": "2020-03-31T20:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1OTQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MDczMQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401160731", "bodyText": "Comment block format:\n/*\n * comments\n */", "author": "huizhilu", "createdAt": "2020-03-31T19:28:19Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1073,10 +1073,24 @@ protected void processStateChanged(WatchedEvent event) {\n \n     fireStateChangedEvent(event.getState());\n \n+    // This following is the case for sharedZkClient\n     if (!isManagingZkConnection()) {\n+      /*", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4ODM4Nw==", "url": "https://github.com/apache/helix/pull/924#discussion_r401188387", "bodyText": "I think we have the format style file? You can apply the style file in intellij.", "author": "lei-xia", "createdAt": "2020-03-31T20:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MDczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwNTYzMw==", "url": "https://github.com/apache/helix/pull/924#discussion_r401205633", "bodyText": "I applied the style file. And it did not pick this up.", "author": "kaisun2000", "createdAt": "2020-03-31T20:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MDczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3Mjg2MQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401172861", "bodyText": "Exposing the internal HelixZkClient is not desirable", "author": "narendly", "createdAt": "2020-03-31T19:50:24Z", "path": "helix-core/src/main/java/org/apache/helix/store/zk/ZkHelixPropertyStore.java", "diffHunk": "@@ -47,4 +48,9 @@ public ZkHelixPropertyStore(String zkAddress, ZkSerializer serializer, String ch\n       ZkBaseDataAccessor.ZkClientType zkClientType) {\n     super(zkAddress, serializer, chrootPath, null, null, MONITOR_TYPE, chrootPath, zkClientType);\n   }\n+\n+  // test only\n+  protected HelixZkClient getTestZkClient() {\n+    return getZkClient();\n+  }", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3ODc5Ng==", "url": "https://github.com/apache/helix/pull/924#discussion_r401178796", "bodyText": "Java has not way to access otherwise private members in the class. In this case, we have to expire the session inside this class. This is a common problem I did not see addressed in our code base. Unless you guys can identify another pattern, I guess we have to leave it this way.", "author": "kaisun2000", "createdAt": "2020-03-31T20:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3Mjg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4ODU1NQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401188555", "bodyText": "We have another thread of this discussion in this pull. Close this one", "author": "kaisun2000", "createdAt": "2020-03-31T20:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3Mjg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzMxMg==", "url": "https://github.com/apache/helix/pull/924#discussion_r401173312", "bodyText": "Possible to avoid print statements?", "author": "narendly", "createdAt": "2020-03-31T19:51:13Z", "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();\n+    ZkTestHelper.expireSession(testClient);\n+\n+\n+    // kill the session one more time to cover Shared ZkClient resetting flag\n+    // indicating first time synconnect happened.\n+    ZkTestHelper.expireSession(testClient);\n+\n+    listener.reset();\n+    int expectDeleteNodes = 1 + firstLevelNr + firstLevelNr * secondLevelNr;\n+    store.remove(\"/\", 0);\n+    // wait until all callbacks have been received\n+    for (int i = 0; i < 10; i++) {\n+      if (listener._deleteKeys.size() == expectDeleteNodes)\n+        break;\n+      Thread.sleep(500);\n+    }\n+\n+    System.out.println(\"createKey#:\" + listener._createKeys.size() + \", changeKey#:\"\n+        + listener._changeKeys.size() + \", deleteKey#:\" + listener._deleteKeys.size());", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzU1NQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401173555", "bodyText": "Can you avoid adding public methods like this that shouldn't otherwise be used in production?", "author": "narendly", "createdAt": "2020-03-31T19:51:39Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -112,4 +112,9 @@ public String create(final String path, Object datat, final List<ACL> acl,\n   protected boolean isManagingZkConnection() {\n     return false;\n   }\n+\n+  // test only\n+  public HelixZkClient getConnectionManager() {\n+    return _connectionManager;\n+  }", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3ODg3MA==", "url": "https://github.com/apache/helix/pull/924#discussion_r401178870", "bodyText": "Java has not way to access otherwise private members in the class. In this case, we have to expire the session inside this class. This is a common problem I did not see addressed in our code base. Unless you guys can identify another pattern, I guess we have to leave it this way.", "author": "kaisun2000", "createdAt": "2020-03-31T20:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NjYzOQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401186639", "bodyText": "Agreed here, we should never add a public method to a public class just for testing.  If you really need to expose ZkClient, either change it to protected, and inherit this class in your test, such that:\nclass SharedZkClient {\nprotected _zkClient;\n}\nclass testSharedZkClient extends SharedZkClient {\nProtected getZkClient() {\nreturn _zkClient;\n}", "author": "lei-xia", "createdAt": "2020-03-31T20:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NzkwOQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401187909", "bodyText": "Another way is, if your test class is put in the same module with sharedZkClient, such as org.apache.helix.zookeeper.impl.client,  you should be able to access protected instance variables or methods from the test code.", "author": "lei-xia", "createdAt": "2020-03-31T20:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI0NzUwMg==", "url": "https://github.com/apache/helix/pull/924#discussion_r401247502", "bodyText": "Here is the case:\ntest case is in package org.apache.helix.store.zk, here is the how it is constructed.\n    ZkSerializer serializer = new ZNRecordSerializer(); ZkHelixPropertyStore<ZNRecord> store = new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\nWe need the internal shared ZkClient in the store; and further the internal _ZkconnectionManager.\nNote, ZkHelixPropertyStore uses ZkCacheBasedDataAccessor which lives in package org.apache.helix.manager.zk;\nNote, ShareZkClient and ZkConnectionManager lives in package org.apache.helix.zookeeper.impl.client;\nSo the solution (in this case, but not in general) can be:\nI can put the test in the org.apache.helix.zookeeper.impl.client, zookeeper-api module\nI can also initialize the HelixPropertystore like this:\n1/ construct SharedZkClient\n2/ construct ZkBaseDataAccessor using this sharedZkCLient.\n3/ construct ZkHelixPropertyStore (using ZkBaseDataAccessor.\nby making SharedZkClient's _zkConnectionManager protected, we can use it here.\nThe problem is that org.apache.helix.zookeeper.impl.client is in Zookeeper-api, we need a test scope dependency to Helix-core and Helix-common module. Does this test dependency work here?\n@lei-xia @narendly ?", "author": "kaisun2000", "createdAt": "2020-03-31T22:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NDQzMg==", "url": "https://github.com/apache/helix/pull/924#discussion_r401174432", "bodyText": "In general, it's not good practice to add subclass-specific logic in its parent class. Can you think of another way to do this?", "author": "narendly", "createdAt": "2020-03-31T19:53:13Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1073,10 +1073,24 @@ protected void processStateChanged(WatchedEvent event) {\n \n     fireStateChangedEvent(event.getState());\n \n+    // This following is the case for sharedZkClient\n     if (!isManagingZkConnection()) {\n+      /*\n+       For SharedZkClient, we will not invoke fireNewSessionEvents and we will invoke fireAllEvents\n+       This keeps the same behavior as original SharedZkClient.\n+       Invoking fireAllEvents is important to make sure HelixPropertyStore working correctly.\n+      */\n+      if ((event.getState() == KeeperState.SyncConnected) && (!_isNewSessionEventFired) && (!\"0\"\n+          .equals(getHexSessionId()))) {\n+        fireAllEvents();\n+        _isNewSessionEventFired = true;\n+      } else if (event.getState() == KeeperState.Expired) {\n+        _isNewSessionEventFired = false;\n+      }\n       return;", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4Mjg5Mw==", "url": "https://github.com/apache/helix/pull/924#discussion_r401182893", "bodyText": "Strictly speaking, this is not from sub-class. This is one object of a class that can act on different roles. But I get what you are thinking.\nThat said, traditionally it is like this.\nI can write in an another concise way wrapping all this logic into the if block of 1093.\nThought about it. The drawback of that way would be losing readability, and thus the intention of the logic. This would pave the way of next hidden bug when people do refactoring later, just as how this bug is introduced.", "author": "kaisun2000", "createdAt": "2020-03-31T20:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NDQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NDYxOA==", "url": "https://github.com/apache/helix/pull/924#discussion_r401174618", "bodyText": "parent class shouldn't know about what its sub classes are doing?", "author": "narendly", "createdAt": "2020-03-31T19:53:32Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1073,10 +1073,24 @@ protected void processStateChanged(WatchedEvent event) {\n \n     fireStateChangedEvent(event.getState());\n \n+    // This following is the case for sharedZkClient\n     if (!isManagingZkConnection()) {\n+      /*\n+       For SharedZkClient, we will not invoke fireNewSessionEvents and we will invoke fireAllEvents\n+       This keeps the same behavior as original SharedZkClient.\n+       Invoking fireAllEvents is important to make sure HelixPropertyStore working correctly.\n+      */\n+      if ((event.getState() == KeeperState.SyncConnected) && (!_isNewSessionEventFired) && (!\"0\"\n+          .equals(getHexSessionId()))) {\n+        fireAllEvents();\n+        _isNewSessionEventFired = true;\n+      } else if (event.getState() == KeeperState.Expired) {\n+        _isNewSessionEventFired = false;\n+      }\n       return;\n     }\n \n+    // The following is the case for non sharedZkClient", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDE2MQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401184161", "bodyText": "See my comment in the other similar comment. We can discuss it over there.", "author": "kaisun2000", "createdAt": "2020-03-31T20:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NDYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTEyOQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401175129", "bodyText": "This is not how you would enter JavaDoc in a public method. Could you please review the javadoc best practice guidelines?", "author": "narendly", "createdAt": "2020-03-31T19:54:21Z", "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTIzOA==", "url": "https://github.com/apache/helix/pull/924#discussion_r401175238", "bodyText": "empty line?", "author": "narendly", "createdAt": "2020-03-31T19:54:33Z", "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();\n+    ZkTestHelper.expireSession(testClient);\n+\n+", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2Njg5NA==", "url": "https://github.com/apache/helix/pull/924#discussion_r401166894", "bodyText": "Remove extra empty line.", "author": "huizhilu", "createdAt": "2020-03-31T19:39:33Z", "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();\n+    ZkTestHelper.expireSession(testClient);\n+", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NzE2OA==", "url": "https://github.com/apache/helix/pull/924#discussion_r401167168", "bodyText": "Style:\nif () {\n}", "author": "huizhilu", "createdAt": "2020-03-31T19:40:02Z", "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();\n+    ZkTestHelper.expireSession(testClient);\n+\n+\n+    // kill the session one more time to cover Shared ZkClient resetting flag\n+    // indicating first time synconnect happened.\n+    ZkTestHelper.expireSession(testClient);\n+\n+    listener.reset();\n+    int expectDeleteNodes = 1 + firstLevelNr + firstLevelNr * secondLevelNr;\n+    store.remove(\"/\", 0);\n+    // wait until all callbacks have been received\n+    for (int i = 0; i < 10; i++) {\n+      if (listener._deleteKeys.size() == expectDeleteNodes)", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NzU2Ng==", "url": "https://github.com/apache/helix/pull/924#discussion_r401167566", "bodyText": "Extra spaces.", "author": "huizhilu", "createdAt": "2020-03-31T19:40:44Z", "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NjIyNw==", "url": "https://github.com/apache/helix/pull/924#discussion_r401176227", "bodyText": "If we remove  _isNewSessionEventFired = false; in reconnect() and do below code, it seems more concise and easier to maintain. _isNewSessionEventFired is only changed in this code block. What do you think?\n    if (event.getState() == KeeperState.SyncConnected && !_isNewSessionEventFired && !\"0\".equals(getHexSessionId())) {\n      if (isManagingZkConnection()) {\n        /*\n         * Before the new zookeeper instance is connected to the zookeeper service and its session\n         * is established, its session id is 0.\n         * New session event is not fired until the new zookeeper session receives the first\n         * SyncConnected state(the zookeeper session is established).\n         * Now the session id is available and non-zero, and we can fire new session events.\n         */\n        fireNewSessionEvents();\n      }\n      /*\n       * Set it true to avoid firing events again for the same session next time\n       * when SyncConnected events are received.\n       */\n      _isNewSessionEventFired = true;\n\n      /*\n       * With this first SyncConnected state, we just get connected to zookeeper service after\n       * reconnecting when the session expired. Because previous session expired, we also have to\n       * notify all listeners that something might have changed.\n       */\n      fireAllEvents();\n    } else if (event.getState() == KeeperState.Expired) {\n      if (isManagingZkConnection()) {\n        reconnectOnExpiring();\n      }\n       _isNewSessionEventFired = false;\n    }", "author": "huizhilu", "createdAt": "2020-03-31T19:56:29Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1073,10 +1073,24 @@ protected void processStateChanged(WatchedEvent event) {\n \n     fireStateChangedEvent(event.getState());\n \n+    // This following is the case for sharedZkClient\n     if (!isManagingZkConnection()) {\n+      /*\n+       For SharedZkClient, we will not invoke fireNewSessionEvents and we will invoke fireAllEvents\n+       This keeps the same behavior as original SharedZkClient.\n+       Invoking fireAllEvents is important to make sure HelixPropertyStore working correctly.\n+      */\n+      if ((event.getState() == KeeperState.SyncConnected) && (!_isNewSessionEventFired) && (!\"0\"\n+          .equals(getHexSessionId()))) {\n+        fireAllEvents();\n+        _isNewSessionEventFired = true;\n+      } else if (event.getState() == KeeperState.Expired) {\n+        _isNewSessionEventFired = false;\n+      }", "originalCommit": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NzQxNg==", "url": "https://github.com/apache/helix/pull/924#discussion_r401187416", "bodyText": "Good point.\nYes, this is another way to do it, thought about it.\nPro: concise\nCon: hard to understand the intention. This may pave the way to another hidden bug when people do refactoring next time, as how we get to this issue.", "author": "kaisun2000", "createdAt": "2020-03-31T20:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NjIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2OTA2Mg==", "url": "https://github.com/apache/helix/pull/924#discussion_r401269062", "bodyText": "To me, it is easier to understand:\n\nonly managed connection will do: fireNewSessionEvents() and reconnectOnExpiring.\nfirst sync connected: _isNewSessionEventFired = true; expired: _isNewSessionEventFired = false.", "author": "huizhilu", "createdAt": "2020-03-31T23:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NjIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxMDg3NQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r401410875", "bodyText": "@jiajunwang, what is your take here?", "author": "kaisun2000", "createdAt": "2020-04-01T07:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NjIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzMTUwNw==", "url": "https://github.com/apache/helix/pull/924#discussion_r402031507", "bodyText": "I like less code : )\nAnd actually I can understand the concise version. So I guess it's better.", "author": "jiajunwang", "createdAt": "2020-04-02T03:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NjIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzNzY2MA==", "url": "https://github.com/apache/helix/pull/924#discussion_r402037660", "bodyText": "The I will use this concise version. I will add a verbose note about the intention too.", "author": "kaisun2000", "createdAt": "2020-04-02T03:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NjIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUzNzM2Nw==", "url": "https://github.com/apache/helix/pull/924#discussion_r402537367", "bodyText": "By they way, setting _isNewSessionEventFired = false should be above reconnect(). Otherwise, maybe there is a small chance of race condition. In reconnect() or current code, maybe we still have this race condition. Put it ahead definitely don't.\n    } else if (event.getState() == KeeperState.Expired) {\n       _isNewSessionEventFired = false;\n      if (isManagingZkConnection()) {\n        reconnectOnExpiring();\n      }\n    }", "author": "kaisun2000", "createdAt": "2020-04-02T18:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NjIyNw=="}], "type": "inlineReview"}, {"oid": "6dd05dcae3d88383b038e8ba56ecd755d1d4aff1", "url": "https://github.com/apache/helix/commit/6dd05dcae3d88383b038e8ba56ecd755d1d4aff1", "message": "major overhaul base on feedback\n\n1/ move the test from TestZkHelixPropertyStore to TestZkCacheAsyncOpSingleThread\nThis is to use TestHelper.VerifyWithTimeout()\n2/ add expireSession with SharedZkClient featue in ZkTestHelper and remove all\nthe public accessor to get ZkClient for test purpose", "committedDate": "2020-04-01T07:10:09Z", "type": "commit"}, {"oid": "c705916ec73af6ea6677a511ffd1798c1b66c335", "url": "https://github.com/apache/helix/commit/c705916ec73af6ea6677a511ffd1798c1b66c335", "message": "restore TestZkHelixPropertyStore.java.", "committedDate": "2020-04-01T07:15:57Z", "type": "commit"}, {"oid": "7bb700818edbd8f7711d55582046aae94e009a94", "url": "https://github.com/apache/helix/commit/7bb700818edbd8f7711d55582046aae94e009a94", "message": "remove one more test only accessor.", "committedDate": "2020-04-01T07:38:33Z", "type": "commit"}, {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c", "url": "https://github.com/apache/helix/commit/c25db42f5f9a524d204d658a5e3858b1c5273d6c", "message": "remove unused import", "committedDate": "2020-04-01T07:40:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxODE5NA==", "url": "https://github.com/apache/helix/pull/924#discussion_r401918194", "bodyText": "I guess this wait only check if there is an expiring happened. The original wait is to ensure the session has been re-established. So if you want to achieve the same goal, maybe we need to compare the older session and newer session then end the wait.\nGiven that saying, I guess you can just modify the existing method to include this check. Note that if this not happen, we can directly fail the test by throwing an exception.", "author": "jiajunwang", "createdAt": "2020-04-01T21:23:51Z", "path": "helix-core/src/test/java/org/apache/helix/ZkTestHelper.java", "diffHunk": "@@ -146,6 +146,70 @@ public void process(WatchedEvent event) {\n     LOG.info(\"After expiry. sessionId: \" + Long.toHexString(curZookeeper.getSessionId()));\n   }\n \n+  public static void expireSharedZkClientSession(HelixZkClient client) throws Exception {\n+    final CountDownLatch waitExpireSession = new CountDownLatch(1);\n+    final ZkClient zkClient = (ZkClient) client;\n+\n+    IZkStateListener listener = new IZkStateListener() {\n+      @Override\n+      public void handleStateChanged(KeeperState state) throws Exception {\n+        LOG.info(\"IZkStateListener#handleStateChanged, state: \" + state);\n+        if (state == KeeperState.Expired) {\n+          waitExpireSession.countDown();", "originalCommit": "c25db42f5f9a524d204d658a5e3858b1c5273d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkyODQ0NA==", "url": "https://github.com/apache/helix/pull/924#discussion_r401928444", "bodyText": "You are right, here this latch guarantees expiring happens. But later, the code still ensures new session established.\nwaitExpireSession.await();\nzkClient.unsubscribeStateChanges(listener);\n\nconnection = (ZkConnection) zkClient.getConnection();\ncurZookeeper = connection.getZookeeper();\n\n// wait util connected\nwhile (curZookeeper.getState() != States.CONNECTED) {\n  Thread.sleep(10);\n}", "author": "kaisun2000", "createdAt": "2020-04-01T21:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxODE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzMDAxMQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r402030011", "bodyText": "This works. Since it should work for all the client, can we just modify the original expiring method? 2 similar methods for the same purpose is not good.", "author": "jiajunwang", "createdAt": "2020-04-02T03:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxODE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA0MjAzNw==", "url": "https://github.com/apache/helix/pull/924#discussion_r402042037", "bodyText": "See my comment later about how to enhance with handleStateChanged. If we agree with that approach. I will use this logic in TestHelper.expireSession() and remove this one.", "author": "kaisun2000", "createdAt": "2020-04-02T04:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxODE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyODk2OA==", "url": "https://github.com/apache/helix/pull/924#discussion_r402028968", "bodyText": "This comment is a bit confusing.  You mean \"The following only applies to dedicated ZkClient in which it manages ZkConnection directly\", right?", "author": "lei-xia", "createdAt": "2020-04-02T03:16:48Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1073,10 +1073,24 @@ protected void processStateChanged(WatchedEvent event) {\n \n     fireStateChangedEvent(event.getState());\n \n+    // This following is the case for ZkClient no managing connection\n     if (!isManagingZkConnection()) {\n+      /*\n+       * For SharedZkClient, we will not invoke fireNewSessionEvents but will invoke fireAllEvents\n+       * This keeps the same behavior as original SharedZkClient.\n+       * Invoking fireAllEvents is important to make sure HelixPropertyStore working correctly.\n+       */\n+      if ((event.getState() == KeeperState.SyncConnected) && (!_isNewSessionEventFired) && (!\"0\"\n+          .equals(getHexSessionId()))) {\n+        fireAllEvents();\n+        _isNewSessionEventFired = true;\n+      } else if (event.getState() == KeeperState.Expired) {\n+        _isNewSessionEventFired = false;\n+      }\n       return;\n     }\n \n+    // The following is the case for ZkClient managing the connection", "originalCommit": "c25db42f5f9a524d204d658a5e3858b1c5273d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzMTk1Mg==", "url": "https://github.com/apache/helix/pull/924#discussion_r402031952", "bodyText": "I guess it can be simplified to:\n// else, if managing the connection\nAnyway, if we do what Huizhi suggested, it should be clearer.", "author": "jiajunwang", "createdAt": "2020-04-02T03:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyODk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA0Mjg0OA==", "url": "https://github.com/apache/helix/pull/924#discussion_r402042848", "bodyText": "@lei-xia, right. Your description is more readable. But @jiajunwang and @hulu like the more concise way. Unless you like this separation of two branch way, I will adopt the more concise way. And add another comment about the goal fo what we will achieve. (Intention)\nSo later if people refactor this code. They know the intention at lease.", "author": "kaisun2000", "createdAt": "2020-04-02T04:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyODk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzMDMxNg==", "url": "https://github.com/apache/helix/pull/924#discussion_r402030316", "bodyText": "Can we subscribe to the state change instead of busy loop?", "author": "jiajunwang", "createdAt": "2020-04-02T03:22:23Z", "path": "helix-core/src/test/java/org/apache/helix/ZkTestHelper.java", "diffHunk": "@@ -146,6 +146,70 @@ public void process(WatchedEvent event) {\n     LOG.info(\"After expiry. sessionId: \" + Long.toHexString(curZookeeper.getSessionId()));\n   }\n \n+  public static void expireSharedZkClientSession(HelixZkClient client) throws Exception {\n+    final CountDownLatch waitExpireSession = new CountDownLatch(1);\n+    final ZkClient zkClient = (ZkClient) client;\n+\n+    IZkStateListener listener = new IZkStateListener() {\n+      @Override\n+      public void handleStateChanged(KeeperState state) throws Exception {\n+        LOG.info(\"IZkStateListener#handleStateChanged, state: \" + state);\n+        if (state == KeeperState.Expired) {\n+          waitExpireSession.countDown();\n+        }\n+      }\n+\n+      @Override\n+      public void handleNewSession(final String sessionId) throws Exception {\n+      }\n+\n+      @Override\n+      public void handleSessionEstablishmentError(Throwable var1) throws Exception {\n+      }\n+    };\n+\n+    zkClient.subscribeStateChanges(listener);\n+\n+    ZkConnection connection = ((ZkConnection) zkClient.getConnection());\n+    ZooKeeper curZookeeper = connection.getZookeeper();\n+    String oldSessionId = Long.toHexString(curZookeeper.getSessionId());\n+    LOG.info(\"Before session expiry. sessionId: \" + oldSessionId + \", zk: \" + curZookeeper);\n+\n+    Watcher watcher = new Watcher() {\n+      @Override\n+      public void process(WatchedEvent event) {\n+        LOG.info(\"Watcher#process, event: \" + event);\n+      }\n+    };\n+\n+    final ZooKeeper dupZookeeper =\n+        new ZooKeeper(connection.getServers(), curZookeeper.getSessionTimeout(), watcher,\n+            curZookeeper.getSessionId(), curZookeeper.getSessionPasswd());\n+    // wait until connected, then close\n+    while (dupZookeeper.getState() != States.CONNECTED) {\n+      Thread.sleep(10);\n+    }\n+    Assert.assertEquals(dupZookeeper.getState(), States.CONNECTED,\n+        \"Fail to connect to zk using current session info\");\n+    dupZookeeper.close();\n+\n+    // make sure session expiry really happens\n+    waitExpireSession.await();\n+    zkClient.unsubscribeStateChanges(listener);\n+\n+    connection = (ZkConnection) zkClient.getConnection();\n+    curZookeeper = connection.getZookeeper();\n+\n+    // wait util connected\n+    while (curZookeeper.getState() != States.CONNECTED) {", "originalCommit": "c25db42f5f9a524d204d658a5e3858b1c5273d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA0MTYyNg==", "url": "https://github.com/apache/helix/pull/924#discussion_r402041626", "bodyText": "There are many ways to do it. Let us be specific to avoid delaying this important fix.\nSo the code can be something like this:\npublic void handleStateChanged(KeeperState state) throws Exception {\n      LOG.info(\"IZkStateListener#handleStateChanged, state: \" + state);\n      if (state == KeeperState.Expired) {\n        waitExpireSession.countDown();\n      } \n      if (state == KeeperState.Synconnected) {\n        waitNewSession.countDown();\n      }\n\n\nLater something like this to wait for latch?\nboolean expiredCompleted = waitExpireSession.await(5L, TimeUnit.SECONDS);\nif (!expiredCompleted)  {\n   throw Exception(\" Expiration of Session failed.\");\n}\nboolean newSessionCompleted = waitNewSession.await(5L, TimeUnit.SECONDS);\nif (!newSessionCompleted) {\n  throw Exception(\" Expiration of Session failed.\");\n}\nzkClient.unsubscribeStateChanges(listener);\n\nNote, the wait for expiration and synconnected are both necessary. The reason is that disconnect can give you sysconnected too.\nNote, the timeout in await() is to prevent hanging here forever to block test from proceeding.", "author": "kaisun2000", "createdAt": "2020-04-02T04:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzMDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MjY2OA==", "url": "https://github.com/apache/helix/pull/924#discussion_r402142668", "bodyText": "+1 to get rid of busy sleeping.", "author": "huizhilu", "createdAt": "2020-04-02T08:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzMDMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMTg0NQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r402131845", "bodyText": "If it is just a local var, no need to make it capitalized.", "author": "huizhilu", "createdAt": "2020-04-02T08:17:02Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,83 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;", "originalCommit": "c25db42f5f9a524d204d658a5e3858b1c5273d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDc4OQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r405970789", "bodyText": "Style?", "author": "huizhilu", "createdAt": "2020-04-09T05:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NTMyNA==", "url": "https://github.com/apache/helix/pull/924#discussion_r402145324", "bodyText": "Should assign the result to ret?", "author": "huizhilu", "createdAt": "2020-04-02T08:39:41Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,83 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,", "originalCommit": "c25db42f5f9a524d204d658a5e3858b1c5273d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNDk1Ng==", "url": "https://github.com/apache/helix/pull/924#discussion_r402514956", "bodyText": "good point.", "author": "kaisun2000", "createdAt": "2020-04-02T18:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2NzY5Ng==", "url": "https://github.com/apache/helix/pull/924#discussion_r405767696", "bodyText": "Do you think this should be changed, since I've seen you agreement but no change?", "author": "huizhilu", "createdAt": "2020-04-08T19:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NTMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NzA4Mw==", "url": "https://github.com/apache/helix/pull/924#discussion_r402147083", "bodyText": "Naming SharedZkClient doesn\u2019t match the parameter type HelixZkClient.\nFYI, it seems the only difference between expireSession and this is, this does not have handleNewSession implementation logic. Would you consider reducing the duplicate code?", "author": "huizhilu", "createdAt": "2020-04-02T08:42:28Z", "path": "helix-core/src/test/java/org/apache/helix/ZkTestHelper.java", "diffHunk": "@@ -146,6 +146,70 @@ public void process(WatchedEvent event) {\n     LOG.info(\"After expiry. sessionId: \" + Long.toHexString(curZookeeper.getSessionId()));\n   }\n \n+  public static void expireSharedZkClientSession(HelixZkClient client) throws Exception {", "originalCommit": "c25db42f5f9a524d204d658a5e3858b1c5273d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNDU2MQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r402514561", "bodyText": "It is different for a reason. Shared ZkClient does not have handleNewSession. Will combine see the above discussion with JJ.", "author": "kaisun2000", "createdAt": "2020-04-02T18:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NzA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MzY1Nw==", "url": "https://github.com/apache/helix/pull/924#discussion_r402153657", "bodyText": "Assert this?", "author": "huizhilu", "createdAt": "2020-04-02T08:52:51Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,83 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,\n+        zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true  );\n+\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    ZkTestHelper.expireSharedZkClientSession(dupZkclient);\n+\n+    // kill the session one more time to cover code path ZkClient resetting flag that\n+    // indicates first time synconnect happened.\n+    ZkTestHelper.expireSharedZkClientSession(dupZkclient);\n+\n+    // remove the currentstates\n+    paths.clear();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      paths.add(path);\n+    }\n+    success = extBaseAccessor.remove(paths, 0);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in remove:\" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,", "originalCommit": "c25db42f5f9a524d204d658a5e3858b1c5273d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyOTc5MA==", "url": "https://github.com/apache/helix/pull/924#discussion_r402529790", "bodyText": "See above.", "author": "kaisun2000", "createdAt": "2020-04-02T18:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MzY1Nw=="}], "type": "inlineReview"}, {"oid": "2cc623ce4560b9ba81e3daa97a04ef39dfdc540e", "url": "https://github.com/apache/helix/commit/2cc623ce4560b9ba81e3daa97a04ef39dfdc540e", "message": "enhance TestHelper.expireSession.\nuse the concise logic in zkClient.", "committedDate": "2020-04-02T19:36:58Z", "type": "commit"}, {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba", "url": "https://github.com/apache/helix/commit/c558a80c5d6dc2cd6cf62ca1615f70196fc2adba", "message": "Make flaky test happy.", "committedDate": "2020-04-07T03:47:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyODI0NQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r405728245", "bodyText": "What if reconnect is not done successfully in the following reconnectOnExpiring() call?\nIn that case, if we change this flag to false, will it cause additional fireNewSessionEvents()? For example if we have a stale new session event in the queue.", "author": "jiajunwang", "createdAt": "2020-04-08T18:28:57Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1101,7 +1104,10 @@ protected void processStateChanged(WatchedEvent event) {\n         fireAllEvents();\n       }\n     } else if (event.getState() == KeeperState.Expired) {\n-      reconnectOnExpiring();\n+      _isNewSessionEventFired = false;", "originalCommit": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MTY1MQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r405741651", "bodyText": "Discussed wit Kai offline, this should be fine as long as processStateChanged is synchronized called in one thread.", "author": "jiajunwang", "createdAt": "2020-04-08T18:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyODI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjQ5Nw==", "url": "https://github.com/apache/helix/pull/924#discussion_r405742497", "bodyText": "BTW, please update the comment of _isNewSessionEventFired, it is out of date.", "author": "jiajunwang", "createdAt": "2020-04-08T18:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyODI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2NzMyMQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r405767321", "bodyText": "I was also thinking about the same concern.  It should be fine as it is protected by the eventLock. And also if reconnecting fails because of IOException, the old/expired zk is kept, but the expired zk could not do anything.", "author": "huizhilu", "createdAt": "2020-04-08T19:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyODI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NjE2MQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r405876161", "bodyText": "updated.", "author": "kaisun2000", "createdAt": "2020-04-08T23:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyODI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjI1NA==", "url": "https://github.com/apache/helix/pull/924#discussion_r405742254", "bodyText": "As we moved the isManagingZkConnection closer to these methods, it might be cleaner if we just move it inside reconnectOnExpiring() and fireNewSessionEvents(). So we have better protection and the code looks cleaner.", "author": "jiajunwang", "createdAt": "2020-04-08T18:52:38Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1101,7 +1104,10 @@ protected void processStateChanged(WatchedEvent event) {\n         fireAllEvents();\n       }\n     } else if (event.getState() == KeeperState.Expired) {\n-      reconnectOnExpiring();\n+      _isNewSessionEventFired = false;\n+      if (isManagingZkConnection()) {", "originalCommit": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3Njc1MQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r405876751", "bodyText": "As @pkuwm pointed out, processStateChanged is private method always called under lock protection, the same as fireAllEvent, and reconnectionOnExpiring.", "author": "kaisun2000", "createdAt": "2020-04-08T23:44:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3ODk1MA==", "url": "https://github.com/apache/helix/pull/924#discussion_r405878950", "bodyText": "Yeah, but it is a good practice to check closer to where the real business logic exists.\nOne example could be, if in the future we want to call reconnectOnExpiring() somewhere else, we don't need to add one more check there.\nHigh-level, these 2 methods shall only be called for non-shared clients. But we don't have a way to block them for shared client implementation. So we just put the check inside, then they won't cause any more problems even if we want to do anything to change the zkclient.", "author": "jiajunwang", "createdAt": "2020-04-08T23:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4MDY5Mw==", "url": "https://github.com/apache/helix/pull/924#discussion_r405880693", "bodyText": "Can you be more specific as what you want to do with the change? Sketch how you think about the fireNewSessionEvent, fireAllEvent, reconnectOnExpiring look like?\nTo me, there are many ways to put the if and else check. Either way works for me.", "author": "kaisun2000", "createdAt": "2020-04-08T23:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4MjMwMw==", "url": "https://github.com/apache/helix/pull/924#discussion_r405882303", "bodyText": "maybe something like this:\nprivate void reconnectOnExpiring() {\n  if (!isManagingZkConnection()) {\n    return;\n  }\n  ... // the rest is the same\n}\n\nprivate void fireNewSessionEvents() {\n  if (!isManagingZkConnection()) {\n    return;\n  }\n ...// the rest is the same.\n\n  }", "author": "kaisun2000", "createdAt": "2020-04-09T00:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4MzEwNw==", "url": "https://github.com/apache/helix/pull/924#discussion_r405883107", "bodyText": "Yeah, this is what I meant.", "author": "jiajunwang", "createdAt": "2020-04-09T00:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NDQ3Nw==", "url": "https://github.com/apache/helix/pull/924#discussion_r405884477", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-04-09T00:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2OTEzNQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r405769135", "bodyText": "If you have to use sleep to wait for the sync connected, I do see duplicate code and it could replaced by TestHelper.varify(), which saves you the duplicate code and also offers a timeout option in case it is forever blocked here.", "author": "huizhilu", "createdAt": "2020-04-08T19:42:18Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,100 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,\n+        zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true  );\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    long sessionId = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    while (true) {\n+      long curSessionId = dupZkclient.getSessionId();\n+      if (curSessionId == sessionId || curSessionId == 0) {\n+        Thread.sleep(500);\n+      } else {\n+        sessionId = curSessionId;\n+        break;", "originalCommit": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NjY0OA==", "url": "https://github.com/apache/helix/pull/924#discussion_r405866648", "bodyText": "fixed.", "author": "kaisun2000", "createdAt": "2020-04-08T23:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2OTEzNQ=="}], "type": "inlineReview"}, {"oid": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca", "url": "https://github.com/apache/helix/commit/c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca", "message": "address some comments.", "committedDate": "2020-04-09T00:06:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2OTUyOA==", "url": "https://github.com/apache/helix/pull/924#discussion_r405969528", "bodyText": "It could be simplified to return curSessionId != sessionId && curSessionId != 0?", "author": "huizhilu", "createdAt": "2020-04-09T05:48:29Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,99 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,\n+        zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true  );\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    final long sessionId = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    ret = TestHelper.verify(()-> {\n+      long curSessionId = dupZkclient.getSessionId();\n+      if (curSessionId != sessionId && curSessionId != 0) {\n+        return true;\n+      }\n+      return false;", "originalCommit": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4NTM1Nw==", "url": "https://github.com/apache/helix/pull/924#discussion_r406385357", "bodyText": "changed.\nthere are many ways to write same bool logic. there is no preferred way by all the people. (say what if JJ prefer another way, how do we resolve it?) let us refrain from pick this kind stuff up. It incurs cost without adding value.", "author": "kaisun2000", "createdAt": "2020-04-09T18:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2OTUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2OTg3Mw==", "url": "https://github.com/apache/helix/pull/924#discussion_r405969873", "bodyText": "Unnecessary extra space before )", "author": "huizhilu", "createdAt": "2020-04-09T05:49:37Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,99 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,\n+        zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true  );", "originalCommit": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4MDM4NQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r406380385", "bodyText": "formatted.", "author": "kaisun2000", "createdAt": "2020-04-09T18:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2OTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDQ1Nw==", "url": "https://github.com/apache/helix/pull/924#discussion_r405970457", "bodyText": "I've seen multiple places not formatted. Can you format your changes here?", "author": "huizhilu", "createdAt": "2020-04-09T05:51:42Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,99 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,\n+        zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true  );\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    final long sessionId = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    ret = TestHelper.verify(()-> {", "originalCommit": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4MDI0Ng==", "url": "https://github.com/apache/helix/pull/924#discussion_r406380246", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-04-09T18:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MTYxMw==", "url": "https://github.com/apache/helix/pull/924#discussion_r405971613", "bodyText": "Reversed way? Managing connection should fire handle new session events.", "author": "huizhilu", "createdAt": "2020-04-09T05:55:26Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1150,6 +1156,10 @@ private void reconnect() {\n   }\n \n   private void fireNewSessionEvents() {\n+    // only managing zkclient fire handleNewSession event\n+    if (isManagingZkConnection()) {", "originalCommit": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MTgyMA==", "url": "https://github.com/apache/helix/pull/924#discussion_r405971820", "bodyText": "Reversed.\nAnd please correct the comment.", "author": "huizhilu", "createdAt": "2020-04-09T05:56:09Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1101,11 +1103,16 @@ protected void processStateChanged(WatchedEvent event) {\n         fireAllEvents();\n       }\n     } else if (event.getState() == KeeperState.Expired) {\n+      _isNewSessionEventFired = false;\n       reconnectOnExpiring();\n     }\n   }\n \n   private void reconnectOnExpiring() {\n+    // only managing zkclient fire handleNewSession event\n+    if (isManagingZkConnection()) {", "originalCommit": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAwMTMwMg==", "url": "https://github.com/apache/helix/pull/924#discussion_r406001302", "bodyText": "Thanks for put the check inside the function. But why we need to move it to after _isNewSessionEventFired = true;?\nIs it concerning? Because when _isNewSessionEventFired is set to true, the event is not sent yet.", "author": "jiajunwang", "createdAt": "2020-04-09T07:14:11Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1080,22 +1080,21 @@ protected void processStateChanged(WatchedEvent event) {\n      */\n     if (event.getState() == KeeperState.SyncConnected) {\n       if (!_isNewSessionEventFired && !\"0\".equals(getHexSessionId())) {\n-        if (isManagingZkConnection()) {\n-          /*\n-           * Before the new zookeeper instance is connected to the zookeeper service and its session\n-           * is established, its session id is 0.\n-           * New session event is not fired until the new zookeeper session receives the first\n-           * SyncConnected state(the zookeeper session is established).\n-           * Now the session id is available and non-zero, and we can fire new session events.\n-           */\n-          fireNewSessionEvents();\n-        }\n         /*\n          * Set it true to avoid firing events again for the same session next time\n          * when SyncConnected events are received.\n          */\n         _isNewSessionEventFired = true;\n \n+        /*\n+         * Before the new zookeeper instance is connected to the zookeeper service and its session\n+         * is established, its session id is 0.\n+         * New session event is not fired until the new zookeeper session receives the first\n+         * SyncConnected state(the zookeeper session is established).\n+         * Now the session id is available and non-zero, and we can fire new session events.\n+         */\n+        fireNewSessionEvents();", "originalCommit": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4Mjg3NQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r406382875", "bodyText": "Any comments on \"why we need to move it to after _isNewSessionEventFired = true;? Is it concerning?\" ?", "author": "jiajunwang", "createdAt": "2020-04-09T18:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAwMTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4OTkzNA==", "url": "https://github.com/apache/helix/pull/924#discussion_r406389934", "bodyText": "I changed it back to the original way. The previous changing order should also work. But to be on the safe side, as you commented, let us change it back to original way.", "author": "kaisun2000", "createdAt": "2020-04-09T18:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAwMTMwMg=="}], "type": "inlineReview"}, {"oid": "41273d1188a0cd2f91f00681ba37b8b72795edb3", "url": "https://github.com/apache/helix/commit/41273d1188a0cd2f91f00681ba37b8b72795edb3", "message": "formatting and address comments.", "committedDate": "2020-04-09T18:11:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5MTYxNw==", "url": "https://github.com/apache/helix/pull/924#discussion_r407791617", "bodyText": "Nit, just make my point clear: this is kind of redundant, not what I meant. I meant\nreturn curSessionId != sessionId && curSessionId != 0;", "author": "huizhilu", "createdAt": "2020-04-14T00:15:07Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,93 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder\n+          .instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000, zkCacheInitPaths, accessor._zkCache._cache,\n+        _gZkClient, true);\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    final long sessionId = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    ret = TestHelper.verify(() -> {\n+      long curSessionId = dupZkclient.getSessionId();\n+      return curSessionId != sessionId && curSessionId != 0 ? true : false;", "originalCommit": "41273d1188a0cd2f91f00681ba37b8b72795edb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyNzQ5OQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r408327499", "bodyText": "addressed.", "author": "kaisun2000", "createdAt": "2020-04-14T17:55:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5MTYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5MzIxMQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r407793211", "bodyText": "I still think CURSTATECNT should follow the style: it is not a constant variable.", "author": "huizhilu", "createdAt": "2020-04-14T00:20:22Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,93 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;", "originalCommit": "41273d1188a0cd2f91f00681ba37b8b72795edb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyNzMyMQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r408327321", "bodyText": "addressed.", "author": "kaisun2000", "createdAt": "2020-04-14T17:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5MzIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwODM5Nw==", "url": "https://github.com/apache/helix/pull/924#discussion_r407808397", "bodyText": "@kaisun2000 My understanding is, the current states created by this invalid session \"session_0\" would also be invalid. Can you help me understand if these invalid current states would work for this testing purpose? Thanks.", "author": "huizhilu", "createdAt": "2020-04-14T01:14:26Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,93 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder\n+          .instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);", "originalCommit": "41273d1188a0cd2f91f00681ba37b8b72795edb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyNTMwNw==", "url": "https://github.com/apache/helix/pull/924#discussion_r408325307", "bodyText": "CurrentStates here only serves the purpose of some directory in zookeeper. This test has nothing to do with controller rebalancing logic.  Note, TestHelper.verifyZkCache only valid the data in zookeeper and propertycache for this currentstates path are the same. That is the gist of this test.\nPut it another way, using currentstate property builder is just a convenience. All the other test in this suite is like this.", "author": "kaisun2000", "createdAt": "2020-04-14T17:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwODM5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2MDAyNQ==", "url": "https://github.com/apache/helix/pull/924#discussion_r408360025", "bodyText": "My point was, I just wanted to understand it is not only reading the current state paths that have a valid session.\nI double checked. It should work as it would read the paths recursively so \"session_0\" would be read.", "author": "huizhilu", "createdAt": "2020-04-14T18:50:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwODM5Nw=="}], "type": "inlineReview"}, {"oid": "68afe66fd7fa041d55ec5b822352a828830a1f3c", "url": "https://github.com/apache/helix/commit/68afe66fd7fa041d55ec5b822352a828830a1f3c", "message": "address some minor issue.", "committedDate": "2020-04-14T17:56:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1ODU5Ng==", "url": "https://github.com/apache/helix/pull/924#discussion_r408358596", "bodyText": "This block of clearing current state paths is unnecessary, as the paths list is not changed?", "author": "huizhilu", "createdAt": "2020-04-14T18:47:47Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,93 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int curstateCnt = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < curstateCnt; i++) {\n+      String path = PropertyPathBuilder\n+          .instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < curstateCnt; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000, zkCacheInitPaths, accessor._zkCache._cache,\n+        _gZkClient, true);\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    final long sessionId = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    ret = TestHelper.verify(() -> {\n+      long curSessionId = dupZkclient.getSessionId();\n+      return curSessionId != sessionId && curSessionId != 0;\n+    }, 10000);\n+    Assert.assertTrue(ret, \"kill session timed out!\");\n+\n+    // kill the session one more time to cover code path ZkClient resetting flag that\n+    // indicates first time synconnect happened.\n+    final long sessionId1 = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    ret = TestHelper.verify(() -> {\n+      long curSessionId = dupZkclient.getSessionId();\n+      return curSessionId != sessionId1 && curSessionId != 0;\n+    }, 10000);\n+    Assert.assertTrue(ret, \"kill session second time timed out!\");\n+\n+    // remove the currentstates\n+    paths.clear();\n+    for (int i = 0; i < curstateCnt; i++) {\n+      String path = PropertyPathBuilder\n+          .instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n+      paths.add(path);\n+    }", "originalCommit": "68afe66fd7fa041d55ec5b822352a828830a1f3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzOTAxMg==", "url": "https://github.com/apache/helix/pull/924#discussion_r408439012", "bodyText": "This is necessary.  This removal of currentstate should trigger propertystore to reflect this removal in its cache as well.\nWithout this fix, this is not going to be true because the watcher to zookeeper is lost.", "author": "kaisun2000", "createdAt": "2020-04-14T21:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1ODU5Ng=="}], "type": "inlineReview"}]}