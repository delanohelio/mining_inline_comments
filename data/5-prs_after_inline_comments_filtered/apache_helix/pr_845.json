{"pr_number": 845, "pr_title": "Async write operation should not throw Exception for serializing error", "pr_createdAt": "2020-03-02T23:55:23Z", "pr_url": "https://github.com/apache/helix/pull/845", "timeline": [{"oid": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef", "url": "https://github.com/apache/helix/commit/f4ac3d31ee3480ffb457aabe57f8b0480191dbef", "message": "Async write operation should not throw Exception for serializing error.\n\nThis change will make the async write operations return error through the async callback instead of throwing exceptions. This change will fix the batch write/create failure due to one single node serializing failure.\nIn addition, according to serializer interface definition, change ZK related serializers to throw ZkMarshallingError instead of ZkClientException.", "committedDate": "2020-03-02T22:24:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNzI4MQ==", "url": "https://github.com/apache/helix/pull/845#discussion_r386737281", "bodyText": "Don't forget to remove unused import for ZkClientException", "author": "huizhilu", "createdAt": "2020-03-03T00:43:20Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZNRecordSizeLimit.java", "diffHunk": "@@ -516,7 +514,7 @@ public void testZNRecordStreamingSerializerWriteSizeLimit() throws Exception {\n       try {\n         zkClient.writeData(path, largeRecord);\n         Assert.fail(\"Data should not written to ZK because data size exceeds writeSizeLimit!\");\n-      } catch (ZkClientException expected) {", "originalCommit": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0Njg2MA==", "url": "https://github.com/apache/helix/pull/845#discussion_r386746860", "bodyText": "It is still used by deletePath().", "author": "jiajunwang", "createdAt": "2020-03-03T01:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNzI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNzk3OQ==", "url": "https://github.com/apache/helix/pull/845#discussion_r386737979", "bodyText": "You prefer 1204 over 1024? :)", "author": "huizhilu", "createdAt": "2020-03-03T00:45:39Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "diffHunk": "@@ -745,4 +749,65 @@ public void testWaitForEstablishedSession() {\n     // Recover zk server for later tests.\n     _zkServer.start();\n   }\n+\n+  @Test\n+  public void testAsyncWriteOperations() {\n+    ZkClient zkClient = new ZkClient(ZK_ADDR);\n+    String originSizeLimit =\n+        System.getProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES);\n+    System.setProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES, \"2000\");\n+    try {\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+      ZNRecord oversizeZNRecord = new ZNRecord(\"Oversize\");\n+      StringBuilder sb = new StringBuilder(1204);", "originalCommit": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NzEyMA==", "url": "https://github.com/apache/helix/pull/845#discussion_r386747120", "bodyText": "This is to leave some buffer space. 1024 will fail due to the additional metadata info in the node.", "author": "jiajunwang", "createdAt": "2020-03-03T01:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNzk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MTE4Ng==", "url": "https://github.com/apache/helix/pull/845#discussion_r386741186", "bodyText": "Nit: maybe it is good to use verify() and Assert to make sure the path is deleted? Do we also need to consider deleting \"/tmp\" if it did not exist originally as you would create it?", "author": "huizhilu", "createdAt": "2020-03-03T00:56:41Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "diffHunk": "@@ -745,4 +749,65 @@ public void testWaitForEstablishedSession() {\n     // Recover zk server for later tests.\n     _zkServer.start();\n   }\n+\n+  @Test\n+  public void testAsyncWriteOperations() {\n+    ZkClient zkClient = new ZkClient(ZK_ADDR);\n+    String originSizeLimit =\n+        System.getProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES);\n+    System.setProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES, \"2000\");\n+    try {\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+      ZNRecord oversizeZNRecord = new ZNRecord(\"Oversize\");\n+      StringBuilder sb = new StringBuilder(1204);\n+      Random ran = new Random();\n+      for (int i = 0; i < 1024; i++) {\n+        sb.append(ran.nextInt(26) + 'a');\n+      }\n+      String buf = sb.toString();\n+      for (int i = 0; i < 1024; i++) {\n+        oversizeZNRecord.setSimpleField(Integer.toString(i), buf);\n+      }\n+\n+      // ensure /tmp exists for the test\n+      if (!zkClient.exists(\"/tmp\")) {\n+        zkClient.create(\"/tmp\", null, CreateMode.PERSISTENT);\n+      }\n+\n+      org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.CreateCallbackHandler\n+          createCallback = new org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.CreateCallbackHandler();\n+      zkClient.asyncCreate(\"/tmp/async\", null, CreateMode.PERSISTENT, createCallback);\n+      createCallback.waitForSuccess();\n+      Assert.assertEquals(createCallback.getRc(), 0);\n+\n+      // try to create oversize node, should fail\n+      zkClient.asyncCreate(\"/tmp/asyncOversize\", oversizeZNRecord, CreateMode.PERSISTENT,\n+          createCallback);\n+      createCallback.waitForSuccess();\n+      Assert.assertEquals(createCallback.getRc(), KeeperException.Code.MarshallingError);\n+\n+      ZNRecord normalZNRecord = new ZNRecord(\"normal\");\n+      normalZNRecord.setSimpleField(\"key\", buf);\n+\n+      org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.SetDataCallbackHandler\n+          setDataCallbackHandler = new org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.SetDataCallbackHandler();\n+      zkClient.asyncSetData(\"/tmp/async\", normalZNRecord, -1, setDataCallbackHandler);\n+      setDataCallbackHandler.waitForSuccess();\n+      Assert.assertEquals(setDataCallbackHandler.getRc(), 0);\n+\n+      zkClient.asyncSetData(\"/tmp/async\", oversizeZNRecord, -1, setDataCallbackHandler);\n+      setDataCallbackHandler.waitForSuccess();\n+      Assert.assertEquals(setDataCallbackHandler.getRc(), KeeperException.Code.MarshallingError);\n+    } finally {\n+      if (originSizeLimit == null) {\n+        System.clearProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES);\n+      } else {\n+        System.setProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES,\n+            originSizeLimit);\n+      }\n+      zkClient.delete(\"/tmp/async\");\n+      zkClient.delete(\"/tmp/asyncOversize\");", "originalCommit": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NzM3NA==", "url": "https://github.com/apache/helix/pull/845#discussion_r386747374", "bodyText": "It has been taken care of by after method call. And if the delete fails, there is nothing I can do except to fail the test. But it is not really this test is testing for. So let's don't over test here.", "author": "jiajunwang", "createdAt": "2020-03-03T01:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MTE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzI1Mg==", "url": "https://github.com/apache/helix/pull/845#discussion_r386743252", "bodyText": "Nit: It seems this is redundant? Do you want to make the byte[] array final? If so, you may do declare data as final without initializing it to null.\nfinal byte[] data;", "author": "huizhilu", "createdAt": "2020-03-03T01:03:57Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1720,33 +1721,43 @@ public Stat writeDataGetStat(final String path, Object datat, final int expected\n   public void asyncCreate(final String path, Object datat, final CreateMode mode,\n       final ZkAsyncCallbacks.CreateCallbackHandler cb) {\n     final long startT = System.currentTimeMillis();\n-    final byte[] data = (datat == null ? null : serialize(datat, path));\n-    retryUntilConnected(new Callable<Object>() {\n-      @Override\n-      public Object call() throws Exception {\n-        ((ZkConnection) getConnection()).getZookeeper()\n-            .create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE,\n-                // Arrays.asList(DEFAULT_ACL),\n-                mode, cb, new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT,\n-                    data == null ? 0 : data.length, false));\n-        return null;\n-      }\n+    byte[] data = null;\n+    try {\n+      data = (datat == null ? null : serialize(datat, path));\n+    } catch (ZkMarshallingError e) {\n+      cb.processResult(KeeperException.Code.MARSHALLINGERROR.intValue(), path,\n+          new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT, 0, false), null);\n+      return;\n+    }\n+    final byte[] finalData = data;\n+    retryUntilConnected(() -> {\n+      ((ZkConnection) getConnection()).getZookeeper()\n+          .create(path, finalData, ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+              // Arrays.asList(DEFAULT_ACL),\n+              mode, cb, new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT,\n+                  finalData == null ? 0 : finalData.length, false));\n+      return null;\n     });\n   }\n \n   // Async Data Accessors\n   public void asyncSetData(final String path, Object datat, final int version,\n       final ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n     final long startT = System.currentTimeMillis();\n-    final byte[] data = serialize(datat, path);\n-    retryUntilConnected(new Callable<Object>() {\n-      @Override\n-      public Object call() throws Exception {\n-        ((ZkConnection) getConnection()).getZookeeper().setData(path, data, version, cb,\n-            new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT,\n-                data == null ? 0 : data.length, false));\n-        return null;\n-      }\n+    byte[] data = null;\n+    try {\n+      data = serialize(datat, path);\n+    } catch (ZkMarshallingError e) {\n+      cb.processResult(KeeperException.Code.MARSHALLINGERROR.intValue(), path,\n+          new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT, 0, false), null);\n+      return;\n+    }\n+    final byte[] finalData = data;", "originalCommit": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0Nzk3MQ==", "url": "https://github.com/apache/helix/pull/845#discussion_r386747971", "bodyText": "The thing is that I don't want to put the retryUntilConnected() method into the try catch block.\nWith the current structure, final data is not possible.", "author": "jiajunwang", "createdAt": "2020-03-03T01:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwMDI2Mw==", "url": "https://github.com/apache/helix/pull/845#discussion_r386800263", "bodyText": "I think it is possible:\nfinal byte[] data;\ntry {\n  data = serialize(datat, path);\n} catch (ZkMarshallingError e) {\n  cb.processResult(KeeperException.Code.MARSHALLINGERROR.intValue(), path,\n     new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT, 0, false), null);\n  return;\n}\n\nretryUntilConnected();", "author": "huizhilu", "createdAt": "2020-03-03T05:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NDU0NQ==", "url": "https://github.com/apache/helix/pull/845#discussion_r386744545", "bodyText": "Nit: Do you also want to check before and after: if the node exists or not to double check the node is not created?", "author": "huizhilu", "createdAt": "2020-03-03T01:08:11Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "diffHunk": "@@ -745,4 +749,65 @@ public void testWaitForEstablishedSession() {\n     // Recover zk server for later tests.\n     _zkServer.start();\n   }\n+\n+  @Test\n+  public void testAsyncWriteOperations() {\n+    ZkClient zkClient = new ZkClient(ZK_ADDR);\n+    String originSizeLimit =\n+        System.getProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES);\n+    System.setProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES, \"2000\");\n+    try {\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+      ZNRecord oversizeZNRecord = new ZNRecord(\"Oversize\");\n+      StringBuilder sb = new StringBuilder(1204);\n+      Random ran = new Random();\n+      for (int i = 0; i < 1024; i++) {\n+        sb.append(ran.nextInt(26) + 'a');\n+      }\n+      String buf = sb.toString();\n+      for (int i = 0; i < 1024; i++) {\n+        oversizeZNRecord.setSimpleField(Integer.toString(i), buf);\n+      }\n+\n+      // ensure /tmp exists for the test\n+      if (!zkClient.exists(\"/tmp\")) {\n+        zkClient.create(\"/tmp\", null, CreateMode.PERSISTENT);\n+      }\n+\n+      org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.CreateCallbackHandler\n+          createCallback = new org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.CreateCallbackHandler();\n+      zkClient.asyncCreate(\"/tmp/async\", null, CreateMode.PERSISTENT, createCallback);\n+      createCallback.waitForSuccess();\n+      Assert.assertEquals(createCallback.getRc(), 0);\n+\n+      // try to create oversize node, should fail\n+      zkClient.asyncCreate(\"/tmp/asyncOversize\", oversizeZNRecord, CreateMode.PERSISTENT,\n+          createCallback);\n+      createCallback.waitForSuccess();\n+      Assert.assertEquals(createCallback.getRc(), KeeperException.Code.MarshallingError);", "originalCommit": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0ODg4OQ==", "url": "https://github.com/apache/helix/pull/845#discussion_r386748889", "bodyText": "Good idea, let me add it.", "author": "jiajunwang", "createdAt": "2020-03-03T01:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NDU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTE5Nw==", "url": "https://github.com/apache/helix/pull/845#discussion_r386745197", "bodyText": "Random is good to make sure compressed data is not that small!", "author": "huizhilu", "createdAt": "2020-03-03T01:10:33Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "diffHunk": "@@ -745,4 +749,65 @@ public void testWaitForEstablishedSession() {\n     // Recover zk server for later tests.\n     _zkServer.start();\n   }\n+\n+  @Test\n+  public void testAsyncWriteOperations() {\n+    ZkClient zkClient = new ZkClient(ZK_ADDR);\n+    String originSizeLimit =\n+        System.getProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES);\n+    System.setProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES, \"2000\");\n+    try {\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+      ZNRecord oversizeZNRecord = new ZNRecord(\"Oversize\");\n+      StringBuilder sb = new StringBuilder(1204);\n+      Random ran = new Random();\n+      for (int i = 0; i < 1024; i++) {\n+        sb.append(ran.nextInt(26) + 'a');", "originalCommit": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2NDQyMg==", "url": "https://github.com/apache/helix/pull/845#discussion_r387364422", "bodyText": "@jiajunwang sb.append(ran.nextInt(26) + 'a'); doesn't add a char to the string builder but an integer.\nWe still have to cast it: sb.append((char) (ran.nextInt(26) + 'a'));", "author": "huizhilu", "createdAt": "2020-03-03T23:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTE5Nw=="}], "type": "inlineReview"}, {"oid": "4122d1ddc883076cda7ef928ddaac1484f4333cf", "url": "https://github.com/apache/helix/commit/4122d1ddc883076cda7ef928ddaac1484f4333cf", "message": "Address comment", "committedDate": "2020-03-03T01:23:47Z", "type": "commit"}]}