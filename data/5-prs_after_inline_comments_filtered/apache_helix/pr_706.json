{"pr_number": 706, "pr_title": "Implement trie routing data", "pr_createdAt": "2020-01-29T21:42:22Z", "pr_url": "https://github.com/apache/helix/pull/706", "timeline": [{"oid": "1129650b89026ff7e4f5e2b5a1e31b67acc09cbd", "url": "https://github.com/apache/helix/commit/1129650b89026ff7e4f5e2b5a1e31b67acc09cbd", "message": "Implement sharding key prefix-tree class", "committedDate": "2020-01-15T22:06:47Z", "type": "commit"}, {"oid": "f6e54138b4b6bd368e951ec86c2905827bff0752", "url": "https://github.com/apache/helix/commit/f6e54138b4b6bd368e951ec86c2905827bff0752", "message": "Rename the class to TrieNode", "committedDate": "2020-01-23T01:22:32Z", "type": "commit"}, {"oid": "6782d3b3bf540daf2d3ccf0641e9f93ba35e82b5", "url": "https://github.com/apache/helix/commit/6782d3b3bf540daf2d3ccf0641e9f93ba35e82b5", "message": "Addressing all comments", "committedDate": "2020-01-24T00:00:44Z", "type": "commit"}, {"oid": "3fb39e521e72fefcf7c278ddf4c8685b0cf1b27c", "url": "https://github.com/apache/helix/commit/3fb39e521e72fefcf7c278ddf4c8685b0cf1b27c", "message": "Add unit tests", "committedDate": "2020-01-24T22:06:03Z", "type": "commit"}, {"oid": "9e7c4eaabae6419107b36ebe236516e6f0020abe", "url": "https://github.com/apache/helix/commit/9e7c4eaabae6419107b36ebe236516e6f0020abe", "message": "return unmodifiablemap for getter on final variable", "committedDate": "2020-01-27T19:07:20Z", "type": "commit"}, {"oid": "b2bfabb1f77cb2eae41f1aef3b11f209ea958f41", "url": "https://github.com/apache/helix/commit/b2bfabb1f77cb2eae41f1aef3b11f209ea958f41", "message": "adds default builder children param", "committedDate": "2020-01-28T01:39:22Z", "type": "commit"}, {"oid": "4f6ea39dea83bb52c31b6658d0aeaa782e510ac9", "url": "https://github.com/apache/helix/commit/4f6ea39dea83bb52c31b6658d0aeaa782e510ac9", "message": "change getZkRealmAddress behaviour", "committedDate": "2020-01-28T20:48:16Z", "type": "commit"}, {"oid": "9f5372a1501be6fa7aec5ae99eac8e882a81b38f", "url": "https://github.com/apache/helix/commit/9f5372a1501be6fa7aec5ae99eac8e882a81b38f", "message": "implement routing data trie", "committedDate": "2020-01-29T21:26:48Z", "type": "commit"}, {"oid": "2932775e623ae16428b291b0bf07b6ba46093ca7", "url": "https://github.com/apache/helix/commit/2932775e623ae16428b291b0bf07b6ba46093ca7", "message": "fix formatting", "committedDate": "2020-01-29T21:44:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY1NTQ1Mg==", "url": "https://github.com/apache/helix/pull/706#discussion_r372655452", "bodyText": "This method is 90% the same as the findTrieNode, can we please merge them?", "author": "jiajunwang", "createdAt": "2020-01-29T22:02:16Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _zkRealmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String zkRealmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _zkRealmAddress = zkRealmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String zkPath) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(zkPath);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (zkPath.substring(zkPath.length() - 1).equals(\"/\")) {\n+      zkPath = zkPath.substring(0, zkPath.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, zkPath);\n+    return resultMap;\n+  }\n+\n+  public String getZkRealm(String zkPath) throws IllegalArgumentException {\n+    TrieNode leafNode = findLeafTrieNodeAlongPath(zkPath);\n+    return leafNode._zkRealmAddress;\n+  }\n+\n+  /**\n+   * Using the root node, find the trie node that the given zkPath is pointing to and return it.\n+   * Raise IllegalArgumentException if the zkPath does not point to any node.\n+   * @param zkPath - the zkPath where the search is conducted\n+   * @return the node pointed by the zkPath\n+   * @throws IllegalArgumentException - when the zkPath points to nothing\n+   */\n+  private TrieNode findTrieNode(String zkPath) throws IllegalArgumentException {\n+    if (zkPath.equals(\"/\") || zkPath.equals(\"\")) {\n+      return _rootNode;\n+    }\n+\n+    if (zkPath.substring(0, 1).equals(\"/\")) {\n+      zkPath = zkPath.substring(1);\n+    }\n+    String[] splitZkPath = zkPath.split(\"/\", 0);\n+    TrieNode curNode = _rootNode;\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitZkPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode != null) {\n+        curChildren = curNode._children;\n+      } else {\n+        throw new IllegalArgumentException(\"the provided zkPath is missing from the trie\");\n+      }\n+    }\n+    return curNode;\n+  }\n+\n+  /**\n+   * Using the root node, find the leaf node along the provided zkPath. Raise\n+   * IllegalArgumentException if the zkPath does not point to any node or if there is no leaf node\n+   * along the path.\n+   * @param zkPath - the zkPath where the search is conducted\n+   * @return the leaf node along the provided zkPath\n+   * @throws IllegalArgumentException - when the zkPath points to nothing or when there is no leaf\n+   *           node along the path.\n+   */\n+  private TrieNode findLeafTrieNodeAlongPath(String zkPath) throws IllegalArgumentException {", "originalCommit": "2932775e623ae16428b291b0bf07b6ba46093ca7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2NzIyMQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r372667221", "bodyText": "I could set a flag to reuse the same logic, but I was concerned about the code being a bit messy. I'll write it up and see how it turns out.", "author": "NealSun96", "createdAt": "2020-01-29T22:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY1NTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3NDA2OA==", "url": "https://github.com/apache/helix/pull/706#discussion_r372674068", "bodyText": "I combined the two methods. It seems a bit long to me, but it does work.", "author": "NealSun96", "createdAt": "2020-01-29T22:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY1NTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTM0NA==", "url": "https://github.com/apache/helix/pull/706#discussion_r372661344", "bodyText": "Shall we just call it ZkRealmData?\nIt might be confusing because we have routing table provider for completely different usage.", "author": "jiajunwang", "createdAt": "2020-01-29T22:16:16Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/RoutingData.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface RoutingData {", "originalCommit": "2932775e623ae16428b291b0bf07b6ba46093ca7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2Njk3MQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r372666971", "bodyText": "I don't have the context for the routing table provider, therefore I don't have any objection to that. Tagging @narendly for reference.", "author": "NealSun96", "createdAt": "2020-01-29T22:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5MzgyOQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r372693829", "bodyText": "As we discussed, \"MetadataStoreRoutingData\" might be more appropriate here.", "author": "narendly", "createdAt": "2020-01-29T23:50:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTM0NA=="}], "type": "inlineReview"}, {"oid": "b704e5bcb548493fa0d62c40c6852b9360048c67", "url": "https://github.com/apache/helix/commit/b704e5bcb548493fa0d62c40c6852b9360048c67", "message": "combine two methods", "committedDate": "2020-01-29T22:46:59Z", "type": "commit"}, {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "url": "https://github.com/apache/helix/commit/a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "message": "remove redundant public", "committedDate": "2020-01-29T23:33:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NDAyNg==", "url": "https://github.com/apache/helix/pull/706#discussion_r372694026", "bodyText": "We could rename this to getMetadataStoreRealm to keep the interface generic.", "author": "narendly", "createdAt": "2020-01-29T23:51:03Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/RoutingData.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface RoutingData {\n+  /**\n+   * Given a zkPath, return all the \"sharding key-zkRealmAddress\" pairs where the sharding keys\n+   * contain the given zkPath. For example, given \"/ESPRESSO_MT_LD-1/schemata\", return\n+   * {\"/ESPRESSO_MT_LD-1/schemata/ESPRESSO_MT_LD-1\": \"zk-ltx1-0-espresso.prod.linkedin.com:2181\",\n+   * \"/ESPRESSO_MT_LD-1/schemata/ESPRESSO_MT_LD-2\": \"zk-ltx1-1-espresso.prod.linkedin.com:2181\"}.\n+   * If the zkPath is invalid, returns an empty mapping.\n+   * @param zkPath - the zkPath where the search is conducted\n+   * @return all \"sharding key-zkRealmAddress\" pairs where the sharding keys contain the given\n+   *         zkPath if the zkPath is valid; empty mapping otherwise\n+   */\n+  Map<String, String> getAllMappingUnderPath(String zkPath);\n+\n+  /**\n+   * Given a zkPath, return the zkRealmAddress corresponding to the sharding key contained in the\n+   * zkPath. If the zkPath doesn't contain a sharding key, throw IllegalArgumentException.\n+   * @param zkPath - the zkPath where the search is conducted\n+   * @return the zkRealmAddress corresponding to the sharding key contained in the zkPath\n+   * @throws IllegalArgumentException - when the zkPath doesn't contain a sharding key\n+   */\n+  String getZkRealm(String zkPath) throws IllegalArgumentException;", "originalCommit": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NDI4Nw==", "url": "https://github.com/apache/helix/pull/706#discussion_r372694287", "bodyText": "Please refrain from exposing internal details @nealsun-linkedin", "author": "narendly", "createdAt": "2020-01-29T23:51:54Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/RoutingData.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface RoutingData {\n+  /**\n+   * Given a zkPath, return all the \"sharding key-zkRealmAddress\" pairs where the sharding keys\n+   * contain the given zkPath. For example, given \"/ESPRESSO_MT_LD-1/schemata\", return\n+   * {\"/ESPRESSO_MT_LD-1/schemata/ESPRESSO_MT_LD-1\": \"zk-ltx1-0-espresso.prod.linkedin.com:2181\",\n+   * \"/ESPRESSO_MT_LD-1/schemata/ESPRESSO_MT_LD-2\": \"zk-ltx1-1-espresso.prod.linkedin.com:2181\"}.", "originalCommit": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NDYyNw==", "url": "https://github.com/apache/helix/pull/706#discussion_r372694627", "bodyText": "This is an interface class; therefore, we want to keep it generic. This means that this interface class should be independent of ZK.\nAlso please refrain from using internal details in comments. This is an open source project.", "author": "narendly", "createdAt": "2020-01-29T23:52:57Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/RoutingData.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.rest.metadatastore;", "originalCommit": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NTcxNQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r372695715", "bodyText": "getMetadataStoreRealm since we want to make this metadata store-agnostic", "author": "narendly", "createdAt": "2020-01-29T23:56:33Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _zkRealmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String zkRealmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _zkRealmAddress = zkRealmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String zkPath) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(zkPath, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (zkPath.substring(zkPath.length() - 1).equals(\"/\")) {\n+      zkPath = zkPath.substring(0, zkPath.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, zkPath);\n+    return resultMap;\n+  }\n+\n+  public String getZkRealm(String zkPath) throws IllegalArgumentException {", "originalCommit": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjEyNQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r372696125", "bodyText": "In general, be careful about terminology you use here. I'd say this class could be used for all metadata stores that use a filesystem API (assuming there are paths).\nSo your variables will have to be named something other than zkPath..", "author": "narendly", "createdAt": "2020-01-29T23:57:54Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {", "originalCommit": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0099083107a0c60a75657c73b2bcfd73b5f62e0c", "url": "https://github.com/apache/helix/commit/0099083107a0c60a75657c73b2bcfd73b5f62e0c", "message": "Address comments about store-agnostic features etc", "committedDate": "2020-01-30T00:25:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNzczOA==", "url": "https://github.com/apache/helix/pull/706#discussion_r372707738", "bodyText": "This is not complete realm address. Naming as it could be confusing.", "author": "junkaixue", "createdAt": "2020-01-30T00:40:16Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;", "originalCommit": "0099083107a0c60a75657c73b2bcfd73b5f62e0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxNTYzMg==", "url": "https://github.com/apache/helix/pull/706#discussion_r372715632", "bodyText": "Do you have any suggestion on the naming?", "author": "NealSun96", "createdAt": "2020-01-30T01:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNzczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE1OTkxMg==", "url": "https://github.com/apache/helix/pull/706#discussion_r373159912", "bodyText": "Per offline meeting, the confusion has been cleared up. Action point: adding javadoc to explain what this field actually means, but the field will remain.", "author": "NealSun96", "createdAt": "2020-01-30T19:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNzczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwODMwNw==", "url": "https://github.com/apache/helix/pull/706#discussion_r372708307", "bodyText": "To fast the processing, we can sacrifice some memory usage as storing all the sub children in current node.", "author": "junkaixue", "createdAt": "2020-01-30T00:42:20Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String realmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _realmAddress = realmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (path.substring(path.length() - 1).equals(\"/\")) {\n+      path = path.substring(0, path.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, path);\n+    return resultMap;", "originalCommit": "0099083107a0c60a75657c73b2bcfd73b5f62e0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcyMTIwNw==", "url": "https://github.com/apache/helix/pull/706#discussion_r372721207", "bodyText": "What I assume you mean is to store all descendant leaf nodes of a trie node as the children of a trie node. If the purposed change is a structural design change, then I'm afraid I have to disagree.\nThe purposed structural change does allow a faster operation for getAllMappingUnderPath, however, it suffers from the following:\n\nThe trie will take longer to construct. Bear in mind that the trie is created on the fly by the major user, therefore construction cost is a realistic concern.\nWith the cost in mind, this change doesn't help with the other operation getMetadataStoreRealm at all.\nA structural change like this makes the data structure no longer a trie. This is intended to be a trie class.", "author": "NealSun96", "createdAt": "2020-01-30T01:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwODMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE2MTUxMA==", "url": "https://github.com/apache/helix/pull/706#discussion_r373161510", "bodyText": "Per offline meeting, the agreement is to keep the implementation as is for the current PR, and based on future usage statistics, potentially make optimization updates as suggested.", "author": "NealSun96", "createdAt": "2020-01-30T19:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwODMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDE4NA==", "url": "https://github.com/apache/helix/pull/706#discussion_r372710184", "bodyText": "This logic confuse me here.\nIf you have trie:\na - leaf\nb       c  -leaf\nd   e - leaf\nAnd you are looking for  /a/b with leaf flag as false. Then you will return root as /a. right?  But for searching purpose. I think it is correct to return b node. Can you explain what is expected scenario?", "author": "junkaixue", "createdAt": "2020-01-30T00:49:48Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String realmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _realmAddress = realmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (path.substring(path.length() - 1).equals(\"/\")) {\n+      path = path.substring(0, path.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, path);\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws IllegalArgumentException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise IllegalArgumentException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise IllegalArgumentException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws IllegalArgumentException - when the path points to nothing or when no leaf node is found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws IllegalArgumentException {\n+    if (path.equals(\"/\") || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new IllegalArgumentException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(\"/\")) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(\"/\", 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }", "originalCommit": "0099083107a0c60a75657c73b2bcfd73b5f62e0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxNjM5Mg==", "url": "https://github.com/apache/helix/pull/706#discussion_r372716392", "bodyText": "Github formatting might have ruined the trie you drew.\nEither way, if the leaf flag is false, then this if statement won't be triggered, and the method will search for b as it continues to the loop; if the leaf flag is true, it checks to see if a is a leaf, if yes then return.\nIf this is not clear, feel free to discuss with me in person. The comment formatting is not helping.", "author": "NealSun96", "createdAt": "2020-01-30T01:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzMjE1OA==", "url": "https://github.com/apache/helix/pull/706#discussion_r373232158", "bodyText": "Per offline discussion, the confusion is led by the variable _isLeaf. _isLeaf is not using the trie sense, but the regular tree sense - it means if the node is a node without children. In a separate discussion, @narendly insisted that one variable shouldn't have two functionalities and we should not use children to dictate the node status, therefore _isLeaf is necessary. I have added javadoc to the variable to clarify the confusion.", "author": "NealSun96", "createdAt": "2020-01-30T22:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDU3NQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r372710575", "bodyText": "Let's try to use iterative way instead of recursive call. You may take more memory in memory stack for function recursive call.", "author": "junkaixue", "createdAt": "2020-01-30T00:51:28Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String realmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _realmAddress = realmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (path.substring(path.length() - 1).equals(\"/\")) {\n+      path = path.substring(0, path.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, path);\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws IllegalArgumentException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise IllegalArgumentException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise IllegalArgumentException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws IllegalArgumentException - when the path points to nothing or when no leaf node is found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws IllegalArgumentException {\n+    if (path.equals(\"/\") || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new IllegalArgumentException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(\"/\")) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(\"/\", 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new IllegalArgumentException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new IllegalArgumentException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  /**\n+   * Given a trie node, search for all leaf nodes that descend from the given trie node, and add\n+   * all complete paths and realm addresses of these leaf nodes to a provided mapping. This method\n+   * recursively calls itself.\n+   * @param mapping - where the results (complete paths of leaf nodes and their realm addresses)\n+   *          are stored\n+   * @param curNode - the current trie node where the search starts\n+   * @param curPath - the complete path of the current trie node\n+   */\n+  private static void addAllAddressesToMapping(Map<String, String> mapping, TrieNode curNode,\n+      String curPath) {\n+    if (curNode._isLeaf) {\n+      mapping.put(curPath, curNode._realmAddress);\n+      return;\n+    }\n+\n+    for (Map.Entry<String, TrieNode> entry : curNode._children.entrySet()) {\n+      addAllAddressesToMapping(mapping, entry.getValue(), curPath + \"/\" + entry.getKey());", "originalCommit": "0099083107a0c60a75657c73b2bcfd73b5f62e0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcyMzY1Nw==", "url": "https://github.com/apache/helix/pull/706#discussion_r372723657", "bodyText": "The recursive calls won't create many call stacks because the depth of the trie is typically limited: based on the current usage, the maximum is 3. The number of call stacks is bounded by the depth of the trie.\nIn terms of scaling in the future, I do agree that an iterative method is better, however, constructing the full paths for each node is more difficult than necessary. (This is related to your next comment - storing full paths resolves this problem. If you feel strongly about the full-path design, I'm happy to discuss further.)", "author": "NealSun96", "createdAt": "2020-01-30T01:45:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEwMjYxMQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373102611", "bodyText": "I thought about it and turns out the iterative method is not as ugly as I thought. Therefore I'm changing it from the recursive method since it is indeed better.", "author": "NealSun96", "createdAt": "2020-01-30T17:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzExNzM5MQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373117391", "bodyText": "I experimented with \"nodes storing full path\" and \"node storing partial path\", and turns out the full path approach makes this method marginally better. I'm therefore adding a field that represents the full path of a trie node.", "author": "NealSun96", "createdAt": "2020-01-30T18:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMTIwNw==", "url": "https://github.com/apache/helix/pull/706#discussion_r372711207", "bodyText": "What if the path does not exist? Why we dont use a complete path to add to trie but with partial info trie node to add to the path? Logically, it is not correct.", "author": "junkaixue", "createdAt": "2020-01-30T00:54:01Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String realmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _realmAddress = realmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (path.substring(path.length() - 1).equals(\"/\")) {\n+      path = path.substring(0, path.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, path);\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws IllegalArgumentException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise IllegalArgumentException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise IllegalArgumentException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws IllegalArgumentException - when the path points to nothing or when no leaf node is found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws IllegalArgumentException {\n+    if (path.equals(\"/\") || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new IllegalArgumentException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(\"/\")) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(\"/\", 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new IllegalArgumentException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new IllegalArgumentException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  /**\n+   * Given a trie node, search for all leaf nodes that descend from the given trie node, and add\n+   * all complete paths and realm addresses of these leaf nodes to a provided mapping. This method\n+   * recursively calls itself.\n+   * @param mapping - where the results (complete paths of leaf nodes and their realm addresses)\n+   *          are stored\n+   * @param curNode - the current trie node where the search starts\n+   * @param curPath - the complete path of the current trie node\n+   */\n+  private static void addAllAddressesToMapping(Map<String, String> mapping, TrieNode curNode,\n+      String curPath) {\n+    if (curNode._isLeaf) {\n+      mapping.put(curPath, curNode._realmAddress);\n+      return;\n+    }\n+\n+    for (Map.Entry<String, TrieNode> entry : curNode._children.entrySet()) {\n+      addAllAddressesToMapping(mapping, entry.getValue(), curPath + \"/\" + entry.getKey());", "originalCommit": "0099083107a0c60a75657c73b2bcfd73b5f62e0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcyMjQ1MQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r372722451", "bodyText": "Two points are raised here which I'll try to break down:\n\nWhat if the path does not exist?\nThe path has to exist because the method is traversing the previously constructed trie; whatever path is defined will be in the trie - this method is not creating arbitrary paths. I believe logically this method is correct. I have several unit tests to prove that it's working.\nWhy don't we store the complete path in the trie node?\nI have considered this design before, and I believe storing complete paths also work. However, partial paths is working without an issue, therefore I see no significant benefit changing it. If you feel strongly about this, I'm happy to discuss further.", "author": "NealSun96", "createdAt": "2020-01-30T01:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMTIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzExODI4OQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373118289", "bodyText": "Update on point 2 (also replied on the previous comment): the \"complete path\" is marginally better for an iterative getAllMappingUnderPath therefore I added the full path field to TrieNode. Thanks for the suggestion @dasahcc . Since the method is iterative, point 1 no longer is an issue. Resolving the conversation.", "author": "NealSun96", "createdAt": "2020-01-30T18:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMTIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjQ5NA==", "url": "https://github.com/apache/helix/pull/706#discussion_r372696494", "bodyText": "Should this be a private class? Also please move this to the end.", "author": "narendly", "createdAt": "2020-01-29T23:59:09Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {", "originalCommit": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA4OTM1Nw==", "url": "https://github.com/apache/helix/pull/706#discussion_r373089357", "bodyText": "The class is declared as package private for testing purpose. Otherwise trie nodes cannot be created in the unit tests.\nIt'll be moved to the end as suggested.", "author": "NealSun96", "createdAt": "2020-01-30T17:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE2NjAwOQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373166009", "bodyText": "I have reconsidered it and I find package private to be not secure enough. I will add a TODO on TrieNode because the unit tests are still dependent on it being package private; once the constructor is created, it will be changed to private.", "author": "NealSun96", "createdAt": "2020-01-30T20:04:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjYzOQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r372696639", "bodyText": "Add JavaDoc.", "author": "narendly", "createdAt": "2020-01-29T23:59:38Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _zkRealmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String zkRealmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _zkRealmAddress = zkRealmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String zkPath) {", "originalCommit": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjY5Nw==", "url": "https://github.com/apache/helix/pull/706#discussion_r372696697", "bodyText": "zkPath -> path?", "author": "narendly", "createdAt": "2020-01-29T23:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA5MzAwMg==", "url": "https://github.com/apache/helix/pull/706#discussion_r373093002", "bodyText": "Please see the interface for JavaDoc of getAllMappingUnderPath. I looked at CustomRestClient and CustomRestClientImpl for reference and mimicked its style of having JavaDoc in interface but not implementation. If this isn't the correct convention, please feel free to correct me.\nThe zkPath comment is on an outdated version of the files. The parameter has already been renamed.", "author": "NealSun96", "createdAt": "2020-01-30T17:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjczMzMyMw==", "url": "https://github.com/apache/helix/pull/706#discussion_r372733323", "bodyText": "Please use level-by-level traversal for this. We try to avoid recursion in production code.", "author": "narendly", "createdAt": "2020-01-30T02:32:10Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String realmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _realmAddress = realmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (path.substring(path.length() - 1).equals(\"/\")) {\n+      path = path.substring(0, path.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, path);\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws IllegalArgumentException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise IllegalArgumentException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise IllegalArgumentException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws IllegalArgumentException - when the path points to nothing or when no leaf node is found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws IllegalArgumentException {\n+    if (path.equals(\"/\") || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new IllegalArgumentException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(\"/\")) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(\"/\", 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new IllegalArgumentException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new IllegalArgumentException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  /**\n+   * Given a trie node, search for all leaf nodes that descend from the given trie node, and add\n+   * all complete paths and realm addresses of these leaf nodes to a provided mapping. This method\n+   * recursively calls itself.\n+   * @param mapping - where the results (complete paths of leaf nodes and their realm addresses)\n+   *          are stored\n+   * @param curNode - the current trie node where the search starts\n+   * @param curPath - the complete path of the current trie node\n+   */\n+  private static void addAllAddressesToMapping(Map<String, String> mapping, TrieNode curNode,\n+      String curPath) {\n+    if (curNode._isLeaf) {\n+      mapping.put(curPath, curNode._realmAddress);\n+      return;\n+    }\n+\n+    for (Map.Entry<String, TrieNode> entry : curNode._children.entrySet()) {", "originalCommit": "0099083107a0c60a75657c73b2bcfd73b5f62e0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEyMzMzMA==", "url": "https://github.com/apache/helix/pull/706#discussion_r373123330", "bodyText": "The recursion code is now replaced with an iterative method based on the feedback from both @dasahcc and @narendly. Because of such a change, I'm storing the complete path of a trie node to the name field of a TrieNode, the reasons are as follows:\n\nStoring complete paths in trie nodes makes getAllMappingUnderPath marginally better than storing partial paths. Without complete paths, the function has to either add/remove partial paths from a list as it operates a trie node stack, or store paths for all nodes as it operates the stack and waste memory; storing compete paths are faster, less wasteful, and simpler than both of these approaches.\nTrie nodes are usually seen to be associated with the complete prefix/strings they represent. Storing complete paths aligns with the common perception.\nHappy to discuss this further, but closing this conversion for now as the code is now iterative.", "author": "NealSun96", "createdAt": "2020-01-30T18:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjczMzMyMw=="}], "type": "inlineReview"}, {"oid": "6596488bbe4836f1cf4094c8b0c9c870261474cb", "url": "https://github.com/apache/helix/commit/6596488bbe4836f1cf4094c8b0c9c870261474cb", "message": "change recursive search to iterative", "committedDate": "2020-01-30T18:40:43Z", "type": "commit"}, {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "url": "https://github.com/apache/helix/commit/9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "message": "reorder private class", "committedDate": "2020-01-30T18:41:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIwNzkyMQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373207921", "bodyText": "private static final", "author": "jiajunwang", "createdAt": "2020-01-30T21:40:09Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final String DELIMITER = \"/\";", "originalCommit": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzMDIwOQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373230209", "bodyText": "Oops, thank you for catching it.", "author": "NealSun96", "createdAt": "2020-01-30T22:33:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIwNzkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxMDQ4OQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373210489", "bodyText": "nit, nodeStack.pop() can be done before check isLeaf()", "author": "jiajunwang", "createdAt": "2020-01-30T21:46:08Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Stack<TrieNode> nodeStack = new Stack<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      if (nodeStack.peek()._isLeaf) {\n+        resultMap.put(nodeStack.peek()._name, nodeStack.peek()._realmAddress);\n+        nodeStack.pop();", "originalCommit": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzMDExNw==", "url": "https://github.com/apache/helix/pull/706#discussion_r373230117", "bodyText": "Agreed.", "author": "NealSun96", "createdAt": "2020-01-30T22:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxMDQ4OQ=="}], "type": "inlineReview"}, {"oid": "10e178bee17a88a0ae4ee91aa4dd179e5bafcee9", "url": "https://github.com/apache/helix/commit/10e178bee17a88a0ae4ee91aa4dd179e5bafcee9", "message": "addresses comments based on discussion", "committedDate": "2020-01-30T22:39:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MTE4MA==", "url": "https://github.com/apache/helix/pull/706#discussion_r373171180", "bodyText": "Just to make it specific and unambiguous, let's say \"metadata store path sharding key\" and \"metadata store realm address\". And give examples.", "author": "narendly", "createdAt": "2020-01-30T20:15:52Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreRoutingData.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface MetadataStoreRoutingData {\n+  /**\n+   * Given a path, return all the \"sharding key-realm address\" pairs where the sharding keys", "originalCommit": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MTgyNg==", "url": "https://github.com/apache/helix/pull/706#discussion_r373171826", "bodyText": "Could we use an exception like **NotFoundException? IllegalArgumentException would be appropriate if the path was malformed.", "author": "narendly", "createdAt": "2020-01-30T20:17:22Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreRoutingData.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface MetadataStoreRoutingData {\n+  /**\n+   * Given a path, return all the \"sharding key-realm address\" pairs where the sharding keys\n+   * contain the given path. For example, given \"/a/b\", return {\"/a/b/c\":\n+   * \"realm.address.c.com:1234\", \"/a/b/d\": \"realm.address.d.com:1234\"}. If the path is invalid,\n+   * returns an empty mapping.\n+   * @param path - the path where the search is conducted\n+   * @return all \"sharding key-realm address\" pairs where the sharding keys contain the given\n+   *         path if the path is valid; empty mapping otherwise\n+   */\n+  Map<String, String> getAllMappingUnderPath(String path);\n+\n+  /**\n+   * Given a path, return the realm address corresponding to the sharding key contained in the\n+   * path. If the path doesn't contain a sharding key, throw IllegalArgumentException.\n+   * @param path - the path where the search is conducted\n+   * @return the realm address corresponding to the sharding key contained in the path\n+   * @throws IllegalArgumentException - when the path doesn't contain a sharding key\n+   */\n+  String getMetadataStoreRealm(String path) throws IllegalArgumentException;", "originalCommit": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzNzI2OA==", "url": "https://github.com/apache/helix/pull/706#discussion_r373237268", "bodyText": "I'll use javassist.NotFoundException, then.", "author": "NealSun96", "createdAt": "2020-01-30T22:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzODE2OQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373238169", "bodyText": "@NealSun96 Let's use https://docs.oracle.com/javase/8/docs/api/java/util/NoSuchElementException.html NoSuchElementException. This way, you don't have to import another library.", "author": "narendly", "createdAt": "2020-01-30T22:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3NjYxMg==", "url": "https://github.com/apache/helix/pull/706#discussion_r373276612", "bodyText": "Thank you for the suggestion. Updated.", "author": "NealSun96", "createdAt": "2020-01-31T01:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MjA2Ng==", "url": "https://github.com/apache/helix/pull/706#discussion_r373172066", "bodyText": "private static final for constant declarations", "author": "narendly", "createdAt": "2020-01-30T20:17:55Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final String DELIMITER = \"/\";", "originalCommit": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzNzM2MA==", "url": "https://github.com/apache/helix/pull/706#discussion_r373237360", "bodyText": "This has been addressed by @jiajunwang and is fixed.", "author": "NealSun96", "createdAt": "2020-01-30T22:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MjA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MzQyMw==", "url": "https://github.com/apache/helix/pull/706#discussion_r373173423", "bodyText": "Nit: ArrayDeque might provide better performance. Optional.", "author": "narendly", "createdAt": "2020-01-30T20:21:12Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Stack<TrieNode> nodeStack = new Stack<>();", "originalCommit": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzNzUxNQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373237515", "bodyText": "I didn't realize that Stack is Vector based. Thanks for the suggestion, I'll switch it over.", "author": "NealSun96", "createdAt": "2020-01-30T22:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MzQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3NTM4OA==", "url": "https://github.com/apache/helix/pull/706#discussion_r373175388", "bodyText": "Could we split this into two methods and remove this boolean flag? You could create another private method for the common logic.", "author": "narendly", "createdAt": "2020-01-30T20:25:36Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Stack<TrieNode> nodeStack = new Stack<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      if (nodeStack.peek()._isLeaf) {\n+        resultMap.put(nodeStack.peek()._name, nodeStack.peek()._realmAddress);\n+        nodeStack.pop();\n+      } else {\n+        curNode = nodeStack.pop();\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws IllegalArgumentException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise IllegalArgumentException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise IllegalArgumentException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws IllegalArgumentException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)", "originalCommit": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzOTQ3Nw==", "url": "https://github.com/apache/helix/pull/706#discussion_r373239477", "bodyText": "The two methods you mentioned were originally split out in this PR. It was @jiajunwang 's earlier comment that led to the merging of two methods (#706 (comment)). I don't have a strong opinion on either approach, but a general agreement should be made before I make any further changes.\nIn terms of extracting common logic, the way these methods work prevent that: leaf checking logic happens on every level of iteration - if common code is extracted, the common code will each be two lines long and is not reasonable as standalone code.", "author": "NealSun96", "createdAt": "2020-01-30T22:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3NTM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0ODA1Nw==", "url": "https://github.com/apache/helix/pull/706#discussion_r373248057", "bodyText": "If it's not easy, I'm okay with keeping it as one for now.", "author": "narendly", "createdAt": "2020-01-30T23:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3NTM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3Njc1NQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373276755", "bodyText": "Both approaches are fine to me. Keeping it as is for now.", "author": "NealSun96", "createdAt": "2020-01-31T01:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3NTM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3OTQxMg==", "url": "https://github.com/apache/helix/pull/706#discussion_r373179412", "bodyText": "Optional: usually I think it might be a good idea to wrap this into a class like MetadataStoreInfo that contains fields like realm address, but it's okay to keep it a string for now.", "author": "narendly", "createdAt": "2020-01-30T20:34:36Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreRoutingData.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface MetadataStoreRoutingData {\n+  /**\n+   * Given a path, return all the \"sharding key-realm address\" pairs where the sharding keys\n+   * contain the given path. For example, given \"/a/b\", return {\"/a/b/c\":\n+   * \"realm.address.c.com:1234\", \"/a/b/d\": \"realm.address.d.com:1234\"}. If the path is invalid,\n+   * returns an empty mapping.\n+   * @param path - the path where the search is conducted\n+   * @return all \"sharding key-realm address\" pairs where the sharding keys contain the given\n+   *         path if the path is valid; empty mapping otherwise\n+   */\n+  Map<String, String> getAllMappingUnderPath(String path);\n+\n+  /**\n+   * Given a path, return the realm address corresponding to the sharding key contained in the\n+   * path. If the path doesn't contain a sharding key, throw IllegalArgumentException.\n+   * @param path - the path where the search is conducted\n+   * @return the realm address corresponding to the sharding key contained in the path\n+   * @throws IllegalArgumentException - when the path doesn't contain a sharding key\n+   */\n+  String getMetadataStoreRealm(String path) throws IllegalArgumentException;", "originalCommit": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzOTcwMQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373239701", "bodyText": "I agree that this is a good idea, but for simplicity let's keep it as string for this PR.", "author": "NealSun96", "createdAt": "2020-01-30T22:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3OTQxMg=="}], "type": "inlineReview"}, {"oid": "0b777d07abc5442a2b38053bf5060c231723faff", "url": "https://github.com/apache/helix/commit/0b777d07abc5442a2b38053bf5060c231723faff", "message": "make tweaks such as docs, exception types, and stack class choice", "committedDate": "2020-01-30T23:06:50Z", "type": "commit"}, {"oid": "e96034483252dda15eb84bc2d6001784757bf25c", "url": "https://github.com/apache/helix/commit/e96034483252dda15eb84bc2d6001784757bf25c", "message": "change exception type", "committedDate": "2020-01-31T01:16:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3ODkzMQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373278931", "bodyText": "Nit: Try to make the error msg more helpful by adding the arguments (path and findLeafAlongPath)\nexample:\n\"No terminal node found along the path given! Path: \" + path", "author": "narendly", "createdAt": "2020-01-31T01:26:50Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");", "originalCommit": "e96034483252dda15eb84bc2d6001784757bf25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4MzEyMQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373283121", "bodyText": "Good point. Modifying test cases as well.", "author": "NealSun96", "createdAt": "2020-01-31T01:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3ODkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTExOQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373279119", "bodyText": "Nit: did we agree to rename this to _isTerminalNode?", "author": "narendly", "createdAt": "2020-01-31T01:27:46Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(DELIMITER, 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new NoSuchElementException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new NoSuchElementException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n+  static class TrieNode {\n+    /**\n+     * This field is a mapping between trie key and children nodes. For example, node \"a\" has\n+     * children \"ab\" and \"ac\", therefore the keys are \"b\" and \"c\" respectively.\n+     */\n+    Map<String, TrieNode> _children;\n+    /**\n+     * This field means if the node is a terminal node in the tree sense, not the trie sense. Any\n+     * node that has children cannot possibly be a leaf node because only the node without children\n+     * can store information.\n+     */\n+    final boolean _isLeaf;", "originalCommit": "e96034483252dda15eb84bc2d6001784757bf25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTk0Mw==", "url": "https://github.com/apache/helix/pull/706#discussion_r373279943", "bodyText": "Add here that if a node is terminal, it cannot have any children. This should be checked in this class as well.", "author": "narendly", "createdAt": "2020-01-31T01:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTM4OA==", "url": "https://github.com/apache/helix/pull/706#discussion_r373279388", "bodyText": "Let's make this errorMsg more helpful. See my comment above.", "author": "narendly", "createdAt": "2020-01-31T01:28:57Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(DELIMITER, 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new NoSuchElementException(\"the provided path is missing from the trie\");", "originalCommit": "e96034483252dda15eb84bc2d6001784757bf25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTQyOA==", "url": "https://github.com/apache/helix/pull/706#discussion_r373279428", "bodyText": "See above.", "author": "narendly", "createdAt": "2020-01-31T01:29:07Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(DELIMITER, 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new NoSuchElementException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new NoSuchElementException(\"no leaf node found along the path\");", "originalCommit": "e96034483252dda15eb84bc2d6001784757bf25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTcyMQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373279721", "bodyText": "This is not very clear?\nShouldn't it be : If a node \"a\" has children \"b\", and \"c\", then ....?", "author": "narendly", "createdAt": "2020-01-31T01:30:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(DELIMITER, 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new NoSuchElementException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new NoSuchElementException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n+  static class TrieNode {\n+    /**\n+     * This field is a mapping between trie key and children nodes. For example, node \"a\" has\n+     * children \"ab\" and \"ac\", therefore the keys are \"b\" and \"c\" respectively.", "originalCommit": "e96034483252dda15eb84bc2d6001784757bf25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4MzM1Mw==", "url": "https://github.com/apache/helix/pull/706#discussion_r373283353", "bodyText": "Resolved offline. See #706 (comment) for additional reference.", "author": "NealSun96", "createdAt": "2020-01-31T01:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4MDI2Mg==", "url": "https://github.com/apache/helix/pull/706#discussion_r373280262", "bodyText": "Didn't we agree to this:\nTrieNode : _name\nroot node: \"/\"\n\"a\": \"a\"\n\"b\": \"b\"\ninstead of \"/a/b\"?\nSince that would just require one String.split, and you'll have a comprehensive list of all nodes' names, which should make the tree traversal simpler as in it won't require any more splitting?", "author": "narendly", "createdAt": "2020-01-31T01:32:38Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(DELIMITER, 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new NoSuchElementException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new NoSuchElementException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n+  static class TrieNode {\n+    /**\n+     * This field is a mapping between trie key and children nodes. For example, node \"a\" has\n+     * children \"ab\" and \"ac\", therefore the keys are \"b\" and \"c\" respectively.\n+     */\n+    Map<String, TrieNode> _children;\n+    /**\n+     * This field means if the node is a terminal node in the tree sense, not the trie sense. Any\n+     * node that has children cannot possibly be a leaf node because only the node without children\n+     * can store information.\n+     */\n+    final boolean _isLeaf;\n+    /**\n+     * This field aligns the traditional trie design: it entails the complete path/prefix leading to\n+     * the current node. For example, the name of root node is \"/\", then the name of its child node\n+     * is \"/a\", and the name of the child's child node is \"/a/b\".\n+     */\n+    final String _name;", "originalCommit": "e96034483252dda15eb84bc2d6001784757bf25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4MzMzMQ==", "url": "https://github.com/apache/helix/pull/706#discussion_r373283331", "bodyText": "Resolved offline. See #706 (comment) for additional reference.", "author": "NealSun96", "createdAt": "2020-01-31T01:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4MDI2Mg=="}], "type": "inlineReview"}, {"oid": "221d8ff079f5d2f325074d5d22f7e4c770847e26", "url": "https://github.com/apache/helix/commit/221d8ff079f5d2f325074d5d22f7e4c770847e26", "message": "make final edits", "committedDate": "2020-01-31T01:51:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4ODcyNg==", "url": "https://github.com/apache/helix/pull/706#discussion_r373288726", "bodyText": "Why is this if condition required if we're going to do the same thing either way?", "author": "narendly", "createdAt": "2020-01-31T02:14:40Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"No leaf node found along the path. Path: \" + path);\n+      }\n+      return _rootNode;\n+    }\n+\n+    String[] splitPath;\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      splitPath = path.substring(1).split(DELIMITER, 0);\n+    } else {\n+      splitPath = path.substring(1).split(DELIMITER, 0);\n+    }", "originalCommit": "221d8ff079f5d2f325074d5d22f7e4c770847e26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU5NzE1OA==", "url": "https://github.com/apache/helix/pull/706#discussion_r373597158", "bodyText": "That was a mistake, thank you for catching it. I also added two more tests to ensure all if-paths are covered.", "author": "NealSun96", "createdAt": "2020-01-31T17:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4ODcyNg=="}], "type": "inlineReview"}, {"oid": "afdce50d795ead0f9bd5ee912238cf453d53b38e", "url": "https://github.com/apache/helix/commit/afdce50d795ead0f9bd5ee912238cf453d53b38e", "message": "fix incorrect substring line", "committedDate": "2020-01-31T17:31:28Z", "type": "commit"}]}