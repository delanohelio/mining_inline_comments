{"pr_number": 899, "pr_title": "Use Java Generics and inheritance to reduce duplicate code in Helix API Builders", "pr_createdAt": "2020-03-17T00:52:40Z", "pr_url": "https://github.com/apache/helix/pull/899", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNzMzOQ==", "url": "https://github.com/apache/helix/pull/899#discussion_r393827339", "bodyText": "nit, this is more a question, I think you have thought about this. Shall we call it GenericHelixZkApiBuilder?", "author": "jiajunwang", "createdAt": "2020-03-17T16:54:56Z", "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -932,73 +933,13 @@ public void close() {\n     }\n   }\n \n-  public static class Builder {\n-    private String _zkAddress;\n-    private RealmAwareZkClient.RealmMode _realmMode;\n-    private RealmAwareZkClient.RealmAwareZkConnectionConfig _realmAwareZkConnectionConfig;\n-    private RealmAwareZkClient.RealmAwareZkClientConfig _realmAwareZkClientConfig;\n-\n+  public static class Builder extends GenericZkHelixApiBuilder<Builder> {", "originalCommit": "988e67768cc04ca8853cb76815aa2f926f97072f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1NTIyNg==", "url": "https://github.com/apache/helix/pull/899#discussion_r393855226", "bodyText": "I am not so particular about the order of Helix and Zk. If you think HelixZk is more appropriate, we could do that. But note that there are existing APIs with the \"ZkHelix\" prefixes: ZkBaseDataAccessor, ZkHelixDataAccessor, ZkHeilxManager, etc.", "author": "narendly", "createdAt": "2020-03-17T17:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNzMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2MzA3Nw==", "url": "https://github.com/apache/helix/pull/899#discussion_r393863077", "bodyText": "Discussed with @jiajunwang offline. We are keeping ZkHelix as is.", "author": "narendly", "createdAt": "2020-03-17T17:50:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNzMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NDQ5Mw==", "url": "https://github.com/apache/helix/pull/899#discussion_r393844493", "bodyText": "The following logic looks generic enough to put in GenericZkHelixApiBuilder. And this ZkBaseDataAccessor constructor can directly get a zkclient instance as the input.", "author": "jiajunwang", "createdAt": "2020-03-17T17:21:34Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -142,22 +142,22 @@ public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n   }\n \n   private ZkBaseDataAccessor(Builder<T> builder) {\n-    switch (builder.realmMode) {\n+    switch (builder.getRealmMode()) {", "originalCommit": "988e67768cc04ca8853cb76815aa2f926f97072f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NjQ4MA==", "url": "https://github.com/apache/helix/pull/899#discussion_r393846480", "bodyText": "Following the previous comment, I can see this zkClientType is an exception which is not common for all the GenericZkHelixApiBuilder child classes' logic. In this case, we can let the ZkBaseDataAccessor builder extends my proposed GenericZkHelixApiBuilder method which creates a ZkClient, and in this extended method, we read and apply this _zkClientType.", "author": "jiajunwang", "createdAt": "2020-03-17T17:24:51Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -142,22 +142,22 @@ public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n   }\n \n   private ZkBaseDataAccessor(Builder<T> builder) {\n-    switch (builder.realmMode) {\n+    switch (builder.getRealmMode()) {\n       case MULTI_REALM:\n         try {\n-          if (builder.zkClientType == ZkClientType.DEDICATED) {\n+          if (builder._zkClientType == ZkClientType.DEDICATED) {", "originalCommit": "988e67768cc04ca8853cb76815aa2f926f97072f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NzMxNw==", "url": "https://github.com/apache/helix/pull/899#discussion_r393847317", "bodyText": "Or, if there are more than one builders require zkClientType, we can have another generic builder which includes the zkClientType logic and let it to extend GenericZkHelixApiBuilder.", "author": "jiajunwang", "createdAt": "2020-03-17T17:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NjQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4MTI4Ng==", "url": "https://github.com/apache/helix/pull/899#discussion_r393881286", "bodyText": "So as for the logic that creates which ZkClient to use -I've actually considered an option to include it in the builder, but I think since this is a construction logic for the API, I've explicitly decided to leave it in the constructor\nMy philosophy is that construction logic (\"business logic\" for the data accessors) should be left in the constructor, and builder should only set the parameters and validate.\nBut I see some duplicate logic in ZkBaseDataAccessor and ZkCacheBaseDataAccessor -\nSo I can actually abstract that logic out into ZkBaseDataAccessor.createZkClient(), and make it a static method that can be used in both accessors. That way, 1) we still keep the construction logic in the accessors 2) Builders have a clean separation and only contain parameter setters and validation logic, and 3) we reduce code duplication.", "author": "narendly", "createdAt": "2020-03-17T18:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NjQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4MjA5MQ==", "url": "https://github.com/apache/helix/pull/899#discussion_r393882091", "bodyText": "Just to summarize:\nThis is the construction logic that only pertains to ZkBaseDataAccessor/ZkCacheBaseDataAccessor\nYour feedback was that this is duplicated in both ZkBaseDataAccessor and ZkCacheBaseDataAccessor\nI agree with your observation\nNow we have a few options in terms of how to refactor this logic\nMake it a reusable method that pertains to data accessors\n\nPut this in the Builder\n\nHere, between 1 and 2, my preference is 1, because this seems like business logic that belongs to the data accessor, not the builder.\nWhat do you think?", "author": "narendly", "createdAt": "2020-03-17T18:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NjQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3MDgyMg==", "url": "https://github.com/apache/helix/pull/899#discussion_r394670822", "bodyText": "I would prefer 2. Once a class is designed with a builder, the builder should contain most of the complicated building logic. IMHO, including which client to use. Then the real private constructor of the Accessor just takes whatever client it is given. Although both ways avoid duplicate code, method 2 encapsulates the logic more closely.\nActually, it is an option that you put this logic into the generic builder. For the other accessors, this type can be fixed in the implemented builder class.", "author": "jiajunwang", "createdAt": "2020-03-18T22:16:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NjQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc5MDI2Mg==", "url": "https://github.com/apache/helix/pull/899#discussion_r394790262", "bodyText": "I value your opinion and it also makes sense. For now, I can move all construction logic to the builders. I have updated the PR accordingly.", "author": "narendly", "createdAt": "2020-03-19T04:53:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NjQ4MA=="}], "type": "inlineReview"}, {"oid": "9a35b2cec65d18f1b5442a4210b3264e3d5c4b64", "url": "https://github.com/apache/helix/commit/9a35b2cec65d18f1b5442a4210b3264e3d5c4b64", "message": "asdfsfa", "committedDate": "2020-03-17T17:49:42Z", "type": "commit"}, {"oid": "f0447fb2dde8c60566c2ea32c948728e0dfce5bf", "url": "https://github.com/apache/helix/commit/f0447fb2dde8c60566c2ea32c948728e0dfce5bf", "message": "Refactor Builders into GenericZkHelixApiBuilder", "committedDate": "2020-03-17T17:49:42Z", "type": "commit"}, {"oid": "63dce2cf5d177664f2f4533fd33c8db5357faecd", "url": "https://github.com/apache/helix/commit/63dce2cf5d177664f2f4533fd33c8db5357faecd", "message": "fix stackoverflow", "committedDate": "2020-03-17T17:49:42Z", "type": "commit"}, {"oid": "63dce2cf5d177664f2f4533fd33c8db5357faecd", "url": "https://github.com/apache/helix/commit/63dce2cf5d177664f2f4533fd33c8db5357faecd", "message": "fix stackoverflow", "committedDate": "2020-03-17T17:49:42Z", "type": "forcePushed"}, {"oid": "bb764b1e6403d0c983c6882d0488e82a84c5df64", "url": "https://github.com/apache/helix/commit/bb764b1e6403d0c983c6882d0488e82a84c5df64", "message": "Remove multizkenvironment", "committedDate": "2020-03-17T17:55:57Z", "type": "commit"}, {"oid": "44fb4ca71771eeff1776eb5fd4244af089c20a47", "url": "https://github.com/apache/helix/commit/44fb4ca71771eeff1776eb5fd4244af089c20a47", "message": "Refactor further", "committedDate": "2020-03-17T19:32:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2OTA3MQ==", "url": "https://github.com/apache/helix/pull/899#discussion_r394669071", "bodyText": "Isn't this switch block identical to the ones in ZKHelixAdmin and ClusterSetup? IMO, let the builder have a method for creating a ZkClient is simpler and easier to maintain.", "author": "jiajunwang", "createdAt": "2020-03-18T22:12:20Z", "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -87,11 +88,11 @@\n    * @param builder\n    */\n   private ConfigAccessor(Builder builder) {\n-    switch (builder._realmMode) {\n+    switch (builder.getRealmMode()) {", "originalCommit": "44fb4ca71771eeff1776eb5fd4244af089c20a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc5MDQwMQ==", "url": "https://github.com/apache/helix/pull/899#discussion_r394790401", "bodyText": "Moved all construction logic to the abstract builder, and refactored the code out of these Java API classes.", "author": "narendly", "createdAt": "2020-03-19T04:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2OTA3MQ=="}], "type": "inlineReview"}, {"oid": "836c112b3e9a7b49709ec5c3a72afdf18d46de71", "url": "https://github.com/apache/helix/commit/836c112b3e9a7b49709ec5c3a72afdf18d46de71", "message": "move construction logic to builder", "committedDate": "2020-03-19T04:48:13Z", "type": "commit"}, {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "url": "https://github.com/apache/helix/commit/5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "message": "asdf", "committedDate": "2020-03-19T04:52:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MjYyMw==", "url": "https://github.com/apache/helix/pull/899#discussion_r395342623", "bodyText": "Is it intended to be done with a different name in the parent class? Note in the child builder it is called createRealmAwareZkClientFromBuilder().\nOne of the reasons that I want to use the same name is avoiding the caller to be confused when they have more than one method to call when they try to get a ZkClient instance from the builder.", "author": "jiajunwang", "createdAt": "2020-03-19T21:57:50Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericZkHelixApiBuilder.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+\n+\n+/**\n+ * GenericZkHelixApiBuilder serves as the abstract parent class for Builders used by Helix Java APIs\n+ * that create ZK connections. By having this class, we reduce duplicate code as much as possible.\n+ * @param <B>\n+ */\n+public abstract class GenericZkHelixApiBuilder<B extends GenericZkHelixApiBuilder<B>> {\n+  protected String _zkAddress;\n+  protected RealmAwareZkClient.RealmMode _realmMode;\n+  protected RealmAwareZkClient.RealmAwareZkConnectionConfig _realmAwareZkConnectionConfig;\n+  protected RealmAwareZkClient.RealmAwareZkClientConfig _realmAwareZkClientConfig;\n+\n+  public B setZkAddress(String zkAddress) {\n+    _zkAddress = zkAddress;\n+    return self();\n+  }\n+\n+  public B setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+    _realmMode = realmMode;\n+    return self();\n+  }\n+\n+  public B setRealmAwareZkConnectionConfig(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+    _realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+    return self();\n+  }\n+\n+  public RealmAwareZkClient.RealmAwareZkConnectionConfig getRealmAwareZkConnectionConfig() {\n+    return _realmAwareZkConnectionConfig;\n+  }\n+\n+  public B setRealmAwareZkClientConfig(\n+      RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+    _realmAwareZkClientConfig = realmAwareZkClientConfig;\n+    return self();\n+  }\n+\n+  /**\n+   * Validates the given Builder parameters using a generic validation logic.\n+   */\n+  protected void validate() {\n+    // Resolve RealmMode based on whether ZK address has been set\n+    boolean isZkAddressSet = _zkAddress != null && !_zkAddress.isEmpty();\n+    if (_realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+      throw new HelixException(\"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+    }\n+    if (_realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM && isZkAddressSet) {\n+      throw new HelixException(\"ZkAddress cannot be set on multi-realm mode!\");\n+    }\n+    if (_realmMode == null) {\n+      _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+          : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+    }\n+\n+    initializeConfigsIfNull();\n+  }\n+\n+  /**\n+   * Initializes Realm-aware ZkConnection and ZkClient configs if they haven't been set.\n+   */\n+  protected void initializeConfigsIfNull() {\n+    // Resolve all default values\n+    if (_realmAwareZkConnectionConfig == null) {\n+      _realmAwareZkConnectionConfig =\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+    }\n+\n+    // For Helix APIs, ZNRecord should be the default data model\n+    if (_realmAwareZkClientConfig == null) {\n+      _realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig()\n+          .setZkSerializer(new ZNRecordSerializer());\n+    }\n+  }\n+\n+  /**\n+   * Creates a RealmAwareZkClient based on the parameters set.\n+   * To be used in Helix ZK APIs' constructors: ConfigAccessor, ClusterSetup, ZKHelixAdmin\n+   * @return\n+   */\n+  public RealmAwareZkClient createZkClientFromBuilder() {", "originalCommit": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1MTA3Ng==", "url": "https://github.com/apache/helix/pull/899#discussion_r395351076", "bodyText": "I think just call it createZkClient() or createRealmAwareZkClient would be good enough.", "author": "jiajunwang", "createdAt": "2020-03-19T22:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MjYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzY5NQ==", "url": "https://github.com/apache/helix/pull/899#discussion_r395343695", "bodyText": "I would prefer to leverage builder here as well. So we can merge the logic of buildRealmAwareZkClientWithDefaultConfigs into the builder.\nNot sure if there are any conflicts. If there are, I don't have a strong preference that we have to do this change.", "author": "jiajunwang", "createdAt": "2020-03-19T22:00:22Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -260,10 +217,9 @@ public ZkBaseDataAccessor(String zkAddress, ZkClientType zkClientType) {\n   @Deprecated\n   public ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer,\n       ZkClientType zkClientType) {\n-    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n-        new RealmAwareZkClient.RealmAwareZkClientConfig().setZkSerializer(zkSerializer);\n-\n-    _zkClient = buildRealmAwareZkClient(clientConfig, zkAddress, zkClientType);\n+    _zkClient = buildRealmAwareZkClientWithDefaultConfigs(", "originalCommit": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5MTkyMg==", "url": "https://github.com/apache/helix/pull/899#discussion_r395391922", "bodyText": "Discussed offline. This buildRealmAwareZkClientWithDefaultConfigs logic actually belongs to an existing, old construction logic, so this shouldn't go into the Builder.", "author": "narendly", "createdAt": "2020-03-20T00:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDAwMA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395344000", "bodyText": "Not sure if we can merge it to the builder logic? If not possible for now, let's have a TODO here.", "author": "jiajunwang", "createdAt": "2020-03-19T22:01:03Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1390,65 +1311,23 @@ public Builder() {\n       validate();\n       return new ZkBaseDataAccessor<>(this);\n     }\n-\n-    /*\n-     * Validates the given parameters before building an instance of ZkBaseDataAccessor.\n-     */\n-    private void validate() {\n-      // Resolve RealmMode based on other parameters\n-      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n-      boolean isZkClientTypeSet = zkClientType != null;\n-\n-      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n-      if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n-        throw new HelixException(\"ZkClientType cannot be set on multi-realm mode!\");\n-      }\n-      // If ZkClientType is not set and realmMode is single-realm, default to SHARED\n-      if (!isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM) {\n-        zkClientType = ZkClientType.SHARED;\n-      }\n-\n-      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n-        throw new HelixException(\"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n-      }\n-\n-      if (realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM && isZkAddressSet) {\n-        throw new HelixException(\"ZkAddress cannot be set on multi-realm mode!\");\n-      }\n-\n-      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM\n-          && zkClientType == ZkClientType.FEDERATED) {\n-        throw new HelixException(\"FederatedZkClient cannot be set on single-realm mode!\");\n-      }\n-\n-      if (realmMode == null) {\n-        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n-            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n-      }\n-\n-      // Resolve RealmAwareZkClientConfig\n-      if (realmAwareZkClientConfig == null) {\n-        realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig()\n-            .setZkSerializer(new ZNRecordSerializer());\n-      }\n-\n-      // Resolve RealmAwareZkConnectionConfig\n-      if (realmAwareZkConnectionConfig == null) {\n-        // If not set, create a default one\n-        realmAwareZkConnectionConfig =\n-            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n-      }\n-    }\n   }\n \n-  /*\n-   * This is used for constructors that do not take a Builder in as a parameter because of\n-   * keeping backward-compatibility.\n+  /**\n+   * This method is used for constructors that are not based on the Builder for\n+   * backward-compatibility.\n+   * It checks if there is a System Property config set for Multi-ZK mode and determines if a\n+   * FederatedZkClient should be created.\n+   * @param clientConfig default RealmAwareZkClientConfig with ZK serializer set\n+   * @param zkAddress\n+   * @param zkClientType\n+   * @return\n    */\n-  private RealmAwareZkClient buildRealmAwareZkClient(\n+  static RealmAwareZkClient buildRealmAwareZkClientWithDefaultConfigs(", "originalCommit": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5MjEzNg==", "url": "https://github.com/apache/helix/pull/899#discussion_r395392136", "bodyText": "I deprecated this method. this is old construction logic, so let's not try to mix it with our new construction logic in the builder :)", "author": "narendly", "createdAt": "2020-03-20T00:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1MjYwNg==", "url": "https://github.com/apache/helix/pull/899#discussion_r395452606", "bodyText": "There is no need to deprecate, we can directly remove it. I checked, it is not in the master branch yet.\nSame for the other usages. I think we should just remove it instead of introducing a new but deprecated method to the master branch.\nIf you are worried about the backward compatibility, then we can just leave the very old code that creates either DEDICATED or SHARED client. Those constructors are deprecated anyway.\nWe don't need to change the logic of the deprecated methods to return RealmAware ZkClient. As you said, this will just mix the new logic with the old/deprecated ones.", "author": "jiajunwang", "createdAt": "2020-03-20T06:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjM3MA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395806370", "bodyText": "Discussed offline.\nAs for deprecating the new little method stub, I will remove the deprecated annotation, but i think we need to look at it as an improvement we are making to the existing code because this is not newly added logic. we have refactored it to cut down on duplicate code. The method stub is created solely for that purpose.", "author": "narendly", "createdAt": "2020-03-20T18:02:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDE0Mw==", "url": "https://github.com/apache/helix/pull/899#discussion_r395344143", "bodyText": "Same here.", "author": "jiajunwang", "createdAt": "2020-03-19T22:01:23Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -126,41 +117,9 @@ public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String\n   public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String chrootPath,\n       List<String> wtCachePaths, List<String> zkCachePaths, String monitorType, String monitorkey,\n       ZkBaseDataAccessor.ZkClientType zkClientType) {\n-\n-    // If the multi ZK config is enabled, use multi-realm mode with FederatedZkClient\n-    if (Boolean.parseBoolean(System.getProperty(SystemPropertyKeys.MULTI_ZK_ENABLED))) {\n-      try {\n-        RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder connectionConfigBuilder =\n-            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder();\n-        RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n-            new RealmAwareZkClient.RealmAwareZkClientConfig();\n-        clientConfig.setZkSerializer(serializer).setMonitorType(monitorType)\n-            .setMonitorKey(monitorkey);\n-        // Use a federated zk client\n-        _zkClient = new FederatedZkClient(connectionConfigBuilder.build(), clientConfig);\n-      } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n-        // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be\n-        // found\n-        throw new HelixException(\"Failed to create ZkCacheBaseDataAccessor!\", e);\n-      }\n-    } else {\n-      HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-      clientConfig.setZkSerializer(serializer).setMonitorType(monitorType)\n-          .setMonitorKey(monitorkey);\n-      switch (zkClientType) {\n-        case DEDICATED:\n-          _zkClient = DedicatedZkClientFactory.getInstance()\n-              .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n-                  new HelixZkClient.ZkClientConfig().setZkSerializer(serializer));\n-          break;\n-        case SHARED:\n-        default:\n-          _zkClient = SharedZkClientFactory.getInstance()\n-              .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-      }\n-      _zkClient.waitUntilConnected(HelixZkClient.DEFAULT_CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n-    }\n-\n+    _zkClient = ZkBaseDataAccessor.buildRealmAwareZkClientWithDefaultConfigs(", "originalCommit": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NjE1OQ==", "url": "https://github.com/apache/helix/pull/899#discussion_r395346159", "bodyText": "The reason we call the path as \"shardingkey\" is to make it more generic. If we assign it to the clusterName, it means we set a strong assumption here that for Helix, the shardingkey == clusterName. Although this assumption is valid, the code is confusing.\nSo shall we add an additional method builder.getClusterName() to avoid confusion? The internal logic is the same. Note that both builder classes are in Helix-core. So we should reduce exposing Realm concept if not necessary.", "author": "jiajunwang", "createdAt": "2020-03-19T22:06:32Z", "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java", "diffHunk": "@@ -144,23 +145,11 @@ public ZkHelixClusterVerifier(String zkAddr, String clusterName) {\n     _keyBuilder = _accessor.keyBuilder();\n   }\n \n-  protected ZkHelixClusterVerifier(Builder builder) {\n-    if (Boolean.parseBoolean(System.getProperty(SystemPropertyKeys.MULTI_ZK_ENABLED))) {\n-      try {\n-        // First, try to create a RealmAwareZkClient that's a DedicatedZkClient\n-        _zkClient = DedicatedZkClientFactory.getInstance()\n-            .buildZkClient(builder._realmAwareZkConnectionConfig,\n-                builder._realmAwareZkClientConfig);\n-      } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n-        throw new HelixException(\"ZkHelixClusterVerifier: failed to create ZkClient!\", e);\n-      }\n-    } else {\n-      _zkClient = DedicatedZkClientFactory.getInstance()\n-          .buildZkClient(new HelixZkClient.ZkConnectionConfig(builder._zkAddress));\n-    }\n-    _usesExternalZkClient = false;\n+  protected <B extends Builder<B>> ZkHelixClusterVerifier(Builder<B> builder) {\n+    _zkClient = builder.createZkClientFromBuilderForVerifier();\n     _zkClient.setZkSerializer(new ZNRecordSerializer());\n-    _clusterName = builder._realmAwareZkConnectionConfig.getZkRealmShardingKey();\n+    _usesExternalZkClient = false;\n+    _clusterName = builder.getRealmAwareZkConnectionConfig().getZkRealmShardingKey();", "originalCommit": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5MjM4MA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395392380", "bodyText": "This is actually also on my mind. Thanks for pointing this out - we are on the same page. I will add getClusterName() to avoid confusion.", "author": "narendly", "createdAt": "2020-03-20T00:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NjE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NjUzOA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395346538", "bodyText": "More java doc to specify what's the difference between types, please.", "author": "jiajunwang", "createdAt": "2020-03-19T22:07:25Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ZkClientType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package org.apache.helix.zookeeper.api.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+public enum ZkClientType {", "originalCommit": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5Mzc3NA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395393774", "bodyText": "Added", "author": "narendly", "createdAt": "2020-03-20T00:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NjUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NzM1OA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395347358", "bodyText": "nit, return setZkClientType(Enum.valueOf(ZkClientType.class, zkClientType.name()));", "author": "jiajunwang", "createdAt": "2020-03-19T22:09:27Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.api.client.ZkClientType;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+\n+\n+/**\n+ * GenericBaseDataAccessorBuilder serves as the abstract parent class for Builders used by\n+ * BaseDataAccessor APIs that create ZK connections. By having this class, we promote code-reuse.\n+ * @param <B>\n+ */\n+public class GenericBaseDataAccessorBuilder<B extends GenericBaseDataAccessorBuilder<B>> extends GenericZkHelixApiBuilder<B> {\n+  /** ZK-based BaseDataAccessor-specific parameter **/\n+  private ZkClientType _zkClientType;\n+\n+  /**\n+   * Sets the ZkClientType.\n+   * If this is set to either DEDICATED or SHARED, this accessor will be created on\n+   * single-realm mode.\n+   * If this is set to FEDERATED, multi-realm mode will be used.\n+   * @param zkClientType\n+   * @return\n+   */\n+  public B setZkClientType(ZkBaseDataAccessor.ZkClientType zkClientType) {\n+    _zkClientType = Enum.valueOf(ZkClientType.class, zkClientType.name());\n+    return self();", "originalCommit": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0ODE0OQ==", "url": "https://github.com/apache/helix/pull/899#discussion_r395348149", "bodyText": "Shall we include the target class as a template T in addition to B here? So you can define the abstract build() method to make this class more complete.", "author": "jiajunwang", "createdAt": "2020-03-19T22:11:31Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericZkHelixApiBuilder.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+\n+\n+/**\n+ * GenericZkHelixApiBuilder serves as the abstract parent class for Builders used by Helix Java APIs\n+ * that create ZK connections. By having this class, we reduce duplicate code as much as possible.\n+ * @param <B>\n+ */\n+public abstract class GenericZkHelixApiBuilder<B extends GenericZkHelixApiBuilder<B>> {", "originalCommit": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5MTczNg==", "url": "https://github.com/apache/helix/pull/899#discussion_r395391736", "bodyText": "Discussed offline. Doing this has no clear benefit because the return types (Helix APIs) do not have a hierarchical relationship or inheritance relationship. It also doesn't reduce duplicate code. We will keep things as is.", "author": "narendly", "createdAt": "2020-03-20T00:33:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0ODE0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1MDcwMw==", "url": "https://github.com/apache/helix/pull/899#discussion_r395450703", "bodyText": "Just to put some details of what we discussed, the only benefit of adding the build() method to the parent builder class is more complete interface design. But as Hunter mentioned, it is optional. I don't have a strong preference on this change, we will have the build() method for all the non-abstract builders anyway.", "author": "jiajunwang", "createdAt": "2020-03-20T06:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0ODE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0ODM0Nw==", "url": "https://github.com/apache/helix/pull/899#discussion_r395348347", "bodyText": "This looks nice : )", "author": "jiajunwang", "createdAt": "2020-03-19T22:12:03Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericZkHelixApiBuilder.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+\n+\n+/**\n+ * GenericZkHelixApiBuilder serves as the abstract parent class for Builders used by Helix Java APIs\n+ * that create ZK connections. By having this class, we reduce duplicate code as much as possible.\n+ * @param <B>\n+ */\n+public abstract class GenericZkHelixApiBuilder<B extends GenericZkHelixApiBuilder<B>> {\n+  protected String _zkAddress;\n+  protected RealmAwareZkClient.RealmMode _realmMode;\n+  protected RealmAwareZkClient.RealmAwareZkConnectionConfig _realmAwareZkConnectionConfig;\n+  protected RealmAwareZkClient.RealmAwareZkClientConfig _realmAwareZkClientConfig;\n+\n+  public B setZkAddress(String zkAddress) {\n+    _zkAddress = zkAddress;\n+    return self();\n+  }\n+\n+  public B setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+    _realmMode = realmMode;\n+    return self();\n+  }\n+\n+  public B setRealmAwareZkConnectionConfig(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+    _realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+    return self();\n+  }\n+\n+  public RealmAwareZkClient.RealmAwareZkConnectionConfig getRealmAwareZkConnectionConfig() {\n+    return _realmAwareZkConnectionConfig;\n+  }\n+\n+  public B setRealmAwareZkClientConfig(\n+      RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+    _realmAwareZkClientConfig = realmAwareZkClientConfig;\n+    return self();\n+  }\n+\n+  /**\n+   * Validates the given Builder parameters using a generic validation logic.\n+   */\n+  protected void validate() {\n+    // Resolve RealmMode based on whether ZK address has been set\n+    boolean isZkAddressSet = _zkAddress != null && !_zkAddress.isEmpty();\n+    if (_realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+      throw new HelixException(\"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+    }\n+    if (_realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM && isZkAddressSet) {\n+      throw new HelixException(\"ZkAddress cannot be set on multi-realm mode!\");\n+    }\n+    if (_realmMode == null) {\n+      _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+          : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+    }\n+\n+    initializeConfigsIfNull();\n+  }\n+\n+  /**\n+   * Initializes Realm-aware ZkConnection and ZkClient configs if they haven't been set.\n+   */\n+  protected void initializeConfigsIfNull() {\n+    // Resolve all default values\n+    if (_realmAwareZkConnectionConfig == null) {\n+      _realmAwareZkConnectionConfig =\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+    }\n+\n+    // For Helix APIs, ZNRecord should be the default data model\n+    if (_realmAwareZkClientConfig == null) {\n+      _realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig()\n+          .setZkSerializer(new ZNRecordSerializer());\n+    }\n+  }\n+\n+  /**\n+   * Creates a RealmAwareZkClient based on the parameters set.\n+   * To be used in Helix ZK APIs' constructors: ConfigAccessor, ClusterSetup, ZKHelixAdmin\n+   * @return\n+   */\n+  public RealmAwareZkClient createZkClientFromBuilder() {\n+    switch (_realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          return new FederatedZkClient(_realmAwareZkConnectionConfig,\n+              _realmAwareZkClientConfig.setZkSerializer(new ZNRecordSerializer()));\n+        } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n+          throw new HelixException(\"Failed to create FederatedZkClient!\", e);\n+        }\n+      case SINGLE_REALM:\n+        // Create a HelixZkClient: Use a SharedZkClient because ClusterSetup does not need to do\n+        // ephemeral operations\n+        return SharedZkClientFactory.getInstance()\n+            .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddress),\n+                _realmAwareZkClientConfig.createHelixZkClientConfig()\n+                    .setZkSerializer(new ZNRecordSerializer()));\n+      default:\n+        throw new HelixException(\"Invalid RealmMode given: \" + _realmMode);\n+    }\n+  }\n+\n+  /**\n+   * Returns an instance of a subclass-Builder in order to reduce duplicate code.\n+   * SuppressWarnings is used to rid of IDE warnings.\n+   * @return an instance of a subclass-Builder. E.g.) ConfigAccessor.Builder\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  final B self() {", "originalCommit": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1NTE0OA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395355148", "bodyText": "I tried to compare this solution with the other method, a private constructor accepts all parameters including the ZkClient.\nPros: less parameter.\nCons: you have to make createZkClient() method public.\nSince the constructor is private and easy to update, will the option B be better? Moreover, many classes have it's defined constructors so you don't need to define a new one.\nIn this way, the builder will be very clean. Basically, the only public methods are setXXX() and build(). All the other methods are not required to be public. What do you think?", "author": "jiajunwang", "createdAt": "2020-03-19T22:29:31Z", "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -87,26 +88,7 @@\n    * @param builder\n    */\n   private ConfigAccessor(Builder builder) {", "originalCommit": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM5MTI0NQ==", "url": "https://github.com/apache/helix/pull/899#discussion_r395391245", "bodyText": "In order to not expose createZkClient(), I'll make that have protected access and modify the constructors.", "author": "narendly", "createdAt": "2020-03-20T00:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1NTE0OA=="}], "type": "inlineReview"}, {"oid": "73a5d99f859af82b3f9afd2b9f3b8a251dd73cef", "url": "https://github.com/apache/helix/commit/73a5d99f859af82b3f9afd2b9f3b8a251dd73cef", "message": "fix", "committedDate": "2020-03-20T00:46:16Z", "type": "commit"}, {"oid": "4b465ba80457f7ba4d125a86d7432adcc3499cb4", "url": "https://github.com/apache/helix/commit/4b465ba80457f7ba4d125a86d7432adcc3499cb4", "message": "fdsa", "committedDate": "2020-03-20T00:49:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1MzUzMA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395453530", "bodyText": "This one shall be deprecated as well. And I would suggest keeping the very original behavior. Only return realmaware client through the new builder method.", "author": "jiajunwang", "createdAt": "2020-03-20T06:17:21Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -126,41 +117,9 @@ public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String\n   public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String chrootPath,", "originalCommit": "4b465ba80457f7ba4d125a86d7432adcc3499cb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczNDg4OA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395734888", "bodyText": "I will deprecate this but I do not agree with that we should revert the behavior.", "author": "narendly", "createdAt": "2020-03-20T16:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1MzUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzMzMw==", "url": "https://github.com/apache/helix/pull/899#discussion_r395807333", "bodyText": "This is already deprecated..", "author": "narendly", "createdAt": "2020-03-20T18:04:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1MzUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1NDIxNw==", "url": "https://github.com/apache/helix/pull/899#discussion_r395454217", "bodyText": "Why not override createZkClient() here?", "author": "jiajunwang", "createdAt": "2020-03-20T06:20:52Z", "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java", "diffHunk": "@@ -384,14 +373,26 @@ protected void validate() {\n                   + _zkAddress + \" RealmAwareZkConnectionConfig: \" + _realmAwareZkConnectionConfig);\n         }\n       }\n+      initializeConfigsIfNull();\n+    }\n \n-      // Resolve all default values\n-      if (_realmAwareZkConnectionConfig == null) {\n-        _realmAwareZkConnectionConfig =\n-            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n-      }\n-      if (_realmAwareZkClientConfig == null) {\n-        _realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig();\n+    /**\n+     * Creates a RealmAwareZkClient for ZkHelixClusterVerifiers.\n+     * Note that DedicatedZkClient is used whether it's multi-realm or single-realm.\n+     * @return\n+     */\n+    private RealmAwareZkClient createZkClientFromBuilderForVerifier() {", "originalCommit": "4b465ba80457f7ba4d125a86d7432adcc3499cb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczNDIwNw==", "url": "https://github.com/apache/helix/pull/899#discussion_r395734207", "bodyText": "We can do that.", "author": "narendly", "createdAt": "2020-03-20T15:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1NDIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwOTM2Mw==", "url": "https://github.com/apache/helix/pull/899#discussion_r395809363", "bodyText": "Turns out we don't need to override that here. This createZkClient() is private and has different logic for verifiers. Just to keep it clear that this logic is different from the regular createZkClient, I will keep the method name as is. Again, I'd like to emphasize that there's no extra public method so we are not adding anything to the interface.", "author": "narendly", "createdAt": "2020-03-20T18:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1NDIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjgwMA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395812800", "bodyText": "This is not quite about the public interface. The ZkClient build behavior of this builder should be this logic, right? So we should override the method here. Unless we do have a use case of this specific builder that requires to call the parent class createZkClient(). Otherwise, it just causes confusing IMO.\nWhat is your concern not doing this?", "author": "jiajunwang", "createdAt": "2020-03-20T18:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1NDIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0Njc0NA==", "url": "https://github.com/apache/helix/pull/899#discussion_r395846744", "bodyText": "@jiajunwang Because this would cause the constructor to take in a list of parameters defined by its parent builder's createZkClient(). I'd argue that it's not confusing because the method name makes is 100% clear - there really is no ambiguity.\nFor ZkHelixClusterVerifier and its implementations, they, by definition, only operate on single realm mode on a dedicated zk client. As such, that degree of customization that would be required in the parent builder's createZkClient() is not necessary.\nIs it a good idea to have unnecessary parameters in a method just for the sake of overriding a parent method, especially when it could be avoided?\nAgain, this is a stylistic choice, and for the sake of moving this forward, I will make that change to make the method override its parent's method - that way we would be on the same page.", "author": "narendly", "createdAt": "2020-03-20T19:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1NDIxNw=="}], "type": "inlineReview"}, {"oid": "063089b581d1bb47bcc80e03a7d3cb8ee0ed8736", "url": "https://github.com/apache/helix/commit/063089b581d1bb47bcc80e03a7d3cb8ee0ed8736", "message": "adsf", "committedDate": "2020-03-20T18:23:46Z", "type": "commit"}, {"oid": "cee717658e48018e4f69e9e51035b2711619d7a7", "url": "https://github.com/apache/helix/commit/cee717658e48018e4f69e9e51035b2711619d7a7", "message": "f", "committedDate": "2020-03-20T20:34:55Z", "type": "commit"}, {"oid": "a85dfece4ca8cf64deb77fb7ce634517de45f62c", "url": "https://github.com/apache/helix/commit/a85dfece4ca8cf64deb77fb7ce634517de45f62c", "message": "sadf", "committedDate": "2020-03-21T04:25:08Z", "type": "commit"}]}