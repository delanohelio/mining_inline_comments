{"pr_number": 1035, "pr_title": "Fix leaking Zk path watch and Callbackhandler issue", "pr_createdAt": "2020-05-28T02:55:54Z", "pr_url": "https://github.com/apache/helix/pull/1035", "timeline": [{"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "url": "https://github.com/apache/helix/commit/e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "message": "Fix leaking Zk path watch and Callbackhandler issue\n\nShort term fix #1034. Get rid of dangling CallbackHandlers and its\nrelated current state parent path in Zookeeper. Get rid of leaking\nof current state znode path due to async nature of deletion of\ncurrent state znode path to installatio of watcher in various\nthread in Helix.", "committedDate": "2020-05-28T02:23:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3ODkxOQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431578919", "bodyText": "be careful here since this changes not only the subscribe but also the current behavior, i,e, it won't handle the event at all.", "author": "lei-xia", "createdAt": "2020-05-28T04:46:59Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -752,6 +756,10 @@ public void handleChildChange(String parentPath, List<String> currentChilds) {\n           changeContext.setType(NotificationContext.Type.CALLBACK);\n           changeContext.setPathChanged(parentPath);\n           changeContext.setChangeType(_changeType);\n+          if (!isReady()) {\n+            // avoid leaking CallbackHandler\n+            return;\n+          }", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwMjI5Mw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431602293", "bodyText": "This I thought about it carefully before. This is exactly what we want, no handling the event in this case.\nFirst, we can reason it this way. \"no ready\" is either the callbackhandler is never initialized, or finalized. (Confirmed by examining the code setting isReady to false). In both cases, the callbackhandler should meet the invariant that they don't subscribe to changes from Zookeeper, they don't put them onto ZkClient's data/child listener lists. Thus, they don't handle event and invoke further callback in the callbackhandler. In fact, they can be trigger-ed only in the fireAllEvent's lambda. (Long term, we should rethink about fireAllEvent.)\nSecond, that is what previous developer intended to do also. See the following code, the previous developer also skips all the rest processing.\npublic void enqueueTask(NotificationContext changeContext) throws Exception {\n    // async mode only applicable to CALLBACK from ZK, During INIT and FINALIZE invoke the\n    // callback's immediately.\n    if (_batchModeEnabled && changeContext.getType() == NotificationContext.Type.CALLBACK) {\n      logger.debug(\"Enqueuing callback\");\n      if (!isReady()) {\n        logger.info(\"CallbackHandler is not ready, ignore change callback from path: \" + _path\n            + \", for listener: \" + _listener);\n      } else {\n        synchronized (this) {\n          if (_batchCallbackProcessor != null) {\n            _batchCallbackProcessor.queueEvent(changeContext.getType(), changeContext);\n          } else {\n            throw new HelixException(\n                \"Failed to process callback in batch mode. Batch Callback Processor does not exist.\");\n          }\n        }\n      }\n    } else {\n      invoke(changeContext);\n    }\nOf course, previous batchProcessor or CallbackHandler-AsycSubscribe singleton have a deadly drawback. They violate the important invariant -- the code needs to install the watch before or at the same time when reading the current snapshot of data upon watch notification in order not to lose update.\nThis is the reason batchProcessor or CallbackHandler-AsycSubscribe singleton  lose update. And this is probably also the reason we added line 763 to do subscribeForChanges() synchronously.", "author": "kaisun2000", "createdAt": "2020-05-28T06:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3ODkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3OTI2Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431579266", "bodyText": "Can we add some java doc here to explain the parameters and the differences between two methods with same name?", "author": "lei-xia", "createdAt": "2020-05-28T04:48:24Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -71,10 +71,14 @@\n   // listener subscription\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  List<String> subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);\n+\n   void unsubscribeChildChanges(String path, IZkChildListener listener);\n \n   void subscribeDataChanges(String path, IZkDataListener listener);\n \n+  void subscribeDataChanges(String path, IZkDataListener listener, boolean skipWatchingNodeNotExist);", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDQwNg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432170406", "bodyText": "added.", "author": "kaisun2000", "createdAt": "2020-05-28T23:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3OTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3OTg4MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431579880", "bodyText": "Can we use a better name than getStat2?", "author": "lei-xia", "createdAt": "2020-05-28T04:51:05Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1074,6 +1101,34 @@ private Stat getStat(final String path, final boolean watch) {\n     }\n   }\n \n+  /*\n+   * Install watch if there is such node and return the stat\n+   * Don't install watch if there is no such node and return null\n+   *\n+   * Use ZooKeeper native api getData() as underlying method\n+   */\n+  private Stat getStat2(final String path) {", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5NDYyMg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431594622", "bodyText": "getStatNoInstallingWatchWhenNodeNotExists()? this seems to be too long.\nOr maybe getStatNoWatchNoNode()?\nAny better name?", "author": "kaisun2000", "createdAt": "2020-05-28T05:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3OTg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMDI5NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431620294", "bodyText": "You can avoid this awkwardly named method by modifying the exiting private getStat() method.\nJust add a parameter to indicate if it should do getData() or exists() internally. That will also help to reduce duplicate code.", "author": "jiajunwang", "createdAt": "2020-05-28T06:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3OTg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MDg3Mg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432180872", "bodyText": "changed.", "author": "kaisun2000", "createdAt": "2020-05-28T23:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3OTg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4MDUwNQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431580505", "bodyText": "Does this return empty list (instead of null) if the path exists, but no children?", "author": "lei-xia", "createdAt": "2020-05-28T04:53:39Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1858,24 +1923,47 @@ public Object call() throws Exception {\n     });\n   }\n \n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {\n+        Stat stat = new Stat();\n+        retryUntilConnected(() -> (((ZkConnection) getConnection()).getZookeeper().getData(path, true, stat)));\n+      } else {\n+        retryUntilConnected(() -> (((ZkConnection) getConnection()).getZookeeper().exists(path, true)));\n+      }\n+    } catch (ZkNoNodeException e) {\n+      // Do nothing, this is what we want as this is not going to leak watch in ZooKeeepr server.\n+      LOG.info(\"watchForData path not existing: \" + path);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n   /**\n    * Installs a child watch for the given path.\n    * @param path\n    * @return the current children of the path or null if the zk node with the given path doesn't\n    *         exist.\n    */\n   public List<String> watchForChilds(final String path) {\n+    return watchForChilds(path, false);\n+  }\n+\n+  private List<String> watchForChilds(final String path, boolean skipWatchingNodeNotExist) {\n     if (_zookeeperEventThread != null && Thread.currentThread() == _zookeeperEventThread) {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n     return retryUntilConnected(new Callable<List<String>>() {\n       @Override\n       public List<String> call() throws Exception {\n-        exists(path, true);\n+        if (!skipWatchingNodeNotExist) {\n+          exists(path, true);\n+        }\n         try {\n           return getChildren(path, true);", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MzI2OA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431593268", "bodyText": "That is right. Null mean the path does not exist. Empty mean no children underlying this path.", "author": "kaisun2000", "createdAt": "2020-05-28T05:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4MDUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4MDcyOA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431580728", "bodyText": "I think we did not discuss the performance impact here, now most of the time we are using getData() instead of exist(), which could increase read traffic.", "author": "lei-xia", "createdAt": "2020-05-28T04:54:45Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1858,24 +1923,47 @@ public Object call() throws Exception {\n     });\n   }\n \n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {\n+        Stat stat = new Stat();\n+        retryUntilConnected(() -> (((ZkConnection) getConnection()).getZookeeper().getData(path, true, stat)));", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MjkzNA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431592934", "bodyText": "You are right, we can discuss this a little bit more in a meeting. It would be ideal if Zookeeper has an exist() API that won't not install watch if the znode does not exist.", "author": "kaisun2000", "createdAt": "2020-05-28T05:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4MDcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODYwNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431608607", "bodyText": "This is mostly duplicate with ClusterControllerManager. I think we can create a parent class for both classes so as to avoid duplicate code.", "author": "jiajunwang", "createdAt": "2020-05-28T06:29:11Z", "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterSpectatorManager.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.apache.helix.integration.manager;\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.manager.zk.CallbackHandler;\n+import org.apache.helix.manager.zk.ZKHelixManager;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusterSpectatorManager extends ZKHelixManager implements Runnable, ZkTestManager {", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3Mjg1Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432172856", "bodyText": "Yes. We have similar class for 3 different role of Helix, controller, participant and spectator.\nLet me file another issue to track this consolidation work. This is out of scope of this diff though.\n#1036 is used to track this work.", "author": "kaisun2000", "createdAt": "2020-05-28T23:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMjU2MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432212561", "bodyText": "I think merging spectator and controller managers is simple work. Better than the current change.\nAnd if you prefer to separate the work, then I would prefer to finish that change first. Otherwise, this class is purely thrown away work.", "author": "jiajunwang", "createdAt": "2020-05-29T01:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MTI1NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432271254", "bodyText": "This is fine. We can add #1036 fix earlier.\nLet us first focus on this short term fix as we have production issue at this time.", "author": "kaisun2000", "createdAt": "2020-05-29T05:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMjkwMg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431622902", "bodyText": "I don't think we can switch this order here. Immediately after the watcher is installed, the event might come. If it happens before _dataListener put is done, then we miss that event.", "author": "jiajunwang", "createdAt": "2020-05-28T07:03:42Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -257,12 +274,22 @@ public void subscribeDataChanges(String path, IZkDataListener listener) {\n         }\n       }\n     }\n-    watchForData(path);\n+", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5MDczNQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431690735", "bodyText": "Agreed. Maybe we could do this: add listeners first. If watch fails, we remove listeners?", "author": "huizhilu", "createdAt": "2020-05-28T09:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMjkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTcyNA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432075724", "bodyText": "@jiajunwang , this is a very good point.\nThe how about what @pkuwm suggested, add listener first, if install watch fails, remove this listener?", "author": "kaisun2000", "createdAt": "2020-05-28T19:41:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMjkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4ODEzMg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432188132", "bodyText": "adopt the approach proposed by @pkuwm.", "author": "kaisun2000", "createdAt": "2020-05-29T00:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMjkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMzkyMg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431623922", "bodyText": "code style-wise, we should implement the original watchForData method using this new one to avoid duplicate logic.", "author": "jiajunwang", "createdAt": "2020-05-28T07:05:51Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1858,24 +1923,47 @@ public Object call() throws Exception {\n     });\n   }\n \n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4ODI4Mg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432188282", "bodyText": "original watchForData use new one now,", "author": "kaisun2000", "createdAt": "2020-05-29T00:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMzkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4MTU1Mg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431681552", "bodyText": "This is a public interface And HelixZkClient also extends it, do we need a default implementation for backward compatibility?", "author": "huizhilu", "createdAt": "2020-05-28T08:51:33Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -71,10 +71,14 @@\n   // listener subscription\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  List<String> subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MzQ0MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432173441", "bodyText": "Already add the implementation for all class implement this interface. We don't need to provide default implementation. I guess.", "author": "kaisun2000", "createdAt": "2020-05-28T23:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4MTU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5MjMyMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432192320", "bodyText": "I think we need a default API for this. In helix we have all implementation for this interface. But how about outside implementation? This is for reference I did before. I think we should do the same thing.\n  /*\n   * This is for backwards compatibility.\n   *\n   * TODO: remove below default implementation when getting rid of I0Itec in the new zk client.\n   */\n  default void subscribeStateChanges(final IZkStateListener listener) {\n    subscribeStateChanges(new I0ItecIZkStateListenerImpl(listener));\n  }\n\n  /*\n   * This is for backwards compatibility.\n   *\n   * TODO: remove below default implementation when getting rid of I0Itec in the new zk client.\n   */\n  default void unsubscribeStateChanges(IZkStateListener listener) {\n    unsubscribeStateChanges(new I0ItecIZkStateListenerImpl(listener));\n  }", "author": "huizhilu", "createdAt": "2020-05-29T00:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4MTU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4NjA1MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431686050", "bodyText": "No need to get stat? Passing null is enough.", "author": "huizhilu", "createdAt": "2020-05-28T08:58:58Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1858,24 +1923,47 @@ public Object call() throws Exception {\n     });\n   }\n \n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {\n+        Stat stat = new Stat();", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3NDM5OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432174399", "bodyText": "getData will return stat too.\nretryUntilConnected(() -> (((ZkConnection) getConnection()).getZookeeper().getData(path, true, stat)));\nHere, we can't pass null to getData(). It would throw exception when getData try to fill data into stat.", "author": "kaisun2000", "createdAt": "2020-05-28T23:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4NjA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5MTIyMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432191220", "bodyText": "@kaisun2000 null is acceptable for the param stat. It would not throw exception. See here\n    public void testBadAuthThenSendOtherCommands() throws Exception {\n        ZooKeeper zk = createClient();     \n        try {        \n            zk.addAuthInfo(\"INVALID\", \"BAR\".getBytes());\n            zk.exists(\"/foobar\", false);             \n            zk.getData(\"/path1\", false, null);\n            Assert.fail(\"Should get auth state error\");", "author": "huizhilu", "createdAt": "2020-05-29T00:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4NjA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4Nzk4NQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r431687985", "bodyText": "Is this log necessary? May pollute the logs?", "author": "huizhilu", "createdAt": "2020-05-28T09:02:15Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1270,6 +1325,9 @@ public void deleteRecursively(String path) throws ZkClientException {\n   private void processDataOrChildChange(WatchedEvent event, long notificationTime) {\n     final String path = event.getPath();\n     final boolean pathExists = event.getType() != EventType.NodeDeleted;\n+    if (EventType.NodeDeleted == event.getType()) {\n+      LOG.info(\"event delelete:\" + event.getPath());", "originalCommit": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4ODY5Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432188696", "bodyText": "changed to debug", "author": "kaisun2000", "createdAt": "2020-05-29T00:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4Nzk4NQ=="}], "type": "inlineReview"}, {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "url": "https://github.com/apache/helix/commit/3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "message": "first round of revise. Mainly subscribeData/ChildChange would add listener\nfirst to zkclient, then add watch. if adding watch failed due to path not\nexisting in Zookeeper server, remove the listner from Zkclient.", "committedDate": "2020-05-29T00:09:41Z", "type": "commit"}, {"oid": "0e0c4c65e4c1d06590d2bbd41c06d69578c20ae2", "url": "https://github.com/apache/helix/commit/0e0c4c65e4c1d06590d2bbd41c06d69578c20ae2", "message": "added the reasoning about how to use getData() to install watch that simulates\nexist() call, but not leak watch in Zookeeper server in case path is deleted", "committedDate": "2020-05-29T01:16:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMDQ0OA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432210448", "bodyText": "This should be the first line in the else block right?", "author": "jiajunwang", "createdAt": "2020-05-29T01:33:46Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -752,6 +756,10 @@ public void handleChildChange(String parentPath, List<String> currentChilds) {\n           changeContext.setType(NotificationContext.Type.CALLBACK);\n           changeContext.setPathChanged(parentPath);\n           changeContext.setChangeType(_changeType);\n+          if (!isReady()) {", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDE2MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432270161", "bodyText": "This is a good point.", "author": "kaisun2000", "createdAt": "2020-05-29T05:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMDQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMjE1NQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432212155", "bodyText": "Why we need to handle INIT differently?", "author": "jiajunwang", "createdAt": "2020-05-29T01:41:27Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -539,7 +539,11 @@ private void subscribeChildChange(String path, NotificationContext.Type callback\n         logger.debug(_manager.getInstanceName() + \" subscribes child-change. path: \" + path\n             + \", listener: \" + _listener);\n       }\n-      _zkClient.subscribeChildChanges(path, this);\n+      if (callbackType == Type.INIT) {", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDcyNg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432270726", "bodyText": "See watchForchilds comment.\nIf skipWatchingNodeNotExist, we don't add watch to parent path. That is exactly what we want.\nWe can think it this way.\n1/ skipWatchingNodeNotExist true, if the parent path is not there. We will not install watch.\n2/ skipWatchingNodeNotExist false, namely original behavior, if the parent path is not there, we will install exist data watch.\nWe discussed this in the meeting.\nThe second case is actually needed for current state callbackhandler registration. LiveInstance change would cause current state callbackhandler to be added to ZkHelixManager. And at the time, it can often be the case the parent node of current state is not yet created. Note, this is the INIT case.\nLater CALLBACK case, we should expect the current state parent path be there. Otherwise, we should not register the watch to Zk server (or we will leak a path). That is why we need the first case.", "author": "kaisun2000", "createdAt": "2020-05-29T05:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMjE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwNTMxNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432705317", "bodyText": "// add a comment why we want to this", "author": "kaisun2000", "createdAt": "2020-05-29T19:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMjE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzYwOA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432213608", "bodyText": "The old methods can be deprecated since the new one completely covers the older ones.\nMoreover, for this interface, please specify the return value, since it might be confusing.\n\nif null, then the subscribe was skipped.\nif empty list, then the path has no children node.", "author": "jiajunwang", "createdAt": "2020-05-29T01:47:37Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,44 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist Ture means not installing any watch if path does not exist.\n+   */\n+  List<String> subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3Mjc1Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432272756", "bodyText": "Good point. Will add this to the comment. By the way, the return value semantic is still. the same. No change here. Add comment would make it explicit for people to understand.", "author": "kaisun2000", "createdAt": "2020-05-29T06:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzQ2MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432273461", "bodyText": "\"No change here.\" not exactly. The previous interface will always add watcher, right? But the new method may not. We need to think about how to return the result so the caller does not need to guess.", "author": "jiajunwang", "createdAt": "2020-05-29T06:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5Mjk5Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432292996", "bodyText": "Agree. We need to give user a signal of installation failure or not. In addition, return null, or empty list. I though about it before. In Java, without reference of boolean it can be a little bit complicated.\nLet us talk about it tomorrow.\nHere is a proposal:\nList<String> subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist, Boolean IsInstalled);\n\nisInstalled is an out parameter and would be set in the implementation to tell if installation successful or not.", "author": "kaisun2000", "createdAt": "2020-05-29T07:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwNjM3OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432706379", "bodyText": "new class of result { list, boolean installation type}", "author": "kaisun2000", "createdAt": "2020-05-29T19:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzcyNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432213727", "bodyText": "How does the caller know if the watcher has been done or not?", "author": "jiajunwang", "createdAt": "2020-05-29T01:48:04Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,44 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist Ture means not installing any watch if path does not exist.\n+   */\n+  List<String> subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);\n+\n   void unsubscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle data events of the path\n+   * Add the exists watch to Zookeeper server even if the path does not exists in zookeeper server\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   void subscribeDataChanges(String path, IZkDataListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle data events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist Ture means not installing any watch if path does not exist.\n+   */\n+  void subscribeDataChanges(String path, IZkDataListener listener, boolean skipWatchingNodeNotExist);", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzkyOQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432213929", "bodyText": "I feel this API need to be designed carefully.", "author": "jiajunwang", "createdAt": "2020-05-29T01:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NDU2NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432274564", "bodyText": "This is a good point. I also thought about it.\nWe can make this one\nboolean subscribeDataChanges(String path, IZkDataListener listener, boolean skipWatchingNodeNotExist);\nreturn boolean indicates whether the installation is successful or not.\nLet us sync about it offline.", "author": "kaisun2000", "createdAt": "2020-05-29T06:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjQ1MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432216451", "bodyText": "It would be easier to understand that we wrap the getData() call with this try catch.\nFor the exists() call, it will never throw ZkNoNodeException, right?\nIn this case, I guess this try catch branch is not necessary here?", "author": "jiajunwang", "createdAt": "2020-05-29T01:59:45Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1078,40 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    Stat stat = null;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        Stat finalStat = stat;\n+        retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().getData(path, true, finalStat));\n+        LOG.debug(\"getstat() invoked with useGetData() with path: \" + path);\n+      }\n       record(path, null, startT, ZkClientMonitor.AccessType.READ);\n       return stat;\n     } catch (ZkNoNodeException e) {\n+      LOG.debug(\"getstat() invoked path: \" + path + \" null\" + \" useGetData:\" + useGetData);\n       record(path, null, startT, ZkClientMonitor.AccessType.READ);\n-      throw e;\n+      return null;", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NTI4NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432275284", "bodyText": "Yes, you are right. But original code still catch NoNodeException using exists() call. I just want to make it safe (keeping exact the same behavior/bug).\nLet me wrap it to the getData() branch.", "author": "kaisun2000", "createdAt": "2020-05-29T06:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjQ1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MDI4MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432780280", "bodyText": "added.", "author": "kaisun2000", "createdAt": "2020-05-29T23:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjc2OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432216769", "bodyText": "Put the getStat call inside the recordPathStat parameter list is no longer clean.\nPlease create a local var for the state and pass it to the record method.", "author": "jiajunwang", "createdAt": "2020-05-29T02:01:01Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1304,7 +1356,11 @@ private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry>\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n               // getStat will re-install watcher only when the path exists\n-              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n+              if (!pathExists) {", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MjczNA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432282734", "bodyText": "you mean something like\nStat stat = null\nif (!pathExists) {\n  stat = getStat(path, false);\n} else {\n  stat = getStat(path, true, true);\n}\npathStatRecord.recordPathStat(stat, notificationTime);", "author": "kaisun2000", "createdAt": "2020-05-29T06:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5ODgyNg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434998826", "bodyText": "I the current way, code readers may still not following. Please add some comments here for the logic.", "author": "jiajunwang", "createdAt": "2020-06-04T05:22:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzMjA4Mg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435032082", "bodyText": "added the reasoning.", "author": "kaisun2000", "createdAt": "2020-06-04T06:57:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjgwMg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432216802", "bodyText": "Same here.", "author": "jiajunwang", "createdAt": "2020-05-29T02:01:09Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1341,8 +1397,11 @@ private void fireChildChangedEvents(final String path, Set<IZkChildListener> chi\n           @Override\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && pathExists),\n-                  OptionalLong.empty());\n+              if (!pathExists) {\n+                pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && pathExists), OptionalLong.empty());", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjg4Mg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432216882", "bodyText": "If no listener, still need to watch? Why?", "author": "jiajunwang", "createdAt": "2020-05-29T02:01:35Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1341,8 +1397,11 @@ private void fireChildChangedEvents(final String path, Set<IZkChildListener> chi\n           @Override\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && pathExists),\n-                  OptionalLong.empty());\n+              if (!pathExists) {\n+                pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && pathExists), OptionalLong.empty());\n+              } else {\n+                pathStatRecord.recordPathStat(getStat(path, true, true), OptionalLong.empty());", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5MDM5Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432290396", "bodyText": "strictly, we should do this:\nStat stat = null;\nif (!pathExists || !hasListener(path)) {\n   stat = getStat(path, false);          // will not install listener using exists call\n} else {\n   stat = getStat(path, true, true);   // will install listener using getData() call; if node not there, install nothing, \n}\npathStatRecord.recordPathStat(stat, OptionalLong.empty());\nLet me change it this way.\nBy in reality, Yi added hasListener() in hope that it would not leak path from here when fireAllEvent() gets called. However, this does not really work due to the reason I illustrated in my doc about case 1 leaking.\nAnd in our code fireAllEvent() is the only place hasListener() will return false. Otherwise, it is simple to reason that hasListeners(path) always return true unless user can unsubscribeChildChange.\nAny, would make this change.", "author": "kaisun2000", "createdAt": "2020-05-29T06:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNzAxNg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432217016", "bodyText": "Same here, if path does not exists, the old logic is skip watching, right?", "author": "jiajunwang", "createdAt": "2020-05-29T02:02:10Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1304,7 +1356,11 @@ private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry>\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n               // getStat will re-install watcher only when the path exists\n-              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n+              if (!pathExists) {\n+                pathStatRecord.recordPathStat(getStat(path, false), notificationTime);\n+              } else {\n+                pathStatRecord.recordPathStat(getStat(path, true, true), notificationTime);", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4Mzk4NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432283984", "bodyText": "Old logic, if pathExists is false, it would not install watch using exist() call; otherwise, use exists() call to install the watch.\nNew logic, if pathExits is false, it would not install watch using exist() call; otherwise, use getData() call to istall the watch.\nNew approach would not leak watch if async deletion happens in between.", "author": "kaisun2000", "createdAt": "2020-05-29T06:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNzAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432263628", "bodyText": "If skipWatchingNodeNotExist, then we don't watch the root path? This change the behavior, right?", "author": "jiajunwang", "createdAt": "2020-05-29T05:31:03Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1865,17 +1934,24 @@ public Object call() throws Exception {\n    *         exist.\n    */\n   public List<String> watchForChilds(final String path) {\n+    return watchForChilds(path, false);\n+  }\n+\n+  private List<String> watchForChilds(final String path, boolean skipWatchingNodeNotExist) {\n     if (_zookeeperEventThread != null && Thread.currentThread() == _zookeeperEventThread) {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n     return retryUntilConnected(new Callable<List<String>>() {\n       @Override\n       public List<String> call() throws Exception {\n-        exists(path, true);\n+        if (!skipWatchingNodeNotExist) {", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2OTY3MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432269670", "bodyText": "If skipWatchingNodeNotExist, we don't add watch to parent path. That is exactly what we want.\nWe can think it this way.\n1/ skipWatchingNodeNotExist true, if the parent path is not there. We will not install watch.\n2/ skipWatchingNodeNotExist false, namely original behavior, if the parent path is not there, we will install exist data watch.\nWe discussed this in the meeting.\nThe second case is actually needed for current state callbackhandler registration. LiveInstance change would cause current state callbackhandler to be added to ZkHelixManager. And at the time, it can often be the case the parent node of current state is not yet created. Note, this is the INIT case.\nLater CALLBACK case, we should expect the current state parent path be there. Otherwise, we should not register the watch to Zk server (or we will leak a path). That is why we need the first case.", "author": "kaisun2000", "createdAt": "2020-05-29T05:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4MjQ2OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434982469", "bodyText": "But if skipWatchingNodeNotExist is true, so we skip install watcher on parent path. Then do we still need to install watcher on childs? Shall we directly return here?", "author": "junkaixue", "createdAt": "2020-06-04T04:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NDU5NQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434994595", "bodyText": "This is intentional.\nif skipWatchingNodeNoExist is true, we skip install \"data\" watch using exists(). Thus, if the directory (parent path) is not created, it won't leak a \"data\" watch in server.\nNote, the getChildren() also installs \"child\" watch if the parent path exists(). Otherwise, it would return null.\nNote child watch and data watch are two different watch from ZK server perspective, stored in different data structure.  Data watch can be installed to path not exist yet, child watch can't.\nIf the parent path exists, we only need child watch to function correctly. skipWatchingNodeNotExist is true in this case. This is also the case when CallbackHandler has CALLBACK notification.\nIf we want to wait till paren path to be created, we set skipWatchingNodeNotExist to be false. This is the case when CallbackHandler has INIT notification.", "author": "kaisun2000", "createdAt": "2020-06-04T05:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMDExOA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435000118", "bodyText": "1/ skipWatchingNodeNotExist true, if the parent path is not there. We will not install watch.\n\nWhat you are doing is, if skipWatchingNodeNotExist is true, then not install the watch no matter the parent path exists or not. Please double check.", "author": "jiajunwang", "createdAt": "2020-06-04T05:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAyMzg4MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435023881", "bodyText": "@kaisun2000 I dont think that is a good idea. In this case, it only handle the leakage of data change but not child change. I think it is better to have consistent behavior: if node does not exist and skipWatchingNodeNotExist is true, no data change and child change watcher install. Otherwise, install both.", "author": "junkaixue", "createdAt": "2020-06-04T06:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MTUyMQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435051521", "bodyText": "@jiajunwang, the code is like this:\n     public List<String> call() throws Exception {\n        if (!skipWatchingNodeNotExist) {\n          exists(path, true);\n        }\n        try {\n          return getChildren(path, true);\n        } catch (ZkNoNodeException e) {\n          // ignore, the \"exists\" watch will listen for the parent node to appear\n          LOG.info(\"watchForChilds path not existing:\" + path + \" skipWatchingNodeNoteExist:\" + skipWatchingNodeNotExist);\n        }\n        return null;\n      }\n\nif skipWatchingNodeNotExist is true, they call getChildren().\n\n\nIf the parent path exists, it would install child change.\n\n\nOtherwise, if parent path not exists, it would not  install parent path. Instead, it would return null as child list. This would eventually cause the CallbackHandler's handleChildren() code path _manager.removeListener(_propertyKey, _listener);. This path would remove CallbackHandler.", "author": "kaisun2000", "createdAt": "2020-06-04T07:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA3OTY2MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435079661", "bodyText": "@dasahcc, this part is kind of complicated. Seems you are concerned that there are some insistent state. But fortunately, we can reason this way, which covers all the cases.\n\"if node does not exist and skipWatchingNodeNotExist is true\", in some case, we do need to install data watch if we expect the parent node is to be created.\nLet us look at the life cycle of CallbackHandler (CB) to see all the cases.\n\n\nINIT of CallbackHandler when parent node note existing. CB first installs data(exists) watch to this parent node. Then when the node is created, CB got notification of creation. Then CB will read all of the children (installing child watch at this time) and install data watch for each children.\n\n\nINIT of CallbackHandler when parent node exists. CB still first installs data watch to this parent node. And the use getData() to get the list of children and install data watch for each children.\n\n\nNot the above two code paths are the same. They are started from CB's subscribeForChanges() --> subscribeChildChange(INIT) --> _zkClient.subscribeChildChanges( skipWatchingNodeNotExist as false) --> watchForChild(skipWatchingNodeNotExist as false)\nThis would trigger both exists() and getData(). This is exactly what we want, because in the first case, you need exists() if the parent path does not exists as explained before.\nThen your next question can be why for the second case I need exists() if the path does exist? The is because later, if the paren path is removed, you want to remove the CB from ZkHelixManager too. With data watch, you are guaranteed a notification of handleChildChange(). Here the _manager.removeListener(_propertyKey, _listener); code path would be trigger. This is exactly what happens when current state parent node moves due to new session established in participant code.\nSo above discussion addressed the basic life cycle of CallbackHandler.\nThe left case is about what happens when normal notification of CALLBACK type.\nThis is triggered by adding or deleting a current state node under the parent path. At this time, the code path is:\nsubscribeForChanges() --> subscribeChildChange(CALLBACK) --> _zkClient.subscribeChildChanges( skipWatchingNodeNotExist as true) --> watchForChild(skipWatchingNodeNotExist as true)\nHere, watchForChild will not install data watch for parent node, only use getData to install child watch and return list of children. Then CallbackHandler would install data watch for each children.\nSo here, if you think about it, there is no in-consistant case of installing part of the parent child watch, but not child data watch.\nNote, we should not install data watch to parent node here at CALLBACK stage for the reason that the removing of parent node is async to this whole process. That can be the source of leaking once the INIT phase passed, as I explained in the doc.\nThe above discussion exhausts all the cases of CallbackHandler life cycle. Hope this would give people a clear idea of how we reason it.", "author": "kaisun2000", "createdAt": "2020-06-04T08:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMDEyMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435520120", "bodyText": "Synced with @kaisun2000 offline. It should be potential leakage but minimum risk.\nMy final comment:\nHere that you introduced the new flag to change the logic. But two types of watchers have different behavior for that flag. This could be confusing.  If you think it is necessary to keep two different behavior, please add more comments of the code. That could lead code reader very confusing.", "author": "junkaixue", "createdAt": "2020-06-04T20:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNDI3MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435524271", "bodyText": "Thx, @dasahcc, let me summarize the gist of our discussion  -- async removal and exists() compatibility wrt life cycle of callbackhandler here.\nIndeed this is an arcane area hard for people to understand.", "author": "kaisun2000", "createdAt": "2020-06-04T20:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0NjA3Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435646077", "bodyText": "This is good and intelligent discussion. I add the comment and would resolve this issue. Let me know if other wise.,", "author": "kaisun2000", "createdAt": "2020-06-05T01:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2NDI2NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432264264", "bodyText": "I feel this boolean is not straightforward to understand. Shall we add an opposite boolean, watchNonExistPath? That is easier to understand, IMO.", "author": "jiajunwang", "createdAt": "2020-05-29T05:33:41Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,44 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist Ture means not installing any watch if path does not exist.", "originalCommit": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MTkyNA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432271924", "bodyText": "Reason it this way is easier to know what is original behavior. The newly added flag (true) introduces new behavior.", "author": "kaisun2000", "createdAt": "2020-05-29T06:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2NDI2NA=="}], "type": "inlineReview"}, {"oid": "a29063095b79a06c7c4bbaf0237b304593814547", "url": "https://github.com/apache/helix/commit/a29063095b79a06c7c4bbaf0237b304593814547", "message": "interface change to return subscription success status. And\nsome small modification.", "committedDate": "2020-05-30T00:34:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0NDE4Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r433544186", "bodyText": "Can we make it more OO?", "author": "jiajunwang", "createdAt": "2020-06-01T23:39:31Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -68,13 +68,55 @@\n   int DEFAULT_CONNECTION_TIMEOUT = 60 * 1000;\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n+  class ChildrenSubscribeResult {", "originalCommit": "a29063095b79a06c7c4bbaf0237b304593814547", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU1NTYzOQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r433555639", "bodyText": "changed it to separate class with getter and constructor.", "author": "kaisun2000", "createdAt": "2020-06-02T00:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0NDE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0NDc4NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r433544784", "bodyText": "Let's make ChildrenSubscribeResult a standalone class.", "author": "jiajunwang", "createdAt": "2020-06-01T23:41:51Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -212,6 +213,11 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n   }\n \n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    RealmAwareZkClient.ChildrenSubscribeResult result = subscribeChildChanges(path, listener, false);\n+    return result.children;\n+  }\n+\n+  public RealmAwareZkClient.ChildrenSubscribeResult subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist) {", "originalCommit": "a29063095b79a06c7c4bbaf0237b304593814547", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6fd34f366718560c5bc634f487ac46c6b38c08a3", "url": "https://github.com/apache/helix/commit/6fd34f366718560c5bc634f487ac46c6b38c08a3", "message": "interface refactor and test class refactor", "committedDate": "2020-06-02T01:02:17Z", "type": "commit"}, {"oid": "e8adc0932330f9636b607c23c43885d9578e8ee9", "url": "https://github.com/apache/helix/commit/e8adc0932330f9636b607c23c43885d9578e8ee9", "message": "minor fix for null case.", "committedDate": "2020-06-02T05:06:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNDM5MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432234390", "bodyText": "Is this variable unnecessary?", "author": "huizhilu", "createdAt": "2020-05-29T03:19:11Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1078,46 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    Stat stat = null;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        Stat finalStat = stat;", "originalCommit": "0e0c4c65e4c1d06590d2bbd41c06d69578c20ae2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg1NTY4OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434855689", "bodyText": "This is needed to workaround intellij check.", "author": "kaisun2000", "createdAt": "2020-06-03T21:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNDM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzAwNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r432237007", "bodyText": "@kaisun2000 Typo. And could you change the logging to parameterized logging: LOG.debug(\"Event delete: {}\", event.getPath());? There is performance advantage over the concatenation. The fully formatted message text is NOT created unless the DEBUG level is enabled for the logger. It is like\nif (logger.isDebugEnabled()) {\n  LOG.debug(\"event delete: \" + event.getPath());\n}\n\nBut the one you use will still create the message. We would like optimal performance, right?", "author": "huizhilu", "createdAt": "2020-05-29T03:31:41Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1270,6 +1325,9 @@ public void deleteRecursively(String path) throws ZkClientException {\n   private void processDataOrChildChange(WatchedEvent event, long notificationTime) {\n     final String path = event.getPath();\n     final boolean pathExists = event.getType() != EventType.NodeDeleted;\n+    if (EventType.NodeDeleted == event.getType()) {\n+      LOG.debug(\"event delelete:\" + event.getPath());", "originalCommit": "0e0c4c65e4c1d06590d2bbd41c06d69578c20ae2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg3OTU4Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434879587", "bodyText": "Good point.", "author": "kaisun2000", "createdAt": "2020-06-03T21:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNjYwMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r433626600", "bodyText": "Why is this finaStat necessary?", "author": "huizhilu", "createdAt": "2020-06-02T05:23:03Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1082,47 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    Stat stat = null;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        try {\n+          LOG.debug(\"getstat() invoked with useGetData() with path: \" + path);\n+          Stat finalStat = stat;", "originalCommit": "e8adc0932330f9636b607c23c43885d9578e8ee9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg1Njg5Mw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434856893", "bodyText": "Intellj other wise don't like it.", "author": "kaisun2000", "createdAt": "2020-06-03T21:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNjYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNzgwMw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r433627803", "bodyText": "Apache license.", "author": "huizhilu", "createdAt": "2020-06-02T05:27:23Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.apache.helix.zookeeper.api.client;\n+", "originalCommit": "e8adc0932330f9636b607c23c43885d9578e8ee9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyODA5MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r433628090", "bodyText": "Apache license.", "author": "huizhilu", "createdAt": "2020-06-02T05:28:10Z", "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.apache.helix.integration.manager;\n+", "originalCommit": "e8adc0932330f9636b607c23c43885d9578e8ee9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyODIyOQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r433628229", "bodyText": "Apache license.", "author": "huizhilu", "createdAt": "2020-06-02T05:28:35Z", "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterSpectatorManager.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.apache.helix.integration.manager;\n+", "originalCommit": "e8adc0932330f9636b607c23c43885d9578e8ee9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "56f9de9e79c432494d0bfaec3168a6dde5bc15d8", "url": "https://github.com/apache/helix/commit/56f9de9e79c432494d0bfaec3168a6dde5bc15d8", "message": "bring subscribeData on par with subscribeChildren. Namely INIT time\nallow no-existing path, CALLBACK time, will not.", "committedDate": "2020-06-02T08:17:40Z", "type": "commit"}, {"oid": "8466c2c41e648baf1ef6a3d50a54c75d8e86b89a", "url": "https://github.com/apache/helix/commit/8466c2c41e648baf1ef6a3d50a54c75d8e86b89a", "message": "revert logging.", "committedDate": "2020-06-02T10:06:06Z", "type": "commit"}, {"oid": "34eb69f799931fac89f146f87427aa8d7675062a", "url": "https://github.com/apache/helix/commit/34eb69f799931fac89f146f87427aa8d7675062a", "message": "add apache license", "committedDate": "2020-06-03T21:49:24Z", "type": "commit"}, {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "url": "https://github.com/apache/helix/commit/a1d39c7f0347dee5004bb603495ecafa7da3d487", "message": "fix logging to improve performance when debug is not on.", "committedDate": "2020-06-03T23:20:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4MDQ5Mw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434980493", "bodyText": "Shall we print some logs here? Since there are some other info log printed before", "author": "junkaixue", "createdAt": "2020-06-04T04:06:18Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -748,6 +756,10 @@ public void handleChildChange(String parentPath, List<String> currentChilds) {\n           // removeListener will call handler.reset(), which in turn call invoke() on FINALIZE type\n           _manager.removeListener(_propertyKey, _listener);\n         } else {\n+          if (!isReady()) {\n+            // avoid leaking CallbackHandler", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MTUxNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434991517", "bodyText": "The would happen a lot when session expires. (aka we leak a lot) Let me add a debug log.", "author": "kaisun2000", "createdAt": "2020-06-04T04:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4MDQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNDYxNg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435014616", "bodyText": "Actually added on info log as this only happens when session expires. Comparing to other info logs, this is not excessive.", "author": "kaisun2000", "createdAt": "2020-06-04T06:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4MDQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyOTM3OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r433629379", "bodyText": "Change it to isSubscribed?", "author": "huizhilu", "createdAt": "2020-06-02T05:32:41Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.apache.helix.zookeeper.api.client;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+public class ChildrenSubscribeResult {\n+  private List<String> _children;\n+  private boolean _isInstalled;", "originalCommit": "e8adc0932330f9636b607c23c43885d9578e8ee9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MjI0OA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434992248", "bodyText": "not just subscribed. But the watch is installed in the ZkServer.", "author": "kaisun2000", "createdAt": "2020-06-04T04:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyOTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NTI4NQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434945285", "bodyText": "@kaisun2000 null is acceptable for the param stat. It would not throw exception. See here So no need to get the stat here for this api.\n    public void testBadAuthThenSendOtherCommands() throws Exception {\n        ZooKeeper zk = createClient();     \n        try {        \n            zk.addAuthInfo(\"INVALID\", \"BAR\".getBytes());\n            zk.exists(\"/foobar\", false);             \n            zk.getData(\"/path1\", false, null);\n            Assert.fail(\"Should get auth state error\");", "author": "huizhilu", "createdAt": "2020-06-04T01:41:26Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1849,13 +1924,23 @@ private void checkDataSizeLimit(byte[] data) {\n   }\n \n   public void watchForData(final String path) {\n-    retryUntilConnected(new Callable<Object>() {\n-      @Override\n-      public Object call() throws Exception {\n-        getConnection().exists(path, true);\n-        return null;\n+    watchForData(path, false);\n+  }\n+\n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {\n+        Stat stat = new Stat();", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5ODgzOA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434998838", "bodyText": "https://zookeeper.apache.org/doc/r3.3.3/api/org/apache/zookeeper/ZooKeeper.html#getData(java.lang.String,%20boolean,%20org.apache.zookeeper.data.Stat)\nThey did not say this is guaranteed for you to pass null. What you state may be true for now, but not later. Or not earlier.\nWhat is more, is there a way to check all the version of client having this behavior?\nBetter to be defensive, seems to me. Saving such a constructor really means not much. The trouble it can potentially bring to us is tremendous though.", "author": "kaisun2000", "createdAt": "2020-06-04T05:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NTI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNTQyNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435005427", "bodyText": "Zookeeper has unit tests everywhere for getData() with null passed in. For example: https://github.com/apache/zookeeper/blob/fe940cdd8fb23ba09684cefb73233d570f4a20fa/zookeeper-server/src/test/java/org/apache/zookeeper/test/AuthTest.java#L68\nIf our api could accept a null, we won't explicitly write it in Javadoc, right? I don't think such important behavior would be changed in zookeeper in future.", "author": "huizhilu", "createdAt": "2020-06-04T05:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NTI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwNDcyNA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435104724", "bodyText": "Is there a way we can verify all the old existing zookeeper version can take null as out parameter?\nRelying unpublished behavior of API is not a good practices. We can also get our self into production issue in the future.", "author": "kaisun2000", "createdAt": "2020-06-04T09:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjA5Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434946096", "bodyText": "Typo: delelete -> delete\nAnd also may be a good idea to make it clearer? \"Event NodeDeleted, path: {}\"", "author": "huizhilu", "createdAt": "2020-06-04T01:44:28Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1270,6 +1330,9 @@ public void deleteRecursively(String path) throws ZkClientException {\n   private void processDataOrChildChange(WatchedEvent event, long notificationTime) {\n     final String path = event.getPath();\n     final boolean pathExists = event.getType() != EventType.NodeDeleted;\n+    if (EventType.NodeDeleted == event.getType()) {\n+      LOG.debug(\"event delelete: {}\", event.getPath());", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NjU1OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434996559", "bodyText": "changed.", "author": "kaisun2000", "createdAt": "2020-06-04T05:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5ODQ5MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434998491", "bodyText": "Just curious, why we need this debug?\nAnd nit, if (LOG.isDebugEnabled() && ventType.NodeDeleted == event.getType())\nJust want to save some unnecessary computation.", "author": "jiajunwang", "createdAt": "2020-06-04T05:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwNTk5NQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435105995", "bodyText": "This is useful in debugging. That is one of the thing I used to confirm async delete from server actually caused the leaking.", "author": "kaisun2000", "createdAt": "2020-06-04T09:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0ODYyMQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434948621", "bodyText": "Maybe could we add a log here for such case?", "author": "huizhilu", "createdAt": "2020-06-04T01:54:47Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -748,6 +756,10 @@ public void handleChildChange(String parentPath, List<String> currentChilds) {\n           // removeListener will call handler.reset(), which in turn call invoke() on FINALIZE type\n           _manager.removeListener(_propertyKey, _listener);\n         } else {\n+          if (!isReady()) {\n+            // avoid leaking CallbackHandler", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MTE5MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434991190", "bodyText": "The would happen a lot when session expires. (aka we leak a lot) Let me add a debug log.", "author": "kaisun2000", "createdAt": "2020-06-04T04:51:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0ODYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwNjUyMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435106520", "bodyText": "Actually added an info log.", "author": "kaisun2000", "createdAt": "2020-06-04T09:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0ODYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NDQ5NQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434954495", "bodyText": "Could we add an empty line before the new test method? And add some comments what this test does?", "author": "huizhilu", "createdAt": "2020-06-04T02:18:10Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTA0Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434955047", "bodyText": "Boolean -> boolean?\nAnd style. It doesn't seem this line is formatted.", "author": "huizhilu", "createdAt": "2020-06-04T02:20:39Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTE5Mw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434955193", "bodyText": "If we don't need these lines, we remove them, instead of commenting out.", "author": "huizhilu", "createdAt": "2020-06-04T02:21:17Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNjg5MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435006890", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-06-04T05:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434955557", "bodyText": "Why does it need to sleep 5 seconds? Is it deterministic?", "author": "huizhilu", "createdAt": "2020-06-04T02:22:42Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NDc1MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434994750", "bodyText": "We agreed on not adding more magic numbers as the sleep time before.\nPlease use wait or verifier which loop and wait until the expected condition matches.", "author": "jiajunwang", "createdAt": "2020-06-04T05:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNTM0OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435005349", "bodyText": "This is very good question. Ideally we should not use sleep(). But verify some state of cluster etc.\nBut in this case of testing leaking watcher etc, all these verification does not guarantee you anything. Last time, I specifically wrote an doc explaining the reason why it is like this. The example is testRemoveUserCbHandlerOnPathRemoval().", "author": "kaisun2000", "createdAt": "2020-06-04T05:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNTY4MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435125680", "bodyText": "@jiajunwang, basically I think this is a special case for watcher. If you don't think so, please give a proposal.", "author": "kaisun2000", "createdAt": "2020-06-04T09:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMzc3MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435413770", "bodyText": "\" all these verification does not guarantee you anything\" What kind of verification did you mean? You meant verifier? But how do you guarantee sleeping 5 secs would be 100% correct: it would return expected result?", "author": "huizhilu", "createdAt": "2020-06-04T17:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NjkxNA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435696914", "bodyText": "@kaisun2000 unverifiable case does exist. But I'm not sure if here is the same case. I'm not reading the test code yet. Could you please clarify what it is sleeping for? Then I think I can give you some ideas.\nFor example the later sleep, it seems you are waiting for new session established. In this case, instead of sleeping, you can use the verifier to polling until the session ID changed. Then you don't need to sleep for a hardcoded period.", "author": "jiajunwang", "createdAt": "2020-06-05T05:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwMTMzOQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435701339", "bodyText": "It doesn't have to explicitly sleep to wait for the new session established because expireSession() already guarantees new session established. I guess next sleep may be waiting for session handling or callback handling? But is it necessary? If necessary, could we find a better/deterministic way to verify it? Could you help understand what each of these sleeps is for.", "author": "huizhilu", "createdAt": "2020-06-05T05:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxMTY1Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435711656", "bodyText": "@jiajunwang. This is a good one for discussion as how best can we make the test more stable.\nIn this sleep(), we wait for RP to get to a stable state of installing the watches, callbackhandlers. However, previous verifyWithBestPossible whatever is waiting for cluster to be stable. That is for controller. As far I know there is not equivalent for RP. And is there a way we can do similar thing for RP to reach a stable state?\nline 374 sleep(). We need to wait till RP's zkHelixManager finish handleAllEvent(). By that time, it would have duplicated CB.\nline 389, we need to wait till participant session expiration finishing handleNewSession(), and RP's leaked version of CB's handleChildrenChange() finishing processing. This reproduce the dangling CB's leak on server.", "author": "kaisun2000", "createdAt": "2020-06-05T06:19:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxODIzMQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435718231", "bodyText": "My suggestion is as follows,\nSleep one: define anonymous verifier which compares the RP snapshot with the resource idealstates. When they match, the RP get the stable state.\nSleep two: I guess you can verify if the session Id in the HelixManager has been updated or not. That is only done after the new session handling starts. Even the wait ends before the new session handling finishes, it won't do anything else before it's done anyway.\nSleep three: what if you don't wait here, but polling to verify if the childListeners are reduced to the expected number within a certain period?", "author": "jiajunwang", "createdAt": "2020-06-05T06:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTY2Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r436075666", "bodyText": "\"Sleep two: I guess you can verify if the session Id in the HelixManager has been updated or not. That is only done after the new session handling starts. Even the wait ends before the new session handling finishes, it won't do anything else before it's done anyway.\"\n\nThis is not going to work. Dangling CB is created in the following lambda/event created by fireAllEvent().", "author": "kaisun2000", "createdAt": "2020-06-05T17:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1NDA5OA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r436154098", "bodyText": "Put a @todo here.", "author": "kaisun2000", "createdAt": "2020-06-05T20:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1NDM1Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r436154356", "bodyText": "@pkuwm would propose a framework to implement more reliable test.", "author": "kaisun2000", "createdAt": "2020-06-05T20:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NjU1Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434956557", "bodyText": "No need to use this extra variable zkAddr? We don't want to over use variables.", "author": "huizhilu", "createdAt": "2020-06-04T02:26:37Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3MzUzMw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434973533", "bodyText": "Is this line redundant?", "author": "huizhilu", "createdAt": "2020-06-04T03:36:00Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);\n+\n+    // expire RoutingProvider would create dangling CB\n+    LOG.info(\"expire rp manager session:\", rpManager.getSessionId());\n+    ZkTestHelper.expireSession(rpManager.getZkClient());\n+    LOG.info(\"rp manager new session:\", rpManager.getSessionId());\n+\n+    Thread.sleep(5000);\n+\n+    MockParticipantManager participantToExpire = participants[0];\n+    String oldSessionId = participantToExpire.getSessionId();\n+    PropertyKey.Builder keyBuilder = new PropertyKey.Builder(clusterName);\n+\n+    // expire participant session; leaked callback handler used to be not reset() and be removed from ZkClient\n+    LOG.info(\n+        \"Expire participant: \" + participantToExpire.getInstanceName() + \", session: \"\n+            + participantToExpire.getSessionId());\n+    ZkTestHelper.expireSession(participantToExpire.getZkClient());\n+    String newSessionId = participantToExpire.getSessionId();\n+    LOG.info(participantToExpire.getInstanceName() + \" oldSessionId: \" + oldSessionId\n+        + \", newSessionId: \" + newSessionId);\n+\n+    Thread.sleep(5000);\n+    Map<String, Set<IZkChildListener>> childListeners = ZkTestHelper.getZkChildListener(rpManager.getZkClient());\n+    for (String path : childListeners.keySet()) {\n+      Assert.assertTrue(childListeners.get(path).size() <= 1);\n+    }\n+\n+    Map<String, List<String>> rpWatchPaths = ZkTestHelper.getZkWatch(rpManager.getZkClient());\n+    List<String> existWatches = rpWatchPaths.get(\"existWatches\");\n+    Assert.assertTrue(existWatches.isEmpty());\n+  }\n+\n+  @Test\n+  public void testCurrentStatePathLeakingByAsycRemoval() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    final int mJobUpdateCnt = 500;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // HelixManager rpManager  = HelixManagerFactory.getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    // rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    LOG.info(\"add job\");\n+    MockParticipantManager jobParticipant = participants[0];\n+    String jobSessionId = jobParticipant.getSessionId();\n+    HelixDataAccessor jobAccesor = jobParticipant.getHelixDataAccessor();\n+    PropertyKey.Builder jobKeyBuilder = new PropertyKey.Builder(clusterName);\n+    PropertyKey db0key = jobKeyBuilder.currentState(jobParticipant.getInstanceName(), jobSessionId, \"TestDB0\");\n+    CurrentState db0 = jobAccesor.getProperty(db0key);\n+    PropertyKey jobKey = jobKeyBuilder.currentState(jobParticipant.getInstanceName(), jobSessionId, \"BackupQueue\");\n+    CurrentState cs = new CurrentState(\"BackupQueue\");\n+    cs.setSessionId(jobSessionId);\n+    cs.setStateModelDefRef(db0.getStateModelDefRef());\n+\n+    LOG.info(\"add job\");\n+    boolean rtJob = jobAccesor.setProperty(jobKey, cs);", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMjk1NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435002954", "bodyText": "sort of. Let me change it.", "author": "kaisun2000", "createdAt": "2020-06-04T05:37:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3MzUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3NDg3Mg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434974872", "bodyText": "Your test method is AsyncRemoval. Is this async?\nShall we also verify the watches before removal, to make sure the watches are really added and removed?", "author": "huizhilu", "createdAt": "2020-06-04T03:41:54Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);\n+\n+    // expire RoutingProvider would create dangling CB\n+    LOG.info(\"expire rp manager session:\", rpManager.getSessionId());\n+    ZkTestHelper.expireSession(rpManager.getZkClient());\n+    LOG.info(\"rp manager new session:\", rpManager.getSessionId());\n+\n+    Thread.sleep(5000);\n+\n+    MockParticipantManager participantToExpire = participants[0];\n+    String oldSessionId = participantToExpire.getSessionId();\n+    PropertyKey.Builder keyBuilder = new PropertyKey.Builder(clusterName);\n+\n+    // expire participant session; leaked callback handler used to be not reset() and be removed from ZkClient\n+    LOG.info(\n+        \"Expire participant: \" + participantToExpire.getInstanceName() + \", session: \"\n+            + participantToExpire.getSessionId());\n+    ZkTestHelper.expireSession(participantToExpire.getZkClient());\n+    String newSessionId = participantToExpire.getSessionId();\n+    LOG.info(participantToExpire.getInstanceName() + \" oldSessionId: \" + oldSessionId\n+        + \", newSessionId: \" + newSessionId);\n+\n+    Thread.sleep(5000);\n+    Map<String, Set<IZkChildListener>> childListeners = ZkTestHelper.getZkChildListener(rpManager.getZkClient());\n+    for (String path : childListeners.keySet()) {\n+      Assert.assertTrue(childListeners.get(path).size() <= 1);\n+    }\n+\n+    Map<String, List<String>> rpWatchPaths = ZkTestHelper.getZkWatch(rpManager.getZkClient());\n+    List<String> existWatches = rpWatchPaths.get(\"existWatches\");\n+    Assert.assertTrue(existWatches.isEmpty());\n+  }\n+\n+  @Test\n+  public void testCurrentStatePathLeakingByAsycRemoval() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    final int mJobUpdateCnt = 500;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // HelixManager rpManager  = HelixManagerFactory.getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    // rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    LOG.info(\"add job\");\n+    MockParticipantManager jobParticipant = participants[0];\n+    String jobSessionId = jobParticipant.getSessionId();\n+    HelixDataAccessor jobAccesor = jobParticipant.getHelixDataAccessor();\n+    PropertyKey.Builder jobKeyBuilder = new PropertyKey.Builder(clusterName);\n+    PropertyKey db0key = jobKeyBuilder.currentState(jobParticipant.getInstanceName(), jobSessionId, \"TestDB0\");\n+    CurrentState db0 = jobAccesor.getProperty(db0key);\n+    PropertyKey jobKey = jobKeyBuilder.currentState(jobParticipant.getInstanceName(), jobSessionId, \"BackupQueue\");\n+    CurrentState cs = new CurrentState(\"BackupQueue\");\n+    cs.setSessionId(jobSessionId);\n+    cs.setStateModelDefRef(db0.getStateModelDefRef());\n+\n+    LOG.info(\"add job\");\n+    boolean rtJob = jobAccesor.setProperty(jobKey, cs);\n+    for (int i = 0; i < mJobUpdateCnt; i++) {\n+      rtJob = jobAccesor.setProperty(jobKey, cs);\n+    }\n+\n+    LOG.info(\"remove job\");\n+    rtJob =jobParticipant.getZkClient().delete(jobKey.getPath());", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMTY3Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435001676", "bodyText": "1/ This is async to the thread of routing provider. You can refer to my investigation doc case 2 to see why this is async and why exists() won't work. Without my fix, there are at least 3 possibilities of leaking.\n2/ No need. If the watch is not installed, RP won't work. This is not purpose of this test.", "author": "kaisun2000", "createdAt": "2020-06-04T05:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3NDg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3NTQwMQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434975401", "bodyText": "Could we add a comment why constructing this RoutingTableProvider is necessary as the variable is not used?", "author": "huizhilu", "createdAt": "2020-06-04T03:44:12Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNjU5OA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435006598", "bodyText": "Sure. Will add. This could be hard to understand for people not seen my doc of issue investigation.\nBasically the source of leaking watch in ZK server happens in current state based Routing Provider. They seem not be used in the test. But they did leak before this fix.", "author": "kaisun2000", "createdAt": "2020-06-04T05:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3NTQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3NjA3Mg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434976072", "bodyText": "You have a fix, would expiring helix manager would still create dangling CB?", "author": "huizhilu", "createdAt": "2020-06-04T03:46:53Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);\n+\n+    // expire RoutingProvider would create dangling CB", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwODE5NQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435108195", "bodyText": "The previous reply is lost.\nWith fix, it will not.", "author": "kaisun2000", "createdAt": "2020-06-04T09:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3NjA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3Nzk0Mg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434977942", "bodyText": "I meant parameterized logging for all logging you are adding. Here this is a debug level, usually we would only enable info or warn level, but this string is still concatenated. But if you use parameterized logging, at info/warn level, we could eliminate such string concatenation overhead, right? I strongly suggest changing all loggings you are adding.", "author": "huizhilu", "createdAt": "2020-06-04T03:55:02Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1082,47 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    Stat stat = null;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        try {\n+          LOG.debug(\"getstat() invoked with useGetData() with path: \" + path);\n+          Stat finalStat = stat;\n+          retryUntilConnected(() -> ((ZkConnection) getConnection()).getZookeeper().getData(path, true, finalStat));\n+        } catch (ZkNoNodeException e) {\n+          LOG.debug(\"getstat() invoked path: \" + path + \" null\" + \" useGetData:\" + useGetData);", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NjUwMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434996500", "bodyText": "Good point. Changed all that I added.", "author": "kaisun2000", "createdAt": "2020-06-04T05:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3Nzk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4MjUzOA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434982538", "bodyText": "@kaisun2000 This is not yet resolved. The reason why Intellij complains it is, the variable used in lamda should be final but you initialize stat to null before try block. So stat is not final.\nTo avoid the finalStat, you could remove the variable init to null. So lamda/intellij won't complain. Then it is fine to remove finalStat. We don't over use variables, right? Thanks.", "author": "huizhilu", "createdAt": "2020-06-04T04:15:16Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1082,47 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    Stat stat = null;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        try {\n+          LOG.debug(\"getstat() invoked with useGetData() with path: \" + path);\n+          Stat finalStat = stat;", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMDAwMQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435000001", "bodyText": "Good point. As long as no one complains variable not initialized.", "author": "kaisun2000", "createdAt": "2020-06-04T05:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4MjUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5Mzg4NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434993884", "bodyText": "Why not check the result here? If subscribe fails, shall we just ignore it?", "author": "jiajunwang", "createdAt": "2020-06-04T05:03:05Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -539,7 +539,15 @@ private void subscribeChildChange(String path, NotificationContext.Type callback\n         logger.debug(_manager.getInstanceName() + \" subscribes child-change. path: \" + path\n             + \", listener: \" + _listener);\n       }\n-      _zkClient.subscribeChildChanges(path, this);\n+      // In the lifecycle of CallbackHandler, INIT is the first stage of registration of watch.\n+      // For some usage case such as current state, the path can be created later. Thus we would\n+      // install watch anyway event the path is not yet created.\n+      // Later, CALLBACK type, the CallbackHandler already registered the watch and knows the\n+      // path was created. Here, to avoid leaking path in ZooKeeper server, we would not let\n+      // CallbackHandler to install exists watch, namely watch for path not existing.\n+      // Note when path is removed, the CallbackHanler would remove itself from ZkHelixManager too\n+      // to avoid leaking a CallbackHandler.\n+      _zkClient.subscribeChildChanges(path, this, callbackType != Type.INIT);", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxMDY4OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435010689", "bodyText": "If CallbackType is CALLBACK, ignore it is just want we want. That is exactly the case of async removal of a parent current state. This would result in hanldeChildren() first code path, removing the callbackhandler from the zkhelixmanager.\nIf CallbackType is INIT, it would not fail.\nSo let us add a debug log for general case. Only failure case, info log. As general case would be too much.", "author": "kaisun2000", "createdAt": "2020-06-04T06:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5Mzg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NDQwNg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435694406", "bodyText": "Agreed", "author": "jiajunwang", "createdAt": "2020-06-05T05:15:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5Mzg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NDEwMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434994100", "bodyText": "Same here, we are not checking the result.", "author": "jiajunwang", "createdAt": "2020-06-04T05:03:56Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -555,7 +563,7 @@ private void subscribeDataChange(String path, NotificationContext.Type callbackT\n         logger.debug(_manager.getInstanceName() + \" subscribe data-change. path: \" + path\n             + \", listener: \" + _listener);\n       }\n-      _zkClient.subscribeDataChanges(path, this);\n+      _zkClient.subscribeDataChanges(path, this, callbackType != Type.INIT);", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxMDkxOA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435010918", "bodyText": "If CallbackType is CALLBACK, ignore it is just want we want. That is exactly the case of async removal of a task current state node from server would do.\nIf CallbackType is INIT, it would not fail.\nSo let us add a debug log for general case. Only failure case, info log. As general case would be too much.", "author": "kaisun2000", "createdAt": "2020-06-04T06:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NDEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NDk5NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434994994", "bodyText": "This is not necessary, I think.", "author": "jiajunwang", "createdAt": "2020-06-04T05:07:47Z", "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterManager.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.apache.helix.integration.manager;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.manager.zk.CallbackHandler;\n+import org.apache.helix.manager.zk.ZKHelixManager;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusterManager extends ZKHelixManager implements Runnable, ZkTestManager {\n+  private static Logger LOG = LoggerFactory.getLogger(ClusterControllerManager.class);\n+\n+  protected CountDownLatch _startCountDown = new CountDownLatch(1);\n+  protected CountDownLatch _stopCountDown = new CountDownLatch(1);\n+  protected CountDownLatch _waitStopFinishCountDown = new CountDownLatch(1);\n+\n+  protected boolean _started = false;\n+\n+  public ClusterManager(String zkAddr, String clusterName, InstanceType type) {", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NTQyNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434995427", "bodyText": "roleName -> instanceName?\nAnd this constructor can be protected, only called in the children.", "author": "jiajunwang", "createdAt": "2020-06-04T05:09:37Z", "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterManager.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.apache.helix.integration.manager;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.manager.zk.CallbackHandler;\n+import org.apache.helix.manager.zk.ZKHelixManager;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusterManager extends ZKHelixManager implements Runnable, ZkTestManager {\n+  private static Logger LOG = LoggerFactory.getLogger(ClusterControllerManager.class);\n+\n+  protected CountDownLatch _startCountDown = new CountDownLatch(1);\n+  protected CountDownLatch _stopCountDown = new CountDownLatch(1);\n+  protected CountDownLatch _waitStopFinishCountDown = new CountDownLatch(1);\n+\n+  protected boolean _started = false;\n+\n+  public ClusterManager(String zkAddr, String clusterName, InstanceType type) {\n+    this(zkAddr, clusterName, \"role\", type);\n+  }\n+\n+  public ClusterManager(String zkAddr, String clusterName, String roleName, InstanceType type) {", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NTU5OA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434995598", "bodyText": "Add some Java doc to describe this new class please.", "author": "jiajunwang", "createdAt": "2020-06-04T05:10:17Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.zookeeper.api.client;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+public class ChildrenSubscribeResult {", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAyNDk2NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435024964", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-06-04T06:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NTU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NTcyMQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434995721", "bodyText": "final for both fields", "author": "jiajunwang", "createdAt": "2020-06-04T05:10:47Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.zookeeper.api.client;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+public class ChildrenSubscribeResult {\n+  private List<String> _children;", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNzk5NQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435017995", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-06-04T06:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NjA0NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434996044", "bodyText": "@return ....", "author": "jiajunwang", "createdAt": "2020-06-04T05:12:03Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,49 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * The method return null if the path does not exists. Otherwise, return a list of children\n+   * under the path. The list can be empty if there is no children.\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist True means not installing any watch if path does not exist.\n+   * The method return ChildrentSubsribeResult. If the path does not exists, the isInstalled field", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxOTMyNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435019327", "bodyText": "good point. Done.", "author": "kaisun2000", "createdAt": "2020-06-04T06:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NjA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NjY4Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434996687", "bodyText": "skipWatchingNonExistNode?", "author": "jiajunwang", "createdAt": "2020-06-04T05:14:36Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,49 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * The method return null if the path does not exists. Otherwise, return a list of children\n+   * under the path. The list can be empty if there is no children.\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist True means not installing any watch if path does not exist.", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5OTYxMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435699610", "bodyText": "@kaisun2000 If you agree on the name changing, please change all the other parameter names of this option. They are not consistent now.", "author": "jiajunwang", "createdAt": "2020-06-05T05:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NjY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NzMwMQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434997301", "bodyText": "Deprecate\uff1f", "author": "jiajunwang", "createdAt": "2020-06-04T05:16:56Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,49 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * The method return null if the path does not exists. Otherwise, return a list of children\n+   * under the path. The list can be empty if there is no children.\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxODk2Mg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435018962", "bodyText": "done.", "author": "kaisun2000", "createdAt": "2020-06-04T06:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NzMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NzM3Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434997376", "bodyText": "Deprecate\uff1f", "author": "jiajunwang", "createdAt": "2020-06-04T05:17:11Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,49 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * The method return null if the path does not exists. Otherwise, return a list of children\n+   * under the path. The list can be empty if there is no children.\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist True means not installing any watch if path does not exist.\n+   * The method return ChildrentSubsribeResult. If the path does not exists, the isInstalled field\n+   * is false. Otherwise, it is true and list of children are returned.\n+   */\n+  ChildrenSubscribeResult subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);\n+\n   void unsubscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle data events of the path\n+   * Add the exists watch to Zookeeper server even if the path does not exists in zookeeper server\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   void subscribeDataChanges(String path, IZkDataListener listener);", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTIxMQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434999211", "bodyText": "Will it be cleaner if we put this condition into the retryUntilConnected lamda?", "author": "jiajunwang", "createdAt": "2020-06-04T05:24:16Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1849,13 +1924,23 @@ private void checkDataSizeLimit(byte[] data) {\n   }\n \n   public void watchForData(final String path) {\n-    retryUntilConnected(new Callable<Object>() {\n-      @Override\n-      public Object call() throws Exception {\n-        getConnection().exists(path, true);\n-        return null;\n+    watchForData(path, false);\n+  }\n+\n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzMzY3NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435033674", "bodyText": "It should work too. But I don't see the benefit. They are purely orthogonal. Either way would just work equally well. Any reason preferring one over the other?", "author": "kaisun2000", "createdAt": "2020-06-04T07:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA3MTk1OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435071959", "bodyText": "One less \"retryUntilConnected\" : )", "author": "jiajunwang", "createdAt": "2020-06-04T08:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMTk1Mw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435111953", "bodyText": "Do you sincerely feel this is necessary?", "author": "kaisun2000", "createdAt": "2020-06-04T09:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NTM0Mw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435695343", "bodyText": "I usually don't joke when I reviewing code : )\nBut if you don't agree it will make the code cleaner, you don't have to change. I don't have a strong preference here.", "author": "jiajunwang", "createdAt": "2020-06-05T05:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNjk5OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435706999", "bodyText": "Let us keep it this way then.\nPut this inside the lambda has one drawback as I tried. For the two different code path, the return value is of different type. You can choose either type as we don't use return value. But then the question can drag on as which return value to use? Whey prefer this one over the other one?", "author": "kaisun2000", "createdAt": "2020-06-05T06:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTM1NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434999354", "bodyText": "This one is not used anyway, just new a Stat in the lamda.", "author": "jiajunwang", "createdAt": "2020-06-04T05:24:56Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1849,13 +1924,23 @@ private void checkDataSizeLimit(byte[] data) {\n   }\n \n   public void watchForData(final String path) {\n-    retryUntilConnected(new Callable<Object>() {\n-      @Override\n-      public Object call() throws Exception {\n-        getConnection().exists(path, true);\n-        return null;\n+    watchForData(path, false);\n+  }\n+\n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {\n+        Stat stat = new Stat();", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNTY0OA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435005648", "bodyText": "Newing a Stat is even not necessary. Null is totally fine.", "author": "huizhilu", "createdAt": "2020-06-04T05:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNjY5OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435006699", "bodyText": "One more thing is, adding unused stat to this api also adds more metadata in the response packet. If we don't need it, I don't think it is a good idea to get the stat.", "author": "huizhilu", "createdAt": "2020-06-04T05:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMjg0Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435112847", "bodyText": "As I said, relying on undocumented feature of API is not good practice. Also, can you verify they have the same behavior for all the old release?", "author": "kaisun2000", "createdAt": "2020-06-04T09:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQwNTIzOQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435405239", "bodyText": "I think it is quite standard to pass a null to it if we don't need a stat. It is not guaranteed every use is in javadoc. The old release on GitHub: https://github.com/apache/zookeeper/blob/82186f0d00ebf30640404afcb55ef741f38678c2/src/java/test/org/apache/zookeeper/test/AuthTest.java#L45", "author": "huizhilu", "createdAt": "2020-06-04T16:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0NjQ1MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435646451", "bodyText": "This is outdated. I added the comment as why we should not do it.", "author": "kaisun2000", "createdAt": "2020-06-05T01:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4ODIyNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434988227", "bodyText": "Why are we making it unmodifiable? It seems to me unnecessary. If no this wrap, we could just assign _children = children;", "author": "huizhilu", "createdAt": "2020-06-04T04:39:31Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.zookeeper.api.client;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+public class ChildrenSubscribeResult {\n+  private List<String> _children;\n+  private boolean _isInstalled;\n+\n+  public ChildrenSubscribeResult(List<String> children, boolean isInstalled) {\n+    if (children != null) {\n+      _children = Collections.unmodifiableList(children);", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxODU5NQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435018595", "bodyText": "Make it final does not mean content is not modifiable. Make it content unmodifiable that user can't accidentally change content and pass it other other method.", "author": "kaisun2000", "createdAt": "2020-06-04T06:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4ODIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MzI2Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r434993267", "bodyText": "From the logic, skipWatchingNodeNotExist indicates whether or not exists watch should be installed for parent, right? I feel it is not that easy to understand. Shall we use skipWatchingParent which seems much easier to understand?", "author": "huizhilu", "createdAt": "2020-06-04T05:00:18Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1865,17 +1950,24 @@ public Object call() throws Exception {\n    *         exist.\n    */\n   public List<String> watchForChilds(final String path) {\n+    return watchForChilds(path, false);\n+  }\n+\n+  private List<String> watchForChilds(final String path, boolean skipWatchingNodeNotExist) {", "originalCommit": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwOTQxMw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435009413", "bodyText": "This is not necessary parent path. There are cases for pure data watch.", "author": "kaisun2000", "createdAt": "2020-06-04T05:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MzI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NTYxMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435085610", "bodyText": "Then could you explain the cases? In the logic, it is ignoring parent path. Otherwise the code logic is not what you expect?", "author": "huizhilu", "createdAt": "2020-06-04T08:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MzI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMzYyMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435113620", "bodyText": "I just wrote an long comment about life cycle of CallbackHandler. However, github lost it. There is something seriously wrong with github.", "author": "kaisun2000", "createdAt": "2020-06-04T09:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MzI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyMjA3Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435122076", "bodyText": "@dasahcc, this part is kind of complicated. Seems you are concerned that there are some insistent state. But fortunately, we can reason this way, which covers all the cases.\n\"if node does not exist and skipWatchingNodeNotExist is true\", in some case, we do need to install data watch if we expect the parent node is to be created.\nLet us look at the life cycle of CallbackHandler (CB) to see all the cases.\nINIT of CallbackHandler when parent node note existing. CB first installs data(exists) watch to this parent node. Then when the node is created, CB got notification of creation. Then CB will read all of the children (installing child watch at this time) and install data watch for each children.\nINIT of CallbackHandler when parent node exists. CB still first installs data watch to this parent node. And the use getData() to get the list of children and install data watch for each children.\nNot the above two code paths are the same. They are started from CB's subscribeForChanges() --> subscribeChildChange(INIT) --> _zkClient.subscribeChildChanges( skipWatchingNodeNotExist as false) --> watchForChild(skipWatchingNodeNotExist as false)\nThis would trigger both exists() and getData(). This is exactly what we want, because in the first case, you need exists() if the parent path does not exists as explained before.\nThen your next question can be why for the second case I need exists() if the path does exist? The is because later, if the paren path is removed, you want to remove the CB from ZkHelixManager too. With data watch, you are guaranteed a notification of handleChildChange(). Here the _manager.removeListener(_propertyKey, _listener); code path would be trigger. This is exactly what happens when current state parent node moves due to new session established in participant code.\nSo above discussion addressed the basic life cycle of CallbackHandler.\nThe left case is about what happens when normal notification of CALLBACK type.\nThis is triggered by adding or deleting a current state node under the parent path. At this time, the code path is:\nsubscribeForChanges() --> subscribeChildChange(CALLBACK) --> _zkClient.subscribeChildChanges( skipWatchingNodeNotExist as true) --> watchForChild(skipWatchingNodeNotExist as true)\nHere, watchForChild will not install data watch for parent node, only use getData to install child watch and return list of children. Then CallbackHandler would install data watch for each children.\nSo here, if you think about it, there is no in-consistant case of installing part of the parent child watch, but not child data watch.\nNote, we should not install data watch to parent node here at CALLBACK stage for the reason that the removing of parent node is async to this whole process. That can be the source of leaking once the INIT phase passed, as I explained in the doc.\nThe above discussion exhausts all the cases of CallbackHandler life cycle. Hope this would give people a clear idea of how we reason it.", "author": "kaisun2000", "createdAt": "2020-06-04T09:35:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MzI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyMjI1Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435122257", "bodyText": "Here is it.", "author": "kaisun2000", "createdAt": "2020-06-04T09:35:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MzI2Nw=="}], "type": "inlineReview"}, {"oid": "e6fd57c018a9ee5cd8c7ec21a2866111e3d057e9", "url": "https://github.com/apache/helix/commit/e6fd57c018a9ee5cd8c7ec21a2866111e3d057e9", "message": "address some further comments.", "committedDate": "2020-06-04T05:56:19Z", "type": "commit"}, {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "url": "https://github.com/apache/helix/commit/76d519e8dd3f71520cb7902e42c7fec21b29382a", "message": "address comments", "committedDate": "2020-06-04T08:47:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMDk2Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435410967", "bodyText": "Not trying to be buggy, but usually no empty space between comments and class signature.", "author": "huizhilu", "createdAt": "2020-06-04T17:01:24Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.apache.helix.zookeeper.api.client;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+\n+\n+/** Represents return type of {@link org.apache.helix.zookeeper.api.client.RealmAwareZkClient#subscribeChildChanges(String, IZkChildListener, boolean)}\n+ *  The returned value would signal if watch installation to ZooKeeper server succeeded\n+ *  or not using field _isInstalled. The _children field would contains the list of child names\n+ *  of the watched path. It would be null if the parent path does not exist at the time of watch\n+ *  installation.\n+ */\n+", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MTEzMA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435641130", "bodyText": "deleted.", "author": "kaisun2000", "createdAt": "2020-06-05T01:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMDk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMjE0OA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435412148", "bodyText": "Could have been better to use java style naming? A clearer variable name would be appreciated.", "author": "huizhilu", "createdAt": "2020-06-04T17:03:24Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -555,7 +569,11 @@ private void subscribeDataChange(String path, NotificationContext.Type callbackT\n         logger.debug(_manager.getInstanceName() + \" subscribe data-change. path: \" + path\n             + \", listener: \" + _listener);\n       }\n-      _zkClient.subscribeDataChanges(path, this);\n+      boolean rt = _zkClient.subscribeDataChanges(path, this, callbackType != Type.INIT);", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MTAyMw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435641023", "bodyText": "changed to subStatus.", "author": "kaisun2000", "createdAt": "2020-06-05T01:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMjE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNDE5OQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435414199", "bodyText": "Could you remove the unused code instead of commenting out?", "author": "huizhilu", "createdAt": "2020-06-04T17:06:59Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -318,6 +325,151 @@ public boolean verify() throws Exception {\n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n \n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(ZK_ADDR,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // Routing provider is a spectator in Helix. Currentstate based RP listens on all the\n+    // currentstate changes of all the clusters. They are a source of leaking of watch in\n+    // Zookeeper server.\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);\n+\n+    // expire RoutingProvider would create dangling CB\n+    LOG.info(\"expire rp manager session:\", rpManager.getSessionId());\n+    ZkTestHelper.expireSession(rpManager.getZkClient());\n+    LOG.info(\"rp manager new session:\", rpManager.getSessionId());\n+\n+    Thread.sleep(5000);\n+\n+    MockParticipantManager participantToExpire = participants[0];\n+    String oldSessionId = participantToExpire.getSessionId();\n+    PropertyKey.Builder keyBuilder = new PropertyKey.Builder(clusterName);\n+\n+    // expire participant session; leaked callback handler used to be not reset() and be removed from ZkClient\n+    LOG.info(\n+        \"Expire participant: \" + participantToExpire.getInstanceName() + \", session: \"\n+            + participantToExpire.getSessionId());\n+    ZkTestHelper.expireSession(participantToExpire.getZkClient());\n+    String newSessionId = participantToExpire.getSessionId();\n+    LOG.info(participantToExpire.getInstanceName() + \" oldSessionId: \" + oldSessionId\n+        + \", newSessionId: \" + newSessionId);\n+\n+    Thread.sleep(5000);\n+    Map<String, Set<IZkChildListener>> childListeners = ZkTestHelper.getZkChildListener(rpManager.getZkClient());\n+    for (String path : childListeners.keySet()) {\n+      Assert.assertTrue(childListeners.get(path).size() <= 1);\n+    }\n+\n+    Map<String, List<String>> rpWatchPaths = ZkTestHelper.getZkWatch(rpManager.getZkClient());\n+    List<String> existWatches = rpWatchPaths.get(\"existWatches\");\n+    Assert.assertTrue(existWatches.isEmpty());\n+  }\n+\n+  @Test\n+  public void testCurrentStatePathLeakingByAsycRemoval() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    final int mJobUpdateCnt = 500;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // HelixManager rpManager  = HelixManagerFactory.getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzOTUzMQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435639531", "bodyText": "fixed.", "author": "kaisun2000", "createdAt": "2020-06-05T01:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNDE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNDU0Mw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435414543", "bodyText": "Still a good idea to use helix style to format the code", "author": "huizhilu", "createdAt": "2020-06-04T17:07:34Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -318,6 +325,151 @@ public boolean verify() throws Exception {\n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n \n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(ZK_ADDR,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // Routing provider is a spectator in Helix. Currentstate based RP listens on all the\n+    // currentstate changes of all the clusters. They are a source of leaking of watch in\n+    // Zookeeper server.\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);\n+\n+    // expire RoutingProvider would create dangling CB\n+    LOG.info(\"expire rp manager session:\", rpManager.getSessionId());\n+    ZkTestHelper.expireSession(rpManager.getZkClient());\n+    LOG.info(\"rp manager new session:\", rpManager.getSessionId());\n+\n+    Thread.sleep(5000);\n+\n+    MockParticipantManager participantToExpire = participants[0];\n+    String oldSessionId = participantToExpire.getSessionId();\n+    PropertyKey.Builder keyBuilder = new PropertyKey.Builder(clusterName);\n+\n+    // expire participant session; leaked callback handler used to be not reset() and be removed from ZkClient\n+    LOG.info(\n+        \"Expire participant: \" + participantToExpire.getInstanceName() + \", session: \"\n+            + participantToExpire.getSessionId());\n+    ZkTestHelper.expireSession(participantToExpire.getZkClient());\n+    String newSessionId = participantToExpire.getSessionId();\n+    LOG.info(participantToExpire.getInstanceName() + \" oldSessionId: \" + oldSessionId\n+        + \", newSessionId: \" + newSessionId);\n+\n+    Thread.sleep(5000);\n+    Map<String, Set<IZkChildListener>> childListeners = ZkTestHelper.getZkChildListener(rpManager.getZkClient());\n+    for (String path : childListeners.keySet()) {\n+      Assert.assertTrue(childListeners.get(path).size() <= 1);\n+    }\n+\n+    Map<String, List<String>> rpWatchPaths = ZkTestHelper.getZkWatch(rpManager.getZkClient());\n+    List<String> existWatches = rpWatchPaths.get(\"existWatches\");\n+    Assert.assertTrue(existWatches.isEmpty());\n+  }\n+\n+  @Test\n+  public void testCurrentStatePathLeakingByAsycRemoval() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    final int mJobUpdateCnt = 500;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // HelixManager rpManager  = HelixManagerFactory.getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    // rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MDY2Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435640666", "bodyText": "applied for both testing method just added.", "author": "kaisun2000", "createdAt": "2020-06-05T01:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNDU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNTMwMg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435415302", "bodyText": "What is this null representing? :)", "author": "huizhilu", "createdAt": "2020-06-04T17:08:55Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1082,46 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    final Stat stat;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        try {\n+          LOG.debug(\"getstat() invoked with useGetData() with path: {} \", path);\n+          retryUntilConnected(() -> ((ZkConnection) getConnection()).getZookeeper().getData(path, true, stat));\n+        } catch (ZkNoNodeException e) {\n+          LOG.debug(\"getstat() invoked path: {}  null  useGetData: {}\", path, useGetData);", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NjUwOA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435566508", "bodyText": "null means returning value is null. This is the case eventually for CB removal. Please see my earlier comment replying to @lei-xia", "author": "kaisun2000", "createdAt": "2020-06-04T21:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NDExNA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435584114", "bodyText": "Then it is confusing. Could we make it clearer like: \"GetStat returns null, path: {}, useGetData: {}\"", "author": "huizhilu", "createdAt": "2020-06-04T22:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNTMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxODEyNg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435418126", "bodyText": "I am wondering if info or warn level for this message. If it may potentially cause problems maybe warn is expected. But if just regular message, info is good enough.", "author": "huizhilu", "createdAt": "2020-06-04T17:13:44Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -555,7 +569,11 @@ private void subscribeDataChange(String path, NotificationContext.Type callbackT\n         logger.debug(_manager.getInstanceName() + \" subscribe data-change. path: \" + path\n             + \", listener: \" + _listener);\n       }\n-      _zkClient.subscribeDataChanges(path, this);\n+      boolean rt = _zkClient.subscribeDataChanges(path, this, callbackType != Type.INIT);\n+      logger.debug(\"CallbackHandler {} subscribe data path {} result {}\", this, path, rt);\n+      if (!rt) {\n+        logger.info(\"CallbackHandler {} subscribe data path {} failed!\", this, path);", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NTg4Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435565886", "bodyText": "As I commented before, it is ok to be returning false here.", "author": "kaisun2000", "createdAt": "2020-06-04T21:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxODEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTMzMg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435419332", "bodyText": "I still think isSubscribe() is more consistent with the concepts in subscribeChildChange() and easier to understand. Someone would wonder what is installed?", "author": "huizhilu", "createdAt": "2020-06-04T17:15:53Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.apache.helix.zookeeper.api.client;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+\n+\n+/** Represents return type of {@link org.apache.helix.zookeeper.api.client.RealmAwareZkClient#subscribeChildChanges(String, IZkChildListener, boolean)}\n+ *  The returned value would signal if watch installation to ZooKeeper server succeeded\n+ *  or not using field _isInstalled. The _children field would contains the list of child names\n+ *  of the watched path. It would be null if the parent path does not exist at the time of watch\n+ *  installation.\n+ */\n+\n+public class ChildrenSubscribeResult {\n+  private final List<String> _children;\n+  private final boolean _isInstalled;\n+\n+  public ChildrenSubscribeResult(List<String> children, boolean isInstalled) {\n+    if (children != null) {\n+      _children = Collections.unmodifiableList(children);\n+    } else {\n+      _children = null;\n+    }\n+    _isInstalled = isInstalled;\n+  }\n+\n+  public List<String> getChildren() {\n+    return _children;\n+  }\n+\n+  public boolean isInstalled() {", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTc0NA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435419744", "bodyText": "parameterized logging.", "author": "huizhilu", "createdAt": "2020-06-04T17:16:39Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1865,17 +1955,24 @@ public Object call() throws Exception {\n    *         exist.\n    */\n   public List<String> watchForChilds(final String path) {\n+    return watchForChilds(path, false);\n+  }\n+\n+  private List<String> watchForChilds(final String path, boolean skipWatchingNodeNotExist) {\n     if (_zookeeperEventThread != null && Thread.currentThread() == _zookeeperEventThread) {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n     return retryUntilConnected(new Callable<List<String>>() {\n       @Override\n       public List<String> call() throws Exception {\n-        exists(path, true);\n+        if (!skipWatchingNodeNotExist) {\n+          exists(path, true);\n+        }\n         try {\n           return getChildren(path, true);\n         } catch (ZkNoNodeException e) {\n           // ignore, the \"exists\" watch will listen for the parent node to appear\n+          LOG.info(\"watchForChilds path not existing:\" + path + \" skipWatchingNodeNoteExist:\" + skipWatchingNodeNotExist);", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzOTI5Ng==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435639296", "bodyText": "fixed.", "author": "kaisun2000", "createdAt": "2020-06-05T01:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQyMTQ4MA==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435421480", "bodyText": "This api is run frequently. A good idea to use parameterize logging to save some string concatenation overhead.", "author": "huizhilu", "createdAt": "2020-06-04T17:19:37Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -220,7 +227,15 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n       }\n       listeners.add(listener);\n     }\n-    return watchForChilds(path);\n+\n+    List<String> children = watchForChilds(path, skipWatchingNodeNotExist);\n+    if (children == null && skipWatchingNodeNotExist) {\n+      unsubscribeChildChanges(path, listener);\n+      LOG.info(\"watchForChilds failed to install no-existing watch and add listener. Path:\" + path);", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzODk3MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435638971", "bodyText": "fixed.", "author": "kaisun2000", "createdAt": "2020-06-05T01:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQyMTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5ODEzMg==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435698132", "bodyText": "nit, could you please rephrase this? I think we need to mention the re-subscribe is skipped because of the CH end of life.", "author": "jiajunwang", "createdAt": "2020-06-05T05:31:36Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -748,6 +766,12 @@ public void handleChildChange(String parentPath, List<String> currentChilds) {\n           // removeListener will call handler.reset(), which in turn call invoke() on FINALIZE type\n           _manager.removeListener(_propertyKey, _listener);\n         } else {\n+          if (!isReady()) {\n+            // avoid leaking CallbackHandler\n+            logger.info(\"Callbackhandler {} with path {} end of life as not ready to avoid leak\",", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NTMyNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r436165327", "bodyText": "good point. changed to \"Callbackhandler {} with path {} is in reset state. Stop subscription to ZK client to avoid leaking\"", "author": "kaisun2000", "createdAt": "2020-06-05T21:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5ODEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxMjE1MQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r435712151", "bodyText": "I thought about this method, I think instead of having this \"useGetData\" option, we just make it explicitly getData(final String path, final boolean watch) method. The caller know which one to all. And then there won't be any confusion.", "author": "jiajunwang", "createdAt": "2020-06-05T06:21:21Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1082,46 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {", "originalCommit": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1NTEyNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r436155127", "bodyText": "add a todo. @jiajunwang we can help to refactor later, as this is private method.", "author": "kaisun2000", "createdAt": "2020-06-05T20:43:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxMjE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NTMxNQ==", "url": "https://github.com/apache/helix/pull/1035#discussion_r436165315", "bodyText": "Why?", "author": "jiajunwang", "createdAt": "2020-06-05T21:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxMjE1MQ=="}], "type": "inlineReview"}, {"oid": "a4be6d554eaa73033e34c936793b7327b8cd8d35", "url": "https://github.com/apache/helix/commit/a4be6d554eaa73033e34c936793b7327b8cd8d35", "message": "address further commit.", "committedDate": "2020-06-05T21:19:34Z", "type": "commit"}, {"oid": "26851fa10b8344678f5460f514a1e4a4ee2fce14", "url": "https://github.com/apache/helix/commit/26851fa10b8344678f5460f514a1e4a4ee2fce14", "message": "split getStat() into two different branch in two methods.", "committedDate": "2020-06-05T22:56:32Z", "type": "commit"}, {"oid": "db3a882d62ecb8affc9886782d5ffa0742b696ff", "url": "https://github.com/apache/helix/commit/db3a882d62ecb8affc9886782d5ffa0742b696ff", "message": "remove refactored code.", "committedDate": "2020-06-05T23:05:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDI2Nw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r436204267", "bodyText": "nit, getdata", "author": "jiajunwang", "createdAt": "2020-06-05T23:22:30Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1082,7 +1082,51 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n-    return getStat(path, watch, false);\n+    long startT = System.currentTimeMillis();\n+    final Stat stat;\n+    try {\n+      stat = retryUntilConnected(\n+          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      record(path, null, startT, ZkClientMonitor.AccessType.READ);\n+      return stat;\n+    } catch (Exception e) {\n+      recordFailure(path, ZkClientMonitor.AccessType.READ);\n+      throw e;\n+    } finally {\n+      long endT = System.currentTimeMillis();\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"exists, path: \" + path + \", time: \" + (endT - startT) + \" ms\");\n+      }\n+    }\n+  }\n+\n+  /*\n+   * This one installs watch only if path is there. Meant to avoid leaking watch in Zk server.\n+   */\n+  private Stat installWatchOnlyPathExist(final String path) {\n+    long startT = System.currentTimeMillis();\n+    final Stat stat;\n+    try {\n+        stat = new Stat();\n+        try {\n+          LOG.debug(\"installWatchOnlyPathExist with path: {} \", path);\n+          retryUntilConnected(() -> ((ZkConnection) getConnection()).getZookeeper().getData(path, true, stat));\n+        } catch (ZkNoNodeException e) {\n+          LOG.debug(\"installWatchOnlyPathExist path not existing: {}\", path);\n+          record(path, null, startT, ZkClientMonitor.AccessType.READ);\n+          return null;\n+        }\n+      record(path, null, startT, ZkClientMonitor.AccessType.READ);\n+      return stat;\n+    } catch (Exception e) {\n+      recordFailure(path, ZkClientMonitor.AccessType.READ);\n+      throw e;\n+    } finally {\n+      long endT = System.currentTimeMillis();\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"exists, path: \" + path + \", time: \" + (endT - startT) + \" ms\");", "originalCommit": "26851fa10b8344678f5460f514a1e4a4ee2fce14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNTkwNw==", "url": "https://github.com/apache/helix/pull/1035#discussion_r436205907", "bodyText": "good point.\nfixed.", "author": "kaisun2000", "createdAt": "2020-06-05T23:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDI2Nw=="}], "type": "inlineReview"}, {"oid": "3403d500e9fef42725b6f209ef2d423621e909cb", "url": "https://github.com/apache/helix/commit/3403d500e9fef42725b6f209ef2d423621e909cb", "message": "fix a logging.", "committedDate": "2020-06-05T23:30:39Z", "type": "commit"}]}