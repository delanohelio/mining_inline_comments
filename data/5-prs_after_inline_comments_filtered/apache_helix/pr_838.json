{"pr_number": 838, "pr_title": "Make ConfigAccessor and ZkUtil realm-aware", "pr_createdAt": "2020-02-29T03:55:01Z", "pr_url": "https://github.com/apache/helix/pull/838", "timeline": [{"oid": "1f5a10ad9ad6e0951b607261ec32a42dd4d3aed1", "url": "https://github.com/apache/helix/commit/1f5a10ad9ad6e0951b607261ec32a42dd4d3aed1", "message": "Make ConfigAccessor realm-aware", "committedDate": "2020-02-29T02:48:33Z", "type": "commit"}, {"oid": "ca33ae14af1eb56a3aa5e8af6b65e21e4f50b1b6", "url": "https://github.com/apache/helix/commit/ca33ae14af1eb56a3aa5e8af6b65e21e4f50b1b6", "message": "Implement", "committedDate": "2020-02-29T03:53:09Z", "type": "commit"}, {"oid": "e60815332bccc622806b3bb30014895d3690a685", "url": "https://github.com/apache/helix/commit/e60815332bccc622806b3bb30014895d3690a685", "message": "Implement", "committedDate": "2020-03-01T03:27:49Z", "type": "commit"}, {"oid": "abe1efef7de4969064d34904361b952f4591143a", "url": "https://github.com/apache/helix/commit/abe1efef7de4969064d34904361b952f4591143a", "message": "format", "committedDate": "2020-03-01T03:30:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MzMxNQ==", "url": "https://github.com/apache/helix/pull/838#discussion_r386563315", "bodyText": "It seems by default you set realmMode as multi realm. Why not set it multi realm by default in constructor ?\nAnd if sharding key is set only, are we going to just allow it to have single realm by default?\nIt seems easier to use and to check the code logic?\nBy default:\n\nNo sharding key or realm mode set, by default it is multi realm\nOnly sharding key is set, single realm\nSharding key and multi realm set, illegal", "author": "huizhilu", "createdAt": "2020-03-02T18:16:56Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -373,6 +379,91 @@ public String getZkRealmShardingKey() {\n     public int getSessionTimeout() {\n       return _sessionTimeout;\n     }\n+\n+    public String getMsdsEndpoint() {\n+      return _msdsEndpoint;\n+    }\n+\n+    public HelixZkClient.ZkConnectionConfig createZkConnectionConfig()\n+        throws IOException, InvalidRoutingDataException {\n+      // Convert to a single-realm HelixZkClient's ZkConnectionConfig\n+      if (_zkRealmShardingKey == null || _zkRealmShardingKey.isEmpty()) {\n+        throw new ZkClientException(\n+            \"Cannot create ZkConnectionConfig because ZK realm sharding key is either null or empty!\");\n+      }\n+\n+      String zkAddress;\n+      // Look up the ZK address for the given ZK realm sharding key\n+      if (_msdsEndpoint == null || _msdsEndpoint.isEmpty()) {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData()\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      } else {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData(_msdsEndpoint)\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      }\n+\n+      return new HelixZkClient.ZkConnectionConfig(zkAddress).setSessionTimeout(_sessionTimeout);\n+    }\n+\n+    public static class Builder {\n+      private RealmMode _realmMode;\n+      private String _zkRealmShardingKey;\n+      private String _msdsEndpoint;\n+      private int _sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n+\n+      public Builder() {\n+      }\n+\n+      public Builder setRealmMode(RealmMode mode) {\n+        _realmMode = mode;\n+        return this;\n+      }\n+\n+      public Builder setZkRealmShardingKey(String shardingKey) {\n+        _zkRealmShardingKey = shardingKey;\n+        return this;\n+      }\n+\n+      public Builder setMsdsEndpoint(String msdsEndpoint) {\n+        _msdsEndpoint = msdsEndpoint;\n+        return this;\n+      }\n+\n+      public Builder setSessionTimeout(int sessionTimeout) {\n+        _sessionTimeout = sessionTimeout;\n+        return this;\n+      }\n+\n+      public RealmAwareZkConnectionConfig build() {\n+        validate();\n+        return new RealmAwareZkConnectionConfig(this);\n+      }\n+\n+      /**\n+       * Validate the internal fields of the builder before creating an instance.\n+       */\n+      private void validate() {\n+        boolean isRealmModeSet = _realmMode != null;\n+        boolean isShardingKeySet = _zkRealmShardingKey != null && !_zkRealmShardingKey.isEmpty();\n+        switch (isRealmModeSet ? _realmMode : RealmMode.MULTI_REALM) {", "originalCommit": "abe1efef7de4969064d34904361b952f4591143a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU3MzI2NQ==", "url": "https://github.com/apache/helix/pull/838#discussion_r386573265", "bodyText": "That's what this piece of logic is doing.\nMoving validation logic to a validate() function is a lot cleaner and promotes better organization. The constructor only constructs.\nI am not understanding your question/comment clearly - could you clarify?", "author": "narendly", "createdAt": "2020-03-02T18:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MzMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4NTkzMA==", "url": "https://github.com/apache/helix/pull/838#discussion_r386685930", "bodyText": "This validation logic needs some time to actually understand. At a first glance, I was not able to understand the logic.\n\nif only sharding key is set and realm mode is not set, I would expect to create a single mode client, but this validation does not pass. Or is realm mode forced to set?", "author": "huizhilu", "createdAt": "2020-03-02T22:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MzMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2MzQyMg==", "url": "https://github.com/apache/helix/pull/838#discussion_r386763422", "bodyText": "I simplified the validation logic. Let me know if you think it's clearer.", "author": "narendly", "createdAt": "2020-03-03T02:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MzMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMjE0OA==", "url": "https://github.com/apache/helix/pull/838#discussion_r386702148", "bodyText": "It seems this could be simplified a bit to make it easier to read?\nif (_realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n throw new HelixException(\n     \"ConfigAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n}\n\nif (_realmMode == null) {\n _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n             : RealmAwareZkClient.RealmMode.MULTI_REALM;\n}", "author": "huizhilu", "createdAt": "2020-03-02T22:57:49Z", "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -830,4 +857,75 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String _zkAddress;\n+    private RealmAwareZkClient.RealmMode _realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig _realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig _realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public Builder setZkAddress(String zkAddress) {\n+      _zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      _realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      _realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      _realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ConfigAccessor build() throws Exception {\n+      validate();\n+      return new ConfigAccessor(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isRealmModeSet = _realmMode != null;\n+      boolean isZkAddressSet = _zkAddress != null && !_zkAddress.isEmpty();\n+      if (isRealmModeSet) {\n+        if (_realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+          throw new HelixException(\n+              \"ConfigAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+        }\n+        // If realm mode is set to multi-realm, we simply ignore the given ZK address\n+      } else {\n+        // If zkAddress is set, that implies single-realm mode. Otherwise, multi-realm mode.\n+        _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;", "originalCommit": "abe1efef7de4969064d34904361b952f4591143a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MjI3NA==", "url": "https://github.com/apache/helix/pull/838#discussion_r386752274", "bodyText": "Simplified :)", "author": "narendly", "createdAt": "2020-03-03T01:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMjE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMzg4Nw==", "url": "https://github.com/apache/helix/pull/838#discussion_r386703887", "bodyText": "Do we want ZkClientException?", "author": "huizhilu", "createdAt": "2020-03-02T23:01:45Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -373,6 +379,91 @@ public String getZkRealmShardingKey() {\n     public int getSessionTimeout() {\n       return _sessionTimeout;\n     }\n+\n+    public String getMsdsEndpoint() {\n+      return _msdsEndpoint;\n+    }\n+\n+    public HelixZkClient.ZkConnectionConfig createZkConnectionConfig()\n+        throws IOException, InvalidRoutingDataException {\n+      // Convert to a single-realm HelixZkClient's ZkConnectionConfig\n+      if (_zkRealmShardingKey == null || _zkRealmShardingKey.isEmpty()) {\n+        throw new ZkClientException(\n+            \"Cannot create ZkConnectionConfig because ZK realm sharding key is either null or empty!\");\n+      }\n+\n+      String zkAddress;\n+      // Look up the ZK address for the given ZK realm sharding key\n+      if (_msdsEndpoint == null || _msdsEndpoint.isEmpty()) {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData()\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      } else {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData(_msdsEndpoint)\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      }\n+\n+      return new HelixZkClient.ZkConnectionConfig(zkAddress).setSessionTimeout(_sessionTimeout);\n+    }\n+\n+    public static class Builder {\n+      private RealmMode _realmMode;\n+      private String _zkRealmShardingKey;\n+      private String _msdsEndpoint;\n+      private int _sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n+\n+      public Builder() {\n+      }\n+\n+      public Builder setRealmMode(RealmMode mode) {\n+        _realmMode = mode;\n+        return this;\n+      }\n+\n+      public Builder setZkRealmShardingKey(String shardingKey) {\n+        _zkRealmShardingKey = shardingKey;\n+        return this;\n+      }\n+\n+      public Builder setMsdsEndpoint(String msdsEndpoint) {\n+        _msdsEndpoint = msdsEndpoint;\n+        return this;\n+      }\n+\n+      public Builder setSessionTimeout(int sessionTimeout) {\n+        _sessionTimeout = sessionTimeout;\n+        return this;\n+      }\n+\n+      public RealmAwareZkConnectionConfig build() {\n+        validate();\n+        return new RealmAwareZkConnectionConfig(this);\n+      }\n+\n+      /**\n+       * Validate the internal fields of the builder before creating an instance.\n+       */\n+      private void validate() {\n+        boolean isRealmModeSet = _realmMode != null;\n+        boolean isShardingKeySet = _zkRealmShardingKey != null && !_zkRealmShardingKey.isEmpty();\n+        switch (isRealmModeSet ? _realmMode : RealmMode.MULTI_REALM) {\n+          case MULTI_REALM:\n+            if (isShardingKeySet && isRealmModeSet) {\n+              throw new IllegalArgumentException(\n+                  \"ZK sharding key cannot be set on multi-realm mode! Sharding key: \"\n+                      + _zkRealmShardingKey);\n+            }\n+            break;\n+          case SINGLE_REALM:\n+            if (!isShardingKeySet) {\n+              throw new IllegalArgumentException(\n+                  \"ZK sharding key must be set on single-realm mode!\");\n+            }\n+            break;\n+          default:\n+            throw new ZkClientException(\"RealmAwareZkConnectionConfig: Unknown mode!\");", "originalCommit": "abe1efef7de4969064d34904361b952f4591143a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTYzOQ==", "url": "https://github.com/apache/helix/pull/838#discussion_r386705639", "bodyText": "Nit, shall we declare type List<> ?", "author": "huizhilu", "createdAt": "2020-03-02T23:06:32Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -75,7 +80,7 @@ public static boolean isClusterSetup(String clusterName, HelixZkClient zkClient)\n       logger.info(\"Fail to check cluster setup : zookeeper client is null!\");\n       return false;\n     }\n-    ArrayList<String> requiredPaths = new ArrayList<String>();\n+    ArrayList<String> requiredPaths = new ArrayList<>();", "originalCommit": "abe1efef7de4969064d34904361b952f4591143a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMjkzNQ==", "url": "https://github.com/apache/helix/pull/838#discussion_r386712935", "bodyText": "I'll change to List.", "author": "narendly", "createdAt": "2020-03-02T23:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNzkyNA==", "url": "https://github.com/apache/helix/pull/838#discussion_r386707924", "bodyText": "It seems this changes the original behavior. baseAccessor.exits is actually an async call using asyncExists() in the bottom implementation. I think it is better to keep the original behavior.", "author": "huizhilu", "createdAt": "2020-03-02T23:12:33Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -92,15 +97,17 @@ public static boolean isClusterSetup(String clusterName, HelixZkClient zkClient)\n     requiredPaths.add(PropertyPathBuilder.controllerHistory(clusterName));\n     boolean isValid = true;\n \n-    BaseDataAccessor<Object> baseAccessor = new ZkBaseDataAccessor<Object>(zkClient);\n-    boolean[] ret = baseAccessor.exists(requiredPaths, 0);\n+    boolean[] ret = new boolean[requiredPaths.size()];\n+    for (int i = 0; i < requiredPaths.size(); i++) {\n+      ret[i] = zkClient.exists(requiredPaths.get(i));", "originalCommit": "abe1efef7de4969064d34904361b952f4591143a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMzIzMA==", "url": "https://github.com/apache/helix/pull/838#discussion_r386713230", "bodyText": "This is a util function. Functionality wise, there is no difference.\nDoing an asyncExists() would require more change (you have to look at the callbacks).", "author": "narendly", "createdAt": "2020-03-02T23:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNzkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODU2MQ==", "url": "https://github.com/apache/helix/pull/838#discussion_r386718561", "bodyText": "I did that is why I know this is an async. If you do this sync, it changes the original behavior. If one call of exists fails and throw exception this call fails. But the original behavior won\u2019t fail all the calls. Some other calls are still possible to succeed. Like you said this is just a realm aware change, I don\u2019t think it is a good idea to change the behavior.", "author": "huizhilu", "createdAt": "2020-03-02T23:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNzkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1NTIzMw==", "url": "https://github.com/apache/helix/pull/838#discussion_r386755233", "bodyText": "Okay. Wrapping it with a try-catch.", "author": "narendly", "createdAt": "2020-03-03T01:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNzkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5MjUwOQ==", "url": "https://github.com/apache/helix/pull/838#discussion_r386792509", "bodyText": "I am still not very convinced we change the behavior. I understand the functionality may be the same. But if one call is blocked because of connection and it has to retry, other calls could be blocked. I am not sure how critical it is for here. Maybe Junkai can give an opinion. Since we are also integrating baseDataAccessor, can we just keep this original behavior by calling base data accessor?", "author": "huizhilu", "createdAt": "2020-03-03T04:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNzkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NTA4MA==", "url": "https://github.com/apache/helix/pull/838#discussion_r386795080", "bodyText": "It is not that critical. This could have easily used a set of sync exists call too.", "author": "narendly", "createdAt": "2020-03-03T04:36:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNzkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODgwNg==", "url": "https://github.com/apache/helix/pull/838#discussion_r386708806", "bodyText": "Nit: Maybe we can modify a bit for the error message to combine the error paths together like below to avoid the extra duplicate strings Invalid cluster setup, missing znode path for each path.\nInvalid cluster setup, missing znode paths: [path1, path2]", "author": "huizhilu", "createdAt": "2020-03-02T23:15:14Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -92,15 +97,17 @@ public static boolean isClusterSetup(String clusterName, HelixZkClient zkClient)\n     requiredPaths.add(PropertyPathBuilder.controllerHistory(clusterName));\n     boolean isValid = true;\n \n-    BaseDataAccessor<Object> baseAccessor = new ZkBaseDataAccessor<Object>(zkClient);\n-    boolean[] ret = baseAccessor.exists(requiredPaths, 0);\n+    boolean[] ret = new boolean[requiredPaths.size()];\n+    for (int i = 0; i < requiredPaths.size(); i++) {\n+      ret[i] = zkClient.exists(requiredPaths.get(i));\n+    }\n     StringBuilder errorMsg = new StringBuilder();\n \n     for (int i = 0; i < ret.length; i++) {\n       if (!ret[i]) {\n         isValid = false;\n-        errorMsg\n-            .append((\"Invalid cluster setup, missing znode path: \" + requiredPaths.get(i)) + \"\\n\");\n+        errorMsg.append(\"Invalid cluster setup, missing znode path: \").append(requiredPaths.get(i))", "originalCommit": "abe1efef7de4969064d34904361b952f4591143a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMzQ5Ng==", "url": "https://github.com/apache/helix/pull/838#discussion_r386713496", "bodyText": "Feel free to do this in a future PR. This PR is not about improving or modifying the logic of ZkUtil. It simply is making things realm-aware.", "author": "narendly", "createdAt": "2020-03-02T23:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMTIzMw==", "url": "https://github.com/apache/helix/pull/838#discussion_r386711233", "bodyText": "If we have public static boolean isClusterSetup(String clusterName, RealmAwareZkClient zkClient), it seems keeping this old API public static boolean isClusterSetup(String clusterName, HelixZkClient zkClient) is redundant, because HelixZkClient is a subclass of RealmAwareZkClient?", "author": "huizhilu", "createdAt": "2020-03-02T23:22:08Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -66,6 +67,10 @@ public static boolean isClusterSetup(String clusterName, String zkAddress) {\n   }\n \n   public static boolean isClusterSetup(String clusterName, HelixZkClient zkClient) {", "originalCommit": "abe1efef7de4969064d34904361b952f4591143a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MjM5Ng==", "url": "https://github.com/apache/helix/pull/838#discussion_r386752396", "bodyText": "Yes. Will remove.", "author": "narendly", "createdAt": "2020-03-03T01:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMTIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMTU4NA==", "url": "https://github.com/apache/helix/pull/838#discussion_r386711584", "bodyText": "I think we can move this old API as HelixZkClient can automatically fit into RealmAwareZkClient.", "author": "huizhilu", "createdAt": "2020-03-02T23:23:10Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -132,7 +139,12 @@ public static boolean isInstanceSetup(String zkAddress, String clusterName, Stri\n     return result;\n   }\n \n-  public static boolean isInstanceSetup(HelixZkClient zkclient, String clusterName,\n+  public static boolean isInstanceSetup(HelixZkClient zkClient, String clusterName,", "originalCommit": "abe1efef7de4969064d34904361b952f4591143a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMzk3OA==", "url": "https://github.com/apache/helix/pull/838#discussion_r386713978", "bodyText": "I agree. Let me remove old signatures.", "author": "narendly", "createdAt": "2020-03-02T23:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMTU4NA=="}], "type": "inlineReview"}, {"oid": "59b39dd50cd8e786ea514156a7666f5c7e6f9507", "url": "https://github.com/apache/helix/commit/59b39dd50cd8e786ea514156a7666f5c7e6f9507", "message": "update", "committedDate": "2020-03-03T02:45:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4OTk4OQ==", "url": "https://github.com/apache/helix/pull/838#discussion_r386789989", "bodyText": "This \u201c._\u201d is a bit annoying and we may not have setters in builder...\nThis is one of the reasons I don\u2019t like this leading underscore naming convention. May be in this case I would just ignore this convention and instead use a convention without leading underscore.", "author": "huizhilu", "createdAt": "2020-03-03T04:11:40Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -325,16 +328,18 @@ public int hashCode() {\n    * ZkConnection-related configs for creating an instance of RealmAwareZkClient.\n    */\n   class RealmAwareZkConnectionConfig {\n-\n     /**\n      * zkRealmShardingKey: used to deduce which ZK realm this RealmAwareZkClientConfig should connect to.\n-     * NOTE: this field will be ignored if MODE is MULTI_REALM!\n+     * NOTE: this field will be ignored if RealmMode is MULTI_REALM!\n      */\n-    private final String _zkRealmShardingKey;\n-    private int _sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n-\n-    public RealmAwareZkConnectionConfig(String zkRealmShardingKey) {\n-      _zkRealmShardingKey = zkRealmShardingKey;\n+    private String _zkRealmShardingKey;\n+    private String _msdsEndpoint;\n+    private int _sessionTimeout;\n+\n+    private RealmAwareZkConnectionConfig(Builder builder) {\n+      _zkRealmShardingKey = builder._zkRealmShardingKey;", "originalCommit": "59b39dd50cd8e786ea514156a7666f5c7e6f9507", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5MDU1Mw==", "url": "https://github.com/apache/helix/pull/838#discussion_r386790553", "bodyText": "It seems if realm mode is not set by caller, we don\u2019t set it here by default. Shall we set a default value based on sharding key being set or not?", "author": "huizhilu", "createdAt": "2020-03-03T04:14:42Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -373,6 +378,81 @@ public String getZkRealmShardingKey() {\n     public int getSessionTimeout() {\n       return _sessionTimeout;\n     }\n+\n+    public String getMsdsEndpoint() {\n+      return _msdsEndpoint;\n+    }\n+\n+    public HelixZkClient.ZkConnectionConfig createZkConnectionConfig()\n+        throws IOException, InvalidRoutingDataException {\n+      // Convert to a single-realm HelixZkClient's ZkConnectionConfig\n+      if (_zkRealmShardingKey == null || _zkRealmShardingKey.isEmpty()) {\n+        throw new ZkClientException(\n+            \"Cannot create ZkConnectionConfig because ZK realm sharding key is either null or empty!\");\n+      }\n+\n+      String zkAddress;\n+      // Look up the ZK address for the given ZK realm sharding key\n+      if (_msdsEndpoint == null || _msdsEndpoint.isEmpty()) {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData()\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      } else {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData(_msdsEndpoint)\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      }\n+\n+      return new HelixZkClient.ZkConnectionConfig(zkAddress).setSessionTimeout(_sessionTimeout);\n+    }\n+\n+    public static class Builder {\n+      private RealmMode _realmMode;\n+      private String _zkRealmShardingKey;\n+      private String _msdsEndpoint;\n+      private int _sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n+\n+      public Builder() {\n+      }\n+\n+      public Builder setRealmMode(RealmMode mode) {\n+        _realmMode = mode;\n+        return this;\n+      }\n+\n+      public Builder setZkRealmShardingKey(String shardingKey) {\n+        _zkRealmShardingKey = shardingKey;\n+        return this;\n+      }\n+\n+      public Builder setMsdsEndpoint(String msdsEndpoint) {\n+        _msdsEndpoint = msdsEndpoint;\n+        return this;\n+      }\n+\n+      public Builder setSessionTimeout(int sessionTimeout) {\n+        _sessionTimeout = sessionTimeout;\n+        return this;\n+      }\n+\n+      public RealmAwareZkConnectionConfig build() {\n+        validate();\n+        return new RealmAwareZkConnectionConfig(this);\n+      }\n+\n+      /**\n+       * Validate the internal fields of the builder before creating an instance.\n+       */\n+      private void validate() {", "originalCommit": "59b39dd50cd8e786ea514156a7666f5c7e6f9507", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NzM0NA==", "url": "https://github.com/apache/helix/pull/838#discussion_r386797344", "bodyText": "This is just a config, not an actual API. So we just do checks. For APIs, we might set the internal variables accordingly to make the construction logic clean and simple.", "author": "narendly", "createdAt": "2020-03-03T04:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5MDU1Mw=="}], "type": "inlineReview"}]}