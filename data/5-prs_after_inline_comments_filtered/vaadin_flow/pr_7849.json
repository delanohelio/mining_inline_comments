{"pr_number": 7849, "pr_title": "Extract frontend executable functionality to a separate contextual class.", "pr_createdAt": "2020-03-19T12:34:56Z", "pr_url": "https://github.com/vaadin/flow/pull/7849", "timeline": [{"oid": "f670079cd11f02ff487652a3ef111f9664f6927b", "url": "https://github.com/vaadin/flow/commit/f670079cd11f02ff487652a3ef111f9664f6927b", "message": "Extract frontend executable functionality to a separate contextual\nclass.\n\nFixes #7771", "committedDate": "2020-03-19T12:34:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk5Njc2OA==", "url": "https://github.com/vaadin/flow/pull/7849#discussion_r394996768", "bodyText": "Invoke method(s) only conditionally.", "author": "vaadin-bot", "createdAt": "2020-03-19T12:42:38Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendTools.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Supplier;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.internal.Pair;\n+import com.vaadin.flow.server.Constants;\n+import com.vaadin.flow.server.frontend.FrontendUtils.UnknownVersionException;\n+import com.vaadin.flow.server.frontend.installer.InstallationException;\n+import com.vaadin.flow.server.frontend.installer.NodeInstaller;\n+import com.vaadin.flow.server.frontend.installer.ProxyConfig;\n+\n+import elemental.json.Json;\n+import elemental.json.JsonObject;\n+\n+/**\n+ * Provides access to frontend tools executables.\n+ *\n+ * @author Vaadin Ltd\n+ *\n+ */\n+public class FrontendTools {\n+\n+    private static final String DEFAULT_NODE_VERSION = \"v12.16.0\";\n+\n+    public static final String INSTALL_NODE_LOCALLY = \"%n  $ mvn com.github.eirslett:frontend-maven-plugin:1.7.6:install-node-and-npm -DnodeVersion=\\\"v12.14.0\\\" \";\n+\n+    private static final String NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. Please install the latest LTS version of node.js (with npm) either by:\"\n+            + \"%n  1) following the https://nodejs.org/en/download/ guide to install it globally. This is the recommended way.\"\n+            + \"%n  2) running the following Maven plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY\n+            + \"%n%nNote that in case you don't install it globally, you'll need to install it again for another Vaadin project.\"\n+            + \"%nIn case you have just installed node.js globally, it was not discovered, so you need to restart your system to get the path variables updated.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String LOCAL_NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. The %s directory already contains 'node' but it's either not a file \"\n+            + \"or not a 'node' executable. Please check %s directory and clean up it: remove '%s'.\"\n+            + \"%n then please run the app or maven goal again.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String BAD_VERSION = \"%n%n======================================================================================================\"\n+            + \"%nYour installed '%s' version (%s) is known to have problems.\" //\n+            + \"%nPlease update to a new one either:\"\n+            + \"%n  - by following the https://nodejs.org/en/download/ guide to install it globally\"\n+            + \"%s\"\n+            + \"%n  - or by running the frontend-maven-plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY + \"%n\" //\n+            + FrontendUtils.DISABLE_CHECK //\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final List<FrontendVersion> NPM_BLACKLISTED_VERSIONS = Arrays\n+            .asList(new FrontendVersion(\"6.11.0\"),\n+                    new FrontendVersion(\"6.11.1\"),\n+                    new FrontendVersion(\"6.11.2\"));\n+\n+    private static final String PNMP_INSTALLED_BY_NPM_FOLDER = \"node_modules/pnpm/\";\n+\n+    private static final String PNMP_INSTALLED_BY_NPM = PNMP_INSTALLED_BY_NPM_FOLDER\n+            + \"bin/pnpm.js\";\n+\n+    private static final FrontendVersion SUPPORTED_NODE_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NODE_MAJOR_VERSION,\n+            Constants.SUPPORTED_NODE_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NODE_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NODE_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NODE_MINOR_VERSION);\n+\n+    private static final FrontendVersion SUPPORTED_NPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_NPM_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NPM_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NPM_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NPM_MINOR_VERSION);\n+\n+    static final String NPMRC_NOPROXY_PROPERTY_KEY = \"noproxy\";\n+    static final String NPMRC_HTTPS_PROXY_PROPERTY_KEY = \"https-proxy\";\n+    static final String NPMRC_PROXY_PROPERTY_KEY = \"proxy\";\n+\n+    // Proxy config properties keys (for both system properties and environment\n+    // variables) can be either fully upper case or fully lower case\n+    static final String SYSTEM_NOPROXY_PROPERTY_KEY = \"NOPROXY\";\n+    static final String SYSTEM_HTTPS_PROXY_PROPERTY_KEY = \"HTTPS_PROXY\";\n+    static final String SYSTEM_HTTP_PROXY_PROPERTY_KEY = \"HTTP_PROXY\";\n+\n+    private static final FrontendVersion SUPPORTED_PNPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_PNPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_PNPM_MINOR_VERSION);\n+\n+    protected static final String DEFAULT_PNPM_VERSION = \"4.5.0\";\n+\n+    public static final String YELLOW = \"\\u001b[38;5;111m%s\\u001b[0m\";\n+\n+    private final String baseDir;\n+    private final Supplier<String> alternativeDirGetter;\n+\n+    private final FrontendToolsLocator frontendToolsLocator = new FrontendToolsLocator();\n+\n+    /**\n+     * Creates an instance of the class using the {@code baseDir} as a base\n+     * directory to locate the tools and the directory returned by the\n+     * {@code alternativeDirGetter} as a directory to install tools if they are\n+     * not found and use it as an alternative tools location.\n+     * <p>\n+     * If {@code alternativeDir} is {@code null} tools won't be installed.\n+     *\n+     *\n+     * @param baseDir\n+     *            the base directory to locate the tools, not {@code null}\n+     * @param alternativeDirGetter\n+     *            the getter for a directory where tools will be installed if\n+     *            they are not found globally or in the {@code baseDir}, may be\n+     *            {@code null}\n+     */\n+    public FrontendTools(String baseDir,\n+            Supplier<String> alternativeDirGetter) {\n+        this.baseDir = Objects.requireNonNull(baseDir);\n+        this.alternativeDirGetter = alternativeDirGetter;\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable.\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String getNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        return getExecutable(nodeCommands.getFirst(), nodeCommands.getSecond(),\n+                alternativeDirGetter != null).getAbsolutePath();\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable in the alternative dir of this class.\n+     *\n+     * <p>\n+     * The difference between {@link #getNodeExecutable()} and this method in a\n+     * search algorithm: {@link #getNodeExecutable()} first searches executable\n+     * in the base/alternative directory and fallbacks to the globally installed\n+     * if it's not found there. The {@link #forceAlternativeNodeExecutable()}\n+     * doesn't search for globally installed executable. It tries to find it in\n+     * the installation directory and if it's not found it downloads and\n+     * installs it there.\n+     *\n+     * @see #getNodeExecutable()\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String forceAlternativeNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        String dir = getAlternativeDir();\n+        File file = new File(dir, nodeCommands.getSecond());\n+        if (file.exists()) {\n+            if (!frontendToolsLocator.verifyTool(file)) {\n+                throw new IllegalStateException(\n+                        String.format(LOCAL_NODE_NOT_FOUND, dir, dir,\n+                                file.getAbsolutePath()));\n+            }\n+            return file.getAbsolutePath();\n+        } else {\n+            getLogger().info(\"Node not found in {}. Installing node {}.\", dir,\n+                    DEFAULT_NODE_VERSION);\n+            return installNode(DEFAULT_NODE_VERSION, null);\n+        }\n+    }\n+\n+    /**\n+     * Locate <code>npm</code> executable.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have npm running\n+     */\n+    public List<String> getNpmExecutable() {\n+        return getNpmExecutable(true);\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable.\n+     * <p>\n+     * In case pnpm is not available it will be installed.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     * @see #getPnpmExecutable( boolean)\n+     */\n+    public List<String> getPnpmExecutable() {\n+        ensurePnpm();\n+        List<String> pnpmCommand = getPnpmExecutable(baseDir, true);\n+        if (!pnpmCommand.isEmpty()) {\n+            pnpmCommand.add(\"--shamefully-hoist=true\");\n+        }\n+        return pnpmCommand;\n+    }\n+\n+    /**\n+     * Ensure that pnpm tool is available and install it if it's not.\n+     *\n+     */\n+    public void ensurePnpm() {\n+        if (isPnpmTooOldOrAbsent(baseDir)) {\n+            // copy the current content of package.json file to a temporary\n+            // location\n+            File packageJson = new File(baseDir, \"package.json\");\n+            File tempFile = null;\n+            boolean packageJsonExists = packageJson.canRead();\n+            if (packageJsonExists) {\n+                try {\n+                    tempFile = File.createTempFile(\"package\", \"json\");\n+                    FileUtils.copyFile(packageJson, tempFile);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't make a copy of package.json file\",\n+                            exception);\n+                }\n+                packageJson.delete();\n+            }\n+            try {\n+                JsonObject pkgJson = Json.createObject();\n+                pkgJson.put(\"name\", \"temp\");\n+                pkgJson.put(\"license\", \"UNLICENSED\");\n+                pkgJson.put(\"repository\", \"npm/npm\");\n+                pkgJson.put(\"description\",\n+                        \"Temporary package for pnpm installation\");\n+                FileUtils.writeLines(packageJson,\n+                        Collections.singletonList(pkgJson.toJson()));\n+                JsonObject lockJson = Json.createObject();\n+                lockJson.put(\"lockfileVersion\", 1);\n+                FileUtils.writeLines(new File(baseDir, \"package-lock.json\"),\n+                        Collections.singletonList(lockJson.toJson()));\n+            } catch (IOException e) {\n+                getLogger().warn(\"Couldn't create temporary package.json\");\n+            }\n+            LoggerFactory.getLogger(\"dev-updater\").info(\n+                    \"Installing pnpm v{} locally. It is suggested to install it globally using 'npm add -g pnpm@{}'\",\n+                    DEFAULT_PNPM_VERSION, DEFAULT_PNPM_VERSION);\n+            // install pnpm locally using npm\n+            installPnpm(getNpmExecutable(false));\n+\n+            // remove package-lock.json which contains pnpm as a dependency.\n+            new File(baseDir, \"package-lock.json\").delete();\n+\n+            if (packageJsonExists && tempFile != null) {\n+                // return back the original package.json\n+                try {\n+                    FileUtils.copyFile(tempFile, packageJson);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't restore package.json file back\",\n+                            exception);\n+                }\n+                tempFile.delete();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate that the found node and npm versions are new enough. Throws an\n+     * exception with a descriptive message if a version is too old.\n+     *\n+     * @param baseDir\n+     *            project root folder.\n+     */\n+    public void validateNodeAndNpmVersion() {\n+        try {\n+            List<String> nodeVersionCommand = new ArrayList<>();\n+            nodeVersionCommand.add(getNodeExecutable());\n+            nodeVersionCommand.add(\"--version\"); // NOSONAR\n+            FrontendVersion nodeVersion = FrontendUtils.getVersion(\"node\",\n+                    nodeVersionCommand);\n+            FrontendUtils.validateToolVersion(\"node\", nodeVersion,\n+                    SUPPORTED_NODE_VERSION, SHOULD_WORK_NODE_VERSION);\n+        } catch (UnknownVersionException e) {\n+            getLogger().warn(\"Error checking if node is new enough\", e);\n+        }\n+\n+        try {\n+            List<String> npmVersionCommand = new ArrayList<>(\n+                    getNpmExecutable(false));\n+            npmVersionCommand.add(\"--version\"); // NOSONAR\n+            FrontendVersion npmVersion = FrontendUtils.getVersion(\"npm\",\n+                    npmVersionCommand);\n+            FrontendUtils.validateToolVersion(\"npm\", npmVersion,\n+                    SUPPORTED_NPM_VERSION, SHOULD_WORK_NPM_VERSION);\n+            checkForFaultyNpmVersion(npmVersion);\n+        } catch (UnknownVersionException e) {\n+            getLogger().warn(\"Error checking if npm is new enough\", e);\n+        }\n+\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable if it's possible.\n+     * <p>\n+     * In case the tool is not found either {@link IllegalStateException} is\n+     * thrown or an empty list is returned depending on {@code failOnAbsence}\n+     * value.\n+     *\n+     * @param the\n+     *            directory to search local pnpm script\n+     *\n+     * @param failOnAbsence\n+     *            if {@code true} throws IllegalStateException if tool is not\n+     *            found, if {@code false} return an empty list if tool is not\n+     *            found\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     */\n+    protected List<String> getPnpmExecutable(String dir,\n+            boolean failOnAbsence) {\n+        // First try local pnpm JS script if it exists\n+        List<String> returnCommand = new ArrayList<>();\n+        Optional<File> localPnpmScript = getLocalPnpmScript(dir);\n+        if (localPnpmScript.isPresent()) {\n+            returnCommand.add(getNodeExecutable());\n+            returnCommand.add(localPnpmScript.get().getAbsolutePath());\n+        } else {\n+            // Otherwise look for regular `pnpm`\n+            String command = FrontendUtils.isWindows() ? \"pnpm.cmd\" : \"pnpm\";\n+            if (failOnAbsence) {\n+                returnCommand.add(\n+                        getExecutable(command, null, false).getAbsolutePath());\n+            } else {\n+                returnCommand.addAll(frontendToolsLocator.tryLocateTool(command)\n+                        .map(File::getPath).map(Collections::singletonList)\n+                        .orElse(Collections.emptyList()));\n+            }\n+        }\n+        return returnCommand;\n+    }\n+\n+    /**\n+     * Install node and npm.\n+     *\n+     * @param nodeVersion\n+     *            node version to install\n+     * @param downloadRoot\n+     *            optional download root for downloading node. May be a\n+     *            filesystem file or a URL see\n+     *            {@link NodeInstaller#setNodeDownloadRoot(URI)}.\n+     * @return node installation path\n+     */\n+    protected String installNode(String nodeVersion, URI downloadRoot) {\n+        NodeInstaller nodeInstaller = new NodeInstaller(\n+                new File(getAlternativeDir()), getProxies())\n+                        .setNodeVersion(nodeVersion);\n+        if (downloadRoot != null) {\n+            nodeInstaller.setNodeDownloadRoot(downloadRoot);\n+        }\n+\n+        try {\n+            nodeInstaller.install();\n+        } catch (InstallationException e) {\n+            throw new IllegalStateException(\"Failed to install Node\", e);\n+        }\n+\n+        return new File(nodeInstaller.getInstallDirectory(),\n+                getNodeCommands().getFirst()).toString();\n+    }\n+\n+    /**\n+     * Read list of configured proxies in order from system properties, .npmrc\n+     * file in the project root folder, .npmrc file in user root folder and\n+     * system environment variables.\n+     *\n+     * @param baseDir\n+     *            project root folder.\n+     * @return list of configured proxies\n+     */\n+    // Not private because of test\n+    protected List<ProxyConfig.Proxy> getProxies() {\n+        File projectNpmrc = new File(baseDir, \".npmrc\");\n+        File userNpmrc = new File(FileUtils.getUserDirectory(), \".npmrc\");\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>();\n+\n+        proxyList.addAll(readProxySettingsFromSystemProperties());\n+        proxyList.addAll(\n+                readProxySettingsFromNpmrcFile(\"project .npmrc\", projectNpmrc));\n+        proxyList.addAll(\n+                readProxySettingsFromNpmrcFile(\"user .npmrc\", userNpmrc));\n+        proxyList.addAll(readProxySettingsFromEnvironmentVariables());\n+\n+        return proxyList;\n+    }\n+\n+    void checkForFaultyNpmVersion(FrontendVersion npmVersion) {\n+        if (NPM_BLACKLISTED_VERSIONS.contains(npmVersion)) {\n+            String badNpmVersion = buildBadVersionString(\"npm\",\n+                    npmVersion.getFullVersion(),\n+                    \"by updating your global npm installation with `npm install -g npm@latest`\");\n+            throw new IllegalStateException(badNpmVersion);\n+        }\n+    }\n+\n+    private File getExecutable(String cmd, String defaultLocation,\n+            boolean installNode) {\n+        File file = null;\n+        try {\n+            if (defaultLocation == null) {\n+                file = frontendToolsLocator.tryLocateTool(cmd).orElse(null);\n+            } else {\n+                file = Arrays.asList(() -> baseDir, alternativeDirGetter)\n+                        .stream().map(Supplier::get)\n+                        .map(dir -> new File(dir, defaultLocation))\n+                        .filter(frontendToolsLocator::verifyTool).findFirst()\n+                        .orElseGet(() -> frontendToolsLocator.tryLocateTool(cmd)\n+                                .orElse(null));\n+            }\n+            if (file == null && installNode) {\n+                getLogger().info(\n+                        \"Couldn't find {}. Installing Node and NPM to {}.\", cmd,\n+                        installNode);\n+                return new File(installNode(DEFAULT_NODE_VERSION, null));\n+            }\n+        } catch (Exception e) { // NOSONAR\n+            // There are IOException coming from process fork\n+        }\n+        if (file == null) {\n+            throw new IllegalStateException(String.format(NODE_NOT_FOUND));\n+        }\n+        return file;\n+    }\n+\n+    private Pair<String, String> getNodeCommands() {\n+        if (FrontendUtils.isWindows()) {\n+            return new Pair<>(\"node.exe\", \"node/node.exe\");\n+        } else {\n+            return new Pair<>(\"node\", \"node/node\");\n+        }\n+    }\n+\n+    private Logger getLogger() {\n+        return LoggerFactory.getLogger(FrontendTools.class);\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromNpmrcFile(\n+            String fileDescription, File npmrc) {\n+        if (!npmrc.exists()) {\n+            return Collections.emptyList();\n+        }\n+\n+        try (FileReader fileReader = new FileReader(npmrc)) { // NOSONAR\n+            List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+            Properties properties = new Properties();\n+            properties.load(fileReader);\n+            String noproxy = properties.getProperty(NPMRC_NOPROXY_PROPERTY_KEY);\n+            if (noproxy != null)\n+                noproxy = noproxy.replaceAll(\",\", \"|\");\n+            String httpsProxyUrl = properties\n+                    .getProperty(NPMRC_HTTPS_PROXY_PROPERTY_KEY);\n+            if (httpsProxyUrl != null) {\n+                proxyList.add(new ProxyConfig.Proxy(\n+                        \"https-proxy - \" + fileDescription, httpsProxyUrl,\n+                        noproxy));\n+            }\n+            String proxyUrl = properties.getProperty(NPMRC_PROXY_PROPERTY_KEY);\n+            if (proxyUrl != null) {\n+                proxyList.add(new ProxyConfig.Proxy(\n+                        \"proxy - \" + fileDescription, proxyUrl, noproxy));\n+            }\n+            return proxyList;\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromSystemProperties() {\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+\n+        String noproxy = getNonNull(\n+                System.getProperty(SYSTEM_NOPROXY_PROPERTY_KEY),\n+                System.getProperty(SYSTEM_NOPROXY_PROPERTY_KEY.toLowerCase()));\n+        if (noproxy != null) {\n+            noproxy = noproxy.replaceAll(\",\", \"|\");\n+        }\n+\n+        String httpsProxyUrl = getNonNull(\n+                System.getProperty(SYSTEM_HTTPS_PROXY_PROPERTY_KEY),\n+                System.getProperty(\n+                        SYSTEM_HTTPS_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (httpsProxyUrl != null) {\n+            proxyList.add(new ProxyConfig.Proxy(\"https-proxy - system\",\n+                    httpsProxyUrl, noproxy));\n+        }\n+\n+        String proxyUrl = getNonNull(\n+                System.getProperty(SYSTEM_HTTP_PROXY_PROPERTY_KEY),\n+                System.getProperty(\n+                        SYSTEM_HTTP_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (proxyUrl != null) {\n+            proxyList.add(\n+                    new ProxyConfig.Proxy(\"proxy - system\", proxyUrl, noproxy));\n+        }\n+\n+        return proxyList;\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromEnvironmentVariables() {\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+\n+        String noproxy = getNonNull(System.getenv(SYSTEM_NOPROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_NOPROXY_PROPERTY_KEY.toLowerCase()));\n+        if (noproxy != null) {\n+            noproxy = noproxy.replaceAll(\",\", \"|\");\n+        }\n+\n+        String httpsProxyUrl = getNonNull(\n+                System.getenv(SYSTEM_HTTPS_PROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_HTTPS_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (httpsProxyUrl != null) {\n+            proxyList.add(new ProxyConfig.Proxy(\"https-proxy - env\",\n+                    httpsProxyUrl, noproxy));\n+        }\n+\n+        String proxyUrl = getNonNull(\n+                System.getenv(SYSTEM_HTTP_PROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_HTTP_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (proxyUrl != null) {\n+            proxyList.add(\n+                    new ProxyConfig.Proxy(\"proxy - env\", proxyUrl, noproxy));\n+        }\n+\n+        return proxyList;\n+    }\n+\n+    /**\n+     * Get the first non null value from the given array.\n+     *\n+     * @param valueArray\n+     *            array of values to get non null from\n+     * @return first non null value or null if no values found\n+     */\n+    private String getNonNull(String... valueArray) {\n+        for (String value : valueArray) {\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private List<String> getNpmExecutable(boolean removePnpmLock) {\n+        List<String> returnCommand = getNpmScriptCommand(baseDir);\n+        if (returnCommand.isEmpty()) {\n+            returnCommand = getNpmScriptCommand(getAlternativeDir());\n+        }\n+\n+        if (returnCommand.isEmpty()) {\n+            // Otherwise look for regular `npm`\n+            String command = FrontendUtils.isWindows() ? \"npm.cmd\" : \"npm\";\n+            returnCommand\n+                    .add(getExecutable(command, null, true).getAbsolutePath());\n+        }\n+        returnCommand.add(\"--no-update-notifier\");\n+        returnCommand.add(\"--no-audit\");\n+\n+        if (removePnpmLock) {\n+            // remove pnpm-lock.yaml which contains pnpm as a dependency.\n+            new File(baseDir, \"pnpm-lock.yaml\").delete();\n+        }\n+\n+        return returnCommand;\n+    }\n+\n+    private List<String> getNpmScriptCommand(String dir) {\n+        // If `node` is not found in PATH, `node/node_modules/npm/bin/npm` will\n+        // not work because it's a shell or windows script that looks for node\n+        // and will fail. Thus we look for the `npm-cli` node script instead\n+        File file = new File(dir, \"node/node_modules/npm/bin/npm-cli.js\");\n+        List<String> returnCommand = new ArrayList<>();\n+        if (file.canRead()) {\n+            // We return a two element list with node binary and npm-cli script\n+            returnCommand.add(getNodeExecutable());\n+            returnCommand.add(file.getAbsolutePath());\n+        }\n+        return returnCommand;\n+    }\n+\n+    private boolean isPnpmTooOldOrAbsent(String dir) {\n+        final List<String> pnpmCommand = getPnpmExecutable(dir, false);\n+        if (!pnpmCommand.isEmpty()) {\n+            // check whether globally or locally installed pnpm is new enough\n+            try {\n+                List<String> versionCmd = new ArrayList<>(pnpmCommand);\n+                versionCmd.add(\"--version\"); // NOSONAR\n+                FrontendVersion pnpmVersion = FrontendUtils.getVersion(\"pnpm\",\n+                        versionCmd);\n+                if (FrontendUtils.isVersionAtLeast(pnpmVersion,\n+                        SUPPORTED_PNPM_VERSION)) {\n+                    return false;\n+                } else {\n+                    getLogger().warn(String.format(", "originalCommit": "f670079cd11f02ff487652a3ef111f9664f6927b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk5Njc4Mg==", "url": "https://github.com/vaadin/flow/pull/7849#discussion_r394996782", "bodyText": "Do something with the \"boolean\" value returned by \"delete\".", "author": "vaadin-bot", "createdAt": "2020-03-19T12:42:39Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendTools.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Supplier;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.internal.Pair;\n+import com.vaadin.flow.server.Constants;\n+import com.vaadin.flow.server.frontend.FrontendUtils.UnknownVersionException;\n+import com.vaadin.flow.server.frontend.installer.InstallationException;\n+import com.vaadin.flow.server.frontend.installer.NodeInstaller;\n+import com.vaadin.flow.server.frontend.installer.ProxyConfig;\n+\n+import elemental.json.Json;\n+import elemental.json.JsonObject;\n+\n+/**\n+ * Provides access to frontend tools executables.\n+ *\n+ * @author Vaadin Ltd\n+ *\n+ */\n+public class FrontendTools {\n+\n+    private static final String DEFAULT_NODE_VERSION = \"v12.16.0\";\n+\n+    public static final String INSTALL_NODE_LOCALLY = \"%n  $ mvn com.github.eirslett:frontend-maven-plugin:1.7.6:install-node-and-npm -DnodeVersion=\\\"v12.14.0\\\" \";\n+\n+    private static final String NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. Please install the latest LTS version of node.js (with npm) either by:\"\n+            + \"%n  1) following the https://nodejs.org/en/download/ guide to install it globally. This is the recommended way.\"\n+            + \"%n  2) running the following Maven plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY\n+            + \"%n%nNote that in case you don't install it globally, you'll need to install it again for another Vaadin project.\"\n+            + \"%nIn case you have just installed node.js globally, it was not discovered, so you need to restart your system to get the path variables updated.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String LOCAL_NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. The %s directory already contains 'node' but it's either not a file \"\n+            + \"or not a 'node' executable. Please check %s directory and clean up it: remove '%s'.\"\n+            + \"%n then please run the app or maven goal again.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String BAD_VERSION = \"%n%n======================================================================================================\"\n+            + \"%nYour installed '%s' version (%s) is known to have problems.\" //\n+            + \"%nPlease update to a new one either:\"\n+            + \"%n  - by following the https://nodejs.org/en/download/ guide to install it globally\"\n+            + \"%s\"\n+            + \"%n  - or by running the frontend-maven-plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY + \"%n\" //\n+            + FrontendUtils.DISABLE_CHECK //\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final List<FrontendVersion> NPM_BLACKLISTED_VERSIONS = Arrays\n+            .asList(new FrontendVersion(\"6.11.0\"),\n+                    new FrontendVersion(\"6.11.1\"),\n+                    new FrontendVersion(\"6.11.2\"));\n+\n+    private static final String PNMP_INSTALLED_BY_NPM_FOLDER = \"node_modules/pnpm/\";\n+\n+    private static final String PNMP_INSTALLED_BY_NPM = PNMP_INSTALLED_BY_NPM_FOLDER\n+            + \"bin/pnpm.js\";\n+\n+    private static final FrontendVersion SUPPORTED_NODE_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NODE_MAJOR_VERSION,\n+            Constants.SUPPORTED_NODE_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NODE_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NODE_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NODE_MINOR_VERSION);\n+\n+    private static final FrontendVersion SUPPORTED_NPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_NPM_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NPM_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NPM_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NPM_MINOR_VERSION);\n+\n+    static final String NPMRC_NOPROXY_PROPERTY_KEY = \"noproxy\";\n+    static final String NPMRC_HTTPS_PROXY_PROPERTY_KEY = \"https-proxy\";\n+    static final String NPMRC_PROXY_PROPERTY_KEY = \"proxy\";\n+\n+    // Proxy config properties keys (for both system properties and environment\n+    // variables) can be either fully upper case or fully lower case\n+    static final String SYSTEM_NOPROXY_PROPERTY_KEY = \"NOPROXY\";\n+    static final String SYSTEM_HTTPS_PROXY_PROPERTY_KEY = \"HTTPS_PROXY\";\n+    static final String SYSTEM_HTTP_PROXY_PROPERTY_KEY = \"HTTP_PROXY\";\n+\n+    private static final FrontendVersion SUPPORTED_PNPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_PNPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_PNPM_MINOR_VERSION);\n+\n+    protected static final String DEFAULT_PNPM_VERSION = \"4.5.0\";\n+\n+    public static final String YELLOW = \"\\u001b[38;5;111m%s\\u001b[0m\";\n+\n+    private final String baseDir;\n+    private final Supplier<String> alternativeDirGetter;\n+\n+    private final FrontendToolsLocator frontendToolsLocator = new FrontendToolsLocator();\n+\n+    /**\n+     * Creates an instance of the class using the {@code baseDir} as a base\n+     * directory to locate the tools and the directory returned by the\n+     * {@code alternativeDirGetter} as a directory to install tools if they are\n+     * not found and use it as an alternative tools location.\n+     * <p>\n+     * If {@code alternativeDir} is {@code null} tools won't be installed.\n+     *\n+     *\n+     * @param baseDir\n+     *            the base directory to locate the tools, not {@code null}\n+     * @param alternativeDirGetter\n+     *            the getter for a directory where tools will be installed if\n+     *            they are not found globally or in the {@code baseDir}, may be\n+     *            {@code null}\n+     */\n+    public FrontendTools(String baseDir,\n+            Supplier<String> alternativeDirGetter) {\n+        this.baseDir = Objects.requireNonNull(baseDir);\n+        this.alternativeDirGetter = alternativeDirGetter;\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable.\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String getNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        return getExecutable(nodeCommands.getFirst(), nodeCommands.getSecond(),\n+                alternativeDirGetter != null).getAbsolutePath();\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable in the alternative dir of this class.\n+     *\n+     * <p>\n+     * The difference between {@link #getNodeExecutable()} and this method in a\n+     * search algorithm: {@link #getNodeExecutable()} first searches executable\n+     * in the base/alternative directory and fallbacks to the globally installed\n+     * if it's not found there. The {@link #forceAlternativeNodeExecutable()}\n+     * doesn't search for globally installed executable. It tries to find it in\n+     * the installation directory and if it's not found it downloads and\n+     * installs it there.\n+     *\n+     * @see #getNodeExecutable()\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String forceAlternativeNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        String dir = getAlternativeDir();\n+        File file = new File(dir, nodeCommands.getSecond());\n+        if (file.exists()) {\n+            if (!frontendToolsLocator.verifyTool(file)) {\n+                throw new IllegalStateException(\n+                        String.format(LOCAL_NODE_NOT_FOUND, dir, dir,\n+                                file.getAbsolutePath()));\n+            }\n+            return file.getAbsolutePath();\n+        } else {\n+            getLogger().info(\"Node not found in {}. Installing node {}.\", dir,\n+                    DEFAULT_NODE_VERSION);\n+            return installNode(DEFAULT_NODE_VERSION, null);\n+        }\n+    }\n+\n+    /**\n+     * Locate <code>npm</code> executable.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have npm running\n+     */\n+    public List<String> getNpmExecutable() {\n+        return getNpmExecutable(true);\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable.\n+     * <p>\n+     * In case pnpm is not available it will be installed.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     * @see #getPnpmExecutable( boolean)\n+     */\n+    public List<String> getPnpmExecutable() {\n+        ensurePnpm();\n+        List<String> pnpmCommand = getPnpmExecutable(baseDir, true);\n+        if (!pnpmCommand.isEmpty()) {\n+            pnpmCommand.add(\"--shamefully-hoist=true\");\n+        }\n+        return pnpmCommand;\n+    }\n+\n+    /**\n+     * Ensure that pnpm tool is available and install it if it's not.\n+     *\n+     */\n+    public void ensurePnpm() {\n+        if (isPnpmTooOldOrAbsent(baseDir)) {\n+            // copy the current content of package.json file to a temporary\n+            // location\n+            File packageJson = new File(baseDir, \"package.json\");\n+            File tempFile = null;\n+            boolean packageJsonExists = packageJson.canRead();\n+            if (packageJsonExists) {\n+                try {\n+                    tempFile = File.createTempFile(\"package\", \"json\");\n+                    FileUtils.copyFile(packageJson, tempFile);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't make a copy of package.json file\",\n+                            exception);\n+                }\n+                packageJson.delete();\n+            }\n+            try {\n+                JsonObject pkgJson = Json.createObject();\n+                pkgJson.put(\"name\", \"temp\");\n+                pkgJson.put(\"license\", \"UNLICENSED\");\n+                pkgJson.put(\"repository\", \"npm/npm\");\n+                pkgJson.put(\"description\",\n+                        \"Temporary package for pnpm installation\");\n+                FileUtils.writeLines(packageJson,\n+                        Collections.singletonList(pkgJson.toJson()));\n+                JsonObject lockJson = Json.createObject();\n+                lockJson.put(\"lockfileVersion\", 1);\n+                FileUtils.writeLines(new File(baseDir, \"package-lock.json\"),\n+                        Collections.singletonList(lockJson.toJson()));\n+            } catch (IOException e) {\n+                getLogger().warn(\"Couldn't create temporary package.json\");\n+            }\n+            LoggerFactory.getLogger(\"dev-updater\").info(\n+                    \"Installing pnpm v{} locally. It is suggested to install it globally using 'npm add -g pnpm@{}'\",\n+                    DEFAULT_PNPM_VERSION, DEFAULT_PNPM_VERSION);\n+            // install pnpm locally using npm\n+            installPnpm(getNpmExecutable(false));\n+\n+            // remove package-lock.json which contains pnpm as a dependency.\n+            new File(baseDir, \"package-lock.json\").delete();", "originalCommit": "f670079cd11f02ff487652a3ef111f9664f6927b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk5Njc5NQ==", "url": "https://github.com/vaadin/flow/pull/7849#discussion_r394996795", "bodyText": "Invoke method(s) only conditionally.", "author": "vaadin-bot", "createdAt": "2020-03-19T12:42:40Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendTools.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Supplier;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.internal.Pair;\n+import com.vaadin.flow.server.Constants;\n+import com.vaadin.flow.server.frontend.FrontendUtils.UnknownVersionException;\n+import com.vaadin.flow.server.frontend.installer.InstallationException;\n+import com.vaadin.flow.server.frontend.installer.NodeInstaller;\n+import com.vaadin.flow.server.frontend.installer.ProxyConfig;\n+\n+import elemental.json.Json;\n+import elemental.json.JsonObject;\n+\n+/**\n+ * Provides access to frontend tools executables.\n+ *\n+ * @author Vaadin Ltd\n+ *\n+ */\n+public class FrontendTools {\n+\n+    private static final String DEFAULT_NODE_VERSION = \"v12.16.0\";\n+\n+    public static final String INSTALL_NODE_LOCALLY = \"%n  $ mvn com.github.eirslett:frontend-maven-plugin:1.7.6:install-node-and-npm -DnodeVersion=\\\"v12.14.0\\\" \";\n+\n+    private static final String NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. Please install the latest LTS version of node.js (with npm) either by:\"\n+            + \"%n  1) following the https://nodejs.org/en/download/ guide to install it globally. This is the recommended way.\"\n+            + \"%n  2) running the following Maven plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY\n+            + \"%n%nNote that in case you don't install it globally, you'll need to install it again for another Vaadin project.\"\n+            + \"%nIn case you have just installed node.js globally, it was not discovered, so you need to restart your system to get the path variables updated.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String LOCAL_NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. The %s directory already contains 'node' but it's either not a file \"\n+            + \"or not a 'node' executable. Please check %s directory and clean up it: remove '%s'.\"\n+            + \"%n then please run the app or maven goal again.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String BAD_VERSION = \"%n%n======================================================================================================\"\n+            + \"%nYour installed '%s' version (%s) is known to have problems.\" //\n+            + \"%nPlease update to a new one either:\"\n+            + \"%n  - by following the https://nodejs.org/en/download/ guide to install it globally\"\n+            + \"%s\"\n+            + \"%n  - or by running the frontend-maven-plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY + \"%n\" //\n+            + FrontendUtils.DISABLE_CHECK //\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final List<FrontendVersion> NPM_BLACKLISTED_VERSIONS = Arrays\n+            .asList(new FrontendVersion(\"6.11.0\"),\n+                    new FrontendVersion(\"6.11.1\"),\n+                    new FrontendVersion(\"6.11.2\"));\n+\n+    private static final String PNMP_INSTALLED_BY_NPM_FOLDER = \"node_modules/pnpm/\";\n+\n+    private static final String PNMP_INSTALLED_BY_NPM = PNMP_INSTALLED_BY_NPM_FOLDER\n+            + \"bin/pnpm.js\";\n+\n+    private static final FrontendVersion SUPPORTED_NODE_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NODE_MAJOR_VERSION,\n+            Constants.SUPPORTED_NODE_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NODE_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NODE_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NODE_MINOR_VERSION);\n+\n+    private static final FrontendVersion SUPPORTED_NPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_NPM_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NPM_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NPM_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NPM_MINOR_VERSION);\n+\n+    static final String NPMRC_NOPROXY_PROPERTY_KEY = \"noproxy\";\n+    static final String NPMRC_HTTPS_PROXY_PROPERTY_KEY = \"https-proxy\";\n+    static final String NPMRC_PROXY_PROPERTY_KEY = \"proxy\";\n+\n+    // Proxy config properties keys (for both system properties and environment\n+    // variables) can be either fully upper case or fully lower case\n+    static final String SYSTEM_NOPROXY_PROPERTY_KEY = \"NOPROXY\";\n+    static final String SYSTEM_HTTPS_PROXY_PROPERTY_KEY = \"HTTPS_PROXY\";\n+    static final String SYSTEM_HTTP_PROXY_PROPERTY_KEY = \"HTTP_PROXY\";\n+\n+    private static final FrontendVersion SUPPORTED_PNPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_PNPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_PNPM_MINOR_VERSION);\n+\n+    protected static final String DEFAULT_PNPM_VERSION = \"4.5.0\";\n+\n+    public static final String YELLOW = \"\\u001b[38;5;111m%s\\u001b[0m\";\n+\n+    private final String baseDir;\n+    private final Supplier<String> alternativeDirGetter;\n+\n+    private final FrontendToolsLocator frontendToolsLocator = new FrontendToolsLocator();\n+\n+    /**\n+     * Creates an instance of the class using the {@code baseDir} as a base\n+     * directory to locate the tools and the directory returned by the\n+     * {@code alternativeDirGetter} as a directory to install tools if they are\n+     * not found and use it as an alternative tools location.\n+     * <p>\n+     * If {@code alternativeDir} is {@code null} tools won't be installed.\n+     *\n+     *\n+     * @param baseDir\n+     *            the base directory to locate the tools, not {@code null}\n+     * @param alternativeDirGetter\n+     *            the getter for a directory where tools will be installed if\n+     *            they are not found globally or in the {@code baseDir}, may be\n+     *            {@code null}\n+     */\n+    public FrontendTools(String baseDir,\n+            Supplier<String> alternativeDirGetter) {\n+        this.baseDir = Objects.requireNonNull(baseDir);\n+        this.alternativeDirGetter = alternativeDirGetter;\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable.\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String getNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        return getExecutable(nodeCommands.getFirst(), nodeCommands.getSecond(),\n+                alternativeDirGetter != null).getAbsolutePath();\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable in the alternative dir of this class.\n+     *\n+     * <p>\n+     * The difference between {@link #getNodeExecutable()} and this method in a\n+     * search algorithm: {@link #getNodeExecutable()} first searches executable\n+     * in the base/alternative directory and fallbacks to the globally installed\n+     * if it's not found there. The {@link #forceAlternativeNodeExecutable()}\n+     * doesn't search for globally installed executable. It tries to find it in\n+     * the installation directory and if it's not found it downloads and\n+     * installs it there.\n+     *\n+     * @see #getNodeExecutable()\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String forceAlternativeNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        String dir = getAlternativeDir();\n+        File file = new File(dir, nodeCommands.getSecond());\n+        if (file.exists()) {\n+            if (!frontendToolsLocator.verifyTool(file)) {\n+                throw new IllegalStateException(\n+                        String.format(LOCAL_NODE_NOT_FOUND, dir, dir,\n+                                file.getAbsolutePath()));\n+            }\n+            return file.getAbsolutePath();\n+        } else {\n+            getLogger().info(\"Node not found in {}. Installing node {}.\", dir,\n+                    DEFAULT_NODE_VERSION);\n+            return installNode(DEFAULT_NODE_VERSION, null);\n+        }\n+    }\n+\n+    /**\n+     * Locate <code>npm</code> executable.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have npm running\n+     */\n+    public List<String> getNpmExecutable() {\n+        return getNpmExecutable(true);\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable.\n+     * <p>\n+     * In case pnpm is not available it will be installed.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     * @see #getPnpmExecutable( boolean)\n+     */\n+    public List<String> getPnpmExecutable() {\n+        ensurePnpm();\n+        List<String> pnpmCommand = getPnpmExecutable(baseDir, true);\n+        if (!pnpmCommand.isEmpty()) {\n+            pnpmCommand.add(\"--shamefully-hoist=true\");\n+        }\n+        return pnpmCommand;\n+    }\n+\n+    /**\n+     * Ensure that pnpm tool is available and install it if it's not.\n+     *\n+     */\n+    public void ensurePnpm() {\n+        if (isPnpmTooOldOrAbsent(baseDir)) {\n+            // copy the current content of package.json file to a temporary\n+            // location\n+            File packageJson = new File(baseDir, \"package.json\");\n+            File tempFile = null;\n+            boolean packageJsonExists = packageJson.canRead();\n+            if (packageJsonExists) {\n+                try {\n+                    tempFile = File.createTempFile(\"package\", \"json\");\n+                    FileUtils.copyFile(packageJson, tempFile);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't make a copy of package.json file\",\n+                            exception);\n+                }\n+                packageJson.delete();\n+            }\n+            try {\n+                JsonObject pkgJson = Json.createObject();\n+                pkgJson.put(\"name\", \"temp\");\n+                pkgJson.put(\"license\", \"UNLICENSED\");\n+                pkgJson.put(\"repository\", \"npm/npm\");\n+                pkgJson.put(\"description\",\n+                        \"Temporary package for pnpm installation\");\n+                FileUtils.writeLines(packageJson,\n+                        Collections.singletonList(pkgJson.toJson()));\n+                JsonObject lockJson = Json.createObject();\n+                lockJson.put(\"lockfileVersion\", 1);\n+                FileUtils.writeLines(new File(baseDir, \"package-lock.json\"),\n+                        Collections.singletonList(lockJson.toJson()));\n+            } catch (IOException e) {\n+                getLogger().warn(\"Couldn't create temporary package.json\");\n+            }\n+            LoggerFactory.getLogger(\"dev-updater\").info(\n+                    \"Installing pnpm v{} locally. It is suggested to install it globally using 'npm add -g pnpm@{}'\",\n+                    DEFAULT_PNPM_VERSION, DEFAULT_PNPM_VERSION);\n+            // install pnpm locally using npm\n+            installPnpm(getNpmExecutable(false));\n+\n+            // remove package-lock.json which contains pnpm as a dependency.\n+            new File(baseDir, \"package-lock.json\").delete();\n+\n+            if (packageJsonExists && tempFile != null) {\n+                // return back the original package.json\n+                try {\n+                    FileUtils.copyFile(tempFile, packageJson);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't restore package.json file back\",\n+                            exception);\n+                }\n+                tempFile.delete();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate that the found node and npm versions are new enough. Throws an\n+     * exception with a descriptive message if a version is too old.\n+     *\n+     * @param baseDir\n+     *            project root folder.\n+     */\n+    public void validateNodeAndNpmVersion() {\n+        try {\n+            List<String> nodeVersionCommand = new ArrayList<>();\n+            nodeVersionCommand.add(getNodeExecutable());\n+            nodeVersionCommand.add(\"--version\"); // NOSONAR\n+            FrontendVersion nodeVersion = FrontendUtils.getVersion(\"node\",\n+                    nodeVersionCommand);\n+            FrontendUtils.validateToolVersion(\"node\", nodeVersion,\n+                    SUPPORTED_NODE_VERSION, SHOULD_WORK_NODE_VERSION);\n+        } catch (UnknownVersionException e) {\n+            getLogger().warn(\"Error checking if node is new enough\", e);\n+        }\n+\n+        try {\n+            List<String> npmVersionCommand = new ArrayList<>(\n+                    getNpmExecutable(false));\n+            npmVersionCommand.add(\"--version\"); // NOSONAR\n+            FrontendVersion npmVersion = FrontendUtils.getVersion(\"npm\",\n+                    npmVersionCommand);\n+            FrontendUtils.validateToolVersion(\"npm\", npmVersion,\n+                    SUPPORTED_NPM_VERSION, SHOULD_WORK_NPM_VERSION);\n+            checkForFaultyNpmVersion(npmVersion);\n+        } catch (UnknownVersionException e) {\n+            getLogger().warn(\"Error checking if npm is new enough\", e);\n+        }\n+\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable if it's possible.\n+     * <p>\n+     * In case the tool is not found either {@link IllegalStateException} is\n+     * thrown or an empty list is returned depending on {@code failOnAbsence}\n+     * value.\n+     *\n+     * @param the\n+     *            directory to search local pnpm script\n+     *\n+     * @param failOnAbsence\n+     *            if {@code true} throws IllegalStateException if tool is not\n+     *            found, if {@code false} return an empty list if tool is not\n+     *            found\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     */\n+    protected List<String> getPnpmExecutable(String dir,\n+            boolean failOnAbsence) {\n+        // First try local pnpm JS script if it exists\n+        List<String> returnCommand = new ArrayList<>();\n+        Optional<File> localPnpmScript = getLocalPnpmScript(dir);\n+        if (localPnpmScript.isPresent()) {\n+            returnCommand.add(getNodeExecutable());\n+            returnCommand.add(localPnpmScript.get().getAbsolutePath());\n+        } else {\n+            // Otherwise look for regular `pnpm`\n+            String command = FrontendUtils.isWindows() ? \"pnpm.cmd\" : \"pnpm\";\n+            if (failOnAbsence) {\n+                returnCommand.add(\n+                        getExecutable(command, null, false).getAbsolutePath());\n+            } else {\n+                returnCommand.addAll(frontendToolsLocator.tryLocateTool(command)\n+                        .map(File::getPath).map(Collections::singletonList)\n+                        .orElse(Collections.emptyList()));\n+            }\n+        }\n+        return returnCommand;\n+    }\n+\n+    /**\n+     * Install node and npm.\n+     *\n+     * @param nodeVersion\n+     *            node version to install\n+     * @param downloadRoot\n+     *            optional download root for downloading node. May be a\n+     *            filesystem file or a URL see\n+     *            {@link NodeInstaller#setNodeDownloadRoot(URI)}.\n+     * @return node installation path\n+     */\n+    protected String installNode(String nodeVersion, URI downloadRoot) {\n+        NodeInstaller nodeInstaller = new NodeInstaller(\n+                new File(getAlternativeDir()), getProxies())\n+                        .setNodeVersion(nodeVersion);\n+        if (downloadRoot != null) {\n+            nodeInstaller.setNodeDownloadRoot(downloadRoot);\n+        }\n+\n+        try {\n+            nodeInstaller.install();\n+        } catch (InstallationException e) {\n+            throw new IllegalStateException(\"Failed to install Node\", e);\n+        }\n+\n+        return new File(nodeInstaller.getInstallDirectory(),\n+                getNodeCommands().getFirst()).toString();\n+    }\n+\n+    /**\n+     * Read list of configured proxies in order from system properties, .npmrc\n+     * file in the project root folder, .npmrc file in user root folder and\n+     * system environment variables.\n+     *\n+     * @param baseDir\n+     *            project root folder.\n+     * @return list of configured proxies\n+     */\n+    // Not private because of test\n+    protected List<ProxyConfig.Proxy> getProxies() {\n+        File projectNpmrc = new File(baseDir, \".npmrc\");\n+        File userNpmrc = new File(FileUtils.getUserDirectory(), \".npmrc\");\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>();\n+\n+        proxyList.addAll(readProxySettingsFromSystemProperties());\n+        proxyList.addAll(\n+                readProxySettingsFromNpmrcFile(\"project .npmrc\", projectNpmrc));\n+        proxyList.addAll(\n+                readProxySettingsFromNpmrcFile(\"user .npmrc\", userNpmrc));\n+        proxyList.addAll(readProxySettingsFromEnvironmentVariables());\n+\n+        return proxyList;\n+    }\n+\n+    void checkForFaultyNpmVersion(FrontendVersion npmVersion) {\n+        if (NPM_BLACKLISTED_VERSIONS.contains(npmVersion)) {\n+            String badNpmVersion = buildBadVersionString(\"npm\",\n+                    npmVersion.getFullVersion(),\n+                    \"by updating your global npm installation with `npm install -g npm@latest`\");\n+            throw new IllegalStateException(badNpmVersion);\n+        }\n+    }\n+\n+    private File getExecutable(String cmd, String defaultLocation,\n+            boolean installNode) {\n+        File file = null;\n+        try {\n+            if (defaultLocation == null) {\n+                file = frontendToolsLocator.tryLocateTool(cmd).orElse(null);\n+            } else {\n+                file = Arrays.asList(() -> baseDir, alternativeDirGetter)\n+                        .stream().map(Supplier::get)\n+                        .map(dir -> new File(dir, defaultLocation))\n+                        .filter(frontendToolsLocator::verifyTool).findFirst()\n+                        .orElseGet(() -> frontendToolsLocator.tryLocateTool(cmd)\n+                                .orElse(null));\n+            }\n+            if (file == null && installNode) {\n+                getLogger().info(\n+                        \"Couldn't find {}. Installing Node and NPM to {}.\", cmd,\n+                        installNode);\n+                return new File(installNode(DEFAULT_NODE_VERSION, null));\n+            }\n+        } catch (Exception e) { // NOSONAR\n+            // There are IOException coming from process fork\n+        }\n+        if (file == null) {\n+            throw new IllegalStateException(String.format(NODE_NOT_FOUND));\n+        }\n+        return file;\n+    }\n+\n+    private Pair<String, String> getNodeCommands() {\n+        if (FrontendUtils.isWindows()) {\n+            return new Pair<>(\"node.exe\", \"node/node.exe\");\n+        } else {\n+            return new Pair<>(\"node\", \"node/node\");\n+        }\n+    }\n+\n+    private Logger getLogger() {\n+        return LoggerFactory.getLogger(FrontendTools.class);\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromNpmrcFile(\n+            String fileDescription, File npmrc) {\n+        if (!npmrc.exists()) {\n+            return Collections.emptyList();\n+        }\n+\n+        try (FileReader fileReader = new FileReader(npmrc)) { // NOSONAR\n+            List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+            Properties properties = new Properties();\n+            properties.load(fileReader);\n+            String noproxy = properties.getProperty(NPMRC_NOPROXY_PROPERTY_KEY);\n+            if (noproxy != null)\n+                noproxy = noproxy.replaceAll(\",\", \"|\");\n+            String httpsProxyUrl = properties\n+                    .getProperty(NPMRC_HTTPS_PROXY_PROPERTY_KEY);\n+            if (httpsProxyUrl != null) {\n+                proxyList.add(new ProxyConfig.Proxy(\n+                        \"https-proxy - \" + fileDescription, httpsProxyUrl,\n+                        noproxy));\n+            }\n+            String proxyUrl = properties.getProperty(NPMRC_PROXY_PROPERTY_KEY);\n+            if (proxyUrl != null) {\n+                proxyList.add(new ProxyConfig.Proxy(\n+                        \"proxy - \" + fileDescription, proxyUrl, noproxy));\n+            }\n+            return proxyList;\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromSystemProperties() {\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+\n+        String noproxy = getNonNull(\n+                System.getProperty(SYSTEM_NOPROXY_PROPERTY_KEY),\n+                System.getProperty(SYSTEM_NOPROXY_PROPERTY_KEY.toLowerCase()));\n+        if (noproxy != null) {\n+            noproxy = noproxy.replaceAll(\",\", \"|\");\n+        }\n+\n+        String httpsProxyUrl = getNonNull(\n+                System.getProperty(SYSTEM_HTTPS_PROXY_PROPERTY_KEY),\n+                System.getProperty(\n+                        SYSTEM_HTTPS_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (httpsProxyUrl != null) {\n+            proxyList.add(new ProxyConfig.Proxy(\"https-proxy - system\",\n+                    httpsProxyUrl, noproxy));\n+        }\n+\n+        String proxyUrl = getNonNull(\n+                System.getProperty(SYSTEM_HTTP_PROXY_PROPERTY_KEY),\n+                System.getProperty(\n+                        SYSTEM_HTTP_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (proxyUrl != null) {\n+            proxyList.add(\n+                    new ProxyConfig.Proxy(\"proxy - system\", proxyUrl, noproxy));\n+        }\n+\n+        return proxyList;\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromEnvironmentVariables() {\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+\n+        String noproxy = getNonNull(System.getenv(SYSTEM_NOPROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_NOPROXY_PROPERTY_KEY.toLowerCase()));\n+        if (noproxy != null) {\n+            noproxy = noproxy.replaceAll(\",\", \"|\");\n+        }\n+\n+        String httpsProxyUrl = getNonNull(\n+                System.getenv(SYSTEM_HTTPS_PROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_HTTPS_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (httpsProxyUrl != null) {\n+            proxyList.add(new ProxyConfig.Proxy(\"https-proxy - env\",\n+                    httpsProxyUrl, noproxy));\n+        }\n+\n+        String proxyUrl = getNonNull(\n+                System.getenv(SYSTEM_HTTP_PROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_HTTP_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (proxyUrl != null) {\n+            proxyList.add(\n+                    new ProxyConfig.Proxy(\"proxy - env\", proxyUrl, noproxy));\n+        }\n+\n+        return proxyList;\n+    }\n+\n+    /**\n+     * Get the first non null value from the given array.\n+     *\n+     * @param valueArray\n+     *            array of values to get non null from\n+     * @return first non null value or null if no values found\n+     */\n+    private String getNonNull(String... valueArray) {\n+        for (String value : valueArray) {\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private List<String> getNpmExecutable(boolean removePnpmLock) {\n+        List<String> returnCommand = getNpmScriptCommand(baseDir);\n+        if (returnCommand.isEmpty()) {\n+            returnCommand = getNpmScriptCommand(getAlternativeDir());\n+        }\n+\n+        if (returnCommand.isEmpty()) {\n+            // Otherwise look for regular `npm`\n+            String command = FrontendUtils.isWindows() ? \"npm.cmd\" : \"npm\";\n+            returnCommand\n+                    .add(getExecutable(command, null, true).getAbsolutePath());\n+        }\n+        returnCommand.add(\"--no-update-notifier\");\n+        returnCommand.add(\"--no-audit\");\n+\n+        if (removePnpmLock) {\n+            // remove pnpm-lock.yaml which contains pnpm as a dependency.\n+            new File(baseDir, \"pnpm-lock.yaml\").delete();\n+        }\n+\n+        return returnCommand;\n+    }\n+\n+    private List<String> getNpmScriptCommand(String dir) {\n+        // If `node` is not found in PATH, `node/node_modules/npm/bin/npm` will\n+        // not work because it's a shell or windows script that looks for node\n+        // and will fail. Thus we look for the `npm-cli` node script instead\n+        File file = new File(dir, \"node/node_modules/npm/bin/npm-cli.js\");\n+        List<String> returnCommand = new ArrayList<>();\n+        if (file.canRead()) {\n+            // We return a two element list with node binary and npm-cli script\n+            returnCommand.add(getNodeExecutable());\n+            returnCommand.add(file.getAbsolutePath());\n+        }\n+        return returnCommand;\n+    }\n+\n+    private boolean isPnpmTooOldOrAbsent(String dir) {\n+        final List<String> pnpmCommand = getPnpmExecutable(dir, false);\n+        if (!pnpmCommand.isEmpty()) {\n+            // check whether globally or locally installed pnpm is new enough\n+            try {\n+                List<String> versionCmd = new ArrayList<>(pnpmCommand);\n+                versionCmd.add(\"--version\"); // NOSONAR\n+                FrontendVersion pnpmVersion = FrontendUtils.getVersion(\"pnpm\",\n+                        versionCmd);\n+                if (FrontendUtils.isVersionAtLeast(pnpmVersion,\n+                        SUPPORTED_PNPM_VERSION)) {\n+                    return false;\n+                } else {\n+                    getLogger().warn(String.format(\n+                            \"installed pnpm ('%s', version %s) is too old, installing supported version locally\",\n+                            String.join(\" \", pnpmCommand),\n+                            pnpmVersion.getFullVersion()));\n+                }\n+            } catch (UnknownVersionException e) {\n+                getLogger().warn(\n+                        \"Error checking pnpm version, installing pnpm locally\",\n+                        e);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void installPnpm(List<String> installCommand) {\n+        List<String> command = new ArrayList<>();\n+        command.addAll(installCommand);\n+        command.add(\"install\");\n+        command.add(\"pnpm@\" + DEFAULT_PNPM_VERSION);\n+\n+        FrontendUtils.console(YELLOW,\n+                FrontendUtils.commandToString(baseDir, command));\n+\n+        ProcessBuilder builder = FrontendUtils.createProcessBuilder(command);\n+        builder.environment().put(\"ADBLOCK\", \"1\");\n+        builder.directory(new File(baseDir));\n+\n+        builder.redirectInput(ProcessBuilder.Redirect.INHERIT);\n+        builder.redirectError(ProcessBuilder.Redirect.INHERIT);\n+\n+        Process process = null;\n+        try {\n+            process = builder.start();\n+            getLogger().debug(\"Output of `{}`:\",\n+                    command.stream().collect(Collectors.joining(\" \")));", "originalCommit": "f670079cd11f02ff487652a3ef111f9664f6927b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk5NjgxNQ==", "url": "https://github.com/vaadin/flow/pull/7849#discussion_r394996815", "bodyText": "Either log or rethrow this exception.", "author": "vaadin-bot", "createdAt": "2020-03-19T12:42:42Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendTools.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Supplier;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.internal.Pair;\n+import com.vaadin.flow.server.Constants;\n+import com.vaadin.flow.server.frontend.FrontendUtils.UnknownVersionException;\n+import com.vaadin.flow.server.frontend.installer.InstallationException;\n+import com.vaadin.flow.server.frontend.installer.NodeInstaller;\n+import com.vaadin.flow.server.frontend.installer.ProxyConfig;\n+\n+import elemental.json.Json;\n+import elemental.json.JsonObject;\n+\n+/**\n+ * Provides access to frontend tools executables.\n+ *\n+ * @author Vaadin Ltd\n+ *\n+ */\n+public class FrontendTools {\n+\n+    private static final String DEFAULT_NODE_VERSION = \"v12.16.0\";\n+\n+    public static final String INSTALL_NODE_LOCALLY = \"%n  $ mvn com.github.eirslett:frontend-maven-plugin:1.7.6:install-node-and-npm -DnodeVersion=\\\"v12.14.0\\\" \";\n+\n+    private static final String NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. Please install the latest LTS version of node.js (with npm) either by:\"\n+            + \"%n  1) following the https://nodejs.org/en/download/ guide to install it globally. This is the recommended way.\"\n+            + \"%n  2) running the following Maven plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY\n+            + \"%n%nNote that in case you don't install it globally, you'll need to install it again for another Vaadin project.\"\n+            + \"%nIn case you have just installed node.js globally, it was not discovered, so you need to restart your system to get the path variables updated.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String LOCAL_NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. The %s directory already contains 'node' but it's either not a file \"\n+            + \"or not a 'node' executable. Please check %s directory and clean up it: remove '%s'.\"\n+            + \"%n then please run the app or maven goal again.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String BAD_VERSION = \"%n%n======================================================================================================\"\n+            + \"%nYour installed '%s' version (%s) is known to have problems.\" //\n+            + \"%nPlease update to a new one either:\"\n+            + \"%n  - by following the https://nodejs.org/en/download/ guide to install it globally\"\n+            + \"%s\"\n+            + \"%n  - or by running the frontend-maven-plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY + \"%n\" //\n+            + FrontendUtils.DISABLE_CHECK //\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final List<FrontendVersion> NPM_BLACKLISTED_VERSIONS = Arrays\n+            .asList(new FrontendVersion(\"6.11.0\"),\n+                    new FrontendVersion(\"6.11.1\"),\n+                    new FrontendVersion(\"6.11.2\"));\n+\n+    private static final String PNMP_INSTALLED_BY_NPM_FOLDER = \"node_modules/pnpm/\";\n+\n+    private static final String PNMP_INSTALLED_BY_NPM = PNMP_INSTALLED_BY_NPM_FOLDER\n+            + \"bin/pnpm.js\";\n+\n+    private static final FrontendVersion SUPPORTED_NODE_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NODE_MAJOR_VERSION,\n+            Constants.SUPPORTED_NODE_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NODE_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NODE_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NODE_MINOR_VERSION);\n+\n+    private static final FrontendVersion SUPPORTED_NPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_NPM_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NPM_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NPM_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NPM_MINOR_VERSION);\n+\n+    static final String NPMRC_NOPROXY_PROPERTY_KEY = \"noproxy\";\n+    static final String NPMRC_HTTPS_PROXY_PROPERTY_KEY = \"https-proxy\";\n+    static final String NPMRC_PROXY_PROPERTY_KEY = \"proxy\";\n+\n+    // Proxy config properties keys (for both system properties and environment\n+    // variables) can be either fully upper case or fully lower case\n+    static final String SYSTEM_NOPROXY_PROPERTY_KEY = \"NOPROXY\";\n+    static final String SYSTEM_HTTPS_PROXY_PROPERTY_KEY = \"HTTPS_PROXY\";\n+    static final String SYSTEM_HTTP_PROXY_PROPERTY_KEY = \"HTTP_PROXY\";\n+\n+    private static final FrontendVersion SUPPORTED_PNPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_PNPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_PNPM_MINOR_VERSION);\n+\n+    protected static final String DEFAULT_PNPM_VERSION = \"4.5.0\";\n+\n+    public static final String YELLOW = \"\\u001b[38;5;111m%s\\u001b[0m\";\n+\n+    private final String baseDir;\n+    private final Supplier<String> alternativeDirGetter;\n+\n+    private final FrontendToolsLocator frontendToolsLocator = new FrontendToolsLocator();\n+\n+    /**\n+     * Creates an instance of the class using the {@code baseDir} as a base\n+     * directory to locate the tools and the directory returned by the\n+     * {@code alternativeDirGetter} as a directory to install tools if they are\n+     * not found and use it as an alternative tools location.\n+     * <p>\n+     * If {@code alternativeDir} is {@code null} tools won't be installed.\n+     *\n+     *\n+     * @param baseDir\n+     *            the base directory to locate the tools, not {@code null}\n+     * @param alternativeDirGetter\n+     *            the getter for a directory where tools will be installed if\n+     *            they are not found globally or in the {@code baseDir}, may be\n+     *            {@code null}\n+     */\n+    public FrontendTools(String baseDir,\n+            Supplier<String> alternativeDirGetter) {\n+        this.baseDir = Objects.requireNonNull(baseDir);\n+        this.alternativeDirGetter = alternativeDirGetter;\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable.\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String getNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        return getExecutable(nodeCommands.getFirst(), nodeCommands.getSecond(),\n+                alternativeDirGetter != null).getAbsolutePath();\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable in the alternative dir of this class.\n+     *\n+     * <p>\n+     * The difference between {@link #getNodeExecutable()} and this method in a\n+     * search algorithm: {@link #getNodeExecutable()} first searches executable\n+     * in the base/alternative directory and fallbacks to the globally installed\n+     * if it's not found there. The {@link #forceAlternativeNodeExecutable()}\n+     * doesn't search for globally installed executable. It tries to find it in\n+     * the installation directory and if it's not found it downloads and\n+     * installs it there.\n+     *\n+     * @see #getNodeExecutable()\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String forceAlternativeNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        String dir = getAlternativeDir();\n+        File file = new File(dir, nodeCommands.getSecond());\n+        if (file.exists()) {\n+            if (!frontendToolsLocator.verifyTool(file)) {\n+                throw new IllegalStateException(\n+                        String.format(LOCAL_NODE_NOT_FOUND, dir, dir,\n+                                file.getAbsolutePath()));\n+            }\n+            return file.getAbsolutePath();\n+        } else {\n+            getLogger().info(\"Node not found in {}. Installing node {}.\", dir,\n+                    DEFAULT_NODE_VERSION);\n+            return installNode(DEFAULT_NODE_VERSION, null);\n+        }\n+    }\n+\n+    /**\n+     * Locate <code>npm</code> executable.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have npm running\n+     */\n+    public List<String> getNpmExecutable() {\n+        return getNpmExecutable(true);\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable.\n+     * <p>\n+     * In case pnpm is not available it will be installed.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     * @see #getPnpmExecutable( boolean)\n+     */\n+    public List<String> getPnpmExecutable() {\n+        ensurePnpm();\n+        List<String> pnpmCommand = getPnpmExecutable(baseDir, true);\n+        if (!pnpmCommand.isEmpty()) {\n+            pnpmCommand.add(\"--shamefully-hoist=true\");\n+        }\n+        return pnpmCommand;\n+    }\n+\n+    /**\n+     * Ensure that pnpm tool is available and install it if it's not.\n+     *\n+     */\n+    public void ensurePnpm() {\n+        if (isPnpmTooOldOrAbsent(baseDir)) {\n+            // copy the current content of package.json file to a temporary\n+            // location\n+            File packageJson = new File(baseDir, \"package.json\");\n+            File tempFile = null;\n+            boolean packageJsonExists = packageJson.canRead();\n+            if (packageJsonExists) {\n+                try {\n+                    tempFile = File.createTempFile(\"package\", \"json\");\n+                    FileUtils.copyFile(packageJson, tempFile);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't make a copy of package.json file\",\n+                            exception);\n+                }\n+                packageJson.delete();\n+            }\n+            try {\n+                JsonObject pkgJson = Json.createObject();\n+                pkgJson.put(\"name\", \"temp\");\n+                pkgJson.put(\"license\", \"UNLICENSED\");\n+                pkgJson.put(\"repository\", \"npm/npm\");\n+                pkgJson.put(\"description\",\n+                        \"Temporary package for pnpm installation\");\n+                FileUtils.writeLines(packageJson,\n+                        Collections.singletonList(pkgJson.toJson()));\n+                JsonObject lockJson = Json.createObject();\n+                lockJson.put(\"lockfileVersion\", 1);\n+                FileUtils.writeLines(new File(baseDir, \"package-lock.json\"),\n+                        Collections.singletonList(lockJson.toJson()));\n+            } catch (IOException e) {", "originalCommit": "f670079cd11f02ff487652a3ef111f9664f6927b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk5NjgyNA==", "url": "https://github.com/vaadin/flow/pull/7849#discussion_r394996824", "bodyText": "Exceptional return value of java.io.File.delete() ignored in com.vaadin.flow.server.frontend.FrontendTools.ensurePnpm() \n Do something with the \"boolean\" value returned by \"delete\".", "author": "vaadin-bot", "createdAt": "2020-03-19T12:42:43Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendTools.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Supplier;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.internal.Pair;\n+import com.vaadin.flow.server.Constants;\n+import com.vaadin.flow.server.frontend.FrontendUtils.UnknownVersionException;\n+import com.vaadin.flow.server.frontend.installer.InstallationException;\n+import com.vaadin.flow.server.frontend.installer.NodeInstaller;\n+import com.vaadin.flow.server.frontend.installer.ProxyConfig;\n+\n+import elemental.json.Json;\n+import elemental.json.JsonObject;\n+\n+/**\n+ * Provides access to frontend tools executables.\n+ *\n+ * @author Vaadin Ltd\n+ *\n+ */\n+public class FrontendTools {\n+\n+    private static final String DEFAULT_NODE_VERSION = \"v12.16.0\";\n+\n+    public static final String INSTALL_NODE_LOCALLY = \"%n  $ mvn com.github.eirslett:frontend-maven-plugin:1.7.6:install-node-and-npm -DnodeVersion=\\\"v12.14.0\\\" \";\n+\n+    private static final String NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. Please install the latest LTS version of node.js (with npm) either by:\"\n+            + \"%n  1) following the https://nodejs.org/en/download/ guide to install it globally. This is the recommended way.\"\n+            + \"%n  2) running the following Maven plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY\n+            + \"%n%nNote that in case you don't install it globally, you'll need to install it again for another Vaadin project.\"\n+            + \"%nIn case you have just installed node.js globally, it was not discovered, so you need to restart your system to get the path variables updated.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String LOCAL_NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. The %s directory already contains 'node' but it's either not a file \"\n+            + \"or not a 'node' executable. Please check %s directory and clean up it: remove '%s'.\"\n+            + \"%n then please run the app or maven goal again.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String BAD_VERSION = \"%n%n======================================================================================================\"\n+            + \"%nYour installed '%s' version (%s) is known to have problems.\" //\n+            + \"%nPlease update to a new one either:\"\n+            + \"%n  - by following the https://nodejs.org/en/download/ guide to install it globally\"\n+            + \"%s\"\n+            + \"%n  - or by running the frontend-maven-plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY + \"%n\" //\n+            + FrontendUtils.DISABLE_CHECK //\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final List<FrontendVersion> NPM_BLACKLISTED_VERSIONS = Arrays\n+            .asList(new FrontendVersion(\"6.11.0\"),\n+                    new FrontendVersion(\"6.11.1\"),\n+                    new FrontendVersion(\"6.11.2\"));\n+\n+    private static final String PNMP_INSTALLED_BY_NPM_FOLDER = \"node_modules/pnpm/\";\n+\n+    private static final String PNMP_INSTALLED_BY_NPM = PNMP_INSTALLED_BY_NPM_FOLDER\n+            + \"bin/pnpm.js\";\n+\n+    private static final FrontendVersion SUPPORTED_NODE_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NODE_MAJOR_VERSION,\n+            Constants.SUPPORTED_NODE_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NODE_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NODE_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NODE_MINOR_VERSION);\n+\n+    private static final FrontendVersion SUPPORTED_NPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_NPM_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NPM_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NPM_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NPM_MINOR_VERSION);\n+\n+    static final String NPMRC_NOPROXY_PROPERTY_KEY = \"noproxy\";\n+    static final String NPMRC_HTTPS_PROXY_PROPERTY_KEY = \"https-proxy\";\n+    static final String NPMRC_PROXY_PROPERTY_KEY = \"proxy\";\n+\n+    // Proxy config properties keys (for both system properties and environment\n+    // variables) can be either fully upper case or fully lower case\n+    static final String SYSTEM_NOPROXY_PROPERTY_KEY = \"NOPROXY\";\n+    static final String SYSTEM_HTTPS_PROXY_PROPERTY_KEY = \"HTTPS_PROXY\";\n+    static final String SYSTEM_HTTP_PROXY_PROPERTY_KEY = \"HTTP_PROXY\";\n+\n+    private static final FrontendVersion SUPPORTED_PNPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_PNPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_PNPM_MINOR_VERSION);\n+\n+    protected static final String DEFAULT_PNPM_VERSION = \"4.5.0\";\n+\n+    public static final String YELLOW = \"\\u001b[38;5;111m%s\\u001b[0m\";\n+\n+    private final String baseDir;\n+    private final Supplier<String> alternativeDirGetter;\n+\n+    private final FrontendToolsLocator frontendToolsLocator = new FrontendToolsLocator();\n+\n+    /**\n+     * Creates an instance of the class using the {@code baseDir} as a base\n+     * directory to locate the tools and the directory returned by the\n+     * {@code alternativeDirGetter} as a directory to install tools if they are\n+     * not found and use it as an alternative tools location.\n+     * <p>\n+     * If {@code alternativeDir} is {@code null} tools won't be installed.\n+     *\n+     *\n+     * @param baseDir\n+     *            the base directory to locate the tools, not {@code null}\n+     * @param alternativeDirGetter\n+     *            the getter for a directory where tools will be installed if\n+     *            they are not found globally or in the {@code baseDir}, may be\n+     *            {@code null}\n+     */\n+    public FrontendTools(String baseDir,\n+            Supplier<String> alternativeDirGetter) {\n+        this.baseDir = Objects.requireNonNull(baseDir);\n+        this.alternativeDirGetter = alternativeDirGetter;\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable.\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String getNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        return getExecutable(nodeCommands.getFirst(), nodeCommands.getSecond(),\n+                alternativeDirGetter != null).getAbsolutePath();\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable in the alternative dir of this class.\n+     *\n+     * <p>\n+     * The difference between {@link #getNodeExecutable()} and this method in a\n+     * search algorithm: {@link #getNodeExecutable()} first searches executable\n+     * in the base/alternative directory and fallbacks to the globally installed\n+     * if it's not found there. The {@link #forceAlternativeNodeExecutable()}\n+     * doesn't search for globally installed executable. It tries to find it in\n+     * the installation directory and if it's not found it downloads and\n+     * installs it there.\n+     *\n+     * @see #getNodeExecutable()\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String forceAlternativeNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        String dir = getAlternativeDir();\n+        File file = new File(dir, nodeCommands.getSecond());\n+        if (file.exists()) {\n+            if (!frontendToolsLocator.verifyTool(file)) {\n+                throw new IllegalStateException(\n+                        String.format(LOCAL_NODE_NOT_FOUND, dir, dir,\n+                                file.getAbsolutePath()));\n+            }\n+            return file.getAbsolutePath();\n+        } else {\n+            getLogger().info(\"Node not found in {}. Installing node {}.\", dir,\n+                    DEFAULT_NODE_VERSION);\n+            return installNode(DEFAULT_NODE_VERSION, null);\n+        }\n+    }\n+\n+    /**\n+     * Locate <code>npm</code> executable.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have npm running\n+     */\n+    public List<String> getNpmExecutable() {\n+        return getNpmExecutable(true);\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable.\n+     * <p>\n+     * In case pnpm is not available it will be installed.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     * @see #getPnpmExecutable( boolean)\n+     */\n+    public List<String> getPnpmExecutable() {\n+        ensurePnpm();\n+        List<String> pnpmCommand = getPnpmExecutable(baseDir, true);\n+        if (!pnpmCommand.isEmpty()) {\n+            pnpmCommand.add(\"--shamefully-hoist=true\");\n+        }\n+        return pnpmCommand;\n+    }\n+\n+    /**\n+     * Ensure that pnpm tool is available and install it if it's not.\n+     *\n+     */\n+    public void ensurePnpm() {\n+        if (isPnpmTooOldOrAbsent(baseDir)) {\n+            // copy the current content of package.json file to a temporary\n+            // location\n+            File packageJson = new File(baseDir, \"package.json\");\n+            File tempFile = null;\n+            boolean packageJsonExists = packageJson.canRead();\n+            if (packageJsonExists) {\n+                try {\n+                    tempFile = File.createTempFile(\"package\", \"json\");\n+                    FileUtils.copyFile(packageJson, tempFile);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't make a copy of package.json file\",\n+                            exception);\n+                }\n+                packageJson.delete();", "originalCommit": "f670079cd11f02ff487652a3ef111f9664f6927b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk5NjgzNA==", "url": "https://github.com/vaadin/flow/pull/7849#discussion_r394996834", "bodyText": "Do something with the \"boolean\" value returned by \"delete\".", "author": "vaadin-bot", "createdAt": "2020-03-19T12:42:44Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendTools.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Supplier;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.internal.Pair;\n+import com.vaadin.flow.server.Constants;\n+import com.vaadin.flow.server.frontend.FrontendUtils.UnknownVersionException;\n+import com.vaadin.flow.server.frontend.installer.InstallationException;\n+import com.vaadin.flow.server.frontend.installer.NodeInstaller;\n+import com.vaadin.flow.server.frontend.installer.ProxyConfig;\n+\n+import elemental.json.Json;\n+import elemental.json.JsonObject;\n+\n+/**\n+ * Provides access to frontend tools executables.\n+ *\n+ * @author Vaadin Ltd\n+ *\n+ */\n+public class FrontendTools {\n+\n+    private static final String DEFAULT_NODE_VERSION = \"v12.16.0\";\n+\n+    public static final String INSTALL_NODE_LOCALLY = \"%n  $ mvn com.github.eirslett:frontend-maven-plugin:1.7.6:install-node-and-npm -DnodeVersion=\\\"v12.14.0\\\" \";\n+\n+    private static final String NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. Please install the latest LTS version of node.js (with npm) either by:\"\n+            + \"%n  1) following the https://nodejs.org/en/download/ guide to install it globally. This is the recommended way.\"\n+            + \"%n  2) running the following Maven plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY\n+            + \"%n%nNote that in case you don't install it globally, you'll need to install it again for another Vaadin project.\"\n+            + \"%nIn case you have just installed node.js globally, it was not discovered, so you need to restart your system to get the path variables updated.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String LOCAL_NODE_NOT_FOUND = \"%n%n======================================================================================================\"\n+            + \"%nVaadin requires node.js & npm to be installed. The %s directory already contains 'node' but it's either not a file \"\n+            + \"or not a 'node' executable. Please check %s directory and clean up it: remove '%s'.\"\n+            + \"%n then please run the app or maven goal again.\"\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final String BAD_VERSION = \"%n%n======================================================================================================\"\n+            + \"%nYour installed '%s' version (%s) is known to have problems.\" //\n+            + \"%nPlease update to a new one either:\"\n+            + \"%n  - by following the https://nodejs.org/en/download/ guide to install it globally\"\n+            + \"%s\"\n+            + \"%n  - or by running the frontend-maven-plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY + \"%n\" //\n+            + FrontendUtils.DISABLE_CHECK //\n+            + \"%n======================================================================================================%n\";\n+\n+    private static final List<FrontendVersion> NPM_BLACKLISTED_VERSIONS = Arrays\n+            .asList(new FrontendVersion(\"6.11.0\"),\n+                    new FrontendVersion(\"6.11.1\"),\n+                    new FrontendVersion(\"6.11.2\"));\n+\n+    private static final String PNMP_INSTALLED_BY_NPM_FOLDER = \"node_modules/pnpm/\";\n+\n+    private static final String PNMP_INSTALLED_BY_NPM = PNMP_INSTALLED_BY_NPM_FOLDER\n+            + \"bin/pnpm.js\";\n+\n+    private static final FrontendVersion SUPPORTED_NODE_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NODE_MAJOR_VERSION,\n+            Constants.SUPPORTED_NODE_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NODE_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NODE_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NODE_MINOR_VERSION);\n+\n+    private static final FrontendVersion SUPPORTED_NPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_NPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_NPM_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NPM_VERSION = new FrontendVersion(\n+            Constants.SHOULD_WORK_NPM_MAJOR_VERSION,\n+            Constants.SHOULD_WORK_NPM_MINOR_VERSION);\n+\n+    static final String NPMRC_NOPROXY_PROPERTY_KEY = \"noproxy\";\n+    static final String NPMRC_HTTPS_PROXY_PROPERTY_KEY = \"https-proxy\";\n+    static final String NPMRC_PROXY_PROPERTY_KEY = \"proxy\";\n+\n+    // Proxy config properties keys (for both system properties and environment\n+    // variables) can be either fully upper case or fully lower case\n+    static final String SYSTEM_NOPROXY_PROPERTY_KEY = \"NOPROXY\";\n+    static final String SYSTEM_HTTPS_PROXY_PROPERTY_KEY = \"HTTPS_PROXY\";\n+    static final String SYSTEM_HTTP_PROXY_PROPERTY_KEY = \"HTTP_PROXY\";\n+\n+    private static final FrontendVersion SUPPORTED_PNPM_VERSION = new FrontendVersion(\n+            Constants.SUPPORTED_PNPM_MAJOR_VERSION,\n+            Constants.SUPPORTED_PNPM_MINOR_VERSION);\n+\n+    protected static final String DEFAULT_PNPM_VERSION = \"4.5.0\";\n+\n+    public static final String YELLOW = \"\\u001b[38;5;111m%s\\u001b[0m\";\n+\n+    private final String baseDir;\n+    private final Supplier<String> alternativeDirGetter;\n+\n+    private final FrontendToolsLocator frontendToolsLocator = new FrontendToolsLocator();\n+\n+    /**\n+     * Creates an instance of the class using the {@code baseDir} as a base\n+     * directory to locate the tools and the directory returned by the\n+     * {@code alternativeDirGetter} as a directory to install tools if they are\n+     * not found and use it as an alternative tools location.\n+     * <p>\n+     * If {@code alternativeDir} is {@code null} tools won't be installed.\n+     *\n+     *\n+     * @param baseDir\n+     *            the base directory to locate the tools, not {@code null}\n+     * @param alternativeDirGetter\n+     *            the getter for a directory where tools will be installed if\n+     *            they are not found globally or in the {@code baseDir}, may be\n+     *            {@code null}\n+     */\n+    public FrontendTools(String baseDir,\n+            Supplier<String> alternativeDirGetter) {\n+        this.baseDir = Objects.requireNonNull(baseDir);\n+        this.alternativeDirGetter = alternativeDirGetter;\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable.\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String getNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        return getExecutable(nodeCommands.getFirst(), nodeCommands.getSecond(),\n+                alternativeDirGetter != null).getAbsolutePath();\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable in the alternative dir of this class.\n+     *\n+     * <p>\n+     * The difference between {@link #getNodeExecutable()} and this method in a\n+     * search algorithm: {@link #getNodeExecutable()} first searches executable\n+     * in the base/alternative directory and fallbacks to the globally installed\n+     * if it's not found there. The {@link #forceAlternativeNodeExecutable()}\n+     * doesn't search for globally installed executable. It tries to find it in\n+     * the installation directory and if it's not found it downloads and\n+     * installs it there.\n+     *\n+     * @see #getNodeExecutable()\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String forceAlternativeNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        String dir = getAlternativeDir();\n+        File file = new File(dir, nodeCommands.getSecond());\n+        if (file.exists()) {\n+            if (!frontendToolsLocator.verifyTool(file)) {\n+                throw new IllegalStateException(\n+                        String.format(LOCAL_NODE_NOT_FOUND, dir, dir,\n+                                file.getAbsolutePath()));\n+            }\n+            return file.getAbsolutePath();\n+        } else {\n+            getLogger().info(\"Node not found in {}. Installing node {}.\", dir,\n+                    DEFAULT_NODE_VERSION);\n+            return installNode(DEFAULT_NODE_VERSION, null);\n+        }\n+    }\n+\n+    /**\n+     * Locate <code>npm</code> executable.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have npm running\n+     */\n+    public List<String> getNpmExecutable() {\n+        return getNpmExecutable(true);\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable.\n+     * <p>\n+     * In case pnpm is not available it will be installed.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     * @see #getPnpmExecutable( boolean)\n+     */\n+    public List<String> getPnpmExecutable() {\n+        ensurePnpm();\n+        List<String> pnpmCommand = getPnpmExecutable(baseDir, true);\n+        if (!pnpmCommand.isEmpty()) {\n+            pnpmCommand.add(\"--shamefully-hoist=true\");\n+        }\n+        return pnpmCommand;\n+    }\n+\n+    /**\n+     * Ensure that pnpm tool is available and install it if it's not.\n+     *\n+     */\n+    public void ensurePnpm() {\n+        if (isPnpmTooOldOrAbsent(baseDir)) {\n+            // copy the current content of package.json file to a temporary\n+            // location\n+            File packageJson = new File(baseDir, \"package.json\");\n+            File tempFile = null;\n+            boolean packageJsonExists = packageJson.canRead();\n+            if (packageJsonExists) {\n+                try {\n+                    tempFile = File.createTempFile(\"package\", \"json\");\n+                    FileUtils.copyFile(packageJson, tempFile);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't make a copy of package.json file\",\n+                            exception);\n+                }\n+                packageJson.delete();\n+            }\n+            try {\n+                JsonObject pkgJson = Json.createObject();\n+                pkgJson.put(\"name\", \"temp\");\n+                pkgJson.put(\"license\", \"UNLICENSED\");\n+                pkgJson.put(\"repository\", \"npm/npm\");\n+                pkgJson.put(\"description\",\n+                        \"Temporary package for pnpm installation\");\n+                FileUtils.writeLines(packageJson,\n+                        Collections.singletonList(pkgJson.toJson()));\n+                JsonObject lockJson = Json.createObject();\n+                lockJson.put(\"lockfileVersion\", 1);\n+                FileUtils.writeLines(new File(baseDir, \"package-lock.json\"),\n+                        Collections.singletonList(lockJson.toJson()));\n+            } catch (IOException e) {\n+                getLogger().warn(\"Couldn't create temporary package.json\");\n+            }\n+            LoggerFactory.getLogger(\"dev-updater\").info(\n+                    \"Installing pnpm v{} locally. It is suggested to install it globally using 'npm add -g pnpm@{}'\",\n+                    DEFAULT_PNPM_VERSION, DEFAULT_PNPM_VERSION);\n+            // install pnpm locally using npm\n+            installPnpm(getNpmExecutable(false));\n+\n+            // remove package-lock.json which contains pnpm as a dependency.\n+            new File(baseDir, \"package-lock.json\").delete();\n+\n+            if (packageJsonExists && tempFile != null) {\n+                // return back the original package.json\n+                try {\n+                    FileUtils.copyFile(tempFile, packageJson);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't restore package.json file back\",\n+                            exception);\n+                }\n+                tempFile.delete();", "originalCommit": "f670079cd11f02ff487652a3ef111f9664f6927b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "73e3e16ed2cacd7f0efe3a023a4a62d37dcf349f", "url": "https://github.com/vaadin/flow/commit/73e3e16ed2cacd7f0efe3a023a4a62d37dcf349f", "message": "Fix javadocs and extract duplicated constants.", "committedDate": "2020-03-19T13:12:15Z", "type": "commit"}, {"oid": "44c78d56c63d17e381c28b44ff0eb9534865a175", "url": "https://github.com/vaadin/flow/commit/44c78d56c63d17e381c28b44ff0eb9534865a175", "message": "Exclude utility class from serializable test.", "committedDate": "2020-03-19T13:44:04Z", "type": "commit"}, {"oid": "4a1b807aed237354d43353c13cb1f4fb17a1a453", "url": "https://github.com/vaadin/flow/commit/4a1b807aed237354d43353c13cb1f4fb17a1a453", "message": "Extract constants", "committedDate": "2020-03-20T12:07:46Z", "type": "commit"}, {"oid": "218cc400d5a54d8a5ea4bfb6496ec0dfd474ecd9", "url": "https://github.com/vaadin/flow/commit/218cc400d5a54d8a5ea4bfb6496ec0dfd474ecd9", "message": "Don't use \"&\" in javadocs", "committedDate": "2020-03-20T12:23:58Z", "type": "commit"}, {"oid": "52153b14e1e941d1beacb609639aad20c946b59c", "url": "https://github.com/vaadin/flow/commit/52153b14e1e941d1beacb609639aad20c946b59c", "message": "Use some dir as a home to install pnpm", "committedDate": "2020-03-20T12:58:17Z", "type": "commit"}, {"oid": "95317b8bb3c0d84e3ebbce11edb0feb2286ea0f0", "url": "https://github.com/vaadin/flow/commit/95317b8bb3c0d84e3ebbce11edb0feb2286ea0f0", "message": "Constants ping pong.", "committedDate": "2020-03-20T13:48:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1NTMzNg==", "url": "https://github.com/vaadin/flow/pull/7849#discussion_r395655336", "bodyText": "Merge this if statement with the enclosing one.", "author": "vaadin-bot", "createdAt": "2020-03-20T14:00:28Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendTools.java", "diffHunk": "@@ -0,0 +1,728 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.internal.Pair;\n+import com.vaadin.flow.server.frontend.FrontendUtils.UnknownVersionException;\n+import com.vaadin.flow.server.frontend.installer.InstallationException;\n+import com.vaadin.flow.server.frontend.installer.NodeInstaller;\n+import com.vaadin.flow.server.frontend.installer.ProxyConfig;\n+\n+import elemental.json.Json;\n+import elemental.json.JsonObject;\n+\n+/**\n+ * Provides access to frontend tools (node.js and npm, pnpm) and optionally\n+ * installs the tools if needed.\n+ * <p>\n+ * <b>WARNING:</b> This class is intended for internal usage only.\n+ *\n+ * @author Vaadin Ltd\n+ *\n+ */\n+public class FrontendTools {\n+\n+    private static final String DEFAULT_NODE_VERSION = \"v12.16.0\";\n+\n+    public static final String DEFAULT_PNPM_VERSION = \"4.5.0\";\n+\n+    public static final String INSTALL_NODE_LOCALLY = \"%n  $ mvn com.github.eirslett:frontend-maven-plugin:1.7.6:install-node-and-npm -DnodeVersion=\\\"v12.14.0\\\" \";\n+\n+    private static final String MSG_PREFIX = \"%n%n======================================================================================================\";\n+    private static final String MSG_SUFFIX = \"%n======================================================================================================%n\";\n+\n+    private static final String NODE_NOT_FOUND = MSG_PREFIX\n+            + \"%nVaadin requires node.js & npm to be installed. Please install the latest LTS version of node.js (with npm) either by:\"\n+            + \"%n  1) following the https://nodejs.org/en/download/ guide to install it globally. This is the recommended way.\"\n+            + \"%n  2) running the following Maven plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY\n+            + \"%n%nNote that in case you don't install it globally, you'll need to install it again for another Vaadin project.\"\n+            + \"%nIn case you have just installed node.js globally, it was not discovered, so you need to restart your system to get the path variables updated.\"\n+            + MSG_SUFFIX;\n+\n+    private static final String LOCAL_NODE_NOT_FOUND = MSG_PREFIX\n+            + \"%nVaadin requires node.js & npm to be installed. The %s directory already contains 'node' but it's either not a file \"\n+            + \"or not a 'node' executable. Please check %s directory and clean up it: remove '%s'.\"\n+            + \"%n then please run the app or maven goal again.\" + MSG_SUFFIX;\n+\n+    private static final String BAD_VERSION = MSG_PREFIX\n+            + \"%nYour installed '%s' version (%s) is known to have problems.\" //\n+            + \"%nPlease update to a new one either:\"\n+            + \"%n  - by following the https://nodejs.org/en/download/ guide to install it globally\"\n+            + \"%s\"\n+            + \"%n  - or by running the frontend-maven-plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY + \"%n\" //\n+            + FrontendUtils.DISABLE_CHECK //\n+            + MSG_SUFFIX;\n+\n+    private static final List<FrontendVersion> NPM_BLACKLISTED_VERSIONS = Arrays\n+            .asList(new FrontendVersion(\"6.11.0\"),\n+                    new FrontendVersion(\"6.11.1\"),\n+                    new FrontendVersion(\"6.11.2\"));\n+\n+    private static final String PNMP_INSTALLED_BY_NPM_FOLDER = \"node_modules/pnpm/\";\n+\n+    private static final String PNMP_INSTALLED_BY_NPM = PNMP_INSTALLED_BY_NPM_FOLDER\n+            + \"bin/pnpm.js\";\n+\n+    private static final int SUPPORTED_NODE_MAJOR_VERSION = 10;\n+    private static final int SUPPORTED_NODE_MINOR_VERSION = 0;\n+    private static final int SUPPORTED_NPM_MAJOR_VERSION = 5;\n+    private static final int SUPPORTED_NPM_MINOR_VERSION = 6;\n+    private static final int SHOULD_WORK_NODE_MAJOR_VERSION = 8;\n+    private static final int SHOULD_WORK_NODE_MINOR_VERSION = 9;\n+    private static final int SHOULD_WORK_NPM_MAJOR_VERSION = 5;\n+    private static final int SHOULD_WORK_NPM_MINOR_VERSION = 5;\n+\n+    public static final int SUPPORTED_PNPM_MAJOR_VERSION = 4;\n+    public static final int SUPPORTED_PNPM_MINOR_VERSION = 4;\n+\n+    private static final FrontendVersion SUPPORTED_NODE_VERSION = new FrontendVersion(\n+            SUPPORTED_NODE_MAJOR_VERSION, SUPPORTED_NODE_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NODE_VERSION = new FrontendVersion(\n+            SHOULD_WORK_NODE_MAJOR_VERSION, SHOULD_WORK_NODE_MINOR_VERSION);\n+\n+    private static final FrontendVersion SUPPORTED_NPM_VERSION = new FrontendVersion(\n+            SUPPORTED_NPM_MAJOR_VERSION, SUPPORTED_NPM_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NPM_VERSION = new FrontendVersion(\n+            SHOULD_WORK_NPM_MAJOR_VERSION, SHOULD_WORK_NPM_MINOR_VERSION);\n+\n+    static final String NPMRC_NOPROXY_PROPERTY_KEY = \"noproxy\";\n+    static final String NPMRC_HTTPS_PROXY_PROPERTY_KEY = \"https-proxy\";\n+    static final String NPMRC_PROXY_PROPERTY_KEY = \"proxy\";\n+\n+    // Proxy config properties keys (for both system properties and environment\n+    // variables) can be either fully upper case or fully lower case\n+    static final String SYSTEM_NOPROXY_PROPERTY_KEY = \"NOPROXY\";\n+    static final String SYSTEM_HTTPS_PROXY_PROPERTY_KEY = \"HTTPS_PROXY\";\n+    static final String SYSTEM_HTTP_PROXY_PROPERTY_KEY = \"HTTP_PROXY\";\n+\n+    private static final FrontendVersion SUPPORTED_PNPM_VERSION = new FrontendVersion(\n+            SUPPORTED_PNPM_MAJOR_VERSION, SUPPORTED_PNPM_MINOR_VERSION);\n+\n+    private final String baseDir;\n+    private final Supplier<String> alternativeDirGetter;\n+\n+    private final FrontendToolsLocator frontendToolsLocator = new FrontendToolsLocator();\n+\n+    /**\n+     * Creates an instance of the class using the {@code baseDir} as a base\n+     * directory to locate the tools and the directory returned by the\n+     * {@code alternativeDirGetter} as a directory to install tools if they are\n+     * not found and use it as an alternative tools location.\n+     * <p>\n+     * If {@code alternativeDir} is {@code null} tools won't be installed.\n+     *\n+     *\n+     * @param baseDir\n+     *            the base directory to locate the tools, not {@code null}\n+     * @param alternativeDirGetter\n+     *            the getter for a directory where tools will be installed if\n+     *            they are not found globally or in the {@code baseDir}, may be\n+     *            {@code null}\n+     */\n+    public FrontendTools(String baseDir,\n+            Supplier<String> alternativeDirGetter) {\n+        this.baseDir = Objects.requireNonNull(baseDir);\n+        this.alternativeDirGetter = alternativeDirGetter;\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable.\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String getNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        return getExecutable(nodeCommands.getFirst(), nodeCommands.getSecond(),\n+                alternativeDirGetter != null).getAbsolutePath();\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable from the alternative directory given.\n+     *\n+     * <p>\n+     * The difference between {@link #getNodeExecutable()} and this method in a\n+     * search algorithm: {@link #getNodeExecutable()} first searches executable\n+     * in the base/alternative directory and fallbacks to the globally installed\n+     * if it's not found there. The {@link #forceAlternativeNodeExecutable()}\n+     * doesn't search for globally installed executable. It tries to find it in\n+     * the installation directory and if it's not found it downloads and\n+     * installs it there.\n+     *\n+     * @see #getNodeExecutable()\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String forceAlternativeNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        String dir = getAlternativeDir();\n+        File file = new File(dir, nodeCommands.getSecond());\n+        if (file.exists()) {\n+            if (!frontendToolsLocator.verifyTool(file)) {\n+                throw new IllegalStateException(\n+                        String.format(LOCAL_NODE_NOT_FOUND, dir, dir,\n+                                file.getAbsolutePath()));\n+            }\n+            return file.getAbsolutePath();\n+        } else {\n+            getLogger().info(\"Node not found in {}. Installing node {}.\", dir,\n+                    DEFAULT_NODE_VERSION);\n+            return installNode(DEFAULT_NODE_VERSION, null);\n+        }\n+    }\n+\n+    /**\n+     * Locate <code>npm</code> executable.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have npm running\n+     */\n+    public List<String> getNpmExecutable() {\n+        return getNpmExecutable(true);\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable.\n+     * <p>\n+     * In case pnpm is not available it will be installed.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     * @see #getPnpmExecutable(String, boolean)\n+     */\n+    public List<String> getPnpmExecutable() {\n+        ensurePnpm();\n+        List<String> pnpmCommand = getPnpmExecutable(baseDir, true);\n+        if (!pnpmCommand.isEmpty()) {\n+            pnpmCommand.add(\"--shamefully-hoist=true\");\n+        }\n+        return pnpmCommand;\n+    }\n+\n+    /**\n+     * Ensure that pnpm tool is available and install it if it's not.\n+     *\n+     */\n+    public void ensurePnpm() {\n+        if (isPnpmTooOldOrAbsent(baseDir)) {\n+            // copy the current content of package.json file to a temporary\n+            // location\n+            File packageJson = new File(baseDir, \"package.json\");\n+            File tempFile = null;\n+            boolean packageJsonExists = packageJson.canRead();\n+            if (packageJsonExists) {\n+                try {\n+                    tempFile = File.createTempFile(\"package\", \"json\");\n+                    FileUtils.copyFile(packageJson, tempFile);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't make a copy of package.json file\",\n+                            exception);\n+                }\n+                packageJson.delete();\n+            }\n+            try {\n+                JsonObject pkgJson = Json.createObject();\n+                pkgJson.put(\"name\", \"temp\");\n+                pkgJson.put(\"license\", \"UNLICENSED\");\n+                pkgJson.put(\"repository\", \"npm/npm\");\n+                pkgJson.put(\"description\",\n+                        \"Temporary package for pnpm installation\");\n+                FileUtils.writeLines(packageJson,\n+                        Collections.singletonList(pkgJson.toJson()));\n+                JsonObject lockJson = Json.createObject();\n+                lockJson.put(\"lockfileVersion\", 1);\n+                FileUtils.writeLines(new File(baseDir, \"package-lock.json\"),\n+                        Collections.singletonList(lockJson.toJson()));\n+            } catch (IOException e) {\n+                getLogger().warn(\"Couldn't create temporary package.json\");\n+            }\n+            LoggerFactory.getLogger(\"dev-updater\").info(\n+                    \"Installing pnpm v{} locally. It is suggested to install it globally using 'npm add -g pnpm@{}'\",\n+                    DEFAULT_PNPM_VERSION, DEFAULT_PNPM_VERSION);\n+            // install pnpm locally using npm\n+            installPnpm(getNpmExecutable(false));\n+\n+            // remove package-lock.json which contains pnpm as a dependency.\n+            new File(baseDir, \"package-lock.json\").delete();\n+\n+            if (packageJsonExists && tempFile != null) {\n+                // return back the original package.json\n+                try {\n+                    FileUtils.copyFile(tempFile, packageJson);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't restore package.json file back\",\n+                            exception);\n+                }\n+                tempFile.delete();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate that the found node and npm versions are new enough. Throws an\n+     * exception with a descriptive message if a version is too old.\n+     */\n+    public void validateNodeAndNpmVersion() {\n+        try {\n+            List<String> nodeVersionCommand = new ArrayList<>();\n+            nodeVersionCommand.add(getNodeExecutable());\n+            nodeVersionCommand.add(\"--version\"); // NOSONAR\n+            FrontendVersion nodeVersion = FrontendUtils.getVersion(\"node\",\n+                    nodeVersionCommand);\n+            FrontendUtils.validateToolVersion(\"node\", nodeVersion,\n+                    SUPPORTED_NODE_VERSION, SHOULD_WORK_NODE_VERSION);\n+        } catch (UnknownVersionException e) {\n+            getLogger().warn(\"Error checking if node is new enough\", e);\n+        }\n+\n+        try {\n+            List<String> npmVersionCommand = new ArrayList<>(\n+                    getNpmExecutable(false));\n+            npmVersionCommand.add(\"--version\"); // NOSONAR\n+            FrontendVersion npmVersion = FrontendUtils.getVersion(\"npm\",\n+                    npmVersionCommand);\n+            FrontendUtils.validateToolVersion(\"npm\", npmVersion,\n+                    SUPPORTED_NPM_VERSION, SHOULD_WORK_NPM_VERSION);\n+            checkForFaultyNpmVersion(npmVersion);\n+        } catch (UnknownVersionException e) {\n+            getLogger().warn(\"Error checking if npm is new enough\", e);\n+        }\n+\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable if it's possible.\n+     * <p>\n+     * In case the tool is not found either {@link IllegalStateException} is\n+     * thrown or an empty list is returned depending on {@code failOnAbsence}\n+     * value.\n+     *\n+     * @param dir\n+     *            the directory to search local pnpm script\n+     *\n+     * @param failOnAbsence\n+     *            if {@code true} throws IllegalStateException if tool is not\n+     *            found, if {@code false} return an empty list if tool is not\n+     *            found\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     */\n+    protected List<String> getPnpmExecutable(String dir,\n+            boolean failOnAbsence) {\n+        // First try local pnpm JS script if it exists\n+        List<String> returnCommand = new ArrayList<>();\n+        Optional<File> localPnpmScript = getLocalPnpmScript(dir);\n+        if (localPnpmScript.isPresent()) {\n+            returnCommand.add(getNodeExecutable());\n+            returnCommand.add(localPnpmScript.get().getAbsolutePath());\n+        } else {\n+            // Otherwise look for regular `pnpm`\n+            String command = FrontendUtils.isWindows() ? \"pnpm.cmd\" : \"pnpm\";\n+            if (failOnAbsence) {\n+                returnCommand.add(\n+                        getExecutable(command, null, false).getAbsolutePath());\n+            } else {\n+                returnCommand.addAll(frontendToolsLocator.tryLocateTool(command)\n+                        .map(File::getPath).map(Collections::singletonList)\n+                        .orElse(Collections.emptyList()));\n+            }\n+        }\n+        return returnCommand;\n+    }\n+\n+    /**\n+     * Install node and npm.\n+     *\n+     * @param nodeVersion\n+     *            node version to install\n+     * @param downloadRoot\n+     *            optional download root for downloading node. May be a\n+     *            filesystem file or a URL see\n+     *            {@link NodeInstaller#setNodeDownloadRoot(URI)}.\n+     * @return node installation path\n+     */\n+    protected String installNode(String nodeVersion, URI downloadRoot) {\n+        NodeInstaller nodeInstaller = new NodeInstaller(\n+                new File(getAlternativeDir()), getProxies())\n+                        .setNodeVersion(nodeVersion);\n+        if (downloadRoot != null) {\n+            nodeInstaller.setNodeDownloadRoot(downloadRoot);\n+        }\n+\n+        try {\n+            nodeInstaller.install();\n+        } catch (InstallationException e) {\n+            throw new IllegalStateException(\"Failed to install Node\", e);\n+        }\n+\n+        return new File(nodeInstaller.getInstallDirectory(),\n+                getNodeCommands().getFirst()).toString();\n+    }\n+\n+    /**\n+     * Read list of configured proxies in order from system properties, .npmrc\n+     * file in the project root folder, .npmrc file in user root folder and\n+     * system environment variables.\n+     *\n+     * @return list of configured proxies\n+     */\n+    // Not private because of test\n+    protected List<ProxyConfig.Proxy> getProxies() {\n+        File projectNpmrc = new File(baseDir, \".npmrc\");\n+        File userNpmrc = new File(FileUtils.getUserDirectory(), \".npmrc\");\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>();\n+\n+        proxyList.addAll(readProxySettingsFromSystemProperties());\n+        proxyList.addAll(\n+                readProxySettingsFromNpmrcFile(\"project .npmrc\", projectNpmrc));\n+        proxyList.addAll(\n+                readProxySettingsFromNpmrcFile(\"user .npmrc\", userNpmrc));\n+        proxyList.addAll(readProxySettingsFromEnvironmentVariables());\n+\n+        return proxyList;\n+    }\n+\n+    void checkForFaultyNpmVersion(FrontendVersion npmVersion) {\n+        if (NPM_BLACKLISTED_VERSIONS.contains(npmVersion)) {\n+            String badNpmVersion = buildBadVersionString(\"npm\",\n+                    npmVersion.getFullVersion(),\n+                    \"by updating your global npm installation with `npm install -g npm@latest`\");\n+            throw new IllegalStateException(badNpmVersion);\n+        }\n+    }\n+\n+    private File getExecutable(String cmd, String defaultLocation,\n+            boolean installNode) {\n+        File file = null;\n+        try {\n+            if (defaultLocation == null) {\n+                file = frontendToolsLocator.tryLocateTool(cmd).orElse(null);\n+            } else {\n+                file = Arrays.asList(() -> baseDir, alternativeDirGetter)\n+                        .stream().map(Supplier::get)\n+                        .map(dir -> new File(dir, defaultLocation))\n+                        .filter(frontendToolsLocator::verifyTool).findFirst()\n+                        .orElseGet(() -> frontendToolsLocator.tryLocateTool(cmd)\n+                                .orElse(null));\n+            }\n+            if (file == null && installNode) {\n+                getLogger().info(\n+                        \"Couldn't find {}. Installing Node and NPM to {}.\", cmd,\n+                        installNode);\n+                return new File(installNode(DEFAULT_NODE_VERSION, null));\n+            }\n+        } catch (Exception e) { // NOSONAR\n+            // There are IOException coming from process fork\n+        }\n+        if (file == null) {\n+            throw new IllegalStateException(String.format(NODE_NOT_FOUND));\n+        }\n+        return file;\n+    }\n+\n+    private Pair<String, String> getNodeCommands() {\n+        if (FrontendUtils.isWindows()) {\n+            return new Pair<>(\"node.exe\", \"node/node.exe\");\n+        } else {\n+            return new Pair<>(\"node\", \"node/node\");\n+        }\n+    }\n+\n+    private Logger getLogger() {\n+        return LoggerFactory.getLogger(FrontendTools.class);\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromNpmrcFile(\n+            String fileDescription, File npmrc) {\n+        if (!npmrc.exists()) {\n+            return Collections.emptyList();\n+        }\n+\n+        try (FileReader fileReader = new FileReader(npmrc)) { // NOSONAR\n+            List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+            Properties properties = new Properties();\n+            properties.load(fileReader);\n+            String noproxy = properties.getProperty(NPMRC_NOPROXY_PROPERTY_KEY);\n+            if (noproxy != null)\n+                noproxy = noproxy.replaceAll(\",\", \"|\");\n+            String httpsProxyUrl = properties\n+                    .getProperty(NPMRC_HTTPS_PROXY_PROPERTY_KEY);\n+            if (httpsProxyUrl != null) {\n+                proxyList.add(new ProxyConfig.Proxy(\n+                        \"https-proxy - \" + fileDescription, httpsProxyUrl,\n+                        noproxy));\n+            }\n+            String proxyUrl = properties.getProperty(NPMRC_PROXY_PROPERTY_KEY);\n+            if (proxyUrl != null) {\n+                proxyList.add(new ProxyConfig.Proxy(\n+                        \"proxy - \" + fileDescription, proxyUrl, noproxy));\n+            }\n+            return proxyList;\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromSystemProperties() {\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+\n+        String noproxy = getNonNull(\n+                System.getProperty(SYSTEM_NOPROXY_PROPERTY_KEY),\n+                System.getProperty(SYSTEM_NOPROXY_PROPERTY_KEY.toLowerCase()));\n+        if (noproxy != null) {\n+            noproxy = noproxy.replaceAll(\",\", \"|\");\n+        }\n+\n+        String httpsProxyUrl = getNonNull(\n+                System.getProperty(SYSTEM_HTTPS_PROXY_PROPERTY_KEY),\n+                System.getProperty(\n+                        SYSTEM_HTTPS_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (httpsProxyUrl != null) {\n+            proxyList.add(new ProxyConfig.Proxy(\"https-proxy - system\",\n+                    httpsProxyUrl, noproxy));\n+        }\n+\n+        String proxyUrl = getNonNull(\n+                System.getProperty(SYSTEM_HTTP_PROXY_PROPERTY_KEY),\n+                System.getProperty(\n+                        SYSTEM_HTTP_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (proxyUrl != null) {\n+            proxyList.add(\n+                    new ProxyConfig.Proxy(\"proxy - system\", proxyUrl, noproxy));\n+        }\n+\n+        return proxyList;\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromEnvironmentVariables() {\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+\n+        String noproxy = getNonNull(System.getenv(SYSTEM_NOPROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_NOPROXY_PROPERTY_KEY.toLowerCase()));\n+        if (noproxy != null) {\n+            noproxy = noproxy.replaceAll(\",\", \"|\");\n+        }\n+\n+        String httpsProxyUrl = getNonNull(\n+                System.getenv(SYSTEM_HTTPS_PROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_HTTPS_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (httpsProxyUrl != null) {\n+            proxyList.add(new ProxyConfig.Proxy(\"https-proxy - env\",\n+                    httpsProxyUrl, noproxy));\n+        }\n+\n+        String proxyUrl = getNonNull(\n+                System.getenv(SYSTEM_HTTP_PROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_HTTP_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (proxyUrl != null) {\n+            proxyList.add(\n+                    new ProxyConfig.Proxy(\"proxy - env\", proxyUrl, noproxy));\n+        }\n+\n+        return proxyList;\n+    }\n+\n+    /**\n+     * Get the first non null value from the given array.\n+     *\n+     * @param valueArray\n+     *            array of values to get non null from\n+     * @return first non null value or null if no values found\n+     */\n+    private String getNonNull(String... valueArray) {\n+        for (String value : valueArray) {\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private List<String> getNpmExecutable(boolean removePnpmLock) {\n+        List<String> returnCommand = getNpmScriptCommand(baseDir);\n+        if (returnCommand.isEmpty()) {\n+            returnCommand = getNpmScriptCommand(getAlternativeDir());\n+        }\n+\n+        if (returnCommand.isEmpty()) {\n+            // Otherwise look for regular `npm`\n+            String command = FrontendUtils.isWindows() ? \"npm.cmd\" : \"npm\";\n+            returnCommand\n+                    .add(getExecutable(command, null, true).getAbsolutePath());\n+        }\n+        returnCommand.add(\"--no-update-notifier\");\n+        returnCommand.add(\"--no-audit\");\n+\n+        if (removePnpmLock) {\n+            // remove pnpm-lock.yaml which contains pnpm as a dependency.\n+            if (new File(baseDir, \"pnpm-lock.yaml\").delete()) {", "originalCommit": "95317b8bb3c0d84e3ebbce11edb0feb2286ea0f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1NTM0OA==", "url": "https://github.com/vaadin/flow/pull/7849#discussion_r395655348", "bodyText": "Use the built-in formatting to construct this argument.", "author": "vaadin-bot", "createdAt": "2020-03-20T14:00:29Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendTools.java", "diffHunk": "@@ -0,0 +1,728 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.internal.Pair;\n+import com.vaadin.flow.server.frontend.FrontendUtils.UnknownVersionException;\n+import com.vaadin.flow.server.frontend.installer.InstallationException;\n+import com.vaadin.flow.server.frontend.installer.NodeInstaller;\n+import com.vaadin.flow.server.frontend.installer.ProxyConfig;\n+\n+import elemental.json.Json;\n+import elemental.json.JsonObject;\n+\n+/**\n+ * Provides access to frontend tools (node.js and npm, pnpm) and optionally\n+ * installs the tools if needed.\n+ * <p>\n+ * <b>WARNING:</b> This class is intended for internal usage only.\n+ *\n+ * @author Vaadin Ltd\n+ *\n+ */\n+public class FrontendTools {\n+\n+    private static final String DEFAULT_NODE_VERSION = \"v12.16.0\";\n+\n+    public static final String DEFAULT_PNPM_VERSION = \"4.5.0\";\n+\n+    public static final String INSTALL_NODE_LOCALLY = \"%n  $ mvn com.github.eirslett:frontend-maven-plugin:1.7.6:install-node-and-npm -DnodeVersion=\\\"v12.14.0\\\" \";\n+\n+    private static final String MSG_PREFIX = \"%n%n======================================================================================================\";\n+    private static final String MSG_SUFFIX = \"%n======================================================================================================%n\";\n+\n+    private static final String NODE_NOT_FOUND = MSG_PREFIX\n+            + \"%nVaadin requires node.js & npm to be installed. Please install the latest LTS version of node.js (with npm) either by:\"\n+            + \"%n  1) following the https://nodejs.org/en/download/ guide to install it globally. This is the recommended way.\"\n+            + \"%n  2) running the following Maven plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY\n+            + \"%n%nNote that in case you don't install it globally, you'll need to install it again for another Vaadin project.\"\n+            + \"%nIn case you have just installed node.js globally, it was not discovered, so you need to restart your system to get the path variables updated.\"\n+            + MSG_SUFFIX;\n+\n+    private static final String LOCAL_NODE_NOT_FOUND = MSG_PREFIX\n+            + \"%nVaadin requires node.js & npm to be installed. The %s directory already contains 'node' but it's either not a file \"\n+            + \"or not a 'node' executable. Please check %s directory and clean up it: remove '%s'.\"\n+            + \"%n then please run the app or maven goal again.\" + MSG_SUFFIX;\n+\n+    private static final String BAD_VERSION = MSG_PREFIX\n+            + \"%nYour installed '%s' version (%s) is known to have problems.\" //\n+            + \"%nPlease update to a new one either:\"\n+            + \"%n  - by following the https://nodejs.org/en/download/ guide to install it globally\"\n+            + \"%s\"\n+            + \"%n  - or by running the frontend-maven-plugin goal to install it in this project:\"\n+            + INSTALL_NODE_LOCALLY + \"%n\" //\n+            + FrontendUtils.DISABLE_CHECK //\n+            + MSG_SUFFIX;\n+\n+    private static final List<FrontendVersion> NPM_BLACKLISTED_VERSIONS = Arrays\n+            .asList(new FrontendVersion(\"6.11.0\"),\n+                    new FrontendVersion(\"6.11.1\"),\n+                    new FrontendVersion(\"6.11.2\"));\n+\n+    private static final String PNMP_INSTALLED_BY_NPM_FOLDER = \"node_modules/pnpm/\";\n+\n+    private static final String PNMP_INSTALLED_BY_NPM = PNMP_INSTALLED_BY_NPM_FOLDER\n+            + \"bin/pnpm.js\";\n+\n+    private static final int SUPPORTED_NODE_MAJOR_VERSION = 10;\n+    private static final int SUPPORTED_NODE_MINOR_VERSION = 0;\n+    private static final int SUPPORTED_NPM_MAJOR_VERSION = 5;\n+    private static final int SUPPORTED_NPM_MINOR_VERSION = 6;\n+    private static final int SHOULD_WORK_NODE_MAJOR_VERSION = 8;\n+    private static final int SHOULD_WORK_NODE_MINOR_VERSION = 9;\n+    private static final int SHOULD_WORK_NPM_MAJOR_VERSION = 5;\n+    private static final int SHOULD_WORK_NPM_MINOR_VERSION = 5;\n+\n+    public static final int SUPPORTED_PNPM_MAJOR_VERSION = 4;\n+    public static final int SUPPORTED_PNPM_MINOR_VERSION = 4;\n+\n+    private static final FrontendVersion SUPPORTED_NODE_VERSION = new FrontendVersion(\n+            SUPPORTED_NODE_MAJOR_VERSION, SUPPORTED_NODE_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NODE_VERSION = new FrontendVersion(\n+            SHOULD_WORK_NODE_MAJOR_VERSION, SHOULD_WORK_NODE_MINOR_VERSION);\n+\n+    private static final FrontendVersion SUPPORTED_NPM_VERSION = new FrontendVersion(\n+            SUPPORTED_NPM_MAJOR_VERSION, SUPPORTED_NPM_MINOR_VERSION);\n+    private static final FrontendVersion SHOULD_WORK_NPM_VERSION = new FrontendVersion(\n+            SHOULD_WORK_NPM_MAJOR_VERSION, SHOULD_WORK_NPM_MINOR_VERSION);\n+\n+    static final String NPMRC_NOPROXY_PROPERTY_KEY = \"noproxy\";\n+    static final String NPMRC_HTTPS_PROXY_PROPERTY_KEY = \"https-proxy\";\n+    static final String NPMRC_PROXY_PROPERTY_KEY = \"proxy\";\n+\n+    // Proxy config properties keys (for both system properties and environment\n+    // variables) can be either fully upper case or fully lower case\n+    static final String SYSTEM_NOPROXY_PROPERTY_KEY = \"NOPROXY\";\n+    static final String SYSTEM_HTTPS_PROXY_PROPERTY_KEY = \"HTTPS_PROXY\";\n+    static final String SYSTEM_HTTP_PROXY_PROPERTY_KEY = \"HTTP_PROXY\";\n+\n+    private static final FrontendVersion SUPPORTED_PNPM_VERSION = new FrontendVersion(\n+            SUPPORTED_PNPM_MAJOR_VERSION, SUPPORTED_PNPM_MINOR_VERSION);\n+\n+    private final String baseDir;\n+    private final Supplier<String> alternativeDirGetter;\n+\n+    private final FrontendToolsLocator frontendToolsLocator = new FrontendToolsLocator();\n+\n+    /**\n+     * Creates an instance of the class using the {@code baseDir} as a base\n+     * directory to locate the tools and the directory returned by the\n+     * {@code alternativeDirGetter} as a directory to install tools if they are\n+     * not found and use it as an alternative tools location.\n+     * <p>\n+     * If {@code alternativeDir} is {@code null} tools won't be installed.\n+     *\n+     *\n+     * @param baseDir\n+     *            the base directory to locate the tools, not {@code null}\n+     * @param alternativeDirGetter\n+     *            the getter for a directory where tools will be installed if\n+     *            they are not found globally or in the {@code baseDir}, may be\n+     *            {@code null}\n+     */\n+    public FrontendTools(String baseDir,\n+            Supplier<String> alternativeDirGetter) {\n+        this.baseDir = Objects.requireNonNull(baseDir);\n+        this.alternativeDirGetter = alternativeDirGetter;\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable.\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String getNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        return getExecutable(nodeCommands.getFirst(), nodeCommands.getSecond(),\n+                alternativeDirGetter != null).getAbsolutePath();\n+    }\n+\n+    /**\n+     * Locate <code>node</code> executable from the alternative directory given.\n+     *\n+     * <p>\n+     * The difference between {@link #getNodeExecutable()} and this method in a\n+     * search algorithm: {@link #getNodeExecutable()} first searches executable\n+     * in the base/alternative directory and fallbacks to the globally installed\n+     * if it's not found there. The {@link #forceAlternativeNodeExecutable()}\n+     * doesn't search for globally installed executable. It tries to find it in\n+     * the installation directory and if it's not found it downloads and\n+     * installs it there.\n+     *\n+     * @see #getNodeExecutable()\n+     *\n+     * @return the full path to the executable\n+     */\n+    public String forceAlternativeNodeExecutable() {\n+        Pair<String, String> nodeCommands = getNodeCommands();\n+        String dir = getAlternativeDir();\n+        File file = new File(dir, nodeCommands.getSecond());\n+        if (file.exists()) {\n+            if (!frontendToolsLocator.verifyTool(file)) {\n+                throw new IllegalStateException(\n+                        String.format(LOCAL_NODE_NOT_FOUND, dir, dir,\n+                                file.getAbsolutePath()));\n+            }\n+            return file.getAbsolutePath();\n+        } else {\n+            getLogger().info(\"Node not found in {}. Installing node {}.\", dir,\n+                    DEFAULT_NODE_VERSION);\n+            return installNode(DEFAULT_NODE_VERSION, null);\n+        }\n+    }\n+\n+    /**\n+     * Locate <code>npm</code> executable.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have npm running\n+     */\n+    public List<String> getNpmExecutable() {\n+        return getNpmExecutable(true);\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable.\n+     * <p>\n+     * In case pnpm is not available it will be installed.\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     * @see #getPnpmExecutable(String, boolean)\n+     */\n+    public List<String> getPnpmExecutable() {\n+        ensurePnpm();\n+        List<String> pnpmCommand = getPnpmExecutable(baseDir, true);\n+        if (!pnpmCommand.isEmpty()) {\n+            pnpmCommand.add(\"--shamefully-hoist=true\");\n+        }\n+        return pnpmCommand;\n+    }\n+\n+    /**\n+     * Ensure that pnpm tool is available and install it if it's not.\n+     *\n+     */\n+    public void ensurePnpm() {\n+        if (isPnpmTooOldOrAbsent(baseDir)) {\n+            // copy the current content of package.json file to a temporary\n+            // location\n+            File packageJson = new File(baseDir, \"package.json\");\n+            File tempFile = null;\n+            boolean packageJsonExists = packageJson.canRead();\n+            if (packageJsonExists) {\n+                try {\n+                    tempFile = File.createTempFile(\"package\", \"json\");\n+                    FileUtils.copyFile(packageJson, tempFile);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't make a copy of package.json file\",\n+                            exception);\n+                }\n+                packageJson.delete();\n+            }\n+            try {\n+                JsonObject pkgJson = Json.createObject();\n+                pkgJson.put(\"name\", \"temp\");\n+                pkgJson.put(\"license\", \"UNLICENSED\");\n+                pkgJson.put(\"repository\", \"npm/npm\");\n+                pkgJson.put(\"description\",\n+                        \"Temporary package for pnpm installation\");\n+                FileUtils.writeLines(packageJson,\n+                        Collections.singletonList(pkgJson.toJson()));\n+                JsonObject lockJson = Json.createObject();\n+                lockJson.put(\"lockfileVersion\", 1);\n+                FileUtils.writeLines(new File(baseDir, \"package-lock.json\"),\n+                        Collections.singletonList(lockJson.toJson()));\n+            } catch (IOException e) {\n+                getLogger().warn(\"Couldn't create temporary package.json\");\n+            }\n+            LoggerFactory.getLogger(\"dev-updater\").info(\n+                    \"Installing pnpm v{} locally. It is suggested to install it globally using 'npm add -g pnpm@{}'\",\n+                    DEFAULT_PNPM_VERSION, DEFAULT_PNPM_VERSION);\n+            // install pnpm locally using npm\n+            installPnpm(getNpmExecutable(false));\n+\n+            // remove package-lock.json which contains pnpm as a dependency.\n+            new File(baseDir, \"package-lock.json\").delete();\n+\n+            if (packageJsonExists && tempFile != null) {\n+                // return back the original package.json\n+                try {\n+                    FileUtils.copyFile(tempFile, packageJson);\n+                } catch (IOException exception) {\n+                    throw new IllegalStateException(\n+                            \"Couldn't restore package.json file back\",\n+                            exception);\n+                }\n+                tempFile.delete();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate that the found node and npm versions are new enough. Throws an\n+     * exception with a descriptive message if a version is too old.\n+     */\n+    public void validateNodeAndNpmVersion() {\n+        try {\n+            List<String> nodeVersionCommand = new ArrayList<>();\n+            nodeVersionCommand.add(getNodeExecutable());\n+            nodeVersionCommand.add(\"--version\"); // NOSONAR\n+            FrontendVersion nodeVersion = FrontendUtils.getVersion(\"node\",\n+                    nodeVersionCommand);\n+            FrontendUtils.validateToolVersion(\"node\", nodeVersion,\n+                    SUPPORTED_NODE_VERSION, SHOULD_WORK_NODE_VERSION);\n+        } catch (UnknownVersionException e) {\n+            getLogger().warn(\"Error checking if node is new enough\", e);\n+        }\n+\n+        try {\n+            List<String> npmVersionCommand = new ArrayList<>(\n+                    getNpmExecutable(false));\n+            npmVersionCommand.add(\"--version\"); // NOSONAR\n+            FrontendVersion npmVersion = FrontendUtils.getVersion(\"npm\",\n+                    npmVersionCommand);\n+            FrontendUtils.validateToolVersion(\"npm\", npmVersion,\n+                    SUPPORTED_NPM_VERSION, SHOULD_WORK_NPM_VERSION);\n+            checkForFaultyNpmVersion(npmVersion);\n+        } catch (UnknownVersionException e) {\n+            getLogger().warn(\"Error checking if npm is new enough\", e);\n+        }\n+\n+    }\n+\n+    /**\n+     * Locate <code>pnpm</code> executable if it's possible.\n+     * <p>\n+     * In case the tool is not found either {@link IllegalStateException} is\n+     * thrown or an empty list is returned depending on {@code failOnAbsence}\n+     * value.\n+     *\n+     * @param dir\n+     *            the directory to search local pnpm script\n+     *\n+     * @param failOnAbsence\n+     *            if {@code true} throws IllegalStateException if tool is not\n+     *            found, if {@code false} return an empty list if tool is not\n+     *            found\n+     *\n+     * @return the list of all commands in sequence that need to be executed to\n+     *         have pnpm running\n+     */\n+    protected List<String> getPnpmExecutable(String dir,\n+            boolean failOnAbsence) {\n+        // First try local pnpm JS script if it exists\n+        List<String> returnCommand = new ArrayList<>();\n+        Optional<File> localPnpmScript = getLocalPnpmScript(dir);\n+        if (localPnpmScript.isPresent()) {\n+            returnCommand.add(getNodeExecutable());\n+            returnCommand.add(localPnpmScript.get().getAbsolutePath());\n+        } else {\n+            // Otherwise look for regular `pnpm`\n+            String command = FrontendUtils.isWindows() ? \"pnpm.cmd\" : \"pnpm\";\n+            if (failOnAbsence) {\n+                returnCommand.add(\n+                        getExecutable(command, null, false).getAbsolutePath());\n+            } else {\n+                returnCommand.addAll(frontendToolsLocator.tryLocateTool(command)\n+                        .map(File::getPath).map(Collections::singletonList)\n+                        .orElse(Collections.emptyList()));\n+            }\n+        }\n+        return returnCommand;\n+    }\n+\n+    /**\n+     * Install node and npm.\n+     *\n+     * @param nodeVersion\n+     *            node version to install\n+     * @param downloadRoot\n+     *            optional download root for downloading node. May be a\n+     *            filesystem file or a URL see\n+     *            {@link NodeInstaller#setNodeDownloadRoot(URI)}.\n+     * @return node installation path\n+     */\n+    protected String installNode(String nodeVersion, URI downloadRoot) {\n+        NodeInstaller nodeInstaller = new NodeInstaller(\n+                new File(getAlternativeDir()), getProxies())\n+                        .setNodeVersion(nodeVersion);\n+        if (downloadRoot != null) {\n+            nodeInstaller.setNodeDownloadRoot(downloadRoot);\n+        }\n+\n+        try {\n+            nodeInstaller.install();\n+        } catch (InstallationException e) {\n+            throw new IllegalStateException(\"Failed to install Node\", e);\n+        }\n+\n+        return new File(nodeInstaller.getInstallDirectory(),\n+                getNodeCommands().getFirst()).toString();\n+    }\n+\n+    /**\n+     * Read list of configured proxies in order from system properties, .npmrc\n+     * file in the project root folder, .npmrc file in user root folder and\n+     * system environment variables.\n+     *\n+     * @return list of configured proxies\n+     */\n+    // Not private because of test\n+    protected List<ProxyConfig.Proxy> getProxies() {\n+        File projectNpmrc = new File(baseDir, \".npmrc\");\n+        File userNpmrc = new File(FileUtils.getUserDirectory(), \".npmrc\");\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>();\n+\n+        proxyList.addAll(readProxySettingsFromSystemProperties());\n+        proxyList.addAll(\n+                readProxySettingsFromNpmrcFile(\"project .npmrc\", projectNpmrc));\n+        proxyList.addAll(\n+                readProxySettingsFromNpmrcFile(\"user .npmrc\", userNpmrc));\n+        proxyList.addAll(readProxySettingsFromEnvironmentVariables());\n+\n+        return proxyList;\n+    }\n+\n+    void checkForFaultyNpmVersion(FrontendVersion npmVersion) {\n+        if (NPM_BLACKLISTED_VERSIONS.contains(npmVersion)) {\n+            String badNpmVersion = buildBadVersionString(\"npm\",\n+                    npmVersion.getFullVersion(),\n+                    \"by updating your global npm installation with `npm install -g npm@latest`\");\n+            throw new IllegalStateException(badNpmVersion);\n+        }\n+    }\n+\n+    private File getExecutable(String cmd, String defaultLocation,\n+            boolean installNode) {\n+        File file = null;\n+        try {\n+            if (defaultLocation == null) {\n+                file = frontendToolsLocator.tryLocateTool(cmd).orElse(null);\n+            } else {\n+                file = Arrays.asList(() -> baseDir, alternativeDirGetter)\n+                        .stream().map(Supplier::get)\n+                        .map(dir -> new File(dir, defaultLocation))\n+                        .filter(frontendToolsLocator::verifyTool).findFirst()\n+                        .orElseGet(() -> frontendToolsLocator.tryLocateTool(cmd)\n+                                .orElse(null));\n+            }\n+            if (file == null && installNode) {\n+                getLogger().info(\n+                        \"Couldn't find {}. Installing Node and NPM to {}.\", cmd,\n+                        installNode);\n+                return new File(installNode(DEFAULT_NODE_VERSION, null));\n+            }\n+        } catch (Exception e) { // NOSONAR\n+            // There are IOException coming from process fork\n+        }\n+        if (file == null) {\n+            throw new IllegalStateException(String.format(NODE_NOT_FOUND));\n+        }\n+        return file;\n+    }\n+\n+    private Pair<String, String> getNodeCommands() {\n+        if (FrontendUtils.isWindows()) {\n+            return new Pair<>(\"node.exe\", \"node/node.exe\");\n+        } else {\n+            return new Pair<>(\"node\", \"node/node\");\n+        }\n+    }\n+\n+    private Logger getLogger() {\n+        return LoggerFactory.getLogger(FrontendTools.class);\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromNpmrcFile(\n+            String fileDescription, File npmrc) {\n+        if (!npmrc.exists()) {\n+            return Collections.emptyList();\n+        }\n+\n+        try (FileReader fileReader = new FileReader(npmrc)) { // NOSONAR\n+            List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+            Properties properties = new Properties();\n+            properties.load(fileReader);\n+            String noproxy = properties.getProperty(NPMRC_NOPROXY_PROPERTY_KEY);\n+            if (noproxy != null)\n+                noproxy = noproxy.replaceAll(\",\", \"|\");\n+            String httpsProxyUrl = properties\n+                    .getProperty(NPMRC_HTTPS_PROXY_PROPERTY_KEY);\n+            if (httpsProxyUrl != null) {\n+                proxyList.add(new ProxyConfig.Proxy(\n+                        \"https-proxy - \" + fileDescription, httpsProxyUrl,\n+                        noproxy));\n+            }\n+            String proxyUrl = properties.getProperty(NPMRC_PROXY_PROPERTY_KEY);\n+            if (proxyUrl != null) {\n+                proxyList.add(new ProxyConfig.Proxy(\n+                        \"proxy - \" + fileDescription, proxyUrl, noproxy));\n+            }\n+            return proxyList;\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromSystemProperties() {\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+\n+        String noproxy = getNonNull(\n+                System.getProperty(SYSTEM_NOPROXY_PROPERTY_KEY),\n+                System.getProperty(SYSTEM_NOPROXY_PROPERTY_KEY.toLowerCase()));\n+        if (noproxy != null) {\n+            noproxy = noproxy.replaceAll(\",\", \"|\");\n+        }\n+\n+        String httpsProxyUrl = getNonNull(\n+                System.getProperty(SYSTEM_HTTPS_PROXY_PROPERTY_KEY),\n+                System.getProperty(\n+                        SYSTEM_HTTPS_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (httpsProxyUrl != null) {\n+            proxyList.add(new ProxyConfig.Proxy(\"https-proxy - system\",\n+                    httpsProxyUrl, noproxy));\n+        }\n+\n+        String proxyUrl = getNonNull(\n+                System.getProperty(SYSTEM_HTTP_PROXY_PROPERTY_KEY),\n+                System.getProperty(\n+                        SYSTEM_HTTP_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (proxyUrl != null) {\n+            proxyList.add(\n+                    new ProxyConfig.Proxy(\"proxy - system\", proxyUrl, noproxy));\n+        }\n+\n+        return proxyList;\n+    }\n+\n+    private List<ProxyConfig.Proxy> readProxySettingsFromEnvironmentVariables() {\n+        List<ProxyConfig.Proxy> proxyList = new ArrayList<>(2);\n+\n+        String noproxy = getNonNull(System.getenv(SYSTEM_NOPROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_NOPROXY_PROPERTY_KEY.toLowerCase()));\n+        if (noproxy != null) {\n+            noproxy = noproxy.replaceAll(\",\", \"|\");\n+        }\n+\n+        String httpsProxyUrl = getNonNull(\n+                System.getenv(SYSTEM_HTTPS_PROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_HTTPS_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (httpsProxyUrl != null) {\n+            proxyList.add(new ProxyConfig.Proxy(\"https-proxy - env\",\n+                    httpsProxyUrl, noproxy));\n+        }\n+\n+        String proxyUrl = getNonNull(\n+                System.getenv(SYSTEM_HTTP_PROXY_PROPERTY_KEY),\n+                System.getenv(SYSTEM_HTTP_PROXY_PROPERTY_KEY.toLowerCase()));\n+        if (proxyUrl != null) {\n+            proxyList.add(\n+                    new ProxyConfig.Proxy(\"proxy - env\", proxyUrl, noproxy));\n+        }\n+\n+        return proxyList;\n+    }\n+\n+    /**\n+     * Get the first non null value from the given array.\n+     *\n+     * @param valueArray\n+     *            array of values to get non null from\n+     * @return first non null value or null if no values found\n+     */\n+    private String getNonNull(String... valueArray) {\n+        for (String value : valueArray) {\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private List<String> getNpmExecutable(boolean removePnpmLock) {\n+        List<String> returnCommand = getNpmScriptCommand(baseDir);\n+        if (returnCommand.isEmpty()) {\n+            returnCommand = getNpmScriptCommand(getAlternativeDir());\n+        }\n+\n+        if (returnCommand.isEmpty()) {\n+            // Otherwise look for regular `npm`\n+            String command = FrontendUtils.isWindows() ? \"npm.cmd\" : \"npm\";\n+            returnCommand\n+                    .add(getExecutable(command, null, true).getAbsolutePath());\n+        }\n+        returnCommand.add(\"--no-update-notifier\");\n+        returnCommand.add(\"--no-audit\");\n+\n+        if (removePnpmLock) {\n+            // remove pnpm-lock.yaml which contains pnpm as a dependency.\n+            if (new File(baseDir, \"pnpm-lock.yaml\").delete()) {\n+                getLogger().debug(\n+                        \"pnpm-lock.yaml file is removed from \" + baseDir);", "originalCommit": "95317b8bb3c0d84e3ebbce11edb0feb2286ea0f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}