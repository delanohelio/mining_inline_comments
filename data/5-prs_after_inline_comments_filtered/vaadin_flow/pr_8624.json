{"pr_number": 8624, "pr_title": "Refactor lazy data view API based on feedback", "pr_createdAt": "2020-06-26T06:30:51Z", "pr_url": "https://github.com/vaadin/flow/pull/8624", "timeline": [{"oid": "47562f6935f3f8ab4a42946fa9bcb8e577d1364c", "url": "https://github.com/vaadin/flow/commit/47562f6935f3f8ab4a42946fa9bcb8e577d1364c", "message": "Refactor to LazyDataView API based on feedback\n\nInstead of defined/undefined size, uses setRowCountUnknown and\nsetRowCountEstimate etc. Removed callback for estimate.", "committedDate": "2020-06-25T07:32:07Z", "type": "commit"}, {"oid": "c0700a269287eee7ea0b3776ac51808091f0d157", "url": "https://github.com/vaadin/flow/commit/c0700a269287eee7ea0b3776ac51808091f0d157", "message": "Fixes based on DX test feedback", "committedDate": "2020-06-26T05:58:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1ODAzOQ==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446058039", "bodyText": "Would it better to replace it with rowCountEstimateIncrease < 0? rowCountEstimateIncrease is either -1 or >= 1. Otherwise, I wonder it there 0 value possible.", "author": "mshabarov", "createdAt": "2020-06-26T08:57:18Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -443,77 +414,106 @@ public void setSizeCallback(\n     }\n \n     /**\n-     * Sets the size estimate callback to be used and switches the component to\n-     * undefined size. Any previously set callbacks or initial size are cleared.\n-     * The new estimate will be fetched after this roundtrip.\n+     * Sets the row count estimate to use and switches component to undefined\n+     * size. Any previously set count callback is cleared. The new estimate is\n+     * applied if the actual count has not been discovered and if the estimate\n+     * is greater than the number of requested items. Otherwise it is not\n+     * applied until there has been a reset.\n+     * <p>\n+     * <em>NOTE:</em> setting row count estimate that is less than two pages\n+     * (set with {@link #setPageSize(int)}) can cause extra requests initially\n+     * or after a reset.\n      * \n-     * @param sizeEstimateCallback\n-     *            the size estimate callback to use\n+     * @param rowCountEstimate\n+     *            the row count estimate to be used\n      */\n-    public void setSizeEstimateCallback(\n-            SizeEstimateCallback<T, ?> sizeEstimateCallback) {\n-        if (sizeEstimateCallback == null) {\n+    public void setRowCountEstimate(int rowCountEstimate) {\n+        if (rowCountEstimate < 1) {\n             throw new IllegalArgumentException(\n-                    \"Provided size estimate callback cannot be null - for \"\n-                            + \"switching between defined and undefined size use \"\n-                            + \"setDefinedSize(boolean) method instead.\");\n+                    \"Given row count estimate cannot be less than 1.\");\n         }\n-        clearSizeCallbacksAndState();\n-        this.sizeEstimateCallback = sizeEstimateCallback;\n+        this.rowCountEstimate = rowCountEstimate;\n+        this.countCallback = null;\n         definedSize = false;\n-        if (!skipSizeCheckUntilReset) {\n+        if (!skipSizeCheckUntilReset\n+                && requestedRange.getEnd() < rowCountEstimate) {\n             sizeReset = true;\n             requestFlush();\n         }\n     }\n \n     /**\n-     * Sets the initial size estimate to use and switches component to undefined\n-     * size. Any previously set size related callbacks are cleared. The new\n-     * estimate is only applied if it is greater than the number of requested\n-     * items. Otherwise it is not applied until there has been a reset.\n-     * <p>\n-     * <em>NOTE:</em> setting an initial size estimate that is less than two\n-     * pages (set with {@link #setPageSize(int)}) can cause extra requests\n-     * initially or after a reset.\n+     * Gets the row count estimate used.\n      * \n-     * @param initialSizeEstimate\n-     *            the initial size estimate to be used\n+     * @return the row count estimate used\n      */\n-    public void setInitialSizeEstimate(int initialSizeEstimate) {\n-        if (initialSizeEstimate < 1) {\n+    public int getRowCountEstimate() {\n+        int estimate = rowCountEstimate;\n+        if (estimate < 1) {\n+            estimate = pageSize * 4;\n+        }\n+        if (estimate <= requestedRange.getEnd()) {\n+            // don't let the count estimate set to lock component to\n+            // defined size -> increase the size so size it's not locked\n+            estimate = requestedRange.getEnd() + pageSize;\n+        }\n+        return estimate;\n+    }\n+\n+    /**\n+     * Sets the row count estimate increase to use and switches the component to\n+     * undefined size if not yet used. Any previously set count callback is\n+     * cleared. The step is used the next time that the count is adjusted.\n+     * <em>NOTE:</em> the increase should be greater than the\n+     * {@link #setPageSize(int)} or it may cause bad performance.\n+     * \n+     * @param rowCountEstimateIncrease\n+     *            the row count estimate step to use\n+     */\n+    public void setRowCountEstimateIncrease(int rowCountEstimateIncrease) {\n+        if (rowCountEstimateIncrease < 1) {\n             throw new IllegalArgumentException(\n-                    \"Given initial size estimate cannot be less than 1. For switching between defined and undefined size use setDefinedSize(boolean) method instead.\");\n+                    \"rowCountEstimateIncrease cannot be less than 1\");\n         }\n-        clearSizeCallbacksAndState();\n-        this.initialSizeEstimate = initialSizeEstimate;\n+        this.rowCountEstimateIncrease = rowCountEstimateIncrease;\n+        this.countCallback = null;\n         definedSize = false;\n-        if (!skipSizeCheckUntilReset\n-                && requestedRange.getEnd() < initialSizeEstimate) {\n-            sizeReset = true;\n-            requestFlush();\n+    }\n+\n+    /**\n+     * Gets the row count estimate increase used.\n+     * \n+     * @return the row count estimate increase\n+     */\n+    public int getRowCountEstimateIncrease() {\n+        if (rowCountEstimateIncrease < 1) {", "originalCommit": "c0700a269287eee7ea0b3776ac51808091f0d157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM2NzUwNA==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446367504", "bodyText": "Well, otherwise it does not matter but if we accidentally internally set it to 0, this would hide the bug. So making some changes.", "author": "pleku", "createdAt": "2020-06-26T19:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1ODAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1ODI4NQ==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446058285", "bodyText": "Let's create a constant variable for '4'", "author": "mshabarov", "createdAt": "2020-06-26T08:57:51Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -443,77 +414,106 @@ public void setSizeCallback(\n     }\n \n     /**\n-     * Sets the size estimate callback to be used and switches the component to\n-     * undefined size. Any previously set callbacks or initial size are cleared.\n-     * The new estimate will be fetched after this roundtrip.\n+     * Sets the row count estimate to use and switches component to undefined\n+     * size. Any previously set count callback is cleared. The new estimate is\n+     * applied if the actual count has not been discovered and if the estimate\n+     * is greater than the number of requested items. Otherwise it is not\n+     * applied until there has been a reset.\n+     * <p>\n+     * <em>NOTE:</em> setting row count estimate that is less than two pages\n+     * (set with {@link #setPageSize(int)}) can cause extra requests initially\n+     * or after a reset.\n      * \n-     * @param sizeEstimateCallback\n-     *            the size estimate callback to use\n+     * @param rowCountEstimate\n+     *            the row count estimate to be used\n      */\n-    public void setSizeEstimateCallback(\n-            SizeEstimateCallback<T, ?> sizeEstimateCallback) {\n-        if (sizeEstimateCallback == null) {\n+    public void setRowCountEstimate(int rowCountEstimate) {\n+        if (rowCountEstimate < 1) {\n             throw new IllegalArgumentException(\n-                    \"Provided size estimate callback cannot be null - for \"\n-                            + \"switching between defined and undefined size use \"\n-                            + \"setDefinedSize(boolean) method instead.\");\n+                    \"Given row count estimate cannot be less than 1.\");\n         }\n-        clearSizeCallbacksAndState();\n-        this.sizeEstimateCallback = sizeEstimateCallback;\n+        this.rowCountEstimate = rowCountEstimate;\n+        this.countCallback = null;\n         definedSize = false;\n-        if (!skipSizeCheckUntilReset) {\n+        if (!skipSizeCheckUntilReset\n+                && requestedRange.getEnd() < rowCountEstimate) {\n             sizeReset = true;\n             requestFlush();\n         }\n     }\n \n     /**\n-     * Sets the initial size estimate to use and switches component to undefined\n-     * size. Any previously set size related callbacks are cleared. The new\n-     * estimate is only applied if it is greater than the number of requested\n-     * items. Otherwise it is not applied until there has been a reset.\n-     * <p>\n-     * <em>NOTE:</em> setting an initial size estimate that is less than two\n-     * pages (set with {@link #setPageSize(int)}) can cause extra requests\n-     * initially or after a reset.\n+     * Gets the row count estimate used.\n      * \n-     * @param initialSizeEstimate\n-     *            the initial size estimate to be used\n+     * @return the row count estimate used\n      */\n-    public void setInitialSizeEstimate(int initialSizeEstimate) {\n-        if (initialSizeEstimate < 1) {\n+    public int getRowCountEstimate() {\n+        int estimate = rowCountEstimate;\n+        if (estimate < 1) {\n+            estimate = pageSize * 4;\n+        }\n+        if (estimate <= requestedRange.getEnd()) {\n+            // don't let the count estimate set to lock component to\n+            // defined size -> increase the size so size it's not locked\n+            estimate = requestedRange.getEnd() + pageSize;\n+        }\n+        return estimate;\n+    }\n+\n+    /**\n+     * Sets the row count estimate increase to use and switches the component to\n+     * undefined size if not yet used. Any previously set count callback is\n+     * cleared. The step is used the next time that the count is adjusted.\n+     * <em>NOTE:</em> the increase should be greater than the\n+     * {@link #setPageSize(int)} or it may cause bad performance.\n+     * \n+     * @param rowCountEstimateIncrease\n+     *            the row count estimate step to use\n+     */\n+    public void setRowCountEstimateIncrease(int rowCountEstimateIncrease) {\n+        if (rowCountEstimateIncrease < 1) {\n             throw new IllegalArgumentException(\n-                    \"Given initial size estimate cannot be less than 1. For switching between defined and undefined size use setDefinedSize(boolean) method instead.\");\n+                    \"rowCountEstimateIncrease cannot be less than 1\");\n         }\n-        clearSizeCallbacksAndState();\n-        this.initialSizeEstimate = initialSizeEstimate;\n+        this.rowCountEstimateIncrease = rowCountEstimateIncrease;\n+        this.countCallback = null;\n         definedSize = false;\n-        if (!skipSizeCheckUntilReset\n-                && requestedRange.getEnd() < initialSizeEstimate) {\n-            sizeReset = true;\n-            requestFlush();\n+    }\n+\n+    /**\n+     * Gets the row count estimate increase used.\n+     * \n+     * @return the row count estimate increase\n+     */\n+    public int getRowCountEstimateIncrease() {\n+        if (rowCountEstimateIncrease < 1) {\n+            return pageSize * 4;", "originalCommit": "c0700a269287eee7ea0b3776ac51808091f0d157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM2NzUzMQ==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446367531", "bodyText": "Done", "author": "pleku", "createdAt": "2020-06-26T19:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1ODI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0Mzk4Mw==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446143983", "bodyText": "What about reset of rowCountEstimate and rowCountEstimateIncrease here?", "author": "mshabarov", "createdAt": "2020-06-26T12:08:23Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -257,7 +254,7 @@ public void confirmUpdate(int updateId) {\n             DataProvider<T, F> dataProvider, F initialFilter) {\n         Objects.requireNonNull(dataProvider, \"data provider cannot be null\");\n         filter = initialFilter;\n-        clearSizeCallbacksAndState();\n+        countCallback = null;", "originalCommit": "c0700a269287eee7ea0b3776ac51808091f0d157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2ODkwOQ==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446168909", "bodyText": "Thought about it, but I think that if the developer wants switch between the modes, it is weird if they have to reset those again even when set ealier. Now there is less magic side effects happening on the background and e.g. the getters still return the values that have been set earlier. I will add a test to make sure those are not used anyway with count callback", "author": "pleku", "createdAt": "2020-06-26T13:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0Mzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzU0NQ==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446193545", "bodyText": "Alright! Now I have been thinking about the cases when the developer wants to change the data provider. It means there is a 'reusable' component which may connect to a different data sources. Is that a real usage? My limited component's usage experience does not give me a reasonable example.", "author": "mshabarov", "createdAt": "2020-06-26T13:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0Mzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3NjcwNA==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446376704", "bodyText": "At least with in-memory data it might occur, but not so sure with backends. Maybe in some not-common scenario where there would be the same data in multiple tables, but that has to be rare.\nBut I think that now that it is possible to switch between \"exact size\" and \"automatically extending grid\", some applications might provide the user the option to choose, even if the \"exact size\" is slower.", "author": "pleku", "createdAt": "2020-06-26T19:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0Mzk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE1MDQxMA==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446150410", "bodyText": "Just wondering, based on what you choose 4 for default estimation? For me it looks reasonable, because usually users have either not so much data to explore, or they apply filters to find something quicker and they scroll not so deeply, but is there any testers feedback about that?", "author": "mshabarov", "createdAt": "2020-06-26T12:22:48Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -443,77 +414,106 @@ public void setSizeCallback(\n     }\n \n     /**\n-     * Sets the size estimate callback to be used and switches the component to\n-     * undefined size. Any previously set callbacks or initial size are cleared.\n-     * The new estimate will be fetched after this roundtrip.\n+     * Sets the row count estimate to use and switches component to undefined\n+     * size. Any previously set count callback is cleared. The new estimate is\n+     * applied if the actual count has not been discovered and if the estimate\n+     * is greater than the number of requested items. Otherwise it is not\n+     * applied until there has been a reset.\n+     * <p>\n+     * <em>NOTE:</em> setting row count estimate that is less than two pages\n+     * (set with {@link #setPageSize(int)}) can cause extra requests initially\n+     * or after a reset.\n      * \n-     * @param sizeEstimateCallback\n-     *            the size estimate callback to use\n+     * @param rowCountEstimate\n+     *            the row count estimate to be used\n      */\n-    public void setSizeEstimateCallback(\n-            SizeEstimateCallback<T, ?> sizeEstimateCallback) {\n-        if (sizeEstimateCallback == null) {\n+    public void setRowCountEstimate(int rowCountEstimate) {\n+        if (rowCountEstimate < 1) {\n             throw new IllegalArgumentException(\n-                    \"Provided size estimate callback cannot be null - for \"\n-                            + \"switching between defined and undefined size use \"\n-                            + \"setDefinedSize(boolean) method instead.\");\n+                    \"Given row count estimate cannot be less than 1.\");\n         }\n-        clearSizeCallbacksAndState();\n-        this.sizeEstimateCallback = sizeEstimateCallback;\n+        this.rowCountEstimate = rowCountEstimate;\n+        this.countCallback = null;\n         definedSize = false;\n-        if (!skipSizeCheckUntilReset) {\n+        if (!skipSizeCheckUntilReset\n+                && requestedRange.getEnd() < rowCountEstimate) {\n             sizeReset = true;\n             requestFlush();\n         }\n     }\n \n     /**\n-     * Sets the initial size estimate to use and switches component to undefined\n-     * size. Any previously set size related callbacks are cleared. The new\n-     * estimate is only applied if it is greater than the number of requested\n-     * items. Otherwise it is not applied until there has been a reset.\n-     * <p>\n-     * <em>NOTE:</em> setting an initial size estimate that is less than two\n-     * pages (set with {@link #setPageSize(int)}) can cause extra requests\n-     * initially or after a reset.\n+     * Gets the row count estimate used.\n      * \n-     * @param initialSizeEstimate\n-     *            the initial size estimate to be used\n+     * @return the row count estimate used\n      */\n-    public void setInitialSizeEstimate(int initialSizeEstimate) {\n-        if (initialSizeEstimate < 1) {\n+    public int getRowCountEstimate() {\n+        int estimate = rowCountEstimate;\n+        if (estimate < 1) {\n+            estimate = pageSize * 4;", "originalCommit": "c0700a269287eee7ea0b3776ac51808091f0d157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE3MzIwNQ==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446173205", "bodyText": "It was based on my own testing and after discussion with @jouni.\nIt can be changed later on and we have over two months of time to change this.", "author": "pleku", "createdAt": "2020-06-26T13:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE1MDQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE1NjkzMg==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446156932", "bodyText": "what if rowCountEstimateIncrease < pageSize? in that case assumedSize would be still less than requestedRange.getEnd() + pageSize, is it fine?", "author": "mshabarov", "createdAt": "2020-06-26T12:36:42Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/DataCommunicator.java", "diffHunk": "@@ -616,102 +610,29 @@ public void setBackEndSorting(List<QuerySortOrder> sortOrder) {\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     protected int getDataProviderSize() {\n         assert definedSize : \"This method should never be called when using undefined size\";\n-        if (sizeCallback != null) {\n-            return sizeCallback.count(new Query(getFilter()));\n+        if (countCallback != null) {\n+            return countCallback.count(new Query(getFilter()));\n         } else {\n             return getDataProvider().size(new Query(getFilter()));\n         }\n     }\n \n     private void updateUndefinedSize() {\n         assert !definedSize : \"This method should never be called when using defined size\";\n-        // things have reset\n+        int previousAssumedSize = assumedSize;\n         if (resendEntireRange || sizeReset) {\n-            // 1. given size estimate\n-            int size = initialSizeEstimate;\n-            if (initialSizeEstimate > 0\n-                    && initialSizeEstimate <= requestedRange.getEnd()) {\n-                // don't let the initial size estimate set to lock component to\n-                // defined size -> increase the size so size it's not locked\n-                size = requestedRange.getEnd() + pageSize;\n-            }\n-            // 2. given estimate callback\n-            if (sizeEstimateCallback != null) {\n-                size = getNewSizeEstimateFromCallback(true);\n-            }\n-            // 3. default initial size\n-            if (size == -1) {\n-                size = getDefaultInitialSize();\n-            }\n-            getLogger(DataCommunicator.class).info(\n-                    \"Requested range: {} old size: {} new size: {}\",\n-                    requestedRange, assumedSize, size);\n-            assumedSize = size;\n+            // things have reset\n+            assumedSize = getRowCountEstimate();\n         } else {\n             // increase size estimate if the last page is being fetched\n             if (requestedRange.getEnd() + pageSize > assumedSize) {\n-                int previousAssumedSize = assumedSize;\n-                if (sizeEstimateCallback != null) {\n-                    assumedSize = getNewSizeEstimateFromCallback(false);\n-                } else {\n-                    // by default adjust size by multiple of page size\n-                    assumedSize += getEstimatedSizeIncrease();\n-                }\n-                getLogger(DataCommunicator.class).info(\n-                        \"Requested range: {} old size: {} new size: {}\",\n-                        requestedRange, previousAssumedSize, assumedSize);\n+                // by default adjust size by multiple of page size\n+                assumedSize += getRowCountEstimateIncrease();", "originalCommit": "c0700a269287eee7ea0b3776ac51808091f0d157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM2Nzg0MQ==", "url": "https://github.com/vaadin/flow/pull/8624#discussion_r446367841", "bodyText": "I realized that I've gone to \"wrong direction\". Fixed and added tests.", "author": "pleku", "createdAt": "2020-06-26T19:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE1NjkzMg=="}], "type": "inlineReview"}, {"oid": "8adf69fd40a9d1d4eb472ff6e456e6cdaed68bd2", "url": "https://github.com/vaadin/flow/commit/8adf69fd40a9d1d4eb472ff6e456e6cdaed68bd2", "message": "Review fixes", "committedDate": "2020-06-26T19:40:03Z", "type": "commit"}]}