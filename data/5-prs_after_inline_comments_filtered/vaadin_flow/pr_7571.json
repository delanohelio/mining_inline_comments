{"pr_number": 7571, "pr_title": "Node and npm download and installation", "pr_createdAt": "2020-02-13T12:55:45Z", "pr_url": "https://github.com/vaadin/flow/pull/7571", "timeline": [{"oid": "9f6388fb93b962af3d4e9e902ae0bcf02182e9b4", "url": "https://github.com/vaadin/flow/commit/9f6388fb93b962af3d4e9e902ae0bcf02182e9b4", "message": "Node and npm download and installation\n\nAdd features fron eirslett plugin to\ndownload and install node+npm\nto the system to a target directory.", "committedDate": "2020-02-13T12:54:49Z", "type": "commit"}, {"oid": "fd1b26902787a2889807088b6cfcf02020fef997", "url": "https://github.com/vaadin/flow/commit/fd1b26902787a2889807088b6cfcf02020fef997", "message": "Generate tar.gz for unix.", "committedDate": "2020-02-13T18:22:15Z", "type": "commit"}, {"oid": "8bfaf6cf8d9499441928c54158593c8fa884ef32", "url": "https://github.com/vaadin/flow/commit/8bfaf6cf8d9499441928c54158593c8fa884ef32", "message": "Fix test archive and serialization test", "committedDate": "2020-02-14T06:16:08Z", "type": "commit"}, {"oid": "c89e1e8ef12da4a21ace75a8cfe344db31a719f5", "url": "https://github.com/vaadin/flow/commit/c89e1e8ef12da4a21ace75a8cfe344db31a719f5", "message": "Move to base test class as they are checked for in multiple modules.", "committedDate": "2020-02-14T06:48:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MjM2Mg==", "url": "https://github.com/vaadin/flow/pull/7571#discussion_r379282362", "bodyText": "Exceptional return value of java.io.File.mkdirs() ignored in com.vaadin.flow.server.frontend.installer.DefaultArchiveExtractor.prepDestination(File, boolean)", "author": "vaadin-bot", "createdAt": "2020-02-14T07:24:21Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/installer/DefaultArchiveExtractor.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend.installer;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.AccessDeniedException;\n+import java.util.Enumeration;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n+import org.apache.commons.io.IOUtils;\n+\n+/**\n+ * Default implementation for file archive extraction.\n+ * <p>\n+ * Derived from eirslett/frontend-maven-plugin\n+ *\n+ * @since\n+ */\n+public final class DefaultArchiveExtractor implements ArchiveExtractor {\n+\n+    @Override\n+    public void extract(String archive, String destinationDirectory)\n+            throws ArchiveExtractionException {\n+        final File archiveFile = new File(archive);\n+\n+        try (FileInputStream fis = new FileInputStream(archiveFile)) {\n+            if (archiveFile.getAbsolutePath().endsWith(\"msi\")) {\n+                String command = \"msiexec /a \" + archiveFile.getAbsolutePath()\n+                        + \" /qn TARGETDIR=\\\"\" + destinationDirectory + \"\\\"\";\n+                Process child = Runtime.getRuntime().exec(command);\n+                try {\n+                    int result = child.waitFor();\n+                    if (result != 0) {\n+                        throw new ArchiveExtractionException(\n+                                \"Could not extract \" + archiveFile\n+                                        .getAbsolutePath() + \"; return code \"\n+                                        + result);\n+                    }\n+                } catch (InterruptedException e) {\n+                    throw new ArchiveExtractionException(\n+                            \"Unexpected interruption of while waiting for extraction process\",\n+                            e);\n+                }\n+            } else if (archiveFile.getAbsolutePath().endsWith(\"zip\")) {\n+                ZipFile zipFile = new ZipFile(archiveFile);\n+                try {\n+                    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n+                    while (entries.hasMoreElements()) {\n+                        ZipEntry entry = entries.nextElement();\n+                        final File destPath = new File(\n+                                destinationDirectory + File.separator + entry\n+                                        .getName());\n+                        prepDestination(destPath, entry.isDirectory());\n+                        if (!entry.isDirectory()) {\n+                            InputStream in = null;\n+                            OutputStream out = null;\n+                            try {\n+                                in = zipFile.getInputStream(entry);\n+                                out = new FileOutputStream(destPath);\n+                                IOUtils.copy(in, out);\n+                            } finally {\n+                                IOUtils.closeQuietly(in);\n+                                IOUtils.closeQuietly(out);\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    zipFile.close();\n+                }\n+            } else {\n+                // TarArchiveInputStream can be constructed with a normal FileInputStream if\n+                // we ever need to extract regular '.tar' files.\n+                TarArchiveInputStream tarIn = null;\n+                try {\n+                    tarIn = new TarArchiveInputStream(\n+                            new GzipCompressorInputStream(fis));\n+\n+                    TarArchiveEntry tarEntry = tarIn.getNextTarEntry();\n+                    String canonicalDestinationDirectory = new File(\n+                            destinationDirectory).getCanonicalPath();\n+                    while (tarEntry != null) {\n+                        // Create a file for this tarEntry\n+                        final File destPath = new File(\n+                                destinationDirectory + File.separator + tarEntry\n+                                        .getName());\n+                        prepDestination(destPath, tarEntry.isDirectory());\n+\n+                        if (!startsWithPath(destPath.getCanonicalPath(),\n+                                canonicalDestinationDirectory)) {\n+                            throw new IOException(\n+                                    \"Expanding \" + tarEntry.getName()\n+                                            + \" would create file outside of \"\n+                                            + canonicalDestinationDirectory);\n+                        }\n+\n+                        if (!tarEntry.isDirectory()) {\n+                            destPath.createNewFile();\n+                            boolean isExecutable =\n+                                    (tarEntry.getMode() & 0100) > 0;\n+                            destPath.setExecutable(isExecutable);\n+\n+                            OutputStream out = null;\n+                            try {\n+                                out = new FileOutputStream(destPath);\n+                                IOUtils.copy(tarIn, out);\n+                            } finally {\n+                                IOUtils.closeQuietly(out);\n+                            }\n+                        }\n+                        tarEntry = tarIn.getNextTarEntry();\n+                    }\n+                } finally {\n+                    IOUtils.closeQuietly(tarIn);\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new ArchiveExtractionException(\n+                    \"Could not extract archive: '\" + archive + \"'\", e);\n+        }\n+    }\n+\n+    private void prepDestination(File path, boolean directory)\n+            throws IOException {\n+        if (directory) {\n+            path.mkdirs();", "originalCommit": "c89e1e8ef12da4a21ace75a8cfe344db31a719f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d5022cd26158ec53c191382cc636330efdf96738", "url": "https://github.com/vaadin/flow/commit/d5022cd26158ec53c191382cc636330efdf96738", "message": "Merge branch 'master' into issues/7562_download_node\n\n# Conflicts:\n#\tflow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java", "committedDate": "2020-02-14T07:41:53Z", "type": "commit"}, {"oid": "e6184955e8f83ae7b7b16f54c33e4483bdfe7fc3", "url": "https://github.com/vaadin/flow/commit/e6184955e8f83ae7b7b16f54c33e4483bdfe7fc3", "message": "Update how we install.\n\nadd some Javadocs.", "committedDate": "2020-02-14T09:19:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM2MzM1NA==", "url": "https://github.com/vaadin/flow/pull/7571#discussion_r379363354", "bodyText": "Complete the task associated to this TODO comment.", "author": "vaadin-bot", "createdAt": "2020-02-14T10:42:17Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java", "diffHunk": "@@ -378,7 +380,44 @@ public static String getNodeExecutable(String baseDir) {\n         String command = isWindows() ? \"node.exe\" : \"node\";\n         String defaultNode = FrontendUtils.isWindows() ? \"node/node.exe\"\n                 : \"node/node\";\n-        return getExecutable(baseDir, command, defaultNode).getAbsolutePath();\n+        return getExecutable(baseDir, command, defaultNode, true)\n+                .getAbsolutePath();\n+    }\n+\n+    /**\n+     * Install node and npm into target directory.\n+     *\n+     * @param installDirectory\n+     *         installation directory\n+     * @param nodeVersion\n+     *         node version to install\n+     * @param downloadRoot\n+     *         optional download root for downloading node. May be a filesystem\n+     *         file or a URL see {@link NodeInstaller#setNodeDownloadRoot(String)}.\n+     *         Must be a valid URI format.\n+     * @return node installation path\n+     */\n+    protected static String installNode(File installDirectory,\n+            String nodeVersion, Optional<String> downloadRoot) {\n+        NodeInstaller nodeInstaller = new NodeInstaller(installDirectory,\n+                getProxies()).setNodeVersion(nodeVersion);\n+        if (downloadRoot.isPresent()) {\n+            nodeInstaller.setNodeDownloadRoot(downloadRoot.get());\n+        }\n+\n+        try {\n+            nodeInstaller.install();\n+        } catch (InstallationException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        String command = isWindows() ? \"node.exe\" : \"node\";\n+        return new File(nodeInstaller.getInstallDirectory(), command).toString();\n+    }\n+\n+    private static List<ProxyConfig.Proxy> getProxies() {\n+        // TODO: Implement proxy collection #7567", "originalCommit": "e6184955e8f83ae7b7b16f54c33e4483bdfe7fc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b7fcd3091f005443e54acd2fca7b5f7c68d243f1", "url": "https://github.com/vaadin/flow/commit/b7fcd3091f005443e54acd2fca7b5f7c68d243f1", "message": "Rework archive extractor and add test\n\nMode JavaDocs.", "committedDate": "2020-02-14T11:34:57Z", "type": "commit"}, {"oid": "00495567a8e861cb2c3503f64566197d3ba29c98", "url": "https://github.com/vaadin/flow/commit/00495567a8e861cb2c3503f64566197d3ba29c98", "message": "More cleanup", "committedDate": "2020-02-14T15:43:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NTY3Mw==", "url": "https://github.com/vaadin/flow/pull/7571#discussion_r379545673", "bodyText": "Exceptional return value of java.io.File.mkdirs() ignored in com.vaadin.flow.server.frontend.installer.DefaultFileDownloader.downloadFile(File, URI)", "author": "vaadin-bot", "createdAt": "2020-02-14T17:09:09Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/installer/DefaultFileDownloader.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend.installer;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.AuthCache;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.protocol.HttpClientContext;\n+import org.apache.http.impl.auth.BasicScheme;\n+import org.apache.http.impl.client.BasicAuthCache;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Default file downloader implementation.\n+ * <p>\n+ * Derived from eirslett/frontend-maven-plugin\n+ *\n+ * @since\n+ */\n+public final class DefaultFileDownloader implements FileDownloader {\n+    public static final String HTTPS_PROTOCOLS = \"https.protocols\";\n+\n+    private final ProxyConfig proxyConfig;\n+\n+    private String userName;\n+    private String password;\n+\n+    /**\n+     * Construct file downloader with given proxy configuration.\n+     *\n+     * @param proxyConfig\n+     *         proxy configuration to use for file download\n+     */\n+    public DefaultFileDownloader(ProxyConfig proxyConfig) {\n+        this.proxyConfig = proxyConfig;\n+    }\n+\n+    @Override\n+    public void download(String downloadTarget, File destination,\n+            String userName, String password) throws DownloadException {\n+        this.userName = userName;\n+        this.password = password;\n+\n+        String fixedDownloadUri = FilenameUtils\n+                .separatorsToUnix(downloadTarget);\n+        String oldProtocols = System.setProperty(HTTPS_PROTOCOLS, \"TLSv1.2\");\n+        try {\n+            // force tls to 1.2 since github removed weak cryptographic standards\n+            // https://blog.github.com/2018-02-02-weak-cryptographic-standards-removal-notice/\n+            URI downloadURI = new URI(fixedDownloadUri);\n+            if (\"file\".equalsIgnoreCase(downloadURI.getScheme())) {\n+                FileUtils.copyFile(new File(downloadURI), destination);\n+            } else {\n+                downloadFile(destination, downloadURI);\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            throw new DownloadException(\n+                    \"Could not download \" + fixedDownloadUri, e);\n+        } finally {\n+            // Return original protocol property\n+            if (oldProtocols == null) {\n+                System.clearProperty(HTTPS_PROTOCOLS);\n+            } else {\n+                System.setProperty(HTTPS_PROTOCOLS, oldProtocols);\n+            }\n+        }\n+    }\n+\n+    public void downloadFile(File destination, URI downloadUri)\n+            throws IOException, DownloadException {\n+        CloseableHttpResponse response = execute(downloadUri);\n+        int statusCode = response.getStatusLine().getStatusCode();\n+        if (statusCode != 200) {\n+            throw new DownloadException(\n+                    \"Got error code \" + statusCode + \" from the server.\");\n+        }\n+        new File(\n+                FilenameUtils.getFullPathNoEndSeparator(destination.toString()))\n+                .mkdirs();", "originalCommit": "00495567a8e861cb2c3503f64566197d3ba29c98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NTcwNQ==", "url": "https://github.com/vaadin/flow/pull/7571#discussion_r379545705", "bodyText": "Invoke method(s) only conditionally.", "author": "vaadin-bot", "createdAt": "2020-02-14T17:09:12Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/installer/DefaultFileDownloader.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend.installer;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.AuthCache;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.protocol.HttpClientContext;\n+import org.apache.http.impl.auth.BasicScheme;\n+import org.apache.http.impl.client.BasicAuthCache;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Default file downloader implementation.\n+ * <p>\n+ * Derived from eirslett/frontend-maven-plugin\n+ *\n+ * @since\n+ */\n+public final class DefaultFileDownloader implements FileDownloader {\n+    public static final String HTTPS_PROTOCOLS = \"https.protocols\";\n+\n+    private final ProxyConfig proxyConfig;\n+\n+    private String userName;\n+    private String password;\n+\n+    /**\n+     * Construct file downloader with given proxy configuration.\n+     *\n+     * @param proxyConfig\n+     *         proxy configuration to use for file download\n+     */\n+    public DefaultFileDownloader(ProxyConfig proxyConfig) {\n+        this.proxyConfig = proxyConfig;\n+    }\n+\n+    @Override\n+    public void download(String downloadTarget, File destination,\n+            String userName, String password) throws DownloadException {\n+        this.userName = userName;\n+        this.password = password;\n+\n+        String fixedDownloadUri = FilenameUtils\n+                .separatorsToUnix(downloadTarget);\n+        String oldProtocols = System.setProperty(HTTPS_PROTOCOLS, \"TLSv1.2\");\n+        try {\n+            // force tls to 1.2 since github removed weak cryptographic standards\n+            // https://blog.github.com/2018-02-02-weak-cryptographic-standards-removal-notice/\n+            URI downloadURI = new URI(fixedDownloadUri);\n+            if (\"file\".equalsIgnoreCase(downloadURI.getScheme())) {\n+                FileUtils.copyFile(new File(downloadURI), destination);\n+            } else {\n+                downloadFile(destination, downloadURI);\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            throw new DownloadException(\n+                    \"Could not download \" + fixedDownloadUri, e);\n+        } finally {\n+            // Return original protocol property\n+            if (oldProtocols == null) {\n+                System.clearProperty(HTTPS_PROTOCOLS);\n+            } else {\n+                System.setProperty(HTTPS_PROTOCOLS, oldProtocols);\n+            }\n+        }\n+    }\n+\n+    public void downloadFile(File destination, URI downloadUri)\n+            throws IOException, DownloadException {\n+        CloseableHttpResponse response = execute(downloadUri);\n+        int statusCode = response.getStatusLine().getStatusCode();\n+        if (statusCode != 200) {\n+            throw new DownloadException(\n+                    \"Got error code \" + statusCode + \" from the server.\");\n+        }\n+        new File(\n+                FilenameUtils.getFullPathNoEndSeparator(destination.toString()))\n+                .mkdirs();\n+        ReadableByteChannel rbc = Channels\n+                .newChannel(response.getEntity().getContent());\n+        try (FileOutputStream fos = new FileOutputStream(destination)) {\n+            fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n+        }\n+    }\n+\n+    private CloseableHttpResponse execute(URI requestUri) throws IOException {\n+        CloseableHttpResponse response;\n+        ProxyConfig.Proxy proxy = proxyConfig\n+                .getProxyForUrl(requestUri.toString());\n+        if (proxy != null) {\n+            getLogger().info(\"Downloading via proxy {}\", proxy.toString());", "originalCommit": "00495567a8e861cb2c3503f64566197d3ba29c98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NTczMA==", "url": "https://github.com/vaadin/flow/pull/7571#discussion_r379545730", "bodyText": "Use already-defined constant 'INSTALL_PATH' instead of duplicating its value here.", "author": "vaadin-bot", "createdAt": "2020-02-14T17:09:16Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/installer/NodeInstaller.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend.installer;\n+\n+import java.io.EOFException;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.server.frontend.FrontendUtils;\n+import com.vaadin.flow.server.frontend.FrontendVersion;\n+\n+/**\n+ * Node installation class.\n+ * <p>\n+ * Derived from eirslett/frontend-maven-plugin\n+ *\n+ * @since\n+ */\n+public class NodeInstaller {\n+\n+    public static final String INSTALL_PATH = \"/node\";\n+\n+    public static final String DEFAULT_NODEJS_DOWNLOAD_ROOT = \"https://nodejs.org/dist/\";\n+\n+    private static final String NODE_WINDOWS =\n+            INSTALL_PATH.replaceAll(\"/\", \"\\\\\\\\\") + \"\\\\node.exe\";\n+    private static final String NODE_DEFAULT = INSTALL_PATH + \"/node\";", "originalCommit": "00495567a8e861cb2c3503f64566197d3ba29c98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NTc1MQ==", "url": "https://github.com/vaadin/flow/pull/7571#discussion_r379545751", "bodyText": "Either re-interrupt this method or rethrow the \"InterruptedException\".", "author": "vaadin-bot", "createdAt": "2020-02-14T17:09:19Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/installer/DefaultArchiveExtractor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend.installer;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.AccessDeniedException;\n+import java.util.Enumeration;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n+import org.apache.commons.io.IOUtils;\n+\n+/**\n+ * Default implementation for file archive extraction.\n+ * <p>\n+ * Derived from eirslett/frontend-maven-plugin\n+ *\n+ * @since\n+ */\n+public final class DefaultArchiveExtractor implements ArchiveExtractor {\n+\n+    @Override\n+    public void extract(File archiveFile, File destinationDirectory)\n+            throws ArchiveExtractionException {\n+        try {\n+            if (archiveFile.getAbsolutePath().endsWith(\"msi\")) {\n+                extractMSIArchive(archiveFile, destinationDirectory);\n+            } else if (archiveFile.getAbsolutePath().endsWith(\"zip\")) {\n+                extractZipArchive(archiveFile, destinationDirectory);\n+            } else {\n+                extractGzipTarArchive(archiveFile, destinationDirectory);\n+            }\n+        } catch (IOException e) {\n+            throw new ArchiveExtractionException(\n+                    \"Could not extract archive: '\" + archiveFile + \"'\", e);\n+        }\n+    }\n+\n+    private void extractMSIArchive(File archiveFile, File destinationDirectory)\n+            throws IOException, ArchiveExtractionException {\n+        String command = \"msiexec /a \" + archiveFile.getAbsolutePath()\n+                + \" /qn TARGETDIR=\\\"\" + destinationDirectory + \"\\\"\";\n+        Process child = Runtime.getRuntime().exec(command);\n+        try {\n+            int result = child.waitFor();\n+            if (result != 0) {\n+                throw new ArchiveExtractionException(\n+                        \"Could not extract \" + archiveFile.getAbsolutePath()\n+                                + \"; return code \" + result);\n+            }\n+        } catch (InterruptedException e) {", "originalCommit": "00495567a8e861cb2c3503f64566197d3ba29c98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NTc1Nw==", "url": "https://github.com/vaadin/flow/pull/7571#discussion_r379545757", "bodyText": "Exceptional return value of java.io.File.createNewFile() ignored in com.vaadin.flow.server.frontend.installer.DefaultArchiveExtractor.copyTarFileContents(TarArchiveInputStream, TarArchiveEntry, File) \n Do something with the \"boolean\" value returned by \"createNewFile\".", "author": "vaadin-bot", "createdAt": "2020-02-14T17:09:20Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/installer/DefaultArchiveExtractor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend.installer;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.AccessDeniedException;\n+import java.util.Enumeration;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n+import org.apache.commons.io.IOUtils;\n+\n+/**\n+ * Default implementation for file archive extraction.\n+ * <p>\n+ * Derived from eirslett/frontend-maven-plugin\n+ *\n+ * @since\n+ */\n+public final class DefaultArchiveExtractor implements ArchiveExtractor {\n+\n+    @Override\n+    public void extract(File archiveFile, File destinationDirectory)\n+            throws ArchiveExtractionException {\n+        try {\n+            if (archiveFile.getAbsolutePath().endsWith(\"msi\")) {\n+                extractMSIArchive(archiveFile, destinationDirectory);\n+            } else if (archiveFile.getAbsolutePath().endsWith(\"zip\")) {\n+                extractZipArchive(archiveFile, destinationDirectory);\n+            } else {\n+                extractGzipTarArchive(archiveFile, destinationDirectory);\n+            }\n+        } catch (IOException e) {\n+            throw new ArchiveExtractionException(\n+                    \"Could not extract archive: '\" + archiveFile + \"'\", e);\n+        }\n+    }\n+\n+    private void extractMSIArchive(File archiveFile, File destinationDirectory)\n+            throws IOException, ArchiveExtractionException {\n+        String command = \"msiexec /a \" + archiveFile.getAbsolutePath()\n+                + \" /qn TARGETDIR=\\\"\" + destinationDirectory + \"\\\"\";\n+        Process child = Runtime.getRuntime().exec(command);\n+        try {\n+            int result = child.waitFor();\n+            if (result != 0) {\n+                throw new ArchiveExtractionException(\n+                        \"Could not extract \" + archiveFile.getAbsolutePath()\n+                                + \"; return code \" + result);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new ArchiveExtractionException(\n+                    \"Unexpected interruption of while waiting for extraction process\",\n+                    e);\n+        }\n+    }\n+\n+    private void extractZipArchive(File archiveFile, File destinationDirectory)\n+            throws IOException {\n+        ZipFile zipFile = new ZipFile(archiveFile);\n+        try {\n+            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n+            while (entries.hasMoreElements()) {\n+                ZipEntry entry = entries.nextElement();\n+                final File destPath = new File(\n+                        destinationDirectory + File.separator + entry\n+                                .getName());\n+                prepDestination(destPath, entry.isDirectory());\n+\n+                copyZipFileContents(zipFile, entry, destPath);\n+            }\n+        } finally {\n+            zipFile.close();\n+        }\n+    }\n+\n+    /**\n+     * Copy ZipEntry file contents to target path.\n+     *\n+     * @param zipFile\n+     *         zip file\n+     * @param entry\n+     *         zip entry\n+     * @param destinationFile\n+     *         destination\n+     * @throws IOException\n+     *         thrown if copying fails\n+     */\n+    private void copyZipFileContents(ZipFile zipFile, ZipEntry entry,\n+            File destinationFile) throws IOException {\n+        if (entry.isDirectory()) {\n+            return;\n+        }\n+        try (InputStream in = zipFile\n+                .getInputStream(entry); OutputStream out = new FileOutputStream(\n+                destinationFile)) {\n+            IOUtils.copy(in, out);\n+        }\n+    }\n+\n+    private void extractGzipTarArchive(File archive, File destinationDirectory)\n+            throws IOException {\n+        // TarArchiveInputStream can be constructed with a normal FileInputStream if\n+        // we ever need to extract regular '.tar' files.\n+\n+        try (FileInputStream fis = new FileInputStream(archive);\n+             GzipCompressorInputStream gis = new GzipCompressorInputStream(fis);\n+             TarArchiveInputStream tarIn = new TarArchiveInputStream(gis)) {\n+\n+            TarArchiveEntry tarEntry = tarIn.getNextTarEntry();\n+            String canonicalDestinationDirectory = destinationDirectory\n+                    .getCanonicalPath();\n+            while (tarEntry != null) {\n+                // Create a file for this tarEntry\n+                final File destPath = new File(\n+                        destinationDirectory + File.separator + tarEntry\n+                                .getName());\n+                prepDestination(destPath, tarEntry.isDirectory());\n+\n+                if (!startsWithPath(destPath.getCanonicalPath(),\n+                        canonicalDestinationDirectory)) {\n+                    throw new IOException(\"Expanding \" + tarEntry.getName()\n+                            + \" would create file outside of \"\n+                            + canonicalDestinationDirectory);\n+                }\n+\n+                copyTarFileContents(tarIn, tarEntry, destPath);\n+                tarEntry = tarIn.getNextTarEntry();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy TarArchiveEntry file contents to target path.\n+     * Set file to executable if marked so in the entry.\n+     *\n+     * @param tarIn\n+     *         tar archive input stream\n+     * @param tarEntry\n+     *         tar archive entry\n+     * @param destinationFile\n+     *         destination\n+     * @throws IOException\n+     *         thrown if copying fails\n+     */\n+    private void copyTarFileContents(TarArchiveInputStream tarIn,\n+            TarArchiveEntry tarEntry, File destinationFile) throws IOException {\n+        if (tarEntry.isDirectory()) {\n+            return;\n+        }\n+        destinationFile.createNewFile();", "originalCommit": "00495567a8e861cb2c3503f64566197d3ba29c98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NTc2Ng==", "url": "https://github.com/vaadin/flow/pull/7571#discussion_r379545766", "bodyText": "Do something with the \"boolean\" value returned by \"setExecutable\".", "author": "vaadin-bot", "createdAt": "2020-02-14T17:09:21Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/installer/DefaultArchiveExtractor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend.installer;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.AccessDeniedException;\n+import java.util.Enumeration;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n+import org.apache.commons.io.IOUtils;\n+\n+/**\n+ * Default implementation for file archive extraction.\n+ * <p>\n+ * Derived from eirslett/frontend-maven-plugin\n+ *\n+ * @since\n+ */\n+public final class DefaultArchiveExtractor implements ArchiveExtractor {\n+\n+    @Override\n+    public void extract(File archiveFile, File destinationDirectory)\n+            throws ArchiveExtractionException {\n+        try {\n+            if (archiveFile.getAbsolutePath().endsWith(\"msi\")) {\n+                extractMSIArchive(archiveFile, destinationDirectory);\n+            } else if (archiveFile.getAbsolutePath().endsWith(\"zip\")) {\n+                extractZipArchive(archiveFile, destinationDirectory);\n+            } else {\n+                extractGzipTarArchive(archiveFile, destinationDirectory);\n+            }\n+        } catch (IOException e) {\n+            throw new ArchiveExtractionException(\n+                    \"Could not extract archive: '\" + archiveFile + \"'\", e);\n+        }\n+    }\n+\n+    private void extractMSIArchive(File archiveFile, File destinationDirectory)\n+            throws IOException, ArchiveExtractionException {\n+        String command = \"msiexec /a \" + archiveFile.getAbsolutePath()\n+                + \" /qn TARGETDIR=\\\"\" + destinationDirectory + \"\\\"\";\n+        Process child = Runtime.getRuntime().exec(command);\n+        try {\n+            int result = child.waitFor();\n+            if (result != 0) {\n+                throw new ArchiveExtractionException(\n+                        \"Could not extract \" + archiveFile.getAbsolutePath()\n+                                + \"; return code \" + result);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new ArchiveExtractionException(\n+                    \"Unexpected interruption of while waiting for extraction process\",\n+                    e);\n+        }\n+    }\n+\n+    private void extractZipArchive(File archiveFile, File destinationDirectory)\n+            throws IOException {\n+        ZipFile zipFile = new ZipFile(archiveFile);\n+        try {\n+            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n+            while (entries.hasMoreElements()) {\n+                ZipEntry entry = entries.nextElement();\n+                final File destPath = new File(\n+                        destinationDirectory + File.separator + entry\n+                                .getName());\n+                prepDestination(destPath, entry.isDirectory());\n+\n+                copyZipFileContents(zipFile, entry, destPath);\n+            }\n+        } finally {\n+            zipFile.close();\n+        }\n+    }\n+\n+    /**\n+     * Copy ZipEntry file contents to target path.\n+     *\n+     * @param zipFile\n+     *         zip file\n+     * @param entry\n+     *         zip entry\n+     * @param destinationFile\n+     *         destination\n+     * @throws IOException\n+     *         thrown if copying fails\n+     */\n+    private void copyZipFileContents(ZipFile zipFile, ZipEntry entry,\n+            File destinationFile) throws IOException {\n+        if (entry.isDirectory()) {\n+            return;\n+        }\n+        try (InputStream in = zipFile\n+                .getInputStream(entry); OutputStream out = new FileOutputStream(\n+                destinationFile)) {\n+            IOUtils.copy(in, out);\n+        }\n+    }\n+\n+    private void extractGzipTarArchive(File archive, File destinationDirectory)\n+            throws IOException {\n+        // TarArchiveInputStream can be constructed with a normal FileInputStream if\n+        // we ever need to extract regular '.tar' files.\n+\n+        try (FileInputStream fis = new FileInputStream(archive);\n+             GzipCompressorInputStream gis = new GzipCompressorInputStream(fis);\n+             TarArchiveInputStream tarIn = new TarArchiveInputStream(gis)) {\n+\n+            TarArchiveEntry tarEntry = tarIn.getNextTarEntry();\n+            String canonicalDestinationDirectory = destinationDirectory\n+                    .getCanonicalPath();\n+            while (tarEntry != null) {\n+                // Create a file for this tarEntry\n+                final File destPath = new File(\n+                        destinationDirectory + File.separator + tarEntry\n+                                .getName());\n+                prepDestination(destPath, tarEntry.isDirectory());\n+\n+                if (!startsWithPath(destPath.getCanonicalPath(),\n+                        canonicalDestinationDirectory)) {\n+                    throw new IOException(\"Expanding \" + tarEntry.getName()\n+                            + \" would create file outside of \"\n+                            + canonicalDestinationDirectory);\n+                }\n+\n+                copyTarFileContents(tarIn, tarEntry, destPath);\n+                tarEntry = tarIn.getNextTarEntry();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy TarArchiveEntry file contents to target path.\n+     * Set file to executable if marked so in the entry.\n+     *\n+     * @param tarIn\n+     *         tar archive input stream\n+     * @param tarEntry\n+     *         tar archive entry\n+     * @param destinationFile\n+     *         destination\n+     * @throws IOException\n+     *         thrown if copying fails\n+     */\n+    private void copyTarFileContents(TarArchiveInputStream tarIn,\n+            TarArchiveEntry tarEntry, File destinationFile) throws IOException {\n+        if (tarEntry.isDirectory()) {\n+            return;\n+        }\n+        destinationFile.createNewFile();\n+        boolean isExecutable = (tarEntry.getMode() & 0100) > 0;\n+        destinationFile.setExecutable(isExecutable);", "originalCommit": "00495567a8e861cb2c3503f64566197d3ba29c98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b554d3303596734c9117ed84b3a31631649f6592", "url": "https://github.com/vaadin/flow/commit/b554d3303596734c9117ed84b3a31631649f6592", "message": "Refactor NodeInstaller\n\nShorter cleaner methods and combined\nduplicate code usage", "committedDate": "2020-02-17T06:29:47Z", "type": "commit"}, {"oid": "c9d506e0e080e5c5f91226482f143d2b5ffe5f20", "url": "https://github.com/vaadin/flow/commit/c9d506e0e080e5c5f91226482f143d2b5ffe5f20", "message": "Use URI instead of String", "committedDate": "2020-02-17T07:17:53Z", "type": "commit"}, {"oid": "9662b4619bb3c41434a259c2ca251492a84117ff", "url": "https://github.com/vaadin/flow/commit/9662b4619bb3c41434a259c2ca251492a84117ff", "message": "Change exception\n\nnew line.", "committedDate": "2020-02-17T07:22:37Z", "type": "commit"}, {"oid": "b1e8931ac65a1a0606f5030fccb1049a4d078039", "url": "https://github.com/vaadin/flow/commit/b1e8931ac65a1a0606f5030fccb1049a4d078039", "message": "Fix serialization test.", "committedDate": "2020-02-17T07:44:33Z", "type": "commit"}, {"oid": "819901b880dc88cf7a0614f971ad68879f55b11f", "url": "https://github.com/vaadin/flow/commit/819901b880dc88cf7a0614f971ad68879f55b11f", "message": "Fix updated chrome", "committedDate": "2020-02-17T08:28:36Z", "type": "commit"}, {"oid": "147f7199e60180c019f852d58fc66caf2f66f31f", "url": "https://github.com/vaadin/flow/commit/147f7199e60180c019f852d58fc66caf2f66f31f", "message": "Merge branch 'master' into issues/7562_download_node\n\n# Conflicts:\n#\tflow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java", "committedDate": "2020-02-17T09:51:12Z", "type": "commit"}, {"oid": "67fe9d29d049a2b4bd381610c1e60e1c62f1c1d5", "url": "https://github.com/vaadin/flow/commit/67fe9d29d049a2b4bd381610c1e60e1c62f1c1d5", "message": "Method visibilites\n\nSmall code cleanup.\nAdded failing archive test.", "committedDate": "2020-02-17T10:20:00Z", "type": "commit"}, {"oid": "d2e0724e8c28739b56981d5fda02512c98ad96c2", "url": "https://github.com/vaadin/flow/commit/d2e0724e8c28739b56981d5fda02512c98ad96c2", "message": "Use node_modules string from FrontendUtils.", "committedDate": "2020-02-17T10:55:49Z", "type": "commit"}, {"oid": "124fa47567f1b9fd0da763b187bfb4c2d74c9b57", "url": "https://github.com/vaadin/flow/commit/124fa47567f1b9fd0da763b187bfb4c2d74c9b57", "message": "Add simple NodeInstallerTest", "committedDate": "2020-02-17T10:59:30Z", "type": "commit"}, {"oid": "6239c7d5a8be2b2bc3f33b5ab43a81a476a92a11", "url": "https://github.com/vaadin/flow/commit/6239c7d5a8be2b2bc3f33b5ab43a81a476a92a11", "message": "Add test for default downloader", "committedDate": "2020-02-17T11:22:25Z", "type": "commit"}, {"oid": "1542e8b65ec4170e05c00f349febb4fcfcad19e5", "url": "https://github.com/vaadin/flow/commit/1542e8b65ec4170e05c00f349febb4fcfcad19e5", "message": "missing new line", "committedDate": "2020-02-17T12:24:05Z", "type": "commit"}, {"oid": "f4b589b5115025b219f1215b3fad245a78174540", "url": "https://github.com/vaadin/flow/commit/f4b589b5115025b219f1215b3fad245a78174540", "message": "Final refactoring.\n\nSonar fixes for methods used.", "committedDate": "2020-02-18T05:16:14Z", "type": "commit"}, {"oid": "e763f6b7b3b3fa4a463295fdfa699af167946fd2", "url": "https://github.com/vaadin/flow/commit/e763f6b7b3b3fa4a463295fdfa699af167946fd2", "message": "Merge branch 'master' into issues/7562_download_node", "committedDate": "2020-02-18T05:17:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ2MTc2Nw==", "url": "https://github.com/vaadin/flow/pull/7571#discussion_r380461767", "bodyText": "Exceptional return value of java.io.File.mkdirs() ignored in com.vaadin.flow.server.frontend.installer.NodeInstaller$InstallData.resolveArchive(String, String, String, String)", "author": "vaadin-bot", "createdAt": "2020-02-18T05:31:25Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/installer/NodeInstaller.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.frontend.installer;\n+\n+import java.io.EOFException;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vaadin.flow.server.frontend.FrontendUtils;\n+import com.vaadin.flow.server.frontend.FrontendVersion;\n+\n+/**\n+ * Node installation class.\n+ * <p>\n+ * Derived from eirslett/frontend-maven-plugin\n+ *\n+ * @since\n+ */\n+public class NodeInstaller {\n+\n+    public static final String INSTALL_PATH = \"/node\";\n+\n+    public static final String DEFAULT_NODEJS_DOWNLOAD_ROOT = \"https://nodejs.org/dist/\";\n+\n+    private static final String NODE_WINDOWS =\n+            INSTALL_PATH.replaceAll(\"/\", \"\\\\\\\\\") + \"\\\\node.exe\";\n+    private static final String NODE_DEFAULT = INSTALL_PATH + \"/node\";\n+\n+    public static final String PROVIDED_VERSION = \"provided\";\n+\n+    private final Object lock = new Object();\n+\n+    private String npmVersion = PROVIDED_VERSION;\n+    private String nodeVersion;\n+    private URI nodeDownloadRoot;\n+    private String userName;\n+    private String password;\n+\n+    private final File installDirectory;\n+    private final Platform platform;\n+\n+    private final ArchiveExtractor archiveExtractor;\n+\n+    private final FileDownloader fileDownloader;\n+\n+    /**\n+     * Create NodeInstaller with default extractor and downloader and guess\n+     * platform.\n+     *\n+     * @param installDirectory\n+     *         installation directory\n+     * @param proxies\n+     *         list of proxies\n+     */\n+    public NodeInstaller(File installDirectory,\n+            List<ProxyConfig.Proxy> proxies) {\n+        this(installDirectory, Platform.guess(), proxies);\n+    }\n+\n+    /**\n+     * Create NoodeInstaller with default extractor and downloader.\n+     *\n+     * @param installDirectory\n+     *         installation directory\n+     * @param platform\n+     *         platform information\n+     * @param proxies\n+     *         list of proxies\n+     */\n+    public NodeInstaller(File installDirectory, Platform platform,\n+            List<ProxyConfig.Proxy> proxies) {\n+        this(installDirectory, platform, new DefaultArchiveExtractor(),\n+                new DefaultFileDownloader(new ProxyConfig(proxies)));\n+    }\n+\n+    /**\n+     * Initialize a new NodeInstaller.\n+     *\n+     * @param installDirectory\n+     *         installation directory\n+     * @param platform\n+     *         platform information\n+     * @param archiveExtractor\n+     *         archive extractor\n+     * @param fileDownloader\n+     *         file downloader\n+     */\n+    public NodeInstaller(File installDirectory, Platform platform,\n+            ArchiveExtractor archiveExtractor, FileDownloader fileDownloader) {\n+        this.installDirectory = installDirectory;\n+        this.platform = platform;\n+        this.archiveExtractor = archiveExtractor;\n+        this.fileDownloader = fileDownloader;\n+    }\n+\n+    /**\n+     * Set the node version to install. (given as \"v12.16.0\")\n+     *\n+     * @param nodeVersion\n+     *         version string\n+     * @return this\n+     */\n+    public NodeInstaller setNodeVersion(String nodeVersion) {\n+        this.nodeVersion = nodeVersion;\n+        return this;\n+    }\n+\n+    /**\n+     * Set a custom download root.\n+     * <p>\n+     * This should be a url or directory under which we can find a directory\n+     * {@link #nodeVersion} and there should then exist the archived node\n+     * packages.\n+     * For instance for v12.16.0 we should have under nodeDownloadRoot:\n+     * ./v12.6.0/node-v12.16.0-linux-x64.tar.xz\n+     * ./v12.6.0/node-v12.16.0-darwin-x64.tar.gz\n+     * ./v12.6.0/node-v12.16.0-win-x64.zip\n+     * ./v12.6.0/node-v12.16.0-win-x86.zip\n+     *\n+     * @param nodeDownloadRoot\n+     *         custom download root\n+     * @return this\n+     */\n+    public NodeInstaller setNodeDownloadRoot(URI nodeDownloadRoot) {\n+        this.nodeDownloadRoot = nodeDownloadRoot;\n+        return this;\n+    }\n+\n+    /**\n+     * Set user name to use.\n+     *\n+     * @param userName\n+     *         user name\n+     * @return this\n+     */\n+    public NodeInstaller setUserName(String userName) {\n+        this.userName = userName;\n+        return this;\n+    }\n+\n+    /**\n+     * Set password to use.\n+     *\n+     * @param password\n+     *         password\n+     * @return this\n+     */\n+    public NodeInstaller setPassword(String password) {\n+        this.password = password;\n+        return this;\n+    }\n+\n+    private boolean npmProvided() throws InstallationException {\n+        if (PROVIDED_VERSION.equals(npmVersion)) {\n+            if (Integer.parseInt(nodeVersion.replace(\"v\", \"\").split(\"[.]\")[0])\n+                    < 4) {\n+                throw new InstallationException(\"NPM version is '\" + npmVersion\n+                        + \"' but Node didn't include NPM prior to v4.0.0\");\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Install node and NPM.\n+     *\n+     * @throws InstallationException\n+     *         exception thrown when installation fails\n+     */\n+    public void install() throws InstallationException {\n+        // use lock object for a synchronized block\n+        synchronized (lock) {\n+            // If no download root defined use default root\n+            if (nodeDownloadRoot == null) {\n+                nodeDownloadRoot = URI.create(DEFAULT_NODEJS_DOWNLOAD_ROOT);\n+            }\n+\n+            if (nodeIsAlreadyInstalled()) {\n+                return;\n+            }\n+\n+            getLogger().info(\"Installing node version {}\", nodeVersion);\n+            if (!nodeVersion.startsWith(\"v\")) {\n+                getLogger()\n+                        .warn(\"Node version does not start with naming convention 'v'. \"\n+                                + \"If download fails please add 'v' to the version string.\");\n+            }\n+            InstallData data = new InstallData(nodeVersion, nodeDownloadRoot,\n+                    platform);\n+            installNode(data);\n+\n+        }\n+    }\n+\n+    private boolean nodeIsAlreadyInstalled() throws InstallationException {\n+        File nodeFile = getNodeExecutable();\n+        if (nodeFile.exists()) {\n+\n+            List<String> nodeVersionCommand = new ArrayList<>();\n+            nodeVersionCommand.add(nodeFile.toString());\n+            nodeVersionCommand.add(\"--version\");\n+            String version = getVersion(\"Node\", nodeVersionCommand)\n+                    .getFullVersion();\n+\n+            if (version.equals(nodeVersion)) {\n+                getLogger().info(\"Node {} is already installed.\", version);\n+                return true;\n+            } else {\n+                getLogger()\n+                        .info(\"Node {} was installed, but we need version {}\",\n+                                version, nodeVersion);\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void installNode(InstallData data) throws InstallationException {\n+        try {\n+\n+            downloadFileIfMissing(data.getDownloadUrl(), data.getArchive(),\n+                    userName, password);\n+\n+            extractFile(data.getArchive(), data.getTmpDirectory());\n+        } catch (DownloadException e) {\n+            throw new InstallationException(\"Could not download Node.js\", e);\n+        } catch (ArchiveExtractionException e) {\n+            throw new InstallationException(\n+                    \"Could not extract the Node archive\", e);\n+        }\n+\n+        try {\n+            if (platform.isWindows()) {\n+                installNodeWindows(data);\n+            } else {\n+                installNodeUnix(data);\n+            }\n+        } catch (IOException e) {\n+            throw new InstallationException(\"Could not install Node\", e);\n+        }\n+\n+        getLogger().info(\"Local node installation successful.\");\n+    }\n+\n+    private void installNodeUnix(InstallData data)\n+            throws InstallationException, IOException {\n+\n+        // Search for the node binary\n+        File nodeBinary = new File(data.getTmpDirectory(),\n+                data.getNodeFilename() + File.separator + \"bin\" + File.separator\n+                        + data.getNodeExecutable());\n+\n+        if (!nodeBinary.exists()) {\n+            throw new FileNotFoundException(\n+                    \"Could not find the downloaded Node.js binary in \"\n+                            + nodeBinary);\n+        }\n+\n+        File destinationDirectory = getNodeInstallDirectory();\n+\n+        File destination = new File(destinationDirectory,\n+                data.getNodeExecutable());\n+\n+        copyNodeBinaryToDestination(nodeBinary, destination);\n+\n+        if (!destination.setExecutable(true, false)) {\n+            throw new InstallationException(\n+                    \"Could not install Node: Was not allowed to make \"\n+                            + destination + \" executable.\");\n+        }\n+\n+        if (npmProvided()) {\n+            extractUnixNpm(data, destinationDirectory);\n+        }\n+\n+        deleteTempDirectory(data.getTmpDirectory());\n+    }\n+\n+    private void extractUnixNpm(InstallData data, File destinationDirectory)\n+            throws IOException {\n+        getLogger().info(\"Extracting NPM\");\n+        File tmpNodeModulesDir = new File(data.getTmpDirectory(),\n+                data.getNodeFilename() + File.separator + \"lib\" + File.separator\n+                        + FrontendUtils.NODE_MODULES);\n+        File nodeModulesDirectory = new File(destinationDirectory,\n+                FrontendUtils.NODE_MODULES);\n+        File npmDirectory = new File(nodeModulesDirectory, \"npm\");\n+        FileUtils.copyDirectory(tmpNodeModulesDir, nodeModulesDirectory);\n+        // create a copy of the npm scripts next to the node executable\n+        for (String script : Arrays.asList(\"npm\", \"npm.cmd\")) {\n+            File scriptFile = new File(npmDirectory,\n+                    \"bin\" + File.separator + script);\n+            if (scriptFile.exists()) {\n+                boolean success = scriptFile.setExecutable(true);\n+                if (!success) {\n+                    getLogger().debug(\"Failed to make '{}' executable.\",\n+                            scriptFile.toPath());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void installNodeWindows(InstallData data)\n+            throws InstallationException, IOException {\n+        // Search for the node binary\n+        File nodeBinary = new File(data.getTmpDirectory(),\n+                data.getNodeFilename() + File.separator + data\n+                        .getNodeExecutable());\n+        if (!nodeBinary.exists()) {\n+            throw new FileNotFoundException(\n+                    \"Could not find the downloaded Node.js binary in \"\n+                            + nodeBinary);\n+        }\n+\n+        File destinationDirectory = getNodeInstallDirectory();\n+\n+        File destination = new File(destinationDirectory,\n+                data.getNodeExecutable());\n+\n+        copyNodeBinaryToDestination(nodeBinary, destination);\n+\n+        if (npmProvided()) {\n+            getLogger().info(\"Extracting NPM\");\n+            File tmpNodeModulesDir = new File(data.getTmpDirectory(),\n+                    data.getNodeFilename() + File.separator + FrontendUtils.NODE_MODULES);\n+            File nodeModulesDirectory = new File(destinationDirectory,\n+                    FrontendUtils.NODE_MODULES);\n+            FileUtils.copyDirectory(tmpNodeModulesDir, nodeModulesDirectory);\n+        }\n+        deleteTempDirectory(data.getTmpDirectory());\n+    }\n+\n+    private void copyNodeBinaryToDestination(File nodeBinary, File destination)\n+            throws InstallationException {\n+        getLogger().info(\"Copying node binary from {} to {}\", nodeBinary,\n+                destination);\n+        if (destination.exists() && !destination.delete()) {\n+            throw new InstallationException(\n+                    \"Could not install Node: Was not allowed to delete \"\n+                            + destination);\n+        }\n+        try {\n+            Files.move(nodeBinary.toPath(), destination.toPath(),\n+                    StandardCopyOption.REPLACE_EXISTING);\n+        } catch (IOException e) {\n+            getLogger().debug(\"Renaming failed.\", e);\n+            throw new InstallationException(\n+                    \"Could not install Node: Was not allowed to rename \"\n+                            + nodeBinary + \" to \" + destination);\n+        }\n+    }\n+\n+    public String getInstallDirectory() {\n+        return new File(installDirectory, INSTALL_PATH).getPath();\n+    }\n+\n+    private File getNodeInstallDirectory() {\n+        File nodeInstallDirectory = new File(installDirectory, INSTALL_PATH);\n+        if (!nodeInstallDirectory.exists()) {\n+            getLogger().debug(\"Creating install directory {}\",\n+                    nodeInstallDirectory);\n+            boolean success = nodeInstallDirectory.mkdirs();\n+            if (!success) {\n+                getLogger().debug(\"Failed to create install directory\");\n+            }\n+        }\n+        return nodeInstallDirectory;\n+    }\n+\n+    private void deleteTempDirectory(File tmpDirectory) throws IOException {\n+        if (tmpDirectory != null && tmpDirectory.exists()) {\n+            getLogger().debug(\"Deleting temporary directory {}\", tmpDirectory);\n+            FileUtils.deleteDirectory(tmpDirectory);\n+        }\n+    }\n+\n+    private void extractFile(File archive, File destinationDirectory)\n+            throws ArchiveExtractionException {\n+        try {\n+            getLogger().info(\"Unpacking {} into {}\", archive,\n+                    destinationDirectory);\n+            archiveExtractor.extract(archive, destinationDirectory);\n+        } catch (ArchiveExtractionException e) {\n+            if (e.getCause() instanceof EOFException) {\n+                // https://github.com/eirslett/frontend-maven-plugin/issues/794\n+                // The downloading was probably interrupted and archive file is incomplete:\n+                // delete it to retry from scratch\n+                getLogger()\n+                        .error(\"The archive file {} is corrupted and will be deleted. \"\n+                                        + \"Please run the application again.\",\n+                                archive.getPath());\n+                boolean deleted = archive.delete();\n+                if (!deleted) {\n+                    getLogger().error(\"Failed to remove archive file {}. \"\n+                                    + \"Please remove it manually and run the application.\",\n+                            archive.getPath());\n+                }\n+                try {\n+                    FileUtils.deleteDirectory(destinationDirectory);\n+                } catch (IOException ioe) {\n+                    getLogger().error(\"Failed to remove target directory '{}'\",\n+                            destinationDirectory, ioe);\n+                }\n+            }\n+\n+            throw e;\n+        }\n+    }\n+\n+    private void downloadFileIfMissing(URI downloadUrl, File destination,\n+            String userName, String password) throws DownloadException {\n+        if (!destination.exists()) {\n+            getLogger().info(\"Downloading {} to {}\", downloadUrl, destination);\n+            fileDownloader\n+                    .download(downloadUrl, destination, userName, password);\n+        }\n+    }\n+\n+    /**\n+     * Get node executable file.\n+     *\n+     * @return node executable\n+     */\n+    private File getNodeExecutable() {\n+        String nodeExecutable = platform.isWindows() ?\n+                NODE_WINDOWS :\n+                NODE_DEFAULT;\n+        return new File(installDirectory + nodeExecutable);\n+    }\n+\n+\n+    private static FrontendVersion getVersion(String tool,\n+            List<String> versionCommand) throws InstallationException {\n+        try {\n+            Process process = FrontendUtils.createProcessBuilder(versionCommand)\n+                    .start();\n+            int exitCode = process.waitFor();\n+            if (exitCode != 0) {\n+                throw new IOException(\n+                        \"Process exited with non 0 exit code. (\" + exitCode\n+                                + \")\");\n+            }\n+            return FrontendUtils.parseFrontendVersion(\n+                    FrontendUtils.streamToString(process.getInputStream()));\n+        } catch (InterruptedException | IOException e) {\n+            throw new InstallationException(\n+                    String.format(\"Unable to detect version of %s. %s\", tool,\n+                            \"Using command \" + String\n+                                    .join(\" \", versionCommand)), e);\n+        }\n+    }\n+\n+    private static Logger getLogger() {\n+        return LoggerFactory.getLogger(\"NodeInstaller\");\n+    }\n+\n+    private class InstallData {\n+        String nodeFilename;\n+        URI downloadUrl;\n+        File tmpDirectory;\n+        File archive;\n+        String nodeExecutable;\n+\n+        InstallData(String nodeVersion, URI nodeDownloadRoot,\n+                Platform platform) {\n+            nodeFilename = getLongNodeFilename(nodeVersion);\n+            downloadUrl = nodeDownloadRoot\n+                    .resolve(getNodeDownloadFilename(nodeVersion));\n+            tmpDirectory = getTempDirectory();\n+            archive = resolveArchive(\"node\", nodeVersion,\n+                    platform.getNodeClassifier(),\n+                    platform.getArchiveExtension());\n+            nodeExecutable = platform.isWindows() ? \"node.exe\" : \"node\";\n+        }\n+\n+        public String getNodeFilename() {\n+            return nodeFilename;\n+        }\n+\n+        public URI getDownloadUrl() {\n+            return downloadUrl;\n+        }\n+\n+        public File getTmpDirectory() {\n+            return tmpDirectory;\n+        }\n+\n+        public File getArchive() {\n+            return archive;\n+        }\n+\n+        public String getNodeExecutable() {\n+            return nodeExecutable;\n+        }\n+\n+        private File getTempDirectory() {\n+            File temporaryDirectory = new File(getNodeInstallDirectory(), \"tmp\");\n+            if (!temporaryDirectory.exists()) {\n+                getLogger()\n+                        .debug(\"Creating temporary directory {}\", temporaryDirectory);\n+                boolean success = temporaryDirectory.mkdirs();\n+                if (!success) {\n+                    getLogger().debug(\"Failed to create temporary directory\");\n+                }\n+            }\n+            return temporaryDirectory;\n+        }\n+\n+        private String getNodeDownloadFilename(String nodeVersion) {\n+            return nodeVersion + \"/\" + getLongNodeFilename(nodeVersion) + \".\"\n+                    + platform.getOs().getArchiveExtension();\n+        }\n+\n+        private String getLongNodeFilename(String nodeVersion) {\n+            return \"node-\" + nodeVersion + \"-\" + platform.getNodeClassifier();\n+        }\n+\n+        /**\n+         * Build archive file name and return archive file target location.\n+         *\n+         * @param name\n+         *         archive name\n+         * @param nodeVersion\n+         *         node version\n+         * @param classifier\n+         *         optional classifier\n+         * @param archiveExtension\n+         *         archive extension\n+         * @return archive {@link File} for archive\n+         */\n+        private File resolveArchive(String name, String nodeVersion,\n+                String classifier, String archiveExtension) {\n+            if (!installDirectory.exists()) {\n+                installDirectory.mkdirs();", "originalCommit": "e763f6b7b3b3fa4a463295fdfa699af167946fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}