{"pr_number": 8550, "pr_title": "Protect add- methods in ListDataView from adding the duplicated items #8538", "pr_createdAt": "2020-06-11T14:45:22Z", "pr_url": "https://github.com/vaadin/flow/pull/8550", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg5OTM1MA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r438899350", "bodyText": "What do you think about public contains(T item) calls a private boolean contains(ListDataProvider<T> dataProvider, T item) instead of creating the dataProvider itself? This could increase the performance especially if you call containsinside a loop like in addItems, addItemsAfter or addItemsBefore.", "author": "knoobie", "createdAt": "2020-06-11T16:01:02Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -153,8 +154,10 @@ public boolean contains(T item) {\n     @Override\n     public AbstractListDataView<T> addItem(T item) {\n         final ListDataProvider<T> dataProvider = getDataProvider();\n-        dataProvider.getItems().add(item);\n-        dataProvider.refreshAll();\n+        if (!contains(item)) {", "originalCommit": "782383f656982449eeffa97b56c00b982af30326", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0MjY1Mg==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r438942652", "bodyText": "Good catch, @knoobie, thanks! Javadoc updated as well.", "author": "mshabarov", "createdAt": "2020-06-11T17:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg5OTM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0ODgxOQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439348819", "bodyText": "Shouldn't the item be moved to the new position and not left as is?", "author": "caalador", "createdAt": "2020-06-12T10:52:57Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -196,96 +196,146 @@ public boolean contains(T item) {\n     @Override\n     public AbstractListDataView<T> addItems(Collection<T> items) {\n         final ListDataProvider<T> dataProvider = getDataProvider();\n-        dataProvider.getItems().addAll(items);\n-        dataProvider.refreshAll();\n+        Collection<T> backendItems = dataProvider.getItems();\n+        if (items != null && !items.isEmpty()) {\n+            items.stream()\n+                    .filter(item ->\n+                            !contains(item, dataProvider))\n+                    .forEach(backendItems::add);\n+            dataProvider.refreshAll();\n+        }\n         return this;\n     }\n \n     @Override\n     public AbstractListDataView<T> addItemAfter(T item, T after) {\n-        final Collection<T> items = getDataProvider().getItems();\n-        if (!items.contains(after)) {\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        final int afterItemIndex = getItemIndex(after);\n+        if (afterItemIndex == -1) {\n             throw new IllegalArgumentException(\n                     \"Item to insert after is not available in the data\");\n         }\n-        if (items instanceof List) {\n-            final List<T> itemList = (List<T>) items;\n-            itemList.add(itemList.indexOf(after) + 1, item);\n-            getDataProvider().refreshAll();\n+\n+        // Do nothing if the backend collection already contains such an item\n+        if (contains(item, dataProvider)) {\n+            return this;\n+        }\n+\n+        if (backendItems instanceof List) {\n+            final List<T> itemList = (List<T>) backendItems;\n+            itemList.add(afterItemIndex + 1, item);\n+            dataProvider.refreshAll();\n             return this;\n         }\n         throw new IllegalArgumentException(\n                 String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n-                        items.getClass().getSimpleName()));\n+                        backendItems.getClass().getSimpleName()));\n     }\n \n     @Override\n     public AbstractListDataView<T> addItemsAfter(Collection<T> items, T after) {\n-        final Collection<T> backendItems = getDataProvider().getItems();\n-        if (!backendItems.contains(after)) {\n+        if (items == null || items.isEmpty()) {\n+            return this;\n+        }\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        final int afterItemIndex = getItemIndex(after);\n+        if (afterItemIndex == -1) {\n             throw new IllegalArgumentException(\n                     \"Item to insert after is not available in the data\");\n         }\n         if (backendItems instanceof List) {\n             final List<T> itemList = (List<T>) backendItems;\n-            itemList.addAll(itemList.indexOf(after) + 1, items);\n-            getDataProvider().refreshAll();\n+            final List<T> itemsToAdd = items.stream()\n+                    .filter(item ->\n+                            !contains(item, dataProvider))\n+                    .collect(Collectors.toList());\n+            itemList.addAll(afterItemIndex + 1, itemsToAdd);\n+            dataProvider.refreshAll();\n             return this;\n         }\n         throw new IllegalArgumentException(\n                 String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n-                        items.getClass().getSimpleName()));\n+                        backendItems.getClass().getSimpleName()));\n     }\n \n     @Override\n     public AbstractListDataView<T> addItemBefore(T item, T before) {\n-        final Collection<T> items = getDataProvider().getItems();\n-        if (!items.contains(before)) {\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        final int beforeItemIndex = getItemIndex(before);\n+        if (beforeItemIndex == -1) {\n             throw new IllegalArgumentException(\n                     \"Item to insert before is not available in the data\");\n         }\n-        if (items instanceof List) {\n-            final List<T> itemList = (List<T>) items;\n-            itemList.add(itemList.indexOf(before), item);\n-            getDataProvider().refreshAll();\n+\n+        // Do nothing if the backend collection already contains such an item", "originalCommit": "ad3a15513c08337e7b1aa23b0f63b898600b224c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2MDUzMQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439360531", "bodyText": "Yes, I thought about it at the very beginning, but decided to simplify it. That's probably something a developers would expect from this method, rather than silently do nothing. Will do.", "author": "mshabarov", "createdAt": "2020-06-12T11:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0ODgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwODY0NA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439508644", "bodyText": "I'm wondering if that is another use case? Personally, I would except an exception or return false if the item is already present and I'm trying to add the same item again at another position.\nOn the other hand -  I think a really common use case for addItemAfter or addItemBefore would be a Grid combined with DragAndDrop. Having this in mind, an additional method move(T item, T target, Location location (Location is a simple enum (BEFORE, AFTER) - would make developer so happy.\nFor example I could remove my whole boilerplate code on top of the dropEvent and even removing the need to save list of items in an external variable.", "author": "knoobie", "createdAt": "2020-06-12T16:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0ODgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5NDk4OQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439994989", "bodyText": "move method looks for me more like a private than a public API. I believe for DnD a developers want to achieve the dragged item/items collection to be placed on the target, i.e. the final outcome, rather than to think about how to move the items around the data set.", "author": "mshabarov", "createdAt": "2020-06-15T07:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0ODgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxMTI0Mg==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440011242", "bodyText": "You could be right - especially with a direct call to getItems the developer has access to the underlying list without storing a reference himself. So they should be no need to call move from outside, because vaadin already does it and I can get the result afterwards with getItems", "author": "knoobie", "createdAt": "2020-06-15T08:28:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0ODgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0ODk0MA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439348940", "bodyText": "Shouldn't the item be moved to the new position and not left as is?", "author": "caalador", "createdAt": "2020-06-12T10:53:13Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -196,96 +196,146 @@ public boolean contains(T item) {\n     @Override\n     public AbstractListDataView<T> addItems(Collection<T> items) {\n         final ListDataProvider<T> dataProvider = getDataProvider();\n-        dataProvider.getItems().addAll(items);\n-        dataProvider.refreshAll();\n+        Collection<T> backendItems = dataProvider.getItems();\n+        if (items != null && !items.isEmpty()) {\n+            items.stream()\n+                    .filter(item ->\n+                            !contains(item, dataProvider))\n+                    .forEach(backendItems::add);\n+            dataProvider.refreshAll();\n+        }\n         return this;\n     }\n \n     @Override\n     public AbstractListDataView<T> addItemAfter(T item, T after) {\n-        final Collection<T> items = getDataProvider().getItems();\n-        if (!items.contains(after)) {\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        final int afterItemIndex = getItemIndex(after);\n+        if (afterItemIndex == -1) {\n             throw new IllegalArgumentException(\n                     \"Item to insert after is not available in the data\");\n         }\n-        if (items instanceof List) {\n-            final List<T> itemList = (List<T>) items;\n-            itemList.add(itemList.indexOf(after) + 1, item);\n-            getDataProvider().refreshAll();\n+\n+        // Do nothing if the backend collection already contains such an item", "originalCommit": "ad3a15513c08337e7b1aa23b0f63b898600b224c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzMDAwNQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439930005", "bodyText": "Yes, done.", "author": "mshabarov", "createdAt": "2020-06-15T04:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0ODk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0OTIzOQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439349239", "bodyText": "Shouldn't the collection be added as given and the existing items be \"moved\" to the new positions?", "author": "caalador", "createdAt": "2020-06-12T10:53:53Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -196,96 +196,146 @@ public boolean contains(T item) {\n     @Override\n     public AbstractListDataView<T> addItems(Collection<T> items) {\n         final ListDataProvider<T> dataProvider = getDataProvider();\n-        dataProvider.getItems().addAll(items);\n-        dataProvider.refreshAll();\n+        Collection<T> backendItems = dataProvider.getItems();\n+        if (items != null && !items.isEmpty()) {\n+            items.stream()\n+                    .filter(item ->\n+                            !contains(item, dataProvider))\n+                    .forEach(backendItems::add);\n+            dataProvider.refreshAll();\n+        }\n         return this;\n     }\n \n     @Override\n     public AbstractListDataView<T> addItemAfter(T item, T after) {\n-        final Collection<T> items = getDataProvider().getItems();\n-        if (!items.contains(after)) {\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        final int afterItemIndex = getItemIndex(after);\n+        if (afterItemIndex == -1) {\n             throw new IllegalArgumentException(\n                     \"Item to insert after is not available in the data\");\n         }\n-        if (items instanceof List) {\n-            final List<T> itemList = (List<T>) items;\n-            itemList.add(itemList.indexOf(after) + 1, item);\n-            getDataProvider().refreshAll();\n+\n+        // Do nothing if the backend collection already contains such an item\n+        if (contains(item, dataProvider)) {\n+            return this;\n+        }\n+\n+        if (backendItems instanceof List) {\n+            final List<T> itemList = (List<T>) backendItems;\n+            itemList.add(afterItemIndex + 1, item);\n+            dataProvider.refreshAll();\n             return this;\n         }\n         throw new IllegalArgumentException(\n                 String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n-                        items.getClass().getSimpleName()));\n+                        backendItems.getClass().getSimpleName()));\n     }\n \n     @Override\n     public AbstractListDataView<T> addItemsAfter(Collection<T> items, T after) {\n-        final Collection<T> backendItems = getDataProvider().getItems();\n-        if (!backendItems.contains(after)) {\n+        if (items == null || items.isEmpty()) {\n+            return this;\n+        }\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        final int afterItemIndex = getItemIndex(after);\n+        if (afterItemIndex == -1) {\n             throw new IllegalArgumentException(\n                     \"Item to insert after is not available in the data\");\n         }\n         if (backendItems instanceof List) {\n             final List<T> itemList = (List<T>) backendItems;\n-            itemList.addAll(itemList.indexOf(after) + 1, items);\n-            getDataProvider().refreshAll();\n+            final List<T> itemsToAdd = items.stream()", "originalCommit": "ad3a15513c08337e7b1aa23b0f63b898600b224c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxNTg2Mg==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440015862", "bodyText": "Yes, done", "author": "mshabarov", "createdAt": "2020-06-15T08:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0OTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0OTMxMw==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439349313", "bodyText": "Shouldn't the collection be added as given and the existing items be \"moved\" to the new positions?", "author": "caalador", "createdAt": "2020-06-12T10:54:02Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -196,96 +196,146 @@ public boolean contains(T item) {\n     @Override\n     public AbstractListDataView<T> addItems(Collection<T> items) {\n         final ListDataProvider<T> dataProvider = getDataProvider();\n-        dataProvider.getItems().addAll(items);\n-        dataProvider.refreshAll();\n+        Collection<T> backendItems = dataProvider.getItems();\n+        if (items != null && !items.isEmpty()) {\n+            items.stream()\n+                    .filter(item ->\n+                            !contains(item, dataProvider))\n+                    .forEach(backendItems::add);\n+            dataProvider.refreshAll();\n+        }\n         return this;\n     }\n \n     @Override\n     public AbstractListDataView<T> addItemAfter(T item, T after) {\n-        final Collection<T> items = getDataProvider().getItems();\n-        if (!items.contains(after)) {\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        final int afterItemIndex = getItemIndex(after);\n+        if (afterItemIndex == -1) {\n             throw new IllegalArgumentException(\n                     \"Item to insert after is not available in the data\");\n         }\n-        if (items instanceof List) {\n-            final List<T> itemList = (List<T>) items;\n-            itemList.add(itemList.indexOf(after) + 1, item);\n-            getDataProvider().refreshAll();\n+\n+        // Do nothing if the backend collection already contains such an item\n+        if (contains(item, dataProvider)) {\n+            return this;\n+        }\n+\n+        if (backendItems instanceof List) {\n+            final List<T> itemList = (List<T>) backendItems;\n+            itemList.add(afterItemIndex + 1, item);\n+            dataProvider.refreshAll();\n             return this;\n         }\n         throw new IllegalArgumentException(\n                 String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n-                        items.getClass().getSimpleName()));\n+                        backendItems.getClass().getSimpleName()));\n     }\n \n     @Override\n     public AbstractListDataView<T> addItemsAfter(Collection<T> items, T after) {\n-        final Collection<T> backendItems = getDataProvider().getItems();\n-        if (!backendItems.contains(after)) {\n+        if (items == null || items.isEmpty()) {\n+            return this;\n+        }\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        final int afterItemIndex = getItemIndex(after);\n+        if (afterItemIndex == -1) {\n             throw new IllegalArgumentException(\n                     \"Item to insert after is not available in the data\");\n         }\n         if (backendItems instanceof List) {\n             final List<T> itemList = (List<T>) backendItems;\n-            itemList.addAll(itemList.indexOf(after) + 1, items);\n-            getDataProvider().refreshAll();\n+            final List<T> itemsToAdd = items.stream()\n+                    .filter(item ->\n+                            !contains(item, dataProvider))\n+                    .collect(Collectors.toList());\n+            itemList.addAll(afterItemIndex + 1, itemsToAdd);\n+            dataProvider.refreshAll();\n             return this;\n         }\n         throw new IllegalArgumentException(\n                 String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n-                        items.getClass().getSimpleName()));\n+                        backendItems.getClass().getSimpleName()));\n     }\n \n     @Override\n     public AbstractListDataView<T> addItemBefore(T item, T before) {\n-        final Collection<T> items = getDataProvider().getItems();\n-        if (!items.contains(before)) {\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        final int beforeItemIndex = getItemIndex(before);\n+        if (beforeItemIndex == -1) {\n             throw new IllegalArgumentException(\n                     \"Item to insert before is not available in the data\");\n         }\n-        if (items instanceof List) {\n-            final List<T> itemList = (List<T>) items;\n-            itemList.add(itemList.indexOf(before), item);\n-            getDataProvider().refreshAll();\n+\n+        // Do nothing if the backend collection already contains such an item\n+        if (contains(item, dataProvider)) {\n+            return this;\n+        }\n+\n+        if (backendItems instanceof List) {\n+            final List<T> itemList = (List<T>) backendItems;\n+            itemList.add(beforeItemIndex, item);\n+            dataProvider.refreshAll();\n             return this;\n         }\n         throw new IllegalArgumentException(\n                 String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n-                        items.getClass().getSimpleName()));\n+                        backendItems.getClass().getSimpleName()));\n     }\n \n     @Override\n     public AbstractListDataView<T> addItemsBefore(Collection<T> items,\n             T before) {\n-        final Collection<T> backendItems = getDataProvider().getItems();\n-        if (!backendItems.contains(before)) {\n+        if (items == null || items.isEmpty()) {\n+            return this;\n+        }\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        final int beforeItemIndex = getItemIndex(before);\n+        if (beforeItemIndex == -1) {\n             throw new IllegalArgumentException(\n                     \"Item to insert before is not available in the data\");\n         }\n         if (backendItems instanceof List) {\n             final List<T> itemList = (List<T>) backendItems;\n-            itemList.addAll(itemList.indexOf(before), items);\n-            getDataProvider().refreshAll();\n+            final List<T> itemsToAdd = items.stream()", "originalCommit": "ad3a15513c08337e7b1aa23b0f63b898600b224c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzMDA0NA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439930044", "bodyText": "Yes, done.", "author": "mshabarov", "createdAt": "2020-06-15T04:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0OTMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0OTk0NQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439349945", "bodyText": "Item should be moved to the new position if it already exists. Same for a ll the other before and after methods.", "author": "caalador", "createdAt": "2020-06-12T10:55:20Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -79,7 +79,8 @@\n     V addItem(T item);\n \n     /**\n-     * Adds an item after the given target item.\n+     * Adds an item after the given target item if it is not already", "originalCommit": "ad3a15513c08337e7b1aa23b0f63b898600b224c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzMDIwOQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439930209", "bodyText": "Yes, done.", "author": "mshabarov", "createdAt": "2020-06-15T04:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0OTk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM1MDk0Mg==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r439350942", "bodyText": "This should also probably relocate any old items to the order given in the collection. e.g. collect existing, removeAll(existing), addAll(items)", "author": "caalador", "createdAt": "2020-06-12T10:57:22Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -196,96 +196,146 @@ public boolean contains(T item) {\n     @Override\n     public AbstractListDataView<T> addItems(Collection<T> items) {\n         final ListDataProvider<T> dataProvider = getDataProvider();\n-        dataProvider.getItems().addAll(items);\n-        dataProvider.refreshAll();\n+        Collection<T> backendItems = dataProvider.getItems();\n+        if (items != null && !items.isEmpty()) {\n+            items.stream()", "originalCommit": "ad3a15513c08337e7b1aa23b0f63b898600b224c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6139f974b318b886cd24c062eff20323e69311b1", "url": "https://github.com/vaadin/flow/commit/6139f974b318b886cd24c062eff20323e69311b1", "message": "Protect add- methods in ListDataView from adding the duplicated items #8538", "committedDate": "2020-06-15T08:41:20Z", "type": "commit"}, {"oid": "0d048c8b4ff58e0b3a5c0cb892c9f6ca3f6b87e3", "url": "https://github.com/vaadin/flow/commit/0d048c8b4ff58e0b3a5c0cb892c9f6ca3f6b87e3", "message": "Invoke data provider getter once, update the javadoc", "committedDate": "2020-06-15T08:41:20Z", "type": "commit"}, {"oid": "25695a2c9a1e104663e305751e3ca8a7062254ce", "url": "https://github.com/vaadin/flow/commit/25695a2c9a1e104663e305751e3ca8a7062254ce", "message": "Rearrange backend collection items in add- methods.", "committedDate": "2020-06-15T08:41:20Z", "type": "commit"}, {"oid": "bdb0360695cc8636752914b92ebfd6f5b1d1380e", "url": "https://github.com/vaadin/flow/commit/bdb0360695cc8636752914b92ebfd6f5b1d1380e", "message": "Update javadoc to emphasize the reordering on items", "committedDate": "2020-06-15T08:41:20Z", "type": "commit"}, {"oid": "bdb0360695cc8636752914b92ebfd6f5b1d1380e", "url": "https://github.com/vaadin/flow/commit/bdb0360695cc8636752914b92ebfd6f5b1d1380e", "message": "Update javadoc to emphasize the reordering on items", "committedDate": "2020-06-15T08:41:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0MDE0MA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440040140", "bodyText": "Why is the getItemIndex(T) method still kept even adding this one ???\nWhy not just force all places to call this new one or the existing one and merge the implementation to the same method ?", "author": "pleku", "createdAt": "2020-06-15T09:17:09Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -332,9 +302,13 @@ private int getItemIndex(\n         return index.get();\n     }\n \n+    private int getItemIndex(T item, ListDataProvider<T> dataProvider) {\n+        return getItemIndex(item, dataProvider::getId);\n+    }\n+", "originalCommit": "bdb0360695cc8636752914b92ebfd6f5b1d1380e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4OTIwNg==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440089206", "bodyText": "Agree, no need to keep those two extra overloaded versions of getItemIndex. Done", "author": "mshabarov", "createdAt": "2020-06-15T10:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0MDE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0MDk3Nw==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440040977", "bodyText": "Also this method seems just totally unnecessary by itself, or otherwise there is something happening here that is not visible in the code.\nShould be merge to the above method.", "author": "pleku", "createdAt": "2020-06-15T09:18:30Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -350,4 +324,113 @@ private Object getIdentifier(T item,\n     private Object getIdentifier(T item, ListDataProvider<T> dataProvider) {\n         return getIdentifier(item, dataProvider::getId);", "originalCommit": "bdb0360695cc8636752914b92ebfd6f5b1d1380e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4OTI1OA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440089258", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-06-15T10:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0MDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0MTYzNw==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440041637", "bodyText": "Again I get the feeling that this method is just adding more methods which add no value but just have one line.\nI think the code should be refactored to include the logic properly in the correct method instead of split around many methods small methods which makes is harder to follow the code flow", "author": "pleku", "createdAt": "2020-06-15T09:19:42Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -350,4 +324,113 @@ private Object getIdentifier(T item,\n     private Object getIdentifier(T item, ListDataProvider<T> dataProvider) {\n         return getIdentifier(item, dataProvider::getId);\n     }\n+\n+    private boolean contains(T item, ListDataProvider<T> dataProvider) {\n+        return contains(item, dataProvider, getItems());", "originalCommit": "bdb0360695cc8636752914b92ebfd6f5b1d1380e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA5MDcxMw==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440090713", "bodyText": "Yes, the second contains method had been used at some point in the intermediate code, but now it is a leftover, and doesn't make sense.\nDone.", "author": "mshabarov", "createdAt": "2020-06-15T10:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0MTYzNw=="}], "type": "inlineReview"}, {"oid": "00f8688b640c44428a8fddb97a48288b0c8c6998", "url": "https://github.com/vaadin/flow/commit/00f8688b640c44428a8fddb97a48288b0c8c6998", "message": "Delete extra overloaded methods", "committedDate": "2020-06-15T10:45:11Z", "type": "commit"}, {"oid": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "url": "https://github.com/vaadin/flow/commit/55e30875759a03eea00850e3f24b9cbfe0f4b592", "message": "Delete unused import", "committedDate": "2020-06-15T12:40:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE1NzkzMQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440157931", "bodyText": "The way the data provider is still passed to all methods makes me wonder that \"will these methods ever be called with another data provider than the one that would anyway be provided with getDataProvider()\" ...\nBut if you feel that it really makes a difference to not have to call it again in the methods since the calling method needs it, then I guess it can stay like this.", "author": "pleku", "createdAt": "2020-06-15T13:00:42Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -347,7 +311,107 @@ private Object getIdentifier(T item,\n         return itemIdentifier;\n     }\n \n-    private Object getIdentifier(T item, ListDataProvider<T> dataProvider) {\n-        return getIdentifier(item, dataProvider::getId);\n+    private boolean contains(T item, ListDataProvider<T> dataProvider) {", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2MTQwNA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440161404", "bodyText": "Why is this method returning anything, or in this case the data view ???", "author": "pleku", "createdAt": "2020-06-15T13:06:35Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -347,7 +311,107 @@ private Object getIdentifier(T item,\n         return itemIdentifier;\n     }\n \n-    private Object getIdentifier(T item, ListDataProvider<T> dataProvider) {\n-        return getIdentifier(item, dataProvider::getId);\n+    private boolean contains(T item, ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return getItems().anyMatch(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item,\n+                                     ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        dataProvider.getItems().removeIf(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item, ListDataProvider<T> dataProvider,\n+                                     List<T> from) {\n+        final int itemIndex = getItemIndex(item, dataProvider::getId);\n+        if (itemIndex != -1) {\n+            from.remove(itemIndex);\n+        }\n+    }\n+\n+    private boolean equals(T item, T compareTo,\n+                           ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return itemIdentifier.equals(\n+                getIdentifier(compareTo, dataProvider::getId));\n+    }\n+\n+    private AbstractListDataView<T> doAddItemOnTarget(", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyMTYzNQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440321635", "bodyText": "Changed to void", "author": "mshabarov", "createdAt": "2020-06-15T17:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2MTQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2MjAwNw==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440162007", "bodyText": "String noTargetErrMessage\nI can't make out from this name what is the message used for", "author": "pleku", "createdAt": "2020-06-15T13:07:37Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -347,7 +311,107 @@ private Object getIdentifier(T item,\n         return itemIdentifier;\n     }\n \n-    private Object getIdentifier(T item, ListDataProvider<T> dataProvider) {\n-        return getIdentifier(item, dataProvider::getId);\n+    private boolean contains(T item, ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return getItems().anyMatch(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item,\n+                                     ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        dataProvider.getItems().removeIf(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item, ListDataProvider<T> dataProvider,\n+                                     List<T> from) {\n+        final int itemIndex = getItemIndex(item, dataProvider::getId);\n+        if (itemIndex != -1) {\n+            from.remove(itemIndex);\n+        }\n+    }\n+\n+    private boolean equals(T item, T compareTo,\n+                           ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return itemIdentifier.equals(\n+                getIdentifier(compareTo, dataProvider::getId));\n+    }\n+\n+    private AbstractListDataView<T> doAddItemOnTarget(\n+            T item, T target, String noTargetErrMessage,", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyMTg0OQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440321849", "bodyText": "Changed to targetItemNotFoundErrorMessage", "author": "mshabarov", "createdAt": "2020-06-15T17:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2MjAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2OTM0OQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440169349", "bodyText": "Shouldn't null be checked separately and thrown directly since it is likely an error by the developer and we should \"help\" them realize it instead of silently not doing anything ?", "author": "pleku", "createdAt": "2020-06-15T13:19:37Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -347,7 +311,107 @@ private Object getIdentifier(T item,\n         return itemIdentifier;\n     }\n \n-    private Object getIdentifier(T item, ListDataProvider<T> dataProvider) {\n-        return getIdentifier(item, dataProvider::getId);\n+    private boolean contains(T item, ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return getItems().anyMatch(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item,\n+                                     ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        dataProvider.getItems().removeIf(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item, ListDataProvider<T> dataProvider,\n+                                     List<T> from) {\n+        final int itemIndex = getItemIndex(item, dataProvider::getId);\n+        if (itemIndex != -1) {\n+            from.remove(itemIndex);\n+        }\n+    }\n+\n+    private boolean equals(T item, T compareTo,\n+                           ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return itemIdentifier.equals(\n+                getIdentifier(compareTo, dataProvider::getId));\n+    }\n+\n+    private AbstractListDataView<T> doAddItemOnTarget(\n+            T item, T target, String noTargetErrMessage,\n+            SerializableFunction<Integer, Integer> insertItemsIndexProvider) {\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+\n+        if (equals(item, target, dataProvider)) {\n+            return this;\n+        }\n+\n+        final int targetItemIndex = getItemIndex(target, dataProvider::getId);\n+        if (targetItemIndex == -1) {\n+            throw new IllegalArgumentException(noTargetErrMessage);\n+        }\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        if (backendItems instanceof List) {\n+            final List<T> itemList = (List<T>) backendItems;\n+            removeItemIfPresent(item, dataProvider, itemList);\n+            itemList.add(insertItemsIndexProvider.apply(targetItemIndex), item);\n+            dataProvider.refreshAll();\n+            return this;\n+        }\n+        throw new IllegalArgumentException(\n+                String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n+                        backendItems.getClass().getSimpleName()));\n+    }\n+\n+    private AbstractListDataView<T> doAddItemsOnTarget(\n+            Collection<T> items, T target, String noTargetErrMessage,\n+        SerializableBiFunction<Integer, Boolean, Integer> insertItemsIndexProvider) {\n+\n+        if (items == null || items.isEmpty()) {", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyMjAxMg==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440322012", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-06-15T17:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2OTM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NDYzMA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440174630", "bodyText": "It is not obvious from the method signatures or parameters that why is there a need for two doAddItemsOnTarget methods, please answer that as a clarifying comment", "author": "pleku", "createdAt": "2020-06-15T13:28:04Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -347,7 +311,107 @@ private Object getIdentifier(T item,\n         return itemIdentifier;\n     }\n \n-    private Object getIdentifier(T item, ListDataProvider<T> dataProvider) {\n-        return getIdentifier(item, dataProvider::getId);\n+    private boolean contains(T item, ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return getItems().anyMatch(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item,\n+                                     ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        dataProvider.getItems().removeIf(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item, ListDataProvider<T> dataProvider,\n+                                     List<T> from) {\n+        final int itemIndex = getItemIndex(item, dataProvider::getId);\n+        if (itemIndex != -1) {\n+            from.remove(itemIndex);\n+        }\n+    }\n+\n+    private boolean equals(T item, T compareTo,\n+                           ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return itemIdentifier.equals(\n+                getIdentifier(compareTo, dataProvider::getId));\n+    }\n+\n+    private AbstractListDataView<T> doAddItemOnTarget(\n+            T item, T target, String noTargetErrMessage,\n+            SerializableFunction<Integer, Integer> insertItemsIndexProvider) {\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+\n+        if (equals(item, target, dataProvider)) {\n+            return this;\n+        }\n+\n+        final int targetItemIndex = getItemIndex(target, dataProvider::getId);\n+        if (targetItemIndex == -1) {\n+            throw new IllegalArgumentException(noTargetErrMessage);\n+        }\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        if (backendItems instanceof List) {\n+            final List<T> itemList = (List<T>) backendItems;\n+            removeItemIfPresent(item, dataProvider, itemList);\n+            itemList.add(insertItemsIndexProvider.apply(targetItemIndex), item);\n+            dataProvider.refreshAll();\n+            return this;\n+        }\n+        throw new IllegalArgumentException(\n+                String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n+                        backendItems.getClass().getSimpleName()));\n+    }\n+\n+    private AbstractListDataView<T> doAddItemsOnTarget(", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNzcwNg==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440327706", "bodyText": "I renamed the method name doAddItemsOnTarget to doAddItemsCollectionOnTarget so as to highlight the distinction between them. Don't know what more I could say in the comments, one of them is for adding a single item, the other is for a adding a collection of items.", "author": "mshabarov", "createdAt": "2020-06-15T17:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NDYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NTMzMA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440175330", "bodyText": "Couple of questions/observations when looking at this method:\n\nWhy does it have to be a List or an exception is thrown ? Why is not Collection suitable ? If it is required to be so, shouldn't it be checked immediately in the method and exception thrown always  - referring to checking first that something else might be null or empty or not present...\nWhy not utilize existing Collection::removeAll or Collection::removeIfPresent in this case since those are already done for us ? So basically first remove existing and then just add those that are available in the provided collection.\n\nApparently it seems that the code is written for the special case of having the target item also present in the new list. But I've had to take a lot of time to read the implementation to figure that out, which is not good.\nWhen is this needed and why - what is the use case ? I just get the feeling that this is adding some overly complex code here and there is no reason for this - at least it is not documented in the code any way. If there is a good reason for these decisions, please also document that in the code (as comments).", "author": "pleku", "createdAt": "2020-06-15T13:29:10Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -347,7 +311,107 @@ private Object getIdentifier(T item,\n         return itemIdentifier;\n     }\n \n-    private Object getIdentifier(T item, ListDataProvider<T> dataProvider) {\n-        return getIdentifier(item, dataProvider::getId);\n+    private boolean contains(T item, ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return getItems().anyMatch(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item,\n+                                     ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        dataProvider.getItems().removeIf(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item, ListDataProvider<T> dataProvider,\n+                                     List<T> from) {\n+        final int itemIndex = getItemIndex(item, dataProvider::getId);\n+        if (itemIndex != -1) {\n+            from.remove(itemIndex);\n+        }\n+    }\n+\n+    private boolean equals(T item, T compareTo,\n+                           ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return itemIdentifier.equals(\n+                getIdentifier(compareTo, dataProvider::getId));\n+    }\n+\n+    private AbstractListDataView<T> doAddItemOnTarget(\n+            T item, T target, String noTargetErrMessage,\n+            SerializableFunction<Integer, Integer> insertItemsIndexProvider) {\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+\n+        if (equals(item, target, dataProvider)) {\n+            return this;\n+        }\n+\n+        final int targetItemIndex = getItemIndex(target, dataProvider::getId);\n+        if (targetItemIndex == -1) {\n+            throw new IllegalArgumentException(noTargetErrMessage);\n+        }\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        if (backendItems instanceof List) {\n+            final List<T> itemList = (List<T>) backendItems;\n+            removeItemIfPresent(item, dataProvider, itemList);\n+            itemList.add(insertItemsIndexProvider.apply(targetItemIndex), item);\n+            dataProvider.refreshAll();\n+            return this;\n+        }\n+        throw new IllegalArgumentException(\n+                String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n+                        backendItems.getClass().getSimpleName()));\n+    }\n+\n+    private AbstractListDataView<T> doAddItemsOnTarget(\n+            Collection<T> items, T target, String noTargetErrMessage,\n+        SerializableBiFunction<Integer, Boolean, Integer> insertItemsIndexProvider) {\n+\n+        if (items == null || items.isEmpty()) {\n+            return this;\n+        }\n+\n+        final ListDataProvider<T> dataProvider = getDataProvider();\n+\n+        if (!contains(target, dataProvider)) {\n+            throw new IllegalArgumentException(noTargetErrMessage);\n+        }\n+\n+        final Collection<T> backendItems = dataProvider.getItems();\n+        if (backendItems instanceof List) {", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2ODc4OA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440368788", "bodyText": "List is needed because it provides the ordering of items and allows to insert the element on a certain position. Collection does not provide such a capabilities. This check is done as soon as all the objects are ready for it. However, contains method runs before List check. IMO it can be kept as it is because 'contains' error is more frequent than 'list type' error.\nI can't use Collection::removeAll because I want to keep the target item untouched to take its index later on in order to place the item before/after it.\n\nYes, I believe the case when the collection contains the target item is probable. If we assume this method would be used for DnD, then the user would be able to multi-select a bunch of items from one component and move them to another. Then, he could drag the item (among other items in the bunch) which is equivalent of target item and if we do not consider such a case, then the target item would be deleted and we never know the position to drop the items to.\nI will add the comments to describe this case.", "author": "mshabarov", "createdAt": "2020-06-15T18:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NTMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NjA0MA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440176040", "bodyText": "Two methods with the same name and almost same parameters makes one wonder why - please add a comment to clarify so future maintainers don't have to read all the code or search git history for this", "author": "pleku", "createdAt": "2020-06-15T13:30:10Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -347,7 +311,107 @@ private Object getIdentifier(T item,\n         return itemIdentifier;\n     }\n \n-    private Object getIdentifier(T item, ListDataProvider<T> dataProvider) {\n-        return getIdentifier(item, dataProvider::getId);\n+    private boolean contains(T item, ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        return getItems().anyMatch(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item,\n+                                     ListDataProvider<T> dataProvider) {\n+        final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n+        dataProvider.getItems().removeIf(i -> itemIdentifier.equals(\n+                getIdentifier(i, dataProvider::getId)));\n+    }\n+\n+    private void removeItemIfPresent(T item, ListDataProvider<T> dataProvider,", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNjU4OA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440336588", "bodyText": "The second one with a List as a last parameter does not give any advantages vs the other, so I decided just to exclude it.", "author": "mshabarov", "createdAt": "2020-06-15T17:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NjA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3OTkzNw==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440179937", "bodyText": "* Moves an item to the proper position (next to {@code after} item) if it\n* is already in the data list, but not after the given item.\n\n\nIs this really so ? To me it means that the item is not moved at all if it is after the item even now ??? Shouldn't it be moved always? Thus the javadocs should be formulated as\n\"If the item is already present in the backend, then it is moved\"\nand then one doesn't have to stop to think about where it might be", "author": "pleku", "createdAt": "2020-06-15T13:36:05Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -81,6 +81,9 @@\n     /**\n      * Adds an item after the given target item.\n      * <p>\n+     * Moves an item to the proper position (next to {@code after} item) if it\n+     * is already in the data list, but not after the given item.", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNjkxNA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440336914", "bodyText": "Change the wording. Done", "author": "mshabarov", "createdAt": "2020-06-15T17:34:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3OTkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MTA4NA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440181084", "bodyText": "Again the same thing as above - this indicates that it is not moved if it is already before the item, like on index 0 and the target item is on index 5.", "author": "pleku", "createdAt": "2020-06-15T13:37:48Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -100,6 +103,9 @@\n     /**\n      * Adds an item before the given target item.\n      * <p>\n+     * Moves an item to the proper position (next to {@code before} item) if it\n+     * is already in the data list, but not before the given item.", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNjk4Mg==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440336982", "bodyText": "Change the wording. Done", "author": "mshabarov", "createdAt": "2020-06-15T17:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MTA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MzMwNA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440183304", "bodyText": "Again, I think this should be formulated clearer, like:\n\"Any items that already exist in the data provider are moved to the end.\"", "author": "pleku", "createdAt": "2020-06-15T13:41:10Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -161,6 +167,9 @@\n \n     /**\n      * Adds multiple items to the data list.\n+     * <p>\n+     * Moves the data list items to the end of the data list if they already\n+     * present, so as to keep the ordering of the {@code items} collection.", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNzAzMw==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440337033", "bodyText": "Change the wording. Done", "author": "mshabarov", "createdAt": "2020-06-15T17:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MzMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4NDQwOA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440184408", "bodyText": "the data list items\n\nI think you should just say \"items\" or \"given items\" or \"given collection\", data list items doesn't sound right", "author": "pleku", "createdAt": "2020-06-15T13:42:49Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -177,6 +186,10 @@\n      * Adds multiple items after the given target item.\n      * The full collection is added in order after the target.\n      * <p>\n+     * Moves the data list items to the proper position (next to {@code after}", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNzU0MA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440337540", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-06-15T17:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4NDQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4NTcwOA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440185708", "bodyText": "Maybe something like\n\"Any items that are already present in the data provider are moved.\"", "author": "pleku", "createdAt": "2020-06-15T13:44:46Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -177,6 +186,10 @@\n      * Adds multiple items after the given target item.\n      * The full collection is added in order after the target.\n      * <p>\n+     * Moves the data list items to the proper position (next to {@code after}\n+     * item) if they already present, so as to keep the ordering of the\n+     * {@code items} collection.", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNzU5OA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440337598", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-06-15T17:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4NTcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4NjE4Nw==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440186187", "bodyText": "Maybe something like\n\"Any items that are already present in the data provider are moved.\"", "author": "pleku", "createdAt": "2020-06-15T13:45:25Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -197,6 +210,10 @@\n      * Adds multiple items before the given target item.\n      * The full collection is added in order before the target.\n      * <p>\n+     * Moves the data list items to the proper position (next to {@code before}\n+     * item) if they already present, so as to keep the ordering of the\n+     * {@code items} collection.\n+     * <p>", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNzYzMw==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440337633", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-06-15T17:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4NjE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4NzQ1Ng==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440187456", "bodyText": "It seems to me there are some exceptions that are thrown from the code on purpose, but there are no unit tests added that verify that and help us not to accidentally remove those. Or are those tested already by existing tests ?", "author": "pleku", "createdAt": "2020-06-15T13:47:08Z", "path": "flow-data/src/test/java/com/vaadin/flow/data/provider/AbstractListDataViewTest.java", "diffHunk": "@@ -327,6 +418,38 @@ public void addItemsBefore_allItemsAreAddedBeforeTargetItem() {\n                 dataView.getItems().toArray(String[]::new));\n     }\n \n+    @Test\n+    public void addItemsBefore_someItemsAlreadyInList_allItemsAreMovedBeforeTargetAndOrdered() {\n+\n+        dataView.addItemsBefore(Arrays.asList(\"first\", \"newOne\", \"newTwo\"),\n+                \"last\");\n+\n+        Assert.assertArrayEquals(\n+                new String[]{\"middle\", \"first\", \"newOne\", \"newTwo\", \"last\"},\n+                dataView.getItems().toArray(String[]::new));\n+\n+        dataView.addItemsBefore(Arrays.asList(\"newThree\", \"last\"),\n+                \"last\");\n+\n+        Assert.assertArrayEquals(\n+                new String[]{\"middle\", \"first\", \"newOne\", \"newTwo\", \"newThree\", \"last\"},\n+                dataView.getItems().toArray(String[]::new));\n+\n+        dataView.addItemsBefore(Arrays.asList(\"newFour\", \"middle\"),\n+                \"middle\");\n+\n+        Assert.assertArrayEquals(\n+                new String[]{\"newFour\", \"middle\", \"first\", \"newOne\", \"newTwo\", \"newThree\", \"last\"},\n+                dataView.getItems().toArray(String[]::new));\n+\n+        dataView.addItemsBefore(Collections.singletonList(\"newFive\"), \"newFour\");\n+\n+        Assert.assertArrayEquals(\n+                new String[]{\"newFive\", \"newFour\", \"middle\", \"first\", \"newOne\"\n+                        , \"newTwo\", \"newThree\", \"last\"},\n+                dataView.getItems().toArray(String[]::new));\n+    }\n+", "originalCommit": "55e30875759a03eea00850e3f24b9cbfe0f4b592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzODI0NQ==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440338245", "bodyText": "You're right, there were some tests missing. Done", "author": "mshabarov", "createdAt": "2020-06-15T17:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4NzQ1Ng=="}], "type": "inlineReview"}, {"oid": "d82da251fddf62dc71a3ecc1d041843beec5b9a7", "url": "https://github.com/vaadin/flow/commit/d82da251fddf62dc71a3ecc1d041843beec5b9a7", "message": "Fix the code review comments", "committedDate": "2020-06-15T17:04:40Z", "type": "commit"}, {"oid": "981c15d0c4ab159bb34c78383e18f9ba2434fb39", "url": "https://github.com/vaadin/flow/commit/981c15d0c4ab159bb34c78383e18f9ba2434fb39", "message": "Delete extra removeIf method, naming improvements", "committedDate": "2020-06-15T17:32:16Z", "type": "commit"}, {"oid": "eb84bc0bb899a3dd873e91e0f834666d19d0ac8b", "url": "https://github.com/vaadin/flow/commit/eb84bc0bb899a3dd873e91e0f834666d19d0ac8b", "message": "Add a comments for specific item collection adding case", "committedDate": "2020-06-16T06:07:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1ODU5NA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440658594", "bodyText": "Like we commonly do, this exception could be thrown in the beginning of the method in a \"if not instance of list\" check. That would remove the need for having this if-else later on. I think it could be thrown after the null check, before the contains", "author": "pleku", "createdAt": "2020-06-16T07:58:16Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -408,10 +429,10 @@ private boolean equals(T item, T compareTo,\n \n             itemList.addAll(indexToInsertItems, items);\n             dataProvider.refreshAll();\n-            return this;\n+        } else {\n+            throw new IllegalArgumentException(\n+                    String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n+                            backendItems.getClass().getSimpleName()));", "originalCommit": "eb84bc0bb899a3dd873e91e0f834666d19d0ac8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3MDA1MA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440670050", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-06-16T08:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1ODU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2MDAwMA==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440660000", "bodyText": "I must apologize - I swear I read yesterday again and again that this method name was the same as above the case without a list, I read it as doAddItemOnTarget instead of doAddItemsOnTarget with the S in the middle. Sorry for that.\nWell, at least now it is obvious :)", "author": "pleku", "createdAt": "2020-06-16T08:00:41Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -324,81 +333,93 @@ private void removeItemIfPresent(T item,\n                 getIdentifier(i, dataProvider::getId)));\n     }\n \n-    private void removeItemIfPresent(T item, ListDataProvider<T> dataProvider,\n-                                     List<T> from) {\n-        final int itemIndex = getItemIndex(item, dataProvider::getId);\n-        if (itemIndex != -1) {\n-            from.remove(itemIndex);\n-        }\n-    }\n-\n     private boolean equals(T item, T compareTo,\n                            ListDataProvider<T> dataProvider) {\n         final Object itemIdentifier = getIdentifier(item, dataProvider::getId);\n         return itemIdentifier.equals(\n                 getIdentifier(compareTo, dataProvider::getId));\n     }\n \n-    private AbstractListDataView<T> doAddItemOnTarget(\n-            T item, T target, String noTargetErrMessage,\n+    private void addItemOnTarget(\n+            T item, T target, String targetItemNotFoundErrorMessage,\n             SerializableFunction<Integer, Integer> insertItemsIndexProvider) {\n         final ListDataProvider<T> dataProvider = getDataProvider();\n \n         if (equals(item, target, dataProvider)) {\n-            return this;\n+            return;\n         }\n \n         final int targetItemIndex = getItemIndex(target, dataProvider::getId);\n         if (targetItemIndex == -1) {\n-            throw new IllegalArgumentException(noTargetErrMessage);\n+            throw new IllegalArgumentException(targetItemNotFoundErrorMessage);\n         }\n         final Collection<T> backendItems = dataProvider.getItems();\n         if (backendItems instanceof List) {\n             final List<T> itemList = (List<T>) backendItems;\n-            removeItemIfPresent(item, dataProvider, itemList);\n+            /*\n+             * If the item is already present in the data provider, then it\n+             * firstly removed from a data provider and secondly re-added into\n+             * the proper position towards to target item.\n+             */\n+            removeItemIfPresent(item, dataProvider);\n             itemList.add(insertItemsIndexProvider.apply(targetItemIndex), item);\n             dataProvider.refreshAll();\n-            return this;\n+        } else {\n+            throw new IllegalArgumentException(\n+                    String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n+                            backendItems.getClass().getSimpleName()));\n         }\n-        throw new IllegalArgumentException(\n-                String.format(COLLECTION_TYPE_ERROR_MESSAGE_PATTERN,\n-                        backendItems.getClass().getSimpleName()));\n     }\n \n-    private AbstractListDataView<T> doAddItemsOnTarget(\n-            Collection<T> items, T target, String noTargetErrMessage,\n+    private void addItemCollectionOnTarget(", "originalCommit": "eb84bc0bb899a3dd873e91e0f834666d19d0ac8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2MjM2Nw==", "url": "https://github.com/vaadin/flow/pull/8550#discussion_r440662367", "bodyText": "Yes, it was completely hard to notice that 's' in the middle, so anyway it had to be renamed ;)", "author": "mshabarov", "createdAt": "2020-06-16T08:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2MDAwMA=="}], "type": "inlineReview"}, {"oid": "36145491e02611f5cb39a92f957d391aad4ff976", "url": "https://github.com/vaadin/flow/commit/36145491e02611f5cb39a92f957d391aad4ff976", "message": "Simplify collection type verification", "committedDate": "2020-06-16T08:17:02Z", "type": "commit"}]}