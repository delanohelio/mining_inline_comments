{"pr_number": 9321, "pr_title": "Forwardporting OSGi feature branch to the master", "pr_createdAt": "2020-11-05T09:25:35Z", "pr_url": "https://github.com/vaadin/flow/pull/9321", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc2MDU3OA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522760578", "bodyText": "Immediately return this expression instead of assigning it to the temporary variable \"resourceProvider\".", "author": "vaadin-bot", "createdAt": "2020-11-13T08:00:01Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "diffHunk": "@@ -832,20 +827,52 @@ private String getClientEngineUrl(BootstrapContext context) {\n             final boolean productionMode = context.getSession()\n                     .getConfiguration().isProductionMode();\n \n-            boolean resolveNow = !productionMode || getClientEngine() == null;\n+            ResourceProvider resourceProvider = getResourceProvider(context);\n+            String clientEngine = getClientEngine(resourceProvider);\n+            boolean resolveNow = !productionMode || clientEngine == null;\n             if (resolveNow\n-                    && ClientResourcesUtils.getResource(\"/META-INF/resources/\"\n+                    && resourceProvider.getClientResource(\"/META-INF/resources/\"\n                             + CLIENT_ENGINE_NOCACHE_FILE) != null) {\n                 return context.getUriResolver().resolveVaadinUri(\n                         \"context://\" + CLIENT_ENGINE_NOCACHE_FILE);\n             }\n \n-            if (getClientEngine() == null) {\n+            if (clientEngine == null) {\n                 throw new BootstrapException(\n                         \"Client engine file name has not been resolved during initialization\");\n             }\n             return context.getUriResolver()\n-                    .resolveVaadinUri(\"context://\" + getClientEngine());\n+                    .resolveVaadinUri(\"context://\" + clientEngine);\n+        }\n+\n+        private ResourceProvider getResourceProvider(BootstrapContext context) {\n+            ResourceProvider resourceProvider = context.getSession()", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwNzU5Mg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522907592", "bodyText": "Even though this code was in the 2.5 version too, I don't recall why is it calling init(this) as the instantiator is created by the factory and the method has been deprecated. Maybe a comment above? The init method javadoc gives the impression that it should be done by the factory", "author": "pleku", "createdAt": "2020-11-13T12:02:07Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +413,31 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                if (instantiator != null && instantiator.init(this)) {", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NTkxNQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524895915", "bodyText": "I hope you understand that it means my intention is failed: it should have been done for 2.5 and now this change should be back-ported after forwardporting. This is exactly what I've been trying to avoid.\nThis should be done by factory.\nBut the method exists. And if it's implemented we should use it I suppose.\nThough I'm not sure: and as result I consider the comment absolutely useless since both approaches makes sense and the code is written using one or another way.\nBut sure, let's add more comments which nobody reads.", "author": "denis-anisimov", "createdAt": "2020-11-17T05:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwNzU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwODY1OA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522908658", "bodyText": "again and still, bad import formatting", "author": "pleku", "createdAt": "2020-11-13T12:04:33Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java", "diffHunk": "@@ -15,6 +15,12 @@\n  */\n package com.vaadin.flow.server.frontend;\n \n+import static com.vaadin.flow.server.Constants.STATISTICS_JSON_DEFAULT;\n+import static com.vaadin.flow.server.Constants.VAADIN_MAPPING;\n+import static com.vaadin.flow.server.Constants.VAADIN_SERVLET_RESOURCES;\n+import static com.vaadin.flow.server.InitParameters.SERVLET_PARAMETER_STATISTICS_JSON;\n+import static java.lang.String.format;\n+", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkxOTE5MA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522919190", "bodyText": "Should the pathInfo be sanitized or is it done by the web container ? So that this doesn't expose a way to traverse contents outside of the static resources directory ? Could not see directly from javadocs if we can expect the container to handle that.", "author": "pleku", "createdAt": "2020-11-13T12:27:40Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NjM4NQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524896385", "bodyText": "And again this code has been already reviewed in 2.5.\nThis is done only for two bundles: flow-client  and flow-push.\nflow-push contains only two resources (and nothing else) and both of them should be exposed.\nflow-client contains client engine compiled files + ts files and map files. Do you see any reason why we should not allow to access any resource in this bundle ?\nDo you suggest add a check for the pathInfo to avoid navigation to parent folders ?\nI would not touch this for now because this should be rewritten via HTTP whiteboard resource registration which should take care about this in a separate PR.", "author": "denis-anisimov", "createdAt": "2020-11-17T05:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkxOTE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyMTUwNg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522921506", "bodyText": "This is the same code as the below method, just total duplication", "author": "pleku", "createdAt": "2020-11-13T12:32:43Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker. OSGi ServiceComponentRuntime\n+     * injects the BundleContext because of the @Activate\n+     * \n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+        open();\n+    }\n+\n+    /**\n+     * OSGi ServiceComponentRuntime calls this method while unregister the\n+     * Service(e.g when stop/uninstall the bundle)\n+     */\n+    @Deactivate\n+    public void deactivate() {\n+        close();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN,\n+                \"/VAADIN/static/push/*\");\n+        servletPushRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(pushBundle,\n+                                \"/META-INF/resources/VAADIN/static/push\"),\n+                        properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletPushRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletPushRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private void registerClientResources(Bundle clientBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(\"osgi.http.whiteboard.servlet.pattern\",\n+                \"/VAADIN/static/client/*\");\n+        servletClientRegistration.compareAndSet(null,\n+                clientBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(clientBundle,\n+                                \"/META-INF/resources/VAADIN/static/client\"),\n+                        properties));\n+    }\n+\n+    private void unregisterClientResource(Bundle clientBundle) {\n+        ServiceRegistration<Servlet> registration = servletClientRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == clientBundle.getBundleId()) {\n+            registration.unregister();\n+            servletClientRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private boolean isPushModule(Bundle bundle) {\n+        return \"com.vaadin.flow.push\".equals(bundle.getSymbolicName());\n+    }\n+\n+    private boolean isClientModule(Bundle bundle) {\n+        return \"com.vaadin.flow.client\".equals(bundle.getSymbolicName());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void scanContextInitializers() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        scanClasses(flowServerBundle, map, this::handleFlowServerClassError);\n+        Collection<Class<?>> classes = map.get(flowServerBundle.getBundleId());\n+\n+        Predicate<Class<?>> isInterface = Class::isInterface;\n+\n+        Collection<Class<? extends ServletContainerInitializer>> initializers = classes\n+                .stream()\n+                .filter(ServletContainerInitializer.class::isAssignableFrom)\n+                .filter(isInterface.negate())\n+                .map(clazz -> (Class<? extends ServletContainerInitializer>) clazz)\n+                .collect(Collectors.toList());\n+        OSGiAccess.getInstance().setServletContainerInitializers(initializers);\n+    }\n+\n+    private void scanActivatedBundle(Bundle bundle) {\n+        if (!isActive(bundle) || !isVaadinExtender(bundle)) {\n+            return;\n+        }\n+        if (OSGiAccess.getInstance().hasInitializers()) {\n+            Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+            scanClasses(bundle, map, this::handleBundleClassError);\n+            OSGiAccess.getInstance().addScannedClasses(map);\n+        } else {\n+            executor.execute(() -> scanActivatedBundle(bundle));\n+        }\n+    }\n+\n+    private void scanActiveBundles() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        Stream.of(flowServerBundle.getBundleContext().getBundles())\n+                .filter(this::isActive).filter(this::isVaadinExtender)\n+                .forEach(activeBundle -> scanClasses(activeBundle, map,\n+                        this::handleBundleClassError));\n+        OSGiAccess.getInstance().addScannedClasses(map);\n+    }\n+\n+    private boolean isActive(Bundle bundle) {\n+        return (bundle.getState() & Bundle.ACTIVE) > 0;\n+    }\n+\n+    private boolean isVaadinExtender(Bundle bundle) {\n+        return !flowServerBundle.equals(bundle) && Boolean.TRUE.toString()\n+                .equals(bundle.getHeaders().get(\"Vaadin-OSGi-Extender\"));\n+    }\n+\n+    private void handleFlowServerClassError(String className,\n+            Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .trace(\"Couldn't load class '{}'\", className, throwable);", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NjQ3MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524896471", "bodyText": "Perhaps, you mean by total duplication  that trace method is totally the same as warn  method.\nBut I think I disagree.\nAnd this code here is for ages : https://github.com/vaadin/flow/blob/2.4/flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java#L137\nhttps://github.com/vaadin/flow/blob/2.4/flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java#L143\nThis is reintroduced code.\nSo you are again reviewing the code in Nth time.", "author": "denis-anisimov", "createdAt": "2020-11-17T05:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyMTUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyMjAzMA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522922030", "bodyText": "Should this and all other occurrences of getUrl() be updated to use getTemplate() instead ? Just to not add more technical debt ? Or if we intend to make the osgi specific registry will go away then not necessary.", "author": "pleku", "createdAt": "2020-11-13T12:33:57Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NjYzMg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524896632", "bodyText": "This is reintroduced code.\nI would suggest to avoid (re-)reviewing the code which is not new but has been removed and then added back overall.\nThis is exactly the reason why I've not done any change : to keep the code the same as in 2.5.\nBut one more reason do not touch this: it will be completely removed once OSGi code moved to osgi repo.", "author": "denis-anisimov", "createdAt": "2020-11-17T05:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyMjAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwNDY2NQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524004665", "bodyText": "Again, adding back deprecated code is not that nice ... but OK for now if we address it soon anyway", "author": "pleku", "createdAt": "2020-11-16T09:13:49Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -67,6 +231,25 @@ protected ApplicationRouteRegistry() {\n                 .forEach(routeFilters::add);\n     }\n \n+    /**\n+     * Gets the route registry for the given servlet context. If the servlet\n+     * context has no route registry, a new instance is created and assigned to\n+     * the context.\n+     *\n+     * @param context\n+     *            the vaadin context for which to get a route registry, not\n+     *            <code>null</code>\n+     * @return a registry instance for the given servlet context, not\n+     *         <code>null</code>\n+     * @deprecated this is deprecated in favor of\n+     *             {@code getInstance(VaadinContext)} and will be removed in a\n+     *             future release\n+     */\n+    @Deprecated\n+    public static ApplicationRouteRegistry getInstance(ServletContext context) {", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NjY3MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524896671", "bodyText": "This is actually done by accident.\nCode is reintroduced from 2.5 but now this method is not used internally and indeed should be removed.", "author": "denis-anisimov", "createdAt": "2020-11-17T05:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwNDY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwNzY0Ng==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524007646", "bodyText": "Wrong import order", "author": "pleku", "createdAt": "2020-11-16T09:16:26Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -15,15 +15,18 @@\n  */\n package com.vaadin.flow.server.startup;\n \n-import javax.servlet.ServletContainerInitializer;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.Set;\n import java.util.stream.Stream;\n \n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzNzkzOQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524037939", "bodyText": "Wrong import ordering", "author": "pleku", "createdAt": "2020-11-16T09:43:20Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/startup/VaadinAppShellInitializerTest.java", "diffHunk": "@@ -15,6 +17,11 @@\n import java.util.Set;\n import java.util.concurrent.ConcurrentMap;\n \n+import javax.annotation.concurrent.NotThreadSafe;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServletRequest;", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzODI4Ng==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524038286", "bodyText": "Wrong import ordering", "author": "pleku", "createdAt": "2020-11-16T09:43:37Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/startup/ServletDeployerTest.java", "diffHunk": "@@ -1,13 +1,17 @@\n package com.vaadin.flow.server.startup;\n \n-import javax.servlet.Registration;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletConfig;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletContextEvent;\n-import javax.servlet.ServletRegistration;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static org.easymock.EasyMock.anyBoolean;\n+import static org.easymock.EasyMock.anyObject;\n+import static org.easymock.EasyMock.anyString;\n+import static org.easymock.EasyMock.capture;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.newCapture;\n+import static org.easymock.EasyMock.replay;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MDc3OA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524040778", "bodyText": "Wrong import ordering", "author": "pleku", "createdAt": "2020-11-16T09:45:47Z", "path": "flow-server/src/test/java/com/vaadin/flow/component/UITest.java", "diffHunk": "@@ -1,7 +1,10 @@\n package com.vaadin.flow.component;\n \n-import javax.servlet.ServletConfig;\n-import javax.servlet.ServletException;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MzAxOQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524043019", "bodyText": "Wrong import ordering", "author": "pleku", "createdAt": "2020-11-16T09:47:58Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerDependenciesTest.java", "diffHunk": "@@ -1,16 +1,28 @@\n package com.vaadin.flow.server;\n \n-import javax.servlet.http.HttpServletRequest;\n+import static org.hamcrest.CoreMatchers.both;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.either;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.mock;", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MzM2Mw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524043363", "bodyText": "Wrong import ordering", "author": "pleku", "createdAt": "2020-11-16T09:48:18Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerPushConfigurationTest.java", "diffHunk": "@@ -1,13 +1,19 @@\n package com.vaadin.flow.server;\n \n-import javax.servlet.http.HttpServletRequest;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MzcyNg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524043726", "bodyText": "Wrong import ordering", "author": "pleku", "createdAt": "2020-11-16T09:48:34Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java", "diffHunk": "@@ -1,8 +1,12 @@\n package com.vaadin.flow.server;\n \n-import javax.servlet.http.HttpServletRequest;\n+import static com.vaadin.flow.server.Constants.VAADIN_MAPPING;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NDAxOA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524044018", "bodyText": "Wrong import ordering", "author": "pleku", "createdAt": "2020-11-16T09:48:50Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/DeploymentConfigurationFactoryTest.java", "diffHunk": "@@ -1,14 +1,29 @@\n package com.vaadin.flow.server;\n \n-import javax.servlet.ServletConfig;\n-import javax.servlet.ServletContext;\n+import static com.vaadin.flow.server.Constants.VAADIN_SERVLET_RESOURCES;\n+import static com.vaadin.flow.server.DeploymentConfigurationFactory.DEV_FOLDER_MISSING_MESSAGE;\n+import static com.vaadin.flow.server.InitParameters.SERVLET_PARAMETER_PRODUCTION_MODE;\n+import static com.vaadin.flow.server.frontend.FrontendUtils.PARAM_TOKEN_FILE;\n+import static com.vaadin.flow.server.frontend.FrontendUtils.TOKEN_FILE;\n+import static java.util.Collections.emptyMap;\n+import static org.easymock.EasyMock.anyObject;\n+import static org.easymock.EasyMock.capture;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.replay;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NTAxNA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524045014", "bodyText": "Wrong import ordering", "author": "pleku", "createdAt": "2020-11-16T09:49:41Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/I18NProviderTest.java", "diffHunk": "@@ -15,32 +15,36 @@\n  */\n package com.vaadin.flow.server;\n \n-import javax.servlet.ServletConfig;\n+import java.util.Locale;\n+import java.util.concurrent.locks.ReentrantLock;\n+", "originalCommit": "442ad42b4470fe7f28f34e70977830cbff288181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e3517a5eed9c52592f8a41c95ac9e4e63e955253", "url": "https://github.com/vaadin/flow/commit/e3517a5eed9c52592f8a41c95ac9e4e63e955253", "message": "fix: revert bnd version", "committedDate": "2020-11-16T11:25:39Z", "type": "commit"}, {"oid": "cb7d9cc8d82db0dfc3363a3f900dd5066f4f0d90", "url": "https://github.com/vaadin/flow/commit/cb7d9cc8d82db0dfc3363a3f900dd5066f4f0d90", "message": "fix: imports order, review comments", "committedDate": "2020-11-17T06:28:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzNTMwNA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r525035304", "bodyText": "Why was this test removed ?", "author": "pleku", "createdAt": "2020-11-17T10:11:52Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java", "diffHunk": "@@ -111,8 +117,8 @@ public void should_reported_routing_hybrid() {\n                 e -> Constants.STATISTIC_ROUTING_SERVER.equals(e.getName())));\n     }\n \n-    @Test\n-    public void testFireSessionDestroy() throws ServletException {\n+    public void testFireSessionDestroy()", "originalCommit": "cb7d9cc8d82db0dfc3363a3f900dd5066f4f0d90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA5Mzk3NA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r525093974", "bodyText": "Good question.\nNo idea. Perhaps merge conflict consequence.\nReturned back.", "author": "denis-anisimov", "createdAt": "2020-11-17T11:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzNTMwNA=="}], "type": "inlineReview"}, {"oid": "977e7f5fa39eda38e2c953fcbe6f8cfd4d14b55f", "url": "https://github.com/vaadin/flow/commit/977e7f5fa39eda38e2c953fcbe6f8cfd4d14b55f", "message": "fix: restore lost test method", "committedDate": "2020-11-17T11:48:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE1NjU0MA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r525156540", "bodyText": "How is it that your imports are again going to the wrong location and causing unnecessary changes ?", "author": "pleku", "createdAt": "2020-11-17T13:35:37Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java", "diffHunk": "@@ -47,10 +51,6 @@\n import com.vaadin.flow.server.communication.StreamRequestHandler;\n import com.vaadin.tests.util.MockDeploymentConfiguration;\n \n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.junit.Assert.assertEquals;\n-", "originalCommit": "977e7f5fa39eda38e2c953fcbe6f8cfd4d14b55f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "df5658b82b63ac24aafcd953f380fc9b8fb73e64", "url": "https://github.com/vaadin/flow/commit/df5658b82b63ac24aafcd953f380fc9b8fb73e64", "message": "fix: import orders", "committedDate": "2020-11-17T13:53:12Z", "type": "commit"}, {"oid": "da5580aa34f3395ad747f9cd3bf0c080c8fc9188", "url": "https://github.com/vaadin/flow/commit/da5580aa34f3395ad747f9cd3bf0c080c8fc9188", "message": "Read stats.json content as a bundle resource in OSGi\nRead token file as a bundle resource in OSGi\n\nFixes #9146\nFix NPE\nRevert logic back to the previous state\n# Conflicts:\n#\tflow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "committedDate": "2020-11-04T06:17:07Z", "type": "commit"}, {"oid": "d33c57c23bbe8fbc305110aad3492f157248be30", "url": "https://github.com/vaadin/flow/commit/d33c57c23bbe8fbc305110aad3492f157248be30", "message": "Refactor Instantiator and resources access\n\nFixes #9185\nExclude non-serializable classes\nDrop dependency to flow-push from flow-server\n# Conflicts:\n#\tflow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java\n#\tflow-server/src/main/resources/META-INF/services/javax.servlet.ServletContainerInitializer\n#\tflow-server/src/test/java/com/vaadin/flow/server/connect/generator/endpoints/model/OSGiInstantiatorFactory.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/connect/generator/endpoints/model/OSGiResourceProvider.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/connect/typeconversion/StringConversionTest.java", "committedDate": "2020-11-04T06:42:41Z", "type": "commit"}, {"oid": "86997a50a122eec3fe24f3a5db0ef1d0ab738fa5", "url": "https://github.com/vaadin/flow/commit/86997a50a122eec3fe24f3a5db0ef1d0ab738fa5", "message": "Remove flow-osgi dep from flow-push, increase osgi cmpn version\n# Conflicts:\n#\tflow-push/pom.xml\n#\tflow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "committedDate": "2020-11-04T06:46:14Z", "type": "commit"}, {"oid": "979e73fbf5c898036663f88244be8d1f328f7a0e", "url": "https://github.com/vaadin/flow/commit/979e73fbf5c898036663f88244be8d1f328f7a0e", "message": "Correct unit tests after refactoring: make them compiling\nMock VaadinServlet in MockVaadinServletService\nAdapt unit tests for refactored code\nAdapt more unti tests and add one more new SPI method\nFix serializable test, proceed with unit tests adaption\nAdapt unit tests for classes in com.vaadin.flow.server\nAdapt unit tests in the com.vaadin.flow.server.communication package\n* Adapt more unit tests\n\n* Make sure that ServletContextInitializers are executed after\nLookupInitializer\nFix OSGi presence check to be able to run unit test\nAdapt servlet deployer unit tests\nExclude OSGi related classes from test\nExclude all OSGi impl classes from serializable test\n# Conflicts:\n#\tflow-polymer-template/src/test/java/com/vaadin/flow/component/polymertemplate/NpmTemplateParserTest.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java\n#\tflow-server/src/main/resources/META-INF/services/javax.servlet.ServletContainerInitializer\n#\tflow-server/src/test/java/com/vaadin/flow/component/InvalidUrlTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/component/UITest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerDependenciesTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/DeploymentConfigurationFactoryTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/I18NProviderTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/MockServletServiceSessionSetup.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/VaadinServletConfigurationTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/VaadinServletServiceTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/VaadinSessionTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/communication/PushHandlerTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/communication/WebComponentBootstrapHandlerTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/startup/DevModeInitializerTestBase.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/startup/EnableOSGiRunner.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/startup/ServletDeployerTest.java", "committedDate": "2020-11-04T10:08:05Z", "type": "commit"}, {"oid": "685d0149e01bd3ef066185839a74900bcdd39406", "url": "https://github.com/vaadin/flow/commit/685d0149e01bd3ef066185839a74900bcdd39406", "message": "Fix OSGi Lookup related issues\nFix OSGi related unit test one more time\n\n# Conflicts:\n#\tflow-osgi/src/main/java/com/vaadin/flow/osgi/support/OSGiResourceProvider.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/VaadinServlet.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/startup/EnableOSGiRunner.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/startup/OSGiInitApplicationRouteRegistryTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/webcomponent/OSGiWebComponentConfigurationRegistryTest.java\n#\tflow-tests/test-root-context/src/main/java/com/vaadin/flow/osgi/Activator.java", "committedDate": "2020-11-05T06:02:16Z", "type": "commit"}, {"oid": "29d48da9eff729d253c6790ec4e28dff0bcba4cf", "url": "https://github.com/vaadin/flow/commit/29d48da9eff729d253c6790ec4e28dff0bcba4cf", "message": "Correct the resource access for VaadinService", "committedDate": "2020-11-05T06:03:22Z", "type": "commit"}, {"oid": "0520283b2b998413934c5ec27aa64f96c60874d6", "url": "https://github.com/vaadin/flow/commit/0520283b2b998413934c5ec27aa64f96c60874d6", "message": "Extend SPI, provide javadocs some unit tests fixes\nMinor code corrections, javadocs\nCorrect unit test\n# Conflicts:\n#\tflow-polymer-template/src/test/java/com/vaadin/flow/component/polymertemplate/NpmTemplateParserTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/communication/WebComponentBootstrapHandlerTest.java", "committedDate": "2020-11-05T06:06:59Z", "type": "commit"}, {"oid": "cd7f3d3ed1e1860bf3eb7466a8216982254840fd", "url": "https://github.com/vaadin/flow/commit/cd7f3d3ed1e1860bf3eb7466a8216982254840fd", "message": "test: add unit tests\n\n# Conflicts:\n#\tflow-tests/test-root-context/src/main/java/com/vaadin/flow/osgi/Activator.java", "committedDate": "2020-11-05T06:10:17Z", "type": "commit"}, {"oid": "2eb52f35370e62b366621f635ce674007621e6d7", "url": "https://github.com/vaadin/flow/commit/2eb52f35370e62b366621f635ce674007621e6d7", "message": "test: make it possible to run felix-jetty in npm mode\n# Conflicts:\n#\tflow-tests/servlet-containers/felix-jetty/pom.xml\n#\tflow-tests/test-root-context/pom-npm.xml", "committedDate": "2020-11-05T06:40:22Z", "type": "commit"}, {"oid": "fa61198e67e8d46216658dab837f6937cad4115f", "url": "https://github.com/vaadin/flow/commit/fa61198e67e8d46216658dab837f6937cad4115f", "message": "Make httpclient dependency optional for now. (#9262)", "committedDate": "2020-11-05T06:45:53Z", "type": "commit"}, {"oid": "999fd8ceefecb1a2668a7e10868911b65927eaa0", "url": "https://github.com/vaadin/flow/commit/999fd8ceefecb1a2668a7e10868911b65927eaa0", "message": "refactoring: move OSGi resource provider impl to flow-server (#9268)\n\nOSGi ResourceProvider impl should be available as a service at the moment when Vaadin WAB register a servlet.\r\nIt's not possible without extra unclear config to make sure that the service is registered if it's in the flow-osgi : the bundle may be activated at any moment regardless of servlet registration.\r\nThe issue doesn't appear if the service is registered at the flow-bundle start phase.", "committedDate": "2020-11-05T06:46:02Z", "type": "commit"}, {"oid": "a8f93dd147b9cc8d2631caa137c6ac74af447e8a", "url": "https://github.com/vaadin/flow/commit/a8f93dd147b9cc8d2631caa137c6ac74af447e8a", "message": "refactor: review fixes for OSGi (#9289)\n\n* refactoring: review fixes\n\n* chore: add a comment about Jar packaging in test-root-context module\n\n* fix: ensureServletContext should be always called\n\n* fix: fix review comments\n# Conflicts:\n#\tflow-tests/test-root-context/pom-npm.xml", "committedDate": "2020-11-05T06:49:25Z", "type": "commit"}, {"oid": "db6c16fb6947ec02a1eada01d49f973ad74dfd93", "url": "https://github.com/vaadin/flow/commit/db6c16fb6947ec02a1eada01d49f973ad74dfd93", "message": "refactor: get rid of cmpn osgi dependency (#9307)\n\nNot needed for flow-server.", "committedDate": "2020-11-05T06:49:56Z", "type": "commit"}, {"oid": "4a2f0cc3af995696a01abbfc83e5f8982307467d", "url": "https://github.com/vaadin/flow/commit/4a2f0cc3af995696a01abbfc83e5f8982307467d", "message": "refactoring: App classpath resources should be access via\nResourceProvider (#9278)\n\nFixes #9269\n# Conflicts:\n#\tflow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/NpmTemplateParser.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/BootstrapUtils.java", "committedDate": "2020-11-05T06:57:18Z", "type": "commit"}, {"oid": "47c73901a6aaaaa7b7bb29a77bb0a18dc64c3054", "url": "https://github.com/vaadin/flow/commit/47c73901a6aaaaa7b7bb29a77bb0a18dc64c3054", "message": "test: update unit tests", "committedDate": "2020-11-05T07:07:55Z", "type": "commit"}, {"oid": "75d5266785bb039a6e9e25f103e18c685bff712f", "url": "https://github.com/vaadin/flow/commit/75d5266785bb039a6e9e25f103e18c685bff712f", "message": "refactor: fix various OSGi related issues\n\n* add back lost classes during cherry-picks\n* fix unit tests\n* rewrite polymer template RPC", "committedDate": "2020-11-05T09:24:07Z", "type": "commit"}, {"oid": "cd6a79f8fd4548cbf6b2f8c0ee7b9017d9dbffc3", "url": "https://github.com/vaadin/flow/commit/cd6a79f8fd4548cbf6b2f8c0ee7b9017d9dbffc3", "message": "fix: fix javadocs after merge conflicts", "committedDate": "2020-11-05T09:37:29Z", "type": "commit"}, {"oid": "b76bb04b8da64606ffed8de85e0a73a50791a92e", "url": "https://github.com/vaadin/flow/commit/b76bb04b8da64606ffed8de85e0a73a50791a92e", "message": "fix: fix mocks in unit tests", "committedDate": "2020-11-05T10:15:23Z", "type": "forcePushed"}, {"oid": "90bdb831c48009090c8d1d60483aa3441c0ed307", "url": "https://github.com/vaadin/flow/commit/90bdb831c48009090c8d1d60483aa3441c0ed307", "message": "fix: fix mocks in unit tests", "committedDate": "2020-11-05T10:39:14Z", "type": "forcePushed"}, {"oid": "92b3ef78a148028061fa3bda24d0a9c6eb6b746b", "url": "https://github.com/vaadin/flow/commit/92b3ef78a148028061fa3bda24d0a9c6eb6b746b", "message": "fix: fix mocks in unit tests", "committedDate": "2020-11-05T11:25:47Z", "type": "forcePushed"}, {"oid": "7201920d92d063407c1c81f2d47ebefcf7489466", "url": "https://github.com/vaadin/flow/commit/7201920d92d063407c1c81f2d47ebefcf7489466", "message": "fix: fix mocks in unit tests", "committedDate": "2020-11-05T11:48:32Z", "type": "commit"}, {"oid": "7201920d92d063407c1c81f2d47ebefcf7489466", "url": "https://github.com/vaadin/flow/commit/7201920d92d063407c1c81f2d47ebefcf7489466", "message": "fix: fix mocks in unit tests", "committedDate": "2020-11-05T11:48:32Z", "type": "forcePushed"}, {"oid": "9093a8ff08ceca07a525a4fab2a4726aa1b29c5d", "url": "https://github.com/vaadin/flow/commit/9093a8ff08ceca07a525a4fab2a4726aa1b29c5d", "message": "test: Correct activator", "committedDate": "2020-11-06T05:27:52Z", "type": "commit"}, {"oid": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "url": "https://github.com/vaadin/flow/commit/135613e7b9bbe1f14333dc2a628f34f36ccadd37", "message": "refactor: correct lookup initializer filtering code", "committedDate": "2020-11-06T06:50:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjYwMw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572603", "bodyText": "This call to \"add()\" may be a performance hot spot if the collection is large.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:43:53Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/DeferredServletContextInitializers.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.server.VaadinContext;\n+\n+/**\n+ * Internal collection of initializers which may not be executed immediately but\n+ * requires a {@link Lookup} instance which will be set in the\n+ * {@link VaadinContext} ({@link ServletContext}) only when\n+ * {@link LookupInitializer} completed.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+class DeferredServletContextInitializers {\n+\n+    /**\n+     * A callback which will be called to run\n+     * {@link ServletContainerInitializer} logic once a {@link ServletContext}\n+     * is initialized with {@link Lookup}.\n+     * \n+     * @author Vaadin Ltd\n+     * @since\n+     *\n+     */\n+    interface Initializer {\n+        /**\n+         * Runs {@link ServletContainerInitializer} logic with the provided\n+         * {@code context}.\n+         * \n+         * @param context\n+         * @throws ServletException\n+         *             thrown if the initializer throws an exception\n+         */\n+        void init(ServletContext context) throws ServletException;\n+    }\n+\n+    private final List<Initializer> initializers = new CopyOnWriteArrayList<>();\n+\n+    /**\n+     * Adds deferred initializer\n+     * \n+     * @param initializer\n+     *            an initializer\n+     */\n+    void addInitializer(Initializer initializer) {\n+        initializers.add(initializer);", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjYzMA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572630", "bodyText": "\"servletContext\" is a method parameter, and should not be used for synchronization.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:43:56Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjYzNA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572634", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:43:57Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {\n+            initializers = vaadinContext\n+                    .getAttribute(DeferredServletContextInitializers.class);\n+            vaadinContext\n+                    .removeAttribute(DeferredServletContextInitializers.class);\n+        }\n+\n+        if (initializers != null) {\n+            initializers.runInitializers(servletContext);\n+        }\n+    }\n+\n+    @Override\n+    public boolean requiresLookup() {\n+        return false;\n+    }\n+\n+    private void initStandardLookup(Set<Class<?>> classSet,\n+            ServletContext servletContext) {\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+\n+        Map<Class<?>, Collection<Object>> services = new HashMap<>();\n+\n+        collectResourceProviders(classSet, services);\n+        collectSubclasses(InstantiatorFactory.class, classSet, services);\n+        collectSubclasses(DeprecatedPolymerPublishedEventHandler.class,", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjYzOA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572638", "bodyText": "Reduce the number of conditional operators (5) used in the expression (maximum allowed 3).", "author": "vaadin-bot", "createdAt": "2020-11-06T07:43:58Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {\n+            initializers = vaadinContext\n+                    .getAttribute(DeferredServletContextInitializers.class);\n+            vaadinContext\n+                    .removeAttribute(DeferredServletContextInitializers.class);\n+        }\n+\n+        if (initializers != null) {\n+            initializers.runInitializers(servletContext);\n+        }\n+    }\n+\n+    @Override\n+    public boolean requiresLookup() {\n+        return false;\n+    }\n+\n+    private void initStandardLookup(Set<Class<?>> classSet,\n+            ServletContext servletContext) {\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+\n+        Map<Class<?>, Collection<Object>> services = new HashMap<>();\n+\n+        collectResourceProviders(classSet, services);\n+        collectSubclasses(InstantiatorFactory.class, classSet, services);\n+        collectSubclasses(DeprecatedPolymerPublishedEventHandler.class,\n+                classSet, services);\n+\n+        LookupImpl lookup = new LookupImpl(services);\n+        vaadinContext.setAttribute(Lookup.class, lookup);\n+    }\n+\n+    private void collectSubclasses(Class<?> clazz, Set<Class<?>> classSet,\n+            Map<Class<?>, Collection<Object>> services) {\n+        services.put(clazz,\n+                filterSubClasses(clazz, classSet).stream()\n+                        .map(ReflectTools::createInstance)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    private void collectResourceProviders(Set<Class<?>> classSet,\n+            Map<Class<?>, Collection<Object>> services) {\n+        Set<Class<?>> providers = filterResourceProviders(classSet);\n+        if (providers.isEmpty()) {\n+            services.put(ResourceProvider.class,\n+                    Collections.singletonList(new ResourceProviderImpl()));\n+        } else if (providers.size() > 1) {\n+            throw new IllegalStateException(\n+                    SEVERAL_IMPLS + ResourceProvider.class.getSimpleName() + SPI\n+                            + classSet + ONE_IMPL_REQUIRED);\n+        } else {\n+            Class<?> clazz = providers.iterator().next();\n+            services.put(ResourceProvider.class, Collections\n+                    .singletonList(ReflectTools.createInstance(clazz)));\n+        }\n+    }\n+\n+    private Set<Class<?>> filterResourceProviders(Set<Class<?>> classes) {\n+        return classes == null ? Collections.emptySet()", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY0Nw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572647", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:43:59Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY1Mg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572652", "bodyText": "Reduce the total number of break and continue statements in this loop to use at most one.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:43:59Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class PushResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+\n+        public PushResourceServlet(Bundle pushBundle) {\n+            bundle = pushBundle;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(\n+                    \"/META-INF/resources/VAADIN/static/push\" + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker.\n+     *\n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(\"osgi.http.whiteboard.servlet.pattern\",\n+                \"/VAADIN/static/push/*\");\n+        servletRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new PushResourceServlet(pushBundle), properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletRegistration.get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private boolean isPushModule(Bundle bundle) {\n+        return \"com.vaadin.flow.push\".equals(bundle.getSymbolicName());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void scanContextInitializers() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        scanClasses(flowServerBundle, map, this::handleFlowServerClassError);\n+        Collection<Class<?>> classes = map.get(flowServerBundle.getBundleId());\n+\n+        Predicate<Class<?>> isInterface = Class::isInterface;\n+\n+        Collection<Class<? extends ServletContainerInitializer>> initializers = classes\n+                .stream()\n+                .filter(ServletContainerInitializer.class::isAssignableFrom)\n+                .filter(isInterface.negate())\n+                .map(clazz -> (Class<? extends ServletContainerInitializer>) clazz)\n+                .collect(Collectors.toList());\n+        OSGiAccess.getInstance().setServletContainerInitializers(initializers);\n+    }\n+\n+    private void scanActivatedBundle(Bundle bundle) {\n+        if (!isActive(bundle) || !isVaadinExtender(bundle)) {\n+            return;\n+        }\n+        if (OSGiAccess.getInstance().hasInitializers()) {\n+            Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+            scanClasses(bundle, map, this::handleBundleClassError);\n+            OSGiAccess.getInstance().addScannedClasses(map);\n+        } else {\n+            executor.execute(() -> scanActivatedBundle(bundle));\n+        }\n+    }\n+\n+    private void scanActiveBundles() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        Stream.of(flowServerBundle.getBundleContext().getBundles())\n+                .filter(this::isActive).filter(this::isVaadinExtender)\n+                .forEach(activeBundle -> scanClasses(activeBundle, map,\n+                        this::handleBundleClassError));\n+        OSGiAccess.getInstance().addScannedClasses(map);\n+    }\n+\n+    private boolean isActive(Bundle bundle) {\n+        return (bundle.getState() & Bundle.ACTIVE) > 0;\n+    }\n+\n+    private boolean isVaadinExtender(Bundle bundle) {\n+        return !flowServerBundle.equals(bundle) && Boolean.TRUE.toString()\n+                .equals(bundle.getHeaders().get(\"Vaadin-OSGi-Extender\"));\n+    }\n+\n+    private void handleFlowServerClassError(String className,\n+            Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .trace(\"Couldn't load class '{}'\", className, throwable);\n+    }\n+\n+    private void handleBundleClassError(String className, Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .warn(\"Couldn't load class '{}'\", className, throwable);\n+    }\n+\n+    private void scanClasses(Bundle bundle, Map<Long, Collection<Class<?>>> map,\n+            BiConsumer<String, Throwable> throwableHandler) {\n+        BundleWiring wiring = bundle.adapt(BundleWiring.class);\n+\n+        // get all .class resources of this bundle\n+        Collection<String> classes = wiring.listResources(\"/\", \"*.class\",\n+                BundleWiring.LISTRESOURCES_RECURSE);\n+\n+        Collection<Class<?>> bundleClasses = new ArrayList<>();\n+\n+        for (String clazz : classes) {", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY1Ng==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572656", "bodyText": "Add a \"try/catch\" block for \"openStream\".", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:01Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class PushResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+\n+        public PushResourceServlet(Bundle pushBundle) {\n+            bundle = pushBundle;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(\n+                    \"/META-INF/resources/VAADIN/static/push\" + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY2NQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572665", "bodyText": "Replace the synchronized class \"Hashtable\" by an unsynchronized one such as \"HashMap\".", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:02Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class PushResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+\n+        public PushResourceServlet(Bundle pushBundle) {\n+            bundle = pushBundle;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(\n+                    \"/META-INF/resources/VAADIN/static/push\" + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker.\n+     *\n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY3MA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572670", "bodyText": "Add a \"try/catch\" block for \"copy\". \n Add a \"try/catch\" block for \"getOutputStream\".", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:02Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class PushResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+\n+        public PushResourceServlet(Bundle pushBundle) {\n+            bundle = pushBundle;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(\n+                    \"/META-INF/resources/VAADIN/static/push\" + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjY3Nw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572677", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:03Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java", "diffHunk": "@@ -135,13 +139,13 @@\n     /**\n      * Default folder for copying front-end resources present in the classpath\n      * jars.\n-     * @deprecated This is deprecated due to a typo.\n-     *             Use DEFAULT_FLOW_RESOURCES_FOLDER instead.\n+     * \n+     * @deprecated This is deprecated due to a typo. Use\n+     *             DEFAULT_FLOW_RESOURCES_FOLDER instead.\n      * @see #DEFAULT_FLOW_RESOURCES_FOLDER\n      */\n     @Deprecated\n-    public static final String DEAULT_FLOW_RESOURCES_FOLDER =\n-            DEFAULT_FLOW_RESOURCES_FOLDER;\n+    public static final String DEAULT_FLOW_RESOURCES_FOLDER = DEFAULT_FLOW_RESOURCES_FOLDER;", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjcwMw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572703", "bodyText": "This call to \"add()\" may be a performance hot spot if the collection is large.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:07Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +63,127 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc1MA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572750", "bodyText": "Remove this use of \"init\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:12Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +410,31 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                if (instantiator != null && instantiator.init(this)) {\n+                    instantiators.add(instantiator);\n+                }\n+            }\n+        }\n+\n+        if (instantiators == null) {\n+            instantiators = new ArrayList<>();\n+        }\n+\n+        // the code to support previous way of loading instantiators\n+        StreamSupport\n                 .stream(ServiceLoader.load(Instantiator.class, getClassLoader())\n                         .spliterator(), false)\n                 .filter(iterator -> iterator.init(this))", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc1OA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572758", "bodyText": "Rename \"instantiator\" which hides the field declared at line 191.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:13Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +410,31 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc2Nw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572767", "bodyText": "Remove this use of \"init\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:14Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +410,31 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                if (instantiator != null && instantiator.init(this)) {", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc3Mw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572773", "bodyText": "Reduce this lambda expression number of lines from 37 to at most 20.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:14Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc4MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572781", "bodyText": "This block of commented-out lines of code should be removed.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:15Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc4Nw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572787", "bodyText": "Replace this lambda with a method reference.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:16Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n+\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {\n+                if (vaadinContext.getAttribute(Lookup.class) == null) {\n+                    DeferredServletContextInitializers initializers = vaadinContext\n+                            .getAttribute(\n+                                    DeferredServletContextInitializers.class,\n+                                    () -> new DeferredServletContextInitializers());", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc5MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572791", "bodyText": "Replace this lambda with a method reference.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:17Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n+\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {\n+                if (vaadinContext.getAttribute(Lookup.class) == null) {\n+                    DeferredServletContextInitializers initializers = vaadinContext\n+                            .getAttribute(\n+                                    DeferredServletContextInitializers.class,\n+                                    () -> new DeferredServletContextInitializers());\n+                    initializers.addInitializer(\n+                            ctx -> deferredInitializer.init(ctx));", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjc5NQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572795", "bodyText": "\"context\" is a method parameter, and should not be used for synchronization.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:18Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n+\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjgwNA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572804", "bodyText": "Either log or rethrow this exception. \n Catch Exception instead of Throwable.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:19Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\n+                    \"Couldn't run servlet context initializer \"\n+                            + initializer.getClass(),\n+                    e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Set<Class<?>> filterClasses(HandlesTypes typesAnnotation) {\n+        Set<Class<?>> result = new HashSet<>();\n+        if (typesAnnotation == null) {\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes));\n+        } else {\n+            Class<?>[] requestedTypes = typesAnnotation.value();\n+\n+            Predicate<Class<?>> isAnnotation = Class::isAnnotation;\n+\n+            List<Class<? extends Annotation>> annotations = Stream\n+                    .of(requestedTypes).filter(isAnnotation)\n+                    .map(clazz -> (Class<? extends Annotation>) clazz)\n+                    .collect(Collectors.toList());\n+\n+            List<Class<?>> superTypes = Stream.of(requestedTypes)\n+                    .filter(isAnnotation.negate()).collect(Collectors.toList());\n+\n+            Predicate<Class<?>> hasType = clazz -> annotations.stream()\n+                    .anyMatch(annotation -> AnnotationReader\n+                            .getAnnotationFor(clazz, annotation).isPresent())\n+                    || superTypes.stream()\n+                            .anyMatch(superType -> GenericTypeReflector\n+                                    .isSuperType(HasErrorParameter.class,\n+                                            clazz));\n+\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes\n+                    .stream().filter(hasType).collect(Collectors.toList())));\n+\n+        }\n+        return result;\n+    }\n+\n+    private ServletContext createOSGiServletContext() {\n+        Builder<OSGiServletContext> builder = new ByteBuddy()\n+                .subclass(OSGiServletContext.class);\n+\n+        Class<? extends OSGiServletContext> osgiServletContextClass = builder\n+                .make().load(OSGiServletContext.class.getClassLoader(),\n+                        ClassLoadingStrategy.Default.WRAPPER)\n+                .getLoaded();\n+\n+        OSGiServletContext osgiContext = ReflectTools.createProxyInstance(\n+                osgiServletContextClass, ServletContext.class);\n+\n+        new VaadinServletContext(osgiContext).setAttribute(Lookup.class,\n+                new OsgiLookupImpl());\n+\n+        return osgiContext;\n+    }\n+\n+    private static final class LazyOSGiDetector {\n+        private static final boolean IS_IN_OSGI = isInOSGi();\n+\n+        private static boolean isInOSGi() {\n+            try {\n+                Class<?> clazz = Class\n+                        .forName(\"org.osgi.framework.FrameworkUtil\");\n+\n+                Method method = clazz.getDeclaredMethod(\"getBundle\",\n+                        Class.class);\n+\n+                // even though the FrameworkUtil class is in the classpath it\n+                // may be there not because of OSGi container but plain WAR with\n+                // jar which contains the class\n+                if (method.invoke(null, OSGiAccess.class) == null) {\n+                    return false;\n+                }\n+                UsageStatistics.markAsUsed(\"flow/osgi\", getOSGiVersion());\n+\n+                return true;\n+            } catch (ClassNotFoundException | NoSuchMethodException\n+                    | SecurityException | IllegalAccessException\n+                    | IllegalArgumentException\n+                    | InvocationTargetException exception) {\n+                if (LoggerFactory.getLogger(OSGiAccess.class)\n+                        .isTraceEnabled()) {\n+                    LoggerFactory.getLogger(OSGiAccess.class)\n+                            .trace(\"Exception in OSGi container check \"\n+                                    + \"(which most likely means that this is not OSGi container)\",\n+                                    exception);\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /**\n+         * Tries to detect the version of the OSGi framework used.\n+         *\n+         * @return the used OSGi version or {@code null} if not able to detect\n+         *         it\n+         */\n+        private static String getOSGiVersion() {\n+            try {\n+                Bundle osgiBundle = org.osgi.framework.FrameworkUtil\n+                        .getBundle(Bundle.class);\n+                return osgiBundle.getVersion().toString();\n+            } catch (Throwable throwable) {", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjgxNw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572817", "bodyText": "Add a private constructor to hide the implicit public one.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:19Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\n+                    \"Couldn't run servlet context initializer \"\n+                            + initializer.getClass(),\n+                    e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Set<Class<?>> filterClasses(HandlesTypes typesAnnotation) {\n+        Set<Class<?>> result = new HashSet<>();\n+        if (typesAnnotation == null) {\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes));\n+        } else {\n+            Class<?>[] requestedTypes = typesAnnotation.value();\n+\n+            Predicate<Class<?>> isAnnotation = Class::isAnnotation;\n+\n+            List<Class<? extends Annotation>> annotations = Stream\n+                    .of(requestedTypes).filter(isAnnotation)\n+                    .map(clazz -> (Class<? extends Annotation>) clazz)\n+                    .collect(Collectors.toList());\n+\n+            List<Class<?>> superTypes = Stream.of(requestedTypes)\n+                    .filter(isAnnotation.negate()).collect(Collectors.toList());\n+\n+            Predicate<Class<?>> hasType = clazz -> annotations.stream()\n+                    .anyMatch(annotation -> AnnotationReader\n+                            .getAnnotationFor(clazz, annotation).isPresent())\n+                    || superTypes.stream()\n+                            .anyMatch(superType -> GenericTypeReflector\n+                                    .isSuperType(HasErrorParameter.class,\n+                                            clazz));\n+\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes\n+                    .stream().filter(hasType).collect(Collectors.toList())));\n+\n+        }\n+        return result;\n+    }\n+\n+    private ServletContext createOSGiServletContext() {\n+        Builder<OSGiServletContext> builder = new ByteBuddy()\n+                .subclass(OSGiServletContext.class);\n+\n+        Class<? extends OSGiServletContext> osgiServletContextClass = builder\n+                .make().load(OSGiServletContext.class.getClassLoader(),\n+                        ClassLoadingStrategy.Default.WRAPPER)\n+                .getLoaded();\n+\n+        OSGiServletContext osgiContext = ReflectTools.createProxyInstance(\n+                osgiServletContextClass, ServletContext.class);\n+\n+        new VaadinServletContext(osgiContext).setAttribute(Lookup.class,\n+                new OsgiLookupImpl());\n+\n+        return osgiContext;\n+    }\n+\n+    private static final class LazyOSGiDetector {", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjgyNQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572825", "bodyText": "Define and throw a dedicated exception instead of using a generic one.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:20Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjgzMw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572833", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:21Z", "path": "flow-server/src/main/java/com/vaadin/flow/di/Instantiator.java", "diffHunk": "@@ -63,7 +63,12 @@\n      * @return <code>true</code> if this instance should be considered as a\n      *         candidate for usage for the provided service; <code>false</code>\n      *         to opt-out from the selection process\n+     * @deprecated The {@link Instantiator} instance should be created by an\n+     *             {@link InstantiatorFactory} which should just return\n+     *             {@code null} if the provided {@code service} can't be handled\n+     *             by it\n      */\n+    @Deprecated\n     boolean init(VaadinService service);", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjgzNg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572836", "bodyText": "Remove this use of \"Thread.sleep()\".", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:22Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/webcomponent/OSGiWebComponentConfigurationRegistryTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.vaadin.flow.server.webcomponent;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.startup.EnableOSGiRunner;\n+\n+import net.jcip.annotations.NotThreadSafe;\n+\n+@NotThreadSafe\n+@RunWith(EnableOSGiRunner.class)\n+public class OSGiWebComponentConfigurationRegistryTest\n+        extends WebComponentConfigurationRegistryTest {\n+\n+    @Override\n+    protected WebComponentConfigurationRegistry createRegistry() {\n+        return new OSGiWebComponentConfigurationRegistry();\n+    }\n+\n+    @Test\n+    @Override\n+    public void assertRegistryIsSingleton() {\n+        Assert.assertSame(\n+                \"OSGiWebComponentConfigurationRegistry instance should be singleton\",\n+                registry,\n+                OSGiWebComponentConfigurationRegistry.getInstance(context));\n+    }\n+\n+    @After\n+    public void cleanUpOSGi() {\n+        OSGiAccess.getInstance().getOsgiServletContext().removeAttribute(\n+                WebComponentConfigurationRegistry.class.getName());\n+    }\n+\n+    @Override\n+    @Test\n+    public void assertWebComponentRegistry() {\n+        Assert.assertEquals(\n+                OSGiWebComponentConfigurationRegistry.class.getName(),\n+                registry.getClass().getName());\n+    }\n+\n+    @Override\n+    public void setConfigurationsTwice_onlyFirstSetIsAccepted() {\n+        // OSGi accepts setting the web components multiple times.\n+        // NO-OP\n+    }\n+\n+    @Override\n+    public void setConfigurations_getConfigurationsCallDoesNotChangeSetProtection() {\n+        // OSGi accepts setting the web components multiple times.\n+        // NO-OP\n+    }\n+\n+    @Test\n+    public void setBuildersTwice_allSetsAcceptedLastSetValid() {\n+        Assert.assertFalse(\"Registry should have no configurations\",\n+                registry.hasConfigurations());\n+\n+        Assert.assertTrue(\n+                \"Registry should have accepted the \" + \"WebComponentExporters\",\n+                registry.setConfigurations(\n+                        createConfigurations(MyComponentExporter.class)));\n+\n+        Assert.assertTrue(\n+                \"OSGi registry should have accept the second set of \"\n+                        + \"WebComponentExporters.\",\n+                registry.setConfigurations(\n+                        createConfigurations(UserBoxExporter.class)));\n+\n+        Assert.assertEquals(\"Registry should contain only one builder\", 1,\n+                registry.getConfigurations().size());\n+\n+        Assert.assertEquals(\"Builder should be linked to UserBox.class\",\n+                UserBox.class, registry.getConfiguration(\"user-box\").get()\n+                        .getComponentClass());\n+\n+        Assert.assertTrue(\"Registry should have configurations\",\n+                registry.hasConfigurations());\n+    }\n+\n+    @Override\n+    public void setSameRouteValueFromDifferentThreads_ConcurrencyTest()\n+            throws InterruptedException, ExecutionException {\n+        final int THREADS = 10;\n+\n+        ExecutorService executorService = Executors.newFixedThreadPool(THREADS);\n+\n+        List<Callable<AtomicBoolean>> callables = IntStream.range(0, THREADS)\n+                .mapToObj(i -> {\n+                    Callable<AtomicBoolean> callable = () -> {\n+                        // Add random sleep for better possibility to run at\n+                        // same time\n+                        Thread.sleep(new Random().nextInt(200));", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg1NQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572855", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:25Z", "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/DeprecatedPolymerPublishedEventHandler.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+\n+import com.vaadin.flow.component.Component;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Handler published event handler service for polymer templates.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ * @deprecated Polymer template support is deprecated - we recommend you to use\n+ *             {@code LitTemplate} instead. Read more details from <a href=\n+ *             \"https://vaadin.com/blog/future-of-html-templates-in-vaadin\">the\n+ *             Vaadin blog.</a>\n+ */\n+@Deprecated\n+public interface DeprecatedPolymerPublishedEventHandler extends Serializable {", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg3MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572871", "bodyText": "Remove this use of \"ModelType\"; it is deprecated. \n Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:26Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -33,56 +33,59 @@\n  *\n  * @since\n  */\n-public class PublishedEventRpcHandlerUtil implements Serializable {\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n \n     /**\n      * Validate that the given Component instance is a PolymerTemplate and that\n      * the value can be converted.\n      *\n      * @param instance\n-     *         Component to be validated\n+     *            Component to be validated\n      * @param argValue\n-     *         received value\n+     *            received value\n      * @param convertedType\n-     *         target type that value should be converted to\n+     *            target type that value should be converted to\n      * @return true if valid template model value\n      */\n-    public static boolean isTemplateModelValue(Component instance,\n-            JsonValue argValue, Class<?> convertedType) {\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n         return instance instanceof PolymerTemplate\n                 && argValue instanceof JsonObject\n                 && ((PolymerTemplate<?>) instance)\n-                .isSupportedClass(convertedType) && ((JsonObject) argValue)\n-                .hasKey(\"nodeId\");\n+                        .isSupportedClass(convertedType)\n+                && ((JsonObject) argValue).hasKey(\"nodeId\");\n     }\n \n     /**\n      * Get the template model object and type.\n      *\n      * @param template\n-     *         polymer template to get model from\n+     *            polymer template to get model from\n      * @param argValue\n-     *         argument value\n+     *            argument value\n      * @param convertedType\n-     *         value type\n+     *            value type\n      * @return the provided model value\n      * @throws IllegalStateException\n-     *         if the component is not attached to the UI\n-         */\n-        public static Object getTemplateItem(Component template,\n-                JsonObject argValue, Type convertedType) {\n-            final Optional<UI> ui = template.getUI();\n-            if (ui.isPresent()) {\n-                StateNode node = ui.get().getInternals().getStateTree()\n-                        .getNodeById((int) argValue.getNumber(\"nodeId\"));\n+     *             if the component is not attached to the UI\n+     */\n+    @Override\n+    public Object getTemplateItem(Component template, JsonObject argValue,\n+            Type convertedType) {\n+        final Optional<UI> ui = template.getUI();\n+        if (ui.isPresent()) {\n+            StateNode node = ui.get().getInternals().getStateTree()\n+                    .getNodeById((int) argValue.getNumber(\"nodeId\"));\n \n-                ModelType propertyType = ((PolymerTemplate<?>) template)\n-                        .getModelType(convertedType);\n+            ModelType propertyType = ((PolymerTemplate<?>) template)", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg3Nw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572877", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:27Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -33,56 +33,59 @@\n  *\n  * @since\n  */\n-public class PublishedEventRpcHandlerUtil implements Serializable {\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg4MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572881", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:27Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -33,56 +33,59 @@\n  *\n  * @since\n  */\n-public class PublishedEventRpcHandlerUtil implements Serializable {\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n \n     /**\n      * Validate that the given Component instance is a PolymerTemplate and that\n      * the value can be converted.\n      *\n      * @param instance\n-     *         Component to be validated\n+     *            Component to be validated\n      * @param argValue\n-     *         received value\n+     *            received value\n      * @param convertedType\n-     *         target type that value should be converted to\n+     *            target type that value should be converted to\n      * @return true if valid template model value\n      */\n-    public static boolean isTemplateModelValue(Component instance,\n-            JsonValue argValue, Class<?> convertedType) {\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n         return instance instanceof PolymerTemplate", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg4OQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572889", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:28Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -33,56 +33,59 @@\n  *\n  * @since\n  */\n-public class PublishedEventRpcHandlerUtil implements Serializable {\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n \n     /**\n      * Validate that the given Component instance is a PolymerTemplate and that\n      * the value can be converted.\n      *\n      * @param instance\n-     *         Component to be validated\n+     *            Component to be validated\n      * @param argValue\n-     *         received value\n+     *            received value\n      * @param convertedType\n-     *         target type that value should be converted to\n+     *            target type that value should be converted to\n      * @return true if valid template model value\n      */\n-    public static boolean isTemplateModelValue(Component instance,\n-            JsonValue argValue, Class<?> convertedType) {\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n         return instance instanceof PolymerTemplate\n                 && argValue instanceof JsonObject\n                 && ((PolymerTemplate<?>) instance)", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjg5OQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572899", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:30Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                assert ui\n+                        .isPresent() : \"Rpc handler may not be called for a component that is not attached\";\n+                VaadinContext context = ui.get().getSession().getService()\n+                        .getContext();\n+                DeprecatedPolymerPublishedEventHandler handler = context", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjkwOA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572908", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:31Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                assert ui\n+                        .isPresent() : \"Rpc handler may not be called for a component that is not attached\";\n+                VaadinContext context = ui.get().getSession().getService()\n+                        .getContext();\n+                DeprecatedPolymerPublishedEventHandler handler = context\n+                        .getAttribute(Lookup.class)\n+                        .lookup(DeprecatedPolymerPublishedEventHandler.class);", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjkyNQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572925", "bodyText": "A \"NullPointerException\" could be thrown; \"instance\" is nullable here.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:33Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -180,14 +182,16 @@ private static void invokeMethod(Component instance, Method method,\n                 Serializable returnValue = (Serializable) invokeMethod(instance,\n                         method, args);\n \n-                instance.getElement().executeJs(\"this.$server['\"\n+                instance.getElement()", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MjkzNw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572937", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:34Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -107,13 +110,12 @@ public String getRpcType() {\n             PolymerServerEventHandlers eventHandlers = node", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjk0NA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572944", "bodyText": "A \"NullPointerException\" could be thrown; \"instance\" is nullable here.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:34Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -180,14 +182,16 @@ private static void invokeMethod(Component instance, Method method,\n                 Serializable returnValue = (Serializable) invokeMethod(instance,\n                         method, args);\n \n-                instance.getElement().executeJs(\"this.$server['\"\n+                instance.getElement()\n+                        .executeJs(\"this.$server['\"\n                                 + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n-                                + \"']($0, true, $1)\", Integer.valueOf(promiseId),\n-                        returnValue);\n+                                + \"']($0, true, $1)\",\n+                                Integer.valueOf(promiseId), returnValue);\n             } catch (RuntimeException e) {\n-                instance.getElement().executeJs(\"this.$server['\"\n-                        + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n-                        + \"']($0, false)\", Integer.valueOf(promiseId));\n+                instance.getElement()", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3Mjk0Ng==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518572946", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-06T07:44:35Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -107,13 +110,12 @@ public String getRpcType() {\n             PolymerServerEventHandlers eventHandlers = node\n                     .getFeature(PolymerServerEventHandlers.class);", "originalCommit": "135613e7b9bbe1f14333dc2a628f34f36ccadd37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d7b5e5047094314e2aa2556ccfd303bcbc99cd20", "url": "https://github.com/vaadin/flow/commit/d7b5e5047094314e2aa2556ccfd303bcbc99cd20", "message": "fix: fix javadocs (SQ)", "committedDate": "2020-11-06T07:57:26Z", "type": "commit"}, {"oid": "e641cf127642e7b07a8952231cffca4563ea3a69", "url": "https://github.com/vaadin/flow/commit/e641cf127642e7b07a8952231cffca4563ea3a69", "message": "refactor: Remove OSGi related ITs and osgi module from the repo", "committedDate": "2020-11-06T10:41:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMzMwMQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r518733301", "bodyText": "You could a BundleContext as Parameter in the method. The ServiceComponentRuntime will inject it.", "author": "stbischof", "createdAt": "2020-11-06T12:55:27Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/OSGiPolymerPublishedEventHandlerRegistration.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+\n+/**\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@Component(immediate = true)\n+public class OSGiPolymerPublishedEventHandlerRegistration {\n+\n+    private ServiceRegistration<DeprecatedPolymerPublishedEventHandler> registration;\n+\n+    @Activate\n+    void activate() {", "originalCommit": "e641cf127642e7b07a8952231cffca4563ea3a69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU2OTQwOA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r519569408", "bodyText": "Thank you.\nI assumed that it should work this way but was too lazy to check that in the spec.", "author": "denis-anisimov", "createdAt": "2020-11-09T06:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMzMwMQ=="}], "type": "inlineReview"}, {"oid": "757c7ceca1a64c1fd52a53b3942acf40126a1d29", "url": "https://github.com/vaadin/flow/commit/757c7ceca1a64c1fd52a53b3942acf40126a1d29", "message": "fix: fix some review comments", "committedDate": "2020-11-09T06:09:57Z", "type": "commit"}, {"oid": "133af374d5295ab5b5f84fbea09ea40ae4f9406a", "url": "https://github.com/vaadin/flow/commit/133af374d5295ab5b5f84fbea09ea40ae4f9406a", "message": "fix: test unstable test", "committedDate": "2020-11-09T06:51:20Z", "type": "commit"}, {"oid": "101fca590d9016a7bcdf644ca07e2fd53bb85f7b", "url": "https://github.com/vaadin/flow/commit/101fca590d9016a7bcdf644ca07e2fd53bb85f7b", "message": "refactor: get rid of OSGiClientStaticResource (#9277)", "committedDate": "2020-11-09T06:55:56Z", "type": "commit"}, {"oid": "5e20bb7ec4f962ba4026afc170d4b2ca3603aa2c", "url": "https://github.com/vaadin/flow/commit/5e20bb7ec4f962ba4026afc170d4b2ca3603aa2c", "message": "fix: use content parameter in the activate method", "committedDate": "2020-11-09T07:29:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYyNDgwNA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r519624804", "bodyText": "Replace the synchronized class \"Hashtable\" by an unsynchronized one such as \"HashMap\".", "author": "vaadin-bot", "createdAt": "2020-11-09T08:22:00Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker.\n+     *\n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(\"osgi.http.whiteboard.servlet.pattern\",\n+                \"/VAADIN/static/push/*\");\n+        servletPushRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(pushBundle,\n+                                \"/META-INF/resources/VAADIN/static/push\"),\n+                        properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletPushRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletPushRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private void registerClientResources(Bundle clientBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();", "originalCommit": "5e20bb7ec4f962ba4026afc170d4b2ca3603aa2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d7e12e5ad7a8a2e1e115e4ec1af556e4b8ccc864", "url": "https://github.com/vaadin/flow/commit/d7e12e5ad7a8a2e1e115e4ec1af556e4b8ccc864", "message": "fix: Make OSGi incompatible vaadin-connect dependencies optional", "committedDate": "2020-11-09T13:19:43Z", "type": "commit"}, {"oid": "6a05fce3e6c9324fc6d6323eddb77ae092ff95cd", "url": "https://github.com/vaadin/flow/commit/6a05fce3e6c9324fc6d6323eddb77ae092ff95cd", "message": "fix: make Spring deps optional", "committedDate": "2020-11-10T10:15:34Z", "type": "commit"}, {"oid": "9bf7596fa66abe88daf7d1518a52d737ac52db0c", "url": "https://github.com/vaadin/flow/commit/9bf7596fa66abe88daf7d1518a52d737ac52db0c", "message": "fix: make a workaround for broken Route registry API", "committedDate": "2020-11-10T10:16:20Z", "type": "commit"}, {"oid": "9bf7596fa66abe88daf7d1518a52d737ac52db0c", "url": "https://github.com/vaadin/flow/commit/9bf7596fa66abe88daf7d1518a52d737ac52db0c", "message": "fix: make a workaround for broken Route registry API", "committedDate": "2020-11-10T10:16:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3NTQ0MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r520475441", "bodyText": "you could remove this class if you declare PolymerPublishedEventRpcHandler als component\n@Component(immidiate=true,service=PolymerPublishedEventRpcHandler.class)\npublic class PolymerPublishedEventRpcHandler", "author": "stbischof", "createdAt": "2020-11-10T11:01:47Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/OSGiPolymerPublishedEventHandlerRegistration.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+\n+/**\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@Component(immediate = true)\n+public class OSGiPolymerPublishedEventHandlerRegistration {\n+\n+    private ServiceRegistration<DeprecatedPolymerPublishedEventHandler> registration;\n+\n+    @Activate\n+    void activate(BundleContext context) {\n+        context.registerService(DeprecatedPolymerPublishedEventHandler.class,\n+                new PolymerPublishedEventRpcHandler(), null);", "originalCommit": "9bf7596fa66abe88daf7d1518a52d737ac52db0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDUxMjM2Ng==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r520512366", "bodyText": "Already explained here:\nhttps://github.com/vaadin/flow/pull/9321/files#r519569258", "author": "denis-anisimov", "createdAt": "2020-11-10T12:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3NTQ0MQ=="}], "type": "inlineReview"}, {"oid": "5be5d4107e7e3d9be89330043272665106ebd222", "url": "https://github.com/vaadin/flow/commit/5be5d4107e7e3d9be89330043272665106ebd222", "message": "fix: avoid not-breaking exception ojn loading class from another bundle", "committedDate": "2020-11-11T06:11:20Z", "type": "commit"}, {"oid": "f28e07ae8836a66c82f85d5a70851f9ab43de8be", "url": "https://github.com/vaadin/flow/commit/f28e07ae8836a66c82f85d5a70851f9ab43de8be", "message": "fix: workaround for possible bug in route registry (like #9360).", "committedDate": "2020-11-11T06:50:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE3NTgzOQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521175839", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-11T07:51:37Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),\n+                        data.getParentLayouts()), caught != null);\n+            }\n+            handleCaughtException(caught);\n+        }\n+\n+        private void setRoutes(List<RouteData> routes) {\n+            Exception caught = null;\n+            for (RouteData data : routes) {\n+                caught = modifyRoute(() -> setRoute(data.getUrl(),\n+                        data.getNavigationTarget(), data.getParentLayouts()),\n+                        caught != null);\n+                for (RouteAliasData alias : data.getRouteAliases()) {\n+                    caught = modifyRoute(() -> setRoute(alias.getUrl(),", "originalCommit": "f28e07ae8836a66c82f85d5a70851f9ab43de8be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE3NTg1NA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521175854", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-11T07:51:38Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),", "originalCommit": "f28e07ae8836a66c82f85d5a70851f9ab43de8be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE3NTg2Mg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521175862", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-11T07:51:39Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),\n+                        data.getParentLayouts()), caught != null);\n+            }\n+            handleCaughtException(caught);\n+        }\n+\n+        private void setRoutes(List<RouteData> routes) {\n+            Exception caught = null;\n+            for (RouteData data : routes) {\n+                caught = modifyRoute(() -> setRoute(data.getUrl(),", "originalCommit": "f28e07ae8836a66c82f85d5a70851f9ab43de8be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE3NTg2NA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521175864", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-11T07:51:40Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),", "originalCommit": "f28e07ae8836a66c82f85d5a70851f9ab43de8be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1df5b02cad7b5a9eaa84149ea8d702ed1f4a2a43", "url": "https://github.com/vaadin/flow/commit/1df5b02cad7b5a9eaa84149ea8d702ed1f4a2a43", "message": "[OSGi] - Cleanup BudleActivator and Service registration, Update bnd and osgi deps (#9361)\n\nrefactor: OSGi improvements \r\n\r\n* update bnd-version\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* update osgi dependency and version\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* fix mocking osgi-classes\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* OSGiResourceProvider uses @Component to declare the service\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* VaadinBundleTracker uses @Component to declare the service\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* Remove `empty` BundleActivator\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* use constants for osgi.http.whiteboard.servlet.pattern\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* fix unregister Service PolymerPublishedEventRpcHandler\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* registers PolymerPublishedEventRpcHandler as a declarative service\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>", "committedDate": "2020-11-11T10:04:17Z", "type": "commit"}, {"oid": "4d7d29a56b838a6222359f29972078fe71aefcbf", "url": "https://github.com/vaadin/flow/commit/4d7d29a56b838a6222359f29972078fe71aefcbf", "message": "fix: add explanation why OSGi Component annotation is safe to use", "committedDate": "2020-11-11T10:07:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMxMDIwNw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521310207", "bodyText": "Remove this call from a constructor to the overridable \"open\" method.", "author": "vaadin-bot", "createdAt": "2020-11-11T12:02:04Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating the bundle.\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker.\n+     * OSGi ServiceComponentRuntime injects the BundleContext because of the @Activate\n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+        open();", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIzNjg0Mg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521236842", "bodyText": "clear since as it's wrong for lit-template", "author": "caalador", "createdAt": "2020-11-11T09:45:55Z", "path": "flow-lit-template/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+\n+import org.mockito.Mockito;\n+\n+import com.vaadin.flow.di.Instantiator;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.function.DeploymentConfiguration;\n+import com.vaadin.flow.router.Router;\n+\n+/**\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.0", "originalCommit": "f28e07ae8836a66c82f85d5a70851f9ab43de8be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI1NDM1NQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521254355", "bodyText": "Faulty since tag.", "author": "caalador", "createdAt": "2020-11-11T10:15:55Z", "path": "flow-polymer-template/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+\n+import org.mockito.Mockito;\n+\n+import com.vaadin.flow.di.Instantiator;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.function.DeploymentConfiguration;\n+import com.vaadin.flow.router.Router;\n+\n+/**\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.0", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5NDg0OQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521294849", "bodyText": "This should throw or return if ui is not present. now If the case is that we don't have an attached Component the next line will NPE.", "author": "caalador", "createdAt": "2020-11-11T11:31:18Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                assert ui\n+                        .isPresent() : \"Rpc handler may not be called for a component that is not attached\";", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0NDExMw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522044113", "bodyText": "This code is designed to work only with StateNode  which are attached to the StateTree: RPC may not be executed for a Node which is not in the tree.\nSo I would say assertion should be enough since it just checks that the assumption correct.\nException should be thrown on a user mistake. Our internal mistake (or incorrect assumption) should be checked with assertions.\nBut I don't see a reason to have a strong position here on my side.\nLet's make it throwing.", "author": "denis-anisimov", "createdAt": "2020-11-12T11:42:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5NDg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5NzYzNA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521297634", "bodyText": "Non descriptive javadoc. This should name that it's a interface for injecting the polymer event handler when the module is available.", "author": "caalador", "createdAt": "2020-11-11T11:37:02Z", "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/DeprecatedPolymerPublishedEventHandler.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+\n+import com.vaadin.flow.component.Component;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Handler published event handler service for polymer templates.", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzA5Ng==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521347096", "bodyText": "Could we have this as a shorthand in BootstrapContext as getReourceProvider()", "author": "caalador", "createdAt": "2020-11-11T13:10:41Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "diffHunk": "@@ -832,20 +827,47 @@ private String getClientEngineUrl(BootstrapContext context) {\n             final boolean productionMode = context.getSession()\n                     .getConfiguration().isProductionMode();\n \n-            boolean resolveNow = !productionMode || getClientEngine() == null;\n+            ResourceProvider resourceProvider = context.getSession()\n+                    .getService().getContext().getAttribute(Lookup.class)\n+                    .lookup(ResourceProvider.class);", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0NjQxMw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522046413", "bodyText": "BootstrapContext is quite hidden internal class.\nAnd ResourceProvider is used only once in the code.\nSo any specific reason to declare a shorthand ?", "author": "denis-anisimov", "createdAt": "2020-11-12T11:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1MDQyOQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522050429", "bodyText": "Readability is the main issue.", "author": "caalador", "createdAt": "2020-11-12T11:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyNzE5OQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522127199", "bodyText": "Ah, you mean just private method.\nI thought public or protected  method for reuse.\nOK.", "author": "denis-anisimov", "createdAt": "2020-11-12T14:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0NDEwNQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521844105", "bodyText": "Please add javaDoc on the differences between the 2 context usages", "author": "caalador", "createdAt": "2020-11-12T05:14:17Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "diffHunk": "@@ -326,26 +337,45 @@ private static String getResourceFromFile(Properties initParameters)\n         return json;\n     }\n \n-    private static String getResourceFromClassloader() throws IOException {\n-        String json = null;\n-        // token file is in the class-path of the application\n+    private static String getTokenFileFromClassloader(Class<?> contextClass,", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521870967", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<URL> resources;\n          \n          \n            \n                    if (classResources.isEmpty()) {\n          \n          \n            \n                        resources = contextResources;\n          \n          \n            \n                    } else if (contextResources.isEmpty()) {\n          \n          \n            \n                        resources = classResources;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        resources = new ArrayList<>(\n          \n          \n            \n                                classResources.size() + contextResources.size());\n          \n          \n            \n                        resources.addAll(classResources);\n          \n          \n            \n                        resources.addAll(contextResources);\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    // Accept resource that doesn't contain\n          \n          \n            \n                    // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n          \n          \n            \n                    URL resource = resources.stream()\n          \n          \n            \n                            .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n          \n          \n            \n                            .findFirst().orElse(null);\n          \n          \n            \n                    Stream<URL> resourceStream = Stream.of(classResources, contextResources).flatMap(Collection::stream);\n          \n          \n            \n            \n          \n          \n            \n                    // Accept resource that doesn't contain\n          \n          \n            \n                    // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n          \n          \n            \n                    URL resource = resourceStream\n          \n          \n            \n                            .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n          \n          \n            \n                            .findFirst().orElse(null);", "author": "caalador", "createdAt": "2020-11-12T06:41:47Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java", "diffHunk": "@@ -326,26 +337,45 @@ private static String getResourceFromFile(Properties initParameters)\n         return json;\n     }\n \n-    private static String getResourceFromClassloader() throws IOException {\n-        String json = null;\n-        // token file is in the class-path of the application\n+    private static String getTokenFileFromClassloader(Class<?> contextClass,\n+            VaadinContext context) throws IOException {\n         String tokenResource = VAADIN_SERVLET_RESOURCES + TOKEN_FILE;\n-        List<URL> resources = Collections.list(DeploymentConfiguration.class\n-                .getClassLoader().getResources(tokenResource));\n+\n+        Lookup lookup = context.getAttribute(Lookup.class);\n+        ResourceProvider resourceProvider = lookup\n+                .lookup(ResourceProvider.class);\n+\n+        List<URL> classResources = resourceProvider\n+                .getApplicationResources(contextClass, tokenResource);\n+        List<URL> contextResources = resourceProvider\n+                .getApplicationResources(context, tokenResource);\n+\n+        List<URL> resources;\n+        if (classResources.isEmpty()) {\n+            resources = contextResources;\n+        } else if (contextResources.isEmpty()) {\n+            resources = classResources;\n+        } else {\n+            resources = new ArrayList<>(\n+                    classResources.size() + contextResources.size());\n+            resources.addAll(classResources);\n+            resources.addAll(contextResources);\n+        }\n+\n         // Accept resource that doesn't contain\n         // 'jar!/META-INF/Vaadin/config/flow-build-info.json'\n         URL resource = resources.stream()\n                 .filter(url -> !url.getPath().endsWith(\"jar!/\" + tokenResource))\n                 .findFirst().orElse(null);", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1NTU4Nw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522055587", "bodyText": "Doesn't work.\nBecause it fixes only URL resource = line.\nBut then below there is a check for resources.isEmpty() which may not be done with the same stream.\nIt might be this can be simplified but it's out of scope of this PR.", "author": "denis-anisimov", "createdAt": "2020-11-12T12:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA2MDM4MA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522060380", "bodyText": "But the stream of an empty list is a \"empty stream\" (e.g. no-op) so it makes streams of the 2 lists (that are never null) and gets the same end result as the if with the isEmpty checks and new list creation.", "author": "caalador", "createdAt": "2020-11-12T12:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMTU4OA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522131588", "bodyText": "I think I don't understand you.\nOne stream instance may be used once. Stream is not interchangeable with List anyhow.\nresourceStream.filter.... closes the stream in the end.\nWhich means that isEmpty  or in fact stream.count() may not be called anymore: stream is closed.\nThat's why the list is used : it's possible to call isEmpty regardless of any other list operations.\nPlease provide the whole code snippet for the method instead of change for the snippet above if you still see how this can be imprioved.", "author": "denis-anisimov", "createdAt": "2020-11-12T14:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY1NjExNw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522656117", "bodyText": "Right didn't see the reuse of the thing later on in the class. then I would just have it as\nCollection<URL> resources = Stream.of(classResources, contextResources).flatMap(Collection::stream).collect(Collectors.toList());", "author": "caalador", "createdAt": "2020-11-13T05:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY2NTk0Mg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522665942", "bodyText": "Done without flatMap.", "author": "denis-anisimov", "createdAt": "2020-11-13T05:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3MDk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NTY4NQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521875685", "bodyText": "Merge comments. These should be cleaned up.", "author": "caalador", "createdAt": "2020-11-12T06:55:34Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinServlet.java", "diffHunk": "@@ -429,8 +435,13 @@ private boolean ensureCookiesEnabled(VaadinServletRequest request,\n      *             if the application is denied access to the persistent data\n      *             store represented by the given URL.\n      *\n+     *             <<<<<<< HEAD =======\n+     * @deprecated As of 1.0. Will be removed in 3.0.\n+     *\n+     *             >>>>>>> 81a7e2d15a... Fix OSGi Lookup related issues", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NjA0Nw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521876047", "bodyText": "Also should be removed as we are now in 6.0 and this should have been removed in 3.0 if going by the comment", "author": "caalador", "createdAt": "2020-11-12T06:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1NjA2MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522056061", "bodyText": "Good point.", "author": "denis-anisimov", "createdAt": "2020-11-12T12:04:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NzY2OA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521877668", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (handler != null) {\n          \n          \n            \n                                if (handler.isTemplateModelValue(instance, argValue,\n          \n          \n            \n                                        convertedType)) {\n          \n          \n            \n                                    return handler.getTemplateItem(instance,\n          \n          \n            \n                                            (JsonObject) argValue,\n          \n          \n            \n                                            method.getGenericParameterTypes()[index]);\n          \n          \n            \n                                }\n          \n          \n            \n                            }\n          \n          \n            \n                            if (handler != null && handler.isTemplateModelValue(instance, argValue,\n          \n          \n            \n                                    convertedType)) {\n          \n          \n            \n                                return handler.getTemplateItem(instance,\n          \n          \n            \n                                        (JsonObject) argValue,\n          \n          \n            \n                                        method.getGenericParameterTypes()[index]);\n          \n          \n            \n                            }", "author": "caalador", "createdAt": "2020-11-12T07:01:13Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                assert ui\n+                        .isPresent() : \"Rpc handler may not be called for a component that is not attached\";\n+                VaadinContext context = ui.get().getSession().getService()\n+                        .getContext();\n+                DeprecatedPolymerPublishedEventHandler handler = context\n+                        .getAttribute(Lookup.class)\n+                        .lookup(DeprecatedPolymerPublishedEventHandler.class);\n+                if (handler != null) {\n+                    if (handler.isTemplateModelValue(instance, argValue,\n+                            convertedType)) {\n+                        return handler.getTemplateItem(instance,\n+                                (JsonObject) argValue,\n+                                method.getGenericParameterTypes()[index]);\n+                    }\n                 }", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3ODcxOQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521878719", "bodyText": "Empty return statement", "author": "caalador", "createdAt": "2020-11-12T07:04:21Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg4MjIyNA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521882224", "bodyText": "As we have a null resource we should return; here", "author": "caalador", "createdAt": "2020-11-12T07:13:44Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating the bundle.\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg4MjY5MA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521882690", "bodyText": "As we are marking it as not found here we should return;  here and not try to serve the (resourceDirPath + null)", "author": "caalador", "createdAt": "2020-11-12T07:14:54Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating the bundle.\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+@Component(immediate = true)\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521922652", "bodyText": "Could we have the classes as their own package protected classes instead of internal?\nAt a minimum document if they are default implementations that may be overridden/changed.", "author": "caalador", "createdAt": "2020-11-12T08:28:48Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    private static class LookupImpl implements Lookup {", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA2NjM2OQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522066369", "bodyText": "Similar question has been already answered in the original review of this code for 2.5 branch.\nLookupImpl : I may extract this class to its own file. But why ?\nThis class is instantiated here directly and there is no any single reason to override it because overridden class won't be ever instantiated.\nImplementation is done private explicitly. And this obviously says that this may not be overriden /changed.\nJust because it's impossible.\nAnd that's the reason why it's done private and nested.\nThe code is self-explanatory .\nLookup is an entry point for \"everything\". It exactly allows to override any service (if it's done properly).\nAnd this is the only thing which may not be overridden: because it give the way to override other things.\nOther classes are made private for same reasons and e.g. ResourceProviderImpl may not be done public because otherwise it will be collected by the LookupInitializer and there will be no any way to override it.\nShortly : this functionality is explicitly made non-overridable because it gives the way to override everything.", "author": "denis-anisimov", "createdAt": "2020-11-12T12:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA2ODM0Ng==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522068346", "bodyText": "So please add a javadoc with the information for both internal impl classes.", "author": "caalador", "createdAt": "2020-11-12T12:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMzIxNQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522133215", "bodyText": "Which kind of information?\nI don't understand . These are impl classes.\nThe contract (interfaces) are described in details in javadocs of interface.\nImpl classes just impl classes (one of impl).", "author": "denis-anisimov", "createdAt": "2020-11-12T14:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAyNTA4Mg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524025082", "bodyText": "Which kind of information?\n\nAnswer review questions in code.\n\nShortly : this functionality is explicitly made non-overridable because it gives the way to override everything.\n\nYes this is obvious to you as you've done this. It was not obvious for me or Mikael so we asked to document it.\nUnless you do that, it will not be obvious to anyone else outside this conversation either. So spending a little time on documenting the code with comments to save time in the future.", "author": "pleku", "createdAt": "2020-11-16T09:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwMDU1MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r524900551", "bodyText": "There is a reason why we are writing the code using Java.\nIt allows to write the code in typesafe way, clear contract and hide things which should not be exposed.\nAll these things may be done so that compiler may check this.\nWithout this JS may be used to write the code: it doesn't provide any safety.\nIt's possible to use 4 visibilities : public, protected , package local and private.\nIf something is defined as private then this is intentionally made non-extendable and intentionally hidden from everyone. And this is enforced by the compiler.\nLooks quite obvious. And the same obvious things are requested to be added as comment. That's why\nI really don't understand why.\nWe don't add any comment for a private field why it's private : it's obvious why it's private.\nHere the internal impl class implements interface which defines a contract and since it's private: it's an implementation details which explicitly is not exposed.\nSo it's absolutely obvious for me why the nested class is private and what it means.\nBut apparently I'm the only one for whom this is obvious.\nSo OK, let's add comment which nobody reads.", "author": "denis-anisimov", "createdAt": "2020-11-17T05:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyMjY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyNjkzOQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521926939", "bodyText": "Why don't we init it automatically anymore?", "author": "caalador", "createdAt": "2020-11-12T08:36:09Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java", "diffHunk": "@@ -39,24 +37,41 @@\n \n     private Router router;\n \n+    private ResourceProvider resourceProvider;\n+\n+    private static class MockVaadinServlet extends VaadinServlet {\n+\n+        private final DeploymentConfiguration configuration;\n+\n+        private VaadinServletService service;\n+\n+        private MockVaadinServlet(DeploymentConfiguration configuration) {\n+            this.configuration = configuration;\n+        }\n+\n+        @Override\n+        protected DeploymentConfiguration createDeploymentConfiguration()\n+                throws ServletException {\n+            return configuration;\n+        }\n+\n+        @Override\n+        protected VaadinServletService createServletService(\n+                DeploymentConfiguration deploymentConfiguration)\n+                throws ServiceException {\n+            return service;\n+        }\n+\n+    }\n+\n     public MockVaadinServletService() {\n         this(new MockDeploymentConfiguration());\n     }\n \n     public MockVaadinServletService(\n             DeploymentConfiguration deploymentConfiguration) {\n-        this(new VaadinServlet(), deploymentConfiguration);\n-    }\n-\n-    public MockVaadinServletService(VaadinServlet servlet,\n-            DeploymentConfiguration deploymentConfiguration) {\n-        super(servlet, deploymentConfiguration);\n-\n-        try {\n-            servlet.init(new MockServletConfig());\n-        } catch (ServletException e) {\n-            throw new RuntimeException(e);\n-        }\n+        super(new MockVaadinServlet(deploymentConfiguration),\n+                deploymentConfiguration);", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyMDU5Nw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522120597", "bodyText": "servlet.init is almost not needed in the tests.\nThat's why I've removed it.\nBut VaadinService::init is needed everywhere.\nSo yes, good point.", "author": "denis-anisimov", "createdAt": "2020-11-12T13:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkyNjkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzNDkyOA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521934928", "bodyText": "Can't we just mock the URL and return a new ByteArrayInputStream(statsJson.getBytes()) for mockURL.openStream().\nIt would be better to not do file handling if not explicitly necessary.", "author": "caalador", "createdAt": "2020-11-12T08:49:14Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java", "diffHunk": "@@ -1379,21 +1386,26 @@ public void getBootstrapPage_removesExportScript() throws ServiceException {\n \n     @Test // #7158\n     public void getBootstrapPage_assetChunksIsAnARRAY_bootstrapParsesOk()\n-            throws ServiceException {\n+            throws ServiceException, IOException {\n \n         initUI(testUI);\n \n-        ClassLoader classLoader = Mockito.mock(ClassLoader.class);\n-        service.setClassLoader(classLoader);\n-\n         String statsJson = \"{\\n\" + \" \\\"errors\\\": [],\\n\" + \" \\\"warnings\\\": [],\\n\"\n                 + \" \\\"assetsByChunkName\\\": {\\n\" + \"  \\\"bundle\\\": [\\n\"\n                 + \"    \\\"build/vaadin-bundle-e77008557c8d410bf0dc.cache.js\\\",\\n\"\n                 + \"    \\\"build/vaadin-bundle-e77008557c8d410bf0dc.cache.js.map\\\"\\n\"\n                 + \"  ],\\n\" + \" }\" + \"}\";\n \n-        Mockito.when(classLoader.getResourceAsStream(Mockito.anyString()))\n-                .thenReturn(new ByteArrayInputStream(statsJson.getBytes()));\n+        File tmpFile = tmpDir.newFile();", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA2OTA0MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522069041", "bodyText": "Can we mock final classes?\nI thought we can't.\nI will check.", "author": "denis-anisimov", "createdAt": "2020-11-12T12:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzNDkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MDY2NA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522070664", "bodyText": "final class may not be mocked.", "author": "denis-anisimov", "createdAt": "2020-11-12T12:30:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzNDkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NDU1MQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522074551", "bodyText": "Right so the other possibility would be to either have a WrapperUrl that is mocked or   mock(URLConnection.class);\ne.g. something like:\nfinal URLConnection mockUrlCon = mock(URLConnection.class);\n\nByteArrayInputStream is = new ByteArrayInputStream(\n        \"<myList></myList>\".getBytes(\"UTF-8\"));\ndoReturn(is).when(mockUrlCon).getInputStream();\n\nURLStreamHandler stubUrlHandler = new URLStreamHandler() {\n    @Override\n     protected URLConnection openConnection(URL u) throws IOException {\n        return mockUrlCon;\n     }            \n};\nURL url = new URL(\"foo\", \"bar\", 99, \"/foobar\", stubUrlHandler);\n\nWhich is in many ways worse... Lets go with the temp file.", "author": "caalador", "createdAt": "2020-11-12T12:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzNDkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk0NTgwMw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521945803", "bodyText": "Is the temp file necesary? We could just mock the URL and return an expected path.", "author": "caalador", "createdAt": "2020-11-12T09:06:33Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/DeploymentConfigurationFactoryTest.java", "diffHunk": "@@ -464,6 +474,69 @@ public void createInitParameters_readDevModeProperties() throws Exception {\n                 .getProperty(InitParameters.REQUIRE_HOME_NODE_EXECUTABLE));\n     }\n \n+    @Test\n+    public void createInitParameters_readTokenFileFromContext()\n+            throws VaadinConfigurationException, IOException {\n+        VaadinContext context = Mockito.mock(VaadinContext.class);\n+        VaadinConfig config = Mockito.mock(VaadinConfig.class);\n+\n+        ResourceProvider resourceProvider = mockResourceProvider(config,\n+                context);\n+\n+        DeploymentConfigurationFactory.createInitParameters(\n+                DeploymentConfigurationFactoryTest.class, config);\n+\n+        Mockito.verify(resourceProvider).getApplicationResources(\n+                DeploymentConfigurationFactoryTest.class,\n+                VAADIN_SERVLET_RESOURCES + TOKEN_FILE);\n+        Mockito.verify(resourceProvider).getApplicationResources(context,\n+                VAADIN_SERVLET_RESOURCES + TOKEN_FILE);\n+    }\n+\n+    @Test\n+    public void createInitParameters_checkWebpackGeneratedFromContext()\n+            throws VaadinConfigurationException, IOException {\n+        VaadinContext context = Mockito.mock(VaadinContext.class);\n+        VaadinConfig config = Mockito.mock(VaadinConfig.class);\n+\n+        ResourceProvider resourceProvider = mockResourceProvider(config,\n+                context);\n+\n+        String path = VAADIN_SERVLET_RESOURCES + TOKEN_FILE;\n+\n+        File tmpFile = temporaryFolder.newFile();", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MDcyMQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522070721", "bodyText": "final class may not be mocked.", "author": "denis-anisimov", "createdAt": "2020-11-12T12:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk0NTgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk1ODcyMg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521958722", "bodyText": "Drop un-used rule and imports", "author": "caalador", "createdAt": "2020-11-12T09:26:06Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/WebComponentBootstrapHandlerTest.java", "diffHunk": "@@ -41,13 +51,14 @@\n import com.vaadin.flow.server.VaadinServletService;\n import com.vaadin.flow.server.VaadinSession;\n import com.vaadin.flow.server.webcomponent.WebComponentConfigurationRegistry;\n+import com.vaadin.flow.shared.ApplicationConstants;\n import com.vaadin.tests.util.MockDeploymentConfiguration;\n \n-import static org.mockito.Matchers.any;\n-import static org.mockito.Matchers.eq;\n-\n public class WebComponentBootstrapHandlerTest {\n \n+    @Rule\n+    public final TemporaryFolder tmpDir = new TemporaryFolder();", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk2MTA0Nw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521961047", "bodyText": "This should also be mockable to not need to have the temporary file by returning a mock url that for openStream() returns the stream.", "author": "caalador", "createdAt": "2020-11-12T09:29:35Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java", "diffHunk": "@@ -264,31 +273,89 @@ public void commandToString_commandContainsBaseDir_baseDirIsReplaced() {\n                 wrappedCommand);\n     }\n \n-    private VaadinService setupStatsAssetMocks(String statsFile)\n+    @Test\n+    public void getStatsContent_getStatsFromClassPath_delegateToGetApplicationResource()\n             throws IOException {\n-        String stats = IOUtils.toString(FrontendUtilsTest.class.getClassLoader()\n-                .getResourceAsStream(statsFile), StandardCharsets.UTF_8);\n+        VaadinService service = Mockito.mock(VaadinService.class);\n \n-        return getServiceWithResource(\n-                new ByteArrayInputStream(stats.getBytes()));\n+        ResourceProvider provider = mockResourceProvider(service);\n+\n+        FrontendUtils.getStatsContent(service);\n+\n+        Mockito.verify(provider).getApplicationResource(service, \"foo\");\n     }\n \n-    private VaadinService getServiceWithResource(InputStream stats) {\n+    @Test\n+    public void getStatsAssetsByChunkName_getStatsFromClassPath_delegateToGetApplicationResource()\n+            throws IOException {\n         VaadinService service = Mockito.mock(VaadinService.class);\n-        ClassLoader classLoader = Mockito.mock(ClassLoader.class);\n-        DeploymentConfiguration deploymentConfiguration = Mockito\n+\n+        ResourceProvider provider = mockResourceProvider(service);\n+\n+        FrontendUtils.getStatsAssetsByChunkName(service);\n+\n+        Mockito.verify(provider).getApplicationResource(service, \"foo\");\n+    }\n+\n+    private ResourceProvider mockResourceProvider(VaadinService service) {\n+        DeploymentConfiguration config = Mockito\n                 .mock(DeploymentConfiguration.class);\n \n-        Mockito.when(service.getClassLoader()).thenReturn(classLoader);\n-        Mockito.when(service.getDeploymentConfiguration())\n-                .thenReturn(deploymentConfiguration);\n-        Mockito.when(deploymentConfiguration.getStringProperty(\n-                SERVLET_PARAMETER_STATISTICS_JSON,\n-                VAADIN_SERVLET_RESOURCES + STATISTICS_JSON_DEFAULT))\n-                .thenReturn(VAADIN_SERVLET_RESOURCES + STATISTICS_JSON_DEFAULT);\n-        Mockito.when(classLoader.getResourceAsStream(\n+        VaadinContext context = Mockito.mock(VaadinContext.class);\n+        Lookup lookup = Mockito.mock(Lookup.class);\n+        Mockito.when(context.getAttribute(Lookup.class)).thenReturn(lookup);\n+\n+        ResourceProvider provider = Mockito.mock(ResourceProvider.class);\n+        Mockito.when(lookup.lookup(ResourceProvider.class))\n+                .thenReturn(provider);\n+\n+        Mockito.when(service.getDeploymentConfiguration()).thenReturn(config);\n+        Mockito.when(service.getContext()).thenReturn(context);\n+\n+        Mockito.when(config.isProductionMode()).thenReturn(true);\n+\n+        Mockito.when(config.getStringProperty(SERVLET_PARAMETER_STATISTICS_JSON,\n                 VAADIN_SERVLET_RESOURCES + STATISTICS_JSON_DEFAULT))\n-                .thenReturn(stats);\n+                .thenReturn(\"foo\");\n+        return provider;\n+    }\n+\n+    private VaadinService setupStatsAssetMocks(String statsFile)\n+            throws IOException, ServiceException {\n+        String stats = IOUtils.toString(FrontendUtilsTest.class.getClassLoader()\n+                .getResourceAsStream(statsFile), StandardCharsets.UTF_8);\n+\n+        return getServiceWithResource(stats);\n+    }\n+\n+    private VaadinService getServiceWithResource(String content)\n+            throws ServiceException, IOException {\n+        MockDeploymentConfiguration configuration = new MockDeploymentConfiguration();\n+        configuration.setProductionMode(true);\n+        VaadinService service = new MockVaadinServletService(configuration);\n+        service.init();\n+\n+        VaadinContext context = service.getContext();\n+\n+        Lookup lookup = Mockito.mock(Lookup.class);\n+        context.setAttribute(Lookup.class, lookup);\n+\n+        ResourceProvider provider = Mockito.mock(ResourceProvider.class);\n+\n+        Mockito.when(lookup.lookup(ResourceProvider.class))\n+                .thenReturn(provider);\n+\n+        if (content != null) {\n+            File tmpFile = tmpDir.newFile();", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MDkyMw==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522070923", "bodyText": "final class may not be mocked.", "author": "denis-anisimov", "createdAt": "2020-11-12T12:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk2MTA0Nw=="}], "type": "inlineReview"}, {"oid": "cb8fd24b04e8294e95b16d5648f6652b75e35c15", "url": "https://github.com/vaadin/flow/commit/cb8fd24b04e8294e95b16d5648f6652b75e35c15", "message": "fix: code review fixes", "committedDate": "2020-11-12T12:33:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzMjQzOA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r521932438", "bodyText": "Does this class exist by magic or ?", "author": "pleku", "createdAt": "2020-11-12T08:45:16Z", "path": "flow-polymer-template/src/test/java/com/vaadin/flow/component/PolymerClassesSerializableTest.java", "diffHunk": "@@ -18,7 +18,8 @@\n                 \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.TemplateParser(\\\\$.*)?\",\n                 \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.InjectablePolymerElementInitializer\",\n                 \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.TemplateDataAnalyzer\",\n-                \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.IdCollector\"),\n+                \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.IdCollector\",\n+                \"com\\\\.vaadin\\\\.flow\\\\.component\\\\.polymertemplate\\\\.rpc\\\\.OSGiPolymerPublishedEventHandlerRegistration\"),", "originalCommit": "4d7d29a56b838a6222359f29972078fe71aefcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyMjQxNg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522122416", "bodyText": "This class has been removed at some point.\nSo now it's not needed.\nJust a leftover, thanks.", "author": "denis-anisimov", "createdAt": "2020-11-12T13:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzMjQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NTUwNA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522075504", "bodyText": "This is also broken, javax. should be at the top", "author": "pleku", "createdAt": "2020-11-12T12:39:39Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -48,12 +47,18 @@\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n \n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.http.HttpServletResponse;", "originalCommit": "cb8fd24b04e8294e95b16d5648f6652b75e35c15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyNTE0MA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522125140", "bodyText": "I had no flow.importorder  imported in my Eclipse apparently.\nDone.", "author": "denis-anisimov", "createdAt": "2020-11-12T13:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NTUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NTU4NQ==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522075585", "bodyText": "Your import ordering is broken ?\nStatic imports should be last https://sites.google.com/a/vaadin.com/fw-flow-team-s-wiki/contributing-code/code-style/e", "author": "pleku", "createdAt": "2020-11-12T12:39:48Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -16,9 +16,7 @@\n \n package com.vaadin.flow.server;\n \n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.http.HttpServletResponse;\n+import static java.nio.charset.StandardCharsets.UTF_8;", "originalCommit": "cb8fd24b04e8294e95b16d5648f6652b75e35c15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "77279d84c5e39add329ff983c11366cc7694c5fd", "url": "https://github.com/vaadin/flow/commit/77279d84c5e39add329ff983c11366cc7694c5fd", "message": "fix: return back accidentially removed method and call init for service", "committedDate": "2020-11-12T13:54:08Z", "type": "commit"}, {"oid": "e0d263dd47aa950fd63f785ba8898cad0987d709", "url": "https://github.com/vaadin/flow/commit/e0d263dd47aa950fd63f785ba8898cad0987d709", "message": "fix: remove non-existent class pattern from test", "committedDate": "2020-11-12T13:56:07Z", "type": "commit"}, {"oid": "2bfeb410e3e2bca39ef9f0abcb7e942f2459b2f2", "url": "https://github.com/vaadin/flow/commit/2bfeb410e3e2bca39ef9f0abcb7e942f2459b2f2", "message": "fix: fix import order", "committedDate": "2020-11-12T13:59:54Z", "type": "commit"}, {"oid": "fe88b7ecde1311d8baecc2cf436dd6f4143df02b", "url": "https://github.com/vaadin/flow/commit/fe88b7ecde1311d8baecc2cf436dd6f4143df02b", "message": "fix: extract code to a separate method", "committedDate": "2020-11-12T14:02:29Z", "type": "commit"}, {"oid": "7a7e97763bf20ab2c6584edf964682e9092216af", "url": "https://github.com/vaadin/flow/commit/7a7e97763bf20ab2c6584edf964682e9092216af", "message": "fix: correct unit test", "committedDate": "2020-11-12T14:35:47Z", "type": "commit"}, {"oid": "d7db8d9fcee30b78fd710395d70181eaea0ff09b", "url": "https://github.com/vaadin/flow/commit/d7db8d9fcee30b78fd710395d70181eaea0ff09b", "message": "fix: fix unit test", "committedDate": "2020-11-12T16:00:18Z", "type": "commit"}, {"oid": "f41e3c7c557b504243a21e480c50c046d5693ee5", "url": "https://github.com/vaadin/flow/commit/f41e3c7c557b504243a21e480c50c046d5693ee5", "message": "refactor: simplify list merging", "committedDate": "2020-11-13T05:35:33Z", "type": "commit"}, {"oid": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98", "url": "https://github.com/vaadin/flow/commit/6d142d5f89a5f6be8fe851c0841fa8cb08327f98", "message": "fix: return back lost code after review", "committedDate": "2020-11-13T06:00:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3MjU3MA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522672570", "bodyText": "This still doesn't have the fixed imports after Pekkas comment", "author": "caalador", "createdAt": "2020-11-13T06:04:25Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java", "diffHunk": "@@ -15,42 +15,47 @@\n  */\n package com.vaadin.flow.server;", "originalCommit": "f41e3c7c557b504243a21e480c50c046d5693ee5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3MzMyOA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522673328", "bodyText": "The private static class TestServlet can be removed as it's not used anymore.", "author": "caalador", "createdAt": "2020-11-13T06:07:30Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/VaadinSessionTest.java", "diffHunk": "@@ -93,18 +88,15 @@ public Router getRouter() {\n                     return Mockito.mock(Router.class);\n                 }\n             };\n-            service.init();\n             return service;\n         }\n     }\n \n     @Before\n     public void setup() throws Exception {\n         httpSessionLock = new ReentrantLock();\n-        mockServletConfig = new MockServletConfig();\n-        mockServlet = new TestServlet();", "originalCommit": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3MzQ0Ng==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522673446", "bodyText": "Imports", "author": "caalador", "createdAt": "2020-11-13T06:08:05Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/StreamReceiverHandlerTest.java", "diffHunk": "@@ -1,11 +1,9 @@\n package com.vaadin.flow.server.communication;\n ", "originalCommit": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3MzUyNg==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522673526", "bodyText": "import position", "author": "caalador", "createdAt": "2020-11-13T06:08:27Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/StreamRequestHandlerTest.java", "diffHunk": "@@ -1,13 +1,14 @@\n package com.vaadin.flow.server.communication;\n \n-import javax.servlet.ServletConfig;\n+import static com.vaadin.flow.server.communication.StreamRequestHandler.DYN_RES_PREFIX;", "originalCommit": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3MzcxOA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522673718", "bodyText": "import position", "author": "caalador", "createdAt": "2020-11-13T06:09:14Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/communication/WebComponentBootstrapHandlerTest.java", "diffHunk": "@@ -15,6 +15,12 @@\n  */\n package com.vaadin.flow.server.communication;\n \n+import static com.vaadin.flow.server.Constants.STATISTICS_JSON_DEFAULT;\n+import static com.vaadin.flow.server.Constants.VAADIN_SERVLET_RESOURCES;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;", "originalCommit": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY3Mzc4OA==", "url": "https://github.com/vaadin/flow/pull/9321#discussion_r522673788", "bodyText": "import position", "author": "caalador", "createdAt": "2020-11-13T06:09:29Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java", "diffHunk": "@@ -15,11 +15,16 @@\n  */\n package com.vaadin.flow.server.frontend;\n \n-import java.io.ByteArrayInputStream;\n+import static com.vaadin.flow.server.Constants.STATISTICS_JSON_DEFAULT;\n+import static com.vaadin.flow.server.Constants.VAADIN_SERVLET_RESOURCES;\n+import static com.vaadin.flow.server.InitParameters.SERVLET_PARAMETER_STATISTICS_JSON;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;", "originalCommit": "6d142d5f89a5f6be8fe851c0841fa8cb08327f98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "442ad42b4470fe7f28f34e70977830cbff288181", "url": "https://github.com/vaadin/flow/commit/442ad42b4470fe7f28f34e70977830cbff288181", "message": "fix: imports order", "committedDate": "2020-11-13T06:16:39Z", "type": "commit"}]}