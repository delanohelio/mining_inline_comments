{"pr_number": 501, "pr_title": "SSLEngine - Handle Large wrap/unwrap Calls", "pr_createdAt": "2020-04-21T18:16:54Z", "pr_url": "https://github.com/dogtagpki/jss/pull/501", "timeline": [{"oid": "57d8bfbe4051616f19a150bc9112e98fad7fcb1b", "url": "https://github.com/dogtagpki/jss/commit/57d8bfbe4051616f19a150bc9112e98fad7fcb1b", "message": "Allow JSSEngine.wrap/unwrap of large buffers\n\nBecause JSSEngine wraps the native NSS, there are two places data can be\nbuffered:\n\n - Within JSSEngine's internal buffers,\n - Within NSS's internal buffers.\n\nWhen the handshake has completed, we need to ensure we always drain as\nmuch data as possible from these buffers into wrap/unwrap. This requires\nus to invoke multiple calls to PR.Read and PR.Write, until they\neventually return EWOULDBLOCK or 0 data written.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-21T20:06:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NjY5NA==", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r412466694", "bodyText": "This isn't actually correct.", "author": "cipherboy", "createdAt": "2020-04-21T20:24:58Z", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -790,58 +777,63 @@ public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int\n         // case no data would be written to dsts. Lastly, even if no new data\n         // from srcs, could still have residual data in read_buf, so we should\n         // attempt to read from the ssl_fd.\n+        //\n+        // In order to handle large buffer sizes, wrap everything in a\n+        // do-while loop.\n \n-        // When we have data from src, write it to read_buf.\n-        if (wire_data > 0) {\n-            byte[] wire_buffer = new byte[wire_data];\n-            src.get(wire_buffer);\n-            int written = (int) Buffer.Write(read_buf, wire_buffer);\n+        // wire_data is the number of bytes from src we've written into\n+        // read_buf. This is bounded above by src.capcity but also the\n+        // free space left in read_buf to write to. Allows us to size the", "originalCommit": "a6a918f6a12dc7de43cc1e4f757ae7e83b23a725", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b128cfc14641f5bb63405439ef004701c5b55a25", "url": "https://github.com/dogtagpki/jss/commit/b128cfc14641f5bb63405439ef004701c5b55a25", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-21T20:38:10Z", "type": "forcePushed"}, {"oid": "20dc7decddd34dba3a288bc9c3451ad36ff8616a", "url": "https://github.com/dogtagpki/jss/commit/20dc7decddd34dba3a288bc9c3451ad36ff8616a", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-21T20:41:35Z", "type": "forcePushed"}, {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833", "url": "https://github.com/dogtagpki/jss/commit/6b9047b361886bdbaa0806c4107c01bf1d3b3833", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same size, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-21T20:43:48Z", "type": "forcePushed"}, {"oid": "30b0d7de968b513205614014a4e4b9e4a8d5dc4f", "url": "https://github.com/dogtagpki/jss/commit/30b0d7de968b513205614014a4e4b9e4a8d5dc4f", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same size, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-22T13:23:52Z", "type": "forcePushed"}, {"oid": "b42e20a46991282db885a1ec209725dce0e6938e", "url": "https://github.com/dogtagpki/jss/commit/b42e20a46991282db885a1ec209725dce0e6938e", "message": "Handle PR.Writes of smaller sizes in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T17:34:04Z", "type": "forcePushed"}, {"oid": "90742c49a66b515cd8d046fb7cd81fb42dfa6332", "url": "https://github.com/dogtagpki/jss/commit/90742c49a66b515cd8d046fb7cd81fb42dfa6332", "message": "Handle PR.Writes of smaller sizes in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMjMyNQ==", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r414122325", "bodyText": "@edewata Can you think of anything more elegant for this? Or is adding a boolean flag and tracking it fine? Maybe I should split it into a updateHandshakePre() and a updateHandshakeState()? -- Pre only getting called once and State getting called only when actually handshaking? Hmm...", "author": "cipherboy", "createdAt": "2020-04-23T21:03:37Z", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -50,6 +50,7 @@\n \n     private int unknown_state_count;\n     private boolean step_handshake;\n+    private boolean returned_finished;", "originalCommit": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MTYxMA==", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r414791610", "bodyText": "I don't really have an opinion on this. If it works then let's keep it :)\nWe can always refactor later if we find a better way.\nI've ACKed this PR, feel free to merge, but I'd prefer @jmagne to take a look at this as well, either before or after merging.", "author": "edewata", "createdAt": "2020-04-24T18:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMjMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI2OTE3NQ==", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r416269175", "bodyText": "I\"m assuming that this_src_write and ths_dst_write will eventually become exactly zero?", "author": "jmagne", "createdAt": "2020-04-28T01:53:03Z", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -811,58 +817,68 @@ public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int\n         // case no data would be written to dsts. Lastly, even if no new data\n         // from srcs, could still have residual data in read_buf, so we should\n         // attempt to read from the ssl_fd.\n+        //\n+        // In order to handle large buffer sizes, wrap everything in a\n+        // do-while loop.\n \n-        // When we have data from src, write it to read_buf.\n-        if (wire_data > 0) {\n-            byte[] wire_buffer = new byte[wire_data];\n-            src.get(wire_buffer);\n-            int written = (int) Buffer.Write(read_buf, wire_buffer);\n+        // wire_data is the number of bytes from src we've written into\n+        // read_buf.\n+        int wire_data = 0;\n \n-            // For safety: ensure everything we thought we could write was\n-            // actually written. Otherwise, we've done something wrong.\n-            wire_data = Math.min(wire_data, written);\n+        // Actual amount of data written to the buffer.\n+        int app_data = 0;\n \n-            // TODO: Determine if we should write the trail of wire_buffer\n-            // back to the front of src... Seems like unnecessary work.\n-            debug(\"JSSEngine.unwrap(): Wrote \" + wire_data + \" bytes to read_buf.\");\n-        }\n+        int this_src_write;\n+        int this_dst_write;\n \n-        // In the above, we should always try to read and write data. Check to\n-        // see if we need to step our handshake process or not.\n-        updateHandshakeState();\n+        do {\n+            this_src_write = 0;\n+            this_dst_write = 0;\n \n-        // Actual amount of data written to the buffer.\n-        int app_data = 0;\n+            if (src != null) {\n+                this_src_write = Math.min((int) Buffer.WriteCapacity(read_buf), src.remaining());\n+\n+                // When we have data from src, write it to read_buf.\n+                if (this_src_write > 0) {\n+                    byte[] wire_buffer = new byte[this_src_write];\n+                    src.get(wire_buffer);\n \n-        // Maximum theoretical amount of data we could've written to the\n-        // destination. This is bounded by the lower of both the size of\n-        // our dsts and the maximum BUFFER_SIZE. Worst case, we'll be forced\n-        // to call unwrap(...) multiple times.\n-        int max_app_data = Math.min(computeSize(dsts, offset, length), BUFFER_SIZE);\n-\n-        // When we have app data to write over the network, go ahead and do\n-        // so. This involves reading from ssl_fd and writing to dsts. We don't\n-        // currently have a good proxy metric for \"can read from a ssl_fd\",\n-        // so always attempt it. In particular, even if the handshake isn't\n-        // finished, we still need to call PR.Read(...) or PR.Write(...) in\n-        // order to tell if an inbound alert was received.\n-        if (max_app_data > 0) {\n-            byte[] app_buffer = PR.Read(ssl_fd, max_app_data);\n-            debug(\"JSSEngine.unwrap() - \" + app_buffer + \" error=\" + errorText(PR.GetError()));\n+                    this_src_write = (int) Buffer.Write(read_buf, wire_buffer);\n+\n+                    wire_data += this_src_write;\n+                    debug(\"JSSEngine.unwrap(): Wrote \" + this_src_write + \" bytes to read_buf.\");\n+                }\n+            }\n+\n+            // In the above, we should always try to read and write data. Check to\n+            // see if we need to step our handshake process or not.\n+            updateHandshakeState();\n+\n+            int max_dst_size = computeSize(dsts, offset, length);\n+            byte[] app_buffer = PR.Read(ssl_fd, max_dst_size);\n+            int error = PR.GetError();\n+            debug(\"JSSEngine.unwrap() - \" + app_buffer + \" error=\" + errorText(error));\n             if (app_buffer != null) {\n-                app_data = putData(app_buffer, dsts, offset, length);\n-            } else {\n-                int error = PR.GetError();\n-                if (error != 0 && error != PRErrors.WOULD_BLOCK_ERROR) {\n+                this_dst_write = putData(app_buffer, dsts, offset, length);\n+                app_data += this_dst_write;\n+            } else if (max_dst_size > 0) {\n+                // There are two scenarios we need to ignore here:\n+                //  1. WOULD_BLOCK_ERRORs are safe, because we're expecting\n+                //     not to block. Usually this means we don't have space\n+                //     to write any more data.\n+                //  2. SOCKET_SHUTDOWN_ERRORs are safe, because if the\n+                //     underling cause was fatal, we'd catch it after exiting\n+                //     the do-while loop, in checkSSLAlerts().\n+                if (error != 0 && error != PRErrors.WOULD_BLOCK_ERROR && error != PRErrors.SOCKET_SHUTDOWN_ERROR) {\n                     ssl_exception = new SSLException(\"Unexpected return from PR.Read(): \" + errorText(error));\n                     seen_exception = true;\n                 }\n             }\n+        } while (this_src_write != 0 || this_dst_write != 0);", "originalCommit": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwMTE2NA==", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r416301164", "bodyText": "Yeah, I need to update the docs pr (#428) with this. But the theory is this: Let's take wrap as an example. We need to take data from src and put it into dst if the handshake has finished. Otherwise if we're still handshaking we need to take whatever handshake data is made and puts it into dst.\nSo let's take the handshaking scenario:\n\nWe'll be ignoring src because PR.Write(...) will fail until the handshake is complete.\nSo UpdateHandshakeState() will write data into the write buffer.\nWe'll drain data from the read buffer and write it into dst.\n\nDuring this:\n\nthis_src_write will be 0 because PR.Write(...) returns 0 / PR_WOULD_BLOCK until handshake completes.\nWhile we're still handshaking in this step, UpdateHandshakeState() will write into the read buffer, which then goes into dst, incrementing this_dst_write.\nWhen we run out of handshake data to write, UpdateHandshakeState() will quit writing data (and return PR_WOULD_BLOCK) and this_dst_write will go to data as the write buffer will be empty.\n\n\nA similar thing applies when src is non-empty and we're not handshaking:\n\nWe'll be writing from src into the SSL PRFileDesc *. PR.Write(...) returns number of bytes written which ends up into this_src_write. As long as we're still writing data (and not getting an error / PR_WOULD_BLOCK), this'll be non-zero. It'll also continue being non-zero while there's space in the write buffer. However, this write buffer gets cleared out by the last step...\nUpdateHandshakeState() will return, a no-op because we're not handshaking.\nWhen there's src data and PR.Write() succeeds, there'll be data in the write buffer so we'll be able to put it in dst and this_dst_write will be non-zero. Otherwise, if src fails, this_src_write becomes 0 and there'll be nothing in the write buffer so this_dst_write will go to 0 as well.\n\n\nIn all helper methods, we guarantee that on error, 0 is returned instead of a less than zero value.\n\nIn both cases, when we run out of handshake and/or src data, we'll quit writing to the write buffer and this_dst_write will eventually go to 0 as well.", "author": "cipherboy", "createdAt": "2020-04-28T03:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI2OTE3NQ=="}], "type": "inlineReview"}, {"oid": "ec4e28037301850c0f85dd7ef9fd78b83b4b4d17", "url": "https://github.com/dogtagpki/jss/commit/ec4e28037301850c0f85dd7ef9fd78b83b4b4d17", "message": "Add test case for large wrap/unwrap\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-29T18:56:07Z", "type": "commit"}, {"oid": "74b49b4988d61f6d815f3db6a950f4ea93025104", "url": "https://github.com/dogtagpki/jss/commit/74b49b4988d61f6d815f3db6a950f4ea93025104", "message": "Allow dummy PR.Write with NULL buffer\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-29T18:56:07Z", "type": "commit"}, {"oid": "8fbf48001b08635416c63576d2cb287466bca342", "url": "https://github.com/dogtagpki/jss/commit/8fbf48001b08635416c63576d2cb287466bca342", "message": "Allow JSSEngine.wrap/unwrap of large buffers\n\nBecause JSSEngine wraps the native NSS, there are two places data can be\nbuffered:\n\n - Within JSSEngine's internal buffers,\n - Within NSS's internal buffers.\n\nWhen the handshake has completed, we need to ensure we always drain as\nmuch data as possible from these buffers into wrap/unwrap. This requires\nus to invoke multiple calls to PR.Read and PR.Write, until they\neventually return EWOULDBLOCK or 0 data written.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-29T18:56:07Z", "type": "commit"}, {"oid": "d011a6b781cf2caa6c8d170e13686dfffbb79c89", "url": "https://github.com/dogtagpki/jss/commit/d011a6b781cf2caa6c8d170e13686dfffbb79c89", "message": "Gate socket logging behind debug flag\n\nThis debug logging is broken for large messages because it timesout\ntrying to write data. Disable it by default unless explicitly recompiled\nwith support in the test suite.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-29T19:00:03Z", "type": "commit"}, {"oid": "10bb963bd26efe00a20bb06307a4cc7545929e79", "url": "https://github.com/dogtagpki/jss/commit/10bb963bd26efe00a20bb06307a4cc7545929e79", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same size, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-29T19:00:03Z", "type": "commit"}, {"oid": "a0f96bc35c22c22fc95d54779a2a746984e1122b", "url": "https://github.com/dogtagpki/jss/commit/a0f96bc35c22c22fc95d54779a2a746984e1122b", "message": "Handle PR.Writes of smaller sizes in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-29T19:00:03Z", "type": "commit"}, {"oid": "2509b454f0dcce7e77124916d03471ace0194426", "url": "https://github.com/dogtagpki/jss/commit/2509b454f0dcce7e77124916d03471ace0194426", "message": "Return FINISHED status from JSSEngine.{un,}wrap\n\nWhen handling large messages, updateHandshakeState() gets called\nmultiple times during handshaking. If the handshake becomes FINISHED\nand data gets written to a buffer, we'll call updateHandshakeState()\nagain, resulting in it immediately moving to NOT_HANDSHAKING. Because\nclients expect a FINISHED message before NOT_HANDSHAKING, only step\nfurther after FINISHED has been returned from either wrap or unwrap.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-29T19:00:03Z", "type": "commit"}, {"oid": "2509b454f0dcce7e77124916d03471ace0194426", "url": "https://github.com/dogtagpki/jss/commit/2509b454f0dcce7e77124916d03471ace0194426", "message": "Return FINISHED status from JSSEngine.{un,}wrap\n\nWhen handling large messages, updateHandshakeState() gets called\nmultiple times during handshaking. If the handshake becomes FINISHED\nand data gets written to a buffer, we'll call updateHandshakeState()\nagain, resulting in it immediately moving to NOT_HANDSHAKING. Because\nclients expect a FINISHED message before NOT_HANDSHAKING, only step\nfurther after FINISHED has been returned from either wrap or unwrap.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-29T19:00:03Z", "type": "forcePushed"}]}