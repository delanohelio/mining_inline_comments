{"pr_number": 1251, "pr_title": "Backend JWT token generation support within microgateway (updated)", "pr_createdAt": "2020-05-30T05:48:20Z", "pr_url": "https://github.com/wso2/product-microgateway/pull/1251", "timeline": [{"oid": "88c5bee29d8261a9697fa01c4708179fae777758", "url": "https://github.com/wso2/product-microgateway/commit/88c5bee29d8261a9697fa01c4708179fae777758", "message": "added backend jwt token generation", "committedDate": "2020-05-29T08:14:52Z", "type": "commit"}, {"oid": "dd5dbeb5479bd4df4e39a4a3c53fa9b863fdea28", "url": "https://github.com/wso2/product-microgateway/commit/dd5dbeb5479bd4df4e39a4a3c53fa9b863fdea28", "message": "method documentation added for jwt_auth_handler file", "committedDate": "2020-05-29T08:15:45Z", "type": "commit"}, {"oid": "32430dd0220a5dc65acab837c06a7ff84d798c22", "url": "https://github.com/wso2/product-microgateway/commit/32430dd0220a5dc65acab837c06a7ff84d798c22", "message": "enabling jwt generator option added", "committedDate": "2020-05-29T08:16:06Z", "type": "commit"}, {"oid": "f5019e6a0708013662d99377135744e7c8057d8a", "url": "https://github.com/wso2/product-microgateway/commit/f5019e6a0708013662d99377135744e7c8057d8a", "message": "integration tests added", "committedDate": "2020-05-29T08:22:04Z", "type": "commit"}, {"oid": "7e49f0dbcbee140800a05034998722ec409ba1aa", "url": "https://github.com/wso2/product-microgateway/commit/7e49f0dbcbee140800a05034998722ec409ba1aa", "message": "configurations updated, generator class creation moved to initiation, mapvalue to map java side", "committedDate": "2020-05-29T09:10:10Z", "type": "commit"}, {"oid": "a85b9053cb72f1c8f6a3c24689d03300595c52a2", "url": "https://github.com/wso2/product-microgateway/commit/a85b9053cb72f1c8f6a3c24689d03300595c52a2", "message": "seperate bal file added for interop functions", "committedDate": "2020-05-29T09:10:54Z", "type": "commit"}, {"oid": "ab79f8f93dbe058e0beefce892855f9517a76ba3", "url": "https://github.com/wso2/product-microgateway/commit/ab79f8f93dbe058e0beefce892855f9517a76ba3", "message": "error handling moved to ballerina side", "committedDate": "2020-05-29T09:27:16Z", "type": "commit"}, {"oid": "35c303a27ae61c8142bb8420915ea93d571bc456", "url": "https://github.com/wso2/product-microgateway/commit/35c303a27ae61c8142bb8420915ea93d571bc456", "message": "restricted claims array conversion moved to java side", "committedDate": "2020-05-29T09:32:05Z", "type": "commit"}, {"oid": "7233309ef1528e1f0ea5668fc4de6f3dcdf11bd5", "url": "https://github.com/wso2/product-microgateway/commit/7233309ef1528e1f0ea5668fc4de6f3dcdf11bd5", "message": "added multiple audience option, refactored code, added license", "committedDate": "2020-05-30T05:36:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MTE0Mg==", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433041142", "bodyText": "Package name should be jwt.generator", "author": "Rajith90", "createdAt": "2020-06-01T04:56:28Z", "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwtgenerator/MGWJWTGeneratorInvoker.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.wso2.micro.gateway.core.jwtgenerator;", "originalCommit": "7233309ef1528e1f0ea5668fc4de6f3dcdf11bd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6e37528d19b38718e0809243a244128df2b82485", "url": "https://github.com/wso2/product-microgateway/commit/6e37528d19b38718e0809243a244128df2b82485", "message": "package name changed, default skew time constant used", "committedDate": "2020-06-01T06:07:43Z", "type": "commit"}, {"oid": "a0c3776a2e3096fee3a86ffccb6dc5a1cd86b332", "url": "https://github.com/wso2/product-microgateway/commit/a0c3776a2e3096fee3a86ffccb6dc5a1cd86b332", "message": "unnecessary defaults removed, refactored code", "committedDate": "2020-06-02T08:49:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMzY4OA==", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r556933688", "bodyText": "I think we can put the common strings used here in a constant file and use those constants instead. If they are already defined as constants let's use that. Ex: \"customClaims\", \"sub\", \"iss\", \"tier\" etc.", "author": "tharikaGitHub", "createdAt": "2021-01-13T22:59:06Z", "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwt/generator/MGWJWTGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.wso2.micro.gateway.core.jwt.generator;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+/**\n+ *  Class to implement standard claims and custom claims.\n+ */\n+public class MGWJWTGeneratorImpl extends AbstractMGWJWTGenerator {\n+    private static final Log logger = LogFactory.getLog(MGWJWTGeneratorImpl.class);\n+    private static final String AUTH_APPLICATION_USER_LEVEL_TOKEN = \"Application_user\";\n+\n+    public MGWJWTGeneratorImpl(String dialectURI,\n+                               String signatureAlgorithm,\n+                               String trustStorePath,\n+                               String trustStorePassword,\n+                               String certificateAlias,\n+                               String privateKeyAlias,\n+                               int jwtExpiryTime,\n+                               String[] restrictedClaims,\n+                               boolean jwtCacheEnabled,\n+                               int jwtCacheExpiry,\n+                               String tokenIssuer,\n+                               String[] tokenAudience) {\n+        super(dialectURI, signatureAlgorithm, trustStorePath, trustStorePassword, certificateAlias, privateKeyAlias,\n+                jwtExpiryTime, restrictedClaims, jwtCacheEnabled, jwtCacheExpiry, tokenIssuer, tokenAudience);\n+    }\n+\n+    @Override\n+    public Map<String, Object> populateStandardClaims(Map<String, Object> jwtInfo) {\n+        long currentTime = System.currentTimeMillis();\n+        long expireIn = currentTime + getTTL();\n+        String dialect = this.getDialectURI();\n+        Map<String, Object> claims = new HashMap<>();\n+        HashMap<String, Object> customClaims = (HashMap<String, Object>) jwtInfo.get(\"customClaims\");", "originalCommit": "a0c3776a2e3096fee3a86ffccb6dc5a1cd86b332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTc2MDI0Mg==", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r571760242", "bodyText": "Done with 45bcd34", "author": "HeshanSudarshana", "createdAt": "2021-02-08T03:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMzY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA0NTkzMA==", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r573045930", "bodyText": "missing try resource", "author": "tharindu1st", "createdAt": "2021-02-09T16:42:21Z", "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwt/generator/AbstractMGWJWTGenerator.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.wso2.micro.gateway.core.jwt.generator;\n+\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import net.minidev.json.JSONArray;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import java.io.FileInputStream;\n+import java.nio.charset.Charset;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.MessageDigest;\n+import java.security.PrivateKey;\n+import java.security.Signature;\n+import java.security.cert.Certificate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ *  Abstract class for generate JWT for backend claims.\n+ */\n+public abstract class AbstractMGWJWTGenerator {\n+    private static final Log logger = LogFactory.getLog(AbstractMGWJWTGenerator.class);\n+    private static final String NONE = \"NONE\";\n+    private static final String SHA256_WITH_RSA = \"SHA256withRSA\";\n+    private String dialectURI;\n+    private String signatureAlgorithm;\n+    private String keyStorePath;\n+    private String keyStorePassword;\n+    private String certificateAlias;\n+    private String privateKeyAlias;\n+    private int jwtExpiryTime;\n+    private ArrayList<String> restrictedClaims;\n+    private boolean cacheEnabled;\n+    private int cacheExpiry;\n+    private String tokenIssuer;\n+    private String[] tokenAudience;\n+    private Map<String, Object> apiDetails;\n+    private List<String> defaultRestrictedClaims;\n+\n+    public AbstractMGWJWTGenerator(String dialectURI,\n+                                   String signatureAlgorithm,\n+                                   String keyStorePath,\n+                                   String keyStorePassword,\n+                                   String certificateAlias,\n+                                   String privateKeyAlias,\n+                                   int jwtExpiryTime,\n+                                   String[] restrictedClaims,\n+                                   boolean cacheEnabled,\n+                                   int cacheExpiry,\n+                                   String tokenIssuer,\n+                                   String[] tokenAudience) {\n+        this.keyStorePath = keyStorePath;\n+        this.keyStorePassword = keyStorePassword;\n+        this.certificateAlias = certificateAlias;\n+        this.privateKeyAlias = privateKeyAlias;\n+        this.jwtExpiryTime = jwtExpiryTime;\n+        this.dialectURI = dialectURI;\n+        this.signatureAlgorithm = signatureAlgorithm;\n+        this.cacheEnabled = cacheEnabled;\n+        this.cacheExpiry = cacheExpiry;\n+        this.tokenIssuer = tokenIssuer;\n+        this.tokenAudience = tokenAudience;\n+        this.restrictedClaims = new ArrayList<>(Arrays.asList(restrictedClaims));\n+        defaultRestrictedClaims = new ArrayList<>(Arrays.asList(\"iss\", \"sub\", \"aud\", \"exp\",\n+                \"nbf\", \"iat\", \"jti\", \"application\", \"tierInfo\", \"subscribedAPIs\", \"keytype\"));\n+        this.restrictedClaims.addAll(defaultRestrictedClaims);\n+    }\n+\n+    public String getPrivateKeyAlias() {\n+        return privateKeyAlias;\n+    }\n+\n+    public void setPrivateKeyAlias(String privateKeyAlias) {\n+        this.privateKeyAlias = privateKeyAlias;\n+    }\n+\n+    public List<String> getDefaultRestrictedClaims() {\n+        return defaultRestrictedClaims;\n+    }\n+\n+    public void setDefaultRestrictedClaims(List<String> defaultRestrictedClaims) {\n+        this.defaultRestrictedClaims = defaultRestrictedClaims;\n+    }\n+\n+    public String getCertificateAlias() {\n+        return certificateAlias;\n+    }\n+\n+    public void setCertificateAlias(String certificateAlias) {\n+        this.certificateAlias = certificateAlias;\n+    }\n+\n+    public Map<String, Object> getApiDetails() {\n+        return apiDetails;\n+    }\n+\n+    public void setApiDetails(Map<String, Object> apiDetails) {\n+        this.apiDetails = apiDetails;\n+    }\n+\n+    public String[] getTokenAudience() {\n+        return tokenAudience;\n+    }\n+\n+    public void setTokenAudience(String[] tokenAudience) {\n+        this.tokenAudience = tokenAudience;\n+    }\n+\n+    public String getTokenIssuer() {\n+        return tokenIssuer;\n+    }\n+\n+    public void setTokenIssuer(String tokenIssuer) {\n+        this.tokenIssuer = tokenIssuer;\n+    }\n+\n+    public boolean isCacheEnabled() {\n+        return cacheEnabled;\n+    }\n+\n+    public void setCacheEnabled(boolean cacheEnabled) {\n+        this.cacheEnabled = cacheEnabled;\n+    }\n+\n+    public int getCacheExpiry() {\n+        return cacheExpiry;\n+    }\n+\n+    public void setCacheExpiry(int cacheExpiry) {\n+        this.cacheExpiry = cacheExpiry;\n+    }\n+\n+    public ArrayList<String> getRestrictedClaims() {\n+        return restrictedClaims;\n+    }\n+\n+    public void setRestrictedClaims(ArrayList<String> restrictedClaims) {\n+        this.restrictedClaims = restrictedClaims;\n+    }\n+\n+    public String getKeyStorePath() {\n+        return keyStorePath;\n+    }\n+\n+    public void setKeyStorePath(String keyStorePath) {\n+        this.keyStorePath = keyStorePath;\n+    }\n+\n+    public String getKeyStorePassword() {\n+        return keyStorePassword;\n+    }\n+\n+    public void setKeyStorePassword(String keyStorePassword) {\n+        this.keyStorePassword = keyStorePassword;\n+    }\n+\n+    public String getDialectURI() {\n+        return dialectURI;\n+    }\n+\n+    public void setDialectURI(String dialectURI) {\n+        this.dialectURI = dialectURI;\n+    }\n+\n+    public String getSignatureAlgorithm() {\n+        return signatureAlgorithm;\n+    }\n+\n+    public void setSignatureAlgorithm(String signatureAlgorithm) {\n+        this.signatureAlgorithm = signatureAlgorithm;\n+    }\n+\n+    public int getJwtExpiryTime() {\n+        return jwtExpiryTime;\n+    }\n+\n+    public void setJwtExpiryTime(int jwtExpiryTime) {\n+        this.jwtExpiryTime = jwtExpiryTime;\n+    }\n+\n+    /**\n+     * Used to generate the JWT token.\n+     */\n+    public String generateToken(Map<String, Object> jwtInfo) throws Exception {\n+        String jwtHeader = buildHeader();\n+        String jwtBody = buildBody(jwtInfo);\n+        String base64UrlEncodedHeader = \"\";\n+        if (jwtHeader != null) {\n+            base64UrlEncodedHeader = encode(jwtHeader.getBytes(Charset.defaultCharset()));\n+        }\n+        String base64UrlEncodedBody = \"\";\n+        if (jwtBody != null) {\n+            base64UrlEncodedBody = encode(jwtBody.getBytes());\n+        }\n+        if (SHA256_WITH_RSA.equals(signatureAlgorithm)) {\n+            String assertion = base64UrlEncodedHeader + '.' + base64UrlEncodedBody;\n+            //get the assertion signed\n+            byte[] signedAssertion = signJWT(assertion);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"signed assertion value : \" + new String(signedAssertion, Charset.defaultCharset()));\n+            }\n+            String base64UrlEncodedAssertion = encode(signedAssertion);\n+            return base64UrlEncodedHeader + '.' + base64UrlEncodedBody + '.' + base64UrlEncodedAssertion;\n+        } else {\n+            return base64UrlEncodedHeader + '.' + base64UrlEncodedBody + '.';\n+        }\n+    }\n+\n+    /**\n+     * Used to build the JWT header.\n+     */\n+    public String buildHeader() throws Exception {\n+        String jwtHeader = null;\n+        if (NONE.equals(signatureAlgorithm)) {\n+            StringBuilder jwtHeaderBuilder = new StringBuilder();\n+            jwtHeaderBuilder.append(\"{\\\"typ\\\":\\\"JWT\\\",\");\n+            jwtHeaderBuilder.append(\"\\\"alg\\\":\\\"\");\n+            jwtHeaderBuilder.append(\"none\");\n+            jwtHeaderBuilder.append('\\\"');\n+            jwtHeaderBuilder.append('}');\n+            jwtHeader = jwtHeaderBuilder.toString();\n+        } else if (SHA256_WITH_RSA.equals(signatureAlgorithm)) {\n+            jwtHeader = addCertToHeader();\n+        }\n+        return jwtHeader;\n+    }\n+\n+    /**\n+     * Used to sign the JWT using the keystore.\n+     */\n+    public byte[] signJWT(String assertion) throws Exception {\n+        FileInputStream is;\n+        is = new FileInputStream(keyStorePath);\n+        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+        keystore.load(is, keyStorePassword.toCharArray());\n+        Key key = keystore.getKey(privateKeyAlias, keyStorePassword.toCharArray());\n+        Key privateKey = null;\n+        if (key instanceof PrivateKey) {\n+            privateKey = key;\n+        }\n+        //initialize signature with private key and algorithm\n+        Signature signature = Signature.getInstance(signatureAlgorithm);\n+        signature.initSign((PrivateKey) privateKey);\n+        //update signature with data to be signed\n+        byte[] dataInBytes = assertion.getBytes(Charset.defaultCharset());\n+        signature.update(dataInBytes);\n+\n+        // close the file stream\n+        is.close();\n+\n+        //sign the assertion and return the signature\n+        return signature.sign();\n+    }\n+\n+    /**\n+     * Used to get the expiration time of the token.\n+     */\n+    public long getTTL() {\n+        if (cacheEnabled) {\n+            return cacheExpiry;\n+        } else {\n+            return jwtExpiryTime;\n+        }\n+    }\n+\n+    /**\n+     * Used to add \"ballerina\"the certificate from the keystore to the header.\n+     */\n+    public String addCertToHeader() throws Exception {\n+        FileInputStream is;\n+        is = new FileInputStream(keyStorePath);", "originalCommit": "a0c3776a2e3096fee3a86ffccb6dc5a1cd86b332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTkyODIzNQ==", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r575928235", "bodyText": "Added with #1638", "author": "HeshanSudarshana", "createdAt": "2021-02-15T03:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA0NTkzMA=="}], "type": "inlineReview"}]}