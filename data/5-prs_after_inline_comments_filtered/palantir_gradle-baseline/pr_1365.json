{"pr_number": 1365, "pr_title": "Convert multi param lambdas and local method invocations to method references", "pr_createdAt": "2020-05-29T03:45:19Z", "pr_url": "https://github.com/palantir/gradle-baseline/pull/1365", "timeline": [{"oid": "3fa6f1b1239631f84a6b0a6177e5593ec45cb5aa", "url": "https://github.com/palantir/gradle-baseline/commit/3fa6f1b1239631f84a6b0a6177e5593ec45cb5aa", "message": "baby steps", "committedDate": "2020-05-29T02:41:41Z", "type": "commit"}, {"oid": "c7fa4b0fd1888c4fdacb533440c0edbf924d4b70", "url": "https://github.com/palantir/gradle-baseline/commit/c7fa4b0fd1888c4fdacb533440c0edbf924d4b70", "message": "convert local methods and multi param methods", "committedDate": "2020-05-29T03:41:53Z", "type": "commit"}, {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "url": "https://github.com/palantir/gradle-baseline/commit/474512dbc8676a65536bd55662f7d1bc1c05dbe3", "message": "Add generated changelog entries", "committedDate": "2020-05-29T03:41:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDQxNg==", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432244416", "bodyText": "I think we should handle a receiver IdentifierTree with name \u201cthis\u201d as well. Worth a test case if we don\u2019t already have one (review on thumbs)", "author": "carterkozak", "createdAt": "2020-05-29T04:05:30Z", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        if (!root.getParameters().isEmpty()) {\n+            Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n+            Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n+            if (!paramSymbol.equals(receiverSymbol)) {\n+                return Description.NO_MATCH;\n+            }\n+        }\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = receiver == null;\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {\n             return Description.NO_MATCH;\n         }\n \n         return buildDescription(root)\n                 .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state))\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n                 .build();\n     }\n \n-    private static boolean shouldIgnore(\n-            Symbol.MethodSymbol methodSymbol, LambdaExpressionTree root, MethodInvocationTree methodInvocation) {\n-        if (!methodSymbol.isStatic()) {\n-            if (root.getParameters().size() == 1) {\n-                Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n-                Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n-                return !paramSymbol.equals(receiverSymbol);\n-            }\n-            return true;\n+    private Description convertMethodInvocations(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        List<Symbol> methodParams = getSymbols(methodInvocation.getArguments());\n+        List<Symbol> lambdaParam = getSymbols(root.getParameters());\n+\n+        // We are guaranteed that all of root params are symbols so equality should handle cases where methodInvocation\n+        // arguments are not symbols or are out of order\n+        if (!methodParams.equals(lambdaParam)) {\n+            return Description.NO_MATCH;\n         }\n-        return !root.getParameters().isEmpty();\n+\n+        boolean isLocal = ASTHelpers.getReceiver(methodInvocation) == null;", "originalCommit": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDcxNg==", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432244716", "bodyText": "Not sure these negative tests are necessary when we have refactoring tests as well.", "author": "carterkozak", "createdAt": "2020-05-29T04:07:06Z", "path": "baseline-error-prone/src/test/java/com/palantir/baseline/errorprone/LambdaMethodReferenceTest.java", "diffHunk": "@@ -67,7 +68,83 @@ void testFunction() {\n     }\n \n     @Test\n-    public void testPositive_block() {\n+    void testLocalInstanceMethod() {\n+        compilationHelper\n+                .addSourceLines(\n+                        \"Test.java\",\n+                        \"import \" + Optional.class.getName() + ';',\n+                        \"class Test {\",\n+                        \"  public Optional<Integer> foo(Optional<String> optional) {\",\n+                        \"    // BUG: Diagnostic contains: Lambda should be a method reference\",\n+                        \"    return optional.map(v -> bar(v));\",\n+                        \"  }\",\n+                        \"  private Integer bar(String value) {\",\n+                        \"    return value.length();\",\n+                        \"  }\",\n+                        \"}\")\n+                .doTest();", "originalCommit": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NTgwNA==", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432245804", "bodyText": "Can we remove the supplier case here in favor of the zero-length method invocation code path?", "author": "carterkozak", "createdAt": "2020-05-29T04:12:17Z", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(", "originalCommit": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0OTk4Mg==", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432249982", "bodyText": "I think there might be some oddness if the method is. It provided by this, but an enclosing class, requiring prefix \u201cEnclosing.this.\u201c. Worth a test to verify, I\u2019d probably exclude that from the check rather than attempt to refactor since it\u2019s fairly uncommon.", "author": "carterkozak", "createdAt": "2020-05-29T04:31:21Z", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        if (!root.getParameters().isEmpty()) {\n+            Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n+            Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n+            if (!paramSymbol.equals(receiverSymbol)) {\n+                return Description.NO_MATCH;\n+            }\n+        }\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = receiver == null;\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {\n             return Description.NO_MATCH;\n         }\n \n         return buildDescription(root)\n                 .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state))\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n                 .build();\n     }\n \n-    private static boolean shouldIgnore(\n-            Symbol.MethodSymbol methodSymbol, LambdaExpressionTree root, MethodInvocationTree methodInvocation) {\n-        if (!methodSymbol.isStatic()) {\n-            if (root.getParameters().size() == 1) {\n-                Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n-                Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n-                return !paramSymbol.equals(receiverSymbol);\n-            }\n-            return true;\n+    private Description convertMethodInvocations(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        List<Symbol> methodParams = getSymbols(methodInvocation.getArguments());\n+        List<Symbol> lambdaParam = getSymbols(root.getParameters());\n+\n+        // We are guaranteed that all of root params are symbols so equality should handle cases where methodInvocation\n+        // arguments are not symbols or are out of order\n+        if (!methodParams.equals(lambdaParam)) {\n+            return Description.NO_MATCH;\n         }\n-        return !root.getParameters().isEmpty();\n+\n+        boolean isLocal = ASTHelpers.getReceiver(methodInvocation) == null;\n+        return buildDescription(root)\n+                .setMessage(MESSAGE)\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n+                .build();\n+    }\n+\n+    private static List<Symbol> getSymbols(List<? extends Tree> params) {\n+        return params.stream()\n+                .map(ASTHelpers::getSymbol)\n+                .filter(Objects::nonNull)\n+                .collect(ImmutableList.toImmutableList());\n     }\n \n     private static Optional<SuggestedFix> buildFix(\n             Symbol.MethodSymbol symbol,\n             MethodInvocationTree invocation,\n             LambdaExpressionTree root,\n-            VisitorState state) {\n+            VisitorState state,\n+            boolean isLocal) {\n         SuggestedFix.Builder builder = SuggestedFix.builder();\n-        return toMethodReference(qualifyTarget(symbol, invocation, builder, state))\n+        return toMethodReference(qualifyTarget(symbol, invocation, builder, state, isLocal))\n                 .map(qualified -> builder.replace(root, qualified).build());\n     }\n \n     private static String qualifyTarget(\n             Symbol.MethodSymbol symbol,\n             MethodInvocationTree invocation,\n             SuggestedFix.Builder builder,\n-            VisitorState state) {\n+            VisitorState state,\n+            boolean isLocal) {\n+        if (!symbol.isStatic() && isLocal) {\n+            return \"this.\" + symbol.name.toString();", "originalCommit": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9ac79db4930bc015819445a449f3579bf7a51dac", "url": "https://github.com/palantir/gradle-baseline/commit/9ac79db4930bc015819445a449f3579bf7a51dac", "message": "handle explicit this", "committedDate": "2020-05-29T12:53:20Z", "type": "commit"}, {"oid": "7f47bb7235f39a4b1a7ef60666c8d2e49049c766", "url": "https://github.com/palantir/gradle-baseline/commit/7f47bb7235f39a4b1a7ef60666c8d2e49049c766", "message": "simplify", "committedDate": "2020-05-29T13:00:20Z", "type": "commit"}, {"oid": "0ecf78c33382ef0749b53388ba321269eeff645d", "url": "https://github.com/palantir/gradle-baseline/commit/0ecf78c33382ef0749b53388ba321269eeff645d", "message": "Merge branch 'fo/lambda-methods' of github.com:palantir/gradle-baseline into fo/lambda-methods", "committedDate": "2020-05-29T15:46:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MzgxMw==", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432583813", "bodyText": "Does this prevent us from fixing static method calls? I don't think static methods have receivers (but I may be incorrect)\n- value -> Preconditions.checkNotNull(value)\n+ Preconditions::checkNotNull", "author": "carterkozak", "createdAt": "2020-05-29T16:00:43Z", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,93 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = isLocal(methodInvocation);\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {", "originalCommit": "0ecf78c33382ef0749b53388ba321269eeff645d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "63697913887e4a07b6ef1f3c48333894d50148cc", "url": "https://github.com/palantir/gradle-baseline/commit/63697913887e4a07b6ef1f3c48333894d50148cc", "message": "demonstrate static method with param", "committedDate": "2020-05-29T19:32:45Z", "type": "commit"}, {"oid": "7a43e41c8c66e33c3cc9451e3d6588ba408ac02b", "url": "https://github.com/palantir/gradle-baseline/commit/7a43e41c8c66e33c3cc9451e3d6588ba408ac02b", "message": "Ckozak/fo/lambda methods/fix (#1369)\n\n* Fix lambdas\n\n* dont change reference capture time\n\n* avoid refactoring lambdas with param types\n\n* cyclo", "committedDate": "2020-05-29T20:16:17Z", "type": "commit"}, {"oid": "df14397f105db2b6ed623d6f228dc138f8343066", "url": "https://github.com/palantir/gradle-baseline/commit/df14397f105db2b6ed623d6f228dc138f8343066", "message": "validate against ambiguous references (#1372)\n\n<!-- User-facing outcomes this PR delivers -->", "committedDate": "2020-06-01T20:48:10Z", "type": "commit"}]}