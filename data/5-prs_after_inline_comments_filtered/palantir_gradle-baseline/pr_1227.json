{"pr_number": 1227, "pr_title": "License replacement attempts to preserve existing year info", "pr_createdAt": "2020-02-10T23:08:24Z", "pr_url": "https://github.com/palantir/gradle-baseline/pull/1227", "timeline": [{"oid": "2c83650e66b57c0cb73f1401d551c58fb1ffeb9a", "url": "https://github.com/palantir/gradle-baseline/commit/2c83650e66b57c0cb73f1401d551c58fb1ffeb9a", "message": "Inline some stuff", "committedDate": "2020-02-10T22:23:02Z", "type": "commit"}, {"oid": "2938a868377fd7016317d0debd6142971d599312", "url": "https://github.com/palantir/gradle-baseline/commit/2938a868377fd7016317d0debd6142971d599312", "message": "Try to preserve year of existing license", "committedDate": "2020-02-10T22:36:23Z", "type": "commit"}, {"oid": "9c71b5f07f36869f695bcf1f56682e1bcde8bc83", "url": "https://github.com/palantir/gradle-baseline/commit/9c71b5f07f36869f695bcf1f56682e1bcde8bc83", "message": "Add generated changelog entries", "committedDate": "2020-02-10T22:36:23Z", "type": "commit"}, {"oid": "04ef5a6effdbee4591914474249e36d04afa1001", "url": "https://github.com/palantir/gradle-baseline/commit/04ef5a6effdbee4591914474249e36d04afa1001", "message": "Don't need single year", "committedDate": "2020-02-10T23:12:59Z", "type": "commit"}, {"oid": "b082b2174958958776494683a4ca35e3e8f52ca6", "url": "https://github.com/palantir/gradle-baseline/commit/b082b2174958958776494683a4ca35e3e8f52ca6", "message": "Dont' need $YEAR indirection anymore", "committedDate": "2020-02-10T23:12:59Z", "type": "commit"}, {"oid": "b14e853ca054173a5bec744dda4611e77b966eef", "url": "https://github.com/palantir/gradle-baseline/commit/b14e853ca054173a5bec744dda4611e77b966eef", "message": "Move logic out of plugin", "committedDate": "2020-02-10T23:29:40Z", "type": "commit"}, {"oid": "7915df0a76cafab3bc799d562bc7a76f7b01f691", "url": "https://github.com/palantir/gradle-baseline/commit/7915df0a76cafab3bc799d562bc7a76f7b01f691", "message": "simplify a bit more", "committedDate": "2020-02-10T23:36:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM4MTYzNg==", "url": "https://github.com/palantir/gradle-baseline/pull/1227#discussion_r377381636", "bodyText": "this line is really the money.\nthe rest of the PR is mainly just me deleting indirection that doesn't seem necessary now that we're not working around spotless' API", "author": "iamdanfox", "createdAt": "2020-02-10T23:38:35Z", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/plugins/MultiLicenseHeaderStep.java", "diffHunk": "@@ -55,113 +60,95 @@\n      */\n     private static final String NAME = \"licenseHeader\";\n \n-    private static final String DEFAULT_YEAR_DELIMITER = \"-\";\n-\n-    private final Pattern delimiterPattern;\n+    /** Spotless will consider the license header to be the file prefix up to the first line starting with delimiter. */\n+    private static final Pattern DELIMITER_PATTERN =\n+            Pattern.compile(\"^(?! \\\\*|/\\\\*| \\\\*/)\", Pattern.UNIX_LINES | Pattern.MULTILINE);\n \n     private final List<LicenseHeader> licenseHeaders;\n \n-    /** Creates a FormatterStep which forces the start of each file to match a license header. */\n-    public static FormatterStep createFromHeaders(List<String> licenseHeaders, String delimiter) {\n-        return createFromHeaders(licenseHeaders, delimiter, DEFAULT_YEAR_DELIMITER);\n+    private MultiLicenseHeaderStep(List<LicenseHeader> licenseHeaders) {\n+        this.licenseHeaders = licenseHeaders;\n     }\n \n-    private static FormatterStep createFromHeaders(\n-            List<String> licenseHeaders, String delimiter, String yearSeparator) {\n-        Objects.requireNonNull(licenseHeaders, \"licenseHeader\");\n-        Objects.requireNonNull(delimiter, \"delimiter\");\n-        Objects.requireNonNull(yearSeparator, \"yearSeparator\");\n+    /** Creates a spotless {@link FormatterStep} which forces the start of each file to match a license header. */\n+    public static FormatterStep createFromHeaders(List<String> templates) {\n+        List<LicenseHeader> headers =\n+                templates.stream().map(LicenseHeader::fromTemplate).collect(Collectors.toList());\n         return FormatterStep.create(\n-                MultiLicenseHeaderStep.NAME,\n-                new MultiLicenseHeaderStep(licenseHeaders, delimiter, yearSeparator),\n-                step -> step::format);\n+                MultiLicenseHeaderStep.NAME, new MultiLicenseHeaderStep(headers), step -> step::format);\n     }\n \n     public static String name() {\n         return NAME;\n     }\n \n-    /** The license that we'd like enforced. */\n-    private MultiLicenseHeaderStep(List<String> licenseHeaders, String delimiter, String yearSeparator) {\n-        this.delimiterPattern = Pattern.compile('^' + delimiter, Pattern.UNIX_LINES | Pattern.MULTILINE);\n-        this.licenseHeaders = licenseHeaders.stream()\n-                .map(header -> new LicenseHeader(header, delimiter, yearSeparator))\n-                .collect(Collectors.toList());\n-    }\n-\n     private static class LicenseHeader implements Serializable {\n         private static final long serialVersionUID = 1L;\n+        private static final Pattern YEAR_RANGE = Pattern.compile(\"[0-9]{4}(-[0-9]{4})?\");\n+        private static final String YEAR_TOKEN = \"${today.year}\";\n+\n+        private final String licenseHeaderBeforeYearToken;\n+        private final String licenseHeaderAfterYearToken;\n+\n+        private LicenseHeader(String licenseHeader) {\n+            Preconditions.checkArgument(\n+                    licenseHeader.contains(YEAR_TOKEN),\n+                    \"License header must contain year token\",\n+                    YEAR_TOKEN,\n+                    licenseHeader);\n+            int yearTokenIndex = licenseHeader.indexOf(YEAR_TOKEN);\n+            this.licenseHeaderBeforeYearToken = licenseHeader.substring(0, yearTokenIndex);\n+            this.licenseHeaderAfterYearToken = licenseHeader.substring(yearTokenIndex + YEAR_TOKEN.length());\n+        }\n \n-        private final String licenseHeader;\n-        private Pattern yearMatcherPattern;\n-        private final boolean hasYearToken;\n-        private String licenseHeaderBeforeYearToken;\n-        private String licenseHeaderAfterYearToken;\n-        private String licenseHeaderWithYearTokenReplaced;\n-\n-        LicenseHeader(String licenseHeader0, String delimiter, String yearSeparator) {\n-            if (delimiter.contains(\"\\n\")) {\n-                throw new IllegalArgumentException(\"The delimiter must not contain any newlines.\");\n-            }\n-            // sanitize the input license\n-            String licenseHeader1 = LineEnding.toUnix(licenseHeader0);\n-            if (!licenseHeader1.endsWith(\"\\n\")) {\n-                licenseHeader1 = licenseHeader1 + \"\\n\";\n-            }\n-            this.licenseHeader = licenseHeader1;\n-            this.hasYearToken = licenseHeader1.contains(\"$YEAR\");\n-            if (this.hasYearToken) {\n-                int yearTokenIndex = licenseHeader1.indexOf(\"$YEAR\");\n-                this.licenseHeaderBeforeYearToken = licenseHeader1.substring(0, yearTokenIndex);\n-                this.licenseHeaderAfterYearToken = licenseHeader1.substring(yearTokenIndex + 5);\n-                this.licenseHeaderWithYearTokenReplaced = licenseHeader1.replace(\n-                        \"$YEAR\", String.valueOf(YearMonth.now().getYear()));\n-                this.yearMatcherPattern = Pattern.compile(\"[0-9]{4}(\" + Pattern.quote(yearSeparator) + \"[0-9]{4})?\");\n-            }\n+        static LicenseHeader fromTemplate(String template) {\n+            String unixEndings = LineEnding.toUnix(template.trim());\n+            Iterable<String> lines = Splitter.on('\\n').trimResults().split(unixEndings);\n+            String javadocHeader = Streams.stream(lines)\n+                    .map(line -> line.isEmpty() ? \" *\" : \" * \" + line)\n+                    .collect(Collectors.joining(\"\\n\"));\n+            return new LicenseHeader(\"/*\\n\" + javadocHeader + \"\\n */\\n\");\n         }\n \n-        private boolean matchesLicenseWithYearToken(String existingHeader) {\n+        private boolean matches(String existingHeader) {\n             int startOfTheSecondPart = existingHeader.indexOf(licenseHeaderAfterYearToken);\n             return startOfTheSecondPart > licenseHeaderBeforeYearToken.length()\n                     && (existingHeader.startsWith(licenseHeaderBeforeYearToken)\n                             && startOfTheSecondPart + licenseHeaderAfterYearToken.length() == existingHeader.length())\n-                    && yearMatcherPattern\n+                    && YEAR_RANGE\n                             .matcher(existingHeader.substring(\n                                     licenseHeaderBeforeYearToken.length(), startOfTheSecondPart))\n                             .matches();\n         }\n \n-        private boolean matches(String existingHeader) {\n-            if (hasYearToken) {\n-                // that means we have the license like `licenseHeaderBeforeYearToken 1990-2015\n-                // licenseHeaderAfterYearToken`\n-                return matchesLicenseWithYearToken(existingHeader);\n-            }\n-            return existingHeader.equals(licenseHeader);\n-        }\n-\n-        private String render() {\n-            if (hasYearToken) {\n-                return licenseHeaderWithYearTokenReplaced;\n-            }\n-            return licenseHeader;\n+        private String render(String existingHeader) {\n+            Matcher yearInfo = YEAR_RANGE.matcher(existingHeader);\n+            boolean existingHeaderContainsYear = yearInfo.find();\n+            String year = existingHeaderContainsYear\n+                    ? yearInfo.group(0)\n+                    : String.valueOf(YearMonth.now().getYear());", "originalCommit": "7915df0a76cafab3bc799d562bc7a76f7b01f691", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}