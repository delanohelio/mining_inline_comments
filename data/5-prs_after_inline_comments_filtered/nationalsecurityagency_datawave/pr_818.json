{"pr_number": 818, "pr_title": "Added logic to produce tighter ranges for queries against geowave ind\u2026", "pr_createdAt": "2020-05-06T17:20:06Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/818", "timeline": [{"oid": "1245c6df02c0cf262a446e87ca39439e78e2bac1", "url": "https://github.com/NationalSecurityAgency/datawave/commit/1245c6df02c0cf262a446e87ca39439e78e2bac1", "message": "Added logic to produce tighter ranges for queries against geowave indexed terms.", "committedDate": "2020-05-06T17:36:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4NDkyMw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422184923", "bodyText": "typo: computer", "author": "keith-ratcliffe", "createdAt": "2020-05-08T14:45:22Z", "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter", "originalCommit": "5f39f0deda142118eb78dce2c4c240f061dcfbd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4NTczNQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422185735", "bodyText": "typo: computer", "author": "keith-ratcliffe", "createdAt": "2020-05-08T14:46:47Z", "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRanges(queryGeometry, byteArrayRanges, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter", "originalCommit": "5f39f0deda142118eb78dce2c4c240f061dcfbd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4Njk1OQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422186959", "bodyText": "same typo, although 'computer' as a verb is actually starting to grow on me.", "author": "keith-ratcliffe", "createdAt": "2020-05-08T14:48:57Z", "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRanges(queryGeometry, byteArrayRanges, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> optimizedRanges = new ArrayList<>();\n+        for (ByteArrayRange byteArrayRange : byteArrayRanges) {\n+            if (!byteArrayRange.isSingleValue()) {\n+                optimizedRanges.addAll(optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, longBuffer));\n+            } else {\n+                optimizedRanges.add(byteArrayRange);\n+            }\n+        }\n+        return optimizedRanges;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter", "originalCommit": "5f39f0deda142118eb78dce2c4c240f061dcfbd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4OTQ5OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422189498", "bodyText": "same :)", "author": "keith-ratcliffe", "createdAt": "2020-05-08T14:53:14Z", "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRanges(queryGeometry, byteArrayRanges, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> optimizedRanges = new ArrayList<>();\n+        for (ByteArrayRange byteArrayRange : byteArrayRanges) {\n+            if (!byteArrayRange.isSingleValue()) {\n+                optimizedRanges.addAll(optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, longBuffer));\n+            } else {\n+                optimizedRanges.add(byteArrayRange);\n+            }\n+        }\n+        return optimizedRanges;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRange(Geometry queryGeometry, ByteArrayRange byteArrayRange, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter", "originalCommit": "5f39f0deda142118eb78dce2c4c240f061dcfbd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4ODkwMg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422288902", "bodyText": "I think I'm computering the right spelling now.", "author": "jwomeara", "createdAt": "2020-05-08T18:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4OTQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MDgxOA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422240818", "bodyText": "Wondering if all the instances of this pattern could be consolidated into one or two helper methods, similar to your positionToGeometry function", "author": "keith-ratcliffe", "createdAt": "2020-05-08T16:29:19Z", "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRanges(queryGeometry, byteArrayRanges, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> optimizedRanges = new ArrayList<>();\n+        for (ByteArrayRange byteArrayRange : byteArrayRanges) {\n+            if (!byteArrayRange.isSingleValue()) {\n+                optimizedRanges.addAll(optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, longBuffer));\n+            } else {\n+                optimizedRanges.add(byteArrayRange);\n+            }\n+        }\n+        return optimizedRanges;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRange(Geometry queryGeometry, ByteArrayRange byteArrayRange, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRange(Geometry queryGeometry, ByteArrayRange byteArrayRange, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        GeometryFactory gf = new GeometryFactory();\n+        List<ByteArrayRange> byteArrayRanges = new ArrayList<>();\n+        \n+        int tier = decodeTier(byteArrayRange.getStart());\n+        if (tier == 0) {\n+            byteArrayRanges.add(byteArrayRange);\n+        } else {\n+            longBuffer = initLongBuffer(longBuffer);\n+            \n+            long min = decodePosition(byteArrayRange.getStart(), longBuffer);\n+            long max = decodePosition(byteArrayRange.getEnd(), longBuffer);\n+            long range = max - min + 1;\n+            \n+            // It's too expensive to check every geohash in the range to see if it\n+            // intersects with the original query geometry, so we will attempt to project\n+            // this range to an equivalent range at a lower granularity tier to minimize\n+            // the number of geohashes we need to check. By doing this, we can adjust\n+            // the level of granularity used to prune our ranges.\n+            // This is controlled by modifying the chunks per range. Higher chunks per\n+            // range will achieve greater pruning, but will be more expensive to compute,\n+            // and will introduce more query ranges (which has performance implications\n+            // as well).\n+            for (int curTier = 0; curTier <= tier; curTier++) {\n+                long scale = (long) Math.pow(2.0, 2.0 * (tier - curTier));\n+                \n+                if (range >= scale) {\n+                    long scaledMin = (long) Math.ceil((double) min / scale);\n+                    long scaledMax = max / scale;\n+                    \n+                    if ((scaledMax - scaledMin + 1) >= rangeSplitThreshold) {\n+                        boolean simplifiedRanges = false;\n+                        long subRangeMin = scaledMin * scale;\n+                        long subRangeMax = Long.MIN_VALUE;\n+                        \n+                        for (long scaledPos = scaledMin; scaledPos <= scaledMax; scaledPos++) {\n+                            long nextSubRangeMax = (scaledPos * scale + scale - 1);\n+                            \n+                            if (nextSubRangeMax <= max) {\n+                                simplifiedRanges = true;\n+                                subRangeMax = nextSubRangeMax;\n+                                \n+                                // make sure that this condensed hash is within the bounds of the map\n+                                ByteArrayId scaledId = createByteArrayId(curTier, scaledPos, longBuffer);\n+                                MultiDimensionalNumericData scaledBounds = GeometryNormalizer.indexStrategy.getRangeForId(scaledId);\n+                                \n+                                // make sure that the scaled id is within the bounds of the map\n+                                // note: all cells for tiers 0 and 1 are within the bounds of the map\n+                                if (curTier <= 1 || inBounds(scaledBounds)) {\n+                                    \n+                                    Geometry scaledGeom = null;\n+                                    if (curTier <= 1) {\n+                                        // @formatter:off\n+                                        scaledGeom = gf.toGeometry(\n+                                                new Envelope(\n+                                                        scaledBounds.getMinValuesPerDimension()[0],\n+                                                        scaledBounds.getMaxValuesPerDimension()[0],\n+                                                        Math.max(-90, scaledBounds.getMinValuesPerDimension()[1]),\n+                                                        Math.min(90, scaledBounds.getMaxValuesPerDimension()[1])));\n+                                        // @formatter:on\n+                                    } else {\n+                                        // @formatter:off\n+                                        scaledGeom = gf.toGeometry(\n+                                                new Envelope(\n+                                                        scaledBounds.getMinValuesPerDimension()[0],\n+                                                        scaledBounds.getMaxValuesPerDimension()[0],\n+                                                        scaledBounds.getMinValuesPerDimension()[1],\n+                                                        scaledBounds.getMaxValuesPerDimension()[1]));\n+                                        // @formatter:on\n+                                    }\n+                                    \n+                                    // make sure that the scaled geometry intersects the original query geometry\n+                                    if (scaledGeom.intersects(queryGeometry)) {\n+                                        byteArrayRanges.add(createByteArrayRange(tier, scaledPos * scale, scaledPos * scale + scale - 1, longBuffer));\n+                                    }\n+                                }\n+                            } else {\n+                                break;\n+                            }\n+                        }\n+                        \n+                        if (simplifiedRanges) {\n+                            if (min < subRangeMin && rangeToGeometry(tier, min, subRangeMin - 1).intersects(queryGeometry)) {\n+                                byteArrayRanges.add(createByteArrayRange(tier, min, subRangeMin - 1, longBuffer));\n+                            }\n+                            \n+                            if (max > subRangeMax && rangeToGeometry(tier, subRangeMax + 1, max).intersects(queryGeometry)) {\n+                                byteArrayRanges.add(createByteArrayRange(tier, subRangeMax + 1, max, longBuffer));\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            \n+            if (byteArrayRanges.isEmpty()) {\n+                if (rangeToGeometry(tier, min, max).intersects(queryGeometry))\n+                    byteArrayRanges.add(byteArrayRange);\n+            } else {\n+                if (byteArrayRanges.size() > 1)\n+                    byteArrayRanges = mergeContiguousRanges(byteArrayRanges, longBuffer);\n+                if (!byteArrayRanges.isEmpty())\n+                    byteArrayRanges = splitLargeRanges(byteArrayRanges, queryGeometry, maxRangeOverlap, longBuffer);\n+            }\n+        }\n+        \n+        return byteArrayRanges;\n+    }\n+    \n+    /**\n+     * Merges contiguous ranges in the list - assumes that the list of ranges is already sorted\n+     * \n+     * @param byteArrayRanges\n+     *            the sorted list of ranges to merge\n+     * @return a list of merged ranges\n+     */\n+    public static List<ByteArrayRange> mergeContiguousRanges(List<ByteArrayRange> byteArrayRanges) {\n+        return mergeContiguousRanges(byteArrayRanges, null);\n+    }\n+    \n+    /**\n+     * Merges contiguous ranges in the list - assumes that the list of ranges is already sorted\n+     * \n+     * @param byteArrayRanges\n+     *            the sorted list of ranges to merge\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of merged ranges\n+     */\n+    public static List<ByteArrayRange> mergeContiguousRanges(List<ByteArrayRange> byteArrayRanges, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> mergedByteArrayRanges = new ArrayList<>(byteArrayRanges.size());\n+        ByteArrayRange currentRange = null;\n+        \n+        for (ByteArrayRange range : byteArrayRanges) {\n+            if (currentRange == null) {\n+                currentRange = range;\n+            } else {\n+                long currentMax = decodePosition(currentRange.getEnd(), longBuffer);\n+                long nextMin = decodePosition(range.getStart(), longBuffer);\n+                \n+                if ((currentMax + 1) == nextMin) {\n+                    currentRange = new ByteArrayRange(currentRange.getStart(), range.getEnd(), false);\n+                } else {\n+                    mergedByteArrayRanges.add(currentRange);\n+                    currentRange = range;\n+                }\n+            }\n+        }\n+        \n+        if (currentRange != null) {\n+            mergedByteArrayRanges.add(currentRange);\n+        }\n+        \n+        return mergedByteArrayRanges;\n+    }\n+    \n+    /**\n+     * Splits ranges whose area overlaps more than maxRangeOverlap of the area of the queryGeometry envelope.\n+     * \n+     * @param byteArrayRanges\n+     *            the list of ranges to split\n+     * @param queryGeometry\n+     *            the original query geometry\n+     * @param maxRangeOverlap\n+     *            the maximum percentage overlap allowed for a range compared to the envelope of the original query geometry\n+     * @return a list of ranges, each of which overlaps less than maxRangeOverlap of the original query geometry\n+     */\n+    public static List<ByteArrayRange> splitLargeRanges(List<ByteArrayRange> byteArrayRanges, Geometry queryGeometry, double maxRangeOverlap) {\n+        return splitLargeRanges(byteArrayRanges, queryGeometry, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Splits ranges whose area overlaps more than maxRangeOverlap of the area of the queryGeometry envelope.\n+     * \n+     * @param byteArrayRanges\n+     *            the list of ranges to split\n+     * @param queryGeometry\n+     *            the original query geometry\n+     * @param maxRangeOverlap\n+     *            the maximum percentage overlap allowed for a range compared to the envelope of the original query geometry\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of ranges, each of which overlaps less than maxRangeOverlap of the original query geometry\n+     */\n+    public static List<ByteArrayRange> splitLargeRanges(List<ByteArrayRange> byteArrayRanges, Geometry queryGeometry, double maxRangeOverlap,\n+                    ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> splitByteArrayRanges = new ArrayList<>();\n+        \n+        for (ByteArrayRange range : byteArrayRanges) {\n+            int tier = decodeTier(range.getStart());\n+            long min = decodePosition(range.getStart(), longBuffer);\n+            long max = decodePosition(range.getEnd(), longBuffer);\n+            \n+            Geometry rangeGeometry = rangeToGeometry(tier, min, max);\n+            if (rangeGeometry.getArea() > maxRangeOverlap * queryGeometry.getEnvelope().getArea()) {\n+                int numSubRanges = (int) (rangeGeometry.getArea() / (maxRangeOverlap * queryGeometry.getEnvelope().getArea())) + 1;\n+                long offset = (max - min) / numSubRanges;\n+                \n+                for (int i = 0; i < numSubRanges; i++) {\n+                    long subMax = ((i + 1) == numSubRanges) ? max : min + (i + 1) * offset - 1;\n+                    splitByteArrayRanges.add(createByteArrayRange(tier, min + i * offset, subMax, longBuffer));\n+                }\n+            } else {\n+                splitByteArrayRanges.add(range);\n+            }\n+        }\n+        return splitByteArrayRanges;\n+    }\n+    \n+    /**\n+     * Extracts the tier from the GeoWave geohash\n+     *\n+     * @param geohash\n+     * @return\n+     */\n+    public static int decodeTier(String geohash) {\n+        return Integer.parseInt(geohash.substring(0, 2), 16);\n+    }\n+    \n+    /**\n+     * Extracts the tier from the byteArrayId\n+     * \n+     * @param byteArrayId\n+     * @return\n+     */\n+    public static int decodeTier(ByteArrayId byteArrayId) {\n+        return byteArrayId.getBytes()[0];\n+    }\n+    \n+    /**\n+     * Extracts the position from the GeoWave geohash\n+     * \n+     * @param geohash\n+     * @return\n+     */\n+    public static long decodePosition(String geohash) {\n+        return geohash.equals(\"00\") ? 0L : Long.parseLong(geohash.substring(2), 16);\n+    }\n+    \n+    /**\n+     * Extracts the position from the byteArrayId\n+     * \n+     * @param byteArrayId\n+     * @return\n+     */\n+    public static long decodePosition(ByteArrayId byteArrayId) {\n+        return decodePosition(byteArrayId, null);\n+    }\n+    \n+    /**\n+     * Extracts the position from the byteArrayId\n+     * \n+     * @param byteArrayId\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static long decodePosition(ByteArrayId byteArrayId, ByteBuffer longBuffer) {\n+        if (byteArrayId.getBytes()[0] != (byte) 0) {\n+            longBuffer = initLongBuffer(longBuffer);\n+            \n+            for (int i = 0; i < (Long.BYTES - (byteArrayId.getBytes().length - 1)); i++)\n+                longBuffer.put((byte) 0);\n+            \n+            longBuffer.put(byteArrayId.getBytes(), 1, byteArrayId.getBytes().length - 1);\n+            return longBuffer.getLong(0);\n+        } else {\n+            return 0L;\n+        }\n+    }\n+    \n+    /**\n+     * Determines the number of hex characters needed to represent a position at a given tier. This excludes the byte reserved for the tier identifier.\n+     * \n+     * @param tier\n+     * @return\n+     */\n+    public static int hexCharsPerTier(int tier) {\n+        String hexString = String.format(\"%X\", ((long) Math.pow(2.0, tier) - 1));\n+        if (Long.parseLong(hexString, 16) == 0)\n+            return 0;\n+        else\n+            return hexString.length() * 2;\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given GeoWave geohash\n+     * \n+     * @param geohash\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(String geohash) {\n+        return createByteArrayId(geohash, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given tier and position\n+     *\n+     * @param tier\n+     * @param position\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(int tier, long position) {\n+        return createByteArrayId(tier, position, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given GeoWave geohash\n+     * \n+     * @param geohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(String geohash, ByteBuffer longBuffer) {\n+        return createByteArrayId(decodeTier(geohash), decodePosition(geohash), longBuffer);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given tier and position\n+     * \n+     * @param tier\n+     * @param position\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(int tier, long position, ByteBuffer longBuffer) {\n+        if (tier != 0) {\n+            longBuffer = initLongBuffer(longBuffer);\n+            \n+            ByteBuffer buffer = ByteBuffer.allocate(hexCharsPerTier(tier) / 2 + 1);\n+            buffer.put((byte) tier);\n+            longBuffer.putLong(position);\n+            buffer.put(longBuffer.array(), longBuffer.capacity() - buffer.remaining(), buffer.remaining());\n+            \n+            return new ByteArrayId(buffer.array());\n+        } else {\n+            return new ByteArrayId(new byte[] {0});\n+        }\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given start and end GeoWave geohashes\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(String startGeohash, String endGeohash) {\n+        return createByteArrayRange(startGeohash, endGeohash, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given tier, and min and max positions\n+     * \n+     * @param tier\n+     * @param min\n+     * @param max\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(int tier, long min, long max) {\n+        return createByteArrayRange(tier, min, max, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given start and end GeoWave geohashes\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(String startGeohash, String endGeohash, ByteBuffer longBuffer) {\n+        return createByteArrayRange(decodeTier(startGeohash), decodePosition(startGeohash), decodePosition(endGeohash), longBuffer);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given tier, and min and max positions\n+     * \n+     * @param tier\n+     * @param min\n+     * @param max\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(int tier, long min, long max, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        return new ByteArrayRange(createByteArrayId(tier, min, longBuffer), createByteArrayId(tier, max, longBuffer), min == max);\n+    }\n+    \n+    /**\n+     * Determines whether the given bounds are within the bounds of the map.\n+     * \n+     * @param bounds\n+     * @return\n+     */\n+    private static boolean inBounds(MultiDimensionalNumericData bounds) {\n+        // @formatter:off\n+        return bounds.getMinValuesPerDimension()[0] >= -180 && bounds.getMinValuesPerDimension()[0] <= 180 &&\n+                bounds.getMaxValuesPerDimension()[0] >= -180 && bounds.getMaxValuesPerDimension()[0] <= 180 &&\n+                bounds.getMinValuesPerDimension()[1] >= -90 && bounds.getMinValuesPerDimension()[1] <= 90 &&\n+                bounds.getMaxValuesPerDimension()[1] >= -90 && bounds.getMaxValuesPerDimension()[1] <= 90;\n+        // @formatter:on\n+    }\n+    \n+    /**\n+     * Given a GeoWave geohash position, this will generate a Geometry which represents that position.\n+     * \n+     * @param geohash\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(String geohash) {\n+        return positionToGeometry(geohash, null);\n+    }\n+    \n+    /**\n+     * Given a position at a given tier, this will generate a Geometry which represents that position.\n+     * \n+     * @param tier\n+     * @param position\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(int tier, long position) {\n+        return positionToGeometry(tier, position, null);\n+    }\n+    \n+    /**\n+     * Given a GeoWave geohash position, this will generate a Geometry which represents that position.\n+     * \n+     * @param geohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(String geohash, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        return positionToGeometry(createByteArrayId(geohash, longBuffer));\n+    }\n+    \n+    /**\n+     * Given a position at a given tier, this will generate a Geometry which represents that position.\n+     * \n+     * @param tier\n+     * @param position\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(int tier, long position, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        return positionToGeometry(createByteArrayId(tier, position, longBuffer));\n+    }\n+    \n+    /**\n+     * Given a byteArrayId, this will generate a Geometry which represents that position.\n+     * \n+     * @param byteArrayId\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(ByteArrayId byteArrayId) {\n+        MultiDimensionalNumericData bounds = GeometryNormalizer.indexStrategy.getRangeForId(byteArrayId);\n+        \n+        if (decodeTier(byteArrayId) <= 1) {\n+            // @formatter:off\n+            return new GeometryFactory().toGeometry(\n+                    new Envelope(\n+                            bounds.getMinValuesPerDimension()[0],\n+                            bounds.getMaxValuesPerDimension()[0],\n+                            Math.max(-90, bounds.getMinValuesPerDimension()[1]),\n+                            Math.min(90, bounds.getMaxValuesPerDimension()[1])));\n+            // @formatter:on\n+        } else {\n+            // @formatter:off\n+            return new GeometryFactory().toGeometry(\n+                    new Envelope(\n+                            bounds.getMinValuesPerDimension()[0],\n+                            bounds.getMaxValuesPerDimension()[0],\n+                            bounds.getMinValuesPerDimension()[1],\n+                            bounds.getMaxValuesPerDimension()[1]));\n+            // @formatter:on\n+        }\n+    }\n+    \n+    /**\n+     * Given a range defined by the start and end geohashes, this will generate a Geometry which represents that range.\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(String startGeohash, String endGeohash) {\n+        return rangeToGeometry(startGeohash, endGeohash, null);\n+    }\n+    \n+    /**\n+     * Given a range defined by the start and end geohashes, this will generate a Geometry which represents that range.\n+     * \n+     * @param byteArrayRange\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(ByteArrayRange byteArrayRange) {\n+        return rangeToGeometry(byteArrayRange, null);\n+    }\n+    \n+    /**\n+     * Given a range at a given tier, this will generate a Geometry which represents that range.\n+     *\n+     * @param tier\n+     * @param start\n+     * @param end\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(int tier, long start, long end) {\n+        return rangeToGeometry(tier, start, end, null);\n+    }\n+    \n+    /**\n+     * Given a range defined by the start and end geohashes, this will generate a Geometry which represents that range.\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(String startGeohash, String endGeohash, ByteBuffer longBuffer) {\n+        return rangeToGeometry(decodeTier(startGeohash), decodePosition(startGeohash), decodePosition(endGeohash), longBuffer);\n+    }\n+    \n+    /**\n+     * Given a range defined by byteArrayRange, this will generate a Geometry which represents that range.\n+     * \n+     * @param byteArrayRange\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(ByteArrayRange byteArrayRange, ByteBuffer longBuffer) {\n+        return rangeToGeometry(decodeTier(byteArrayRange.getStart()), decodePosition(byteArrayRange.getStart()), decodePosition(byteArrayRange.getEnd()),\n+                        longBuffer);\n+    }\n+    \n+    /**\n+     * Given a range at a given tier, this will generate a Geometry which represents that range.\n+     * \n+     * @param tier\n+     * @param start\n+     * @param end\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(int tier, long start, long end, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        GeometryFactory gf = new GeometryFactory();\n+        \n+        List<ByteArrayId> byteArrayIds = decomposeRange(tier, start, end, longBuffer);\n+        \n+        List<Geometry> geometries = new ArrayList<>(byteArrayIds.size());\n+        for (ByteArrayId byteArrayId : byteArrayIds) {\n+            MultiDimensionalNumericData bounds = GeometryNormalizer.indexStrategy.getRangeForId(byteArrayId);\n+            \n+            if (decodeTier(byteArrayId) <= 1) {\n+                // @formatter:off\n+                geometries.add(gf.toGeometry(\n+                        new Envelope(\n+                                bounds.getMinValuesPerDimension()[0],\n+                                bounds.getMaxValuesPerDimension()[0],\n+                                Math.max(-90, bounds.getMinValuesPerDimension()[1]),\n+                                Math.min(90, bounds.getMaxValuesPerDimension()[1]))));\n+                // @formatter:on\n+            } else if (inBounds(bounds)) {\n+                // @formatter:off\n+                geometries.add(gf.toGeometry(\n+                        new Envelope(\n+                                bounds.getMinValuesPerDimension()[0],\n+                                bounds.getMaxValuesPerDimension()[0],\n+                                bounds.getMinValuesPerDimension()[1],\n+                                bounds.getMaxValuesPerDimension()[1])));\n+                // @formatter:on\n+            }\n+        }", "originalCommit": "5f39f0deda142118eb78dce2c4c240f061dcfbd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4ODYxOQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422288619", "bodyText": "I think the latest commit has this covered.", "author": "jwomeara", "createdAt": "2020-05-08T18:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MDgxOA=="}], "type": "inlineReview"}, {"oid": "e075bdb05ccfa068400abf7dfe50d8de20a11cfd", "url": "https://github.com/NationalSecurityAgency/datawave/commit/e075bdb05ccfa068400abf7dfe50d8de20a11cfd", "message": "Added logic to produce tighter ranges for queries against geowave indexed terms.", "committedDate": "2020-05-19T19:12:19Z", "type": "commit"}, {"oid": "769b69dd2c2bc31c49584e4f8aaf8a65be50ca4c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/769b69dd2c2bc31c49584e4f8aaf8a65be50ca4c", "message": "docs fix", "committedDate": "2020-05-19T19:12:20Z", "type": "commit"}, {"oid": "a20660916325d5ab3a283784f84ef8827ec5907a", "url": "https://github.com/NationalSecurityAgency/datawave/commit/a20660916325d5ab3a283784f84ef8827ec5907a", "message": "pr feedback.", "committedDate": "2020-05-19T19:34:17Z", "type": "commit"}, {"oid": "a20660916325d5ab3a283784f84ef8827ec5907a", "url": "https://github.com/NationalSecurityAgency/datawave/commit/a20660916325d5ab3a283784f84ef8827ec5907a", "message": "pr feedback.", "committedDate": "2020-05-19T19:34:17Z", "type": "forcePushed"}, {"oid": "ca8d631bbc65ad60b98054172f7a3a9fc3c95b2c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/ca8d631bbc65ad60b98054172f7a3a9fc3c95b2c", "message": "Merge branch 'release/version2.9' into feature/geoImprovements", "committedDate": "2020-05-29T12:38:24Z", "type": "commit"}, {"oid": "ff225fe4852f4a68bf00c6ec8320bf08242791e8", "url": "https://github.com/NationalSecurityAgency/datawave/commit/ff225fe4852f4a68bf00c6ec8320bf08242791e8", "message": "Merge branch 'release/version2.9' into feature/geoImprovements", "committedDate": "2020-06-23T12:58:10Z", "type": "commit"}, {"oid": "cf2a8ac5cbeadd9560c53bbfa238b7b6949c1838", "url": "https://github.com/NationalSecurityAgency/datawave/commit/cf2a8ac5cbeadd9560c53bbfa238b7b6949c1838", "message": "Merge branch 'release/version2.9' into feature/geoImprovements", "committedDate": "2020-07-29T19:24:22Z", "type": "commit"}]}