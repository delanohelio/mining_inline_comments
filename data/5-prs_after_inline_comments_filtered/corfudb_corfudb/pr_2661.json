{"pr_number": 2661, "pr_title": "File descriptor leaks corfu 0.3.0.2", "pr_createdAt": "2020-07-27T17:21:23Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2661", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM0MjU0Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r461342546", "bodyText": "Where is the epoch checks for reads?", "author": "Maithem", "createdAt": "2020-07-28T06:16:13Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -272,40 +293,44 @@ public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IS\n         boolean cacheable = msg.getPayload().isCacheReadResult();\n         log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddress(), cacheable);\n \n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            ILogData logData = dataCache.get(address, cacheable);\n-            if (logData == null) {\n-                rr.put(address, LogData.getEmpty(address));\n-            } else {\n-                rr.put(address, (LogData) logData);\n+        logUnitLock.acquireReadLockAndExecuteSync(() -> {\n+            ReadResponse rr = new ReadResponse();\n+            try {\n+                ILogData logData = dataCache.get(address, cacheable);\n+                if (logData == null) {\n+                    rr.put(address, LogData.getEmpty(address));\n+                } else {\n+                    rr.put(address, (LogData) logData);\n+                }\n+                r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n+            } catch (DataCorruptionException e) {\n+                log.error(\"Data corruption exception while reading address {}\", address, e);\n+                r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n             }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            log.error(\"Data corruption exception while reading address {}\", address, e);\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n-        }\n+        });\n     }\n \n     @ServerHandler(type = CorfuMsgType.MULTIPLE_READ_REQUEST)\n     public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n         boolean cacheable = msg.getPayload().isCacheReadResult();\n         log.trace(\"multiRead: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n \n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            for (Long address : msg.getPayload().getAddresses()) {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n+        logUnitLock.acquireReadLockAndExecuteSync(() -> {", "originalCommit": "39d3f163d119c85b6e8a609dae1b1352dc1126a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MjY0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r462482641", "bodyText": "fixed", "author": "xnull", "createdAt": "2020-07-29T17:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM0MjU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM0Nzc1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r461347756", "bodyText": "I think this style is an overkill. It's kind of convoluted. If you still wan't to use this, then I suggest moving the code to the entry point, which is processRequest, it's more centralized that way.\nAlso, wouldn't this swallow the exception ? On master, at least it's logged with uncaughtException.\nAnother cleaner solution  to consider is to shutdown the LogUnit executor and execute the reset logic on the IO thread. After the reset logic completes you can install a new executor. That way in-flight operations will time out on transition. As opposed to be being evaluated with an older epoch.", "author": "Maithem", "createdAt": "2020-07-28T06:29:45Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -472,4 +507,57 @@ public static LogUnitServerConfig parse(Map<String, Object> opts) {\n                     .build();\n         }\n     }\n+\n+    public static class LogUnitLock {\n+        private final ReadWriteLock resetLock = new ReentrantReadWriteLock();\n+\n+        private void acquireReadLockAndExecuteSync(Runnable action) {\n+\n+            acquireReadLock()\n+                    .thenApply(lock -> {\n+                        action.run();\n+                        return lock;\n+                    })\n+                    .whenComplete((lock, err) -> lock.unlock());", "originalCommit": "39d3f163d119c85b6e8a609dae1b1352dc1126a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MzcxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r462483717", "bodyText": "I deleted LogUnitLock\nchanged", "author": "xnull", "createdAt": "2020-07-29T17:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM0Nzc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2MzQxMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r462763412", "bodyText": "Shouldn't this be based on serverContext.getLogUnitEpochWaterMark()?", "author": "Maithem", "createdAt": "2020-07-30T06:28:51Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -272,18 +290,29 @@ public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IS\n         boolean cacheable = msg.getPayload().isCacheReadResult();\n         log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddress(), cacheable);\n \n-        ReadResponse rr = new ReadResponse();\n+        Lock lock = resetLock.readLock();\n+        lock.lock();\n+\n         try {\n-            ILogData logData = dataCache.get(address, cacheable);\n-            if (logData == null) {\n-                rr.put(address, LogData.getEmpty(address));\n-            } else {\n-                rr.put(address, (LogData) logData);\n+            if (msg.getEpoch() != serverContext.getServerEpoch()) {\n+                throw new WrongEpochException(serverContext.getServerEpoch());", "originalCommit": "f776abef05681aff377ac1f17e6a175e18eee62a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzMTE2Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463231162", "bodyText": "What's the motivation for that?", "author": "xnull", "createdAt": "2020-07-30T19:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2MzQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUwODM4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463508380", "bodyText": "The motivation is \"consistency\". The batch processor will fail requests based on LogUnitEpochWaterMark and not ServerEpoch", "author": "Maithem", "createdAt": "2020-07-31T09:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2MzQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMDQ1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463730456", "bodyText": "fixed", "author": "xnull", "createdAt": "2020-07-31T17:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2MzQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2NDA4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r462764081", "bodyText": "Can you put a comment to indicate that this has to be a synchronous call for the lock to take effect.", "author": "Maithem", "createdAt": "2020-07-30T06:30:26Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -383,28 +438,39 @@ public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n     private synchronized void resetLogUnit(CorfuPayloadMsg<Long> msg,\n                                            ChannelHandlerContext ctx, IServerRouter r) {\n \n+        if (msg.getPayload() <= serverContext.getLogUnitEpochWaterMark()\n+                || msg.getPayload() != serverContext.getServerEpoch()) {\n+            log.info(\"LogUnit Server Reset request received but reset already done.\");\n+            r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n+            return;\n+        }\n+\n         // Check if the reset request is with an epoch greater than the last reset epoch seen to\n-        // prevent multiple reset in the same epoch. and should be equal to the current router\n+        // prevent multiple reset in the same epoch and should be equal to the current router\n         // epoch to prevent stale reset requests from wiping out the data.\n-        if (msg.getPayload() > serverContext.getLogUnitEpochWaterMark()\n-                && msg.getPayload() == serverContext.getServerEpoch()) {\n-            serverContext.setLogUnitEpochWaterMark(msg.getPayload());\n-            batchWriter.addTask(RESET, msg)\n+        serverContext.setLogUnitEpochWaterMark(msg.getPayload());\n+\n+        Lock lock = resetLock.writeLock();\n+        lock.lock();\n+\n+        try {\n+            CompletableFuture<Void> cf = batchWriter\n+                    .addTask(RESET, msg)\n                     .thenRun(() -> {\n                         dataCache.invalidateAll();\n                         log.info(\"LogUnit Server Reset.\");\n                         r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n-                    }).exceptionally(ex -> {\n-                handleException(ex, ctx, msg, r);\n-                return null;\n-            });\n-        } else {\n-            log.info(\"LogUnit Server Reset request received but reset already done.\");\n-            r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n+                    })\n+                    .exceptionally(ex -> {\n+                        handleException(ex, ctx, msg, r);\n+                        return null;\n+                    });\n+            cf.join();", "originalCommit": "f776abef05681aff377ac1f17e6a175e18eee62a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzMjg3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463232879", "bodyText": "done", "author": "xnull", "createdAt": "2020-07-30T19:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2NDA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2NTAyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r462765027", "bodyText": "ERROR_DATA_CORRUPTION.msg() need to pass a long here. Please pull in #2612", "author": "Maithem", "createdAt": "2020-07-30T06:33:05Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -292,19 +321,30 @@ public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerCo\n         boolean cacheable = msg.getPayload().isCacheReadResult();\n         log.trace(\"multiRead: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n \n-        ReadResponse rr = new ReadResponse();\n+        Lock lock = resetLock.readLock();\n+        lock.lock();\n+\n         try {\n-            for (Long address : msg.getPayload().getAddresses()) {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n+            ReadResponse rr = new ReadResponse();\n+            try {\n+                if (msg.getEpoch() != serverContext.getServerEpoch()) {\n+                    throw new WrongEpochException(serverContext.getServerEpoch());\n                 }\n+\n+                for (Long address : msg.getPayload().getAddresses()) {\n+                    ILogData logData = dataCache.get(address, cacheable);\n+                    if (logData == null) {\n+                        rr.put(address, LogData.getEmpty(address));\n+                    } else {\n+                        rr.put(address, (LogData) logData);\n+                    }\n+                }\n+                r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n+            } catch (DataCorruptionException e) {\n+                r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());", "originalCommit": "f776abef05681aff377ac1f17e6a175e18eee62a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyOTIzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463229231", "bodyText": "MULTIPLE_READ_REQUEST and KNOWN_ADDRESS_REQUEST has a bug, please rebase on #2612", "author": "Maithem", "createdAt": "2020-07-30T19:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzMDY2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463230669", "bodyText": "#2612 should be merged into corfu-0.3.0.2 otherwise I can't merge into my PR directly", "author": "xnull", "createdAt": "2020-07-30T19:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyNDk1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463324958", "bodyText": "So you didn't want to rebase because of the conflicts ? lel\nHere's the rebased version #2674", "author": "Maithem", "createdAt": "2020-07-30T23:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzODk0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463338945", "bodyText": "Did I say that?\nWhy you don't want merge #2612 into 0.3.0.2 branch?", "author": "xnull", "createdAt": "2020-07-31T00:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MjI3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463352275", "bodyText": "This is part of your patch, and you said you were done. It's reasonable to assume that you would do it, so I wasn't sure why you are waiting for me to cherry-pick it. Anyways, in the interest of time I did it on your behalf.", "author": "Maithem", "createdAt": "2020-07-31T01:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2NTAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NTAzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463355037", "bodyText": "#2612 is another PR, I don't quite see why you want to mix it with this pr, why not just bring it to 0.3.0.2 separately, then I can get it from 0.3.0.2.\nAnyways, let's merge #2674 and finish this conversation, don't you agree?", "author": "xnull", "createdAt": "2020-07-31T01:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2NTAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2OTgyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r462769822", "bodyText": "You have to send back a WRONG_EPOCH and not throw an exception. Otherwise, the exception wont be handled.", "author": "Maithem", "createdAt": "2020-07-30T06:42:42Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -292,19 +321,30 @@ public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerCo\n         boolean cacheable = msg.getPayload().isCacheReadResult();\n         log.trace(\"multiRead: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n \n-        ReadResponse rr = new ReadResponse();\n+        Lock lock = resetLock.readLock();\n+        lock.lock();\n+\n         try {\n-            for (Long address : msg.getPayload().getAddresses()) {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n+            ReadResponse rr = new ReadResponse();\n+            try {\n+                if (msg.getEpoch() != serverContext.getServerEpoch()) {\n+                    throw new WrongEpochException(serverContext.getServerEpoch());", "originalCommit": "f776abef05681aff377ac1f17e6a175e18eee62a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzMzY3Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463233672", "bodyText": "fixed", "author": "xnull", "createdAt": "2020-07-30T19:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2OTgyMg=="}], "type": "inlineReview"}, {"oid": "760637155fb9c0aca3bee8947d1d7952d4ceca27", "url": "https://github.com/CorfuDB/CorfuDB/commit/760637155fb9c0aca3bee8947d1d7952d4ceca27", "message": "fdl", "committedDate": "2020-07-31T17:07:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc3NTE0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r463775147", "bodyText": "Might be a perf issue, not sure thought.", "author": "Maithem", "createdAt": "2020-07-31T18:50:03Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -128,13 +138,40 @@ public LogUnitServer(ServerContext serverContext) {\n         dataCache = new LogUnitServerCache(config, streamLog);\n         batchWriter = new BatchProcessor(streamLog, serverContext.getServerEpoch(), !config.isNoSync());\n \n-        logCleaner = new StreamLogCompaction(streamLog, 10, 45, TimeUnit.MINUTES, ServerContext.SHUTDOWN_TIMER);\n+        logCleaner = new StreamLogCompaction(\n+                streamLog, resetLock, 10, 45, TimeUnit.MINUTES, ServerContext.SHUTDOWN_TIMER\n+        );\n     }\n \n \n     @Override\n     protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        executor.submit(() -> getHandler().handle(msg, ctx, r));\n+        executor.submit(\n+                () -> {\n+                    switch (msg.getMsgType()) {\n+                        case READ_REQUEST:\n+                        case KNOWN_ADDRESS_REQUEST:\n+                        case COMPACT_REQUEST:\n+                            Lock lock = resetLock.readLock();\n+                            lock.lock();\n+\n+                            if (msg.getEpoch() != serverContext.getLogUnitEpochWaterMark()) {\n+                                r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH,", "originalCommit": "760637155fb9c0aca3bee8947d1d7952d4ceca27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0NTQ3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r465245471", "bodyText": "Could we have some comments on this read-write lock? Like how it should be used in the future?\nAnd looks like this PR is pretty different from #2616 , is this PR a subset?", "author": "zhangn49", "createdAt": "2020-08-04T18:25:56Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -102,6 +107,8 @@\n \n     private ExecutorService executor;\n \n+    private final ReadWriteLock resetLock = new ReentrantReadWriteLock();", "originalCommit": "d360d82af3b0eee553e19a94d26c34edacc00311", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4OTc4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r465289782", "bodyText": "comments - done.\nThis is a small fix for 0.3.0.2, yes it's different.", "author": "xnull", "createdAt": "2020-08-04T19:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0NTQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjM4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r464752382", "bodyText": "I think the lock should be put in streamLogFiles instead of here because most of the read requests are served by the cache, which doesn't require a lock, having a lock will be a waste in terms of performance. Also in-memory stream log does not require lock at any time.", "author": "WenbinZhu", "createdAt": "2020-08-04T01:51:02Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -273,26 +291,34 @@ public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IS\n             log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n         }\n \n-        ReadResponse rr = new ReadResponse();\n+        Lock lock = resetLock.readLock();\n+        lock.lock();", "originalCommit": "d360d82af3b0eee553e19a94d26c34edacc00311", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzMDkxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r466630918", "bodyText": "We can't move it to StreamLog because we need the lock, in StreamLogCompaction class.\nAlso, we need to get a lock before we start reading data and we need to check epoch, so we need to prevent a message getting into BatchProcessor.\nWe have to use lock in LogUnitServer", "author": "xnull", "createdAt": "2020-08-06T19:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzODI5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r466638299", "bodyText": "You don't need a lock for StreamLogCompaction, the compactor only deletes files that are less than trim mark, that no readers can read, even you need the lock, you can create lock here, but call lock() inside it.\n\n\nReads don't go to BatchProcessor at all, so I don't know where is your epoch check...", "author": "WenbinZhu", "createdAt": "2020-08-06T19:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwODExNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r466808115", "bodyText": "having a lock will be a waste in terms of performance.\n\ncan you please explain how it can be possible?", "author": "xnull", "createdAt": "2020-08-07T04:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MTU0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467181541", "bodyText": "Also, I was thinking about your argument and come up with the statement, which sounds like this - the most important thing is: you probably don't want to read data from the cache if you actually don't have data in your database.\nIt is a data inconsistency problem. That's why we need to have rwLock in LogUnitServer, when we reset LoUnit we have to clean cache, and only then we can read from the cache.", "author": "xnull", "createdAt": "2020-08-07T17:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE2NTA2Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r468165062", "bodyText": "I think the concern here is that in the absence of reset calls the cost of acquiring a read lock will still be incurred despite the high probability of a cache hit.\n@xnull to address this issue, the lock doesn't have to be moved to StreamLogFiles, it can be moved to LogUnitServerCache::handleRetrieval that way the cost of the lock will only be incurred on a cache miss, which should have a low probability (since we usually see cache hit rates of ~90%).\n@WenbinZhu I think that there are other bottlenecks in the stack that we would hit before this being a problem. You can get some sense of read lock latency without contention here https://mechanical-sympathy.blogspot.com/2013/08/lock-based-vs-lock-free-concurrent.html", "author": "Maithem", "createdAt": "2020-08-10T20:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNjg1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r468216859", "bodyText": "LogUnitServer is an entry point for locks, I don't like the idea of moving it to underlying classes, it will make code more complex.", "author": "xnull", "createdAt": "2020-08-10T22:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxODA4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r468218085", "bodyText": "Locks are super fast, no need to optimize it, according to the article you have provided it's ~5million op/sec, which is ~20-30 times faster than reading from caffeine. The overall performance of reading from Corfu node is 5k per sec, do we really want to optimize lock with millions of ops per sec?", "author": "xnull", "createdAt": "2020-08-10T22:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMDk4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467310985", "bodyText": "The epoch check for reads was dropped from the last patch. Please re-add it.", "author": "Maithem", "createdAt": "2020-08-07T22:22:53Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -273,26 +295,34 @@ public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IS\n             log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n         }\n \n-        ReadResponse rr = new ReadResponse();\n+        Lock lock = resetLock.readLock();\n+        lock.lock();\n \n-        for (long address : msg.getPayload().getAddresses()) {\n-            try {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n+        try {\n+\n+            ReadResponse rr = new ReadResponse();\n+", "originalCommit": "412db26475a4a03628e90997a4453ebfb453dedc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxNTM4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467315385", "bodyText": "Forgot to move it from processRequest, my bad.\nAdded that check into processRequest for\n READ_REQUEST:\n KNOWN_ADDRESS_REQUEST:\n COMPACT_REQUEST:", "author": "xnull", "createdAt": "2020-08-07T22:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMDk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5NzE0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r468997145", "bodyText": "Unfortunately, the change break tests #2661 (comment)", "author": "xnull", "createdAt": "2020-08-12T04:24:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMDk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTgyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467311825", "bodyText": "Epoch check after lock.lock().", "author": "Maithem", "createdAt": "2020-08-07T22:26:00Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -303,26 +333,40 @@ public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IS\n     private void getKnownAddressesInRange(CorfuPayloadMsg<KnownAddressRequest> msg,\n                                           ChannelHandlerContext ctx, IServerRouter r) {\n \n-        KnownAddressRequest request = msg.getPayload();\n+        Lock lock = resetLock.readLock();\n+        lock.lock();\n+\n         try {\n-            Set<Long> knownAddresses = streamLog\n-                    .getKnownAddressesInRange(request.getStartRange(), request.getEndRange());\n-            r.sendResponse(ctx, msg,\n-                    CorfuMsgType.KNOWN_ADDRESS_RESPONSE.payloadMsg(knownAddresses));\n-        } catch (DataCorruptionException dc) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION\n-                    .payloadMsg(Address.NON_ADDRESS));\n-            return;\n-        } catch (Exception e) {\n-            handleException(e, ctx, msg, r);\n+            KnownAddressRequest request = msg.getPayload();\n+            try {", "originalCommit": "412db26475a4a03628e90997a4453ebfb453dedc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxNTQ5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467315499", "bodyText": "I have changed processRequest could you please take a look", "author": "xnull", "createdAt": "2020-08-07T22:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5NDIxOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r468994219", "bodyText": "@xnull Is epoch check missing here?", "author": "zhangn49", "createdAt": "2020-08-12T04:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5NTc5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r468995794", "bodyText": "As discussed twice the check will crash most of the unit tests, here is the build with the change https://travis-ci.org/github/CorfuDB/CorfuDB/builds/716015026", "author": "xnull", "createdAt": "2020-08-12T04:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5NjE4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r468996186", "bodyText": "also see my comment #2661 (comment)", "author": "xnull", "createdAt": "2020-08-12T04:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTkzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467311932", "bodyText": "epoch check after lock.", "author": "Maithem", "createdAt": "2020-08-07T22:26:23Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -303,26 +333,40 @@ public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IS\n     private void getKnownAddressesInRange(CorfuPayloadMsg<KnownAddressRequest> msg,\n                                           ChannelHandlerContext ctx, IServerRouter r) {\n \n-        KnownAddressRequest request = msg.getPayload();\n+        Lock lock = resetLock.readLock();\n+        lock.lock();\n+\n         try {\n-            Set<Long> knownAddresses = streamLog\n-                    .getKnownAddressesInRange(request.getStartRange(), request.getEndRange());\n-            r.sendResponse(ctx, msg,\n-                    CorfuMsgType.KNOWN_ADDRESS_RESPONSE.payloadMsg(knownAddresses));\n-        } catch (DataCorruptionException dc) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION\n-                    .payloadMsg(Address.NON_ADDRESS));\n-            return;\n-        } catch (Exception e) {\n-            handleException(e, ctx, msg, r);\n+            KnownAddressRequest request = msg.getPayload();\n+            try {\n+                Set<Long> knownAddresses = streamLog\n+                        .getKnownAddressesInRange(request.getStartRange(), request.getEndRange());\n+                r.sendResponse(ctx, msg,\n+                        CorfuMsgType.KNOWN_ADDRESS_RESPONSE.payloadMsg(knownAddresses));\n+            } catch (DataCorruptionException dc) {\n+                r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION\n+                        .payloadMsg(Address.NON_ADDRESS));\n+            } catch (Exception e) {\n+                handleException(e, ctx, msg, r);\n+            }\n+        } finally {\n+            lock.unlock();\n         }\n     }\n \n     @ServerHandler(type = CorfuMsgType.COMPACT_REQUEST)\n     private void handleCompactRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n         log.debug(\"handleCompactRequest: received a compact request {}\", msg);\n-        streamLog.compact();\n-        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n+\n+        Lock lock = resetLock.writeLock();\n+        lock.lock();\n+", "originalCommit": "412db26475a4a03628e90997a4453ebfb453dedc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5NTcyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r468995722", "bodyText": "As discussed twice the check will crash most of the unit tests, here is the build with the change https://travis-ci.org/github/CorfuDB/CorfuDB/builds/716015026", "author": "xnull", "createdAt": "2020-08-12T04:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTkzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5NjIxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r468996211", "bodyText": "also see my comment #2661 (comment)", "author": "xnull", "createdAt": "2020-08-12T04:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467312381", "bodyText": "Maybe your test can't trigger the issue because of this (which was causing the leak). Why was it dropped?", "author": "Maithem", "createdAt": "2020-08-07T22:28:17Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/log/StreamLogFiles.java", "diffHunk": "@@ -1275,7 +1281,7 @@ public void reset() {\n         dataStore.resetStartingAddress();\n         dataStore.resetTailSegment();\n         logMetadata = new LogMetadata();\n-        writeChannels.clear();", "originalCommit": "412db26475a4a03628e90997a4453ebfb453dedc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxNjIwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467316204", "bodyText": "Could you please explain your question?\nIt was dropped because if you clean this you will have FD leaks", "author": "xnull", "createdAt": "2020-08-07T22:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxODk5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467318998", "bodyText": "But if you have the locks protecting it, why adding this line could have the leaks? Does that mean the lock doesn't work at all?", "author": "WenbinZhu", "createdAt": "2020-08-07T22:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxOTM3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467319378", "bodyText": "The leak was happening due to a synchronization problem between when writeChannels.clear and writeChannels.computeIfAbsent , but the RW lock is suppose to solve this synchronization issue. So, I don't understand why writeChannels.clear(); has been removed.\nIF there are 4 segment handles [s1, s2, s3, s4] and the compaction mark is at 0, then a reset happens, then the same segment handles will be used to populate the state transfer data, which is incorrect. Essentially, your keeping the file channel handles in the map, but deleting the files underneath. What am I missing ?", "author": "Maithem", "createdAt": "2020-08-07T22:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMDA4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467320081", "bodyText": "btw closeSegmentHandlers() will also remove the handle from the wirteChannels", "author": "WenbinZhu", "createdAt": "2020-08-07T22:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMDQxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467320411", "bodyText": "Ah, I see.", "author": "Maithem", "createdAt": "2020-08-07T23:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMTUwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467321503", "bodyText": "But it still doesn't explain why removing this line could cause test to fail when lock is being added...", "author": "WenbinZhu", "createdAt": "2020-08-07T23:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMjAxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467322011", "bodyText": "I was asking @xnull , I didn't see the test failing without the writeschannel.clear call. I didn't try it myself.", "author": "Maithem", "createdAt": "2020-08-07T23:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyNzI3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467327273", "bodyText": "@Maithem I can't say for sure, my guess is somehow new segments get added after we execute closeSegmentHandlers and those segments get cleaned afterward by writeSegments.clean().\nI reproduced FD leaks one more time right now when I added epoch checks, and unfortunately, it has leaks.\nCleaning writeChannels prevents us from leaks.\nP.S. one small question - \n  \n    \n      CorfuDB/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java\n    \n    \n         Line 158\n      in\n      00f40e2\n    \n    \n    \n    \n\n        \n          \n           if (msg.getEpoch() != serverContext.getServerEpoch()) { \n        \n    \n  \n\n\nshould it be check for serverContext.getLogUnitEpochWaterMark() ?", "author": "xnull", "createdAt": "2020-08-07T23:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyODQzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467328432", "bodyText": "Just to be consistent getLogUnitEpochWaterMark should be used, because that's what the BatchProcessor uses.", "author": "Maithem", "createdAt": "2020-08-07T23:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMDAyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467330027", "bodyText": "ok, thanks", "author": "xnull", "createdAt": "2020-08-07T23:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMjU5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467322593", "bodyText": "Could you elaborate why this is checked here? From my understanding, a message type like READ_REQUEST or KNOWN_ADDRESS_REQUEST already have their epochs checked in the method epochIsValid from IServerRouter, since their ignoreEpoch fields are set as false. What's the difference between the getServerEpoch provided by the router versus the one provided by the context?", "author": "zfrenette", "createdAt": "2020-08-07T23:10:35Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -128,13 +141,34 @@ public LogUnitServer(ServerContext serverContext) {\n         dataCache = new LogUnitServerCache(config, streamLog);\n         batchWriter = new BatchProcessor(streamLog, serverContext.getServerEpoch(), !config.isNoSync());\n \n-        logCleaner = new StreamLogCompaction(streamLog, 10, 45, TimeUnit.MINUTES, ServerContext.SHUTDOWN_TIMER);\n+        logCleaner = new StreamLogCompaction(\n+                streamLog, resetLock, 10, 45, TimeUnit.MINUTES, ServerContext.SHUTDOWN_TIMER\n+        );\n     }\n \n \n     @Override\n     protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        executor.submit(() -> getHandler().handle(msg, ctx, r));\n+        executor.submit(\n+                () -> {\n+                    switch (msg.getMsgType()) {\n+                        case READ_REQUEST:\n+                        case KNOWN_ADDRESS_REQUEST:\n+                        case COMPACT_REQUEST:\n+                            if (msg.getEpoch() != serverContext.getServerEpoch()) {\n+                                CorfuPayloadMsg<Long> payload = new CorfuPayloadMsg<>(\n+                                        CorfuMsgType.WRONG_EPOCH,\n+                                        serverContext.getServerEpoch()\n+                                );\n+                                r.sendResponse(ctx, msg, payload);\n+                                return;\n+                            }", "originalCommit": "00f40e2e700313ca422a7f03f8fc92da58e0b67b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMzMwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r467323307", "bodyText": "Oh I see, the epoch can become outdated as the request waits in the queue.", "author": "zfrenette", "createdAt": "2020-08-07T23:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMjU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5NDAzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470894035", "bodyText": "Please put lock into StreamLogFiles or cache load (preferrably in StreamLogFiles). When you reset or do compaction, a lot of reads will be blocked, even those can be read from cache (actually 80-90% requests can be served by cache). That will create a cacading impact on read performance that accumulates.\nYour initial argument is about epoch check, but your epoch check is before lock, then it has nothing to do with where you put the lock.\nEven if you put the epoch check after lock, you can still put the lock and epoch check in LogUnitServerCache::handleRetrieval", "author": "WenbinZhu", "createdAt": "2020-08-14T22:42:03Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -273,26 +295,40 @@ public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IS\n             log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n         }\n \n-        ReadResponse rr = new ReadResponse();\n+        if (msg.getEpoch() != serverContext.getServerEpoch()) {\n+            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH,\n+                    serverContext.getServerEpoch()));\n+            return;\n+        }\n+\n+        Lock lock = resetLock.readLock();\n+        lock.lock();", "originalCommit": "c07086f6716e2a8c3a0ef72e06ced3925c385789", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTEwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470905104", "bodyText": "Please see my comment here #2661 (comment)\nIf we allow reading data from the cache when we don't have data in the database, I see it as a big issue.\n\n\n'reset' happens very rarely in comparison to reads,\n\n\nreset happens when a node is in the unresponsive list, so, reads not going to be affected.\n\n\nCould you please explain your motivation for inconsistent reads?\nLet's chat privately", "author": "xnull", "createdAt": "2020-08-14T23:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5NDAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTE0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470911147", "bodyText": "resetLock moved into StreamLogFiles", "author": "xnull", "createdAt": "2020-08-15T00:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5NDAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5NTcxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470895718", "bodyText": "Epoch check here does not do much help. @Maithem 's point is after reset is done, reads that are blocked might be stale. That means reads have be waiting on lock, so the check should be after lock.\nIf you put it here just because tests are failing, then just remvoe epoch completely, as it doesn't do much, the epoch is checked on BaseServer right before entering here.", "author": "WenbinZhu", "createdAt": "2020-08-14T22:49:24Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -273,26 +295,40 @@ public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IS\n             log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n         }\n \n-        ReadResponse rr = new ReadResponse();\n+        if (msg.getEpoch() != serverContext.getServerEpoch()) {\n+            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH,\n+                    serverContext.getServerEpoch()));\n+            return;\n+        }", "originalCommit": "c07086f6716e2a8c3a0ef72e06ced3925c385789", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTUzOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470905538", "bodyText": "done", "author": "xnull", "createdAt": "2020-08-14T23:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5NTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5NzIwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470897202", "bodyText": "This comment should be above previous if block.", "author": "WenbinZhu", "createdAt": "2020-08-14T22:56:25Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -374,28 +424,40 @@ public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n     private synchronized void resetLogUnit(CorfuPayloadMsg<Long> msg,\n                                            ChannelHandlerContext ctx, IServerRouter r) {\n \n+        if (msg.getPayload() <= serverContext.getLogUnitEpochWaterMark()\n+                || msg.getPayload() != serverContext.getServerEpoch()) {\n+            log.info(\"LogUnit Server Reset request received but reset already done.\");\n+            r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n+            return;\n+        }\n+\n         // Check if the reset request is with an epoch greater than the last reset epoch seen to\n-        // prevent multiple reset in the same epoch. and should be equal to the current router\n+        // prevent multiple reset in the same epoch and should be equal to the current router\n         // epoch to prevent stale reset requests from wiping out the data.", "originalCommit": "c07086f6716e2a8c3a0ef72e06ced3925c385789", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTQ0Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470911443", "bodyText": "done", "author": "xnull", "createdAt": "2020-08-15T00:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5NzIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5ODE5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470898194", "bodyText": "Locking here is bad, the reset op is added to BatchProcessor, but will be run after all previous write operations in the queue are finished, during that all reads will be blocked. This is a performance issue.\nAlso if you put lock into streamLogFiles then you don't need to do cf.join() below.", "author": "WenbinZhu", "createdAt": "2020-08-14T23:01:01Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -374,28 +424,40 @@ public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n     private synchronized void resetLogUnit(CorfuPayloadMsg<Long> msg,\n                                            ChannelHandlerContext ctx, IServerRouter r) {\n \n+        if (msg.getPayload() <= serverContext.getLogUnitEpochWaterMark()\n+                || msg.getPayload() != serverContext.getServerEpoch()) {\n+            log.info(\"LogUnit Server Reset request received but reset already done.\");\n+            r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n+            return;\n+        }\n+\n         // Check if the reset request is with an epoch greater than the last reset epoch seen to\n-        // prevent multiple reset in the same epoch. and should be equal to the current router\n+        // prevent multiple reset in the same epoch and should be equal to the current router\n         // epoch to prevent stale reset requests from wiping out the data.\n-        if (msg.getPayload() > serverContext.getLogUnitEpochWaterMark()\n-                && msg.getPayload() == serverContext.getServerEpoch()) {\n-            serverContext.setLogUnitEpochWaterMark(msg.getPayload());\n-            batchWriter.addTask(RESET, msg)\n+        serverContext.setLogUnitEpochWaterMark(msg.getPayload());\n+\n+        Lock lock = resetLock.writeLock();\n+        lock.lock();", "originalCommit": "c07086f6716e2a8c3a0ef72e06ced3925c385789", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTUzOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470911538", "bodyText": "done", "author": "xnull", "createdAt": "2020-08-15T00:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5ODE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMDczNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470910734", "bodyText": "Please fix the indent.", "author": "WenbinZhu", "createdAt": "2020-08-15T00:05:33Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -273,26 +286,26 @@ public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IS\n             log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n         }\n \n-        ReadResponse rr = new ReadResponse();\n-\n-        for (long address : msg.getPayload().getAddresses()) {\n-            try {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n+            ReadResponse rr = new ReadResponse();\n+\n+            for (long address : msg.getPayload().getAddresses()) {\n+                try {\n+                    ILogData logData = dataCache.get(address, cacheable);\n+                    if (logData == null) {\n+                        rr.put(address, LogData.getEmpty(address));\n+                    } else {\n+                        rr.put(address, (LogData) logData);\n+                    }\n+                } catch (DataCorruptionException e) {\n+                    log.error(\n+                            \"Data corruption exception while reading addresses {}\",\n+                            msg.getPayload().getAddresses(),\n+                            e);\n+                    r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));", "originalCommit": "b19b9fb1f603dbd4ef3fb26124e61afe7aaf93c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTYxNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2661#discussion_r470911615", "bodyText": "fixed", "author": "xnull", "createdAt": "2020-08-15T00:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMDczNA=="}], "type": "inlineReview"}, {"oid": "8d690a826d32ca95c90ffd786541835ef9f1b346", "url": "https://github.com/CorfuDB/CorfuDB/commit/8d690a826d32ca95c90ffd786541835ef9f1b346", "message": "File Descriptor leaks", "committedDate": "2020-08-15T00:28:34Z", "type": "forcePushed"}, {"oid": "c500b904c62aee8e39837da38f7f90967a79b1e5", "url": "https://github.com/CorfuDB/CorfuDB/commit/c500b904c62aee8e39837da38f7f90967a79b1e5", "message": "File Descriptor leaks", "committedDate": "2020-08-15T00:33:27Z", "type": "forcePushed"}, {"oid": "2b8b2f4c94cfe1d561948743fce313716e9b3cba", "url": "https://github.com/CorfuDB/CorfuDB/commit/2b8b2f4c94cfe1d561948743fce313716e9b3cba", "message": "fdl", "committedDate": "2020-08-15T04:09:48Z", "type": "commit"}, {"oid": "461707036bc8a335bb8d5c4c7f1f404314bae09b", "url": "https://github.com/CorfuDB/CorfuDB/commit/461707036bc8a335bb8d5c4c7f1f404314bae09b", "message": "File Descriptor leaks", "committedDate": "2020-08-15T04:09:48Z", "type": "commit"}, {"oid": "693707ba3c52195e004dbfba9dead8610beeffa2", "url": "https://github.com/CorfuDB/CorfuDB/commit/693707ba3c52195e004dbfba9dead8610beeffa2", "message": "docker", "committedDate": "2020-08-15T04:09:48Z", "type": "commit"}, {"oid": "693707ba3c52195e004dbfba9dead8610beeffa2", "url": "https://github.com/CorfuDB/CorfuDB/commit/693707ba3c52195e004dbfba9dead8610beeffa2", "message": "docker", "committedDate": "2020-08-15T04:09:48Z", "type": "forcePushed"}]}