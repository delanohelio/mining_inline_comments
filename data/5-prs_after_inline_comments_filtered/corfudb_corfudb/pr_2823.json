{"pr_number": 2823, "pr_title": "Protobuf Layout RPCs", "pr_createdAt": "2020-11-11T16:22:15Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2823", "timeline": [{"oid": "0c40d5d14129a93f4ab8d7ed2dc0add35ed91b2e", "url": "https://github.com/CorfuDB/CorfuDB/commit/0c40d5d14129a93f4ab8d7ed2dc0add35ed91b2e", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-12T00:41:13Z", "type": "forcePushed"}, {"oid": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "url": "https://github.com/CorfuDB/CorfuDB/commit/5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-12T18:48:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE4OTE4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523189184", "bodyText": "Reformat imports.", "author": "Maithem", "createdAt": "2020-11-13T19:53:01Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -13,18 +15,29 @@\n import org.corfudb.infrastructure.paxos.PaxosDataStore;\n import org.corfudb.protocols.wireprotocol.CorfuMsg;\n import org.corfudb.protocols.wireprotocol.CorfuMsgType;\n-import org.corfudb.protocols.wireprotocol.CorfuPayloadMsg;\n-import org.corfudb.protocols.wireprotocol.LayoutBootstrapRequest;\n-import org.corfudb.protocols.wireprotocol.LayoutCommittedRequest;\n-import org.corfudb.protocols.wireprotocol.LayoutMsg;\n-import org.corfudb.protocols.wireprotocol.LayoutPrepareRequest;\n-import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n-import org.corfudb.protocols.wireprotocol.LayoutProposeRequest;\n-import org.corfudb.protocols.wireprotocol.LayoutProposeResponse;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE5MDAyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523190020", "bodyText": "Why can't you remove this in this patch? It's not needed. I think we should eagerly remove dead code paths because its hard to track them and try to delete them later.", "author": "Maithem", "createdAt": "2020-11-13T19:54:46Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -66,6 +79,7 @@\n \n     /**\n      * HandlerMethod for this server.\n+     * [RM] Remove this after Protobuf for RPC Completion\n      */\n     @Getter\n     private final HandlerMethods handler =", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE5MDcwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523190707", "bodyText": "Note: It was made abstract in the other PR (2812), so a getHandler method is required.", "author": "zfrenette", "createdAt": "2020-11-13T19:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE5MDAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE5MDQzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523190437", "bodyText": "Throw an UnsupportedOperationException instead.", "author": "Maithem", "createdAt": "2020-11-13T19:55:36Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -86,6 +100,7 @@\n \n     @Override\n     public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n+        //[RM] Remove this after Protobuf for RPC Completion\n         return getState() == ServerState.READY;", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE5MDU2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523190569", "bodyText": "Throw an UnsupportedOperationException instead.", "author": "Maithem", "createdAt": "2020-11-13T19:55:50Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -118,6 +133,7 @@ public LayoutServer(@Nonnull ServerContext serverContext) {\n \n     @Override\n     protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n+        //[RM] Remove this after Protobuf for RPC Completion", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE5MTA0Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523191043", "bodyText": "Dead code, delete method.", "author": "Maithem", "createdAt": "2020-11-13T19:56:54Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -132,6 +148,7 @@ public void shutdown() {\n         executor.shutdown();\n     }\n \n+    //[RM] Remove this after Protobuf for RPC Completion\n     private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE5MTg5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523191898", "bodyText": "I would pass the RequestMsg and extract the header just before it is needed. Passing header around seems a little strange.", "author": "Maithem", "createdAt": "2020-11-13T19:58:41Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE5MjYxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523192611", "bodyText": "The old implementation also logs a message. Can you put that back, but as a debug log?", "author": "Maithem", "createdAt": "2020-11-13T20:00:08Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE5NTMzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523195333", "bodyText": "I know you didn't write this, but I think its cleaner to make the isBootstrapped such that it doesn't have a side effect. Maybe something like this:\nif(!isBootstrapped(requestHeader, ctx, r)) {\n   r.sendNoBootstrapError(reqHeader, ctx);\n}", "author": "Maithem", "createdAt": "2020-11-13T20:05:55Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(getCurrentLayout() == null) {\n+            r.sendNoBootstrapError(reqHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n     // Helper Methods\n \n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n-            return;\n-        }\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(!isBootstrapped(req.getHeader(), ctx, r)) return;\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if(payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            //TODO: Client is ahead of the server. Is any other handling required?\n+            log.warn(\"handleLayoutRequest[{}]: Payload epoch {} ahead of Server epoch {}\",\n+                    req.getHeader().getRequestId(), payloadEpoch, serverEpoch);\n+\n+            r.sendWrongEpochError(req.getHeader(), ctx, serverEpoch);\n         }\n     }\n \n     /**\n      * Sets the new layout if the server has not been bootstrapped with one already.\n      *\n-     * @param msg corfu message containing LAYOUT_BOOTSTRAP\n+     * @param req corfu message containing BOOTSTRAP_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_BOOTSTRAP)\n-    public synchronized void handleMessageLayoutBootstrap(\n-            @NonNull CorfuPayloadMsg<LayoutBootstrapRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        if (getCurrentLayout() == null) {\n-            Layout layout = msg.getPayload().getLayout();\n-\n-            log.info(\"handleMessageLayoutBootstrap: Bootstrap with new layout={}, {}\",\n-                    layout, msg);\n-\n-            if (layout.getClusterId() == null) {\n-                log.warn(\"handleMessageLayoutBootstrap: The layout does {} not have a clusterId\",\n-                        layout);\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.NACK));\n-            }\n-            else{\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)\n+    public synchronized void handleBootstrapLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        if(getCurrentLayout() == null) {\n+            final Layout layout = getLayout(req.getPayload().getBootstrapLayoutRequest().getLayout());\n+            log.info(\"handleBootstrapLayoutRequest[{}]: Bootstrap with new layout={}\", requestHeader.getRequestId(), layout);\n+\n+            if(layout.getClusterId() == null) {\n+                log.warn(\"handleBootstrapLayoutRequest[{}]: The layout={} does not have a clusterId\",\n+                        requestHeader.getRequestId(), layout);\n+\n+                responseHeader = getHeaderMsg(requestHeader, false, false);\n+                response = getResponseMsg(responseHeader,\n+                        getBootstrapLayoutResponseMsg(BootstrapLayoutResponseMsg.Type.NACK));\n+            } else {\n                 setCurrentLayout(layout);\n                 serverContext.setServerEpoch(layout.getEpoch(), r);\n-                //send a response that the bootstrap was successful.\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.ACK));\n+\n+                responseHeader = getHeaderMsg(requestHeader, false, true);\n+                response = getResponseMsg(responseHeader,\n+                        getBootstrapLayoutResponseMsg(BootstrapLayoutResponseMsg.Type.ACK));\n             }\n         } else {\n-            // We are already bootstrapped, bootstrap again is not allowed.\n-            log.warn(\"handleMessageLayoutBootstrap: Got a request to bootstrap a server which is \"\n-                    + \"already bootstrapped, rejecting!\");\n-            r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.LAYOUT_ALREADY_BOOTSTRAP));\n+            log.warn(\"handleBootstrapLayoutRequest[{}]: Got a request to bootstrap a server which is \"\n+                    + \"already bootstrapped, rejecting!\", requestHeader.getRequestId());\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, true);\n+            response = getResponseMsg(responseHeader, getBootstrappedErrorMsg());\n         }\n+\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * Accepts a prepare message if the rank is higher than any accepted so far.\n      *\n-     * @param msg corfu message containing LAYOUT_PREPARE\n+     * @param req corfu message containing PREPARE_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    // TODO this can work under a separate lock for this step as it does not change the global\n-    // components\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_PREPARE)\n-    public synchronized void handleMessageLayoutPrepare(\n-            @NonNull CorfuPayloadMsg<LayoutPrepareRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        // Check if the prepare is for the correct epoch\n-        if (!isBootstrapped(msg, ctx, r)) {\n-            return;\n-        }\n+    // TODO this can work under a separate lock for this step as it does not change the global components\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.PREPARE_LAYOUT_REQUEST)\n+    public synchronized void handlePrepareLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        final PrepareLayoutRequestMsg payload = req.getPayload().getPrepareLayoutRequest();\n+\n+        if(!isBootstrapped(requestHeader, ctx, r)) return;", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE5ODE5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523198192", "bodyText": "You can remove the TODO this scenario can naturally happen. Imagine you run Paxos Layout at epoch 2. Its possible that out of the 3 nodes, only 2 nodes accepted epoch two layout. So, when a client requests a layout from the third node (i.e., the one that didn't participate in the paxos round, then it should just return the older layout. If you return a wrong epoch exception its fine, but superfluous because the clients need to check that they never regress the epoch the layout that they are tracking.", "author": "Maithem", "createdAt": "2020-11-13T20:12:12Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(getCurrentLayout() == null) {\n+            r.sendNoBootstrapError(reqHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n     // Helper Methods\n \n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n-            return;\n-        }\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(!isBootstrapped(req.getHeader(), ctx, r)) return;\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if(payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            //TODO: Client is ahead of the server. Is any other handling required?", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwMDg2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523200865", "bodyText": "Can you drop the \"REQUEST\" suffix naming convention, it seems redundant. Maybe use RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT", "author": "Maithem", "createdAt": "2020-11-13T20:18:00Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(getCurrentLayout() == null) {\n+            r.sendNoBootstrapError(reqHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n     // Helper Methods\n \n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n-            return;\n-        }\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(!isBootstrapped(req.getHeader(), ctx, r)) return;\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if(payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            //TODO: Client is ahead of the server. Is any other handling required?\n+            log.warn(\"handleLayoutRequest[{}]: Payload epoch {} ahead of Server epoch {}\",\n+                    req.getHeader().getRequestId(), payloadEpoch, serverEpoch);\n+\n+            r.sendWrongEpochError(req.getHeader(), ctx, serverEpoch);\n         }\n     }\n \n     /**\n      * Sets the new layout if the server has not been bootstrapped with one already.\n      *\n-     * @param msg corfu message containing LAYOUT_BOOTSTRAP\n+     * @param req corfu message containing BOOTSTRAP_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_BOOTSTRAP)\n-    public synchronized void handleMessageLayoutBootstrap(\n-            @NonNull CorfuPayloadMsg<LayoutBootstrapRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        if (getCurrentLayout() == null) {\n-            Layout layout = msg.getPayload().getLayout();\n-\n-            log.info(\"handleMessageLayoutBootstrap: Bootstrap with new layout={}, {}\",\n-                    layout, msg);\n-\n-            if (layout.getClusterId() == null) {\n-                log.warn(\"handleMessageLayoutBootstrap: The layout does {} not have a clusterId\",\n-                        layout);\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.NACK));\n-            }\n-            else{\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5NjUyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r527996527", "bodyText": "I had a discuss with @zfrenette offline and we thought it might be okay to keep the suffix, since sometimes we directly import the PayloadCase rather than RequestPayloadMsg.PayloadCase, the suffix might help to tell the type of the message. (if we remove the suffix, both the RequestPayloadMsg and ResponsePayloadMsg will have a PayloadCase.PING for example)", "author": "xcchang", "createdAt": "2020-11-20T22:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwMDg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwMTg3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523201878", "bodyText": "You don't need to log the request id since its per-channel and only used to timeout/complete requests.", "author": "Maithem", "createdAt": "2020-11-13T20:20:11Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(getCurrentLayout() == null) {\n+            r.sendNoBootstrapError(reqHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n     // Helper Methods\n \n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n-            return;\n-        }\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(!isBootstrapped(req.getHeader(), ctx, r)) return;\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if(payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            //TODO: Client is ahead of the server. Is any other handling required?\n+            log.warn(\"handleLayoutRequest[{}]: Payload epoch {} ahead of Server epoch {}\",\n+                    req.getHeader().getRequestId(), payloadEpoch, serverEpoch);\n+\n+            r.sendWrongEpochError(req.getHeader(), ctx, serverEpoch);\n         }\n     }\n \n     /**\n      * Sets the new layout if the server has not been bootstrapped with one already.\n      *\n-     * @param msg corfu message containing LAYOUT_BOOTSTRAP\n+     * @param req corfu message containing BOOTSTRAP_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_BOOTSTRAP)\n-    public synchronized void handleMessageLayoutBootstrap(\n-            @NonNull CorfuPayloadMsg<LayoutBootstrapRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        if (getCurrentLayout() == null) {\n-            Layout layout = msg.getPayload().getLayout();\n-\n-            log.info(\"handleMessageLayoutBootstrap: Bootstrap with new layout={}, {}\",\n-                    layout, msg);\n-\n-            if (layout.getClusterId() == null) {\n-                log.warn(\"handleMessageLayoutBootstrap: The layout does {} not have a clusterId\",\n-                        layout);\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.NACK));\n-            }\n-            else{\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)\n+    public synchronized void handleBootstrapLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        if(getCurrentLayout() == null) {\n+            final Layout layout = getLayout(req.getPayload().getBootstrapLayoutRequest().getLayout());\n+            log.info(\"handleBootstrapLayoutRequest[{}]: Bootstrap with new layout={}\", requestHeader.getRequestId(), layout);\n+", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwMjkzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523202936", "bodyText": "Can you reverse the logic and get rid of the if-else here?\nYou can check if(getCurrentLayout() != null) you can send the error message and return right away. Otherwise continue to save the new bootstrap layout.", "author": "Maithem", "createdAt": "2020-11-13T20:22:22Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(getCurrentLayout() == null) {\n+            r.sendNoBootstrapError(reqHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n     // Helper Methods\n \n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n-            return;\n-        }\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(!isBootstrapped(req.getHeader(), ctx, r)) return;\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if(payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            //TODO: Client is ahead of the server. Is any other handling required?\n+            log.warn(\"handleLayoutRequest[{}]: Payload epoch {} ahead of Server epoch {}\",\n+                    req.getHeader().getRequestId(), payloadEpoch, serverEpoch);\n+\n+            r.sendWrongEpochError(req.getHeader(), ctx, serverEpoch);\n         }\n     }\n \n     /**\n      * Sets the new layout if the server has not been bootstrapped with one already.\n      *\n-     * @param msg corfu message containing LAYOUT_BOOTSTRAP\n+     * @param req corfu message containing BOOTSTRAP_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_BOOTSTRAP)\n-    public synchronized void handleMessageLayoutBootstrap(\n-            @NonNull CorfuPayloadMsg<LayoutBootstrapRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        if (getCurrentLayout() == null) {\n-            Layout layout = msg.getPayload().getLayout();\n-\n-            log.info(\"handleMessageLayoutBootstrap: Bootstrap with new layout={}, {}\",\n-                    layout, msg);\n-\n-            if (layout.getClusterId() == null) {\n-                log.warn(\"handleMessageLayoutBootstrap: The layout does {} not have a clusterId\",\n-                        layout);\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.NACK));\n-            }\n-            else{\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)\n+    public synchronized void handleBootstrapLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        if(getCurrentLayout() == null) {", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwODI5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523208292", "bodyText": "Un-nest this, move the validation to the top (after the layout.getClusterId() == null check)", "author": "Maithem", "createdAt": "2020-11-13T20:34:15Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(getCurrentLayout() == null) {\n+            r.sendNoBootstrapError(reqHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n     // Helper Methods\n \n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n-            return;\n-        }\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(!isBootstrapped(req.getHeader(), ctx, r)) return;\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if(payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            //TODO: Client is ahead of the server. Is any other handling required?\n+            log.warn(\"handleLayoutRequest[{}]: Payload epoch {} ahead of Server epoch {}\",\n+                    req.getHeader().getRequestId(), payloadEpoch, serverEpoch);\n+\n+            r.sendWrongEpochError(req.getHeader(), ctx, serverEpoch);\n         }\n     }\n \n     /**\n      * Sets the new layout if the server has not been bootstrapped with one already.\n      *\n-     * @param msg corfu message containing LAYOUT_BOOTSTRAP\n+     * @param req corfu message containing BOOTSTRAP_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_BOOTSTRAP)\n-    public synchronized void handleMessageLayoutBootstrap(\n-            @NonNull CorfuPayloadMsg<LayoutBootstrapRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        if (getCurrentLayout() == null) {\n-            Layout layout = msg.getPayload().getLayout();\n-\n-            log.info(\"handleMessageLayoutBootstrap: Bootstrap with new layout={}, {}\",\n-                    layout, msg);\n-\n-            if (layout.getClusterId() == null) {\n-                log.warn(\"handleMessageLayoutBootstrap: The layout does {} not have a clusterId\",\n-                        layout);\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.NACK));\n-            }\n-            else{\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)\n+    public synchronized void handleBootstrapLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        if(getCurrentLayout() == null) {\n+            final Layout layout = getLayout(req.getPayload().getBootstrapLayoutRequest().getLayout());\n+            log.info(\"handleBootstrapLayoutRequest[{}]: Bootstrap with new layout={}\", requestHeader.getRequestId(), layout);\n+\n+            if(layout.getClusterId() == null) {\n+                log.warn(\"handleBootstrapLayoutRequest[{}]: The layout={} does not have a clusterId\",\n+                        requestHeader.getRequestId(), layout);\n+\n+                responseHeader = getHeaderMsg(requestHeader, false, false);\n+                response = getResponseMsg(responseHeader,\n+                        getBootstrapLayoutResponseMsg(BootstrapLayoutResponseMsg.Type.NACK));", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwODg5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523208890", "bodyText": "Log the newly bootstrapped layout as info", "author": "Maithem", "createdAt": "2020-11-13T20:35:33Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(getCurrentLayout() == null) {\n+            r.sendNoBootstrapError(reqHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n     // Helper Methods\n \n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n-            return;\n-        }\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(!isBootstrapped(req.getHeader(), ctx, r)) return;\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if(payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            //TODO: Client is ahead of the server. Is any other handling required?\n+            log.warn(\"handleLayoutRequest[{}]: Payload epoch {} ahead of Server epoch {}\",\n+                    req.getHeader().getRequestId(), payloadEpoch, serverEpoch);\n+\n+            r.sendWrongEpochError(req.getHeader(), ctx, serverEpoch);\n         }\n     }\n \n     /**\n      * Sets the new layout if the server has not been bootstrapped with one already.\n      *\n-     * @param msg corfu message containing LAYOUT_BOOTSTRAP\n+     * @param req corfu message containing BOOTSTRAP_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_BOOTSTRAP)\n-    public synchronized void handleMessageLayoutBootstrap(\n-            @NonNull CorfuPayloadMsg<LayoutBootstrapRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        if (getCurrentLayout() == null) {\n-            Layout layout = msg.getPayload().getLayout();\n-\n-            log.info(\"handleMessageLayoutBootstrap: Bootstrap with new layout={}, {}\",\n-                    layout, msg);\n-\n-            if (layout.getClusterId() == null) {\n-                log.warn(\"handleMessageLayoutBootstrap: The layout does {} not have a clusterId\",\n-                        layout);\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.NACK));\n-            }\n-            else{\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)\n+    public synchronized void handleBootstrapLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        if(getCurrentLayout() == null) {\n+            final Layout layout = getLayout(req.getPayload().getBootstrapLayoutRequest().getLayout());\n+            log.info(\"handleBootstrapLayoutRequest[{}]: Bootstrap with new layout={}\", requestHeader.getRequestId(), layout);\n+\n+            if(layout.getClusterId() == null) {\n+                log.warn(\"handleBootstrapLayoutRequest[{}]: The layout={} does not have a clusterId\",\n+                        requestHeader.getRequestId(), layout);\n+\n+                responseHeader = getHeaderMsg(requestHeader, false, false);\n+                response = getResponseMsg(responseHeader,\n+                        getBootstrapLayoutResponseMsg(BootstrapLayoutResponseMsg.Type.NACK));\n+            } else {\n                 setCurrentLayout(layout);\n                 serverContext.setServerEpoch(layout.getEpoch(), r);\n-                //send a response that the bootstrap was successful.\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.ACK));\n+", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIxMzQxOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523213419", "bodyText": "Instead of calling this from each handler, you can just move it to processRequest. Note that it needs to be called on all messages except for LAYOUT_NOBOOTSTRAP", "author": "Maithem", "createdAt": "2020-11-13T20:40:55Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2NDg3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523764871", "bodyText": "Note that checking this in processRequest means we are performing the check before the task is submitted to the executor service.  Is it possible that the status changes by the time the new thread is actually executing the handler?", "author": "zfrenette", "createdAt": "2020-11-15T14:18:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIxMzQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIyMDQzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523220436", "bodyText": "Why is this responseHeader different than the one in line 277\nThe response header should always copy its metadata from the requestHeader.", "author": "Maithem", "createdAt": "2020-11-13T20:48:10Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,280 +158,315 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n         return true;\n     }\n \n+    private boolean isBootstrapped(HeaderMsg reqHeader, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(getCurrentLayout() == null) {\n+            r.sendNoBootstrapError(reqHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n     // Helper Methods\n \n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n-            return;\n-        }\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if(!isBootstrapped(req.getHeader(), ctx, r)) return;\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if(payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            //TODO: Client is ahead of the server. Is any other handling required?\n+            log.warn(\"handleLayoutRequest[{}]: Payload epoch {} ahead of Server epoch {}\",\n+                    req.getHeader().getRequestId(), payloadEpoch, serverEpoch);\n+\n+            r.sendWrongEpochError(req.getHeader(), ctx, serverEpoch);\n         }\n     }\n \n     /**\n      * Sets the new layout if the server has not been bootstrapped with one already.\n      *\n-     * @param msg corfu message containing LAYOUT_BOOTSTRAP\n+     * @param req corfu message containing BOOTSTRAP_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_BOOTSTRAP)\n-    public synchronized void handleMessageLayoutBootstrap(\n-            @NonNull CorfuPayloadMsg<LayoutBootstrapRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        if (getCurrentLayout() == null) {\n-            Layout layout = msg.getPayload().getLayout();\n-\n-            log.info(\"handleMessageLayoutBootstrap: Bootstrap with new layout={}, {}\",\n-                    layout, msg);\n-\n-            if (layout.getClusterId() == null) {\n-                log.warn(\"handleMessageLayoutBootstrap: The layout does {} not have a clusterId\",\n-                        layout);\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.NACK));\n-            }\n-            else{\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)\n+    public synchronized void handleBootstrapLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        if(getCurrentLayout() == null) {\n+            final Layout layout = getLayout(req.getPayload().getBootstrapLayoutRequest().getLayout());\n+            log.info(\"handleBootstrapLayoutRequest[{}]: Bootstrap with new layout={}\", requestHeader.getRequestId(), layout);\n+\n+            if(layout.getClusterId() == null) {\n+                log.warn(\"handleBootstrapLayoutRequest[{}]: The layout={} does not have a clusterId\",\n+                        requestHeader.getRequestId(), layout);\n+\n+                responseHeader = getHeaderMsg(requestHeader, false, false);\n+                response = getResponseMsg(responseHeader,\n+                        getBootstrapLayoutResponseMsg(BootstrapLayoutResponseMsg.Type.NACK));\n+            } else {\n                 setCurrentLayout(layout);\n                 serverContext.setServerEpoch(layout.getEpoch(), r);\n-                //send a response that the bootstrap was successful.\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.ACK));\n+\n+                responseHeader = getHeaderMsg(requestHeader, false, true);\n+                response = getResponseMsg(responseHeader,\n+                        getBootstrapLayoutResponseMsg(BootstrapLayoutResponseMsg.Type.ACK));\n             }\n         } else {\n-            // We are already bootstrapped, bootstrap again is not allowed.\n-            log.warn(\"handleMessageLayoutBootstrap: Got a request to bootstrap a server which is \"\n-                    + \"already bootstrapped, rejecting!\");\n-            r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.LAYOUT_ALREADY_BOOTSTRAP));\n+            log.warn(\"handleBootstrapLayoutRequest[{}]: Got a request to bootstrap a server which is \"\n+                    + \"already bootstrapped, rejecting!\", requestHeader.getRequestId());\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, true);\n+            response = getResponseMsg(responseHeader, getBootstrappedErrorMsg());\n         }\n+\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * Accepts a prepare message if the rank is higher than any accepted so far.\n      *\n-     * @param msg corfu message containing LAYOUT_PREPARE\n+     * @param req corfu message containing PREPARE_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    // TODO this can work under a separate lock for this step as it does not change the global\n-    // components\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_PREPARE)\n-    public synchronized void handleMessageLayoutPrepare(\n-            @NonNull CorfuPayloadMsg<LayoutPrepareRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        // Check if the prepare is for the correct epoch\n-        if (!isBootstrapped(msg, ctx, r)) {\n-            return;\n-        }\n+    // TODO this can work under a separate lock for this step as it does not change the global components\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.PREPARE_LAYOUT_REQUEST)\n+    public synchronized void handlePrepareLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        final PrepareLayoutRequestMsg payload = req.getPayload().getPrepareLayoutRequest();\n+\n+        if(!isBootstrapped(requestHeader, ctx, r)) return;\n \n-        final long payloadEpoch = msg.getPayload().getEpoch();\n+        final long payloadEpoch = payload.getEpoch();;\n         final long serverEpoch = getServerEpoch();\n \n-        final Rank prepareRank = new Rank(msg.getPayload().getRank(), msg.getClientID());\n         final Rank phase1Rank = getPhase1Rank(payloadEpoch);\n+        final Rank prepareRank = new Rank(payload.getRank(), getUUID(requestHeader.getClientId()));\n \n-        if (payloadEpoch != serverEpoch) {\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.trace(\"handleMessageLayoutPrepare: Incoming message with wrong epoch, got {}, \"\n-                            + \"expected {}, message was: {}\",\n-                    msg.getPayload().getEpoch(), serverEpoch, msg);\n+        if(payloadEpoch != serverEpoch) {\n+            r.sendWrongEpochError(requestHeader, ctx, serverEpoch);\n             return;\n         }\n \n-        Layout proposedLayout = getProposedLayout(payloadEpoch);\n+        final Layout proposedLayout = getProposedLayout(payloadEpoch);\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        // If the PREPARE_LAYOUT_REQUEST rank is less than or equal to the highest phase 1 rank, reject.\n+        if(phase1Rank != null && prepareRank.lessThanEqualTo(phase1Rank)) {\n+            log.debug(\"handlePrepareLayoutRequest[{}]: Rejected phase 1 prepare of rank={}, phase1Rank={}\",\n+                    requestHeader.getRequestId(), prepareRank, phase1Rank);\n \n-        // This is a prepare. If the rank is less than or equal to the phase 1 rank, reject.\n-        if (phase1Rank != null && prepareRank.lessThanEqualTo(phase1Rank)) {\n-            log.debug(\"handleMessageLayoutPrepare: Rejected phase 1 prepare of rank={}, \"\n-                    + \"phase1Rank={}\", prepareRank, phase1Rank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PREPARE_REJECT.payloadMsg(new\n-                    LayoutPrepareResponse(phase1Rank.getRank(), proposedLayout)));\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader, getPrepareLayoutResponseMsg(\n+                    PrepareLayoutResponseMsg.Type.REJECT, phase1Rank.getRank(), proposedLayout));\n         } else {\n             // Return the layout with the highest rank proposed before.\n-            Rank highestProposedRank = proposedLayout == null ? new Rank(-1L, msg.getClientID())\n-                    : getPhase2Rank(payloadEpoch);\n+            Rank highestProposedRank = proposedLayout == null ?\n+                    new Rank(-1L, getUUID(requestHeader.getClientId())) : getPhase2Rank(payloadEpoch);\n+\n             setPhase1Rank(prepareRank, payloadEpoch);\n-            log.debug(\"handleMessageLayoutPrepare: New phase 1 rank={}\", prepareRank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PREPARE_ACK.payloadMsg(new\n-                    LayoutPrepareResponse(highestProposedRank.getRank(), proposedLayout)));\n+            log.debug(\"handlePrepareLayoutRequest[{}]: New phase 1 rank={}\", requestHeader.getRequestId(), prepareRank);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, true);", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2NTUyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523765526", "bodyText": "All of the fields are the same, except possibly the ignoreEpochor ignoreClusterId fields. These differ because the message in 277 corresponds to a NACK/REJECT while here it corresponds to an ACK. Note that in the original CorfuMsgType implementation, an ACK will ignore the epoch check while a NACK does not. You can notice this in  PR 2812 as well.", "author": "zfrenette", "createdAt": "2020-11-15T14:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIyMDQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIyNzE3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523227179", "bodyText": "Not used?", "author": "Maithem", "createdAt": "2020-11-13T20:55:17Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolLayout.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+import org.corfudb.runtime.proto.service.Layout.BootstrapLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.BootstrapLayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.CommitLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.CommitLayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.LayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.LayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.PrepareLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.PrepareLayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.ProposeLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.ProposeLayoutResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getLayout;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getLayoutMsg;\n+\n+@Slf4j\n+public class CorfuProtocolLayout {\n+    public static RequestPayloadMsg getLayoutRequestMsg(long epoch) {\n+        return RequestPayloadMsg.newBuilder()\n+                .setLayoutRequest(LayoutRequestMsg.newBuilder()\n+                        .setEpoch(epoch)\n+                        .build())\n+                .build();\n+    }\n+\n+    public static ResponsePayloadMsg getLayoutResponseMsg(Layout layout) {\n+        return ResponsePayloadMsg.newBuilder()\n+                .setLayoutResponse(LayoutResponseMsg.newBuilder()\n+                        .setLayout(getLayoutMsg(layout))\n+                        .build())\n+                .build();\n+    }\n+\n+    public static RequestPayloadMsg getPrepareLayoutRequestMsg(long epoch, long rank) {\n+        return RequestPayloadMsg.newBuilder()\n+                .setPrepareLayoutRequest(PrepareLayoutRequestMsg.newBuilder()\n+                        .setEpoch(epoch)\n+                        .setRank(rank)\n+                        .build())\n+                .build();\n+    }\n+\n+    public static ResponsePayloadMsg getPrepareLayoutResponseMsg(PrepareLayoutResponseMsg.Type type,\n+                                                                 long rank, Layout layout) {\n+        return ResponsePayloadMsg.newBuilder()\n+                .setPrepareLayoutResponse(PrepareLayoutResponseMsg.newBuilder()\n+                        .setRespType(type)\n+                        .setRank(rank)\n+                        .setLayout(getLayoutMsg(layout))\n+                        .build())\n+                .build();\n+    }\n+\n+    public static LayoutPrepareResponse getLayoutPrepareResponse(PrepareLayoutResponseMsg msg) {\n+        return new LayoutPrepareResponse(msg.getRank(), getLayout(msg.getLayout()));", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2NjA3Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523766072", "bodyText": "Good catch. It was meant to be used in the LayoutHandler, but I think it can be removed.", "author": "zfrenette", "createdAt": "2020-11-15T14:28:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIyNzE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIyODU4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523228589", "bodyText": "Wouldn't it be cleaner to pass the requestHeader to these methods and have these methods construct and return the final message. Instead of doing this construction all over the place it can be in one place, here.", "author": "Maithem", "createdAt": "2020-11-13T20:57:39Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolLayout.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+import org.corfudb.runtime.proto.service.Layout.BootstrapLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.BootstrapLayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.CommitLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.CommitLayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.LayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.LayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.PrepareLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.PrepareLayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.ProposeLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.ProposeLayoutResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getLayout;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getLayoutMsg;\n+\n+@Slf4j\n+public class CorfuProtocolLayout {", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2NzUyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523767525", "bodyText": "The reason why we don't pass the header at this stage is because the client class (i.e. LayoutClient) is currently responsible for building the message payload, but it doesn't have all of the information required to build the header, most notably the request id, which is only available once we reach the router. So if the client builds a RequestMsg directly (consisting of HeaderMsg and RequestPayloadMsg), then the router needs to rebuild the object in order to stamp the request id. Therefore, the client builds the payload and passes its information to the router, and its the router that then builds the header and wraps everything together into a RequestMsg. The class CorfuProtocolMessage provides this functionality. You can also see this in PR 2812.", "author": "zfrenette", "createdAt": "2020-11-15T14:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIyODU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIyOTM3MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523229370", "bodyText": "Remove. All of this uses protobuf messages now. Also, don't forget to remove Layout requests/responses from CorfuMsgType.", "author": "Maithem", "createdAt": "2020-11-13T20:59:31Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/LayoutClient.java", "diffHunk": "@@ -27,13 +28,15 @@ public LayoutClient(IClientRouter router, long epoch, UUID clusterID) {\n         super(router, epoch, clusterID);\n     }\n \n+    // Protobuf region\n+", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIyOTk0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523229945", "bodyText": "Remove all usages of CorfuMsgType with these changes those paths become inactive. Its better to remove them than assume that they are not functional.", "author": "Maithem", "createdAt": "2020-11-13T21:00:54Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/LayoutHandler.java", "diffHunk": "@@ -94,4 +105,116 @@ private static Object handleAlreadyBootstrap(CorfuMsg msg,\n             throws Exception {\n         throw new AlreadyBootstrappedException();\n     }\n+\n+    // Protobuf region\n+\n+    /**", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIzMTkyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523231927", "bodyText": "Why don't you just use a boolean to represent this.\nmessage CommitLayoutResponseMsg {\n      bool committed = 1;\n}", "author": "Maithem", "createdAt": "2020-11-13T21:05:37Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/LayoutHandler.java", "diffHunk": "@@ -94,4 +105,116 @@ private static Object handleAlreadyBootstrap(CorfuMsg msg,\n             throws Exception {\n         throw new AlreadyBootstrappedException();\n     }\n+\n+    // Protobuf region\n+\n+    /**\n+     * Handle a layout response from the server.\n+     *\n+     * @param msg The layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return {@link Layout} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.LAYOUT_RESPONSE)\n+    private static Object handleLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                               IClientRouter r) {\n+        LayoutResponseMsg layoutResponse = msg.getPayload().getLayoutResponse();\n+        RpcCommon.LayoutMsg layoutMsg = layoutResponse.getLayout();\n+\n+        return CorfuProtocolCommon.getLayout(layoutMsg);\n+    }\n+\n+    /**\n+     * Handle a prepare layout response from the server.\n+     *\n+     * @param msg The prepare layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return {@link LayoutPrepareResponse} if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.PREPARE_LAYOUT_RESPONSE)\n+    private static Object handlePrepareLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                      IClientRouter r) {\n+        PrepareLayoutResponseMsg prepareLayoutMsg = msg.getPayload().getPrepareLayoutResponse();\n+        PrepareLayoutResponseMsg.Type type = prepareLayoutMsg.getRespType();\n+        long rank = prepareLayoutMsg.getRank();\n+        Layout layout = CorfuProtocolCommon.getLayout(prepareLayoutMsg.getLayout());\n+\n+        switch (type) {\n+            case ACK: return new LayoutPrepareResponse(rank, layout);\n+            case REJECT: throw new OutrankedException(rank, layout);\n+                // TODO for INVALID\n+            default: throw new UnsupportedOperationException(\"Response handler not provided\");\n+        }\n+    }\n+\n+    /**\n+     * Handle a propose layout response from the server.\n+     *\n+     * @param msg The propose layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return True if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.PROPOSE_LAYOUT_RESPONSE)\n+    private static Object handleProposeLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                      IClientRouter r) {\n+        ProposeLayoutResponseMsg proposeLayoutMsg = msg.getPayload().getProposeLayoutResponse();\n+        ProposeLayoutResponseMsg.Type type = proposeLayoutMsg.getRespType();\n+        long rank = proposeLayoutMsg.getRank();\n+\n+        switch (type) {\n+            case ACK: return true;\n+            case REJECT: throw new OutrankedException(rank);\n+                // TODO for INVALID\n+            default: throw new UnsupportedOperationException(\"Response handler not provided\");\n+        }\n+    }\n+\n+    /**\n+     * Handle a propose layout response from the server.\n+     *\n+     * @param msg The propose layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return True if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.COMMIT_LAYOUT_RESPONSE)\n+    private static Object handleCommitLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                     IClientRouter r) {\n+        CommitLayoutResponseMsg commitLayoutMsg = msg.getPayload().getCommitLayoutResponse();\n+        CommitLayoutResponseMsg.Type type = commitLayoutMsg.getRespType();\n+\n+        switch (type) {\n+            case ACK: return true;\n+            case NACK: return false;\n+            // TODO for INVALID\n+            default: throw new UnsupportedOperationException(\"Response handler not provided\");\n+        }", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5NzY3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r524397676", "bodyText": "I think when @zfrenette design these message types, enum types were used to make it easier for extension. For example when the message type needs to change sometime in the future, to model something like ACK, NACK-FAILURE-REASON-A, NACK-FAILURE-REASON-B, enum might provide more flexibility and easier for backward compatibility. But definitely using a boolean would make it cleaner at this time. We might need to make a tradeoff here.", "author": "xcchang", "createdAt": "2020-11-16T16:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIzMTkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTA0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r525549047", "bodyText": "I would just go with a boolean, what do you think @zfrenette", "author": "Maithem", "createdAt": "2020-11-17T21:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIzMTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIzMjA4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523232082", "bodyText": "Cleaner to use a boolean in the protobuf message. See comment above.", "author": "Maithem", "createdAt": "2020-11-13T21:06:00Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/LayoutHandler.java", "diffHunk": "@@ -94,4 +105,116 @@ private static Object handleAlreadyBootstrap(CorfuMsg msg,\n             throws Exception {\n         throw new AlreadyBootstrappedException();\n     }\n+\n+    // Protobuf region\n+\n+    /**\n+     * Handle a layout response from the server.\n+     *\n+     * @param msg The layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return {@link Layout} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.LAYOUT_RESPONSE)\n+    private static Object handleLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                               IClientRouter r) {\n+        LayoutResponseMsg layoutResponse = msg.getPayload().getLayoutResponse();\n+        RpcCommon.LayoutMsg layoutMsg = layoutResponse.getLayout();\n+\n+        return CorfuProtocolCommon.getLayout(layoutMsg);\n+    }\n+\n+    /**\n+     * Handle a prepare layout response from the server.\n+     *\n+     * @param msg The prepare layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return {@link LayoutPrepareResponse} if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.PREPARE_LAYOUT_RESPONSE)\n+    private static Object handlePrepareLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                      IClientRouter r) {\n+        PrepareLayoutResponseMsg prepareLayoutMsg = msg.getPayload().getPrepareLayoutResponse();\n+        PrepareLayoutResponseMsg.Type type = prepareLayoutMsg.getRespType();\n+        long rank = prepareLayoutMsg.getRank();\n+        Layout layout = CorfuProtocolCommon.getLayout(prepareLayoutMsg.getLayout());\n+\n+        switch (type) {\n+            case ACK: return new LayoutPrepareResponse(rank, layout);\n+            case REJECT: throw new OutrankedException(rank, layout);\n+                // TODO for INVALID\n+            default: throw new UnsupportedOperationException(\"Response handler not provided\");\n+        }\n+    }\n+\n+    /**\n+     * Handle a propose layout response from the server.\n+     *\n+     * @param msg The propose layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return True if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.PROPOSE_LAYOUT_RESPONSE)\n+    private static Object handleProposeLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                      IClientRouter r) {\n+        ProposeLayoutResponseMsg proposeLayoutMsg = msg.getPayload().getProposeLayoutResponse();\n+        ProposeLayoutResponseMsg.Type type = proposeLayoutMsg.getRespType();\n+        long rank = proposeLayoutMsg.getRank();\n+\n+        switch (type) {\n+            case ACK: return true;\n+            case REJECT: throw new OutrankedException(rank);\n+                // TODO for INVALID\n+            default: throw new UnsupportedOperationException(\"Response handler not provided\");\n+        }\n+    }\n+\n+    /**\n+     * Handle a propose layout response from the server.\n+     *\n+     * @param msg The propose layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return True if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.COMMIT_LAYOUT_RESPONSE)\n+    private static Object handleCommitLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                     IClientRouter r) {\n+        CommitLayoutResponseMsg commitLayoutMsg = msg.getPayload().getCommitLayoutResponse();\n+        CommitLayoutResponseMsg.Type type = commitLayoutMsg.getRespType();\n+\n+        switch (type) {\n+            case ACK: return true;\n+            case NACK: return false;\n+            // TODO for INVALID\n+            default: throw new UnsupportedOperationException(\"Response handler not provided\");\n+        }\n+    }\n+\n+    /**\n+     * Handle a bootstrap layout response from the server.\n+     *\n+     * @param msg The propose layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return True if ACK, false if NACK.\n+     */\n+    @ResponseHandler(type = PayloadCase.BOOTSTRAP_LAYOUT_RESPONSE)\n+    private static Object handleBootstrapLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                        IClientRouter r) {\n+        BootstrapLayoutResponseMsg bootstrapLayoutMsg =  msg.getPayload().getBootstrapLayoutResponse();\n+        BootstrapLayoutResponseMsg.Type type = bootstrapLayoutMsg.getRespType();\n+\n+        switch (type) {\n+            case ACK: return true;\n+            case NACK: return false;\n+            // TODO for INVALID", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2OTg1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523769857", "bodyText": "Can we add the Javadocs for the methods in this class?", "author": "zfrenette", "createdAt": "2020-11-15T14:56:11Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolLayout.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+import org.corfudb.runtime.proto.service.Layout.BootstrapLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.BootstrapLayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.CommitLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.CommitLayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.LayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.LayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.PrepareLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.PrepareLayoutResponseMsg;\n+import org.corfudb.runtime.proto.service.Layout.ProposeLayoutRequestMsg;\n+import org.corfudb.runtime.proto.service.Layout.ProposeLayoutResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getLayout;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getLayoutMsg;\n+\n+@Slf4j\n+public class CorfuProtocolLayout {\n+    public static RequestPayloadMsg getLayoutRequestMsg(long epoch) {", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc5MDc3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r523790778", "bodyText": "LayoutPrepareResponse no longer needs to implement ICorfuPayoad. It can be removed, along with the related serialization methods.", "author": "zfrenette", "createdAt": "2020-11-15T17:53:22Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/LayoutHandler.java", "diffHunk": "@@ -94,4 +105,116 @@ private static Object handleAlreadyBootstrap(CorfuMsg msg,\n             throws Exception {\n         throw new AlreadyBootstrappedException();\n     }\n+\n+    // Protobuf region\n+\n+    /**\n+     * Handle a layout response from the server.\n+     *\n+     * @param msg The layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return {@link Layout} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.LAYOUT_RESPONSE)\n+    private static Object handleLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                               IClientRouter r) {\n+        LayoutResponseMsg layoutResponse = msg.getPayload().getLayoutResponse();\n+        RpcCommon.LayoutMsg layoutMsg = layoutResponse.getLayout();\n+\n+        return CorfuProtocolCommon.getLayout(layoutMsg);\n+    }\n+\n+    /**\n+     * Handle a prepare layout response from the server.\n+     *\n+     * @param msg The prepare layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return {@link LayoutPrepareResponse} if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.PREPARE_LAYOUT_RESPONSE)\n+    private static Object handlePrepareLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                      IClientRouter r) {\n+        PrepareLayoutResponseMsg prepareLayoutMsg = msg.getPayload().getPrepareLayoutResponse();\n+        PrepareLayoutResponseMsg.Type type = prepareLayoutMsg.getRespType();\n+        long rank = prepareLayoutMsg.getRank();\n+        Layout layout = CorfuProtocolCommon.getLayout(prepareLayoutMsg.getLayout());\n+\n+        switch (type) {\n+            case ACK: return new LayoutPrepareResponse(rank, layout);", "originalCommit": "5ef1fbf4a2bf76c739874a552a9be39003e19f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "87dc46b53952620e664bf12e8a05207702303600", "url": "https://github.com/CorfuDB/CorfuDB/commit/87dc46b53952620e664bf12e8a05207702303600", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-17T03:00:05Z", "type": "forcePushed"}, {"oid": "7cb8076e859398d4516c7171dfa5173323ece8e7", "url": "https://github.com/CorfuDB/CorfuDB/commit/7cb8076e859398d4516c7171dfa5173323ece8e7", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-17T04:39:44Z", "type": "forcePushed"}, {"oid": "3f2d1a7e26648441f17aae7fa4616c8a0f8ea5a7", "url": "https://github.com/CorfuDB/CorfuDB/commit/3f2d1a7e26648441f17aae7fa4616c8a0f8ea5a7", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-17T19:56:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4NjI5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r527286290", "bodyText": "We need the default header for the next set of handleMessage() calls of MANAGEMENT_BOOTSTRAP_REQUEST and BOOTSTRAP_SEQUENCER.\nTherefore, Can we move this to CorfuProtocolMessage?\nWe can add a new method to get default header and call CorfuProtocolMessage.getRequestMsg() with that header and the new payloadMsg.\npublic static HeaderMsg getDefaultHeaderMsg(boolean ignoreClusterId, boolean ignoreEpoch) {\n    return getHeaderMsg(0, CorfuMessage.PriorityLevel.NORMAL, 0,\n        DEFAULT_UUID, DEFAULT_UUID, ignoreClusterId, ignoreEpoch);\n}\n\nNote: Unfortunately, we cannot use HeaderMsg.getDefaultInstance() provided by Protobuf as it sets the values to empty instead of the default intended values. Its output is -\nheaderMsg.getRequestId() - 0\nheaderMsg.getClientId() - \nheaderMsg.getClusterId() - \nheaderMsg.getEpoch() - 0\nheaderMsg.getIgnoreEpoch() - false\nheaderMsg.getIgnoreClusterId() - false\nheaderMsg.getPriority() - PRIORITY_LEVEL_INVALID\nheaderMsg.getVersion() -", "author": "chetangudisagar", "createdAt": "2020-11-20T00:08:54Z", "path": "test/src/test/java/org/corfudb/runtime/view/AbstractViewTest.java", "diffHunk": "@@ -469,6 +474,12 @@ public String getEndpoint(int port) {\n \n     // Private\n \n+    private RequestMsg getRequest(CorfuMessage.RequestPayloadMsg payloadMsg) {\n+        CorfuMessage.HeaderMsg header = getHeaderMsg(0, CorfuMessage.PriorityLevel.NORMAL, 0,\n+                DEFAULT_UUID, DEFAULT_UUID, true, true);\n+        return getRequestMsg(header, payloadMsg);\n+    }\n+", "originalCommit": "3f2d1a7e26648441f17aae7fa4616c8a0f8ea5a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNTcwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r527325703", "bodyText": "Update: After an internal discussion, we decided to add a temporary variable within the method to be reused by all 3 request messges -\npublic void bootstrapAllServers(Layout l) {\n    CorfuMessage.HeaderMsg headerMsg = getHeaderMsg(0, CorfuMessage.PriorityLevel.NORMAL, 0,\n            DEFAULT_UUID, DEFAULT_UUID, true, true);\n    ...\n    ...", "author": "chetangudisagar", "createdAt": "2020-11-20T00:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4NjI5MA=="}], "type": "inlineReview"}, {"oid": "be0b24b43225a79318d490fb7de7257f5eee2846", "url": "https://github.com/CorfuDB/CorfuDB/commit/be0b24b43225a79318d490fb7de7257f5eee2846", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-20T00:20:38Z", "type": "forcePushed"}, {"oid": "3cb7a95b8152fd197641df912dfb5ebb2202b324", "url": "https://github.com/CorfuDB/CorfuDB/commit/3cb7a95b8152fd197641df912dfb5ebb2202b324", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-20T01:07:21Z", "type": "forcePushed"}, {"oid": "998afc7e60085b1ef21b4ecbc0a3977e107ad1ac", "url": "https://github.com/CorfuDB/CorfuDB/commit/998afc7e60085b1ef21b4ecbc0a3977e107ad1ac", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-23T01:54:22Z", "type": "forcePushed"}, {"oid": "2fdbb67094b352babd14d105b137974e24713447", "url": "https://github.com/CorfuDB/CorfuDB/commit/2fdbb67094b352babd14d105b137974e24713447", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-23T02:00:12Z", "type": "forcePushed"}, {"oid": "0474bae615ffbe1cf368df11f715f7ba70714512", "url": "https://github.com/CorfuDB/CorfuDB/commit/0474bae615ffbe1cf368df11f715f7ba70714512", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-23T02:49:39Z", "type": "forcePushed"}, {"oid": "9b0f308597cc2c0b8e7d26ba85877410813cf8f0", "url": "https://github.com/CorfuDB/CorfuDB/commit/9b0f308597cc2c0b8e7d26ba85877410813cf8f0", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-23T03:24:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE0NjMyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r529146327", "bodyText": "Would it be better to use a mock of the DataStore instead?", "author": "zfrenette", "createdAt": "2020-11-24T02:19:53Z", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuLayoutServerTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.datastore.DataStore;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+public class CorfuLayoutServerTest {\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // LayoutServer instance used for testing\n+    private LayoutServer layoutServer;\n+\n+    // Objects that need to be mocked\n+    private ServerContext mockServerContext;\n+    private IServerRouter mockServerRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     * @param requestHeader   the header from the request message\n+     * @param responseHeader  the header from the response message\n+     * @return                true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        mockServerContext = mock(ServerContext.class);\n+        mockServerRouter = mock(IServerRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+\n+        // Initialize an in memory DataStore for LayoutServer\n+        when(mockServerContext.getDataStore()).thenReturn(\n+                new DataStore(new ImmutableMap.Builder<String, Object>()\n+                .put(\"--memory\", true)\n+                .build(), fn -> { }));", "originalCommit": "9b0f308597cc2c0b8e7d26ba85877410813cf8f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NTIwOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r529165209", "bodyText": "This DataStore is used to initialize the paxosDataStore field of LayoutServer, which is needed to get phase1rank when handling PROPOSE_LAYOUT_REQUEST for example, and it's not exposed. So some changes may be necessary if we do want to use mocking for paxosDataStore, like moving it to serverContext?", "author": "xcchang", "createdAt": "2020-11-24T02:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE0NjMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxOTAwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r529619007", "bodyText": "It is already available from the server context:\n        this.paxosDataStore = PaxosDataStore.builder()\n                .dataStore(serverContext.getDataStore())\n                .build();\n\nYou can continue to use the PaxosDataStore wrapper, but the data store itself can already be mocked easily since we are mocking the server context -- Just return a mock DataStore when getDataStore() is called.", "author": "zfrenette", "createdAt": "2020-11-24T15:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE0NjMyNw=="}], "type": "inlineReview"}, {"oid": "1e9761ce4b28bab1ecace96e720d3b9cf5c148da", "url": "https://github.com/CorfuDB/CorfuDB/commit/1e9761ce4b28bab1ecace96e720d3b9cf5c148da", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-24T03:53:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5MTk4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r529191983", "bodyText": "static methods make code less maintainable/testable", "author": "xnull", "createdAt": "2020-11-24T04:18:55Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/LayoutHandler.java", "diffHunk": "@@ -52,46 +59,116 @@ public LayoutClient getClient(long epoch, UUID clusterID) {\n             .generateHandlers(MethodHandles.lookup(), this)\n             .generateErrorHandlers(MethodHandles.lookup(), this);\n \n+    /**\n+     * TODO: Remove this method when Management RPC get landed.\n+     */\n+    @Deprecated\n+    @ClientHandler(type = CorfuMsgType.LAYOUT_NOBOOTSTRAP)\n+    private static Object handleNoBootstrap(CorfuMsg msg,\n+                                            ChannelHandlerContext ctx, IClientRouter r)\n+            throws Exception {\n+        throw new NoBootstrapException();\n+    }\n \n+    /**\n+     * TODO: Remove this method when Management RPC get landed.\n+     */\n+    @Deprecated\n     @ClientHandler(type = CorfuMsgType.LAYOUT_RESPONSE)\n     private static Object handleLayoutResponse(CorfuMsg msg,\n                                                ChannelHandlerContext ctx, IClientRouter r) {\n         return ((LayoutMsg) msg).getLayout();\n     }\n \n-    @ClientHandler(type = CorfuMsgType.LAYOUT_PREPARE_ACK)\n-    private static Object handleLayoutPrepareAck(CorfuPayloadMsg<LayoutPrepareRequest> msg,\n-                                                 ChannelHandlerContext ctx, IClientRouter r) {\n-        return msg.getPayload();\n+    /**\n+     * Handle a layout response from the server.\n+     *\n+     * @param msg The layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return {@link Layout} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.LAYOUT_RESPONSE)\n+    private static Object handleLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                               IClientRouter r) {\n+        LayoutResponseMsg layoutResponse = msg.getPayload().getLayoutResponse();\n+        RpcCommon.LayoutMsg layoutMsg = layoutResponse.getLayout();\n+\n+        return CorfuProtocolCommon.getLayout(layoutMsg);\n     }\n \n-    @ClientHandler(type = CorfuMsgType.LAYOUT_NOBOOTSTRAP)\n-    private static Object handleNoBootstrap(CorfuMsg msg,\n-                                            ChannelHandlerContext ctx, IClientRouter r)\n-            throws Exception {\n-        throw new NoBootstrapException();\n+    /**\n+     * Handle a prepare layout response from the server.\n+     *\n+     * @param msg The prepare layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return {@link LayoutPrepareResponse} if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.PREPARE_LAYOUT_RESPONSE)\n+    private static Object handlePrepareLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                      IClientRouter r) {\n+        PrepareLayoutResponseMsg prepareLayoutMsg = msg.getPayload().getPrepareLayoutResponse();\n+        boolean prepared = prepareLayoutMsg.getPrepared();\n+        long rank = prepareLayoutMsg.getRank();\n+        Layout layout = CorfuProtocolCommon.getLayout(prepareLayoutMsg.getLayout());", "originalCommit": "1e9761ce4b28bab1ecace96e720d3b9cf5c148da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NDE5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r544764196", "bodyText": "Sure, but in this case its a It's a stateless helper method. Anyways, if you still want this to change, the please propose something more actionable.", "author": "Maithem", "createdAt": "2020-12-17T02:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5MTk4Mw=="}], "type": "inlineReview"}, {"oid": "de28b513f86239c87c66badcc2b7dfae6951a833", "url": "https://github.com/CorfuDB/CorfuDB/commit/de28b513f86239c87c66badcc2b7dfae6951a833", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-24T19:39:06Z", "type": "forcePushed"}, {"oid": "df3556abe06ec7207beb7187d8404f33a6744f92", "url": "https://github.com/CorfuDB/CorfuDB/commit/df3556abe06ec7207beb7187d8404f33a6744f92", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-24T19:44:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MTg3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r530041879", "bodyText": "Maybe use a non-zero value here? It could make some failures more noticeable.", "author": "zfrenette", "createdAt": "2020-11-25T01:03:55Z", "path": "runtime/src/test/java/org/corfudb/runtime/clients/CorfuLayoutHandlerTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.exceptions.OutrankedException;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class CorfuLayoutHandlerTest {\n+\n+    // The BaseHandler instance used for testing\n+    private LayoutHandler layoutHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual\n+     * tests by preparing the mocks.\n+     */\n+    @Before\n+    public void setup() {\n+        mockClientRouter = mock(IClientRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        layoutHandler = new LayoutHandler();\n+        layoutHandler.setRouter(mockClientRouter);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testGetLayout() throws IOException {\n+        Layout defaultLayout = getDefaultLayout();\n+        List<String> unresponsiveServers = defaultLayout.getUnresponsiveServers();\n+        unresponsiveServers.add(\"localhost:9001\");\n+        defaultLayout.setUnresponsiveServers(unresponsiveServers);\n+\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getLayoutResponseMsg(defaultLayout)\n+        );\n+\n+        layoutHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<Layout> layoutCaptor = ArgumentCaptor.forClass(Layout.class);\n+\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), layoutCaptor.capture());\n+\n+        Layout layout = layoutCaptor.getValue();\n+        assertThat(layout.getActiveLayoutServers()).containsExactly(\"localhost:9000\", \"localhost:9002\");\n+        assertThat(layout.getSequencers()).containsExactly(\"localhost:9000\");\n+        assertThat(layout.getAllLogServers()).containsExactly(\"localhost:9002\", \"localhost:9001\", \"localhost:9000\");\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a BOOTSTRAP_LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testBootstrapLayout() {\n+        ResponseMsg responseACK = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getBootstrapLayoutResponseMsg(true)\n+        );\n+\n+        ResponseMsg responseNACK = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getBootstrapLayoutResponseMsg(false)\n+        );\n+\n+        layoutHandler.handleMessage(responseACK, mockChannelHandlerContext);\n+        layoutHandler.handleMessage(responseNACK, mockChannelHandlerContext);\n+\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(responseACK.getHeader().getRequestId(), true);\n+        verify(mockClientRouter).completeRequest(responseNACK.getHeader().getRequestId(), false);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a PREPARE_LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testPrepare() throws IOException {\n+        Layout defaultLayout = getDefaultLayout();\n+        long defaultRank = 0L;", "originalCommit": "df3556abe06ec7207beb7187d8404f33a6744f92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0NDMzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r530044336", "bodyText": "You can consider factoring these assertions into a private method that can be reused.", "author": "zfrenette", "createdAt": "2020-11-25T01:12:10Z", "path": "runtime/src/test/java/org/corfudb/runtime/clients/CorfuLayoutHandlerTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.exceptions.OutrankedException;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class CorfuLayoutHandlerTest {\n+\n+    // The BaseHandler instance used for testing\n+    private LayoutHandler layoutHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual\n+     * tests by preparing the mocks.\n+     */\n+    @Before\n+    public void setup() {\n+        mockClientRouter = mock(IClientRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        layoutHandler = new LayoutHandler();\n+        layoutHandler.setRouter(mockClientRouter);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testGetLayout() throws IOException {\n+        Layout defaultLayout = getDefaultLayout();\n+        List<String> unresponsiveServers = defaultLayout.getUnresponsiveServers();\n+        unresponsiveServers.add(\"localhost:9001\");\n+        defaultLayout.setUnresponsiveServers(unresponsiveServers);\n+\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getLayoutResponseMsg(defaultLayout)\n+        );\n+\n+        layoutHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<Layout> layoutCaptor = ArgumentCaptor.forClass(Layout.class);\n+\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), layoutCaptor.capture());\n+\n+        Layout layout = layoutCaptor.getValue();\n+        assertThat(layout.getActiveLayoutServers()).containsExactly(\"localhost:9000\", \"localhost:9002\");\n+        assertThat(layout.getSequencers()).containsExactly(\"localhost:9000\");\n+        assertThat(layout.getAllLogServers()).containsExactly(\"localhost:9002\", \"localhost:9001\", \"localhost:9000\");\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a BOOTSTRAP_LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testBootstrapLayout() {\n+        ResponseMsg responseACK = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getBootstrapLayoutResponseMsg(true)\n+        );\n+\n+        ResponseMsg responseNACK = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getBootstrapLayoutResponseMsg(false)\n+        );\n+\n+        layoutHandler.handleMessage(responseACK, mockChannelHandlerContext);\n+        layoutHandler.handleMessage(responseNACK, mockChannelHandlerContext);\n+\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(responseACK.getHeader().getRequestId(), true);\n+        verify(mockClientRouter).completeRequest(responseNACK.getHeader().getRequestId(), false);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a PREPARE_LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testPrepare() throws IOException {\n+        Layout defaultLayout = getDefaultLayout();\n+        long defaultRank = 0L;\n+        ResponseMsg responseACK = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getPrepareLayoutResponseMsg(true, defaultRank, defaultLayout)\n+        );\n+        ResponseMsg responseREJECT = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getPrepareLayoutResponseMsg(false, defaultRank, defaultLayout)\n+        );\n+\n+        // Verify that the correct request was completed (once) with the appropriate value.\n+        layoutHandler.handleMessage(responseACK, mockChannelHandlerContext);\n+        ArgumentCaptor<LayoutPrepareResponse> layoutPrepareCaptor = ArgumentCaptor.forClass(LayoutPrepareResponse.class);\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(responseACK.getHeader().getRequestId()), layoutPrepareCaptor.capture());\n+\n+        LayoutPrepareResponse layoutPrepareCaptorValue = layoutPrepareCaptor.getValue();\n+        Layout retLayout = layoutPrepareCaptorValue.getLayout();\n+        assertThat(retLayout.getActiveLayoutServers()).containsExactly(\"localhost:9000\", \"localhost:9001\", \"localhost:9002\");\n+        assertThat(retLayout.getSequencers()).containsExactly(\"localhost:9000\");\n+        assertThat(retLayout.getAllLogServers()).containsExactly(\"localhost:9002\", \"localhost:9001\", \"localhost:9000\");", "originalCommit": "df3556abe06ec7207beb7187d8404f33a6744f92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0NDY3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r530044675", "bodyText": "Maybe use a non-zero value here too.", "author": "zfrenette", "createdAt": "2020-11-25T01:13:21Z", "path": "runtime/src/test/java/org/corfudb/runtime/clients/CorfuLayoutHandlerTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.exceptions.OutrankedException;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class CorfuLayoutHandlerTest {\n+\n+    // The BaseHandler instance used for testing\n+    private LayoutHandler layoutHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual\n+     * tests by preparing the mocks.\n+     */\n+    @Before\n+    public void setup() {\n+        mockClientRouter = mock(IClientRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        layoutHandler = new LayoutHandler();\n+        layoutHandler.setRouter(mockClientRouter);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testGetLayout() throws IOException {\n+        Layout defaultLayout = getDefaultLayout();\n+        List<String> unresponsiveServers = defaultLayout.getUnresponsiveServers();\n+        unresponsiveServers.add(\"localhost:9001\");\n+        defaultLayout.setUnresponsiveServers(unresponsiveServers);\n+\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getLayoutResponseMsg(defaultLayout)\n+        );\n+\n+        layoutHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<Layout> layoutCaptor = ArgumentCaptor.forClass(Layout.class);\n+\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), layoutCaptor.capture());\n+\n+        Layout layout = layoutCaptor.getValue();\n+        assertThat(layout.getActiveLayoutServers()).containsExactly(\"localhost:9000\", \"localhost:9002\");\n+        assertThat(layout.getSequencers()).containsExactly(\"localhost:9000\");\n+        assertThat(layout.getAllLogServers()).containsExactly(\"localhost:9002\", \"localhost:9001\", \"localhost:9000\");\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a BOOTSTRAP_LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testBootstrapLayout() {\n+        ResponseMsg responseACK = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getBootstrapLayoutResponseMsg(true)\n+        );\n+\n+        ResponseMsg responseNACK = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getBootstrapLayoutResponseMsg(false)\n+        );\n+\n+        layoutHandler.handleMessage(responseACK, mockChannelHandlerContext);\n+        layoutHandler.handleMessage(responseNACK, mockChannelHandlerContext);\n+\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(responseACK.getHeader().getRequestId(), true);\n+        verify(mockClientRouter).completeRequest(responseNACK.getHeader().getRequestId(), false);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a PREPARE_LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testPrepare() throws IOException {\n+        Layout defaultLayout = getDefaultLayout();\n+        long defaultRank = 0L;\n+        ResponseMsg responseACK = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getPrepareLayoutResponseMsg(true, defaultRank, defaultLayout)\n+        );\n+        ResponseMsg responseREJECT = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getPrepareLayoutResponseMsg(false, defaultRank, defaultLayout)\n+        );\n+\n+        // Verify that the correct request was completed (once) with the appropriate value.\n+        layoutHandler.handleMessage(responseACK, mockChannelHandlerContext);\n+        ArgumentCaptor<LayoutPrepareResponse> layoutPrepareCaptor = ArgumentCaptor.forClass(LayoutPrepareResponse.class);\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(responseACK.getHeader().getRequestId()), layoutPrepareCaptor.capture());\n+\n+        LayoutPrepareResponse layoutPrepareCaptorValue = layoutPrepareCaptor.getValue();\n+        Layout retLayout = layoutPrepareCaptorValue.getLayout();\n+        assertThat(retLayout.getActiveLayoutServers()).containsExactly(\"localhost:9000\", \"localhost:9001\", \"localhost:9002\");\n+        assertThat(retLayout.getSequencers()).containsExactly(\"localhost:9000\");\n+        assertThat(retLayout.getAllLogServers()).containsExactly(\"localhost:9002\", \"localhost:9001\", \"localhost:9000\");\n+\n+        // Verify that the correct exception was thrown with the appropriate field set.\n+        layoutHandler.handleMessage(responseREJECT, mockChannelHandlerContext);\n+        ArgumentCaptor<OutrankedException> exceptionCaptor = ArgumentCaptor.forClass(OutrankedException.class);\n+        verify(mockClientRouter).completeExceptionally(\n+                eq(responseREJECT.getHeader().getRequestId()), exceptionCaptor.capture());\n+        OutrankedException outrankedException = exceptionCaptor.getValue();\n+        assertThat(outrankedException.getNewRank()).isEqualTo(defaultRank);\n+\n+        retLayout = outrankedException.getLayout();\n+        assertThat(retLayout.getActiveLayoutServers()).containsExactly(\"localhost:9000\", \"localhost:9001\", \"localhost:9002\");\n+        assertThat(retLayout.getSequencers()).containsExactly(\"localhost:9000\");\n+        assertThat(retLayout.getAllLogServers()).containsExactly(\"localhost:9002\", \"localhost:9001\", \"localhost:9000\");\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a PROPOSE_LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testPropose() {\n+        long defaultRank = 0L;", "originalCommit": "df3556abe06ec7207beb7187d8404f33a6744f92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0NjI5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r530046296", "bodyText": "Would it be worth considering the case where deserializing the Layout throws an exception, and seeing that we complete exceptionally?", "author": "zfrenette", "createdAt": "2020-11-25T01:18:13Z", "path": "runtime/src/test/java/org/corfudb/runtime/clients/CorfuLayoutHandlerTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.exceptions.OutrankedException;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class CorfuLayoutHandlerTest {\n+\n+    // The BaseHandler instance used for testing\n+    private LayoutHandler layoutHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual\n+     * tests by preparing the mocks.\n+     */\n+    @Before\n+    public void setup() {\n+        mockClientRouter = mock(IClientRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        layoutHandler = new LayoutHandler();\n+        layoutHandler.setRouter(mockClientRouter);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a LAYOUT_RESPONSE.\n+     */", "originalCommit": "df3556abe06ec7207beb7187d8404f33a6744f92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NjM1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r530596357", "bodyText": "Maybe consider adding a cause of a null clusterId in the comment description (i.e. ... correctly handles a BOOTSTRAP_LAYOUT_REQUEST with a legacy layout having a null clusterId)", "author": "zfrenette", "createdAt": "2020-11-25T19:22:13Z", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuLayoutServerTest.java", "diffHunk": "@@ -0,0 +1,710 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.datastore.DataStore;\n+import org.corfudb.infrastructure.datastore.KvDataStore.KvRecord;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.ServerErrors.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+public class CorfuLayoutServerTest {\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // LayoutServer instance used for testing\n+    private LayoutServer layoutServer;\n+\n+    // Objects that need to be mocked\n+    private ServerContext mockServerContext;\n+    private IServerRouter mockServerRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    private DataStore mockDataStore;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     * @param requestHeader   the header from the request message\n+     * @param responseHeader  the header from the response message\n+     * @return                true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        mockServerContext = mock(ServerContext.class);\n+        mockServerRouter = mock(IServerRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        mockDataStore = mock(DataStore.class);\n+\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+\n+        // Initialize an in memory DataStore for LayoutServer\n+//        when(mockServerContext.getDataStore()).thenReturn(\n+//                new DataStore(new ImmutableMap.Builder<String, Object>()\n+//                .put(\"--memory\", true)\n+//                .build(), fn -> { }));\n+        when(mockServerContext.getDataStore()).thenReturn(mockDataStore);\n+\n+        layoutServer = new LayoutServer(mockServerContext);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testBootstrapLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertTrue(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST with null clusterId.", "originalCommit": "df3556abe06ec7207beb7187d8404f33a6744f92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1c89f812cd710cf939c87182d6bbea8065b29dbf", "url": "https://github.com/CorfuDB/CorfuDB/commit/1c89f812cd710cf939c87182d6bbea8065b29dbf", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-30T14:31:54Z", "type": "forcePushed"}, {"oid": "ddad1bdb071d36d1fe72f1adcb603bb9fc76d515", "url": "https://github.com/CorfuDB/CorfuDB/commit/ddad1bdb071d36d1fe72f1adcb603bb9fc76d515", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-30T15:58:03Z", "type": "forcePushed"}, {"oid": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "url": "https://github.com/CorfuDB/CorfuDB/commit/4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-11-30T20:51:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyMjg0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532922849", "bodyText": "nit: I think we have to wait until the end to remove this since it may be sent by IServerRouter whenever it handles a legacy CorfuMsg.", "author": "zfrenette", "createdAt": "2020-11-30T21:43:59Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/LayoutHandler.java", "diffHunk": "@@ -52,46 +59,116 @@ public LayoutClient getClient(long epoch, UUID clusterID) {\n             .generateHandlers(MethodHandles.lookup(), this)\n             .generateErrorHandlers(MethodHandles.lookup(), this);\n \n+    /**\n+     * TODO: Remove this method when Management RPC get landed.", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyNDM4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532924389", "bodyText": "LayoutHandler instance", "author": "zfrenette", "createdAt": "2020-11-30T21:46:53Z", "path": "runtime/src/test/java/org/corfudb/runtime/clients/CorfuLayoutHandlerTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.exceptions.OutrankedException;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.LinkedList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.corfudb.runtime.view.Layout.fromJSONString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class CorfuLayoutHandlerTest {\n+\n+    // The BaseHandler instance used for testing", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyNjU3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532926575", "bodyText": "Do we need to capture the Layout here? I think calling verify with just defaultLayout should work.", "author": "zfrenette", "createdAt": "2020-11-30T21:50:58Z", "path": "runtime/src/test/java/org/corfudb/runtime/clients/CorfuLayoutHandlerTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.exceptions.OutrankedException;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.LinkedList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.corfudb.runtime.view.Layout.fromJSONString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class CorfuLayoutHandlerTest {\n+\n+    // The BaseHandler instance used for testing\n+    private LayoutHandler layoutHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual\n+     * tests by preparing the mocks.\n+     */\n+    @Before\n+    public void setup() {\n+        mockClientRouter = mock(IClientRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        layoutHandler = new LayoutHandler();\n+        layoutHandler.setRouter(mockClientRouter);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testGetLayout() throws IOException {\n+        Layout defaultLayout = getDefaultLayout();\n+\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getLayoutResponseMsg(defaultLayout)\n+        );\n+\n+        layoutHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<Layout> layoutCaptor = ArgumentCaptor.forClass(Layout.class);\n+\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), layoutCaptor.capture());\n+\n+        Layout layout = layoutCaptor.getValue();\n+        assertLayoutMatch(layout);", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzMDYwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532930607", "bodyText": "Does LayoutPrepareResponse still need to implement ICorfuPayload?", "author": "zfrenette", "createdAt": "2020-11-30T21:58:49Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/CorfuMsgType.java", "diffHunk": "@@ -32,14 +32,7 @@\n     WRONG_CLUSTER_ID(28, new TypeToken<CorfuPayloadMsg<WrongClusterMsg>>(){}, true, false),\n \n     // Layout Messages\n-    LAYOUT_REQUEST(10, new TypeToken<CorfuPayloadMsg<Long>>(){}, true, true),\n     LAYOUT_RESPONSE(11, TypeToken.of(LayoutMsg.class), true, false),\n-    LAYOUT_PREPARE(12, new TypeToken<CorfuPayloadMsg<LayoutPrepareRequest>>(){}, true, false),\n-    LAYOUT_PREPARE_REJECT(13, new TypeToken<CorfuPayloadMsg<LayoutPrepareResponse>>(){}),", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzMTc3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532931779", "bodyText": "Should this be getBasicHeader(false, true)?", "author": "zfrenette", "createdAt": "2020-11-30T22:01:00Z", "path": "runtime/src/test/java/org/corfudb/runtime/clients/CorfuLayoutHandlerTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.exceptions.OutrankedException;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.LinkedList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.corfudb.runtime.view.Layout.fromJSONString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class CorfuLayoutHandlerTest {\n+\n+    // The BaseHandler instance used for testing\n+    private LayoutHandler layoutHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual\n+     * tests by preparing the mocks.\n+     */\n+    @Before\n+    public void setup() {\n+        mockClientRouter = mock(IClientRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        layoutHandler = new LayoutHandler();\n+        layoutHandler.setRouter(mockClientRouter);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testGetLayout() throws IOException {\n+        Layout defaultLayout = getDefaultLayout();\n+\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getLayoutResponseMsg(defaultLayout)\n+        );\n+\n+        layoutHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<Layout> layoutCaptor = ArgumentCaptor.forClass(Layout.class);\n+\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), layoutCaptor.capture());\n+\n+        Layout layout = layoutCaptor.getValue();\n+        assertLayoutMatch(layout);\n+    }\n+\n+\n+    /**\n+     * Test that the LayoutHandler throws a SerializerException when handling\n+     * LAYOUT_RESPONSE without necessary fields.\n+     */\n+    @Test\n+    public void testMalformedGetLayout() throws IOException {\n+        Layout defaultLayout = getDefaultLayout();\n+        defaultLayout.setLayoutServers(new LinkedList<>());\n+\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getLayoutResponseMsg(defaultLayout)\n+        );\n+\n+        layoutHandler.handleMessage(response, mockChannelHandlerContext);\n+\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter).completeExceptionally(anyLong(), any(SerializerException.class));\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a BOOTSTRAP_LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testBootstrapLayout() {\n+        ResponseMsg responseACK = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getBootstrapLayoutResponseMsg(true)\n+        );\n+\n+        ResponseMsg responseNACK = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getBootstrapLayoutResponseMsg(false)\n+        );\n+\n+        layoutHandler.handleMessage(responseACK, mockChannelHandlerContext);\n+        layoutHandler.handleMessage(responseNACK, mockChannelHandlerContext);\n+\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(responseACK.getHeader().getRequestId(), true);\n+        verify(mockClientRouter).completeRequest(responseNACK.getHeader().getRequestId(), false);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a PREPARE_LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testPrepare() throws IOException {\n+        Layout defaultLayout = getDefaultLayout();\n+        long defaultRank = 5L;\n+        ResponseMsg responseACK = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getPrepareLayoutResponseMsg(true, defaultRank, defaultLayout)\n+        );\n+        ResponseMsg responseREJECT = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getPrepareLayoutResponseMsg(false, defaultRank, defaultLayout)\n+        );\n+\n+        // Verify that the correct request was completed (once) with the appropriate value.\n+        layoutHandler.handleMessage(responseACK, mockChannelHandlerContext);\n+        ArgumentCaptor<LayoutPrepareResponse> layoutPrepareCaptor = ArgumentCaptor.forClass(LayoutPrepareResponse.class);\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(responseACK.getHeader().getRequestId()), layoutPrepareCaptor.capture());\n+\n+        LayoutPrepareResponse layoutPrepareCaptorValue = layoutPrepareCaptor.getValue();\n+        Layout retLayout = layoutPrepareCaptorValue.getLayout();\n+        assertLayoutMatch(retLayout);\n+\n+        // Verify that the correct exception was thrown with the appropriate field set.\n+        layoutHandler.handleMessage(responseREJECT, mockChannelHandlerContext);\n+        ArgumentCaptor<OutrankedException> exceptionCaptor = ArgumentCaptor.forClass(OutrankedException.class);\n+        verify(mockClientRouter).completeExceptionally(\n+                eq(responseREJECT.getHeader().getRequestId()), exceptionCaptor.capture());\n+        OutrankedException outrankedException = exceptionCaptor.getValue();\n+        assertThat(outrankedException.getNewRank()).isEqualTo(defaultRank);\n+\n+        retLayout = outrankedException.getLayout();\n+        assertLayoutMatch(retLayout);\n+    }\n+\n+    /**\n+     * Test that the LayoutHandler correctly handles a PROPOSE_LAYOUT_RESPONSE.\n+     */\n+    @Test\n+    public void testPropose() {\n+        long defaultRank = 5L;\n+        ResponseMsg responseACK = getResponseMsg(\n+                getBasicHeader(false, false),", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0MjgzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532942837", "bodyText": "This can be removed as this is the default behaviour in AbstractServer.", "author": "zfrenette", "createdAt": "2020-11-30T22:24:08Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -101,19 +96,18 @@ public LayoutServer(@Nonnull ServerContext serverContext) {\n                 .dataStore(serverContext.getDataStore())\n                 .build();\n \n-        executor = Executors.newFixedThreadPool(\n-                serverContext.getLayoutServerThreadCount(),\n-                new ServerThreadFactory(\"layoutServer-\", new ExceptionHandler())\n-        );\n+        this.executor = serverContext.getExecutorService(\n+                serverContext.getLayoutServerThreadCount(), \"layoutServer-\");\n \n         if (serverContext.installSingleNodeLayoutIfAbsent()) {\n             setLayoutInHistory(getCurrentLayout());\n         }\n     }\n \n     @Override\n+    @Deprecated\n     protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        executor.submit(() -> getHandler().handle(msg, ctx, r));\n+        throw new UnsupportedOperationException(\"CorfuMsg is no longer supported, please use Protobuf\");\n     }", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0NjA0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532946041", "bodyText": "Since getLayout() can return null, we should also perform a check for null here.", "author": "zfrenette", "createdAt": "2020-11-30T22:30:57Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,275 +134,317 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if (!isBootstrapped(req)) {\n+            r.sendNoBootstrapError(req.getHeader(), ctx);\n             return;\n         }\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if (payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            log.warn(\"handleLayoutRequest[{}]: Payload epoch {} ahead of Server epoch {}\",\n+                    req.getHeader().getRequestId(), payloadEpoch, serverEpoch);\n+\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(serverEpoch));\n+            r.sendResponse(response, ctx);\n         }\n     }\n \n     /**\n      * Sets the new layout if the server has not been bootstrapped with one already.\n      *\n-     * @param msg corfu message containing LAYOUT_BOOTSTRAP\n+     * @param req corfu message containing BOOTSTRAP_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_BOOTSTRAP)\n-    public synchronized void handleMessageLayoutBootstrap(\n-            @NonNull CorfuPayloadMsg<LayoutBootstrapRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)\n+    public synchronized void handleBootstrapLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        if (getCurrentLayout() != null) {\n+            log.warn(\"handleBootstrapLayoutRequest[{}]: Got a request to bootstrap a server which is \"\n+                    + \"already bootstrapped, rejecting!\", requestHeader.getRequestId());\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, true);\n+            response = getResponseMsg(responseHeader, getBootstrappedErrorMsg());\n+            r.sendResponse(response, ctx);\n+            return;\n+        }\n \n-        if (getCurrentLayout() == null) {\n-            Layout layout = msg.getPayload().getLayout();\n-\n-            log.info(\"handleMessageLayoutBootstrap: Bootstrap with new layout={}, {}\",\n-                    layout, msg);\n-\n-            if (layout.getClusterId() == null) {\n-                log.warn(\"handleMessageLayoutBootstrap: The layout does {} not have a clusterId\",\n-                        layout);\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.NACK));\n-            }\n-            else{\n-                setCurrentLayout(layout);\n-                serverContext.setServerEpoch(layout.getEpoch(), r);\n-                //send a response that the bootstrap was successful.\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.ACK));\n-            }\n+        final Layout layout = getLayout(req.getPayload().getBootstrapLayoutRequest().getLayout());\n+\n+        if (layout.getClusterId() == null) {", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0OTE3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532949173", "bodyText": "Should we perform a check for null before this?", "author": "zfrenette", "createdAt": "2020-11-30T22:37:53Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,275 +134,317 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if (!isBootstrapped(req)) {\n+            r.sendNoBootstrapError(req.getHeader(), ctx);\n             return;\n         }\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if (payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            log.warn(\"handleLayoutRequest[{}]: Payload epoch {} ahead of Server epoch {}\",\n+                    req.getHeader().getRequestId(), payloadEpoch, serverEpoch);\n+\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(serverEpoch));\n+            r.sendResponse(response, ctx);\n         }\n     }\n \n     /**\n      * Sets the new layout if the server has not been bootstrapped with one already.\n      *\n-     * @param msg corfu message containing LAYOUT_BOOTSTRAP\n+     * @param req corfu message containing BOOTSTRAP_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_BOOTSTRAP)\n-    public synchronized void handleMessageLayoutBootstrap(\n-            @NonNull CorfuPayloadMsg<LayoutBootstrapRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)\n+    public synchronized void handleBootstrapLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        if (getCurrentLayout() != null) {\n+            log.warn(\"handleBootstrapLayoutRequest[{}]: Got a request to bootstrap a server which is \"\n+                    + \"already bootstrapped, rejecting!\", requestHeader.getRequestId());\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, true);\n+            response = getResponseMsg(responseHeader, getBootstrappedErrorMsg());\n+            r.sendResponse(response, ctx);\n+            return;\n+        }\n \n-        if (getCurrentLayout() == null) {\n-            Layout layout = msg.getPayload().getLayout();\n-\n-            log.info(\"handleMessageLayoutBootstrap: Bootstrap with new layout={}, {}\",\n-                    layout, msg);\n-\n-            if (layout.getClusterId() == null) {\n-                log.warn(\"handleMessageLayoutBootstrap: The layout does {} not have a clusterId\",\n-                        layout);\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.NACK));\n-            }\n-            else{\n-                setCurrentLayout(layout);\n-                serverContext.setServerEpoch(layout.getEpoch(), r);\n-                //send a response that the bootstrap was successful.\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.ACK));\n-            }\n+        final Layout layout = getLayout(req.getPayload().getBootstrapLayoutRequest().getLayout());\n+\n+        if (layout.getClusterId() == null) {\n+            log.warn(\"handleBootstrapLayoutRequest[{}]: The layout={} does not have a clusterId\",\n+                    requestHeader.getRequestId(), layout);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader,\n+                    getBootstrapLayoutResponseMsg(false));\n         } else {\n-            // We are already bootstrapped, bootstrap again is not allowed.\n-            log.warn(\"handleMessageLayoutBootstrap: Got a request to bootstrap a server which is \"\n-                    + \"already bootstrapped, rejecting!\");\n-            r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.LAYOUT_ALREADY_BOOTSTRAP));\n+            log.info(\"handleBootstrapLayoutRequest[{}]: Bootstrap with new layout={}\", requestHeader.getRequestId(), layout);\n+            setCurrentLayout(layout);\n+            serverContext.setServerEpoch(layout.getEpoch(), r);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, true);\n+            response = getResponseMsg(responseHeader,\n+                    getBootstrapLayoutResponseMsg(true));\n         }\n+\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * Accepts a prepare message if the rank is higher than any accepted so far.\n      *\n-     * @param msg corfu message containing LAYOUT_PREPARE\n+     * @param req corfu message containing PREPARE_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    // TODO this can work under a separate lock for this step as it does not change the global\n-    // components\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_PREPARE)\n-    public synchronized void handleMessageLayoutPrepare(\n-            @NonNull CorfuPayloadMsg<LayoutPrepareRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        // Check if the prepare is for the correct epoch\n-        if (!isBootstrapped(msg, ctx, r)) {\n+    // TODO this can work under a separate lock for this step as it does not change the global components\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.PREPARE_LAYOUT_REQUEST)\n+    public synchronized void handlePrepareLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        final PrepareLayoutRequestMsg payload = req.getPayload().getPrepareLayoutRequest();\n+\n+        if (!isBootstrapped(req)) {\n+            r.sendNoBootstrapError(req.getHeader(), ctx);\n             return;\n         }\n \n-        final long payloadEpoch = msg.getPayload().getEpoch();\n+        final long payloadEpoch = payload.getEpoch();;\n         final long serverEpoch = getServerEpoch();\n \n-        final Rank prepareRank = new Rank(msg.getPayload().getRank(), msg.getClientID());\n         final Rank phase1Rank = getPhase1Rank(payloadEpoch);\n+        final Rank prepareRank = new Rank(payload.getRank(), getUUID(requestHeader.getClientId()));\n \n         if (payloadEpoch != serverEpoch) {\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.trace(\"handleMessageLayoutPrepare: Incoming message with wrong epoch, got {}, \"\n-                            + \"expected {}, message was: {}\",\n-                    msg.getPayload().getEpoch(), serverEpoch, msg);\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(serverEpoch));\n+            r.sendResponse(response, ctx);\n             return;\n         }\n \n-        Layout proposedLayout = getProposedLayout(payloadEpoch);\n+        final Layout proposedLayout = getProposedLayout(payloadEpoch);\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n \n-        // This is a prepare. If the rank is less than or equal to the phase 1 rank, reject.\n+        // If the PREPARE_LAYOUT_REQUEST rank is less than or equal to the highest phase 1 rank, reject.\n         if (phase1Rank != null && prepareRank.lessThanEqualTo(phase1Rank)) {\n-            log.debug(\"handleMessageLayoutPrepare: Rejected phase 1 prepare of rank={}, \"\n-                    + \"phase1Rank={}\", prepareRank, phase1Rank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PREPARE_REJECT.payloadMsg(new\n-                    LayoutPrepareResponse(phase1Rank.getRank(), proposedLayout)));\n+            log.debug(\"handlePrepareLayoutRequest[{}]: Rejected phase 1 prepare of rank={}, phase1Rank={}\",\n+                    requestHeader.getRequestId(), prepareRank, phase1Rank);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader, getPrepareLayoutResponseMsg(\n+                    false, phase1Rank.getRank(), proposedLayout));\n         } else {\n             // Return the layout with the highest rank proposed before.\n-            Rank highestProposedRank = proposedLayout == null ? new Rank(-1L, msg.getClientID())\n-                    : getPhase2Rank(payloadEpoch);\n+            Rank highestProposedRank = proposedLayout == null ?\n+                    new Rank(-1L, getUUID(requestHeader.getClientId())) : getPhase2Rank(payloadEpoch);\n+\n             setPhase1Rank(prepareRank, payloadEpoch);\n-            log.debug(\"handleMessageLayoutPrepare: New phase 1 rank={}\", prepareRank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PREPARE_ACK.payloadMsg(new\n-                    LayoutPrepareResponse(highestProposedRank.getRank(), proposedLayout)));\n+            log.debug(\"handlePrepareLayoutRequest[{}]: New phase 1 rank={}\", requestHeader.getRequestId(), prepareRank);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, true);\n+            response = getResponseMsg(responseHeader, getPrepareLayoutResponseMsg(\n+                    true, highestProposedRank.getRank(), proposedLayout));\n         }\n+\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * Accepts a proposal for which it had accepted in the prepare phase.\n      * A minor optimization is to reject any duplicate propose messages.\n      *\n-     * @param msg corfu message containing LAYOUT_PROPOSE\n+     * @param req corfu message containing PROPOSE_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_PROPOSE)\n-    public synchronized void handleMessageLayoutPropose(\n-            @NonNull CorfuPayloadMsg<LayoutProposeRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.PROPOSE_LAYOUT_REQUEST)\n+    public synchronized void handleProposeLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        final ProposeLayoutRequestMsg payload = req.getPayload().getProposeLayoutRequest();\n \n-        if (!isBootstrapped(msg, ctx, r)) {\n+        if (!isBootstrapped(req)) {\n+            r.sendNoBootstrapError(req.getHeader(), ctx);\n             return;\n         }\n \n-        final long payloadEpoch = msg.getPayload().getEpoch();\n+        final long payloadEpoch = payload.getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        final Rank proposeRank = new Rank(msg.getPayload().getRank(), msg.getClientID());\n         final Rank phase1Rank = getPhase1Rank(payloadEpoch);\n+        final Rank proposeRank = new Rank(payload.getRank(), getUUID(requestHeader.getClientId()));\n \n-        // Check if the propose is for the correct epoch\n         if (payloadEpoch != serverEpoch) {\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.trace(\"handleMessageLayoutPropose: Incoming message with wrong epoch, got {}, \"\n-                            + \"expected {}, message was: {}\", payloadEpoch, serverEpoch, msg);\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(serverEpoch));\n+            r.sendResponse(response, ctx);\n             return;\n         }\n-        // This is a propose. If no prepare, reject.\n+\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        // If there is not corresponding PREPARE_LAYOUT_REQUEST, reject.\n         if (phase1Rank == null) {\n-            log.debug(\"handleMessageLayoutPropose: Rejected phase 2 propose of rank={}, \"\n-                    + \"phase1Rank=none\", proposeRank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PROPOSE_REJECT.payloadMsg(new\n-                    LayoutProposeResponse(-1)));\n+            log.debug(\"handleProposeLayoutRequest[{}]: Rejected phase 2 propose of rank={}, phase1Rank=none\",\n+                    requestHeader.getRequestId(), proposeRank);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader, getProposeLayoutResponseMsg(false, -1L));\n+\n+            r.sendResponse(response, ctx);\n             return;\n         }\n-        // This is a propose. If the rank in the proposal is less than or equal to the highest yet\n-        // observed prepare rank, reject.\n+\n+        // If the rank in PROPOSE_LAYOUT_REQUEST is less than or equal to the highest observed\n+        // rank from PREPARE_LAYOUT_REQUEST, reject.\n         if (!proposeRank.equals(phase1Rank)) {\n-            log.debug(\"handleMessageLayoutPropose: Rejected phase 2 propose of rank={}, \"\n-                    + \"phase1Rank={}\", proposeRank, phase1Rank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PROPOSE_REJECT.payloadMsg(new\n-                    LayoutProposeResponse(phase1Rank.getRank())));\n+            log.debug(\"handleProposeLayoutRequest[{}]: Rejected phase 2 propose of rank={}, phase1Rank={}\",\n+                    requestHeader.getRequestId(), proposeRank, phase1Rank);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader, getProposeLayoutResponseMsg(false, phase1Rank.getRank()));\n+\n+            r.sendResponse(response, ctx);\n             return;\n         }\n \n         final Rank phase2Rank = getPhase2Rank(payloadEpoch);\n-        final Layout proposeLayout = msg.getPayload().getLayout();\n+        final Layout proposeLayout = getLayout(payload.getLayout());\n \n-        // Make sure that the layout epoch is the same as the LayoutProposeRequest epoch.\n+        // Make sure that the layout epoch is the same as the PROPOSE_LAYOUT_REQUEST epoch.", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1MDA1Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532950053", "bodyText": "getHeaderMsg(requestHeader, false, true) since successful?", "author": "zfrenette", "createdAt": "2020-11-30T22:39:49Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,275 +134,317 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if (!isBootstrapped(req)) {\n+            r.sendNoBootstrapError(req.getHeader(), ctx);\n             return;\n         }\n \n-        final long msgEpoch = msg.getPayload();\n+        final long payloadEpoch = req.getPayload().getLayoutRequest().getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        if (msgEpoch <= serverEpoch) {\n-            r.sendResponse(ctx, msg, new LayoutMsg(getCurrentLayout(), CorfuMsgType\n-                    .LAYOUT_RESPONSE));\n+        if (payloadEpoch <= serverEpoch) {\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getLayoutResponseMsg(getCurrentLayout()));\n+            r.sendResponse(response, ctx);\n         } else {\n-            // else the client is somehow ahead of the server.\n-            //TODO figure out a strategy to deal with this situation\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.warn(\"handleMessageLayoutRequest: Message Epoch {} ahead of Server epoch {}\",\n-                    msgEpoch, serverEpoch);\n+            log.warn(\"handleLayoutRequest[{}]: Payload epoch {} ahead of Server epoch {}\",\n+                    req.getHeader().getRequestId(), payloadEpoch, serverEpoch);\n+\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(serverEpoch));\n+            r.sendResponse(response, ctx);\n         }\n     }\n \n     /**\n      * Sets the new layout if the server has not been bootstrapped with one already.\n      *\n-     * @param msg corfu message containing LAYOUT_BOOTSTRAP\n+     * @param req corfu message containing BOOTSTRAP_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_BOOTSTRAP)\n-    public synchronized void handleMessageLayoutBootstrap(\n-            @NonNull CorfuPayloadMsg<LayoutBootstrapRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)\n+    public synchronized void handleBootstrapLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        if (getCurrentLayout() != null) {\n+            log.warn(\"handleBootstrapLayoutRequest[{}]: Got a request to bootstrap a server which is \"\n+                    + \"already bootstrapped, rejecting!\", requestHeader.getRequestId());\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, true);\n+            response = getResponseMsg(responseHeader, getBootstrappedErrorMsg());\n+            r.sendResponse(response, ctx);\n+            return;\n+        }\n \n-        if (getCurrentLayout() == null) {\n-            Layout layout = msg.getPayload().getLayout();\n-\n-            log.info(\"handleMessageLayoutBootstrap: Bootstrap with new layout={}, {}\",\n-                    layout, msg);\n-\n-            if (layout.getClusterId() == null) {\n-                log.warn(\"handleMessageLayoutBootstrap: The layout does {} not have a clusterId\",\n-                        layout);\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.NACK));\n-            }\n-            else{\n-                setCurrentLayout(layout);\n-                serverContext.setServerEpoch(layout.getEpoch(), r);\n-                //send a response that the bootstrap was successful.\n-                r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.ACK));\n-            }\n+        final Layout layout = getLayout(req.getPayload().getBootstrapLayoutRequest().getLayout());\n+\n+        if (layout.getClusterId() == null) {\n+            log.warn(\"handleBootstrapLayoutRequest[{}]: The layout={} does not have a clusterId\",\n+                    requestHeader.getRequestId(), layout);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader,\n+                    getBootstrapLayoutResponseMsg(false));\n         } else {\n-            // We are already bootstrapped, bootstrap again is not allowed.\n-            log.warn(\"handleMessageLayoutBootstrap: Got a request to bootstrap a server which is \"\n-                    + \"already bootstrapped, rejecting!\");\n-            r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.LAYOUT_ALREADY_BOOTSTRAP));\n+            log.info(\"handleBootstrapLayoutRequest[{}]: Bootstrap with new layout={}\", requestHeader.getRequestId(), layout);\n+            setCurrentLayout(layout);\n+            serverContext.setServerEpoch(layout.getEpoch(), r);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, true);\n+            response = getResponseMsg(responseHeader,\n+                    getBootstrapLayoutResponseMsg(true));\n         }\n+\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * Accepts a prepare message if the rank is higher than any accepted so far.\n      *\n-     * @param msg corfu message containing LAYOUT_PREPARE\n+     * @param req corfu message containing PREPARE_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    // TODO this can work under a separate lock for this step as it does not change the global\n-    // components\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_PREPARE)\n-    public synchronized void handleMessageLayoutPrepare(\n-            @NonNull CorfuPayloadMsg<LayoutPrepareRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n-\n-        // Check if the prepare is for the correct epoch\n-        if (!isBootstrapped(msg, ctx, r)) {\n+    // TODO this can work under a separate lock for this step as it does not change the global components\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.PREPARE_LAYOUT_REQUEST)\n+    public synchronized void handlePrepareLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        final PrepareLayoutRequestMsg payload = req.getPayload().getPrepareLayoutRequest();\n+\n+        if (!isBootstrapped(req)) {\n+            r.sendNoBootstrapError(req.getHeader(), ctx);\n             return;\n         }\n \n-        final long payloadEpoch = msg.getPayload().getEpoch();\n+        final long payloadEpoch = payload.getEpoch();;\n         final long serverEpoch = getServerEpoch();\n \n-        final Rank prepareRank = new Rank(msg.getPayload().getRank(), msg.getClientID());\n         final Rank phase1Rank = getPhase1Rank(payloadEpoch);\n+        final Rank prepareRank = new Rank(payload.getRank(), getUUID(requestHeader.getClientId()));\n \n         if (payloadEpoch != serverEpoch) {\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.trace(\"handleMessageLayoutPrepare: Incoming message with wrong epoch, got {}, \"\n-                            + \"expected {}, message was: {}\",\n-                    msg.getPayload().getEpoch(), serverEpoch, msg);\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(serverEpoch));\n+            r.sendResponse(response, ctx);\n             return;\n         }\n \n-        Layout proposedLayout = getProposedLayout(payloadEpoch);\n+        final Layout proposedLayout = getProposedLayout(payloadEpoch);\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n \n-        // This is a prepare. If the rank is less than or equal to the phase 1 rank, reject.\n+        // If the PREPARE_LAYOUT_REQUEST rank is less than or equal to the highest phase 1 rank, reject.\n         if (phase1Rank != null && prepareRank.lessThanEqualTo(phase1Rank)) {\n-            log.debug(\"handleMessageLayoutPrepare: Rejected phase 1 prepare of rank={}, \"\n-                    + \"phase1Rank={}\", prepareRank, phase1Rank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PREPARE_REJECT.payloadMsg(new\n-                    LayoutPrepareResponse(phase1Rank.getRank(), proposedLayout)));\n+            log.debug(\"handlePrepareLayoutRequest[{}]: Rejected phase 1 prepare of rank={}, phase1Rank={}\",\n+                    requestHeader.getRequestId(), prepareRank, phase1Rank);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader, getPrepareLayoutResponseMsg(\n+                    false, phase1Rank.getRank(), proposedLayout));\n         } else {\n             // Return the layout with the highest rank proposed before.\n-            Rank highestProposedRank = proposedLayout == null ? new Rank(-1L, msg.getClientID())\n-                    : getPhase2Rank(payloadEpoch);\n+            Rank highestProposedRank = proposedLayout == null ?\n+                    new Rank(-1L, getUUID(requestHeader.getClientId())) : getPhase2Rank(payloadEpoch);\n+\n             setPhase1Rank(prepareRank, payloadEpoch);\n-            log.debug(\"handleMessageLayoutPrepare: New phase 1 rank={}\", prepareRank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PREPARE_ACK.payloadMsg(new\n-                    LayoutPrepareResponse(highestProposedRank.getRank(), proposedLayout)));\n+            log.debug(\"handlePrepareLayoutRequest[{}]: New phase 1 rank={}\", requestHeader.getRequestId(), prepareRank);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, true);\n+            response = getResponseMsg(responseHeader, getPrepareLayoutResponseMsg(\n+                    true, highestProposedRank.getRank(), proposedLayout));\n         }\n+\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * Accepts a proposal for which it had accepted in the prepare phase.\n      * A minor optimization is to reject any duplicate propose messages.\n      *\n-     * @param msg corfu message containing LAYOUT_PROPOSE\n+     * @param req corfu message containing PROPOSE_LAYOUT_REQUEST\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_PROPOSE)\n-    public synchronized void handleMessageLayoutPropose(\n-            @NonNull CorfuPayloadMsg<LayoutProposeRequest> msg,\n-            ChannelHandlerContext ctx,\n-            @NonNull IServerRouter r) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.PROPOSE_LAYOUT_REQUEST)\n+    public synchronized void handleProposeLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HeaderMsg requestHeader = req.getHeader();\n+        final ProposeLayoutRequestMsg payload = req.getPayload().getProposeLayoutRequest();\n \n-        if (!isBootstrapped(msg, ctx, r)) {\n+        if (!isBootstrapped(req)) {\n+            r.sendNoBootstrapError(req.getHeader(), ctx);\n             return;\n         }\n \n-        final long payloadEpoch = msg.getPayload().getEpoch();\n+        final long payloadEpoch = payload.getEpoch();\n         final long serverEpoch = getServerEpoch();\n \n-        final Rank proposeRank = new Rank(msg.getPayload().getRank(), msg.getClientID());\n         final Rank phase1Rank = getPhase1Rank(payloadEpoch);\n+        final Rank proposeRank = new Rank(payload.getRank(), getUUID(requestHeader.getClientId()));\n \n-        // Check if the propose is for the correct epoch\n         if (payloadEpoch != serverEpoch) {\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch));\n-            log.trace(\"handleMessageLayoutPropose: Incoming message with wrong epoch, got {}, \"\n-                            + \"expected {}, message was: {}\", payloadEpoch, serverEpoch, msg);\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(serverEpoch));\n+            r.sendResponse(response, ctx);\n             return;\n         }\n-        // This is a propose. If no prepare, reject.\n+\n+        HeaderMsg responseHeader;\n+        ResponseMsg response;\n+\n+        // If there is not corresponding PREPARE_LAYOUT_REQUEST, reject.\n         if (phase1Rank == null) {\n-            log.debug(\"handleMessageLayoutPropose: Rejected phase 2 propose of rank={}, \"\n-                    + \"phase1Rank=none\", proposeRank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PROPOSE_REJECT.payloadMsg(new\n-                    LayoutProposeResponse(-1)));\n+            log.debug(\"handleProposeLayoutRequest[{}]: Rejected phase 2 propose of rank={}, phase1Rank=none\",\n+                    requestHeader.getRequestId(), proposeRank);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader, getProposeLayoutResponseMsg(false, -1L));\n+\n+            r.sendResponse(response, ctx);\n             return;\n         }\n-        // This is a propose. If the rank in the proposal is less than or equal to the highest yet\n-        // observed prepare rank, reject.\n+\n+        // If the rank in PROPOSE_LAYOUT_REQUEST is less than or equal to the highest observed\n+        // rank from PREPARE_LAYOUT_REQUEST, reject.\n         if (!proposeRank.equals(phase1Rank)) {\n-            log.debug(\"handleMessageLayoutPropose: Rejected phase 2 propose of rank={}, \"\n-                    + \"phase1Rank={}\", proposeRank, phase1Rank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PROPOSE_REJECT.payloadMsg(new\n-                    LayoutProposeResponse(phase1Rank.getRank())));\n+            log.debug(\"handleProposeLayoutRequest[{}]: Rejected phase 2 propose of rank={}, phase1Rank={}\",\n+                    requestHeader.getRequestId(), proposeRank, phase1Rank);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader, getProposeLayoutResponseMsg(false, phase1Rank.getRank()));\n+\n+            r.sendResponse(response, ctx);\n             return;\n         }\n \n         final Rank phase2Rank = getPhase2Rank(payloadEpoch);\n-        final Layout proposeLayout = msg.getPayload().getLayout();\n+        final Layout proposeLayout = getLayout(payload.getLayout());\n \n-        // Make sure that the layout epoch is the same as the LayoutProposeRequest epoch.\n+        // Make sure that the layout epoch is the same as the PROPOSE_LAYOUT_REQUEST epoch.\n         if (proposeLayout.getEpoch() != payloadEpoch) {\n-            log.debug(\"Phase II error: layout {} and payload {} epoch should be the same\",\n-                    proposeLayout.getEpoch(), payloadEpoch);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PROPOSE_REJECT.payloadMsg(new\n-                    LayoutProposeResponse(phase1Rank.getRank())));\n+            log.debug(\"handleProposeLayoutRequest[{}]: layout {} and payload {} epoch should be the same\",\n+                    requestHeader.getRequestId(), proposeLayout.getEpoch(), payloadEpoch);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader, getProposeLayoutResponseMsg(false, phase1Rank.getRank()));\n+\n+            r.sendResponse(response, ctx);\n             return;\n         }\n \n-        // In addition, if the rank in the propose message is equal to the current phase 2 rank\n-        // (already accepted message), reject.\n-        // This can happen in case of duplicate messages.\n+        // In addition, if the rank in PROPOSE_LAYOUT_REQUEST is equal to the current phase 2 rank,\n+        // reject. This can happen in case of duplicate messages.\n         if (proposeRank.equals(phase2Rank)) {\n-            log.debug(\"handleMessageLayoutPropose: Rejected phase 2 propose of rank={}, \"\n-                    + \"phase2Rank={}\", proposeRank, phase2Rank);\n-            r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PROPOSE_REJECT.payloadMsg(new\n-                    LayoutProposeResponse(phase2Rank.getRank())));\n+            log.debug(\"handleProposeLayoutRequest[{}]: Rejected phase 2 propose of rank={}, phase2Rank={}\",\n+                    requestHeader.getRequestId(), proposeRank, phase2Rank);\n+\n+            responseHeader = getHeaderMsg(requestHeader, false, false);\n+            response = getResponseMsg(responseHeader, getProposeLayoutResponseMsg(false, phase2Rank.getRank()));\n+\n+            r.sendResponse(response, ctx);\n             return;\n         }\n \n-        log.debug(\"handleMessageLayoutPropose: New phase 2 rank={}, layout={}\",\n-                proposeRank, proposeLayout);\n+        log.debug(\"handleProposeLayoutRequest[{}]: New phase 2 rank={}, layout={}\",\n+                requestHeader.getRequestId(), proposeRank, proposeLayout);\n+\n         setPhase2Data(new Phase2Data(proposeRank, proposeLayout), payloadEpoch);\n-        r.sendResponse(ctx, msg, new CorfuMsg(CorfuMsgType.ACK));\n-    }\n+        responseHeader = getHeaderMsg(requestHeader, false, false);", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1MzQwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532953403", "bodyText": "Can we also verify that the setCurrentLayout method was called on the mockServerContext?", "author": "zfrenette", "createdAt": "2020-11-30T22:47:12Z", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuLayoutServerTest.java", "diffHunk": "@@ -0,0 +1,710 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.datastore.DataStore;\n+import org.corfudb.infrastructure.datastore.KvDataStore.KvRecord;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+public class CorfuLayoutServerTest {\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // LayoutServer instance used for testing\n+    private LayoutServer layoutServer;\n+\n+    // Objects that need to be mocked\n+    private ServerContext mockServerContext;\n+    private IServerRouter mockServerRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    private DataStore mockDataStore;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     * @param requestHeader   the header from the request message\n+     * @param responseHeader  the header from the response message\n+     * @return                true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        mockServerContext = mock(ServerContext.class);\n+        mockServerRouter = mock(IServerRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        mockDataStore = mock(DataStore.class);\n+\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+\n+        // Initialize mocked DataStore for LayoutServer\n+        when(mockServerContext.getDataStore()).thenReturn(mockDataStore);\n+\n+        layoutServer = new LayoutServer(mockServerContext);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testBootstrapLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertTrue(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1Mzc4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532953783", "bodyText": "Consider also verifying that setCurrentLayout was not called in this case?", "author": "zfrenette", "createdAt": "2020-11-30T22:48:10Z", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuLayoutServerTest.java", "diffHunk": "@@ -0,0 +1,710 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.datastore.DataStore;\n+import org.corfudb.infrastructure.datastore.KvDataStore.KvRecord;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+public class CorfuLayoutServerTest {\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // LayoutServer instance used for testing\n+    private LayoutServer layoutServer;\n+\n+    // Objects that need to be mocked\n+    private ServerContext mockServerContext;\n+    private IServerRouter mockServerRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    private DataStore mockDataStore;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     * @param requestHeader   the header from the request message\n+     * @param responseHeader  the header from the response message\n+     * @return                true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        mockServerContext = mock(ServerContext.class);\n+        mockServerRouter = mock(IServerRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        mockDataStore = mock(DataStore.class);\n+\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+\n+        // Initialize mocked DataStore for LayoutServer\n+        when(mockServerContext.getDataStore()).thenReturn(mockDataStore);\n+\n+        layoutServer = new LayoutServer(mockServerContext);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testBootstrapLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertTrue(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST\n+     * with a legacy layout having a null clusterId\u3002\n+     */\n+    @Test\n+    public void testBootstrapLayoutWithNullClusterId() throws IOException {\n+        Layout l = getDefaultLayout();\n+        l.setClusterId(null);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertFalse(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1NDIyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532954220", "bodyText": "Same here.", "author": "zfrenette", "createdAt": "2020-11-30T22:49:11Z", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuLayoutServerTest.java", "diffHunk": "@@ -0,0 +1,710 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.datastore.DataStore;\n+import org.corfudb.infrastructure.datastore.KvDataStore.KvRecord;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+public class CorfuLayoutServerTest {\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // LayoutServer instance used for testing\n+    private LayoutServer layoutServer;\n+\n+    // Objects that need to be mocked\n+    private ServerContext mockServerContext;\n+    private IServerRouter mockServerRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    private DataStore mockDataStore;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     * @param requestHeader   the header from the request message\n+     * @param responseHeader  the header from the response message\n+     * @return                true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        mockServerContext = mock(ServerContext.class);\n+        mockServerRouter = mock(IServerRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        mockDataStore = mock(DataStore.class);\n+\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+\n+        // Initialize mocked DataStore for LayoutServer\n+        when(mockServerContext.getDataStore()).thenReturn(mockDataStore);\n+\n+        layoutServer = new LayoutServer(mockServerContext);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testBootstrapLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertTrue(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST\n+     * with a legacy layout having a null clusterId\u3002\n+     */\n+    @Test\n+    public void testBootstrapLayoutWithNullClusterId() throws IOException {\n+        Layout l = getDefaultLayout();\n+        l.setClusterId(null);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertFalse(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly sends a BootstrappedErrorMsg.\n+     */\n+    @Test\n+    public void testBootstrappedLayout() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a BootstrappedErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasBootstrappedError());\n+    }", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1NTI1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532955258", "bodyText": "Can you also verify the correct epoch argument is what you expect?", "author": "zfrenette", "createdAt": "2020-11-30T22:51:27Z", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuLayoutServerTest.java", "diffHunk": "@@ -0,0 +1,710 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.datastore.DataStore;\n+import org.corfudb.infrastructure.datastore.KvDataStore.KvRecord;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+public class CorfuLayoutServerTest {\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // LayoutServer instance used for testing\n+    private LayoutServer layoutServer;\n+\n+    // Objects that need to be mocked\n+    private ServerContext mockServerContext;\n+    private IServerRouter mockServerRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    private DataStore mockDataStore;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     * @param requestHeader   the header from the request message\n+     * @param responseHeader  the header from the response message\n+     * @return                true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        mockServerContext = mock(ServerContext.class);\n+        mockServerRouter = mock(IServerRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        mockDataStore = mock(DataStore.class);\n+\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+\n+        // Initialize mocked DataStore for LayoutServer\n+        when(mockServerContext.getDataStore()).thenReturn(mockDataStore);\n+\n+        layoutServer = new LayoutServer(mockServerContext);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testBootstrapLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertTrue(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST\n+     * with a legacy layout having a null clusterId\u3002\n+     */\n+    @Test\n+    public void testBootstrapLayoutWithNullClusterId() throws IOException {\n+        Layout l = getDefaultLayout();\n+        l.setClusterId(null);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertFalse(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly sends a BootstrappedErrorMsg.\n+     */\n+    @Test\n+    public void testBootstrappedLayout() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a BootstrappedErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasBootstrappedError());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testGetLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getLayoutRequestMsg(payloadEpoch)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasLayoutResponse());\n+\n+        Layout retLayout = CorfuProtocolCommon.getLayout(response.getPayload().getLayoutResponse().getLayout());\n+        assertLayoutMatch(retLayout);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a LAYOUT_REQUEST with wrong epoch.\n+     */\n+    @Test\n+    public void testGetLayoutWrongEpoch() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long wrongEpoch = 5L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getLayoutRequestMsg(wrongEpoch)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a WrongEpochErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasWrongEpochError());", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1NjA5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532956096", "bodyText": "Can we also add a test that the request is ignored and that an error is sent if the server isn't bootstrapped yet? Consider doing so for the other RPCs too, where applicable.", "author": "zfrenette", "createdAt": "2020-11-30T22:53:22Z", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuLayoutServerTest.java", "diffHunk": "@@ -0,0 +1,710 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.datastore.DataStore;\n+import org.corfudb.infrastructure.datastore.KvDataStore.KvRecord;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+public class CorfuLayoutServerTest {\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // LayoutServer instance used for testing\n+    private LayoutServer layoutServer;\n+\n+    // Objects that need to be mocked\n+    private ServerContext mockServerContext;\n+    private IServerRouter mockServerRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    private DataStore mockDataStore;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     * @param requestHeader   the header from the request message\n+     * @param responseHeader  the header from the response message\n+     * @return                true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        mockServerContext = mock(ServerContext.class);\n+        mockServerRouter = mock(IServerRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        mockDataStore = mock(DataStore.class);\n+\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+\n+        // Initialize mocked DataStore for LayoutServer\n+        when(mockServerContext.getDataStore()).thenReturn(mockDataStore);\n+\n+        layoutServer = new LayoutServer(mockServerContext);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testBootstrapLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertTrue(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST\n+     * with a legacy layout having a null clusterId\u3002\n+     */\n+    @Test\n+    public void testBootstrapLayoutWithNullClusterId() throws IOException {\n+        Layout l = getDefaultLayout();\n+        l.setClusterId(null);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertFalse(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly sends a BootstrappedErrorMsg.\n+     */\n+    @Test\n+    public void testBootstrappedLayout() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a BootstrappedErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasBootstrappedError());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testGetLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getLayoutRequestMsg(payloadEpoch)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasLayoutResponse());\n+\n+        Layout retLayout = CorfuProtocolCommon.getLayout(response.getPayload().getLayoutResponse().getLayout());\n+        assertLayoutMatch(retLayout);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a LAYOUT_REQUEST with wrong epoch.\n+     */\n+    @Test\n+    public void testGetLayoutWrongEpoch() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long wrongEpoch = 5L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getLayoutRequestMsg(wrongEpoch)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a WrongEpochErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasWrongEpochError());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a PREPARE_LAYOUT_REQUEST.\n+     */", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3ODEyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533878121", "bodyText": "Added, thanks!", "author": "xcchang", "createdAt": "2020-12-02T03:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1NjA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1OTYwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532959603", "bodyText": "Can you also verify that the correct epoch is what you expect?", "author": "zfrenette", "createdAt": "2020-11-30T23:01:33Z", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuLayoutServerTest.java", "diffHunk": "@@ -0,0 +1,710 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.datastore.DataStore;\n+import org.corfudb.infrastructure.datastore.KvDataStore.KvRecord;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+public class CorfuLayoutServerTest {\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // LayoutServer instance used for testing\n+    private LayoutServer layoutServer;\n+\n+    // Objects that need to be mocked\n+    private ServerContext mockServerContext;\n+    private IServerRouter mockServerRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    private DataStore mockDataStore;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     * @param requestHeader   the header from the request message\n+     * @param responseHeader  the header from the response message\n+     * @return                true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        mockServerContext = mock(ServerContext.class);\n+        mockServerRouter = mock(IServerRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        mockDataStore = mock(DataStore.class);\n+\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+\n+        // Initialize mocked DataStore for LayoutServer\n+        when(mockServerContext.getDataStore()).thenReturn(mockDataStore);\n+\n+        layoutServer = new LayoutServer(mockServerContext);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testBootstrapLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertTrue(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST\n+     * with a legacy layout having a null clusterId\u3002\n+     */\n+    @Test\n+    public void testBootstrapLayoutWithNullClusterId() throws IOException {\n+        Layout l = getDefaultLayout();\n+        l.setClusterId(null);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertFalse(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly sends a BootstrappedErrorMsg.\n+     */\n+    @Test\n+    public void testBootstrappedLayout() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a BootstrappedErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasBootstrappedError());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testGetLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getLayoutRequestMsg(payloadEpoch)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasLayoutResponse());\n+\n+        Layout retLayout = CorfuProtocolCommon.getLayout(response.getPayload().getLayoutResponse().getLayout());\n+        assertLayoutMatch(retLayout);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a LAYOUT_REQUEST with wrong epoch.\n+     */\n+    @Test\n+    public void testGetLayoutWrongEpoch() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long wrongEpoch = 5L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getLayoutRequestMsg(wrongEpoch)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a WrongEpochErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasWrongEpochError());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a PREPARE_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPrepareAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        // when there were no proposed rank before\n+        long defaultRank = -1L;\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getPrepareLayoutRequestMsg(payloadEpoch, phase1Rank)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        ArgumentCaptor<KvRecord<Rank>> recordCaptor = ArgumentCaptor.forClass(KvRecord.class);\n+        ArgumentCaptor<Rank> rankCaptor = ArgumentCaptor.forClass(Rank.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore).put(recordCaptor.capture(), rankCaptor.capture());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        KvRecord<Rank> record = recordCaptor.getValue();\n+        Rank rank = rankCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasPrepareLayoutResponse());\n+        // Verify the LayoutServer performs setPhase1Rank through the paxosDataStore with expected values\n+        assertEquals(rank.getRank().longValue(), phase1Rank);\n+        assertEquals(record.getFullKeyName(), \"PHASE_1_\" + payloadEpoch + \"RANK\");\n+        // There should not be proposed layout before and the highest rank was set to -1\n+        assertNull(CorfuProtocolCommon.getLayout(response.getPayload().getPrepareLayoutResponse().getLayout()));\n+        assertEquals(response.getPayload().getPrepareLayoutResponse().getRank(), defaultRank);\n+        assertTrue(response.getPayload().getPrepareLayoutResponse().getPrepared());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PREPARE_LAYOUT_REQUEST when\n+     * the PREPARE_LAYOUT_REQUEST rank is less than or equal to the highest phase 1 rank, reject.\n+     */\n+    @Test\n+    public void testPrepareWrongPrepareRank() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        long highestPhase1Rank = 10L;\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getPrepareLayoutRequestMsg(payloadEpoch, phase1Rank)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(highestPhase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasPrepareLayoutResponse());\n+        // There should not be proposed layout before and the highest rank was set to -1\n+        assertNull(CorfuProtocolCommon.getLayout(response.getPayload().getPrepareLayoutResponse().getLayout()));\n+        // PREPARE_LAYOUT_REQUEST should be rejected and the highest phase 1 rank should be returned.\n+        assertFalse(response.getPayload().getPrepareLayoutResponse().getPrepared());\n+        assertEquals(response.getPayload().getPrepareLayoutResponse().getRank(), highestPhase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly acknowledges a PROPOSE_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testProposeAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        ArgumentCaptor<KvRecord<Phase2Data>> recordCaptor = ArgumentCaptor.forClass(KvRecord.class);\n+        ArgumentCaptor<Phase2Data> phase2DataCaptor = ArgumentCaptor.forClass(Phase2Data.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore).put(recordCaptor.capture(), phase2DataCaptor.capture());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        KvRecord<Phase2Data> record = recordCaptor.getValue();\n+        Phase2Data phase2Data = phase2DataCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // Verify the LayoutServer performs setPhase2Rank through the paxosDataStore with expected values\n+        assertEquals(phase2Data.getRank().getRank().longValue(), phase1Rank);\n+        assertEquals(record.getFullKeyName(), \"PHASE_2_\" + payloadEpoch + \"DATA\");\n+        // The PROPOSE_LAYOUT_REQUEST should succeed and proposed rank should equal to the rank in proposeRequest\n+        assertTrue(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+        assertEquals(proposeResponse.getPayload().getProposeLayoutResponse().getRank(), phase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * there is not corresponding PREPARE_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testProposeRejectNoPrepare() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        // when there were no proposed rank before\n+        long defaultRank = -1L;\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasProposeLayoutResponse());\n+        // Propose request should be rejected because there were no phase 1 rank\n+        assertFalse(response.getPayload().getProposeLayoutResponse().getProposed());\n+        assertEquals(response.getPayload().getProposeLayoutResponse().getRank(), defaultRank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * the Layout epoch is not equal to payload epoch.\n+     */\n+    @Test\n+    public void testProposeWrongEpoch() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        long wrongEpoch = 5L;\n+        l.setEpoch(wrongEpoch);\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // The PROPOSE_LAYOUT_REQUEST should be rejected because the Layout epoch is not equal to payload epoch\n+        assertFalse(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+        // The LayoutServer should send back the expected phase1rank\n+        assertEquals(proposeResponse.getPayload().getProposeLayoutResponse().getRank(), phase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * the rank in PROPOSE_LAYOUT_REQUEST is less than or equal to the phase1rank\n+     */\n+    @Test\n+    public void testProposeWrongProposeRank() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        long wrongProposeRank = 10L;\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, wrongProposeRank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // The PROPOSE_LAYOUT_REQUEST should be rejected due to wrong propose rank\n+        assertFalse(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+        // The LayoutServer should send back the expected phase1rank\n+        assertEquals(proposeResponse.getPayload().getProposeLayoutResponse().getRank(), phase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * the rank in PROPOSE_LAYOUT_REQUEST is equal to the current phase 2 rank.\n+     */\n+    @Test\n+    public void testProposeDuplicateMessage() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        when(mockDataStore.get(argThat(new Phase2Matcher(payloadEpoch))))\n+                .thenReturn(new Phase2Data(new Rank(phase1Rank, DEFAULT_UUID), l));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // The PROPOSE_LAYOUT_REQUEST should be rejected because the rank\n+        // in PROPOSE_LAYOUT_REQUEST is equal to the current phase 2 rank.\n+        assertFalse(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly acknowledges a COMMIT_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testCommitAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getCommitLayoutRequestMsg(false, payloadEpoch, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        ArgumentCaptor<Layout> layoutCaptor = ArgumentCaptor.forClass(Layout.class);\n+        ArgumentCaptor<Long> serverEpochCaptor = ArgumentCaptor.forClass(Long.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerContext).setCurrentLayout(layoutCaptor.capture());\n+        verify(mockServerContext).setServerEpoch(serverEpochCaptor.capture(), any(IServerRouter.class));\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        Layout currentLayout = layoutCaptor.getValue();\n+        long serverEpoch = serverEpochCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasCommitLayoutResponse());\n+        assertTrue(response.getPayload().getCommitLayoutResponse().getCommitted());\n+        // Verify the serverContext performs setCurrentLayout and setServerEpoch with expected values\n+        assertLayoutMatch(currentLayout);\n+        assertEquals(serverEpoch, payloadEpoch);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a COMMIT_LAYOUT_REQUEST when\n+     * the payloadEpoch is not equal to serverEpoch..\n+     */\n+    @Test\n+    public void testCommitWrongEpoch() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long serverEpoch = 5L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getCommitLayoutRequestMsg(false, payloadEpoch, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockServerContext.getServerEpoch()).thenReturn(serverEpoch);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerContext, never()).setCurrentLayout(any());\n+        verify(mockServerContext, never()).setServerEpoch(anyLong(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a WrongEpochErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasWrongEpochError());", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk2MTMwOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532961308", "bodyText": "Are these argument captors necessary? I think calling verify with the expected object should suffice here. In most cases, if you know the result ahead of time, you don't need an argument captor.", "author": "zfrenette", "createdAt": "2020-11-30T23:05:54Z", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuLayoutServerTest.java", "diffHunk": "@@ -0,0 +1,710 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.datastore.DataStore;\n+import org.corfudb.infrastructure.datastore.KvDataStore.KvRecord;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+public class CorfuLayoutServerTest {\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // LayoutServer instance used for testing\n+    private LayoutServer layoutServer;\n+\n+    // Objects that need to be mocked\n+    private ServerContext mockServerContext;\n+    private IServerRouter mockServerRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    private DataStore mockDataStore;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     * @param requestHeader   the header from the request message\n+     * @param responseHeader  the header from the response message\n+     * @return                true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        mockServerContext = mock(ServerContext.class);\n+        mockServerRouter = mock(IServerRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        mockDataStore = mock(DataStore.class);\n+\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+\n+        // Initialize mocked DataStore for LayoutServer\n+        when(mockServerContext.getDataStore()).thenReturn(mockDataStore);\n+\n+        layoutServer = new LayoutServer(mockServerContext);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testBootstrapLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertTrue(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST\n+     * with a legacy layout having a null clusterId\u3002\n+     */\n+    @Test\n+    public void testBootstrapLayoutWithNullClusterId() throws IOException {\n+        Layout l = getDefaultLayout();\n+        l.setClusterId(null);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertFalse(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly sends a BootstrappedErrorMsg.\n+     */\n+    @Test\n+    public void testBootstrappedLayout() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a BootstrappedErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasBootstrappedError());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testGetLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getLayoutRequestMsg(payloadEpoch)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasLayoutResponse());\n+\n+        Layout retLayout = CorfuProtocolCommon.getLayout(response.getPayload().getLayoutResponse().getLayout());\n+        assertLayoutMatch(retLayout);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a LAYOUT_REQUEST with wrong epoch.\n+     */\n+    @Test\n+    public void testGetLayoutWrongEpoch() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long wrongEpoch = 5L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getLayoutRequestMsg(wrongEpoch)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a WrongEpochErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasWrongEpochError());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a PREPARE_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPrepareAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        // when there were no proposed rank before\n+        long defaultRank = -1L;\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getPrepareLayoutRequestMsg(payloadEpoch, phase1Rank)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        ArgumentCaptor<KvRecord<Rank>> recordCaptor = ArgumentCaptor.forClass(KvRecord.class);\n+        ArgumentCaptor<Rank> rankCaptor = ArgumentCaptor.forClass(Rank.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore).put(recordCaptor.capture(), rankCaptor.capture());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        KvRecord<Rank> record = recordCaptor.getValue();\n+        Rank rank = rankCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasPrepareLayoutResponse());\n+        // Verify the LayoutServer performs setPhase1Rank through the paxosDataStore with expected values\n+        assertEquals(rank.getRank().longValue(), phase1Rank);\n+        assertEquals(record.getFullKeyName(), \"PHASE_1_\" + payloadEpoch + \"RANK\");\n+        // There should not be proposed layout before and the highest rank was set to -1\n+        assertNull(CorfuProtocolCommon.getLayout(response.getPayload().getPrepareLayoutResponse().getLayout()));\n+        assertEquals(response.getPayload().getPrepareLayoutResponse().getRank(), defaultRank);\n+        assertTrue(response.getPayload().getPrepareLayoutResponse().getPrepared());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PREPARE_LAYOUT_REQUEST when\n+     * the PREPARE_LAYOUT_REQUEST rank is less than or equal to the highest phase 1 rank, reject.\n+     */\n+    @Test\n+    public void testPrepareWrongPrepareRank() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        long highestPhase1Rank = 10L;\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getPrepareLayoutRequestMsg(payloadEpoch, phase1Rank)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(highestPhase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasPrepareLayoutResponse());\n+        // There should not be proposed layout before and the highest rank was set to -1\n+        assertNull(CorfuProtocolCommon.getLayout(response.getPayload().getPrepareLayoutResponse().getLayout()));\n+        // PREPARE_LAYOUT_REQUEST should be rejected and the highest phase 1 rank should be returned.\n+        assertFalse(response.getPayload().getPrepareLayoutResponse().getPrepared());\n+        assertEquals(response.getPayload().getPrepareLayoutResponse().getRank(), highestPhase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly acknowledges a PROPOSE_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testProposeAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        ArgumentCaptor<KvRecord<Phase2Data>> recordCaptor = ArgumentCaptor.forClass(KvRecord.class);\n+        ArgumentCaptor<Phase2Data> phase2DataCaptor = ArgumentCaptor.forClass(Phase2Data.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore).put(recordCaptor.capture(), phase2DataCaptor.capture());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        KvRecord<Phase2Data> record = recordCaptor.getValue();\n+        Phase2Data phase2Data = phase2DataCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // Verify the LayoutServer performs setPhase2Rank through the paxosDataStore with expected values\n+        assertEquals(phase2Data.getRank().getRank().longValue(), phase1Rank);\n+        assertEquals(record.getFullKeyName(), \"PHASE_2_\" + payloadEpoch + \"DATA\");\n+        // The PROPOSE_LAYOUT_REQUEST should succeed and proposed rank should equal to the rank in proposeRequest\n+        assertTrue(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+        assertEquals(proposeResponse.getPayload().getProposeLayoutResponse().getRank(), phase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * there is not corresponding PREPARE_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testProposeRejectNoPrepare() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        // when there were no proposed rank before\n+        long defaultRank = -1L;\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasProposeLayoutResponse());\n+        // Propose request should be rejected because there were no phase 1 rank\n+        assertFalse(response.getPayload().getProposeLayoutResponse().getProposed());\n+        assertEquals(response.getPayload().getProposeLayoutResponse().getRank(), defaultRank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * the Layout epoch is not equal to payload epoch.\n+     */\n+    @Test\n+    public void testProposeWrongEpoch() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        long wrongEpoch = 5L;\n+        l.setEpoch(wrongEpoch);\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // The PROPOSE_LAYOUT_REQUEST should be rejected because the Layout epoch is not equal to payload epoch\n+        assertFalse(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+        // The LayoutServer should send back the expected phase1rank\n+        assertEquals(proposeResponse.getPayload().getProposeLayoutResponse().getRank(), phase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * the rank in PROPOSE_LAYOUT_REQUEST is less than or equal to the phase1rank\n+     */\n+    @Test\n+    public void testProposeWrongProposeRank() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        long wrongProposeRank = 10L;\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, wrongProposeRank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // The PROPOSE_LAYOUT_REQUEST should be rejected due to wrong propose rank\n+        assertFalse(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+        // The LayoutServer should send back the expected phase1rank\n+        assertEquals(proposeResponse.getPayload().getProposeLayoutResponse().getRank(), phase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * the rank in PROPOSE_LAYOUT_REQUEST is equal to the current phase 2 rank.\n+     */\n+    @Test\n+    public void testProposeDuplicateMessage() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        when(mockDataStore.get(argThat(new Phase2Matcher(payloadEpoch))))\n+                .thenReturn(new Phase2Data(new Rank(phase1Rank, DEFAULT_UUID), l));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // The PROPOSE_LAYOUT_REQUEST should be rejected because the rank\n+        // in PROPOSE_LAYOUT_REQUEST is equal to the current phase 2 rank.\n+        assertFalse(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly acknowledges a COMMIT_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testCommitAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getCommitLayoutRequestMsg(false, payloadEpoch, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        ArgumentCaptor<Layout> layoutCaptor = ArgumentCaptor.forClass(Layout.class);\n+        ArgumentCaptor<Long> serverEpochCaptor = ArgumentCaptor.forClass(Long.class);", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk2MTUwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r532961501", "bodyText": "Same here.", "author": "zfrenette", "createdAt": "2020-11-30T23:06:25Z", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuLayoutServerTest.java", "diffHunk": "@@ -0,0 +1,710 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.datastore.DataStore;\n+import org.corfudb.infrastructure.datastore.KvDataStore.KvRecord;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+public class CorfuLayoutServerTest {\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // LayoutServer instance used for testing\n+    private LayoutServer layoutServer;\n+\n+    // Objects that need to be mocked\n+    private ServerContext mockServerContext;\n+    private IServerRouter mockServerRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    private DataStore mockDataStore;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     * @param requestHeader   the header from the request message\n+     * @param responseHeader  the header from the response message\n+     * @return                true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        mockServerContext = mock(ServerContext.class);\n+        mockServerRouter = mock(IServerRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        mockDataStore = mock(DataStore.class);\n+\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+\n+        // Initialize mocked DataStore for LayoutServer\n+        when(mockServerContext.getDataStore()).thenReturn(mockDataStore);\n+\n+        layoutServer = new LayoutServer(mockServerContext);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testBootstrapLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertTrue(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a BOOTSTRAP_LAYOUT_REQUEST\n+     * with a legacy layout having a null clusterId\u3002\n+     */\n+    @Test\n+    public void testBootstrapLayoutWithNullClusterId() throws IOException {\n+        Layout l = getDefaultLayout();\n+        l.setClusterId(null);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasBootstrapLayoutResponse());\n+        assertFalse(response.getPayload().getBootstrapLayoutResponse().getBootstrapped());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly sends a BootstrappedErrorMsg.\n+     */\n+    @Test\n+    public void testBootstrappedLayout() throws IOException {\n+        Layout l = getDefaultLayout();\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getBootstrapLayoutRequestMsg(l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a BootstrappedErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasBootstrappedError());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testGetLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getLayoutRequestMsg(payloadEpoch)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasLayoutResponse());\n+\n+        Layout retLayout = CorfuProtocolCommon.getLayout(response.getPayload().getLayoutResponse().getLayout());\n+        assertLayoutMatch(retLayout);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a LAYOUT_REQUEST with wrong epoch.\n+     */\n+    @Test\n+    public void testGetLayoutWrongEpoch() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long wrongEpoch = 5L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                getLayoutRequestMsg(wrongEpoch)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a WrongEpochErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasWrongEpochError());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly handles a PREPARE_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPrepareAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        // when there were no proposed rank before\n+        long defaultRank = -1L;\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getPrepareLayoutRequestMsg(payloadEpoch, phase1Rank)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        ArgumentCaptor<KvRecord<Rank>> recordCaptor = ArgumentCaptor.forClass(KvRecord.class);\n+        ArgumentCaptor<Rank> rankCaptor = ArgumentCaptor.forClass(Rank.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore).put(recordCaptor.capture(), rankCaptor.capture());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        KvRecord<Rank> record = recordCaptor.getValue();\n+        Rank rank = rankCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasPrepareLayoutResponse());\n+        // Verify the LayoutServer performs setPhase1Rank through the paxosDataStore with expected values\n+        assertEquals(rank.getRank().longValue(), phase1Rank);\n+        assertEquals(record.getFullKeyName(), \"PHASE_1_\" + payloadEpoch + \"RANK\");\n+        // There should not be proposed layout before and the highest rank was set to -1\n+        assertNull(CorfuProtocolCommon.getLayout(response.getPayload().getPrepareLayoutResponse().getLayout()));\n+        assertEquals(response.getPayload().getPrepareLayoutResponse().getRank(), defaultRank);\n+        assertTrue(response.getPayload().getPrepareLayoutResponse().getPrepared());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PREPARE_LAYOUT_REQUEST when\n+     * the PREPARE_LAYOUT_REQUEST rank is less than or equal to the highest phase 1 rank, reject.\n+     */\n+    @Test\n+    public void testPrepareWrongPrepareRank() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        long highestPhase1Rank = 10L;\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getPrepareLayoutRequestMsg(payloadEpoch, phase1Rank)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(highestPhase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasPrepareLayoutResponse());\n+        // There should not be proposed layout before and the highest rank was set to -1\n+        assertNull(CorfuProtocolCommon.getLayout(response.getPayload().getPrepareLayoutResponse().getLayout()));\n+        // PREPARE_LAYOUT_REQUEST should be rejected and the highest phase 1 rank should be returned.\n+        assertFalse(response.getPayload().getPrepareLayoutResponse().getPrepared());\n+        assertEquals(response.getPayload().getPrepareLayoutResponse().getRank(), highestPhase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly acknowledges a PROPOSE_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testProposeAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        ArgumentCaptor<KvRecord<Phase2Data>> recordCaptor = ArgumentCaptor.forClass(KvRecord.class);\n+        ArgumentCaptor<Phase2Data> phase2DataCaptor = ArgumentCaptor.forClass(Phase2Data.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore).put(recordCaptor.capture(), phase2DataCaptor.capture());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        KvRecord<Phase2Data> record = recordCaptor.getValue();\n+        Phase2Data phase2Data = phase2DataCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // Verify the LayoutServer performs setPhase2Rank through the paxosDataStore with expected values\n+        assertEquals(phase2Data.getRank().getRank().longValue(), phase1Rank);\n+        assertEquals(record.getFullKeyName(), \"PHASE_2_\" + payloadEpoch + \"DATA\");\n+        // The PROPOSE_LAYOUT_REQUEST should succeed and proposed rank should equal to the rank in proposeRequest\n+        assertTrue(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+        assertEquals(proposeResponse.getPayload().getProposeLayoutResponse().getRank(), phase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * there is not corresponding PREPARE_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testProposeRejectNoPrepare() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        // when there were no proposed rank before\n+        long defaultRank = -1L;\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasProposeLayoutResponse());\n+        // Propose request should be rejected because there were no phase 1 rank\n+        assertFalse(response.getPayload().getProposeLayoutResponse().getProposed());\n+        assertEquals(response.getPayload().getProposeLayoutResponse().getRank(), defaultRank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * the Layout epoch is not equal to payload epoch.\n+     */\n+    @Test\n+    public void testProposeWrongEpoch() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        long wrongEpoch = 5L;\n+        l.setEpoch(wrongEpoch);\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // The PROPOSE_LAYOUT_REQUEST should be rejected because the Layout epoch is not equal to payload epoch\n+        assertFalse(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+        // The LayoutServer should send back the expected phase1rank\n+        assertEquals(proposeResponse.getPayload().getProposeLayoutResponse().getRank(), phase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * the rank in PROPOSE_LAYOUT_REQUEST is less than or equal to the phase1rank\n+     */\n+    @Test\n+    public void testProposeWrongProposeRank() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+        long wrongProposeRank = 10L;\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, wrongProposeRank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // The PROPOSE_LAYOUT_REQUEST should be rejected due to wrong propose rank\n+        assertFalse(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+        // The LayoutServer should send back the expected phase1rank\n+        assertEquals(proposeResponse.getPayload().getProposeLayoutResponse().getRank(), phase1Rank);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a PROPOSE_LAYOUT_REQUEST when\n+     * the rank in PROPOSE_LAYOUT_REQUEST is equal to the current phase 2 rank.\n+     */\n+    @Test\n+    public void testProposeDuplicateMessage() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long phase1Rank = 5L;\n+\n+        RequestMsg proposeRequest = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getProposeLayoutRequestMsg(payloadEpoch, phase1Rank, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockDataStore.get(argThat(new Phase1Matcher(payloadEpoch))))\n+                .thenReturn(new Rank(phase1Rank, DEFAULT_UUID));\n+        when(mockDataStore.get(argThat(new Phase2Matcher(payloadEpoch))))\n+                .thenReturn(new Phase2Data(new Rank(phase1Rank, DEFAULT_UUID), l));\n+        layoutServer.handleMessage(proposeRequest, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockDataStore, never()).put(any(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg proposeResponse = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(proposeRequest.getHeader(), proposeResponse.getHeader()));\n+        assertTrue(proposeResponse.getPayload().hasProposeLayoutResponse());\n+        // The PROPOSE_LAYOUT_REQUEST should be rejected because the rank\n+        // in PROPOSE_LAYOUT_REQUEST is equal to the current phase 2 rank.\n+        assertFalse(proposeResponse.getPayload().getProposeLayoutResponse().getProposed());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly acknowledges a COMMIT_LAYOUT_REQUEST.\n+     */\n+    @Test\n+    public void testCommitAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getCommitLayoutRequestMsg(false, payloadEpoch, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        ArgumentCaptor<Layout> layoutCaptor = ArgumentCaptor.forClass(Layout.class);\n+        ArgumentCaptor<Long> serverEpochCaptor = ArgumentCaptor.forClass(Long.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerContext).setCurrentLayout(layoutCaptor.capture());\n+        verify(mockServerContext).setServerEpoch(serverEpochCaptor.capture(), any(IServerRouter.class));\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        Layout currentLayout = layoutCaptor.getValue();\n+        long serverEpoch = serverEpochCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasCommitLayoutResponse());\n+        assertTrue(response.getPayload().getCommitLayoutResponse().getCommitted());\n+        // Verify the serverContext performs setCurrentLayout and setServerEpoch with expected values\n+        assertLayoutMatch(currentLayout);\n+        assertEquals(serverEpoch, payloadEpoch);\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly rejects a COMMIT_LAYOUT_REQUEST when\n+     * the payloadEpoch is not equal to serverEpoch..\n+     */\n+    @Test\n+    public void testCommitWrongEpoch() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        long serverEpoch = 5L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getCommitLayoutRequestMsg(false, payloadEpoch, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+\n+        when(mockServerContext.getCurrentLayout()).thenReturn(l);\n+        when(mockServerContext.getServerEpoch()).thenReturn(serverEpoch);\n+        layoutServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+        verify(mockServerContext, never()).setCurrentLayout(any());\n+        verify(mockServerContext, never()).setServerEpoch(anyLong(), any());\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a LAYOUT_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        // Check that Layout Server handler sends a WrongEpochErrorMsg\n+        ServerErrorMsg serverErrorMsg = response.getPayload().getServerError();\n+        assertTrue(serverErrorMsg.hasWrongEpochError());\n+    }\n+\n+    /**\n+     * Test that the LayoutServer correctly acknowledges a COMMIT_LAYOUT_REQUEST that is forced set to true.\n+     */\n+    @Test\n+    public void testForceLayoutAck() throws IOException {\n+        Layout l = getDefaultLayout();\n+        long payloadEpoch = 0L;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                getCommitLayoutRequestMsg(true, payloadEpoch, l)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        ArgumentCaptor<Layout> layoutCaptor = ArgumentCaptor.forClass(Layout.class);\n+        ArgumentCaptor<Long> serverEpochCaptor = ArgumentCaptor.forClass(Long.class);", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyMzU1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533823551", "bodyText": "Notice that this check is called on all the handlers except for the actual bootstrap call. I would recommend that this check is executed in the entry point, i.e, processRequest.\n@Override\n    protected void processRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n        executor.submit(() -> {\n\n\n            if (!req.getPayload().getPayloadCase().equals(RequestPayloadMsg.PayloadCase.BOOTSTRAP_LAYOUT_REQUEST)\n            && !isBootstrapped(req)) {\n                r.sendNoBootstrapError(req.getHeader(), ctx);\n                return;\n            }\n\n            // Don't process layout server requests unless the server is bootstrapped \n            getHandlerMethods().handle(req, ctx, r);\n        });\n    }", "author": "Maithem", "createdAt": "2020-12-02T00:57:51Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -127,10 +121,9 @@ public void shutdown() {\n         executor.shutdown();\n     }\n \n-    private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    private boolean isBootstrapped(RequestMsg requestMsg) {", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4MDY5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533880695", "bodyText": "Yeah it's called for most handlers. But @zfrenette formerly brought up a concern that, by this way we are performing the check before the task is submitted to the executor service, and the status could change by the time the new thread is actually executing the handler. (#2823 (comment)) I think it's reasonable, but would like to know your opinion for this.", "author": "xcchang", "createdAt": "2020-12-02T03:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyMzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4MTk5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533881993", "bodyText": "but hmm followed by your next comment, those handlers are literally single threaded, then it should be fine to move this check to processRequest :-)", "author": "xcchang", "createdAt": "2020-12-02T04:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyMzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2MjA1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r544762050", "bodyText": "The status cannot change if only one thread is executing all handlers", "author": "Maithem", "createdAt": "2020-12-17T02:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyMzU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyNDc0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533824748", "bodyText": "I know this predates your patch, but honestly this doesn't make sense at all: having a multi-threaded executor to server the request handlers and marking all the handlers as synchronized is just lol.\nCan you just change this.executor  to be single threaded and drop all the synchronized ?", "author": "Maithem", "createdAt": "2020-12-02T01:01:00Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -141,275 +134,317 @@ private boolean isBootstrapped(CorfuMsg msg, ChannelHandlerContext ctx, IServerR\n     /**\n      * Handle a layout request message.\n      *\n-     * @param msg              corfu message containing LAYOUT_REQUEST\n+     * @param req              corfu message containing LAYOUT_REQUEST\n      * @param ctx              netty ChannelHandlerContext\n      * @param r                server router\n      */\n-    @ServerHandler(type = CorfuMsgType.LAYOUT_REQUEST)\n-    public synchronized void handleMessageLayoutRequest(CorfuPayloadMsg<Long> msg,\n-                                                    ChannelHandlerContext ctx, IServerRouter r) {\n-        if (!isBootstrapped(msg, ctx, r)) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.LAYOUT_REQUEST)\n+    public synchronized void handleLayoutRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyNTUxOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533825519", "bodyText": "With Biased locking (hotspot optimization) having synchronized without contention should be cheap, so you can keep the synchronized methods, but change the executor to a single thread.\nI would just remove the synchronized though, it seems super unnecessary.", "author": "Maithem", "createdAt": "2020-12-02T01:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyNDc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1Njg4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r534456882", "bodyText": "Removed the synchronized, thanks!", "author": "xcchang", "createdAt": "2020-12-02T20:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyNDc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzMTY0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533831647", "bodyText": "This is a bug. The clients are expecting an exception to be thrown when this response is sent back, but this will return a value.", "author": "Maithem", "createdAt": "2020-12-02T01:18:27Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/LayoutHandler.java", "diffHunk": "@@ -52,46 +59,116 @@ public LayoutClient getClient(long epoch, UUID clusterID) {\n             .generateHandlers(MethodHandles.lookup(), this)\n             .generateErrorHandlers(MethodHandles.lookup(), this);\n \n+    /**\n+     * TODO: Remove this method when Management RPC get landed.\n+     */\n+    @Deprecated\n+    @ClientHandler(type = CorfuMsgType.LAYOUT_NOBOOTSTRAP)\n+    private static Object handleNoBootstrap(CorfuMsg msg,\n+                                            ChannelHandlerContext ctx, IClientRouter r)\n+            throws Exception {\n+        throw new NoBootstrapException();\n+    }\n \n+    /**\n+     * TODO: Remove this method when Management RPC get landed.\n+     */\n+    @Deprecated\n     @ClientHandler(type = CorfuMsgType.LAYOUT_RESPONSE)\n     private static Object handleLayoutResponse(CorfuMsg msg,\n                                                ChannelHandlerContext ctx, IClientRouter r) {\n         return ((LayoutMsg) msg).getLayout();\n     }\n \n-    @ClientHandler(type = CorfuMsgType.LAYOUT_PREPARE_ACK)\n-    private static Object handleLayoutPrepareAck(CorfuPayloadMsg<LayoutPrepareRequest> msg,\n-                                                 ChannelHandlerContext ctx, IClientRouter r) {\n-        return msg.getPayload();\n+    /**\n+     * Handle a layout response from the server.\n+     *\n+     * @param msg The layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return {@link Layout} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.LAYOUT_RESPONSE)\n+    private static Object handleLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                               IClientRouter r) {\n+        LayoutResponseMsg layoutResponse = msg.getPayload().getLayoutResponse();\n+        RpcCommon.LayoutMsg layoutMsg = layoutResponse.getLayout();\n+\n+        return CorfuProtocolCommon.getLayout(layoutMsg);\n     }\n \n-    @ClientHandler(type = CorfuMsgType.LAYOUT_NOBOOTSTRAP)\n-    private static Object handleNoBootstrap(CorfuMsg msg,\n-                                            ChannelHandlerContext ctx, IClientRouter r)\n-            throws Exception {\n-        throw new NoBootstrapException();\n+    /**\n+     * Handle a prepare layout response from the server.\n+     *\n+     * @param msg The prepare layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return {@link LayoutPrepareResponse} if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.PREPARE_LAYOUT_RESPONSE)\n+    private static Object handlePrepareLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                      IClientRouter r) {\n+        PrepareLayoutResponseMsg prepareLayoutMsg = msg.getPayload().getPrepareLayoutResponse();\n+        boolean prepared = prepareLayoutMsg.getPrepared();\n+        long rank = prepareLayoutMsg.getRank();\n+        Layout layout = CorfuProtocolCommon.getLayout(prepareLayoutMsg.getLayout());\n+\n+        if (!prepared) {\n+            throw new OutrankedException(rank, layout);\n+        }\n+        return new LayoutPrepareResponse(rank, layout);\n     }\n \n-    @ClientHandler(type = CorfuMsgType.LAYOUT_PREPARE_REJECT)\n-    private static Object handlePrepareReject(CorfuPayloadMsg<LayoutPrepareResponse> msg,\n-                                              ChannelHandlerContext ctx, IClientRouter r)\n-            throws Exception {\n-        LayoutPrepareResponse response = msg.getPayload();\n-        throw new OutrankedException(response.getRank(), response.getLayout());\n+    /**\n+     * Handle a propose layout response from the server.\n+     *\n+     * @param msg The propose layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return True if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.PROPOSE_LAYOUT_RESPONSE)\n+    private static Object handleProposeLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                      IClientRouter r) {\n+        ProposeLayoutResponseMsg proposeLayoutMsg = msg.getPayload().getProposeLayoutResponse();\n+        boolean proposed = proposeLayoutMsg.getProposed();\n+        long rank = proposeLayoutMsg.getRank();\n+\n+        if (!proposed) {\n+            throw new OutrankedException(rank);\n+        }\n+        return true;\n     }\n \n-    @ClientHandler(type = CorfuMsgType.LAYOUT_PROPOSE_REJECT)\n-    private static Object handleProposeReject(CorfuPayloadMsg<LayoutProposeResponse> msg,\n-                                              ChannelHandlerContext ctx, IClientRouter r)\n-            throws Exception {\n-        LayoutProposeResponse response = msg.getPayload();\n-        throw new OutrankedException(response.getRank());\n+    /**\n+     * Handle a propose layout response from the server.\n+     *\n+     * @param msg The propose layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return True if ACK, throw an {@link OutrankedException} if REJECT.\n+     */\n+    @ResponseHandler(type = PayloadCase.COMMIT_LAYOUT_RESPONSE)\n+    private static Object handleCommitLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                     IClientRouter r) {\n+        CommitLayoutResponseMsg commitLayoutMsg = msg.getPayload().getCommitLayoutResponse();\n+\n+        return commitLayoutMsg.getCommitted();\n     }\n \n-    @ClientHandler(type = CorfuMsgType.LAYOUT_ALREADY_BOOTSTRAP)\n-    private static Object handleAlreadyBootstrap(CorfuMsg msg,\n-                                                 ChannelHandlerContext ctx, IClientRouter r)\n-            throws Exception {\n-        throw new AlreadyBootstrappedException();\n+    /**\n+     * Handle a bootstrap layout response from the server.\n+     *\n+     * @param msg The propose layout response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r A reference to the router.\n+     * @return True if ACK, false if NACK.\n+     */\n+    @ResponseHandler(type = PayloadCase.BOOTSTRAP_LAYOUT_RESPONSE)\n+    private static Object handleBootstrapLayoutResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                        IClientRouter r) {\n+        BootstrapLayoutResponseMsg bootstrapLayoutMsg =  msg.getPayload().getBootstrapLayoutResponse();\n+\n+        return bootstrapLayoutMsg.getBootstrapped();", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzMjk2Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533832966", "bodyText": "If you look here: https://github.com/CorfuDB/CorfuDB/blob/master/runtime/src/main/java/org/corfudb/runtime/view/LayoutView.java#L328\nA lot of code paths that rely on the exception to be thrown won't execute, because this changes the semantics of the method, but code that consumes this wasn't changed.", "author": "Maithem", "createdAt": "2020-12-02T01:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzMTY0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzNjExOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533836118", "bodyText": "Ops, I'm wrong.\nThere's a test for this and it is handled in the base handler. Kind of confusing when some errors return a false bool and some throw an exception.", "author": "Maithem", "createdAt": "2020-12-02T01:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzMTY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzNjkzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533836937", "bodyText": "Can you remove the tests in LayoutHandlerTest and replace them with these tests?", "author": "Maithem", "createdAt": "2020-12-02T01:33:44Z", "path": "runtime/src/test/java/org/corfudb/runtime/clients/CorfuLayoutHandlerTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.LayoutPrepareResponse;\n+import org.corfudb.runtime.exceptions.OutrankedException;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.LinkedList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getBootstrapLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getCommitLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getPrepareLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolLayout.getProposeLayoutResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.corfudb.runtime.view.Layout.fromJSONString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class CorfuLayoutHandlerTest {", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2MzIxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r534363214", "bodyText": "How about just delete the old LayoutHanlderTest?", "author": "xcchang", "createdAt": "2020-12-02T17:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzNjkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzNzM5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533837391", "bodyText": "Can you delete these instead of deprecating ?\nThey are not exposed publicly and we dont support backward compatibility.", "author": "Maithem", "createdAt": "2020-12-02T01:35:04Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/LayoutHandler.java", "diffHunk": "@@ -52,46 +59,116 @@ public LayoutClient getClient(long epoch, UUID clusterID) {\n             .generateHandlers(MethodHandles.lookup(), this)\n             .generateErrorHandlers(MethodHandles.lookup(), this);\n \n+    /**\n+     * TODO: Remove this method when Management RPC get landed.\n+     */\n+    @Deprecated\n+    @ClientHandler(type = CorfuMsgType.LAYOUT_NOBOOTSTRAP)\n+    private static Object handleNoBootstrap(CorfuMsg msg,\n+                                            ChannelHandlerContext ctx, IClientRouter r)\n+            throws Exception {\n+        throw new NoBootstrapException();", "originalCommit": "4490e7ac4f944ca0e5f963f8d0eb49930f56557f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4NzcyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r533887727", "bodyText": "Yeah they will be deleted after the following PRs get merged. Currently they are still used by some other CorfuMsg RPCs even if all the Layout RPCs has been replaced by Protobuf.", "author": "xcchang", "createdAt": "2020-12-02T04:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzNzM5MQ=="}], "type": "inlineReview"}, {"oid": "5b8f9e20bff9de238de4c7e3037285a2669d9cbb", "url": "https://github.com/CorfuDB/CorfuDB/commit/5b8f9e20bff9de238de4c7e3037285a2669d9cbb", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-02T03:44:55Z", "type": "forcePushed"}, {"oid": "63734e2bf06f27e0390d471b8cffb91a0feb5f45", "url": "https://github.com/CorfuDB/CorfuDB/commit/63734e2bf06f27e0390d471b8cffb91a0feb5f45", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-02T04:29:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2MDU0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2823#discussion_r534260548", "bodyText": "You can also remove the unused ByteBuf import here.", "author": "zfrenette", "createdAt": "2020-12-02T15:32:53Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/LayoutPrepareResponse.java", "diffHunk": "@@ -19,30 +19,7 @@\n  */\n @Data\n @AllArgsConstructor\n-public class LayoutPrepareResponse implements ICorfuPayload<LayoutPrepareResponse> {\n+public class LayoutPrepareResponse {\n     private long rank;\n     private Layout layout;\n-\n-    /**\n-     * Constructor for layout server response in first phase of Paxos.\n-     */\n-    public LayoutPrepareResponse(ByteBuf buf) {", "originalCommit": "63734e2bf06f27e0390d471b8cffb91a0feb5f45", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d2098981f1ee638a182f3435d89edc5e63bf75e2", "url": "https://github.com/CorfuDB/CorfuDB/commit/d2098981f1ee638a182f3435d89edc5e63bf75e2", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-02T18:55:59Z", "type": "forcePushed"}, {"oid": "3ae730c2cda42dc60fff5c8a511cbec6b67e2451", "url": "https://github.com/CorfuDB/CorfuDB/commit/3ae730c2cda42dc60fff5c8a511cbec6b67e2451", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-02T19:11:50Z", "type": "forcePushed"}, {"oid": "bdd9a3819336e7f1d953fdcbcecc457865c8b411", "url": "https://github.com/CorfuDB/CorfuDB/commit/bdd9a3819336e7f1d953fdcbcecc457865c8b411", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-03T04:44:04Z", "type": "forcePushed"}, {"oid": "5a70a54c7628709e548f23875e75a8f82e2b40b2", "url": "https://github.com/CorfuDB/CorfuDB/commit/5a70a54c7628709e548f23875e75a8f82e2b40b2", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-03T05:29:42Z", "type": "forcePushed"}, {"oid": "770fafddfe548d82304efa38089f19617a144904", "url": "https://github.com/CorfuDB/CorfuDB/commit/770fafddfe548d82304efa38089f19617a144904", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-03T17:10:20Z", "type": "forcePushed"}, {"oid": "759ba1efd6982489b2bf0d856320917742d9e13d", "url": "https://github.com/CorfuDB/CorfuDB/commit/759ba1efd6982489b2bf0d856320917742d9e13d", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-03T18:52:43Z", "type": "forcePushed"}, {"oid": "4f4fdb5f4d5017b670e23e3eb3e0053280968698", "url": "https://github.com/CorfuDB/CorfuDB/commit/4f4fdb5f4d5017b670e23e3eb3e0053280968698", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-03T22:29:24Z", "type": "forcePushed"}, {"oid": "60734a5bec1a38e4e4526f2da6611715c63c2a8c", "url": "https://github.com/CorfuDB/CorfuDB/commit/60734a5bec1a38e4e4526f2da6611715c63c2a8c", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-03T22:59:15Z", "type": "forcePushed"}, {"oid": "ed6ef4e5c1a642c7c18244c841aec3e0f023e511", "url": "https://github.com/CorfuDB/CorfuDB/commit/ed6ef4e5c1a642c7c18244c841aec3e0f023e511", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-04T20:53:24Z", "type": "forcePushed"}, {"oid": "f98a4f3ff1726734ab82db6538405b21a92cc32b", "url": "https://github.com/CorfuDB/CorfuDB/commit/f98a4f3ff1726734ab82db6538405b21a92cc32b", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-04T21:16:10Z", "type": "forcePushed"}, {"oid": "68d4455a699a8a1ccd76a11061245e4066eb48ae", "url": "https://github.com/CorfuDB/CorfuDB/commit/68d4455a699a8a1ccd76a11061245e4066eb48ae", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-04T21:26:52Z", "type": "forcePushed"}, {"oid": "d60a81488abde1554906856652d63dca24d014e3", "url": "https://github.com/CorfuDB/CorfuDB/commit/d60a81488abde1554906856652d63dca24d014e3", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-08T22:23:37Z", "type": "forcePushed"}, {"oid": "2b84d0d60faeb45ec31bce7c3b052ac540be9f2d", "url": "https://github.com/CorfuDB/CorfuDB/commit/2b84d0d60faeb45ec31bce7c3b052ac540be9f2d", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-14T23:05:33Z", "type": "forcePushed"}, {"oid": "fd7c8ceba41e3357caf76e328cac66cf0a783651", "url": "https://github.com/CorfuDB/CorfuDB/commit/fd7c8ceba41e3357caf76e328cac66cf0a783651", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-15T05:02:03Z", "type": "commit"}, {"oid": "fd7c8ceba41e3357caf76e328cac66cf0a783651", "url": "https://github.com/CorfuDB/CorfuDB/commit/fd7c8ceba41e3357caf76e328cac66cf0a783651", "message": "Add Implementation of Layout RPCs using Protobuf\n\nProvides an implementation of Layout RPCs using Protobuf. Done\nas part of an effort to support rolling upgrades.", "committedDate": "2020-12-15T05:02:03Z", "type": "forcePushed"}]}