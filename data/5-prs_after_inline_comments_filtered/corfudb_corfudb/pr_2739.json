{"pr_number": 2739, "pr_title": "Two-Phase Snapshot Sync", "pr_createdAt": "2020-08-28T03:19:49Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2739", "timeline": [{"oid": "75507c87359123437a69eaf735c4cd8618f3084b", "url": "https://github.com/CorfuDB/CorfuDB/commit/75507c87359123437a69eaf735c4cd8618f3084b", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-08-28T03:21:50Z", "type": "forcePushed"}, {"oid": "35162854c15f329fccf0670d0a1d06dceb491db3", "url": "https://github.com/CorfuDB/CorfuDB/commit/35162854c15f329fccf0670d0a1d06dceb491db3", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-08-28T03:31:29Z", "type": "forcePushed"}, {"oid": "a3f7a81fb5df2781033233c75265db2c763ecdd8", "url": "https://github.com/CorfuDB/CorfuDB/commit/a3f7a81fb5df2781033233c75265db2c763ecdd8", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-08-28T03:33:50Z", "type": "forcePushed"}, {"oid": "f92bd9b63bfeeae3fdc01b476ad162f67c47286e", "url": "https://github.com/CorfuDB/CorfuDB/commit/f92bd9b63bfeeae3fdc01b476ad162f67c47286e", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-08-28T03:36:53Z", "type": "forcePushed"}, {"oid": "0726e56a50e0ce9768b3cff4b73960e7485556d2", "url": "https://github.com/CorfuDB/CorfuDB/commit/0726e56a50e0ce9768b3cff4b73960e7485556d2", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-08-28T03:43:09Z", "type": "forcePushed"}, {"oid": "2912729585a7da58b295816ed7c66d21296dec99", "url": "https://github.com/CorfuDB/CorfuDB/commit/2912729585a7da58b295816ed7c66d21296dec99", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-08-28T04:08:52Z", "type": "forcePushed"}, {"oid": "249bf8ff9fe47fc3ad74595cf94da7f8966a6409", "url": "https://github.com/CorfuDB/CorfuDB/commit/249bf8ff9fe47fc3ad74595cf94da7f8966a6409", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-08-28T07:12:58Z", "type": "forcePushed"}, {"oid": "7fe08333648b24e0147cba27d1e5e8168ff8c9ec", "url": "https://github.com/CorfuDB/CorfuDB/commit/7fe08333648b24e0147cba27d1e5e8168ff8c9ec", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-08-28T18:49:14Z", "type": "forcePushed"}, {"oid": "ec868dec82696a419eed1becebfe59298cb533be", "url": "https://github.com/CorfuDB/CorfuDB/commit/ec868dec82696a419eed1becebfe59298cb533be", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-08-28T18:59:17Z", "type": "forcePushed"}, {"oid": "f061f089f97b1ddef3980dfad202ed627a5753b9", "url": "https://github.com/CorfuDB/CorfuDB/commit/f061f089f97b1ddef3980dfad202ed627a5753b9", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-09-01T23:36:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU0MzkxNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r479543915", "bodyText": "Negotiation -> metadata", "author": "zhangn49", "createdAt": "2020-08-28T21:32:57Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogReplicationServer.java", "diffHunk": "@@ -100,27 +100,27 @@ private void handleLogReplicationEntry(CorfuPayloadMsg<LogReplicationEntry> msg,\n         }\n     }\n \n-    @ServerHandler(type = CorfuMsgType.LOG_REPLICATION_NEGOTIATION_REQUEST)\n-    private void handleLogReplicationNegotiationRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        log.info(\"Log Replication Negotiation Request received by Server.\");\n+    @ServerHandler(type = CorfuMsgType.LOG_REPLICATION_METADATA_REQUEST)\n+    private void handleMetadataRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n+        log.info(\"Log Replication Metadata Request received by Server.\");\n \n         if (isLeader(msg, r)) {\n             LogReplicationMetadataManager metadataMgr = sinkManager.getLogReplicationMetadataManager();\n \n-            // TODO (Xiaoqin Ma): That's 6 independent DB calls per one LOG_REPLICATION_NEGOTIATION_REQUEST.\n+            // TODO (Xiaoqin Ma): That's 6 independent DB calls per one request.\n             //  Can we do just one? Also, It does not look like we handle failures if one of them fails, for example.\n-            LogReplicationNegotiationResponse response = new LogReplicationNegotiationResponse(\n+            LogReplicationMetadataResponse response = new LogReplicationMetadataResponse(\n                     metadataMgr.getTopologyConfigId(),\n                     metadataMgr.getVersion(),\n-                    metadataMgr.getLastSnapStartTimestamp(),\n-                    metadataMgr.getLastSnapTransferDoneTimestamp(),\n-                    metadataMgr.getLastAppliedBaseSnapshotTimestamp(),\n-                    metadataMgr.getLastProcessedLogTimestamp());\n+                    metadataMgr.getLastStartedSnapshotTimestamp(),\n+                    metadataMgr.getLastTransferredSnapshotTimestamp(),\n+                    metadataMgr.getLastAppliedSnapshotTimestamp(),\n+                    metadataMgr.getLastProcessedLogEntryTimestamp());\n             log.info(\"Send Negotiation response\");", "originalCommit": "ec868dec82696a419eed1becebfe59298cb533be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzNzAwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481537001", "bodyText": "Done.", "author": "annym", "createdAt": "2020-09-02T01:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU0MzkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwMjg4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481502880", "bodyText": "Each LOG_ENTRY_SYNC_REPLICATED event will print an error log in FSM consumer. Can we disable the error log for this event?", "author": "zhangn49", "createdAt": "2020-09-02T00:20:53Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/InLogEntrySyncState.java", "diffHunk": "@@ -74,6 +74,15 @@ public LogReplicationState processEvent(LogReplicationEvent event) throws Illega\n             case REPLICATION_SHUTDOWN:\n                 cancelLogEntrySync(\"replication terminated.\");\n                 return fsm.getStates().get(LogReplicationStateType.STOPPED);\n+            case LOG_ENTRY_SYNC_REPLICATED:\n+                // Verify the replicated entry corresponds to the current log entry sync cycle (and not a previous/old one)\n+                if (transitionEventId.equals(event.getMetadata().getRequestId())) {\n+                    log.debug(\"Log Entry Sync ACK, update last ack timestamp to {}\", event.getMetadata().getLastLogEntrySyncedTimestamp());\n+                    fsm.setAckedTimestamp(event.getMetadata().getLastLogEntrySyncedTimestamp());\n+                }\n+                // Do not return a new state as there is no actual transition, the IllegalTransitionException\n+                // will allow us to avoid any transition from this state given the event.\n+                break;", "originalCommit": "f061f089f97b1ddef3980dfad202ed627a5753b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0MDIxMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481540212", "bodyText": "sure, sounds reasonable. Done.", "author": "annym", "createdAt": "2020-09-02T01:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwMjg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNDY1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481504656", "bodyText": "Is it possible that ACK is out of order? It is from CF.Anyof pendingCompletableFutureForAcks.\nIf so, do we need to make fsm's AckedTimestamp increase monotonically?", "author": "zhangn49", "createdAt": "2020-09-02T00:27:24Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/InLogEntrySyncState.java", "diffHunk": "@@ -74,6 +74,15 @@ public LogReplicationState processEvent(LogReplicationEvent event) throws Illega\n             case REPLICATION_SHUTDOWN:\n                 cancelLogEntrySync(\"replication terminated.\");\n                 return fsm.getStates().get(LogReplicationStateType.STOPPED);\n+            case LOG_ENTRY_SYNC_REPLICATED:\n+                // Verify the replicated entry corresponds to the current log entry sync cycle (and not a previous/old one)\n+                if (transitionEventId.equals(event.getMetadata().getRequestId())) {\n+                    log.debug(\"Log Entry Sync ACK, update last ack timestamp to {}\", event.getMetadata().getLastLogEntrySyncedTimestamp());\n+                    fsm.setAckedTimestamp(event.getMetadata().getLastLogEntrySyncedTimestamp());", "originalCommit": "f061f089f97b1ddef3980dfad202ed627a5753b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0NTA4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481545082", "bodyText": "I don't think they can come out of order, because the receiver can only process in order and it will send a summarized ack, plus the receiver is single threaded in its processing.", "author": "annym", "createdAt": "2020-09-02T01:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNDY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0OTI3MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481549270", "bodyText": "Yeah, I see the previous logic was doing the same thing. I was thinking about things like network delay", "author": "zhangn49", "createdAt": "2020-09-02T02:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNDY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUyODAwNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482528005", "bodyText": "Can you explain why we need this check?\nAlso, now the eventID is a randomUUID, we should replace that with a deterministic method and guarantee no duplicates.", "author": "xiaoqin2012", "createdAt": "2020-09-02T22:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNDY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYyOTg4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482629885", "bodyText": "Like in the comment, it is needed to:\n// Verify the replicated entry corresponds to the current log entry sync cycle (and not a previous/old one)\nThe first time we enter LOG_ENTRY_SYNC it is random (because we need an initial one) after that ACKs are always stamped with the same one. It allows to discard an event originated by an old replication cycle, which is not the current one.", "author": "annym", "createdAt": "2020-09-03T00:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNDY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMDM1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481530352", "bodyText": "Looks like we don't have a timeout here, does it mean we will retry to verify forever if standby's apply phase is stuck? In this case, we need a user to enforce snapshot sync?", "author": "zhangn49", "createdAt": "2020-09-02T01:32:49Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/WaitSnapshotApplyState.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.corfudb.infrastructure.logreplication.replication.fsm;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.DataSender;\n+import org.corfudb.infrastructure.logreplication.replication.send.LogReplicationEventMetadata;\n+import org.corfudb.infrastructure.logreplication.runtime.CorfuLogReplicationRuntime;\n+import org.corfudb.protocols.wireprotocol.logreplication.LogReplicationMetadataResponse;\n+\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * This class represents the WaitSnapshotApply state of the Log Replication State Machine.\n+ *\n+ * In this state the remote cluster is queried to verify snapshot sync has been applied\n+ * and move onto log entry sync (incremental update replication).\n+ *\n+ * This state is an optimization such that snapshot sync is separated into transfer and apply phases.\n+ * If data has been completely transferred and some failure occurs immediately after, the receiver can still\n+ * recover and data does not need to be transferred all over again.\n+ */\n+@Slf4j\n+public class WaitSnapshotApplyState implements LogReplicationState {\n+\n+    /**\n+     * Delay in milliseconds to monitor replication status on receiver, when snapshot sync apply is in progress.\n+     */\n+    private static final int SCHEDULE_APPLY_MONITOR_DELAY = 2000;\n+\n+    /**\n+     * Log Replication Finite State Machine Instance\n+     */\n+    private final LogReplicationFSM fsm;\n+\n+    /**\n+     Uniquely identifies the snapshot sync to which this wait state is associated.\n+     */\n+    private UUID transitionEventId;\n+\n+    /**\n+     * Route query metadata messages to the remote cluster\n+     */\n+    private DataSender dataSender;\n+\n+    /**\n+     * Base Snapshot Timestamp for current Snapshot Sync\n+     */\n+    private long baseSnapshotTimestamp;\n+\n+    private ScheduledExecutorService snapshotSyncApplyMonitorExecutor;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param logReplicationFSM log replication state machine\n+     */\n+    public WaitSnapshotApplyState(LogReplicationFSM logReplicationFSM, DataSender dataSender) {\n+        this.fsm = logReplicationFSM;\n+        this.dataSender = dataSender;\n+        this.snapshotSyncApplyMonitorExecutor = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryBuilder()\n+                .setDaemon(true)\n+                .setNameFormat(\"snapshotSyncApplyVerificationScheduler\")\n+                .build());\n+    }\n+\n+    @Override\n+    public LogReplicationState processEvent(LogReplicationEvent event) throws IllegalTransitionException {\n+        switch (event.getType()) {\n+            case SNAPSHOT_SYNC_REQUEST:\n+                log.info(\"Snapshot Sync requested {} while waiting for {} to complete.\", event.getEventID(), getTransitionEventId());\n+                LogReplicationState snapshotSyncState = fsm.getStates().get(LogReplicationStateType.IN_SNAPSHOT_SYNC);\n+                snapshotSyncState.setTransitionEventId(event.getEventID());\n+                return snapshotSyncState;\n+            case SYNC_CANCEL:\n+                log.debug(\"Sync has been canceled while waiting for Snapshot Sync {} to complete apply. Restart.\", transitionEventId);\n+                LogReplicationState inSnapshotSyncState = fsm.getStates().get(LogReplicationStateType.IN_SNAPSHOT_SYNC);\n+                inSnapshotSyncState.setTransitionEventId(UUID.randomUUID());\n+                return inSnapshotSyncState;\n+            case SNAPSHOT_APPLY_IN_PROGRESS:\n+                log.debug(\"Snapshot Apply in progress {}. Verify status.\", transitionEventId);\n+                return this;\n+            case SNAPSHOT_APPLY_COMPLETE:\n+                UUID snapshotSyncApplyId = event.getMetadata().getRequestId();\n+                /*\n+                 This is required as in the following sequence of events:\n+\n+                 1. SNAPSHOT_SYNC_REQUEST (ID = 1) EXTERNAL\n+                 2. SYNC_CANCEL (ID = 1) EXTERNAL\n+                 3. SNAPSHOT_SYNC_REQUEST (ID = 2) EXTERNAL\n+\n+                 Snapshot Sync with ID = 1 could be completed in between (1 and 2) but show up in the queue\n+                 as 4, attempting to process a completion event for the incorrect snapshot sync.\n+                 */\n+                if (snapshotSyncApplyId.equals(transitionEventId)) {\n+                    LogReplicationState logEntrySyncState = fsm.getStates()\n+                            .get(LogReplicationStateType.IN_LOG_ENTRY_SYNC);\n+                    // We need to set a new transition event Id, so anything happening on this new state\n+                    // is marked with this unique Id and correlated to cancel or trimmed events.\n+                    logEntrySyncState.setTransitionEventId(event.getEventID());\n+                    fsm.setBaseSnapshot(event.getMetadata().getLastTransferredBaseSnapshot());\n+                    fsm.setAckedTimestamp(event.getMetadata().getLastLogEntrySyncedTimestamp());\n+                    log.info(\"Snapshot Sync apply completed, syncRequestId={}, baseSnapshot={}. Transition to LOG_ENTRY_SYNC\",\n+                            event.getEventID(), event.getMetadata().getLastTransferredBaseSnapshot());\n+                    return logEntrySyncState;\n+                }\n+\n+                log.warn(\"Ignoring snapshot sync apply complete event, for request {}, as ongoing snapshot sync is {}\",\n+                        snapshotSyncApplyId, transitionEventId);\n+                return this;\n+            case REPLICATION_STOP:\n+                log.debug(\"Stop Log Replication while waiting for snapshot sync apply to complete id={}\", transitionEventId);\n+                return fsm.getStates().get(LogReplicationStateType.INITIALIZED);\n+            case REPLICATION_SHUTDOWN:\n+                log.debug(\"Shutdown Log Replication while waiting for snapshot sync apply to complete id={}\", transitionEventId);\n+                return fsm.getStates().get(LogReplicationStateType.STOPPED);\n+            default: {\n+                log.warn(\"Unexpected log replication event {} when in wait snapshot sync apply state.\", event.getType());\n+                throw new IllegalTransitionException(event.getType(), getType());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEntry(LogReplicationState from) {\n+        log.info(\"OnEntry :: wait snapshot apply state\");\n+        this.fsm.getLogReplicationFSMWorkers().submit(this::verifyStatusOfSnapshotSyncApply);\n+    }\n+\n+    private void verifyStatusOfSnapshotSyncApply() {", "originalCommit": "f061f089f97b1ddef3980dfad202ed627a5753b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0Mjk0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481542949", "bodyText": "yes, that's the way it will perform.", "author": "annym", "createdAt": "2020-09-02T01:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMDM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMjQ0Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481532446", "bodyText": "If there is an exception, looks like we are not able to input an event to FSM and not able to start the executor?", "author": "zhangn49", "createdAt": "2020-09-02T01:36:16Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/WaitSnapshotApplyState.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.corfudb.infrastructure.logreplication.replication.fsm;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.DataSender;\n+import org.corfudb.infrastructure.logreplication.replication.send.LogReplicationEventMetadata;\n+import org.corfudb.infrastructure.logreplication.runtime.CorfuLogReplicationRuntime;\n+import org.corfudb.protocols.wireprotocol.logreplication.LogReplicationMetadataResponse;\n+\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * This class represents the WaitSnapshotApply state of the Log Replication State Machine.\n+ *\n+ * In this state the remote cluster is queried to verify snapshot sync has been applied\n+ * and move onto log entry sync (incremental update replication).\n+ *\n+ * This state is an optimization such that snapshot sync is separated into transfer and apply phases.\n+ * If data has been completely transferred and some failure occurs immediately after, the receiver can still\n+ * recover and data does not need to be transferred all over again.\n+ */\n+@Slf4j\n+public class WaitSnapshotApplyState implements LogReplicationState {\n+\n+    /**\n+     * Delay in milliseconds to monitor replication status on receiver, when snapshot sync apply is in progress.\n+     */\n+    private static final int SCHEDULE_APPLY_MONITOR_DELAY = 2000;\n+\n+    /**\n+     * Log Replication Finite State Machine Instance\n+     */\n+    private final LogReplicationFSM fsm;\n+\n+    /**\n+     Uniquely identifies the snapshot sync to which this wait state is associated.\n+     */\n+    private UUID transitionEventId;\n+\n+    /**\n+     * Route query metadata messages to the remote cluster\n+     */\n+    private DataSender dataSender;\n+\n+    /**\n+     * Base Snapshot Timestamp for current Snapshot Sync\n+     */\n+    private long baseSnapshotTimestamp;\n+\n+    private ScheduledExecutorService snapshotSyncApplyMonitorExecutor;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param logReplicationFSM log replication state machine\n+     */\n+    public WaitSnapshotApplyState(LogReplicationFSM logReplicationFSM, DataSender dataSender) {\n+        this.fsm = logReplicationFSM;\n+        this.dataSender = dataSender;\n+        this.snapshotSyncApplyMonitorExecutor = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryBuilder()\n+                .setDaemon(true)\n+                .setNameFormat(\"snapshotSyncApplyVerificationScheduler\")\n+                .build());\n+    }\n+\n+    @Override\n+    public LogReplicationState processEvent(LogReplicationEvent event) throws IllegalTransitionException {\n+        switch (event.getType()) {\n+            case SNAPSHOT_SYNC_REQUEST:\n+                log.info(\"Snapshot Sync requested {} while waiting for {} to complete.\", event.getEventID(), getTransitionEventId());\n+                LogReplicationState snapshotSyncState = fsm.getStates().get(LogReplicationStateType.IN_SNAPSHOT_SYNC);\n+                snapshotSyncState.setTransitionEventId(event.getEventID());\n+                return snapshotSyncState;\n+            case SYNC_CANCEL:\n+                log.debug(\"Sync has been canceled while waiting for Snapshot Sync {} to complete apply. Restart.\", transitionEventId);\n+                LogReplicationState inSnapshotSyncState = fsm.getStates().get(LogReplicationStateType.IN_SNAPSHOT_SYNC);\n+                inSnapshotSyncState.setTransitionEventId(UUID.randomUUID());\n+                return inSnapshotSyncState;\n+            case SNAPSHOT_APPLY_IN_PROGRESS:\n+                log.debug(\"Snapshot Apply in progress {}. Verify status.\", transitionEventId);\n+                return this;\n+            case SNAPSHOT_APPLY_COMPLETE:\n+                UUID snapshotSyncApplyId = event.getMetadata().getRequestId();\n+                /*\n+                 This is required as in the following sequence of events:\n+\n+                 1. SNAPSHOT_SYNC_REQUEST (ID = 1) EXTERNAL\n+                 2. SYNC_CANCEL (ID = 1) EXTERNAL\n+                 3. SNAPSHOT_SYNC_REQUEST (ID = 2) EXTERNAL\n+\n+                 Snapshot Sync with ID = 1 could be completed in between (1 and 2) but show up in the queue\n+                 as 4, attempting to process a completion event for the incorrect snapshot sync.\n+                 */\n+                if (snapshotSyncApplyId.equals(transitionEventId)) {\n+                    LogReplicationState logEntrySyncState = fsm.getStates()\n+                            .get(LogReplicationStateType.IN_LOG_ENTRY_SYNC);\n+                    // We need to set a new transition event Id, so anything happening on this new state\n+                    // is marked with this unique Id and correlated to cancel or trimmed events.\n+                    logEntrySyncState.setTransitionEventId(event.getEventID());\n+                    fsm.setBaseSnapshot(event.getMetadata().getLastTransferredBaseSnapshot());\n+                    fsm.setAckedTimestamp(event.getMetadata().getLastLogEntrySyncedTimestamp());\n+                    log.info(\"Snapshot Sync apply completed, syncRequestId={}, baseSnapshot={}. Transition to LOG_ENTRY_SYNC\",\n+                            event.getEventID(), event.getMetadata().getLastTransferredBaseSnapshot());\n+                    return logEntrySyncState;\n+                }\n+\n+                log.warn(\"Ignoring snapshot sync apply complete event, for request {}, as ongoing snapshot sync is {}\",\n+                        snapshotSyncApplyId, transitionEventId);\n+                return this;\n+            case REPLICATION_STOP:\n+                log.debug(\"Stop Log Replication while waiting for snapshot sync apply to complete id={}\", transitionEventId);\n+                return fsm.getStates().get(LogReplicationStateType.INITIALIZED);\n+            case REPLICATION_SHUTDOWN:\n+                log.debug(\"Shutdown Log Replication while waiting for snapshot sync apply to complete id={}\", transitionEventId);\n+                return fsm.getStates().get(LogReplicationStateType.STOPPED);\n+            default: {\n+                log.warn(\"Unexpected log replication event {} when in wait snapshot sync apply state.\", event.getType());\n+                throw new IllegalTransitionException(event.getType(), getType());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEntry(LogReplicationState from) {\n+        log.info(\"OnEntry :: wait snapshot apply state\");\n+        this.fsm.getLogReplicationFSMWorkers().submit(this::verifyStatusOfSnapshotSyncApply);\n+    }\n+\n+    private void verifyStatusOfSnapshotSyncApply() {\n+        try {\n+            log.debug(\"Verify snapshot sync apply status, sync={}\", transitionEventId);\n+\n+            // Query metadata on remote cluster to verify the status of the snapshot sync apply\n+            CompletableFuture<LogReplicationMetadataResponse> metadataResponseCompletableFuture = dataSender.sendMetadataRequest();\n+            LogReplicationMetadataResponse metadataResponse = metadataResponseCompletableFuture.get(CorfuLogReplicationRuntime.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);\n+\n+            // If snapshot sync apply phase has been completed on remote cluster, transition to Log Entry Sync\n+            // (incremental update replication), otherwise, schedule new query.\n+            if (metadataResponse.getLastLogProcessed() == metadataResponse.getSnapshotApplied() &&\n+                    metadataResponse.getSnapshotApplied() == baseSnapshotTimestamp) {\n+                log.info(\"Snapshot sync apply is complete appliedTs={}, baseTs={}\", metadataResponse.getSnapshotApplied(),\n+                        baseSnapshotTimestamp);\n+                fsm.input(new LogReplicationEvent(LogReplicationEvent.LogReplicationEventType.SNAPSHOT_APPLY_COMPLETE,\n+                        new LogReplicationEventMetadata(transitionEventId, baseSnapshotTimestamp, baseSnapshotTimestamp)));\n+            } else {\n+                log.debug(\"Snapshot sync apply is still in progress, appliedTs={}, baseTs={}, sync_id={}\", metadataResponse.getSnapshotApplied(),\n+                        baseSnapshotTimestamp, transitionEventId);\n+                // Schedule a one time action which will verify the snapshot apply status after a given delay\n+                this.snapshotSyncApplyMonitorExecutor.schedule(this::scheduleSnapshotApplyVerification, SCHEDULE_APPLY_MONITOR_DELAY,\n+                        TimeUnit.MILLISECONDS);\n+            }\n+        } catch (TimeoutException te) {\n+            log.error(\"Snapshot sync apply verification timed out.\", te);\n+        } catch (ExecutionException ee) {\n+            // Completable future completed exceptionally\n+            log.error(\"Snapshot sync apply verification failed.\", ee);\n+        } catch (Exception e) {\n+            log.error(\"Snapshot sync apply verification failed.\", e);\n+        }", "originalCommit": "f061f089f97b1ddef3980dfad202ed627a5753b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0MzczMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481543730", "bodyText": "mmm, you're right we should re-schedule also on any exception:\nthis.snapshotSyncApplyMonitorExecutor.schedule(this::scheduleSnapshotApplyVerification, SCHEDULE_APPLY_MONITOR_DELAY,\nTimeUnit.MILLISECONDS);\nI'm not sure if on an unknown exception we should start snapshot sync again.", "author": "annym", "createdAt": "2020-09-02T01:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMjQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU1MDI2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r481550260", "bodyText": "I'm writing a test to be sure we cover these cases.", "author": "annym", "createdAt": "2020-09-02T02:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMjQ0Ng=="}], "type": "inlineReview"}, {"oid": "0ce9bddf8ea7f8fc41485b2afc6c77f0971f8fd5", "url": "https://github.com/CorfuDB/CorfuDB/commit/0ce9bddf8ea7f8fc41485b2afc6c77f0971f8fd5", "message": "Two-Phase Snapshot Sync\n\n    - 2-phase snapshot sync: transfer and apply phases", "committedDate": "2020-09-02T08:04:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3MDI3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482270271", "bodyText": "ts <= persistedTopologyConfigId or persistedSnapshotStart", "author": "zhangn49", "createdAt": "2020-09-02T18:14:40Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -251,73 +258,69 @@ public boolean setSrcBaseSnapshotStart(long topologyConfigId, long ts) {\n                         \"persistedSnapshotStart={}\",\n                 topologyConfigId, ts, persistedTopologyConfigID, persistSnapStart);\n \n-        return (ts == getLastSnapStartTimestamp() && topologyConfigId == getTopologyConfigId());\n+        return (ts == getLastStartedSnapshotTimestamp() && topologyConfigId == getTopologyConfigId());\n     }\n \n \n     /**\n-     * This call should be done in a transaction after a transfer done and before apply the snapshot.\n-     * @param ts\n+     * This call should be done in a transaction after a snapshot transfer is complete and before the apply starts.\n+     *\n+     * @param topologyConfigId current topology config identifier\n+     * @param ts timestamp of completed snapshot sync transfer\n      */\n-    public void setLastSnapTransferDoneTimestamp(long topologyConfigId, long ts) {\n+    public void setLastSnapshotTransferCompleteTimestamp(long topologyConfigId, long ts) {\n         CorfuStoreMetadata.Timestamp timestamp = corfuStore.getTimestamp();\n         long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n-        long persistSnapStart = query(timestamp, LogReplicationMetadataType.LAST_SNAPSHOT_STARTED);\n+        long persistedSnapshotStart = query(timestamp, LogReplicationMetadataType.LAST_SNAPSHOT_STARTED);\n \n         log.debug(\"setLastSnapTransferDone snapshotStart topologyConfigId={}, ts={}, persistedTopologyConfigID={},\" +\n                 \" persistedSiteConfigID={}, persistedSnapshotStart={}\", topologyConfigId, ts, persistedTopologyConfigId,\n-                persistSnapStart);\n+                persistedSnapshotStart);\n \n         // It means the cluster config has changed, ignore the update operation.\n         if (topologyConfigId != persistedTopologyConfigId || ts <= persistedTopologyConfigId) {", "originalCommit": "0ce9bddf8ea7f8fc41485b2afc6c77f0971f8fd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ3NzA3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482477071", "bodyText": "it should, and I think it should only be < because equals is the target..", "author": "annym", "createdAt": "2020-09-02T21:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3MDI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3MTUzMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482271530", "bodyText": "need to remove persistedSiteConfigID={}", "author": "zhangn49", "createdAt": "2020-09-02T18:16:54Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -251,73 +258,69 @@ public boolean setSrcBaseSnapshotStart(long topologyConfigId, long ts) {\n                         \"persistedSnapshotStart={}\",\n                 topologyConfigId, ts, persistedTopologyConfigID, persistSnapStart);\n \n-        return (ts == getLastSnapStartTimestamp() && topologyConfigId == getTopologyConfigId());\n+        return (ts == getLastStartedSnapshotTimestamp() && topologyConfigId == getTopologyConfigId());\n     }\n \n \n     /**\n-     * This call should be done in a transaction after a transfer done and before apply the snapshot.\n-     * @param ts\n+     * This call should be done in a transaction after a snapshot transfer is complete and before the apply starts.\n+     *\n+     * @param topologyConfigId current topology config identifier\n+     * @param ts timestamp of completed snapshot sync transfer\n      */\n-    public void setLastSnapTransferDoneTimestamp(long topologyConfigId, long ts) {\n+    public void setLastSnapshotTransferCompleteTimestamp(long topologyConfigId, long ts) {\n         CorfuStoreMetadata.Timestamp timestamp = corfuStore.getTimestamp();\n         long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n-        long persistSnapStart = query(timestamp, LogReplicationMetadataType.LAST_SNAPSHOT_STARTED);\n+        long persistedSnapshotStart = query(timestamp, LogReplicationMetadataType.LAST_SNAPSHOT_STARTED);\n \n         log.debug(\"setLastSnapTransferDone snapshotStart topologyConfigId={}, ts={}, persistedTopologyConfigID={},\" +\n                 \" persistedSiteConfigID={}, persistedSnapshotStart={}\", topologyConfigId, ts, persistedTopologyConfigId,\n-                persistSnapStart);\n+                persistedSnapshotStart);", "originalCommit": "0ce9bddf8ea7f8fc41485b2afc6c77f0971f8fd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMzMzE2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482333163", "bodyText": "Why we need to update topologyConfigId here?", "author": "zhangn49", "createdAt": "2020-09-02T19:24:00Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -403,17 +412,39 @@ private void processSnapshotMessage(LogReplicationEntry message) {\n                 snapshotWriter.apply(message);\n                 break;\n             case SNAPSHOT_END:\n-                setDataConsistent(false);\n-                snapshotWriter.snapshotTransferDone(message);\n-                completeSnapshotApply(message);\n-                setDataConsistent(true);\n+                if (snapshotWriter.getPhase() != StreamsSnapshotWriter.Phase.APPLY_PHASE) {\n+                    // Mark Snapshot Sync Transfer as complete and return ACK right away\n+                    completeSnapshotTransfer(message);\n+                    startSnapshotApplyAsync(message);\n+                }\n                 break;\n             default:\n-                log.warn(\"Message type {} should not be applied as snapshot sync.\", message.getMetadata().getMessageMetadataType());\n+                log.warn(\"Message type {} should not be applied during snapshot sync.\", message.getMetadata().getMessageMetadataType());\n                 break;\n         }\n     }\n \n+    private void startSnapshotApplyAsync(LogReplicationEntry entry) {\n+        applyExecutor.submit(() -> startSnapshotApply(entry));\n+    }\n+\n+    private void startSnapshotApply(LogReplicationEntry entry) {\n+        log.debug(\"OnEntry :: Snapshot Sync apply, id={}\", entry.getMetadata().getSyncRequestId());\n+        setDataConsistent(false);\n+        snapshotWriter.startSnapshotSyncApply();\n+        completeSnapshotApply(entry);\n+        setDataConsistent(true);\n+        log.debug(\"OnExit :: Snapshot Sync apply, id={}\", entry.getMetadata().getSyncRequestId());\n+    }\n+\n+    private void completeSnapshotTransfer(LogReplicationEntry message) {\n+        topologyConfigId = message.getMetadata().getTopologyConfigId();", "originalCommit": "0ce9bddf8ea7f8fc41485b2afc6c77f0971f8fd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ4ODc3MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482488770", "bodyText": "I copy/paste the old code, but I don't really think that is needed, removing it.", "author": "annym", "createdAt": "2020-09-02T21:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMzMzE2Mw=="}], "type": "inlineReview"}, {"oid": "90316aa9b32672d3159c7aabe510b7af8bba2d97", "url": "https://github.com/CorfuDB/CorfuDB/commit/90316aa9b32672d3159c7aabe510b7af8bba2d97", "message": "Additional changes for 2-phased snapshot sync", "committedDate": "2020-09-02T21:27:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzMTUyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482531527", "bodyText": "Should add break at the above line.", "author": "xiaoqin2012", "createdAt": "2020-09-02T22:19:59Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/InLogEntrySyncState.java", "diffHunk": "@@ -89,9 +99,9 @@ public LogReplicationState processEvent(LogReplicationEvent event) throws Illega\n             default: {", "originalCommit": "90316aa9b32672d3159c7aabe510b7af8bba2d97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzMjY3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482532676", "bodyText": "Just one variable is need for the log.", "author": "xiaoqin2012", "createdAt": "2020-09-02T22:21:18Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/InSnapshotSyncState.java", "diffHunk": "@@ -82,13 +82,21 @@ public LogReplicationState processEvent(LogReplicationEvent event) throws Illega\n                  batch of updates for the current snapshot sync.\n                  */\n                 if (event.getMetadata().getRequestId() == transitionEventId) {\n-                    log.debug(\"InSnapshotSync[{}] :: Continuation of snapshot sync for {}\", this, event.getEventID());\n+                    log.debug(\"InSnapshotSync :: Continuation of snapshot sync for {}\", transitionEventId, event.getEventID());", "originalCommit": "90316aa9b32672d3159c7aabe510b7af8bba2d97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzNzE3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482537178", "bodyText": "Why do there are two places to need to setup fsm.setBaseSnapshot, and fsm.setAckedTimestamp?", "author": "xiaoqin2012", "createdAt": "2020-09-02T22:25:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/InitializedState.java", "diffHunk": "@@ -33,19 +33,28 @@ public InitializedState(LogReplicationFSM logReplicationFSM) {\n     public LogReplicationState processEvent(LogReplicationEvent event) throws IllegalTransitionException {\n         switch (event.getType()) {\n             case SNAPSHOT_SYNC_REQUEST:\n-            case SNAPSHOT_WAIT_COMPLETE:\n                 log.info(\"Start Snapshot Sync, requestId={}\", event.getEventID());\n                 // Set the id of the event that caused the transition to the new state\n                 // This is used to correlate trim or error events that derive from this state\n                 LogReplicationState snapshotSyncState = fsm.getStates().get(LogReplicationStateType.IN_SNAPSHOT_SYNC);\n                 snapshotSyncState.setTransitionEventId(event.getEventID());\n                 return snapshotSyncState;\n-            case REPLICATION_START:\n+            case SNAPSHOT_TRANSFER_COMPLETE:\n+                log.info(\"Snapshot Sync transfer completed. Wait for snapshot apply to complete.\");\n+                WaitSnapshotApplyState waitSnapshotApplyState = (WaitSnapshotApplyState)fsm.getStates().get(LogReplicationStateType.WAIT_SNAPSHOT_APPLY);\n+                waitSnapshotApplyState.setTransitionEventId(event.getEventID());\n+                waitSnapshotApplyState.setBaseSnapshotTimestamp(fsm.getBaseSnapshot());\n+                fsm.setBaseSnapshot(event.getMetadata().getLastTransferredBaseSnapshot());\n+                fsm.setAckedTimestamp(event.getMetadata().getLastLogEntrySyncedTimestamp());\n+                return waitSnapshotApplyState;\n+            case LOG_ENTRY_SYNC_REQUEST:\n                 log.info(\"Start Log Entry Sync, requestId={}\", event.getEventID());\n                 // Set the id of the event that caused the transition to the new state\n                 // This is used to correlate trim or error events that derive from this state\n                 LogReplicationState logEntrySyncState = fsm.getStates().get(LogReplicationStateType.IN_LOG_ENTRY_SYNC);\n                 logEntrySyncState.setTransitionEventId(event.getEventID());\n+                fsm.setBaseSnapshot(event.getMetadata().getLastTransferredBaseSnapshot());", "originalCommit": "90316aa9b32672d3159c7aabe510b7af8bba2d97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYyMzg5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482623895", "bodyText": "Both are local variables in the FSM with different meaning. This is set when there is a transition from Initialized directly to Log Entry Sync, the first one indicates the latest base snapshot that was synced, the second the last log entry that was synced. And most likely if this is a continued log entry sync, these 2 values are different.", "author": "annym", "createdAt": "2020-09-03T00:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzNzE3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYyODE1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482628155", "bodyText": "I don't mean the two variables. I mean in the above case SNAPSHOT_TRANSFER_COMPLETE and the current case LOG_ENTRY_SYNC_REQUEST, they both setBaseSnapshot? Why do you need to setBaseSnapshot in two places?", "author": "xiaoqin2012", "createdAt": "2020-09-03T00:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzNzE3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzMjA3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482632073", "bodyText": "They are two different events which can happen independently. In the SNAPSHOT_TRANSFER_COMPLETE case, you're just starting and negotiation determines that the data is already transferred (therefore you need to reset/set the base snapshot to the one that represents the baseSnapshot of the ongoing snapshot sync). And in the second case, negotiation determined you can continue with log entry sync, you also initialize the values you just got to be aware of during negotiation.", "author": "annym", "createdAt": "2020-09-03T01:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzNzE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU3NzYyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482577628", "bodyText": "How  IN_SNAPSHOT_SYNC get a SNAPSHOT_REQUEST or SNAPSHOT_CANCEL and go to WAIT_SNAPSHOT_APPLY ?", "author": "xiaoqin2012", "createdAt": "2020-09-02T22:58:21Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/LogReplicationFSM.java", "diffHunk": "@@ -39,64 +40,84 @@\n  * communication channels.\n  *\n  * Log Replication on the source cluster is defined by an event-driven finite state machine, with 5 states\n- * and 8 events/messages---which can trigger the transition between states.\n+ * and 10 events/messages---which can trigger the transition between states.\n  *\n  * States:\n  * ------\n  *  - Initialized (initial state)\n  *  - In_Log_Entry_Sync\n  *  - In_Snapshot_Sync\n- *  - Snapshot_Sync_Required\n+ *  - Wait_Snapshot_Apply\n  *  - Stopped\n  *\n  * Events:\n  * ------\n- *  - replication_start\n- *  - replication_stop\n  *  - snapshot_sync_request\n- *  - snapshot_sync_complete\n  *  - snapshot_sync_continue\n+ *  - snapshot_transfer_complete\n+ *  - snapshot_apply_in_progress\n+ *  - snapshot_apply_complete\n+ *  - log_entry_sync_request\n+ *  - log_entry_sync_continue\n  *  - sync_cancel\n- *  - log_entry_sync_replicated\n+ *  - replication_stop\n  *  - replication_shutdown\n  *\n  *\n  * The following diagram illustrates the Log Replication FSM state transition:\n  *\n  *\n- *                                       replication_stop\n- *                      +-------------------------------------------------+\n- *    replication_stop  |                                                 |\n- *             +-----+  |              replication_stop                   |\n- *             |     |  v      v-----------------------------+            |\n- *             |    ++--+---------+                          |        +---+--------------------+\n- *             +--->+ INITIALIZED +------------------------+ |        | SNAPSHOT_SYNC_REQUIRED +<---+\n- *                  +---+----+----+ snapshot_sync_request  | |        +---+---------------+----+    |\n- *                      ^    |                             | |            |               ^         |\n- *                      |    |                             | |   snapshot |               |         |\n- *                      |    |                             | |    sync    |               |         |\n- *     replication_stop |    | replication_start           | |    request |               |         |\n- *                      |    |                             | |            |               |         |\n- *                      |    v                             v |            v               |         |\n- *               +------+----+-------+  snapshot_sync    +-+-+------------+-+             |         |\n- *         +-----| IN_LOG_ENTRY_SYNC |     request       | IN_SNAPSHOT_SYNC +             |         |\n- *         |     |                   +------------------>+                  |             |         |\n- *         |     +----+----+---------+                   +---+---+----------+-------------+         |\n- *         |       ^  |   ^                                 |    |        ^        sync             |\n- *         |       |  |   +---------------------------------+    |        |       cancel            |\n- *         + ----- +  |                snapshot_sync             + -------+                         |\n- *  log_entry_sync    |                  complete               snapshot_sync                       |\n- *    continue        |                                           continue                          |\n- *                    +-----------------------------------------------------------------------------+\n- *                                                     sync_cancel\n- *               replication\n- * +---------+    shutdown    +------------+\n- * | STOPPED +<---------------+ ALL_STATES |\n- * +---------+                +------------+\n+ *\n+ *                                          REPLICATION_STOP\n+ *                                              +------+\n+ *                                              |      |\n+ *                                              |      |\n+ *                LOG_ENTRY_SYNC_REQUEST   +----+------v-----+    SNAPSHOT_SYNC_REQUEST\n+ *             +---------------------------+   INITIALIZED   +-----------------------------+\n+ *             |                           +-^---^--+------^-+                             |\n+ *             |                             |   |  |      |                               |\n+ *             |                             |   |  |      |                               |\n+ *             |                             |   |  |      |                               |\n+ *             |                             |   |  |      |                               |\n+ *             |                             |   |  |      |                               |\n+ *             |                             |   |  |      |                               |     SYNC\n+ *             |                             |   |  |      |                               |    CANCEL\n+ *             |                             |   |  |      |                               |   +------+\n+ *             |                             |   |  |      |                               |   |      |\n+ *             |                             |   |  |      |                               |   |      |\n+ * +-----------v-----------+   REPLICATION   |   |  |      |   REPLICATION     +-----------v---+------v--+\n+ * |   IN_LOG_ENTRY_SYNC   +------STOP-------+   |  |      +------STOP---------+    IN_SNAPSHOT_SYNC     |\n+ * +----+-----^---+------^-+                     |  |                          +-^-----+---^-----+-----^-+\n+ *      |     |   |      |                       |  |                            |     |   |     |     |\n+ *      |     |   |      |                       |  |                            |     |   |     |     |\n+ *      |     |   +------+           REPLICATION |  | SNAPSHOT_TRANSFER          +-----+   |     |     |\n+ *      |     |   LOG_ENTRY              STOP    |  |      COMPLETE              SNAPSHOT  |     |     |\n+ *      |     | SYNC_CONTINUE                    |  |                              SYNC    |     |     |\n+ *      |     |                                  |  |                            CONTINUE  |     |     |\n+ *      |     |                                  |  |                                      |     |     |\n+ *      |     |                                  |  |                                      |     |     |\n+ *      |     |                                  |  |                                      |     |     |\n+ *      |     |                         +--------+--v-------------+  SNAPSHOT_SYNC_REQUEST |     |     |\n+ *      |     +-----SNAPSHOT_APPLY------+   WAIT_SNAPSHOT_APPLY   +------------------------+     |     |\n+ *      |              COMPLETE         +-^----+---^--------------+       SYNC_CANCEL            |     |\n+ *      |                                 |    |   |                                             |     |\n+ *      |                                 |    |   +-----------SNAPSHOT_TRANSFER_COMPLETE--------+     |\n+ *      |                                 +----+                                                       |\n+ *      |                             SNAPSHOT_APPLY                                                   |\n+ *      |                               IN_PROGRESS                                                    |\n+ *      |                                                                                              |\n+ *      +----------------------------------------SYNC_CANCEL-------------------------------------------+\n+ *                                          SNAPSHOT_SYNC_REQUEST\n+ *\n+ *\n+ *\n+ *\n+ *     +-------------+\n+ *     |   STOPPED   <-----REPLICATION-----  ALL_STATES\n+ *     +-------------+       SHUTDOWN", "originalCommit": "90316aa9b32672d3159c7aabe510b7af8bba2d97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYyMzA5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482623094", "bodyText": "I'm not sure I understand the question. The only event that takes us from IN_SNAPSHOT_SYNC to WAIT_SNAPSHOT_APPLY is SNAPSHOT_TRANSFER_COMPLETE, which is achieved when the ACK of type snapshot_transfer_complete is received.", "author": "annym", "createdAt": "2020-09-03T00:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU3NzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYyNjIwOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482626209", "bodyText": "The diagram shows that is  link from IN_SNAPSHOT_SYNC to WAIT_SNAPSHOT_APPLY with mark of  SNAPSHOT_REQUEST or SNAPSHOT_CANCEL.", "author": "xiaoqin2012", "createdAt": "2020-09-03T00:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU3NzYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzMDg5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482630892", "bodyText": "The arrow is in the other direction from WAIT_SNAPSHOT_APPLY to IN_SNAPSHOT_SYNC, in case a new request comes in...", "author": "annym", "createdAt": "2020-09-03T00:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU3NzYyOA=="}], "type": "inlineReview"}, {"oid": "8de9bdb9c1972ce036bb7834e7b1e29e64093f5e", "url": "https://github.com/CorfuDB/CorfuDB/commit/8de9bdb9c1972ce036bb7834e7b1e29e64093f5e", "message": "Two-Phase Snapshot Sync\n\n     Separate snapshot sync in two stages: transfer and apply stages.", "committedDate": "2020-09-03T03:29:33Z", "type": "forcePushed"}, {"oid": "386fc147f9d5fabbbdead1038ce5f23393283188", "url": "https://github.com/CorfuDB/CorfuDB/commit/386fc147f9d5fabbbdead1038ce5f23393283188", "message": "Two-Phase Snapshot Sync\n\n     Separate snapshot sync in two stages: transfer and apply stages.", "committedDate": "2020-09-03T03:36:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4MzEzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482683137", "bodyText": "Codacy found an issue: Avoid unused imports such as 'org.corfudb.protocols.wireprotocol.logreplication.MessageType'", "author": "corfudb-bot", "createdAt": "2020-09-03T03:36:26Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/runtime/LogReplicationClientRouter.java", "diffHunk": "@@ -8,9 +8,12 @@\n import org.corfudb.infrastructure.logreplication.infrastructure.plugins.LogReplicationPluginConfig;\n import org.corfudb.infrastructure.logreplication.infrastructure.ClusterDescriptor;\n import org.corfudb.infrastructure.logreplication.runtime.fsm.LogReplicationRuntimeEvent;\n+import org.corfudb.infrastructure.logreplication.runtime.fsm.LogReplicationRuntimeEvent.LogReplicationRuntimeEventType;\n import org.corfudb.infrastructure.logreplication.utils.CorfuMessageConverterUtils;\n import org.corfudb.protocols.wireprotocol.CorfuMsg;\n import org.corfudb.protocols.wireprotocol.CorfuMsgType;\n+import org.corfudb.protocols.wireprotocol.logreplication.LogReplicationEntry;\n+import org.corfudb.protocols.wireprotocol.logreplication.MessageType;", "originalCommit": "8de9bdb9c1972ce036bb7834e7b1e29e64093f5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f029fcd3b49eeb157f4aaf2f7c77b353b539d097", "url": "https://github.com/CorfuDB/CorfuDB/commit/f029fcd3b49eeb157f4aaf2f7c77b353b539d097", "message": "Two-Phase Snapshot Sync\n\n     Separate snapshot sync in two stages: transfer and apply stages.", "committedDate": "2020-09-03T04:17:43Z", "type": "forcePushed"}, {"oid": "7b6067137d81cc1da2e34d748ca3caef266a9314", "url": "https://github.com/CorfuDB/CorfuDB/commit/7b6067137d81cc1da2e34d748ca3caef266a9314", "message": "Two-Phase Snapshot Sync\n\n     Separate snapshot sync in two stages: transfer and apply stages.", "committedDate": "2020-09-03T04:53:27Z", "type": "commit"}, {"oid": "7b6067137d81cc1da2e34d748ca3caef266a9314", "url": "https://github.com/CorfuDB/CorfuDB/commit/7b6067137d81cc1da2e34d748ca3caef266a9314", "message": "Two-Phase Snapshot Sync\n\n     Separate snapshot sync in two stages: transfer and apply stages.", "committedDate": "2020-09-03T04:53:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcwNDUwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482704507", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "corfudb-bot", "createdAt": "2020-09-03T04:58:35Z", "path": "test/src/test/java/org/corfudb/integration/LogReplicationIT.java", "diffHunk": "@@ -1038,6 +986,80 @@ public void testLogEntrySyncLargeTables() throws Exception {\n         cleanEnv();\n     }\n \n+    /**\n+     * Test the case where a Snapshot Sync apply phase takes several cycles to complete.\n+     * We need to ensure the Sender re-schedules verification of snapshot sync status and\n+     * once completed moves onto Log Entry Sync.\n+     */\n+    @Test\n+    public void testSnapshotSyncLongDurationApply() throws Exception {", "originalCommit": "7b6067137d81cc1da2e34d748ca3caef266a9314", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcwNDUxMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2739#discussion_r482704510", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "corfudb-bot", "createdAt": "2020-09-03T04:58:36Z", "path": "test/src/test/java/org/corfudb/integration/LogReplicationIT.java", "diffHunk": "@@ -1038,6 +986,80 @@ public void testLogEntrySyncLargeTables() throws Exception {\n         cleanEnv();\n     }\n \n+    /**\n+     * Test the case where a Snapshot Sync apply phase takes several cycles to complete.\n+     * We need to ensure the Sender re-schedules verification of snapshot sync status and\n+     * once completed moves onto Log Entry Sync.\n+     */\n+    @Test\n+    public void testSnapshotSyncLongDurationApply() throws Exception {\n+        final int numCyclesToDelayApply = 3;\n+        testSnapshotSyncAndLogEntrySync(numCyclesToDelayApply, false);\n+    }\n+\n+    /**\n+     * Test the case where a Snapshot Sync apply metadata response is delayed causing TimeoutExceptions.\n+     * Verify we are able to recover.\n+     */\n+    @Test\n+    public void testSnapshotSyncDelayedApplyResponse() throws Exception {", "originalCommit": "7b6067137d81cc1da2e34d748ca3caef266a9314", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}