{"pr_number": 2375, "pr_title": "Implementation StreamSnapshotWriter, StreamLogEntryReader/Writer.", "pr_createdAt": "2020-02-06T23:09:30Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2375", "timeline": [{"oid": "6d34b0d90766892391aa11c866b15f1f8104b82a", "url": "https://github.com/CorfuDB/CorfuDB/commit/6d34b0d90766892391aa11c866b15f1f8104b82a", "message": "Implementation of StreamSnapshotReader with Opaquestream.", "committedDate": "2020-02-06T17:55:56Z", "type": "commit"}, {"oid": "f7904a5db8c66cc84ff55db031f6e2a4552a706d", "url": "https://github.com/CorfuDB/CorfuDB/commit/f7904a5db8c66cc84ff55db031f6e2a4552a706d", "message": "Merge branch 'federation' into xq/fed04", "committedDate": "2020-02-06T17:58:03Z", "type": "commit"}, {"oid": "4cc03971baf7b5b6e2c71230fe796ec82e1fe925", "url": "https://github.com/CorfuDB/CorfuDB/commit/4cc03971baf7b5b6e2c71230fe796ec82e1fe925", "message": "Implementation StreamSnapshotWriter, StreamLogEntryReader, StreamLogEntryWriter.", "committedDate": "2020-02-06T23:07:21Z", "type": "commit"}, {"oid": "24386ba1c47876f74619ffb1a8145bd7f016a056", "url": "https://github.com/CorfuDB/CorfuDB/commit/24386ba1c47876f74619ffb1a8145bd7f016a056", "message": "Some code cleanup.", "committedDate": "2020-02-07T00:06:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1NjgyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376156820", "bodyText": "do you mean fullsync stream ?", "author": "medhavidhawan", "createdAt": "2020-02-07T00:27:15Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/MessageMetadata.java", "diffHunk": "@@ -1,41 +1,42 @@\n package org.corfudb.logreplication;\n \n+import lombok.Data;\n import lombok.Getter;\n-\n+@Data\n public class MessageMetadata {\n     /*\n      * Used to determine the type of the metadata:\n      * - snapshot type for reading/writing the snapshot timestamp,\n      * - log entry type for reading/writing the entry and previous entry timestamps,\n      */\n-    @Getter\n     private MessageType messageMetadataType;\n \n     /*\n      * From Tx -> Rx: timestamp of the entry enqueued for shipping\n      * From Rx -> Tx: timestamp of the entry applied on the receiving side\n      */\n-    @Getter\n     public long entryTimeStamp;\n+    //for full sync when the entryTimeStamp == snapshotTimestamp, it means the end of the stream.\n \n     /*\n      * Used to chain sparse entries for ordering\n      */\n-    @Getter\n     private long previousEntryTimestamp;\n \n     /*\n      * Used to keep track of the time used for snapshots.\n      * Read by the log entry shipper to determine which point to read the log from.\n      */\n-    @Getter\n     private long snapshotTimestamp;\n \n-    public MessageMetadata(MessageType type, long entryTimeStamp, long previousEntryTimestamp, long snapshotTimestamp) {\n+    private long fullSyncSeqNum; //used by fullsync only, zero means the start of the stream.", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1NjkwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376156906", "bodyText": "please rename it to snapshotSyncSeqNum", "author": "medhavidhawan", "createdAt": "2020-02-07T00:27:38Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/MessageMetadata.java", "diffHunk": "@@ -1,41 +1,42 @@\n package org.corfudb.logreplication;\n \n+import lombok.Data;\n import lombok.Getter;\n-\n+@Data\n public class MessageMetadata {\n     /*\n      * Used to determine the type of the metadata:\n      * - snapshot type for reading/writing the snapshot timestamp,\n      * - log entry type for reading/writing the entry and previous entry timestamps,\n      */\n-    @Getter\n     private MessageType messageMetadataType;\n \n     /*\n      * From Tx -> Rx: timestamp of the entry enqueued for shipping\n      * From Rx -> Tx: timestamp of the entry applied on the receiving side\n      */\n-    @Getter\n     public long entryTimeStamp;\n+    //for full sync when the entryTimeStamp == snapshotTimestamp, it means the end of the stream.\n \n     /*\n      * Used to chain sparse entries for ordering\n      */\n-    @Getter\n     private long previousEntryTimestamp;\n \n     /*\n      * Used to keep track of the time used for snapshots.\n      * Read by the log entry shipper to determine which point to read the log from.\n      */\n-    @Getter\n     private long snapshotTimestamp;\n \n-    public MessageMetadata(MessageType type, long entryTimeStamp, long previousEntryTimestamp, long snapshotTimestamp) {\n+    private long fullSyncSeqNum; //used by fullsync only, zero means the start of the stream.", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1NzM0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376157341", "bodyText": "comments at class level as to what this class does.", "author": "medhavidhawan", "createdAt": "2020-02-07T00:29:22Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsLogEntryReader.java", "diffHunk": "@@ -1,67 +1,108 @@\n package org.corfudb.logreplication.transmitter;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageType;\n import org.corfudb.logreplication.fsm.LogReplicationConfig;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.view.ObjectsView;\n import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n \n-import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n \n @Slf4j\n+@NotThreadSafe", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1NzU0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376157544", "bodyText": "please add comments for each member variable, what it means and how it is used.", "author": "medhavidhawan", "createdAt": "2020-02-07T00:30:14Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsLogEntryReader.java", "diffHunk": "@@ -1,67 +1,108 @@\n package org.corfudb.logreplication.transmitter;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageType;\n import org.corfudb.logreplication.fsm.LogReplicationConfig;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.view.ObjectsView;\n import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n \n-import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n \n @Slf4j\n+@NotThreadSafe\n public class StreamsLogEntryReader implements LogEntryReader {\n-    private IStreamView stream;\n-    private long globalBaseSnapshot;\n     private CorfuRuntime rt;", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1ODYxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376158618", "bodyText": "maybe this can be folded into the constructor and then you can get rid of streams ?", "author": "medhavidhawan", "createdAt": "2020-02-07T00:34:13Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsLogEntryReader.java", "diffHunk": "@@ -1,67 +1,108 @@\n package org.corfudb.logreplication.transmitter;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageType;\n import org.corfudb.logreplication.fsm.LogReplicationConfig;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.view.ObjectsView;\n import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n \n-import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n \n @Slf4j\n+@NotThreadSafe\n public class StreamsLogEntryReader implements LogEntryReader {\n-    private IStreamView stream;\n-    private long globalBaseSnapshot;\n     private CorfuRuntime rt;\n     private final MessageType MSG_TYPE = MessageType.LOG_ENTRY_MESSAGE;\n+    private OpaqueStream txStream;\n+    private long globalBaseSnapshot;\n     private long preMsgTs;\n     private long currentMsgTs;\n+    private long sequence;\n+    private Set<String> streams;\n+    private Set<UUID> streamUUIDs;\n+\n+    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n+        this.rt = runtime;\n+        streams = config.getStreamsToReplicate();\n+        initStream();\n+    }\n \n     void initStream() {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1ODczMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376158731", "bodyText": "please add a comment here as to what you are pulling.", "author": "medhavidhawan", "createdAt": "2020-02-07T00:34:38Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsLogEntryReader.java", "diffHunk": "@@ -1,67 +1,108 @@\n package org.corfudb.logreplication.transmitter;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageType;\n import org.corfudb.logreplication.fsm.LogReplicationConfig;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.view.ObjectsView;\n import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n \n-import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n \n @Slf4j\n+@NotThreadSafe\n public class StreamsLogEntryReader implements LogEntryReader {\n-    private IStreamView stream;\n-    private long globalBaseSnapshot;\n     private CorfuRuntime rt;\n     private final MessageType MSG_TYPE = MessageType.LOG_ENTRY_MESSAGE;\n+    private OpaqueStream txStream;\n+    private long globalBaseSnapshot;\n     private long preMsgTs;\n     private long currentMsgTs;\n+    private long sequence;\n+    private Set<String> streams;\n+    private Set<UUID> streamUUIDs;\n+\n+    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n+        this.rt = runtime;\n+        streams = config.getStreamsToReplicate();\n+        initStream();\n+    }\n \n     void initStream() {\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n         StreamOptions options = StreamOptions.builder()\n                 .cacheEntries(false)\n                 .build();\n-        stream = rt.getStreamsView()\n-                .getUnsafe(ObjectsView.TRANSACTION_STREAM_ID, options);\n+        long tail = 0;\n+        txStream = new OpaqueStream(rt, rt.getStreamsView().get(ObjectsView.TRANSACTION_STREAM_ID));", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1ODgxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376158814", "bodyText": "seems like options and tail are not used anywhere ?", "author": "medhavidhawan", "createdAt": "2020-02-07T00:35:01Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsLogEntryReader.java", "diffHunk": "@@ -1,67 +1,108 @@\n package org.corfudb.logreplication.transmitter;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageType;\n import org.corfudb.logreplication.fsm.LogReplicationConfig;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.view.ObjectsView;\n import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n \n-import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n \n @Slf4j\n+@NotThreadSafe\n public class StreamsLogEntryReader implements LogEntryReader {\n-    private IStreamView stream;\n-    private long globalBaseSnapshot;\n     private CorfuRuntime rt;\n     private final MessageType MSG_TYPE = MessageType.LOG_ENTRY_MESSAGE;\n+    private OpaqueStream txStream;\n+    private long globalBaseSnapshot;\n     private long preMsgTs;\n     private long currentMsgTs;\n+    private long sequence;\n+    private Set<String> streams;\n+    private Set<UUID> streamUUIDs;\n+\n+    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n+        this.rt = runtime;\n+        streams = config.getStreamsToReplicate();\n+        initStream();\n+    }\n \n     void initStream() {\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n         StreamOptions options = StreamOptions.builder()", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MjA1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376162051", "bodyText": "use tmpUUIDs", "author": "medhavidhawan", "createdAt": "2020-02-07T00:46:38Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsLogEntryReader.java", "diffHunk": "@@ -1,67 +1,108 @@\n package org.corfudb.logreplication.transmitter;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageType;\n import org.corfudb.logreplication.fsm.LogReplicationConfig;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.view.ObjectsView;\n import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n \n-import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n \n @Slf4j\n+@NotThreadSafe\n public class StreamsLogEntryReader implements LogEntryReader {\n-    private IStreamView stream;\n-    private long globalBaseSnapshot;\n     private CorfuRuntime rt;\n     private final MessageType MSG_TYPE = MessageType.LOG_ENTRY_MESSAGE;\n+    private OpaqueStream txStream;\n+    private long globalBaseSnapshot;\n     private long preMsgTs;\n     private long currentMsgTs;\n+    private long sequence;\n+    private Set<String> streams;\n+    private Set<UUID> streamUUIDs;\n+\n+    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n+        this.rt = runtime;\n+        streams = config.getStreamsToReplicate();\n+        initStream();\n+    }\n \n     void initStream() {\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n         StreamOptions options = StreamOptions.builder()\n                 .cacheEntries(false)\n                 .build();\n-        stream = rt.getStreamsView()\n-                .getUnsafe(ObjectsView.TRANSACTION_STREAM_ID, options);\n+        long tail = 0;\n+        txStream = new OpaqueStream(rt, rt.getStreamsView().get(ObjectsView.TRANSACTION_STREAM_ID));\n     }\n \n-    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n-        this.rt = runtime;\n \n-        //initStream();\n-    }\n+    TxMessage generateMessage(OpaqueEntry entry) {\n+        ByteBuf buf = Unpooled.buffer();\n+        OpaqueEntry.serialize(buf, entry);\n \n-    //poll txnStream\n-    List<ILogData> poll(long start) {\n-        stream.seek(start);\n-        return stream.remaining();\n-    }\n-\n-    TxMessage generateMessage(ILogData entry) {\n-        currentMsgTs = entry.getGlobalAddress();\n-        TxMessage txMessage = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalBaseSnapshot);\n-        //set data with Maithem's new api\n+        currentMsgTs = entry.getVersion();\n+        TxMessage txMessage = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalBaseSnapshot, sequence, buf.array());\n         preMsgTs = currentMsgTs;\n+        sequence++;\n         return  txMessage;\n     }\n \n-    void nextMsgs(List<ILogData> inputs) {\n-        for (ILogData entry : inputs) {\n-            //((StreamsSnapshotReader)context.getSnapshotReader()).getSnapshotListener().onNext(generateMessage(entry));\n+    boolean shouldProcess(OpaqueEntry entry) throws Exception {\n+        Set<UUID> tmpUUIDs = entry.getEntries().keySet();\n+\n+        //If the entry's stream set is a subset of interested streams, it is the entry we should process\n+        if (streamUUIDs.containsAll(tmpUUIDs))\n+            return true;\n+\n+        //If the entry's stream set has no overlap with the interested streams, it should be skipped.\n+        tmpUUIDs.retainAll(streamUUIDs);\n+        if (tmpUUIDs.isEmpty())\n+            return false;\n+\n+        //If the entry's stream set contains both interested streams and other streams, it is not\n+        //the expected behavior\n+        log.error(\"There are noisy streams {} in the entry, expected streams set {}\",\n+                    entry.getEntries().keySet(), streamUUIDs);", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2NTkzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376165935", "bodyText": "we should make a specific exception", "author": "medhavidhawan", "createdAt": "2020-02-07T01:00:46Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsLogEntryReader.java", "diffHunk": "@@ -1,67 +1,108 @@\n package org.corfudb.logreplication.transmitter;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageType;\n import org.corfudb.logreplication.fsm.LogReplicationConfig;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.view.ObjectsView;\n import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n \n-import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n \n @Slf4j\n+@NotThreadSafe\n public class StreamsLogEntryReader implements LogEntryReader {\n-    private IStreamView stream;\n-    private long globalBaseSnapshot;\n     private CorfuRuntime rt;\n     private final MessageType MSG_TYPE = MessageType.LOG_ENTRY_MESSAGE;\n+    private OpaqueStream txStream;\n+    private long globalBaseSnapshot;\n     private long preMsgTs;\n     private long currentMsgTs;\n+    private long sequence;\n+    private Set<String> streams;\n+    private Set<UUID> streamUUIDs;\n+\n+    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n+        this.rt = runtime;\n+        streams = config.getStreamsToReplicate();\n+        initStream();\n+    }\n \n     void initStream() {\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n         StreamOptions options = StreamOptions.builder()\n                 .cacheEntries(false)\n                 .build();\n-        stream = rt.getStreamsView()\n-                .getUnsafe(ObjectsView.TRANSACTION_STREAM_ID, options);\n+        long tail = 0;\n+        txStream = new OpaqueStream(rt, rt.getStreamsView().get(ObjectsView.TRANSACTION_STREAM_ID));\n     }\n \n-    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n-        this.rt = runtime;\n \n-        //initStream();\n-    }\n+    TxMessage generateMessage(OpaqueEntry entry) {\n+        ByteBuf buf = Unpooled.buffer();\n+        OpaqueEntry.serialize(buf, entry);\n \n-    //poll txnStream\n-    List<ILogData> poll(long start) {\n-        stream.seek(start);\n-        return stream.remaining();\n-    }\n-\n-    TxMessage generateMessage(ILogData entry) {\n-        currentMsgTs = entry.getGlobalAddress();\n-        TxMessage txMessage = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalBaseSnapshot);\n-        //set data with Maithem's new api\n+        currentMsgTs = entry.getVersion();\n+        TxMessage txMessage = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalBaseSnapshot, sequence, buf.array());\n         preMsgTs = currentMsgTs;\n+        sequence++;\n         return  txMessage;\n     }\n \n-    void nextMsgs(List<ILogData> inputs) {\n-        for (ILogData entry : inputs) {\n-            //((StreamsSnapshotReader)context.getSnapshotReader()).getSnapshotListener().onNext(generateMessage(entry));\n+    boolean shouldProcess(OpaqueEntry entry) throws Exception {\n+        Set<UUID> tmpUUIDs = entry.getEntries().keySet();\n+\n+        //If the entry's stream set is a subset of interested streams, it is the entry we should process\n+        if (streamUUIDs.containsAll(tmpUUIDs))\n+            return true;\n+\n+        //If the entry's stream set has no overlap with the interested streams, it should be skipped.\n+        tmpUUIDs.retainAll(streamUUIDs);\n+        if (tmpUUIDs.isEmpty())\n+            return false;\n+\n+        //If the entry's stream set contains both interested streams and other streams, it is not\n+        //the expected behavior\n+        log.error(\"There are noisy streams {} in the entry, expected streams set {}\",\n+                    entry.getEntries().keySet(), streamUUIDs);\n+        throw new Exception(\"There are noisy streams\");", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2OTI2Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376169266", "bodyText": "rename accordingly to interface TxMessage read()", "author": "medhavidhawan", "createdAt": "2020-02-07T01:13:39Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsLogEntryReader.java", "diffHunk": "@@ -1,67 +1,108 @@\n package org.corfudb.logreplication.transmitter;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageType;\n import org.corfudb.logreplication.fsm.LogReplicationConfig;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.view.ObjectsView;\n import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n \n-import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n \n @Slf4j\n+@NotThreadSafe\n public class StreamsLogEntryReader implements LogEntryReader {\n-    private IStreamView stream;\n-    private long globalBaseSnapshot;\n     private CorfuRuntime rt;\n     private final MessageType MSG_TYPE = MessageType.LOG_ENTRY_MESSAGE;\n+    private OpaqueStream txStream;\n+    private long globalBaseSnapshot;\n     private long preMsgTs;\n     private long currentMsgTs;\n+    private long sequence;\n+    private Set<String> streams;\n+    private Set<UUID> streamUUIDs;\n+\n+    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n+        this.rt = runtime;\n+        streams = config.getStreamsToReplicate();\n+        initStream();\n+    }\n \n     void initStream() {\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n         StreamOptions options = StreamOptions.builder()\n                 .cacheEntries(false)\n                 .build();\n-        stream = rt.getStreamsView()\n-                .getUnsafe(ObjectsView.TRANSACTION_STREAM_ID, options);\n+        long tail = 0;\n+        txStream = new OpaqueStream(rt, rt.getStreamsView().get(ObjectsView.TRANSACTION_STREAM_ID));\n     }\n \n-    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n-        this.rt = runtime;\n \n-        //initStream();\n-    }\n+    TxMessage generateMessage(OpaqueEntry entry) {\n+        ByteBuf buf = Unpooled.buffer();\n+        OpaqueEntry.serialize(buf, entry);\n \n-    //poll txnStream\n-    List<ILogData> poll(long start) {\n-        stream.seek(start);\n-        return stream.remaining();\n-    }\n-\n-    TxMessage generateMessage(ILogData entry) {\n-        currentMsgTs = entry.getGlobalAddress();\n-        TxMessage txMessage = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalBaseSnapshot);\n-        //set data with Maithem's new api\n+        currentMsgTs = entry.getVersion();\n+        TxMessage txMessage = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalBaseSnapshot, sequence, buf.array());\n         preMsgTs = currentMsgTs;\n+        sequence++;\n         return  txMessage;\n     }\n \n-    void nextMsgs(List<ILogData> inputs) {\n-        for (ILogData entry : inputs) {\n-            //((StreamsSnapshotReader)context.getSnapshotReader()).getSnapshotListener().onNext(generateMessage(entry));\n+    boolean shouldProcess(OpaqueEntry entry) throws Exception {\n+        Set<UUID> tmpUUIDs = entry.getEntries().keySet();\n+\n+        //If the entry's stream set is a subset of interested streams, it is the entry we should process\n+        if (streamUUIDs.containsAll(tmpUUIDs))\n+            return true;\n+\n+        //If the entry's stream set has no overlap with the interested streams, it should be skipped.\n+        tmpUUIDs.retainAll(streamUUIDs);\n+        if (tmpUUIDs.isEmpty())\n+            return false;\n+\n+        //If the entry's stream set contains both interested streams and other streams, it is not\n+        //the expected behavior\n+        log.error(\"There are noisy streams {} in the entry, expected streams set {}\",\n+                    entry.getEntries().keySet(), streamUUIDs);\n+        throw new Exception(\"There are noisy streams\");\n+\n+    }\n+\n+    void nextMsgs() throws Exception {\n+        //txStream.seek(preMsgTs + 1);  we may no need to call seek every time\n+        long tail = rt.getAddressSpaceView().getLogTail();\n+        Stream stream = txStream.streamUpTo(tail); //this can throw trimmed exception\n+\n+        while(stream.iterator().hasNext()) {\n+            OpaqueEntry opaqueEntry = (OpaqueEntry)stream.iterator().next();\n+            if (!shouldProcess(opaqueEntry)) {\n+                continue;\n+            }\n+            TxMessage txMessage = generateMessage(opaqueEntry);\n+            //callback to send message\n         }\n     }\n \n-    public void resetGlobalBaseSnapshot(long snapshot) {\n+    public void setGlobalBaseSnapshot(long snapshot) {\n         globalBaseSnapshot = snapshot;\n         preMsgTs = snapshot;\n+        txStream.seek(snapshot + 1);\n+        sequence = 0;\n     }\n \n-    public void sync() {\n+    public void sync() throws Exception {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2OTk1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376169951", "bodyText": "returning the message here would mean you would lose other updates? also we should consider back-off if onNext is temp not working.", "author": "medhavidhawan", "createdAt": "2020-02-07T01:16:36Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsLogEntryReader.java", "diffHunk": "@@ -1,67 +1,108 @@\n package org.corfudb.logreplication.transmitter;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageType;\n import org.corfudb.logreplication.fsm.LogReplicationConfig;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.view.ObjectsView;\n import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n \n-import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n \n @Slf4j\n+@NotThreadSafe\n public class StreamsLogEntryReader implements LogEntryReader {\n-    private IStreamView stream;\n-    private long globalBaseSnapshot;\n     private CorfuRuntime rt;\n     private final MessageType MSG_TYPE = MessageType.LOG_ENTRY_MESSAGE;\n+    private OpaqueStream txStream;\n+    private long globalBaseSnapshot;\n     private long preMsgTs;\n     private long currentMsgTs;\n+    private long sequence;\n+    private Set<String> streams;\n+    private Set<UUID> streamUUIDs;\n+\n+    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n+        this.rt = runtime;\n+        streams = config.getStreamsToReplicate();\n+        initStream();\n+    }\n \n     void initStream() {\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n         StreamOptions options = StreamOptions.builder()\n                 .cacheEntries(false)\n                 .build();\n-        stream = rt.getStreamsView()\n-                .getUnsafe(ObjectsView.TRANSACTION_STREAM_ID, options);\n+        long tail = 0;\n+        txStream = new OpaqueStream(rt, rt.getStreamsView().get(ObjectsView.TRANSACTION_STREAM_ID));\n     }\n \n-    public StreamsLogEntryReader(CorfuRuntime runtime, LogReplicationConfig config) {\n-        this.rt = runtime;\n \n-        //initStream();\n-    }\n+    TxMessage generateMessage(OpaqueEntry entry) {\n+        ByteBuf buf = Unpooled.buffer();\n+        OpaqueEntry.serialize(buf, entry);\n \n-    //poll txnStream\n-    List<ILogData> poll(long start) {\n-        stream.seek(start);\n-        return stream.remaining();\n-    }\n-\n-    TxMessage generateMessage(ILogData entry) {\n-        currentMsgTs = entry.getGlobalAddress();\n-        TxMessage txMessage = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalBaseSnapshot);\n-        //set data with Maithem's new api\n+        currentMsgTs = entry.getVersion();\n+        TxMessage txMessage = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalBaseSnapshot, sequence, buf.array());\n         preMsgTs = currentMsgTs;\n+        sequence++;\n         return  txMessage;\n     }\n \n-    void nextMsgs(List<ILogData> inputs) {\n-        for (ILogData entry : inputs) {\n-            //((StreamsSnapshotReader)context.getSnapshotReader()).getSnapshotListener().onNext(generateMessage(entry));\n+    boolean shouldProcess(OpaqueEntry entry) throws Exception {\n+        Set<UUID> tmpUUIDs = entry.getEntries().keySet();\n+\n+        //If the entry's stream set is a subset of interested streams, it is the entry we should process\n+        if (streamUUIDs.containsAll(tmpUUIDs))\n+            return true;\n+\n+        //If the entry's stream set has no overlap with the interested streams, it should be skipped.\n+        tmpUUIDs.retainAll(streamUUIDs);\n+        if (tmpUUIDs.isEmpty())\n+            return false;\n+\n+        //If the entry's stream set contains both interested streams and other streams, it is not\n+        //the expected behavior\n+        log.error(\"There are noisy streams {} in the entry, expected streams set {}\",\n+                    entry.getEntries().keySet(), streamUUIDs);\n+        throw new Exception(\"There are noisy streams\");\n+\n+    }\n+\n+    void nextMsgs() throws Exception {\n+        //txStream.seek(preMsgTs + 1);  we may no need to call seek every time\n+        long tail = rt.getAddressSpaceView().getLogTail();\n+        Stream stream = txStream.streamUpTo(tail); //this can throw trimmed exception\n+\n+        while(stream.iterator().hasNext()) {\n+            OpaqueEntry opaqueEntry = (OpaqueEntry)stream.iterator().next();\n+            if (!shouldProcess(opaqueEntry)) {\n+                continue;\n+            }\n+            TxMessage txMessage = generateMessage(opaqueEntry);\n+            //callback to send message", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MDA5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376170090", "bodyText": "please add comments", "author": "medhavidhawan", "createdAt": "2020-02-07T01:17:14Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MDQ2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376170467", "bodyText": "add comments", "author": "medhavidhawan", "createdAt": "2020-02-07T01:18:50Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {\n+        //if it is the end of the stream, set an end of stream mark, the current\n+        List<SMREntry> list = new ArrayList<>();\n+        try {\n+            while (stream.iterator.hasNext() && list.size() < numEntries) {\n+                OpaqueEntry entry = (OpaqueEntry) stream.iterator.next();\n+                verify(stream, entry);\n+                stream.maxVersion = Math.max(stream.maxVersion, entry.getVersion());\n+                list.addAll(entry.getEntries().get(stream.uuid));\n+            }\n+        } catch (TrimmedException e) {\n+            log.error(\"Catch an TrimmedException exception \", e);\n         }\n-\n-        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", streamName, globalSnapshot);\n-        return;\n+        return list;\n     }\n \n     /**\n-     * while transmit finish put an event to the queue\n+     * Poll the current stream and get a batch of SMR entries and\n+     * generate one message\n+     * @param stream bookkeeping of the current stream information.\n+     * @return\n      */\n-    public void sync() {\n-        setup();\n-        try {\n-            for (String streamName : streams) {\n-                next(streamName);\n-            }\n-        } catch (Exception e) {\n-            //handle exception\n-            log.warn(\"Sync call get an exception \", e);\n-            throw e;\n-        }\n-\n-        //todo: update metadata to record a Snapshot Reader done\n-        log.info(\"Successfully do a transmit read for globalSnapshot {}\", globalSnapshot);\n+    TxMessage next(StreamInfo stream) {\n+        List<SMREntry> entries = next(stream, MAX_BATCH_SIZE);\n+        TxMessage txMsg = generateMessage(stream, entries);\n+        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", stream.name, globalSnapshot);\n+        return txMsg;\n     }\n \n     @Override\n     public SnapshotReadMessage read() {\n-        return null;\n+        if (currentStreamInfo == null || !currentStreamInfo.iterator.hasNext()) {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MDYyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376170625", "bodyText": "change -> streamsToSend", "author": "medhavidhawan", "createdAt": "2020-02-07T01:19:26Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {\n+        //if it is the end of the stream, set an end of stream mark, the current\n+        List<SMREntry> list = new ArrayList<>();\n+        try {\n+            while (stream.iterator.hasNext() && list.size() < numEntries) {\n+                OpaqueEntry entry = (OpaqueEntry) stream.iterator.next();\n+                verify(stream, entry);\n+                stream.maxVersion = Math.max(stream.maxVersion, entry.getVersion());\n+                list.addAll(entry.getEntries().get(stream.uuid));\n+            }\n+        } catch (TrimmedException e) {\n+            log.error(\"Catch an TrimmedException exception \", e);\n         }\n-\n-        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", streamName, globalSnapshot);\n-        return;\n+        return list;\n     }\n \n     /**\n-     * while transmit finish put an event to the queue\n+     * Poll the current stream and get a batch of SMR entries and\n+     * generate one message\n+     * @param stream bookkeeping of the current stream information.\n+     * @return\n      */\n-    public void sync() {\n-        setup();\n-        try {\n-            for (String streamName : streams) {\n-                next(streamName);\n-            }\n-        } catch (Exception e) {\n-            //handle exception\n-            log.warn(\"Sync call get an exception \", e);\n-            throw e;\n-        }\n-\n-        //todo: update metadata to record a Snapshot Reader done\n-        log.info(\"Successfully do a transmit read for globalSnapshot {}\", globalSnapshot);\n+    TxMessage next(StreamInfo stream) {\n+        List<SMREntry> entries = next(stream, MAX_BATCH_SIZE);\n+        TxMessage txMsg = generateMessage(stream, entries);\n+        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", stream.name, globalSnapshot);\n+        return txMsg;\n     }\n \n     @Override\n     public SnapshotReadMessage read() {\n-        return null;\n+        if (currentStreamInfo == null || !currentStreamInfo.iterator.hasNext()) {\n+            if (streamsToSent.isEmpty()) {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MDcxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376170714", "bodyText": "add comment indicating that the stream is over..", "author": "medhavidhawan", "createdAt": "2020-02-07T01:19:54Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {\n+        //if it is the end of the stream, set an end of stream mark, the current\n+        List<SMREntry> list = new ArrayList<>();\n+        try {\n+            while (stream.iterator.hasNext() && list.size() < numEntries) {\n+                OpaqueEntry entry = (OpaqueEntry) stream.iterator.next();\n+                verify(stream, entry);\n+                stream.maxVersion = Math.max(stream.maxVersion, entry.getVersion());\n+                list.addAll(entry.getEntries().get(stream.uuid));\n+            }\n+        } catch (TrimmedException e) {\n+            log.error(\"Catch an TrimmedException exception \", e);\n         }\n-\n-        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", streamName, globalSnapshot);\n-        return;\n+        return list;\n     }\n \n     /**\n-     * while transmit finish put an event to the queue\n+     * Poll the current stream and get a batch of SMR entries and\n+     * generate one message\n+     * @param stream bookkeeping of the current stream information.\n+     * @return\n      */\n-    public void sync() {\n-        setup();\n-        try {\n-            for (String streamName : streams) {\n-                next(streamName);\n-            }\n-        } catch (Exception e) {\n-            //handle exception\n-            log.warn(\"Sync call get an exception \", e);\n-            throw e;\n-        }\n-\n-        //todo: update metadata to record a Snapshot Reader done\n-        log.info(\"Successfully do a transmit read for globalSnapshot {}\", globalSnapshot);\n+    TxMessage next(StreamInfo stream) {\n+        List<SMREntry> entries = next(stream, MAX_BATCH_SIZE);\n+        TxMessage txMsg = generateMessage(stream, entries);\n+        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", stream.name, globalSnapshot);\n+        return txMsg;\n     }\n \n     @Override\n     public SnapshotReadMessage read() {\n-        return null;\n+        if (currentStreamInfo == null || !currentStreamInfo.iterator.hasNext()) {\n+            if (streamsToSent.isEmpty()) {\n+                return new SnapshotReadMessage(null, true);", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MDk0Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376170946", "bodyText": "what happens in the first run?  not very clear in the way the code is.", "author": "medhavidhawan", "createdAt": "2020-02-07T01:20:53Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {\n+        //if it is the end of the stream, set an end of stream mark, the current\n+        List<SMREntry> list = new ArrayList<>();\n+        try {\n+            while (stream.iterator.hasNext() && list.size() < numEntries) {\n+                OpaqueEntry entry = (OpaqueEntry) stream.iterator.next();\n+                verify(stream, entry);\n+                stream.maxVersion = Math.max(stream.maxVersion, entry.getVersion());\n+                list.addAll(entry.getEntries().get(stream.uuid));\n+            }\n+        } catch (TrimmedException e) {\n+            log.error(\"Catch an TrimmedException exception \", e);\n         }\n-\n-        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", streamName, globalSnapshot);\n-        return;\n+        return list;\n     }\n \n     /**\n-     * while transmit finish put an event to the queue\n+     * Poll the current stream and get a batch of SMR entries and\n+     * generate one message\n+     * @param stream bookkeeping of the current stream information.\n+     * @return\n      */\n-    public void sync() {\n-        setup();\n-        try {\n-            for (String streamName : streams) {\n-                next(streamName);\n-            }\n-        } catch (Exception e) {\n-            //handle exception\n-            log.warn(\"Sync call get an exception \", e);\n-            throw e;\n-        }\n-\n-        //todo: update metadata to record a Snapshot Reader done\n-        log.info(\"Successfully do a transmit read for globalSnapshot {}\", globalSnapshot);\n+    TxMessage next(StreamInfo stream) {\n+        List<SMREntry> entries = next(stream, MAX_BATCH_SIZE);\n+        TxMessage txMsg = generateMessage(stream, entries);\n+        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", stream.name, globalSnapshot);\n+        return txMsg;\n     }\n \n     @Override\n     public SnapshotReadMessage read() {\n-        return null;\n+        if (currentStreamInfo == null || !currentStreamInfo.iterator.hasNext()) {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MjE1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376172155", "bodyText": "Please add comments to class StreamInfo", "author": "medhavidhawan", "createdAt": "2020-02-07T01:26:05Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MjkwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376172906", "bodyText": "Please add comments", "author": "medhavidhawan", "createdAt": "2020-02-07T01:28:49Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {\n+        //if it is the end of the stream, set an end of stream mark, the current\n+        List<SMREntry> list = new ArrayList<>();\n+        try {\n+            while (stream.iterator.hasNext() && list.size() < numEntries) {\n+                OpaqueEntry entry = (OpaqueEntry) stream.iterator.next();\n+                verify(stream, entry);\n+                stream.maxVersion = Math.max(stream.maxVersion, entry.getVersion());\n+                list.addAll(entry.getEntries().get(stream.uuid));\n+            }\n+        } catch (TrimmedException e) {\n+            log.error(\"Catch an TrimmedException exception \", e);\n         }\n-\n-        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", streamName, globalSnapshot);\n-        return;\n+        return list;\n     }\n \n     /**\n-     * while transmit finish put an event to the queue\n+     * Poll the current stream and get a batch of SMR entries and\n+     * generate one message\n+     * @param stream bookkeeping of the current stream information.\n+     * @return\n      */\n-    public void sync() {\n-        setup();\n-        try {\n-            for (String streamName : streams) {\n-                next(streamName);\n-            }\n-        } catch (Exception e) {\n-            //handle exception\n-            log.warn(\"Sync call get an exception \", e);\n-            throw e;\n-        }\n-\n-        //todo: update metadata to record a Snapshot Reader done\n-        log.info(\"Successfully do a transmit read for globalSnapshot {}\", globalSnapshot);\n+    TxMessage next(StreamInfo stream) {\n+        List<SMREntry> entries = next(stream, MAX_BATCH_SIZE);\n+        TxMessage txMsg = generateMessage(stream, entries);\n+        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", stream.name, globalSnapshot);\n+        return txMsg;\n     }\n \n     @Override\n     public SnapshotReadMessage read() {\n-        return null;\n+        if (currentStreamInfo == null || !currentStreamInfo.iterator.hasNext()) {\n+            if (streamsToSent.isEmpty()) {\n+                return new SnapshotReadMessage(null, true);\n+            }\n+            currentStreamInfo = new StreamInfo(streamsToSent.poll(), rt, globalSnapshot);\n+        }\n+\n+        List msgs = new ArrayList<TxMessage>();\n+        msgs.add(next(currentStreamInfo));\n+        return new SnapshotReadMessage(msgs, streamsToSent.isEmpty()&&!currentStreamInfo.iterator.hasNext());\n     }\n \n     @Override\n     public void reset(long snapshotTimestamp) {\n+        streamsToSent = new PriorityQueue<>(streams);\n+        preMsgTs = Address.NON_ADDRESS;\n+        currentMsgTs = Address.NON_ADDRESS;\n+        globalSnapshot = snapshotTimestamp; //rt.getAddressSpaceView().getLogTail();\n+        sequence = 0;\n+    }\n \n+    public static class StreamInfo {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MzQ4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376173484", "bodyText": "stream seems to not be used anywhere, do you need it?", "author": "medhavidhawan", "createdAt": "2020-02-07T01:31:20Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {\n+        //if it is the end of the stream, set an end of stream mark, the current\n+        List<SMREntry> list = new ArrayList<>();\n+        try {\n+            while (stream.iterator.hasNext() && list.size() < numEntries) {\n+                OpaqueEntry entry = (OpaqueEntry) stream.iterator.next();\n+                verify(stream, entry);\n+                stream.maxVersion = Math.max(stream.maxVersion, entry.getVersion());\n+                list.addAll(entry.getEntries().get(stream.uuid));\n+            }\n+        } catch (TrimmedException e) {\n+            log.error(\"Catch an TrimmedException exception \", e);\n         }\n-\n-        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", streamName, globalSnapshot);\n-        return;\n+        return list;\n     }\n \n     /**\n-     * while transmit finish put an event to the queue\n+     * Poll the current stream and get a batch of SMR entries and\n+     * generate one message\n+     * @param stream bookkeeping of the current stream information.\n+     * @return\n      */\n-    public void sync() {\n-        setup();\n-        try {\n-            for (String streamName : streams) {\n-                next(streamName);\n-            }\n-        } catch (Exception e) {\n-            //handle exception\n-            log.warn(\"Sync call get an exception \", e);\n-            throw e;\n-        }\n-\n-        //todo: update metadata to record a Snapshot Reader done\n-        log.info(\"Successfully do a transmit read for globalSnapshot {}\", globalSnapshot);\n+    TxMessage next(StreamInfo stream) {\n+        List<SMREntry> entries = next(stream, MAX_BATCH_SIZE);\n+        TxMessage txMsg = generateMessage(stream, entries);\n+        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", stream.name, globalSnapshot);\n+        return txMsg;\n     }\n \n     @Override\n     public SnapshotReadMessage read() {\n-        return null;\n+        if (currentStreamInfo == null || !currentStreamInfo.iterator.hasNext()) {\n+            if (streamsToSent.isEmpty()) {\n+                return new SnapshotReadMessage(null, true);\n+            }\n+            currentStreamInfo = new StreamInfo(streamsToSent.poll(), rt, globalSnapshot);\n+        }\n+\n+        List msgs = new ArrayList<TxMessage>();\n+        msgs.add(next(currentStreamInfo));\n+        return new SnapshotReadMessage(msgs, streamsToSent.isEmpty()&&!currentStreamInfo.iterator.hasNext());\n     }\n \n     @Override\n     public void reset(long snapshotTimestamp) {\n+        streamsToSent = new PriorityQueue<>(streams);\n+        preMsgTs = Address.NON_ADDRESS;\n+        currentMsgTs = Address.NON_ADDRESS;\n+        globalSnapshot = snapshotTimestamp; //rt.getAddressSpaceView().getLogTail();\n+        sequence = 0;\n+    }\n \n+    public static class StreamInfo {\n+        String name;\n+        UUID uuid;\n+        Stream stream;", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MzYxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376173614", "bodyText": "Could there be a better name for this class? StreamIterator? OpaqueStreamIterator?", "author": "medhavidhawan", "createdAt": "2020-02-07T01:31:38Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {\n+        //if it is the end of the stream, set an end of stream mark, the current\n+        List<SMREntry> list = new ArrayList<>();\n+        try {\n+            while (stream.iterator.hasNext() && list.size() < numEntries) {\n+                OpaqueEntry entry = (OpaqueEntry) stream.iterator.next();\n+                verify(stream, entry);\n+                stream.maxVersion = Math.max(stream.maxVersion, entry.getVersion());\n+                list.addAll(entry.getEntries().get(stream.uuid));\n+            }\n+        } catch (TrimmedException e) {\n+            log.error(\"Catch an TrimmedException exception \", e);\n         }\n-\n-        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", streamName, globalSnapshot);\n-        return;\n+        return list;\n     }\n \n     /**\n-     * while transmit finish put an event to the queue\n+     * Poll the current stream and get a batch of SMR entries and\n+     * generate one message\n+     * @param stream bookkeeping of the current stream information.\n+     * @return\n      */\n-    public void sync() {\n-        setup();\n-        try {\n-            for (String streamName : streams) {\n-                next(streamName);\n-            }\n-        } catch (Exception e) {\n-            //handle exception\n-            log.warn(\"Sync call get an exception \", e);\n-            throw e;\n-        }\n-\n-        //todo: update metadata to record a Snapshot Reader done\n-        log.info(\"Successfully do a transmit read for globalSnapshot {}\", globalSnapshot);\n+    TxMessage next(StreamInfo stream) {\n+        List<SMREntry> entries = next(stream, MAX_BATCH_SIZE);\n+        TxMessage txMsg = generateMessage(stream, entries);\n+        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", stream.name, globalSnapshot);\n+        return txMsg;\n     }\n \n     @Override\n     public SnapshotReadMessage read() {\n-        return null;\n+        if (currentStreamInfo == null || !currentStreamInfo.iterator.hasNext()) {\n+            if (streamsToSent.isEmpty()) {\n+                return new SnapshotReadMessage(null, true);\n+            }\n+            currentStreamInfo = new StreamInfo(streamsToSent.poll(), rt, globalSnapshot);\n+        }\n+\n+        List msgs = new ArrayList<TxMessage>();\n+        msgs.add(next(currentStreamInfo));\n+        return new SnapshotReadMessage(msgs, streamsToSent.isEmpty()&&!currentStreamInfo.iterator.hasNext());\n     }\n \n     @Override\n     public void reset(long snapshotTimestamp) {\n+        streamsToSent = new PriorityQueue<>(streams);\n+        preMsgTs = Address.NON_ADDRESS;\n+        currentMsgTs = Address.NON_ADDRESS;\n+        globalSnapshot = snapshotTimestamp; //rt.getAddressSpaceView().getLogTail();\n+        sequence = 0;\n+    }\n \n+    public static class StreamInfo {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3NDIyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376174226", "bodyText": "maxAddress?", "author": "medhavidhawan", "createdAt": "2020-02-07T01:34:24Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {\n+        //if it is the end of the stream, set an end of stream mark, the current\n+        List<SMREntry> list = new ArrayList<>();\n+        try {\n+            while (stream.iterator.hasNext() && list.size() < numEntries) {\n+                OpaqueEntry entry = (OpaqueEntry) stream.iterator.next();\n+                verify(stream, entry);\n+                stream.maxVersion = Math.max(stream.maxVersion, entry.getVersion());\n+                list.addAll(entry.getEntries().get(stream.uuid));\n+            }\n+        } catch (TrimmedException e) {\n+            log.error(\"Catch an TrimmedException exception \", e);\n         }\n-\n-        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", streamName, globalSnapshot);\n-        return;\n+        return list;\n     }\n \n     /**\n-     * while transmit finish put an event to the queue\n+     * Poll the current stream and get a batch of SMR entries and\n+     * generate one message\n+     * @param stream bookkeeping of the current stream information.\n+     * @return\n      */\n-    public void sync() {\n-        setup();\n-        try {\n-            for (String streamName : streams) {\n-                next(streamName);\n-            }\n-        } catch (Exception e) {\n-            //handle exception\n-            log.warn(\"Sync call get an exception \", e);\n-            throw e;\n-        }\n-\n-        //todo: update metadata to record a Snapshot Reader done\n-        log.info(\"Successfully do a transmit read for globalSnapshot {}\", globalSnapshot);\n+    TxMessage next(StreamInfo stream) {\n+        List<SMREntry> entries = next(stream, MAX_BATCH_SIZE);\n+        TxMessage txMsg = generateMessage(stream, entries);\n+        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", stream.name, globalSnapshot);\n+        return txMsg;\n     }\n \n     @Override\n     public SnapshotReadMessage read() {\n-        return null;\n+        if (currentStreamInfo == null || !currentStreamInfo.iterator.hasNext()) {\n+            if (streamsToSent.isEmpty()) {\n+                return new SnapshotReadMessage(null, true);\n+            }\n+            currentStreamInfo = new StreamInfo(streamsToSent.poll(), rt, globalSnapshot);\n+        }\n+\n+        List msgs = new ArrayList<TxMessage>();\n+        msgs.add(next(currentStreamInfo));\n+        return new SnapshotReadMessage(msgs, streamsToSent.isEmpty()&&!currentStreamInfo.iterator.hasNext());\n     }\n \n     @Override\n     public void reset(long snapshotTimestamp) {\n+        streamsToSent = new PriorityQueue<>(streams);\n+        preMsgTs = Address.NON_ADDRESS;\n+        currentMsgTs = Address.NON_ADDRESS;\n+        globalSnapshot = snapshotTimestamp; //rt.getAddressSpaceView().getLogTail();\n+        sequence = 0;\n+    }\n \n+    public static class StreamInfo {\n+        String name;\n+        UUID uuid;\n+        Stream stream;\n+        Iterator iterator;\n+        long maxVersion;", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU1OTg4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376559885", "bodyText": "For checkpoint entries, we use the snapshot ts for them. Version is more accurate.", "author": "xiaoqin2012", "createdAt": "2020-02-07T19:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3NDIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3OTA2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376179069", "bodyText": "There seems to be a bug here. next only works on a batch and then you move to the next stream. So if a stream has more entries than a MAX_BATCH_SIZE, you will miss those entries.", "author": "medhavidhawan", "createdAt": "2020-02-07T01:55:19Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {\n+        //if it is the end of the stream, set an end of stream mark, the current\n+        List<SMREntry> list = new ArrayList<>();\n+        try {\n+            while (stream.iterator.hasNext() && list.size() < numEntries) {\n+                OpaqueEntry entry = (OpaqueEntry) stream.iterator.next();\n+                verify(stream, entry);\n+                stream.maxVersion = Math.max(stream.maxVersion, entry.getVersion());\n+                list.addAll(entry.getEntries().get(stream.uuid));\n+            }\n+        } catch (TrimmedException e) {\n+            log.error(\"Catch an TrimmedException exception \", e);\n         }\n-\n-        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", streamName, globalSnapshot);\n-        return;\n+        return list;\n     }\n \n     /**\n-     * while transmit finish put an event to the queue\n+     * Poll the current stream and get a batch of SMR entries and\n+     * generate one message\n+     * @param stream bookkeeping of the current stream information.\n+     * @return\n      */\n-    public void sync() {\n-        setup();\n-        try {\n-            for (String streamName : streams) {\n-                next(streamName);\n-            }\n-        } catch (Exception e) {\n-            //handle exception\n-            log.warn(\"Sync call get an exception \", e);\n-            throw e;\n-        }\n-\n-        //todo: update metadata to record a Snapshot Reader done\n-        log.info(\"Successfully do a transmit read for globalSnapshot {}\", globalSnapshot);\n+    TxMessage next(StreamInfo stream) {\n+        List<SMREntry> entries = next(stream, MAX_BATCH_SIZE);\n+        TxMessage txMsg = generateMessage(stream, entries);\n+        log.info(\"Successfully pass a stream {} for globalSnapshot {}\", stream.name, globalSnapshot);\n+        return txMsg;\n     }\n \n     @Override\n     public SnapshotReadMessage read() {\n-        return null;\n+        if (currentStreamInfo == null || !currentStreamInfo.iterator.hasNext()) {\n+            if (streamsToSent.isEmpty()) {\n+                return new SnapshotReadMessage(null, true);\n+            }\n+            currentStreamInfo = new StreamInfo(streamsToSent.poll(), rt, globalSnapshot);\n+        }\n+\n+        List msgs = new ArrayList<TxMessage>();\n+        msgs.add(next(currentStreamInfo));", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU4MDAzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376580033", "bodyText": "It will continue work on the same stream for the read call.", "author": "xiaoqin2012", "createdAt": "2020-02-07T19:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3OTA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3OTc4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376179784", "bodyText": "comments", "author": "medhavidhawan", "createdAt": "2020-02-07T01:58:19Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4MDEwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376180103", "bodyText": "Need to bubble up the TrimmedException", "author": "medhavidhawan", "createdAt": "2020-02-07T01:59:40Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/transmitter/StreamsSnapshotReader.java", "diffHunk": "@@ -29,101 +38,131 @@\n     private final MessageType MSG_TYPE = MessageType.SNAPSHOT_MESSAGE;\n     private long globalSnapshot;\n     private Set<String> streams;\n+    private PriorityQueue<String> streamsToSent;\n     private CorfuRuntime rt;\n     private long preMsgTs;\n     private long currentMsgTs;\n     private LogReplicationConfig config;\n+    private StreamInfo currentStreamInfo;\n+    private long sequence;\n \n     /**\n-     * Set runtime and callback function to pass message to network\n+     * Init runtime and streams to read\n      */\n     public StreamsSnapshotReader(CorfuRuntime rt, LogReplicationConfig config) {\n         this.rt = rt;\n         this.config = config;\n+        streams = config.getStreamsToReplicate();\n     }\n+\n     /**\n-     * setup globalSnapshot\n+     * Verify that the OpaqueEntry has the correct information.\n+     * @param stream\n+     * @param entry\n+     * @return\n      */\n-    void setup() {\n-        preMsgTs = Address.NON_ADDRESS;\n-        currentMsgTs = Address.NON_ADDRESS;\n-        globalSnapshot = rt.getAddressSpaceView().getLogTail();\n+    boolean verify(StreamInfo stream, OpaqueEntry entry) {\n+        Set<UUID> keySet = entry.getEntries().keySet();\n+\n+        if (keySet.size() != 1 || !keySet.contains(stream.uuid)) {\n+            log.error(\"OpaqueEntry is wrong \", entry);\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n-     * get all entries for a stream up to the globalSnapshot\n+     * Given a streamID and list of smrEntries, generate an OpaqueEntry\n      * @param streamID\n+     * @param smrEntries\n      * @return\n      */\n-    List<SMREntry> readStream(UUID streamID) {\n-        StreamViewSMRAdapter smrAdapter =  new StreamViewSMRAdapter(rt, rt.getStreamsView().getUnsafe(streamID));\n-        return smrAdapter.remainingUpTo(globalSnapshot);\n+    OpaqueEntry generateOpaqueEntry(UUID streamID, List smrEntries) {\n+        Map<UUID, List<SMREntry>> map = new HashMap<>();\n+        map.put(streamID, smrEntries);\n+        return new OpaqueEntry(currentMsgTs, map);\n     }\n \n-    TxMessage generateMessage(List<SMREntry> entries) {\n-        currentMsgTs = entries.get(entries.size() - 1).getGlobalAddress();\n-        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot);\n-\n-        // todo: using Maithem API to generate msg data with entries.\n+    TxMessage generateMessage(StreamInfo stream, List<SMREntry> entries) {\n         ByteBuf buf = Unpooled.buffer();\n-        entries.get(0).serialize(buf);\n-        txMsg.setData(buf.array());\n-\n+        OpaqueEntry.serialize(buf, generateOpaqueEntry(stream.uuid, entries));\n+        currentMsgTs = stream.maxVersion;\n+        if (!stream.iterator.hasNext()) {\n+            //mark the end of the current stream.\n+            currentMsgTs = globalSnapshot;\n+        }\n+        TxMessage txMsg = new TxMessage(MSG_TYPE, currentMsgTs, preMsgTs, globalSnapshot, sequence, buf.array());\n+        preMsgTs = currentMsgTs;\n+        sequence++;\n         log.debug(\"Generate TxMsg {}\", txMsg.getMetadata());\n-        //set data, will plug in meithem's new api\n         return  txMsg;\n     }\n \n-    /**\n-     * Given a stream name, get all entries for this stream,\n-     * put entries in a message and call the callback handler\n-     * to pass the message to the other site.\n-     * @param streamName\n-     */\n-    void next(String streamName) {\n-        UUID streamID = CorfuRuntime.getStreamID(streamName);\n-        ArrayList<SMREntry> entries = new ArrayList<>(readStream(streamID));\n-        preMsgTs = Address.NON_ADDRESS;\n-\n-        for (int i = 0; i < entries.size(); i += MAX_BATCH_SIZE) {\n-            List<SMREntry> msg_entries = entries.subList(i, i + MAX_BATCH_SIZE);\n-            TxMessage txMsg = generateMessage(msg_entries);\n-\n-            //update preMsgTs only after process a msg successfully\n-            preMsgTs = currentMsgTs;\n-            log.debug(\"Successfully pass a TxMsg {}\", txMsg.getMetadata());\n+    List<SMREntry> next(StreamInfo stream, int numEntries) {\n+        //if it is the end of the stream, set an end of stream mark, the current\n+        List<SMREntry> list = new ArrayList<>();\n+        try {\n+            while (stream.iterator.hasNext() && list.size() < numEntries) {\n+                OpaqueEntry entry = (OpaqueEntry) stream.iterator.next();\n+                verify(stream, entry);\n+                stream.maxVersion = Math.max(stream.maxVersion, entry.getVersion());\n+                list.addAll(entry.getEntries().get(stream.uuid));\n+            }\n+        } catch (TrimmedException e) {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4MDYxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376180618", "bodyText": "comments", "author": "medhavidhawan", "createdAt": "2020-02-07T02:01:47Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4MDc0MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376180740", "bodyText": "need comments for each of the member fields.", "author": "medhavidhawan", "createdAt": "2020-02-07T02:02:17Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {\n+    private Set<String> streams;", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4MTY1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376181657", "bodyText": "you probably need some ordered datastructure here to not not make every pass O(n)", "author": "medhavidhawan", "createdAt": "2020-02-07T02:05:57Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {\n+    private Set<String> streams;\n     private List<UUID> streamUUIDs;\n     HashMap<UUID, IStreamView> streamViewMap;\n     CorfuRuntime rt;\n-    long proccessedMsgTs;\n-    final private int QUEUE_SIZE = 20;\n     private long srcGlobalSnapshot;\n-    private long lastSrcAddressProcessed;\n-    private PriorityQueue<TxMessage> msgQ;\n-\n-    LogEntryWriter() {\n-        msgQ = new PriorityQueue(QUEUE_SIZE, Comparator.comparingLong(\n-                a ->(((TxMessage)a).metadata.entryTimeStamp)));\n-    }\n-\n-    void verifyMetadata(MessageMetadata metadata) {\n+    long lastMsgTs;\n+    private final int MAX_MSG_QUE_SIZE = 20;\n+    private HashMap<Long, TxMessage> msgQ; //If the received messages are out of order, buffer them. Can be queried according to the preTs.", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4MTgzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376181837", "bodyText": "comments.", "author": "medhavidhawan", "createdAt": "2020-02-07T02:06:43Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {\n+    private Set<String> streams;\n     private List<UUID> streamUUIDs;\n     HashMap<UUID, IStreamView> streamViewMap;\n     CorfuRuntime rt;\n-    long proccessedMsgTs;\n-    final private int QUEUE_SIZE = 20;\n     private long srcGlobalSnapshot;\n-    private long lastSrcAddressProcessed;\n-    private PriorityQueue<TxMessage> msgQ;\n-\n-    LogEntryWriter() {\n-        msgQ = new PriorityQueue(QUEUE_SIZE, Comparator.comparingLong(\n-                a ->(((TxMessage)a).metadata.entryTimeStamp)));\n-    }\n-\n-    void verifyMetadata(MessageMetadata metadata) {\n+    long lastMsgTs;\n+    private final int MAX_MSG_QUE_SIZE = 20;\n+    private HashMap<Long, TxMessage> msgQ; //If the received messages are out of order, buffer them. Can be queried according to the preTs.\n \n+    LogEntryWriter(CorfuRuntime rt, LogReplicationConfig config) {\n+        this.rt = rt;\n+        this.streams = config.getStreamsToReplicate();\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n+        msgQ = new HashMap<>();\n+        srcGlobalSnapshot = Address.NON_ADDRESS;\n+        lastMsgTs = Address.NON_ADDRESS;\n     }\n \n-    void processTxMessage(TxMessage msg) {\n-        MessageMetadata metadata = msg.getMetadata();\n-        verifyMetadata(metadata);\n-        TxMessage currentMsg = null;\n-\n-        assert(metadata.getPreviousEntryTimestamp() == proccessedMsgTs);\n-        for (UUID streamID : streamUUIDs) {\n-            ILogData logData = null;\n-            MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry)logData.getPayload(rt);\n-            for (SMREntry entry : multiObjSMREntry.getSMRUpdates(streamID)) {\n-                streamViewMap.get(streamID).append(entry);\n-            }\n+    /**\n+     *\n+     * @param metadata\n+     * @throws Exception\n+     */\n+    void verifyMetadata(MessageMetadata metadata) throws Exception {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NDU1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376184556", "bodyText": "maybe you need a specific Exception Type", "author": "medhavidhawan", "createdAt": "2020-02-07T02:19:33Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {\n+    private Set<String> streams;\n     private List<UUID> streamUUIDs;\n     HashMap<UUID, IStreamView> streamViewMap;\n     CorfuRuntime rt;\n-    long proccessedMsgTs;\n-    final private int QUEUE_SIZE = 20;\n     private long srcGlobalSnapshot;\n-    private long lastSrcAddressProcessed;\n-    private PriorityQueue<TxMessage> msgQ;\n-\n-    LogEntryWriter() {\n-        msgQ = new PriorityQueue(QUEUE_SIZE, Comparator.comparingLong(\n-                a ->(((TxMessage)a).metadata.entryTimeStamp)));\n-    }\n-\n-    void verifyMetadata(MessageMetadata metadata) {\n+    long lastMsgTs;\n+    private final int MAX_MSG_QUE_SIZE = 20;\n+    private HashMap<Long, TxMessage> msgQ; //If the received messages are out of order, buffer them. Can be queried according to the preTs.\n \n+    LogEntryWriter(CorfuRuntime rt, LogReplicationConfig config) {\n+        this.rt = rt;\n+        this.streams = config.getStreamsToReplicate();\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n+        msgQ = new HashMap<>();\n+        srcGlobalSnapshot = Address.NON_ADDRESS;\n+        lastMsgTs = Address.NON_ADDRESS;\n     }\n \n-    void processTxMessage(TxMessage msg) {\n-        MessageMetadata metadata = msg.getMetadata();\n-        verifyMetadata(metadata);\n-        TxMessage currentMsg = null;\n-\n-        assert(metadata.getPreviousEntryTimestamp() == proccessedMsgTs);\n-        for (UUID streamID : streamUUIDs) {\n-            ILogData logData = null;\n-            MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry)logData.getPayload(rt);\n-            for (SMREntry entry : multiObjSMREntry.getSMRUpdates(streamID)) {\n-                streamViewMap.get(streamID).append(entry);\n-            }\n+    /**\n+     *\n+     * @param metadata\n+     * @throws Exception\n+     */\n+    void verifyMetadata(MessageMetadata metadata) throws Exception {\n+        if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) {\n+            log.error(\"Wrong message metadata {}, expecting  type {} snapshot {}\", metadata,\n+                    MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot);\n+            throw new Exception(\"wrong type of message\");", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NDgyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376184828", "bodyText": "Does ths need to throw an exception ?", "author": "medhavidhawan", "createdAt": "2020-02-07T02:20:43Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {\n+    private Set<String> streams;\n     private List<UUID> streamUUIDs;\n     HashMap<UUID, IStreamView> streamViewMap;\n     CorfuRuntime rt;\n-    long proccessedMsgTs;\n-    final private int QUEUE_SIZE = 20;\n     private long srcGlobalSnapshot;\n-    private long lastSrcAddressProcessed;\n-    private PriorityQueue<TxMessage> msgQ;\n-\n-    LogEntryWriter() {\n-        msgQ = new PriorityQueue(QUEUE_SIZE, Comparator.comparingLong(\n-                a ->(((TxMessage)a).metadata.entryTimeStamp)));\n-    }\n-\n-    void verifyMetadata(MessageMetadata metadata) {\n+    long lastMsgTs;\n+    private final int MAX_MSG_QUE_SIZE = 20;\n+    private HashMap<Long, TxMessage> msgQ; //If the received messages are out of order, buffer them. Can be queried according to the preTs.\n \n+    LogEntryWriter(CorfuRuntime rt, LogReplicationConfig config) {\n+        this.rt = rt;\n+        this.streams = config.getStreamsToReplicate();\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n+        msgQ = new HashMap<>();\n+        srcGlobalSnapshot = Address.NON_ADDRESS;\n+        lastMsgTs = Address.NON_ADDRESS;\n     }\n \n-    void processTxMessage(TxMessage msg) {\n-        MessageMetadata metadata = msg.getMetadata();\n-        verifyMetadata(metadata);\n-        TxMessage currentMsg = null;\n-\n-        assert(metadata.getPreviousEntryTimestamp() == proccessedMsgTs);\n-        for (UUID streamID : streamUUIDs) {\n-            ILogData logData = null;\n-            MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry)logData.getPayload(rt);\n-            for (SMREntry entry : multiObjSMREntry.getSMRUpdates(streamID)) {\n-                streamViewMap.get(streamID).append(entry);\n-            }\n+    /**\n+     *\n+     * @param metadata\n+     * @throws Exception\n+     */\n+    void verifyMetadata(MessageMetadata metadata) throws Exception {\n+        if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) {\n+            log.error(\"Wrong message metadata {}, expecting  type {} snapshot {}\", metadata,\n+                    MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot);\n+            throw new Exception(\"wrong type of message\");\n         }\n     }\n \n     /**\n-     * find the msg whose\n-     * @param preAddress\n-     * @return\n+     * Convert message data to an MultiObjectSMREntry and write to log.\n+     * @param txMessage\n      */\n-    TxMessage findMsg(long preAddress) {\n-        //delete all message whose address < preAddress\n-        //return the msg whose preAddress == preAddress\n-        return new TxMessage();\n-    }\n+    void processMsg(TxMessage txMessage) {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NjIxNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376186215", "bodyText": "rename processQueue", "author": "medhavidhawan", "createdAt": "2020-02-07T02:26:39Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {\n+    private Set<String> streams;\n     private List<UUID> streamUUIDs;\n     HashMap<UUID, IStreamView> streamViewMap;\n     CorfuRuntime rt;\n-    long proccessedMsgTs;\n-    final private int QUEUE_SIZE = 20;\n     private long srcGlobalSnapshot;\n-    private long lastSrcAddressProcessed;\n-    private PriorityQueue<TxMessage> msgQ;\n-\n-    LogEntryWriter() {\n-        msgQ = new PriorityQueue(QUEUE_SIZE, Comparator.comparingLong(\n-                a ->(((TxMessage)a).metadata.entryTimeStamp)));\n-    }\n-\n-    void verifyMetadata(MessageMetadata metadata) {\n+    long lastMsgTs;\n+    private final int MAX_MSG_QUE_SIZE = 20;\n+    private HashMap<Long, TxMessage> msgQ; //If the received messages are out of order, buffer them. Can be queried according to the preTs.\n \n+    LogEntryWriter(CorfuRuntime rt, LogReplicationConfig config) {\n+        this.rt = rt;\n+        this.streams = config.getStreamsToReplicate();\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n+        msgQ = new HashMap<>();\n+        srcGlobalSnapshot = Address.NON_ADDRESS;\n+        lastMsgTs = Address.NON_ADDRESS;\n     }\n \n-    void processTxMessage(TxMessage msg) {\n-        MessageMetadata metadata = msg.getMetadata();\n-        verifyMetadata(metadata);\n-        TxMessage currentMsg = null;\n-\n-        assert(metadata.getPreviousEntryTimestamp() == proccessedMsgTs);\n-        for (UUID streamID : streamUUIDs) {\n-            ILogData logData = null;\n-            MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry)logData.getPayload(rt);\n-            for (SMREntry entry : multiObjSMREntry.getSMRUpdates(streamID)) {\n-                streamViewMap.get(streamID).append(entry);\n-            }\n+    /**\n+     *\n+     * @param metadata\n+     * @throws Exception\n+     */\n+    void verifyMetadata(MessageMetadata metadata) throws Exception {\n+        if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) {\n+            log.error(\"Wrong message metadata {}, expecting  type {} snapshot {}\", metadata,\n+                    MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot);\n+            throw new Exception(\"wrong type of message\");\n         }\n     }\n \n     /**\n-     * find the msg whose\n-     * @param preAddress\n-     * @return\n+     * Convert message data to an MultiObjectSMREntry and write to log.\n+     * @param txMessage\n      */\n-    TxMessage findMsg(long preAddress) {\n-        //delete all message whose address < preAddress\n-        //return the msg whose preAddress == preAddress\n-        return new TxMessage();\n-    }\n+    void processMsg(TxMessage txMessage) {\n+        OpaqueEntry opaqueEntry = OpaqueEntry.deserialize(Unpooled.wrappedBuffer(txMessage.getData()));\n+        Map<UUID, List<SMREntry>> map = opaqueEntry.getEntries();\n+        if (!streamUUIDs.contains(map.keySet())) {\n+            log.error(\"txMessage contains noisy streams {}, expecting {}\", map.keySet(), streamUUIDs);\n+        }\n+        try {\n+            rt.getObjectsView().TXBegin();\n+            TokenResponse tokenResponse = rt.getSequencerView().next((UUID[])(map.keySet().toArray()));\n+            MultiObjectSMREntry multiObjectSMREntry = new MultiObjectSMREntry();\n+            for (UUID uuid : opaqueEntry.getEntries().keySet()) {\n+                for(SMREntry smrEntry : opaqueEntry.getEntries().get(uuid)) {\n+                    multiObjectSMREntry.addTo(uuid, smrEntry);\n+                }\n+            }\n+            rt.getAddressSpaceView().write(tokenResponse.getToken(), multiObjectSMREntry);\n \n-    void setContext(long snapshot) {\n-        srcGlobalSnapshot = snapshot;\n-        lastSrcAddressProcessed = snapshot;\n+        } finally {\n+            rt.getObjectsView().TXEnd();\n+        }\n     }\n \n-    //Question? what the size of the deltaQue? Is it a in memory que or persistent que?\n-    void processDeltaQue() {\n+    /**\n+     * Go over the queue, if the next expecting msg is in queue, process it.\n+     * @throws Exception\n+     */\n+    void processQue() throws Exception {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NjYwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376186600", "bodyText": "does processMsg guarantee that it will always be successful because you remove the message after that.", "author": "medhavidhawan", "createdAt": "2020-02-07T02:28:22Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {\n+    private Set<String> streams;\n     private List<UUID> streamUUIDs;\n     HashMap<UUID, IStreamView> streamViewMap;\n     CorfuRuntime rt;\n-    long proccessedMsgTs;\n-    final private int QUEUE_SIZE = 20;\n     private long srcGlobalSnapshot;\n-    private long lastSrcAddressProcessed;\n-    private PriorityQueue<TxMessage> msgQ;\n-\n-    LogEntryWriter() {\n-        msgQ = new PriorityQueue(QUEUE_SIZE, Comparator.comparingLong(\n-                a ->(((TxMessage)a).metadata.entryTimeStamp)));\n-    }\n-\n-    void verifyMetadata(MessageMetadata metadata) {\n+    long lastMsgTs;\n+    private final int MAX_MSG_QUE_SIZE = 20;\n+    private HashMap<Long, TxMessage> msgQ; //If the received messages are out of order, buffer them. Can be queried according to the preTs.\n \n+    LogEntryWriter(CorfuRuntime rt, LogReplicationConfig config) {\n+        this.rt = rt;\n+        this.streams = config.getStreamsToReplicate();\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n+        msgQ = new HashMap<>();\n+        srcGlobalSnapshot = Address.NON_ADDRESS;\n+        lastMsgTs = Address.NON_ADDRESS;\n     }\n \n-    void processTxMessage(TxMessage msg) {\n-        MessageMetadata metadata = msg.getMetadata();\n-        verifyMetadata(metadata);\n-        TxMessage currentMsg = null;\n-\n-        assert(metadata.getPreviousEntryTimestamp() == proccessedMsgTs);\n-        for (UUID streamID : streamUUIDs) {\n-            ILogData logData = null;\n-            MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry)logData.getPayload(rt);\n-            for (SMREntry entry : multiObjSMREntry.getSMRUpdates(streamID)) {\n-                streamViewMap.get(streamID).append(entry);\n-            }\n+    /**\n+     *\n+     * @param metadata\n+     * @throws Exception\n+     */\n+    void verifyMetadata(MessageMetadata metadata) throws Exception {\n+        if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) {\n+            log.error(\"Wrong message metadata {}, expecting  type {} snapshot {}\", metadata,\n+                    MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot);\n+            throw new Exception(\"wrong type of message\");\n         }\n     }\n \n     /**\n-     * find the msg whose\n-     * @param preAddress\n-     * @return\n+     * Convert message data to an MultiObjectSMREntry and write to log.\n+     * @param txMessage\n      */\n-    TxMessage findMsg(long preAddress) {\n-        //delete all message whose address < preAddress\n-        //return the msg whose preAddress == preAddress\n-        return new TxMessage();\n-    }\n+    void processMsg(TxMessage txMessage) {\n+        OpaqueEntry opaqueEntry = OpaqueEntry.deserialize(Unpooled.wrappedBuffer(txMessage.getData()));\n+        Map<UUID, List<SMREntry>> map = opaqueEntry.getEntries();\n+        if (!streamUUIDs.contains(map.keySet())) {\n+            log.error(\"txMessage contains noisy streams {}, expecting {}\", map.keySet(), streamUUIDs);\n+        }\n+        try {\n+            rt.getObjectsView().TXBegin();\n+            TokenResponse tokenResponse = rt.getSequencerView().next((UUID[])(map.keySet().toArray()));\n+            MultiObjectSMREntry multiObjectSMREntry = new MultiObjectSMREntry();\n+            for (UUID uuid : opaqueEntry.getEntries().keySet()) {\n+                for(SMREntry smrEntry : opaqueEntry.getEntries().get(uuid)) {\n+                    multiObjectSMREntry.addTo(uuid, smrEntry);\n+                }\n+            }\n+            rt.getAddressSpaceView().write(tokenResponse.getToken(), multiObjectSMREntry);\n \n-    void setContext(long snapshot) {\n-        srcGlobalSnapshot = snapshot;\n-        lastSrcAddressProcessed = snapshot;\n+        } finally {\n+            rt.getObjectsView().TXEnd();\n+        }\n     }\n \n-    //Question? what the size of the deltaQue? Is it a in memory que or persistent que?\n-    void processDeltaQue() {\n+    /**\n+     * Go over the queue, if the next expecting msg is in queue, process it.\n+     * @throws Exception\n+     */\n+    void processQue() throws Exception {\n         while (true) {\n-            TxMessage msg = findMsg(lastSrcAddressProcessed);\n-            if (msg == null) {\n+            TxMessage txMessage = msgQ.get(lastMsgTs);\n+            if (txMessage == null) {\n                 return;\n             }\n+            processMsg(txMessage);", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4ODM2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376188363", "bodyText": "if the size is more you are going to drop the message. please add a log  message and also add comments.", "author": "medhavidhawan", "createdAt": "2020-02-07T02:36:10Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {\n+    private Set<String> streams;\n     private List<UUID> streamUUIDs;\n     HashMap<UUID, IStreamView> streamViewMap;\n     CorfuRuntime rt;\n-    long proccessedMsgTs;\n-    final private int QUEUE_SIZE = 20;\n     private long srcGlobalSnapshot;\n-    private long lastSrcAddressProcessed;\n-    private PriorityQueue<TxMessage> msgQ;\n-\n-    LogEntryWriter() {\n-        msgQ = new PriorityQueue(QUEUE_SIZE, Comparator.comparingLong(\n-                a ->(((TxMessage)a).metadata.entryTimeStamp)));\n-    }\n-\n-    void verifyMetadata(MessageMetadata metadata) {\n+    long lastMsgTs;\n+    private final int MAX_MSG_QUE_SIZE = 20;\n+    private HashMap<Long, TxMessage> msgQ; //If the received messages are out of order, buffer them. Can be queried according to the preTs.\n \n+    LogEntryWriter(CorfuRuntime rt, LogReplicationConfig config) {\n+        this.rt = rt;\n+        this.streams = config.getStreamsToReplicate();\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n+        msgQ = new HashMap<>();\n+        srcGlobalSnapshot = Address.NON_ADDRESS;\n+        lastMsgTs = Address.NON_ADDRESS;\n     }\n \n-    void processTxMessage(TxMessage msg) {\n-        MessageMetadata metadata = msg.getMetadata();\n-        verifyMetadata(metadata);\n-        TxMessage currentMsg = null;\n-\n-        assert(metadata.getPreviousEntryTimestamp() == proccessedMsgTs);\n-        for (UUID streamID : streamUUIDs) {\n-            ILogData logData = null;\n-            MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry)logData.getPayload(rt);\n-            for (SMREntry entry : multiObjSMREntry.getSMRUpdates(streamID)) {\n-                streamViewMap.get(streamID).append(entry);\n-            }\n+    /**\n+     *\n+     * @param metadata\n+     * @throws Exception\n+     */\n+    void verifyMetadata(MessageMetadata metadata) throws Exception {\n+        if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) {\n+            log.error(\"Wrong message metadata {}, expecting  type {} snapshot {}\", metadata,\n+                    MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot);\n+            throw new Exception(\"wrong type of message\");\n         }\n     }\n \n     /**\n-     * find the msg whose\n-     * @param preAddress\n-     * @return\n+     * Convert message data to an MultiObjectSMREntry and write to log.\n+     * @param txMessage\n      */\n-    TxMessage findMsg(long preAddress) {\n-        //delete all message whose address < preAddress\n-        //return the msg whose preAddress == preAddress\n-        return new TxMessage();\n-    }\n+    void processMsg(TxMessage txMessage) {\n+        OpaqueEntry opaqueEntry = OpaqueEntry.deserialize(Unpooled.wrappedBuffer(txMessage.getData()));\n+        Map<UUID, List<SMREntry>> map = opaqueEntry.getEntries();\n+        if (!streamUUIDs.contains(map.keySet())) {\n+            log.error(\"txMessage contains noisy streams {}, expecting {}\", map.keySet(), streamUUIDs);\n+        }\n+        try {\n+            rt.getObjectsView().TXBegin();\n+            TokenResponse tokenResponse = rt.getSequencerView().next((UUID[])(map.keySet().toArray()));\n+            MultiObjectSMREntry multiObjectSMREntry = new MultiObjectSMREntry();\n+            for (UUID uuid : opaqueEntry.getEntries().keySet()) {\n+                for(SMREntry smrEntry : opaqueEntry.getEntries().get(uuid)) {\n+                    multiObjectSMREntry.addTo(uuid, smrEntry);\n+                }\n+            }\n+            rt.getAddressSpaceView().write(tokenResponse.getToken(), multiObjectSMREntry);\n \n-    void setContext(long snapshot) {\n-        srcGlobalSnapshot = snapshot;\n-        lastSrcAddressProcessed = snapshot;\n+        } finally {\n+            rt.getObjectsView().TXEnd();\n+        }\n     }\n \n-    //Question? what the size of the deltaQue? Is it a in memory que or persistent que?\n-    void processDeltaQue() {\n+    /**\n+     * Go over the queue, if the next expecting msg is in queue, process it.\n+     * @throws Exception\n+     */\n+    void processQue() throws Exception {\n         while (true) {\n-            TxMessage msg = findMsg(lastSrcAddressProcessed);\n-            if (msg == null) {\n+            TxMessage txMessage = msgQ.get(lastMsgTs);\n+            if (txMessage == null) {\n                 return;\n             }\n+            processMsg(txMessage);\n+            msgQ.remove(lastMsgTs);\n+            lastMsgTs = txMessage.getMetadata().getEntryTimeStamp();\n+        }\n+    }\n+\n+    void applyTxMessage(TxMessage msg) throws Exception {\n+        verifyMetadata(msg.getMetadata());\n+\n+        // Ignore the out of date messages\n+        if (msg.getMetadata().getSnapshotTimestamp() < srcGlobalSnapshot) {\n+            log.warn(\"Received message with snapshot {} is smaller than current snapshot {}.Ignore it\",\n+                    msg.getMetadata().getSnapshotTimestamp(), srcGlobalSnapshot);\n+            return;\n+        }\n+\n+        // A new full sync happens, setup the new srcGlobalSnapshot\n+        if (msg.getMetadata().getSnapshotTimestamp() > srcGlobalSnapshot) {\n+            srcGlobalSnapshot = msg.getMetadata().getSnapshotTimestamp();\n+            lastMsgTs = srcGlobalSnapshot;\n+        }\n+\n+        //we will skip the entries has been processed.\n+        if (msg.getMetadata().getEntryTimeStamp() <= lastMsgTs) {\n+            return;\n+        }\n+\n+        //If the entry is the expecting entry, process it and then process\n+        //the messages in the queue.\n+        if (msg.getMetadata().getPreviousEntryTimestamp() == lastMsgTs) {\n+            processMsg(msg);\n+            lastMsgTs = msg.getMetadata().getEntryTimeStamp();\n+            processQue();\n+        }\n \n-            processTxMessage(msg);\n-            lastSrcAddressProcessed = msg.getMetadata().getEntryTimeStamp();\n-            //remove msg from deltaQue\n+        //If the entry's ts is larger than the entry processed, put it in queue\n+        if (msgQ.size() < MAX_MSG_QUE_SIZE) {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4ODU4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376188582", "bodyText": "add more comments with more description. as to what is the workflow of fullsync. It is much easier to debug if the intention is there in the comments.", "author": "medhavidhawan", "createdAt": "2020-02-07T02:37:10Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/StreamsSnapshotWriter.java", "diffHunk": "@@ -1,103 +1,81 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n import org.corfudb.logreplication.transmitter.TxMessage;\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.collections.CorfuTable;\n import com.google.common.reflect.TypeToken;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Set;\n import java.util.UUID;\n \n /**\n- * The AR will pass in FullSyncQue and DeltaQue and API for fullSyncDone()\n+ * Writing a fullsync\n  * Open streams interested and append all entries\n  */", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4ODcwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376188701", "bodyText": "There need to be comment for these member variables.", "author": "medhavidhawan", "createdAt": "2020-02-07T02:37:44Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/StreamsSnapshotWriter.java", "diffHunk": "@@ -1,103 +1,81 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n import org.corfudb.logreplication.transmitter.TxMessage;\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.collections.CorfuTable;\n import com.google.common.reflect.TypeToken;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Set;\n import java.util.UUID;\n \n /**\n- * The AR will pass in FullSyncQue and DeltaQue and API for fullSyncDone()\n+ * Writing a fullsync\n  * Open streams interested and append all entries\n  */\n \n+@Slf4j\n+@NotThreadSafe\n public class StreamsSnapshotWriter implements SnapshotWriter {\n-    private List<UUID> streamUUIDs;\n+    private Set<String> streams;", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIxMDQzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376210436", "bodyText": "specific exception if possible.", "author": "medhavidhawan", "createdAt": "2020-02-07T04:32:43Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/StreamsSnapshotWriter.java", "diffHunk": "@@ -1,103 +1,81 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n import org.corfudb.logreplication.transmitter.TxMessage;\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.collections.CorfuTable;\n import com.google.common.reflect.TypeToken;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Set;\n import java.util.UUID;\n \n /**\n- * The AR will pass in FullSyncQue and DeltaQue and API for fullSyncDone()\n+ * Writing a fullsync\n  * Open streams interested and append all entries\n  */\n \n+@Slf4j\n+@NotThreadSafe\n public class StreamsSnapshotWriter implements SnapshotWriter {\n-    private List<UUID> streamUUIDs;\n+    private Set<String> streams;\n     HashMap<UUID, IStreamView> streamViewMap;\n     CorfuRuntime rt;\n-    long proccessedMsgTs;\n-    final private int QUEUE_SIZE = 20;\n-    private PriorityQueue<TxMessage> msgQ;\n     private long srcGlobalSnapshot;\n+    private long recvSeq;\n \n-    StreamsSnapshotWriter() {\n-        //init rt, streamUUIDs, srcGlobalSnapshot\n-        msgQ = new PriorityQueue(QUEUE_SIZE, Comparator.comparingLong(a ->(((TxMessage)a).metadata.entryTimeStamp)));\n+    /**\n+     * open all streams interested\n+     */\n+    void openStreams() {\n+        for (String stream : streams) {\n+            UUID streamID = CorfuRuntime.getStreamID(stream);\n+            IStreamView sv = rt.getStreamsView().getUnsafe(streamID);\n+            streamViewMap.put(streamID, sv);\n+        }\n+    }\n+\n+    StreamsSnapshotWriter(CorfuRuntime rt, Set<String> streams) {\n+        this.rt = rt;\n+        this.streams = streams;\n+        openStreams();\n     }\n \n     /**\n      * clear all tables interested\n      */\n     void clearTables() {\n-        for (UUID stream : streamUUIDs) {\n+        for (String stream : streams) {\n+            UUID streamID = CorfuRuntime.getStreamID(stream);\n             CorfuTable<String, String> corfuTable = rt.getObjectsView()\n                     .build()\n                     .setTypeToken(new TypeToken<CorfuTable<String, String>>() {\n                     })\n-                    .setStreamID(stream)\n+                    .setStreamID(streamID)\n                     .open();\n             corfuTable.clear();\n             corfuTable.close();\n         }\n     }\n \n-    /**\n-     * open all streams interested\n-     */\n-    void openStreams() {\n-        for (UUID streamID : streamUUIDs) {\n-            IStreamView sv = rt.getStreamsView().getUnsafe(streamID);\n-            streamViewMap.put(streamID, sv);\n-        }\n-    }\n-\n-    void processSMREntries(UUID streamId, List<SMREntry> entries) {\n-        for (SMREntry entry : entries) {\n-            streamViewMap.get(streamId).append(entry);\n-        }\n-    }\n-\n     /**\n      * if the metadata has wrong message type or baseSnapshot, throw an exception\n      * @param metadata\n      * @return\n      */\n-    void verifyMetadata(MessageMetadata metadata) {\n-    }\n-\n-    // If the message is out of order, buffer it. If buffer is overflown, thrown an exception.\n-    // Will define the exception type later.\n-    // will use Maithem's api to query the msg to get the uuid and\n-    // list of smr entries\n-    void processTxMessage(TxMessage msg) throws Exception {\n-        MessageMetadata metadata = msg.getMetadata();\n-        verifyMetadata(metadata);\n-        TxMessage currentMsg = null;\n-\n-        //decide to queue message or not according the snapshot value\n-        if (metadata.getPreviousEntryTimestamp() > proccessedMsgTs) {\n-            msgQ.add(msg);\n-            TxMessage first = msgQ.peek();\n-            if (first.getMetadata().getPreviousEntryTimestamp() == proccessedMsgTs) {\n-                currentMsg = msgQ.poll();\n-            }\n-        } else if (metadata.getPreviousEntryTimestamp() == proccessedMsgTs){\n-            currentMsg = msg;\n-        }\n-\n-        if (currentMsg != null) {\n-            // process the message\n-            //UUID streamID = streamUUIDs.get(0);\n-            //List<SMREntry> entries; //get the entries from the msg\n-            //processSMREntries(streamID, entries);\n+    void verifyMetadata(MessageMetadata metadata) throws Exception {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIxMTYwOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376211609", "bodyText": "does this inequality work with a NON_ADDRESS", "author": "medhavidhawan", "createdAt": "2020-02-07T04:39:15Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {\n+    private Set<String> streams;\n     private List<UUID> streamUUIDs;\n     HashMap<UUID, IStreamView> streamViewMap;\n     CorfuRuntime rt;\n-    long proccessedMsgTs;\n-    final private int QUEUE_SIZE = 20;\n     private long srcGlobalSnapshot;\n-    private long lastSrcAddressProcessed;\n-    private PriorityQueue<TxMessage> msgQ;\n-\n-    LogEntryWriter() {\n-        msgQ = new PriorityQueue(QUEUE_SIZE, Comparator.comparingLong(\n-                a ->(((TxMessage)a).metadata.entryTimeStamp)));\n-    }\n-\n-    void verifyMetadata(MessageMetadata metadata) {\n+    long lastMsgTs;\n+    private final int MAX_MSG_QUE_SIZE = 20;\n+    private HashMap<Long, TxMessage> msgQ; //If the received messages are out of order, buffer them. Can be queried according to the preTs.\n \n+    LogEntryWriter(CorfuRuntime rt, LogReplicationConfig config) {\n+        this.rt = rt;\n+        this.streams = config.getStreamsToReplicate();\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n+        msgQ = new HashMap<>();\n+        srcGlobalSnapshot = Address.NON_ADDRESS;\n+        lastMsgTs = Address.NON_ADDRESS;\n     }\n \n-    void processTxMessage(TxMessage msg) {\n-        MessageMetadata metadata = msg.getMetadata();\n-        verifyMetadata(metadata);\n-        TxMessage currentMsg = null;\n-\n-        assert(metadata.getPreviousEntryTimestamp() == proccessedMsgTs);\n-        for (UUID streamID : streamUUIDs) {\n-            ILogData logData = null;\n-            MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry)logData.getPayload(rt);\n-            for (SMREntry entry : multiObjSMREntry.getSMRUpdates(streamID)) {\n-                streamViewMap.get(streamID).append(entry);\n-            }\n+    /**\n+     *\n+     * @param metadata\n+     * @throws Exception\n+     */\n+    void verifyMetadata(MessageMetadata metadata) throws Exception {\n+        if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) {\n+            log.error(\"Wrong message metadata {}, expecting  type {} snapshot {}\", metadata,\n+                    MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot);\n+            throw new Exception(\"wrong type of message\");\n         }\n     }\n \n     /**\n-     * find the msg whose\n-     * @param preAddress\n-     * @return\n+     * Convert message data to an MultiObjectSMREntry and write to log.\n+     * @param txMessage\n      */\n-    TxMessage findMsg(long preAddress) {\n-        //delete all message whose address < preAddress\n-        //return the msg whose preAddress == preAddress\n-        return new TxMessage();\n-    }\n+    void processMsg(TxMessage txMessage) {\n+        OpaqueEntry opaqueEntry = OpaqueEntry.deserialize(Unpooled.wrappedBuffer(txMessage.getData()));\n+        Map<UUID, List<SMREntry>> map = opaqueEntry.getEntries();\n+        if (!streamUUIDs.contains(map.keySet())) {\n+            log.error(\"txMessage contains noisy streams {}, expecting {}\", map.keySet(), streamUUIDs);\n+        }\n+        try {\n+            rt.getObjectsView().TXBegin();\n+            TokenResponse tokenResponse = rt.getSequencerView().next((UUID[])(map.keySet().toArray()));\n+            MultiObjectSMREntry multiObjectSMREntry = new MultiObjectSMREntry();\n+            for (UUID uuid : opaqueEntry.getEntries().keySet()) {\n+                for(SMREntry smrEntry : opaqueEntry.getEntries().get(uuid)) {\n+                    multiObjectSMREntry.addTo(uuid, smrEntry);\n+                }\n+            }\n+            rt.getAddressSpaceView().write(tokenResponse.getToken(), multiObjectSMREntry);\n \n-    void setContext(long snapshot) {\n-        srcGlobalSnapshot = snapshot;\n-        lastSrcAddressProcessed = snapshot;\n+        } finally {\n+            rt.getObjectsView().TXEnd();\n+        }\n     }\n \n-    //Question? what the size of the deltaQue? Is it a in memory que or persistent que?\n-    void processDeltaQue() {\n+    /**\n+     * Go over the queue, if the next expecting msg is in queue, process it.\n+     * @throws Exception\n+     */\n+    void processQue() throws Exception {\n         while (true) {\n-            TxMessage msg = findMsg(lastSrcAddressProcessed);\n-            if (msg == null) {\n+            TxMessage txMessage = msgQ.get(lastMsgTs);\n+            if (txMessage == null) {\n                 return;\n             }\n+            processMsg(txMessage);\n+            msgQ.remove(lastMsgTs);\n+            lastMsgTs = txMessage.getMetadata().getEntryTimeStamp();\n+        }\n+    }\n+\n+    void applyTxMessage(TxMessage msg) throws Exception {\n+        verifyMetadata(msg.getMetadata());\n+\n+        // Ignore the out of date messages\n+        if (msg.getMetadata().getSnapshotTimestamp() < srcGlobalSnapshot) {\n+            log.warn(\"Received message with snapshot {} is smaller than current snapshot {}.Ignore it\",\n+                    msg.getMetadata().getSnapshotTimestamp(), srcGlobalSnapshot);\n+            return;\n+        }\n+\n+        // A new full sync happens, setup the new srcGlobalSnapshot\n+        if (msg.getMetadata().getSnapshotTimestamp() > srcGlobalSnapshot) {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIxMjM1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376212358", "bodyText": "when can this happen ? isn't the verify going to throw an exception at the beginning of the method.", "author": "medhavidhawan", "createdAt": "2020-02-07T04:43:58Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/LogEntryWriter.java", "diffHunk": "@@ -1,80 +1,136 @@\n package org.corfudb.logreplication.receiver;\n \n+import io.netty.buffer.Unpooled;\n+import lombok.extern.slf4j.Slf4j;\n import org.corfudb.logreplication.MessageMetadata;\n+import org.corfudb.logreplication.MessageType;\n+import org.corfudb.logreplication.fsm.LogReplicationConfig;\n import org.corfudb.logreplication.transmitter.TxMessage;\n import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n-import java.util.Comparator;\n+import javax.annotation.concurrent.NotThreadSafe;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.PriorityQueue;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n \n+@NotThreadSafe\n+@Slf4j\n public class LogEntryWriter {\n+    private Set<String> streams;\n     private List<UUID> streamUUIDs;\n     HashMap<UUID, IStreamView> streamViewMap;\n     CorfuRuntime rt;\n-    long proccessedMsgTs;\n-    final private int QUEUE_SIZE = 20;\n     private long srcGlobalSnapshot;\n-    private long lastSrcAddressProcessed;\n-    private PriorityQueue<TxMessage> msgQ;\n-\n-    LogEntryWriter() {\n-        msgQ = new PriorityQueue(QUEUE_SIZE, Comparator.comparingLong(\n-                a ->(((TxMessage)a).metadata.entryTimeStamp)));\n-    }\n-\n-    void verifyMetadata(MessageMetadata metadata) {\n+    long lastMsgTs;\n+    private final int MAX_MSG_QUE_SIZE = 20;\n+    private HashMap<Long, TxMessage> msgQ; //If the received messages are out of order, buffer them. Can be queried according to the preTs.\n \n+    LogEntryWriter(CorfuRuntime rt, LogReplicationConfig config) {\n+        this.rt = rt;\n+        this.streams = config.getStreamsToReplicate();\n+        for (String s : streams) {\n+            streamUUIDs.add(CorfuRuntime.getStreamID(s));\n+        }\n+        msgQ = new HashMap<>();\n+        srcGlobalSnapshot = Address.NON_ADDRESS;\n+        lastMsgTs = Address.NON_ADDRESS;\n     }\n \n-    void processTxMessage(TxMessage msg) {\n-        MessageMetadata metadata = msg.getMetadata();\n-        verifyMetadata(metadata);\n-        TxMessage currentMsg = null;\n-\n-        assert(metadata.getPreviousEntryTimestamp() == proccessedMsgTs);\n-        for (UUID streamID : streamUUIDs) {\n-            ILogData logData = null;\n-            MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry)logData.getPayload(rt);\n-            for (SMREntry entry : multiObjSMREntry.getSMRUpdates(streamID)) {\n-                streamViewMap.get(streamID).append(entry);\n-            }\n+    /**\n+     *\n+     * @param metadata\n+     * @throws Exception\n+     */\n+    void verifyMetadata(MessageMetadata metadata) throws Exception {\n+        if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) {\n+            log.error(\"Wrong message metadata {}, expecting  type {} snapshot {}\", metadata,\n+                    MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot);\n+            throw new Exception(\"wrong type of message\");\n         }\n     }\n \n     /**\n-     * find the msg whose\n-     * @param preAddress\n-     * @return\n+     * Convert message data to an MultiObjectSMREntry and write to log.\n+     * @param txMessage\n      */\n-    TxMessage findMsg(long preAddress) {\n-        //delete all message whose address < preAddress\n-        //return the msg whose preAddress == preAddress\n-        return new TxMessage();\n-    }\n+    void processMsg(TxMessage txMessage) {\n+        OpaqueEntry opaqueEntry = OpaqueEntry.deserialize(Unpooled.wrappedBuffer(txMessage.getData()));\n+        Map<UUID, List<SMREntry>> map = opaqueEntry.getEntries();\n+        if (!streamUUIDs.contains(map.keySet())) {\n+            log.error(\"txMessage contains noisy streams {}, expecting {}\", map.keySet(), streamUUIDs);\n+        }\n+        try {\n+            rt.getObjectsView().TXBegin();\n+            TokenResponse tokenResponse = rt.getSequencerView().next((UUID[])(map.keySet().toArray()));\n+            MultiObjectSMREntry multiObjectSMREntry = new MultiObjectSMREntry();\n+            for (UUID uuid : opaqueEntry.getEntries().keySet()) {\n+                for(SMREntry smrEntry : opaqueEntry.getEntries().get(uuid)) {\n+                    multiObjectSMREntry.addTo(uuid, smrEntry);\n+                }\n+            }\n+            rt.getAddressSpaceView().write(tokenResponse.getToken(), multiObjectSMREntry);\n \n-    void setContext(long snapshot) {\n-        srcGlobalSnapshot = snapshot;\n-        lastSrcAddressProcessed = snapshot;\n+        } finally {\n+            rt.getObjectsView().TXEnd();\n+        }\n     }\n \n-    //Question? what the size of the deltaQue? Is it a in memory que or persistent que?\n-    void processDeltaQue() {\n+    /**\n+     * Go over the queue, if the next expecting msg is in queue, process it.\n+     * @throws Exception\n+     */\n+    void processQue() throws Exception {\n         while (true) {\n-            TxMessage msg = findMsg(lastSrcAddressProcessed);\n-            if (msg == null) {\n+            TxMessage txMessage = msgQ.get(lastMsgTs);\n+            if (txMessage == null) {\n                 return;\n             }\n+            processMsg(txMessage);\n+            msgQ.remove(lastMsgTs);\n+            lastMsgTs = txMessage.getMetadata().getEntryTimeStamp();\n+        }\n+    }\n+\n+    void applyTxMessage(TxMessage msg) throws Exception {\n+        verifyMetadata(msg.getMetadata());\n+\n+        // Ignore the out of date messages\n+        if (msg.getMetadata().getSnapshotTimestamp() < srcGlobalSnapshot) {\n+            log.warn(\"Received message with snapshot {} is smaller than current snapshot {}.Ignore it\",\n+                    msg.getMetadata().getSnapshotTimestamp(), srcGlobalSnapshot);\n+            return;\n+        }\n+\n+        // A new full sync happens, setup the new srcGlobalSnapshot\n+        if (msg.getMetadata().getSnapshotTimestamp() > srcGlobalSnapshot) {", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5MDIyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376590225", "bodyText": "The leadership change, the new leader does a new snapshot sync and a new delta sync.", "author": "xiaoqin2012", "createdAt": "2020-02-07T20:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIxMjM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIxMjYzNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376212634", "bodyText": "do we need more specific exception or is this ok ?", "author": "medhavidhawan", "createdAt": "2020-02-07T04:45:33Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/SnapshotWriter.java", "diffHunk": "@@ -6,7 +6,7 @@\n \n public interface SnapshotWriter {\n \n-    void apply(TxMessage message);\n+    void apply(TxMessage message) throws Exception;", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIxMjY2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2375#discussion_r376212667", "bodyText": "comments are missing on the interface.", "author": "medhavidhawan", "createdAt": "2020-02-07T04:45:46Z", "path": "log-replication/src/main/java/org/corfudb/logreplication/receiver/SnapshotWriter.java", "diffHunk": "@@ -6,7 +6,7 @@\n \n public interface SnapshotWriter {\n \n-    void apply(TxMessage message);\n+    void apply(TxMessage message) throws Exception;", "originalCommit": "24386ba1c47876f74619ffb1a8145bd7f016a056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "89e49dc033704889df3dc851840e3bbb57648e27", "url": "https://github.com/CorfuDB/CorfuDB/commit/89e49dc033704889df3dc851840e3bbb57648e27", "message": "Address comments.", "committedDate": "2020-02-07T20:32:45Z", "type": "commit"}, {"oid": "0de74652fc35a305daabb23f8fd34afa4ddb0475", "url": "https://github.com/CorfuDB/CorfuDB/commit/0de74652fc35a305daabb23f8fd34afa4ddb0475", "message": "Merge branch 'federation' into xq/fed04", "committedDate": "2020-02-07T20:42:05Z", "type": "commit"}]}