{"pr_number": 2634, "pr_title": "Add Log Replication Cluster Role ITs", "pr_createdAt": "2020-07-14T23:04:42Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2634", "timeline": [{"oid": "a7843225315a68e819991be444f5dea76fad650e", "url": "https://github.com/CorfuDB/CorfuDB/commit/a7843225315a68e819991be444f5dea76fad650e", "message": "Add Log Replication Cluster Role ITs", "committedDate": "2020-07-16T18:59:29Z", "type": "forcePushed"}, {"oid": "8c8d92fda4514da535e4abc56cc01dca1b15f059", "url": "https://github.com/CorfuDB/CorfuDB/commit/8c8d92fda4514da535e4abc56cc01dca1b15f059", "message": "Add Log Replication Cluster Role ITs", "committedDate": "2020-07-16T19:13:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxNjU3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456016578", "bodyText": "Even if current node's role did not change, it does not guarantee that others' role or config id is not changed...\nSo updating sender/receiver's config id is necessary here.", "author": "zhangn49", "createdAt": "2020-07-16T19:19:46Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -578,15 +581,18 @@ private void onStandbyClusterAddRemove(TopologyDescriptor discoveredTopology) {\n         log.debug(\"Standby Cluster has been added or removed from topology={}\", discoveredTopology);\n \n         // We only need to process new standby's if your role is of an ACTIVE cluster\n-        if (localClusterDescriptor.getRole() == ClusterRole.STANDBY) {\n-            return;\n-        }\n-\n-        if (replicationManager != null && isLeader.get()) {\n-            replicationManager.processStandbyChange(discoveredTopology);\n+        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n+            if (replicationManager != null && isLeader.get()) {\n+                replicationManager.processStandbyChange(discoveredTopology);\n+            }\n         }\n \n         updateLocalTopology(discoveredTopology);\n+        updateReplicationManagerTopology(discoveredTopology);\n+        // Update topology config id in metadata manager\n+        logReplicationMetadataManager.setupTopologyConfigId(topologyDescriptor.getTopologyConfigId());\n+        log.debug(\"Persist new topologyConfigId {}, cluster id={}, status={}\", topologyDescriptor.getTopologyConfigId(),\n+                localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());", "originalCommit": "8c8d92fda4514da535e4abc56cc01dca1b15f059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0MTk5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456041993", "bodyText": "We have three update*** functions here, can you add comments about what they are doing? We keep the topologyConfigID at SinkManager and also for each logReplication Runtime. Is it possible to just keep one reference instead of multi like handling leaderShip?", "author": "xiaoqin2012", "createdAt": "2020-07-16T19:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxNjU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxNzc2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456017763", "bodyText": "We do not assume that config id change implies a role change, so it is possible that we have a higher config id.", "author": "zhangn49", "createdAt": "2020-07-16T19:21:39Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java", "diffHunk": "@@ -177,35 +179,41 @@ private void stopLogReplicationRuntime(String remoteClusterId) {\n         }\n     }\n \n+    /**\n+     * Update Log Replication Runtime config id.\n+     */\n+    public void updateRuntimeConfigId(TopologyDescriptor newConfig) {\n+        runtimeToRemoteCluster.values().forEach(runtime -> runtime.updateFSMConfigId(newConfig));\n+    }\n+\n     /**\n      * The notification of change of adding/removing standby's without epoch change.\n      *\n      * @param newConfig has the same topologyConfigId as the current config\n      */\n     public void processStandbyChange(TopologyDescriptor newConfig) {\n         if (newConfig.getTopologyConfigId() != topology.getTopologyConfigId()) {\n-            log.error(\"Detected changes in the topology. The new topology descriptor {} doesn't have the same \" +\n+            log.warn(\"Detected changes in the topology. The new topology descriptor {} doesn't have the same \" +", "originalCommit": "8c8d92fda4514da535e4abc56cc01dca1b15f059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1MDExNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456050116", "bodyText": "We may add more comments to the function to explain in what conditions this function will be called.", "author": "xiaoqin2012", "createdAt": "2020-07-16T20:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxNzc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4NjU1NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459786554", "bodyText": "if the topologyId can change on a standby change, why are we logging it as a warning?  Yes, it will be good to add comments stating any assumptions/expectations", "author": "pankti-m", "createdAt": "2020-07-23T23:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxNzc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwOTY5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459809694", "bodyText": "Ideally, there is no config id change when we only processStandbyChange. I will add a short comment.", "author": "zhangn49", "createdAt": "2020-07-24T01:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxNzc2Mw=="}], "type": "inlineReview"}, {"oid": "8683374605c376a5d2b2372c1ac090e903703a4b", "url": "https://github.com/CorfuDB/CorfuDB/commit/8683374605c376a5d2b2372c1ac090e903703a4b", "message": "Add Log Replication Cluster Role ITs", "committedDate": "2020-07-16T19:24:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAyMjc3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456022779", "bodyText": "Since there is no way to make sure apply completes before the writer reset, we do not support DuringTransferPhase & DuringApplyPhase now.", "author": "zhangn49", "createdAt": "2020-07-16T19:28:38Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -93,104 +91,520 @@ public void testLogReplicationRoleFlip() throws Exception {\n         assertThat(mapActive.size()).isZero();\n         assertThat(mapStandby.size()).isZero();\n \n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n         // Write 10 entry to active map\n         for (int i = 0; i < firstBatch; i++) {\n             activeRuntime.getObjectsView().TXBegin();\n             mapActive.put(String.valueOf(i), i);\n             activeRuntime.getObjectsView().TXEnd();\n         }\n         assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n \n-        System.out.println(\"First batch size is \" + firstBatch + \", current standby tail is \" +\n-                standbyRuntime.getAddressSpaceView().getLogTail() + \", and active tail is \" +\n-                activeRuntime.getAddressSpaceView().getLogTail());\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        //assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n \n-        ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync transfer phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Perform a role switch with corfu store\n+     * 5. Standby will drop messages and keep size 0\n+     * 6. Verify active map becomes size 0, since source size is 0\n+     */\n+    //@Test", "originalCommit": "8683374605c376a5d2b2372c1ac090e903703a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0844c5736f25bc52d186178fb5d5099fb711d097", "url": "https://github.com/CorfuDB/CorfuDB/commit/0844c5736f25bc52d186178fb5d5099fb711d097", "message": "Add Log Replication Cluster Role ITs", "committedDate": "2020-07-16T19:52:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0OTY3Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456049672", "bodyText": "If the topologyConfigId has been change, it will overrule the processStandbyChange. processStandbyChange only is called when the topologyConfigId doesn't change and the list of standbys have been changed.\nIs the logic correct that processStandbyChange called before updating the localTopology?", "author": "xiaoqin2012", "createdAt": "2020-07-16T20:12:20Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -578,15 +581,18 @@ private void onStandbyClusterAddRemove(TopologyDescriptor discoveredTopology) {\n         log.debug(\"Standby Cluster has been added or removed from topology={}\", discoveredTopology);\n \n         // We only need to process new standby's if your role is of an ACTIVE cluster\n-        if (localClusterDescriptor.getRole() == ClusterRole.STANDBY) {\n-            return;\n-        }\n-\n-        if (replicationManager != null && isLeader.get()) {\n-            replicationManager.processStandbyChange(discoveredTopology);\n+        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n+            if (replicationManager != null && isLeader.get()) {\n+                replicationManager.processStandbyChange(discoveredTopology);\n+            }", "originalCommit": "0844c5736f25bc52d186178fb5d5099fb711d097", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyOTcxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456129718", "bodyText": "Since we don't assume that config id change implies a role change anymore, processStandbyChange won't be overruled. Now we only detect if local node role changes or not, then perform onClusterRoleChange  or onStandbyClusterAddRemove\n\nIs the logic correct that processStandbyChange called before updating the localTopology?\n\nI think the logic is correct, since stopping old replication relies on old config.", "author": "zhangn49", "createdAt": "2020-07-16T23:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0OTY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1MTM3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456051378", "bodyText": "Can we also add a check of the log replication metadata at the standby side. It should indicate a status of snapshot full sync has finished and the timestamp for the snapshot full sync should agree with the current active log tail.", "author": "xiaoqin2012", "createdAt": "2020-07-16T20:15:46Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -93,104 +91,520 @@ public void testLogReplicationRoleFlip() throws Exception {\n         assertThat(mapActive.size()).isZero();\n         assertThat(mapStandby.size()).isZero();\n \n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n         // Write 10 entry to active map\n         for (int i = 0; i < firstBatch; i++) {\n             activeRuntime.getObjectsView().TXBegin();\n             mapActive.put(String.valueOf(i), i);\n             activeRuntime.getObjectsView().TXEnd();\n         }\n         assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +", "originalCommit": "0844c5736f25bc52d186178fb5d5099fb711d097", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzMDk4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456130982", "bodyText": "Yeah, it makes sense to check metadata. I need to add helper functions to do some Corfu table queries...\nI will make sure this PR's logic is correct, then I will have a look at metadata tables and add extra checks.", "author": "zhangn49", "createdAt": "2020-07-16T23:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1MTM3OA=="}], "type": "inlineReview"}, {"oid": "1904a08f904a24f2fb8cb61006568dce59e81f5f", "url": "https://github.com/CorfuDB/CorfuDB/commit/1904a08f904a24f2fb8cb61006568dce59e81f5f", "message": "Add Log Replication Cluster Role ITs", "committedDate": "2020-07-20T18:02:25Z", "type": "forcePushed"}, {"oid": "946999817492aa9fca1f041c7d76ba6815974ab2", "url": "https://github.com/CorfuDB/CorfuDB/commit/946999817492aa9fca1f041c7d76ba6815974ab2", "message": "Add Log Replication Cluster Role ITs", "committedDate": "2020-07-20T18:06:34Z", "type": "forcePushed"}, {"oid": "fd6336ceced3b28d43c705b2576499358c0773e9", "url": "https://github.com/CorfuDB/CorfuDB/commit/fd6336ceced3b28d43c705b2576499358c0773e9", "message": "Fix Travis", "committedDate": "2020-07-21T21:15:10Z", "type": "forcePushed"}, {"oid": "946999817492aa9fca1f041c7d76ba6815974ab2", "url": "https://github.com/CorfuDB/CorfuDB/commit/946999817492aa9fca1f041c7d76ba6815974ab2", "message": "Add Log Replication Cluster Role ITs", "committedDate": "2020-07-20T18:06:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI0NjI2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456246260", "bodyText": "Replace with:\nthis(topologyConfigId, activeClusters, standbyClusters); invalidClusters.forEach(invalidCluster -> this.invalidClusters.put(invalidCluster.getClusterId(), invalidCluster));", "author": "annym", "createdAt": "2020-07-17T06:34:52Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/TopologyDescriptor.java", "diffHunk": "@@ -89,13 +90,28 @@ public TopologyDescriptor(long topologyConfigId, @NonNull List<ClusterDescriptor\n         this.standbyClusters = new HashMap<>();\n         this.invalidClusters = new HashMap<>();\n \n-        if(activeClusters != null) {\n-            activeClusters.forEach(activeCluster -> this.activeClusters.put(activeCluster.getClusterId(), activeCluster));\n-        }\n+        activeClusters.forEach(activeCluster -> this.activeClusters.put(activeCluster.getClusterId(), activeCluster));\n+        standbyClusters.forEach(standbyCluster -> this.standbyClusters.put(standbyCluster.getClusterId(), standbyCluster));\n+    }\n \n-        if(standbyClusters != null) {\n-            standbyClusters.forEach(standbyCluster -> this.standbyClusters.put(standbyCluster.getClusterId(), standbyCluster));\n-        }\n+    /**\n+     * Constructor\n+     *\n+     * @param topologyConfigId topology configuration identifier (epoch)\n+     * @param activeClusters active cluster's\n+     * @param standbyClusters standby cluster's\n+     * @param invalidClusters invalid cluster's\n+     */\n+    public TopologyDescriptor(long topologyConfigId, @NonNull List<ClusterDescriptor> activeClusters,\n+                              @NonNull List<ClusterDescriptor> standbyClusters, @NonNull List<ClusterDescriptor> invalidClusters) {\n+        this.topologyConfigId = topologyConfigId;", "originalCommit": "0844c5736f25bc52d186178fb5d5099fb711d097", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI0Njg1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r456246855", "bodyText": "We should fix this path to point something local in the project repo.", "author": "annym", "createdAt": "2020-07-17T06:36:29Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -1,33 +1,49 @@\n package org.corfudb.infrastructure.logreplication.infrastructure.plugins;\n \n import lombok.Getter;\n+import lombok.NonNull;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.infrastructure.logreplication.infrastructure.ClusterDescriptor;\n import org.corfudb.infrastructure.logreplication.infrastructure.NodeDescriptor;\n import org.corfudb.infrastructure.logreplication.infrastructure.TopologyDescriptor;\n-import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo.TopologyConfigurationMsg;\n import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo.ClusterRole;\n+import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo.TopologyConfigurationMsg;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.CorfuStoreMetadata;\n+import org.corfudb.runtime.Messages;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuStreamEntries;\n+import org.corfudb.runtime.collections.CorfuStreamEntry;\n+import org.corfudb.runtime.collections.StreamListener;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.collections.TableSchema;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n \n import java.io.File;\n-import java.io.FileNotFoundException;\n import java.io.FileReader;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Properties;\n import java.util.Set;\n import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n \n-import static java.lang.Thread.sleep;\n-\n+/**\n+ * This class extends CorfuReplicationClusterManagerAdapter, provides topology config API\n+ * for integration tests. The initial topology config should be valid, which means it has only\n+ * one active cluster, and one or more standby clusters.\n+ */\n @Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n public class DefaultClusterManager extends CorfuReplicationClusterManagerBaseAdapter {\n-    public static long epoch = 0;\n-    public static final int changeInterval = 5000;\n-    public static final String config_file = \"/config/corfu/corfu_replication_config.properties\";\n+    public static final String CONFIG_FILE_PATH = \"/config/corfu/corfu_replication_config.properties\";", "originalCommit": "0844c5736f25bc52d186178fb5d5099fb711d097", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5NzUwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r457797500", "bodyText": "Just for completeness, can you please remove the TODO at the beginning of this method and also add a comment describing that cluster change from active to standby is a two step process. We first confirm that we are ready to do the cluster role change, so by the time we receive that change of cluster notification, nothing needs to be done, other than stop.", "author": "annym", "createdAt": "2020-07-21T02:23:44Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -510,6 +510,9 @@ public void onClusterRoleChange(TopologyDescriptor newTopology) {\n         log.debug(\"Persist new topologyConfigId {}, cluster id={}, status={}\", topologyDescriptor.getTopologyConfigId(),\n                 localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n \n+        // Update replication manager", "originalCommit": "e4e49b58949ad335573f1110ea7246f8c79a8822", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5NzcxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r457797714", "bodyText": "status -> role", "author": "annym", "createdAt": "2020-07-21T02:24:30Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -510,6 +510,9 @@ public void onClusterRoleChange(TopologyDescriptor newTopology) {\n         log.debug(\"Persist new topologyConfigId {}, cluster id={}, status={}\", topologyDescriptor.getTopologyConfigId(),", "originalCommit": "e4e49b58949ad335573f1110ea7246f8c79a8822", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5ODE4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r457798188", "bodyText": "Just curious, if we change from active to standby, or we're a standby cluster, there is no need of updating the replication manager topology?...", "author": "annym", "createdAt": "2020-07-21T02:26:01Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -510,6 +510,9 @@ public void onClusterRoleChange(TopologyDescriptor newTopology) {\n         log.debug(\"Persist new topologyConfigId {}, cluster id={}, status={}\", topologyDescriptor.getTopologyConfigId(),\n                 localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n \n+        // Update replication manager\n+        updateReplicationManagerTopology(newTopology);", "originalCommit": "e4e49b58949ad335573f1110ea7246f8c79a8822", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzNDg5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459534893", "bodyText": "Let's assume that we start with topology[0]: {active: A, standby:B}, then update with topology[1]:{standby: A, B}. If we do not update replication manager topology, cluster B will have outdated epoch 0.\nNext time a new active C comes in, topology is [2]{active C, standby:A, B}. For cluster B, its role never changed, and it won't update replication manager topology.", "author": "zhangn49", "createdAt": "2020-07-23T15:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5ODE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwMDg1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r457800850", "bodyText": "Can't this be updated at the end of processStandbyChange.\nAlso, we only want this to run if we are active right? it would also run for standby.", "author": "annym", "createdAt": "2020-07-21T02:35:47Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -578,15 +581,18 @@ private void onStandbyClusterAddRemove(TopologyDescriptor discoveredTopology) {\n         log.debug(\"Standby Cluster has been added or removed from topology={}\", discoveredTopology);\n \n         // We only need to process new standby's if your role is of an ACTIVE cluster\n-        if (localClusterDescriptor.getRole() == ClusterRole.STANDBY) {\n-            return;\n-        }\n-\n-        if (replicationManager != null && isLeader.get()) {\n-            replicationManager.processStandbyChange(discoveredTopology);\n+        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n+            if (replicationManager != null && isLeader.get()) {\n+                replicationManager.processStandbyChange(discoveredTopology);\n+            }\n         }\n \n         updateLocalTopology(discoveredTopology);\n+        updateReplicationManagerTopology(discoveredTopology);", "originalCommit": "e4e49b58949ad335573f1110ea7246f8c79a8822", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzNjE3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459536177", "bodyText": "Just like my example above, we need to keep replication manager's topology epoch updated.", "author": "zhangn49", "createdAt": "2020-07-23T15:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwMDg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4NTIzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459785233", "bodyText": "earlier we invoked updateLocalTopology() and updateReplicationManagerTopology() only on the active but now it will be invoked on standby also.  Is it the intended behavior?", "author": "pankti-m", "createdAt": "2020-07-23T23:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwMDg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwOTMwOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459809309", "bodyText": "@pankti-m  Yes, please see my example at line 515", "author": "zhangn49", "createdAt": "2020-07-24T01:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwMDg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwMTAyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r457801025", "bodyText": "status -> role", "author": "annym", "createdAt": "2020-07-21T02:36:25Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -578,15 +581,18 @@ private void onStandbyClusterAddRemove(TopologyDescriptor discoveredTopology) {\n         log.debug(\"Standby Cluster has been added or removed from topology={}\", discoveredTopology);\n \n         // We only need to process new standby's if your role is of an ACTIVE cluster\n-        if (localClusterDescriptor.getRole() == ClusterRole.STANDBY) {\n-            return;\n-        }\n-\n-        if (replicationManager != null && isLeader.get()) {\n-            replicationManager.processStandbyChange(discoveredTopology);\n+        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n+            if (replicationManager != null && isLeader.get()) {\n+                replicationManager.processStandbyChange(discoveredTopology);\n+            }\n         }\n \n         updateLocalTopology(discoveredTopology);\n+        updateReplicationManagerTopology(discoveredTopology);\n+        // Update topology config id in metadata manager\n+        logReplicationMetadataManager.setupTopologyConfigId(topologyDescriptor.getTopologyConfigId());\n+        log.debug(\"Persist new topologyConfigId {}, cluster id={}, status={}\", topologyDescriptor.getTopologyConfigId(),", "originalCommit": "e4e49b58949ad335573f1110ea7246f8c79a8822", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NTAxNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r458395015", "bodyText": "What are these OP? can we have a general description?", "author": "annym", "createdAt": "2020-07-21T21:20:41Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -41,28 +57,72 @@\n \n     private static final String ACTIVE_CLUSTER_NODE = \"primary_site_node\";\n     private static final String STANDBY_CLUSTER_NODE = \"standby_site_node\";\n-    private boolean ifShutdown = false;\n+\n+\n+    public static final String CONFIG_NAMESPACE = \"ns_lr_config_it\";\n+    public static final String CONFIG_TABLE_NAME = \"lr_config_it\";\n+    public static final CommonTypes.Uuid OP_RESUME = CommonTypes.Uuid.newBuilder().setLsb(0L).setMsb(0L).build();\n+    public static final CommonTypes.Uuid OP_SWITCH = CommonTypes.Uuid.newBuilder().setLsb(1L).setMsb(1L).build();", "originalCommit": "fd6336ceced3b28d43c705b2576499358c0773e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3MDYyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459570624", "bodyText": "It is operations. I think it is kind of ugly to hardcode it and I will try to directly write new config to tables.", "author": "zhangn49", "createdAt": "2020-07-23T16:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NTAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyNTk0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459025944", "bodyText": "we can remove this commented code.", "author": "annym", "createdAt": "2020-07-22T19:18:08Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java", "diffHunk": "@@ -177,35 +179,41 @@ private void stopLogReplicationRuntime(String remoteClusterId) {\n         }\n     }\n \n+    /**\n+     * Update Log Replication Runtime config id.\n+     */\n+    public void updateRuntimeConfigId(TopologyDescriptor newConfig) {\n+        runtimeToRemoteCluster.values().forEach(runtime -> runtime.updateFSMConfigId(newConfig));\n+    }\n+\n     /**\n      * The notification of change of adding/removing standby's without epoch change.\n      *\n      * @param newConfig has the same topologyConfigId as the current config\n      */\n     public void processStandbyChange(TopologyDescriptor newConfig) {\n         if (newConfig.getTopologyConfigId() != topology.getTopologyConfigId()) {\n-            log.error(\"Detected changes in the topology. The new topology descriptor {} doesn't have the same \" +\n+            log.warn(\"Detected changes in the topology. The new topology descriptor {} doesn't have the same \" +\n                     \"topologyConfigId as the current one {}\", newConfig, topology);\n-            return;\n         }\n \n-        Map<String, ClusterDescriptor> newStandbys = newConfig.getStandbyClusters();\n-        Map<String, ClusterDescriptor> currentStandbys = topology.getStandbyClusters();\n-        newStandbys.keySet().retainAll(currentStandbys.keySet());\n-        Set<String> standbysToRemove = currentStandbys.keySet();\n-        standbysToRemove.removeAll(newStandbys.keySet());\n+        Set<String> currentStandbys = new HashSet<>(topology.getStandbyClusters().keySet());\n+        Set<String> newStandbys = new HashSet<>(newConfig.getStandbyClusters().keySet());\n+        Set<String> intersection = Sets.intersection(currentStandbys, newStandbys);\n \n-        /*\n-         * Remove standbys that are not in the new config\n-         */\n+        //standbysToRemove = currentStandbys - intersection", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODI2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459028269", "bodyText": "is this the corfu epoch or topologyConfigId?", "author": "annym", "createdAt": "2020-07-22T19:22:15Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -41,28 +57,72 @@\n \n     private static final String ACTIVE_CLUSTER_NODE = \"primary_site_node\";\n     private static final String STANDBY_CLUSTER_NODE = \"standby_site_node\";\n-    private boolean ifShutdown = false;\n+\n+\n+    public static final String CONFIG_NAMESPACE = \"ns_lr_config_it\";\n+    public static final String CONFIG_TABLE_NAME = \"lr_config_it\";\n+    public static final CommonTypes.Uuid OP_RESUME = CommonTypes.Uuid.newBuilder().setLsb(0L).setMsb(0L).build();\n+    public static final CommonTypes.Uuid OP_SWITCH = CommonTypes.Uuid.newBuilder().setLsb(1L).setMsb(1L).build();\n+    public static final CommonTypes.Uuid OP_TWO_ACTIVE = CommonTypes.Uuid.newBuilder().setLsb(2L).setMsb(2L).build();\n+    public static final CommonTypes.Uuid OP_ALL_STANDBY = CommonTypes.Uuid.newBuilder().setLsb(3L).setMsb(3L).build();\n+    public static final CommonTypes.Uuid OP_INVALID = CommonTypes.Uuid.newBuilder().setLsb(4L).setMsb(4L).build();\n+\n+    @Getter\n+    private long epoch;", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzODYyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459538628", "bodyText": "It is configId. Renamed.", "author": "zhangn49", "createdAt": "2020-07-23T15:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyOTMwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459029307", "bodyText": "Should this exception be thrown so the test fails? or can we proceed without this table being opened in the right way?", "author": "annym", "createdAt": "2020-07-22T19:24:21Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -41,28 +57,72 @@\n \n     private static final String ACTIVE_CLUSTER_NODE = \"primary_site_node\";\n     private static final String STANDBY_CLUSTER_NODE = \"standby_site_node\";\n-    private boolean ifShutdown = false;\n+\n+\n+    public static final String CONFIG_NAMESPACE = \"ns_lr_config_it\";\n+    public static final String CONFIG_TABLE_NAME = \"lr_config_it\";\n+    public static final CommonTypes.Uuid OP_RESUME = CommonTypes.Uuid.newBuilder().setLsb(0L).setMsb(0L).build();\n+    public static final CommonTypes.Uuid OP_SWITCH = CommonTypes.Uuid.newBuilder().setLsb(1L).setMsb(1L).build();\n+    public static final CommonTypes.Uuid OP_TWO_ACTIVE = CommonTypes.Uuid.newBuilder().setLsb(2L).setMsb(2L).build();\n+    public static final CommonTypes.Uuid OP_ALL_STANDBY = CommonTypes.Uuid.newBuilder().setLsb(3L).setMsb(3L).build();\n+    public static final CommonTypes.Uuid OP_INVALID = CommonTypes.Uuid.newBuilder().setLsb(4L).setMsb(4L).build();\n+\n+    @Getter\n+    private long epoch;\n+\n+    @Getter\n+    private boolean shutdown;\n \n     @Getter\n-    public SiteManagerCallback siteManagerCallback;\n+    public ClusterManagerCallback clusterManagerCallback;\n \n     private Thread thread;\n \n+    private CorfuRuntime corfuRuntime;\n \n+    private CorfuStore corfuStore;\n \n     public void start() {\n-        siteManagerCallback = new SiteManagerCallback(this);\n-        thread = new Thread(siteManagerCallback);\n+        epoch = 0L;\n+        shutdown = false;\n+        topologyConfig = constructTopologyConfigMsg();\n+        clusterManagerCallback = new ClusterManagerCallback(this);\n+        corfuRuntime = CorfuRuntime.fromParameters(CorfuRuntime.CorfuRuntimeParameters.builder().build())\n+                .parseConfigurationString(\"localhost:9000\")\n+                .setTransactionLogging(true)\n+                .connect();\n+        corfuStore = new CorfuStore(corfuRuntime);\n+        CorfuStoreMetadata.Timestamp ts = corfuStore.getTimestamp();\n+        try {\n+            Table<Messages.Uuid, Messages.Uuid, Messages.Uuid> table = corfuStore.openTable(\n+                    CONFIG_NAMESPACE, CONFIG_TABLE_NAME,\n+                    Messages.Uuid.class, Messages.Uuid.class, Messages.Uuid.class,\n+                    TableOptions.builder().build()\n+            );\n+            table.clear();\n+        } catch (Exception e) {\n+            // Ignore", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0MzA5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459543095", "bodyText": "Yes, it should be thrown and discovery service will timeout and fail the test.", "author": "zhangn49", "createdAt": "2020-07-23T15:37:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyOTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzNjMwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459036306", "bodyText": "I think we wouldn't support several actives.", "author": "annym", "createdAt": "2020-07-22T19:37:27Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -181,57 +229,151 @@ public TopologyConfigurationMsg queryTopologyConfig(boolean useCached) {\n     }\n \n     /**\n-     * Enforce one of the standby Cluster's to become the new active cluster and current active to become standby\n+     * Create a new topology config, which changes one of the standby as the active,\n+     * and active as standby. Data should flow in the reverse direction.\n      **/\n-    public static TopologyDescriptor changeActiveCluster(TopologyConfigurationMsg topologyConfig) {\n-        TopologyDescriptor topologyDescriptor = new TopologyDescriptor(topologyConfig);\n+    public TopologyDescriptor generateConfigWithRoleSwitch() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n \n-        // Convert the current active to standby\n-        ClusterDescriptor oldActive = topologyDescriptor.getActiveClusters().values().iterator().next();\n-        ClusterDescriptor newStandby = new ClusterDescriptor(oldActive, ClusterRole.STANDBY);\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>();\n+        List<ClusterDescriptor> newStandbyClusters = new ArrayList<>();\n+        currentConfig.getActiveClusters().values().forEach(activeCluster ->\n+                newStandbyClusters.add(new ClusterDescriptor(activeCluster, ClusterRole.STANDBY)));\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newActiveClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE)));", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1NjkwOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459556908", "bodyText": "Yes, done.", "author": "zhangn49", "createdAt": "2020-07-23T15:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzNjMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0OTUyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459049525", "bodyText": "If I understand correctly, you are using this Listener, to determine changes in the topology if ever it is changed in the table, correct?\nIf that is true, then the ClusterManagerCallback is not really required, correct? you can just call clusterManager.updateTopologyConfig directly on the streamListener.", "author": "annym", "createdAt": "2020-07-22T20:02:00Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -181,57 +229,151 @@ public TopologyConfigurationMsg queryTopologyConfig(boolean useCached) {\n     }\n \n     /**\n-     * Enforce one of the standby Cluster's to become the new active cluster and current active to become standby\n+     * Create a new topology config, which changes one of the standby as the active,\n+     * and active as standby. Data should flow in the reverse direction.\n      **/\n-    public static TopologyDescriptor changeActiveCluster(TopologyConfigurationMsg topologyConfig) {\n-        TopologyDescriptor topologyDescriptor = new TopologyDescriptor(topologyConfig);\n+    public TopologyDescriptor generateConfigWithRoleSwitch() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n \n-        // Convert the current active to standby\n-        ClusterDescriptor oldActive = topologyDescriptor.getActiveClusters().values().iterator().next();\n-        ClusterDescriptor newStandby = new ClusterDescriptor(oldActive, ClusterRole.STANDBY);\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>();\n+        List<ClusterDescriptor> newStandbyClusters = new ArrayList<>();\n+        currentConfig.getActiveClusters().values().forEach(activeCluster ->\n+                newStandbyClusters.add(new ClusterDescriptor(activeCluster, ClusterRole.STANDBY)));\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newActiveClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE)));\n \n-        List<ClusterDescriptor> standbyClusters = Arrays.asList(newStandby);\n-        ClusterDescriptor newPrimary = null;\n+        return new TopologyDescriptor(++epoch, newActiveClusters, newStandbyClusters);\n+    }\n \n-        for (ClusterDescriptor standbyCluster : topologyDescriptor.getStandbyClusters().values()) {\n-            if (newPrimary == null) {\n-                newPrimary = new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE);\n-            } else {\n-                standbyClusters.add(standbyCluster);\n-            }\n-        }\n+    /**\n+     * Create a new topology config, which marks all standby cluster as active on purpose.\n+     * System should drop messages between any two active clusters.\n+     **/\n+    public TopologyDescriptor generateConfigWithAllActive() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+        ClusterDescriptor currentActive = currentConfig.getActiveClusters().values().iterator().next();\n+\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>();\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newActiveClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE)));\n+        newActiveClusters.add(currentActive);\n+\n+        return new TopologyDescriptor(++epoch, newActiveClusters, new ArrayList<>());\n+    }\n \n-        TopologyDescriptor newSiteConf = new TopologyDescriptor(1L, Arrays.asList(newPrimary), standbyClusters);\n-        return newSiteConf;\n+    /**\n+     * Create a new topology config, which marks all cluster as standby on purpose.\n+     * System should not send messages in this case.\n+     **/\n+    public TopologyDescriptor generateConfigWithAllStandby() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+        ClusterDescriptor currentActive = currentConfig.getActiveClusters().values().iterator().next();\n+\n+        List<ClusterDescriptor> newStandbyClusters = new ArrayList<>(currentConfig.getStandbyClusters().values());\n+        ClusterDescriptor newStandby = new ClusterDescriptor(currentActive, ClusterRole.STANDBY);\n+        newStandbyClusters.add(newStandby);\n+\n+        return new TopologyDescriptor(++epoch, new ArrayList<>(), newStandbyClusters);\n+    }\n+\n+    /**\n+     * Create a new topology config, which marks all standby cluster as invalid on purpose.\n+     * System should not send messages in this case.\n+     **/\n+    public TopologyDescriptor generateConfigWithInvalid() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>(currentConfig.getActiveClusters().values());\n+        List<ClusterDescriptor> newInvalidClusters = new ArrayList<>();\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newInvalidClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.INVALID)));\n+\n+        return new TopologyDescriptor(++epoch, newActiveClusters, new ArrayList<>(), newInvalidClusters);\n+    }\n+\n+    /**\n+     * Bring topology config back to default valid config.\n+     **/\n+    public TopologyDescriptor generateDefaultValidConfig() {\n+        TopologyDescriptor defaultTopology = new TopologyDescriptor(constructTopologyConfigMsg());\n+        List<ClusterDescriptor> activeClusters = new ArrayList<>(defaultTopology.getActiveClusters().values());\n+        List<ClusterDescriptor> standbyClusters = new ArrayList<>(defaultTopology.getStandbyClusters().values());\n+\n+        return new TopologyDescriptor(++epoch, activeClusters, standbyClusters);\n     }\n \n     /**\n      * Testing purpose to generate cluster role change.\n      */\n-    public static class SiteManagerCallback implements Runnable {\n-        public boolean clusterRoleChange = false;\n-        DefaultClusterManager clusterManager;\n+    public static class ClusterManagerCallback implements Runnable {\n+        private final DefaultClusterManager clusterManager;\n+        private final LinkedBlockingQueue<TopologyDescriptor> queue;\n \n-        SiteManagerCallback(DefaultClusterManager clusterManager) {\n+        public ClusterManagerCallback(DefaultClusterManager clusterManager) {\n             this.clusterManager = clusterManager;\n+            queue = new LinkedBlockingQueue<>();\n+        }\n+\n+        public void applyNewTopologyConfig(@NonNull TopologyDescriptor descriptor) {\n+            log.info(\"Applying a new config {}\", descriptor);\n+            queue.add(descriptor);\n         }\n \n         @Override\n         public void run() {\n-            while (!clusterManager.ifShutdown) {\n+            while (!clusterManager.isShutdown()) {\n                 try {\n-                    sleep(changeInterval);\n-                    if (clusterRoleChange) {\n-                        TopologyDescriptor newConfig = changeActiveCluster(clusterManager.getTopologyConfig());\n-                        clusterManager.updateTopologyConfig(newConfig.convertToMessage());\n-                        log.warn(\"Change the cluster config\");\n-                        clusterRoleChange = false;\n-                    }\n-                } catch (Exception e) {\n-                    log.error(\"Caught an exception\",e);\n+                    TopologyDescriptor newConfig = queue.take();\n+                    clusterManager.updateTopologyConfig(newConfig.convertToMessage());\n+                    log.warn(\"change the cluster config\");\n+                } catch (InterruptedException ie) {\n+                    throw new UnrecoverableCorfuInterruptedError(ie);\n                 }\n             }\n         }\n     }\n \n+    public static class ConfigStreamListener implements StreamListener {", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1OTE0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459559141", "bodyText": "Yes, it is not required.", "author": "zhangn49", "createdAt": "2020-07-23T16:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0OTUyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5ODk5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459798998", "bodyText": "why do we need to use the table and a listener on it?  The test can just iterate thru all cases and inject different topologies right?", "author": "pankti-m", "createdAt": "2020-07-24T00:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0OTUyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMDU3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459810573", "bodyText": "@pankti-m Listener enables us not to busy-wait.", "author": "zhangn49", "createdAt": "2020-07-24T01:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0OTUyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMTY1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459811657", "bodyText": "... not sure if I understand, but we can discuss this offline.  It is not a functional issue.", "author": "pankti-m", "createdAt": "2020-07-24T01:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0OTUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1MDA4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459050088", "bodyText": "Can we add a short description to this class?", "author": "annym", "createdAt": "2020-07-22T20:03:06Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -181,57 +229,151 @@ public TopologyConfigurationMsg queryTopologyConfig(boolean useCached) {\n     }\n \n     /**\n-     * Enforce one of the standby Cluster's to become the new active cluster and current active to become standby\n+     * Create a new topology config, which changes one of the standby as the active,\n+     * and active as standby. Data should flow in the reverse direction.\n      **/\n-    public static TopologyDescriptor changeActiveCluster(TopologyConfigurationMsg topologyConfig) {\n-        TopologyDescriptor topologyDescriptor = new TopologyDescriptor(topologyConfig);\n+    public TopologyDescriptor generateConfigWithRoleSwitch() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n \n-        // Convert the current active to standby\n-        ClusterDescriptor oldActive = topologyDescriptor.getActiveClusters().values().iterator().next();\n-        ClusterDescriptor newStandby = new ClusterDescriptor(oldActive, ClusterRole.STANDBY);\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>();\n+        List<ClusterDescriptor> newStandbyClusters = new ArrayList<>();\n+        currentConfig.getActiveClusters().values().forEach(activeCluster ->\n+                newStandbyClusters.add(new ClusterDescriptor(activeCluster, ClusterRole.STANDBY)));\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newActiveClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE)));\n \n-        List<ClusterDescriptor> standbyClusters = Arrays.asList(newStandby);\n-        ClusterDescriptor newPrimary = null;\n+        return new TopologyDescriptor(++epoch, newActiveClusters, newStandbyClusters);\n+    }\n \n-        for (ClusterDescriptor standbyCluster : topologyDescriptor.getStandbyClusters().values()) {\n-            if (newPrimary == null) {\n-                newPrimary = new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE);\n-            } else {\n-                standbyClusters.add(standbyCluster);\n-            }\n-        }\n+    /**\n+     * Create a new topology config, which marks all standby cluster as active on purpose.\n+     * System should drop messages between any two active clusters.\n+     **/\n+    public TopologyDescriptor generateConfigWithAllActive() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+        ClusterDescriptor currentActive = currentConfig.getActiveClusters().values().iterator().next();\n+\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>();\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newActiveClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE)));\n+        newActiveClusters.add(currentActive);\n+\n+        return new TopologyDescriptor(++epoch, newActiveClusters, new ArrayList<>());\n+    }\n \n-        TopologyDescriptor newSiteConf = new TopologyDescriptor(1L, Arrays.asList(newPrimary), standbyClusters);\n-        return newSiteConf;\n+    /**\n+     * Create a new topology config, which marks all cluster as standby on purpose.\n+     * System should not send messages in this case.\n+     **/\n+    public TopologyDescriptor generateConfigWithAllStandby() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+        ClusterDescriptor currentActive = currentConfig.getActiveClusters().values().iterator().next();\n+\n+        List<ClusterDescriptor> newStandbyClusters = new ArrayList<>(currentConfig.getStandbyClusters().values());\n+        ClusterDescriptor newStandby = new ClusterDescriptor(currentActive, ClusterRole.STANDBY);\n+        newStandbyClusters.add(newStandby);\n+\n+        return new TopologyDescriptor(++epoch, new ArrayList<>(), newStandbyClusters);\n+    }\n+\n+    /**\n+     * Create a new topology config, which marks all standby cluster as invalid on purpose.\n+     * System should not send messages in this case.\n+     **/\n+    public TopologyDescriptor generateConfigWithInvalid() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>(currentConfig.getActiveClusters().values());\n+        List<ClusterDescriptor> newInvalidClusters = new ArrayList<>();\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newInvalidClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.INVALID)));\n+\n+        return new TopologyDescriptor(++epoch, newActiveClusters, new ArrayList<>(), newInvalidClusters);\n+    }\n+\n+    /**\n+     * Bring topology config back to default valid config.\n+     **/\n+    public TopologyDescriptor generateDefaultValidConfig() {\n+        TopologyDescriptor defaultTopology = new TopologyDescriptor(constructTopologyConfigMsg());\n+        List<ClusterDescriptor> activeClusters = new ArrayList<>(defaultTopology.getActiveClusters().values());\n+        List<ClusterDescriptor> standbyClusters = new ArrayList<>(defaultTopology.getStandbyClusters().values());\n+\n+        return new TopologyDescriptor(++epoch, activeClusters, standbyClusters);\n     }\n \n     /**\n      * Testing purpose to generate cluster role change.\n      */\n-    public static class SiteManagerCallback implements Runnable {\n-        public boolean clusterRoleChange = false;\n-        DefaultClusterManager clusterManager;\n+    public static class ClusterManagerCallback implements Runnable {\n+        private final DefaultClusterManager clusterManager;\n+        private final LinkedBlockingQueue<TopologyDescriptor> queue;\n \n-        SiteManagerCallback(DefaultClusterManager clusterManager) {\n+        public ClusterManagerCallback(DefaultClusterManager clusterManager) {\n             this.clusterManager = clusterManager;\n+            queue = new LinkedBlockingQueue<>();\n+        }\n+\n+        public void applyNewTopologyConfig(@NonNull TopologyDescriptor descriptor) {\n+            log.info(\"Applying a new config {}\", descriptor);\n+            queue.add(descriptor);\n         }\n \n         @Override\n         public void run() {\n-            while (!clusterManager.ifShutdown) {\n+            while (!clusterManager.isShutdown()) {\n                 try {\n-                    sleep(changeInterval);\n-                    if (clusterRoleChange) {\n-                        TopologyDescriptor newConfig = changeActiveCluster(clusterManager.getTopologyConfig());\n-                        clusterManager.updateTopologyConfig(newConfig.convertToMessage());\n-                        log.warn(\"Change the cluster config\");\n-                        clusterRoleChange = false;\n-                    }\n-                } catch (Exception e) {\n-                    log.error(\"Caught an exception\",e);\n+                    TopologyDescriptor newConfig = queue.take();\n+                    clusterManager.updateTopologyConfig(newConfig.convertToMessage());\n+                    log.warn(\"change the cluster config\");\n+                } catch (InterruptedException ie) {\n+                    throw new UnrecoverableCorfuInterruptedError(ie);\n                 }\n             }\n         }\n     }\n \n+    public static class ConfigStreamListener implements StreamListener {", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1OTA2Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459559062", "bodyText": "Done.", "author": "zhangn49", "createdAt": "2020-07-23T16:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1MDA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1MTUwNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459051505", "bodyText": "maybe moving the types of configurations to an enum, and having a switch would make it easier to follow? this I'm not that picky about, just a suggestion.", "author": "annym", "createdAt": "2020-07-22T20:05:36Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -181,57 +229,151 @@ public TopologyConfigurationMsg queryTopologyConfig(boolean useCached) {\n     }\n \n     /**\n-     * Enforce one of the standby Cluster's to become the new active cluster and current active to become standby\n+     * Create a new topology config, which changes one of the standby as the active,\n+     * and active as standby. Data should flow in the reverse direction.\n      **/\n-    public static TopologyDescriptor changeActiveCluster(TopologyConfigurationMsg topologyConfig) {\n-        TopologyDescriptor topologyDescriptor = new TopologyDescriptor(topologyConfig);\n+    public TopologyDescriptor generateConfigWithRoleSwitch() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n \n-        // Convert the current active to standby\n-        ClusterDescriptor oldActive = topologyDescriptor.getActiveClusters().values().iterator().next();\n-        ClusterDescriptor newStandby = new ClusterDescriptor(oldActive, ClusterRole.STANDBY);\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>();\n+        List<ClusterDescriptor> newStandbyClusters = new ArrayList<>();\n+        currentConfig.getActiveClusters().values().forEach(activeCluster ->\n+                newStandbyClusters.add(new ClusterDescriptor(activeCluster, ClusterRole.STANDBY)));\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newActiveClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE)));\n \n-        List<ClusterDescriptor> standbyClusters = Arrays.asList(newStandby);\n-        ClusterDescriptor newPrimary = null;\n+        return new TopologyDescriptor(++epoch, newActiveClusters, newStandbyClusters);\n+    }\n \n-        for (ClusterDescriptor standbyCluster : topologyDescriptor.getStandbyClusters().values()) {\n-            if (newPrimary == null) {\n-                newPrimary = new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE);\n-            } else {\n-                standbyClusters.add(standbyCluster);\n-            }\n-        }\n+    /**\n+     * Create a new topology config, which marks all standby cluster as active on purpose.\n+     * System should drop messages between any two active clusters.\n+     **/\n+    public TopologyDescriptor generateConfigWithAllActive() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+        ClusterDescriptor currentActive = currentConfig.getActiveClusters().values().iterator().next();\n+\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>();\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newActiveClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE)));\n+        newActiveClusters.add(currentActive);\n+\n+        return new TopologyDescriptor(++epoch, newActiveClusters, new ArrayList<>());\n+    }\n \n-        TopologyDescriptor newSiteConf = new TopologyDescriptor(1L, Arrays.asList(newPrimary), standbyClusters);\n-        return newSiteConf;\n+    /**\n+     * Create a new topology config, which marks all cluster as standby on purpose.\n+     * System should not send messages in this case.\n+     **/\n+    public TopologyDescriptor generateConfigWithAllStandby() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+        ClusterDescriptor currentActive = currentConfig.getActiveClusters().values().iterator().next();\n+\n+        List<ClusterDescriptor> newStandbyClusters = new ArrayList<>(currentConfig.getStandbyClusters().values());\n+        ClusterDescriptor newStandby = new ClusterDescriptor(currentActive, ClusterRole.STANDBY);\n+        newStandbyClusters.add(newStandby);\n+\n+        return new TopologyDescriptor(++epoch, new ArrayList<>(), newStandbyClusters);\n+    }\n+\n+    /**\n+     * Create a new topology config, which marks all standby cluster as invalid on purpose.\n+     * System should not send messages in this case.\n+     **/\n+    public TopologyDescriptor generateConfigWithInvalid() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>(currentConfig.getActiveClusters().values());\n+        List<ClusterDescriptor> newInvalidClusters = new ArrayList<>();\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newInvalidClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.INVALID)));\n+\n+        return new TopologyDescriptor(++epoch, newActiveClusters, new ArrayList<>(), newInvalidClusters);\n+    }\n+\n+    /**\n+     * Bring topology config back to default valid config.\n+     **/\n+    public TopologyDescriptor generateDefaultValidConfig() {\n+        TopologyDescriptor defaultTopology = new TopologyDescriptor(constructTopologyConfigMsg());\n+        List<ClusterDescriptor> activeClusters = new ArrayList<>(defaultTopology.getActiveClusters().values());\n+        List<ClusterDescriptor> standbyClusters = new ArrayList<>(defaultTopology.getStandbyClusters().values());\n+\n+        return new TopologyDescriptor(++epoch, activeClusters, standbyClusters);\n     }\n \n     /**\n      * Testing purpose to generate cluster role change.\n      */\n-    public static class SiteManagerCallback implements Runnable {\n-        public boolean clusterRoleChange = false;\n-        DefaultClusterManager clusterManager;\n+    public static class ClusterManagerCallback implements Runnable {\n+        private final DefaultClusterManager clusterManager;\n+        private final LinkedBlockingQueue<TopologyDescriptor> queue;\n \n-        SiteManagerCallback(DefaultClusterManager clusterManager) {\n+        public ClusterManagerCallback(DefaultClusterManager clusterManager) {\n             this.clusterManager = clusterManager;\n+            queue = new LinkedBlockingQueue<>();\n+        }\n+\n+        public void applyNewTopologyConfig(@NonNull TopologyDescriptor descriptor) {\n+            log.info(\"Applying a new config {}\", descriptor);\n+            queue.add(descriptor);\n         }\n \n         @Override\n         public void run() {\n-            while (!clusterManager.ifShutdown) {\n+            while (!clusterManager.isShutdown()) {\n                 try {\n-                    sleep(changeInterval);\n-                    if (clusterRoleChange) {\n-                        TopologyDescriptor newConfig = changeActiveCluster(clusterManager.getTopologyConfig());\n-                        clusterManager.updateTopologyConfig(newConfig.convertToMessage());\n-                        log.warn(\"Change the cluster config\");\n-                        clusterRoleChange = false;\n-                    }\n-                } catch (Exception e) {\n-                    log.error(\"Caught an exception\",e);\n+                    TopologyDescriptor newConfig = queue.take();\n+                    clusterManager.updateTopologyConfig(newConfig.convertToMessage());\n+                    log.warn(\"change the cluster config\");\n+                } catch (InterruptedException ie) {\n+                    throw new UnrecoverableCorfuInterruptedError(ie);\n                 }\n             }\n         }\n     }\n \n+    public static class ConfigStreamListener implements StreamListener {\n+\n+        private final DefaultClusterManager clusterManager;\n+\n+        public ConfigStreamListener(DefaultClusterManager clusterManager) {\n+            this.clusterManager = clusterManager;\n+        }\n+\n+        @Override\n+        public void onNext(CorfuStreamEntries results) {\n+            log.info(\"ConfigStreamListener onNext {} with entry size {}\", results, results.getEntries().size());", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1MzI3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459053279", "bodyText": "typo -> suit -> suite", "author": "annym", "createdAt": "2020-07-22T20:09:04Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1NzIxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459057211", "bodyText": "typo -> verifies", "author": "annym", "createdAt": "2020-07-22T20:16:43Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3MDY5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459070699", "bodyText": "entry -> entries", "author": "annym", "createdAt": "2020-07-22T20:42:16Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3MzQ1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459073456", "bodyText": "You can change this for:             mapStandby.keySet().containsAll(mapActive.keySet());", "author": "annym", "createdAt": "2020-07-22T20:47:25Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1MjE4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459552186", "bodyText": "Yeah, it is cleaner. I think for loop can make sure all entries exist and help understand how many entries should be there.", "author": "zhangn49", "createdAt": "2020-07-23T15:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3MzQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3NDY1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459074650", "bodyText": "was this commented because it did not work? Cause technically the previous line already verified it was transferred so it should work right?", "author": "annym", "createdAt": "2020-07-22T20:49:45Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        //assertThat(mapActive.size()).isEqualTo(thirdBatch);", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1MDQ0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459550444", "bodyText": "Yes, it works now. Forgot to bring it back after debugging.", "author": "zhangn49", "createdAt": "2020-07-23T15:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3NDY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3NDk0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459074941", "bodyText": "verify -> verifies", "author": "annym", "createdAt": "2020-07-22T20:50:18Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        //assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync transfer phase.", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3NjMwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459076306", "bodyText": "verify -> verifies", "author": "annym", "createdAt": "2020-07-22T20:53:03Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        //assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync transfer phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Perform a role switch with corfu store\n+     * 5. Standby will drop messages and keep size 0\n+     * 6. Verify active map becomes size 0, since source size is 0\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringTransferPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+        TimeUnit.SECONDS.sleep(shortInterval);\n+\n+        // Perform a role switch during transfer\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+\n+        // Wait until active map size becomes 0\n+        waitForReplication(size -> size == 0, mapActive, 0);\n+        log.info(\"After role switch during transfer phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync apply phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync goes to apply phase\n+     * 5. Perform a role switch with corfu store\n+     * 6. Standby will continue apply and have size 50\n+     * 7. Verify both maps have size 50\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringApplyPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until apply phase\n+        UUID standbyStream = CorfuRuntime.getStreamID(streamName);\n+        while (!standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().containsKey(standbyStream)) {\n+            TimeUnit.MILLISECONDS.sleep(100L);\n+        }\n+\n+        log.info(\"======standby tail is : \" + standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().get(standbyStream));\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Should finish apply\n+        waitForReplication(size -> size == largeBatch, mapStandby, largeBatch);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        log.info(\"After role switch during apply phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isEqualTo(largeBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two active clusters", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3NzE5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459077190", "bodyText": "to mapActive", "author": "annym", "createdAt": "2020-07-22T20:54:52Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        //assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync transfer phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Perform a role switch with corfu store\n+     * 5. Standby will drop messages and keep size 0\n+     * 6. Verify active map becomes size 0, since source size is 0\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringTransferPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+        TimeUnit.SECONDS.sleep(shortInterval);\n+\n+        // Perform a role switch during transfer\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+\n+        // Wait until active map size becomes 0\n+        waitForReplication(size -> size == 0, mapActive, 0);\n+        log.info(\"After role switch during transfer phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync apply phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync goes to apply phase\n+     * 5. Perform a role switch with corfu store\n+     * 6. Standby will continue apply and have size 50\n+     * 7. Verify both maps have size 50\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringApplyPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until apply phase\n+        UUID standbyStream = CorfuRuntime.getStreamID(streamName);\n+        while (!standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().containsKey(standbyStream)) {\n+            TimeUnit.MILLISECONDS.sleep(100L);\n+        }\n+\n+        log.info(\"======standby tail is : \" + standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().get(standbyStream));\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Should finish apply\n+        waitForReplication(size -> size == largeBatch, mapStandby, largeBatch);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        log.info(\"After role switch during apply phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isEqualTo(largeBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two active clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-active config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since both are active\n+     */\n+    @Test\n+    public void testNewConfigWithTwoActive() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with two active\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_TWO_ACTIVE,\n+                        DefaultClusterManager.OP_TWO_ACTIVE, DefaultClusterManager.OP_TWO_ACTIVE)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        // Append to mapStandby", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3NzM0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459077342", "bodyText": "have -> has", "author": "annym", "createdAt": "2020-07-22T20:55:07Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        //assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync transfer phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Perform a role switch with corfu store\n+     * 5. Standby will drop messages and keep size 0\n+     * 6. Verify active map becomes size 0, since source size is 0\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringTransferPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+        TimeUnit.SECONDS.sleep(shortInterval);\n+\n+        // Perform a role switch during transfer\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+\n+        // Wait until active map size becomes 0\n+        waitForReplication(size -> size == 0, mapActive, 0);\n+        log.info(\"After role switch during transfer phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync apply phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync goes to apply phase\n+     * 5. Perform a role switch with corfu store\n+     * 6. Standby will continue apply and have size 50\n+     * 7. Verify both maps have size 50\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringApplyPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until apply phase\n+        UUID standbyStream = CorfuRuntime.getStreamID(streamName);\n+        while (!standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().containsKey(standbyStream)) {\n+            TimeUnit.MILLISECONDS.sleep(100L);\n+        }\n+\n+        log.info(\"======standby tail is : \" + standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().get(standbyStream));\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Should finish apply\n+        waitForReplication(size -> size == largeBatch, mapStandby, largeBatch);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        log.info(\"After role switch during apply phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isEqualTo(largeBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two active clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-active config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since both are active\n+     */\n+    @Test\n+    public void testNewConfigWithTwoActive() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with two active\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_TWO_ACTIVE,\n+                        DefaultClusterManager.OP_TWO_ACTIVE, DefaultClusterManager.OP_TWO_ACTIVE)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        // Append to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        log.info(\"Active map have {} entries now!\", thirdBatch);", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3NzU1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459077555", "bodyText": "verify -> verifies", "author": "annym", "createdAt": "2020-07-22T20:55:32Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        //assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync transfer phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Perform a role switch with corfu store\n+     * 5. Standby will drop messages and keep size 0\n+     * 6. Verify active map becomes size 0, since source size is 0\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringTransferPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+        TimeUnit.SECONDS.sleep(shortInterval);\n+\n+        // Perform a role switch during transfer\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+\n+        // Wait until active map size becomes 0\n+        waitForReplication(size -> size == 0, mapActive, 0);\n+        log.info(\"After role switch during transfer phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync apply phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync goes to apply phase\n+     * 5. Perform a role switch with corfu store\n+     * 6. Standby will continue apply and have size 50\n+     * 7. Verify both maps have size 50\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringApplyPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until apply phase\n+        UUID standbyStream = CorfuRuntime.getStreamID(streamName);\n+        while (!standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().containsKey(standbyStream)) {\n+            TimeUnit.MILLISECONDS.sleep(100L);\n+        }\n+\n+        log.info(\"======standby tail is : \" + standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().get(standbyStream));\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Should finish apply\n+        waitForReplication(size -> size == largeBatch, mapStandby, largeBatch);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        log.info(\"After role switch during apply phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isEqualTo(largeBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two active clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-active config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since both are active\n+     */\n+    @Test\n+    public void testNewConfigWithTwoActive() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with two active\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_TWO_ACTIVE,\n+                        DefaultClusterManager.OP_TWO_ACTIVE, DefaultClusterManager.OP_TWO_ACTIVE)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        // Append to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        log.info(\"Active map have {} entries now!\", thirdBatch);\n+\n+        // Standby map should still have secondBatch size\n+        log.info(\"Standby map should still have {} size\", secondBatch);\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(secondBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two standby clusters", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3NzkzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459077932", "bodyText": "verify -> verifies", "author": "annym", "createdAt": "2020-07-22T20:56:17Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        //assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync transfer phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Perform a role switch with corfu store\n+     * 5. Standby will drop messages and keep size 0\n+     * 6. Verify active map becomes size 0, since source size is 0\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringTransferPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+        TimeUnit.SECONDS.sleep(shortInterval);\n+\n+        // Perform a role switch during transfer\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+\n+        // Wait until active map size becomes 0\n+        waitForReplication(size -> size == 0, mapActive, 0);\n+        log.info(\"After role switch during transfer phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync apply phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync goes to apply phase\n+     * 5. Perform a role switch with corfu store\n+     * 6. Standby will continue apply and have size 50\n+     * 7. Verify both maps have size 50\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringApplyPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until apply phase\n+        UUID standbyStream = CorfuRuntime.getStreamID(streamName);\n+        while (!standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().containsKey(standbyStream)) {\n+            TimeUnit.MILLISECONDS.sleep(100L);\n+        }\n+\n+        log.info(\"======standby tail is : \" + standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().get(standbyStream));\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Should finish apply\n+        waitForReplication(size -> size == largeBatch, mapStandby, largeBatch);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        log.info(\"After role switch during apply phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isEqualTo(largeBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two active clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-active config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since both are active\n+     */\n+    @Test\n+    public void testNewConfigWithTwoActive() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with two active\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_TWO_ACTIVE,\n+                        DefaultClusterManager.OP_TWO_ACTIVE, DefaultClusterManager.OP_TWO_ACTIVE)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        // Append to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        log.info(\"Active map have {} entries now!\", thirdBatch);\n+\n+        // Standby map should still have secondBatch size\n+        log.info(\"Standby map should still have {} size\", secondBatch);\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(secondBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two standby clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-standby config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since both are standby\n+     */\n+    @Test\n+    public void testNewConfigWithAllStandby() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with all standby\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_ALL_STANDBY,\n+                        DefaultClusterManager.OP_ALL_STANDBY, DefaultClusterManager.OP_ALL_STANDBY)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        log.info(\"Active map have {} entries now!\", thirdBatch);\n+\n+        // Standby map should still have secondBatch size\n+        log.info(\"Standby map should still have {} size\", secondBatch);\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(secondBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with one active and one invalid", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3ODQ2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459078468", "bodyText": "Good test!", "author": "annym", "createdAt": "2020-07-22T20:57:15Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        //assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync transfer phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Perform a role switch with corfu store\n+     * 5. Standby will drop messages and keep size 0\n+     * 6. Verify active map becomes size 0, since source size is 0\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringTransferPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+        TimeUnit.SECONDS.sleep(shortInterval);\n+\n+        // Perform a role switch during transfer\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+\n+        // Wait until active map size becomes 0\n+        waitForReplication(size -> size == 0, mapActive, 0);\n+        log.info(\"After role switch during transfer phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync apply phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync goes to apply phase\n+     * 5. Perform a role switch with corfu store\n+     * 6. Standby will continue apply and have size 50\n+     * 7. Verify both maps have size 50\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringApplyPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until apply phase\n+        UUID standbyStream = CorfuRuntime.getStreamID(streamName);\n+        while (!standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().containsKey(standbyStream)) {\n+            TimeUnit.MILLISECONDS.sleep(100L);\n+        }\n+\n+        log.info(\"======standby tail is : \" + standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().get(standbyStream));\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Should finish apply\n+        waitForReplication(size -> size == largeBatch, mapStandby, largeBatch);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        log.info(\"After role switch during apply phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isEqualTo(largeBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two active clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-active config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since both are active\n+     */\n+    @Test\n+    public void testNewConfigWithTwoActive() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with two active\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_TWO_ACTIVE,\n+                        DefaultClusterManager.OP_TWO_ACTIVE, DefaultClusterManager.OP_TWO_ACTIVE)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        // Append to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        log.info(\"Active map have {} entries now!\", thirdBatch);\n+\n+        // Standby map should still have secondBatch size\n+        log.info(\"Standby map should still have {} size\", secondBatch);\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(secondBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two standby clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-standby config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since both are standby\n+     */\n+    @Test\n+    public void testNewConfigWithAllStandby() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with all standby\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_ALL_STANDBY,\n+                        DefaultClusterManager.OP_ALL_STANDBY, DefaultClusterManager.OP_ALL_STANDBY)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        log.info(\"Active map have {} entries now!\", thirdBatch);\n+\n+        // Standby map should still have secondBatch size\n+        log.info(\"Standby map should still have {} size\", secondBatch);\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(secondBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with one active and one invalid\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a active-invalid config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since standby is invalid\n+     * 9. Resume to standby and verify data is fully replicated again.\n+     */\n+    @Test\n+    public void testNewConfigWithInvalidClusters() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with invalid state\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_INVALID,\n+                        DefaultClusterManager.OP_INVALID, DefaultClusterManager.OP_INVALID)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        // Append to mapActive\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+\n+        // Standby map should still have secondBatch size\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(secondBatch);\n+        log.info(\"After {} seconds sleep, double check passed\", mediumInterval);\n+\n+        // Change to default active standby config\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4MDE2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459080164", "bodyText": "If you take a look at PR #2640 I broke all these functions of writing to active/standby maps/ stopping into generic utilities available in LogReplicationAbstractIT, which would reduce a lot of the code here (just a suggestion)", "author": "annym", "createdAt": "2020-07-22T21:00:24Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        //assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync transfer phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Perform a role switch with corfu store\n+     * 5. Standby will drop messages and keep size 0\n+     * 6. Verify active map becomes size 0, since source size is 0\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringTransferPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+        TimeUnit.SECONDS.sleep(shortInterval);\n+\n+        // Perform a role switch during transfer\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+\n+        // Wait until active map size becomes 0\n+        waitForReplication(size -> size == 0, mapActive, 0);\n+        log.info(\"After role switch during transfer phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch during a snapshot sync apply phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync goes to apply phase\n+     * 5. Perform a role switch with corfu store\n+     * 6. Standby will continue apply and have size 50\n+     * 7. Verify both maps have size 50\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringApplyPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until apply phase\n+        UUID standbyStream = CorfuRuntime.getStreamID(streamName);\n+        while (!standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().containsKey(standbyStream)) {\n+            TimeUnit.MILLISECONDS.sleep(100L);\n+        }\n+\n+        log.info(\"======standby tail is : \" + standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().get(standbyStream));\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Should finish apply\n+        waitForReplication(size -> size == largeBatch, mapStandby, largeBatch);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        log.info(\"After role switch during apply phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isEqualTo(largeBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two active clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-active config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since both are active\n+     */\n+    @Test\n+    public void testNewConfigWithTwoActive() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with two active\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_TWO_ACTIVE,\n+                        DefaultClusterManager.OP_TWO_ACTIVE, DefaultClusterManager.OP_TWO_ACTIVE)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        // Append to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        log.info(\"Active map have {} entries now!\", thirdBatch);\n+\n+        // Standby map should still have secondBatch size\n+        log.info(\"Standby map should still have {} size\", secondBatch);\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(secondBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with two standby clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-standby config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since both are standby\n+     */\n+    @Test\n+    public void testNewConfigWithAllStandby() throws Exception {\n+        // Write 10 entry to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with all standby\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_ALL_STANDBY,\n+                        DefaultClusterManager.OP_ALL_STANDBY, DefaultClusterManager.OP_ALL_STANDBY)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        log.info(\"Active map have {} entries now!\", thirdBatch);\n+\n+        // Standby map should still have secondBatch size\n+        log.info(\"Standby map should still have {} size\", secondBatch);\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(secondBatch);\n+    }\n+\n+    /**\n+     * This test verify config change with one active and one invalid\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a active-invalid config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since standby is invalid\n+     * 9. Resume to standby and verify data is fully replicated again.\n+     */\n+    @Test\n+    public void testNewConfigWithInvalidClusters() throws Exception {", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwNDc3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459804775", "bodyText": "A similar suggestion is to move the common code from all tests to a common place in this file so the tests themselves are smaller", "author": "pankti-m", "createdAt": "2020-07-24T00:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4MDE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4MTM2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459081363", "bodyText": "These tests are good! I think one that we might be missing and could be interesting is:\n\nSnapshot and Log Entry (check it completes)\nStop both LRs\nEnforce Role Switch\nBring them back\n\nThis way we can verify it performs correctly the site flip even when coming back up after with a new config.", "author": "annym", "createdAt": "2020-07-22T21:02:38Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,619 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suit exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verify config change with a role switch.\n+     * <p>", "originalCommit": "946999817492aa9fca1f041c7d76ba6815974ab2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "471c6fe82a9cb1cfb9301762e4e4c3615c52cfba", "url": "https://github.com/CorfuDB/CorfuDB/commit/471c6fe82a9cb1cfb9301762e4e4c3615c52cfba", "message": "Add Log Replication Cluster Role ITs", "committedDate": "2020-07-23T04:22:28Z", "type": "commit"}, {"oid": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "url": "https://github.com/CorfuDB/CorfuDB/commit/cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "message": "Address comments", "committedDate": "2020-07-23T16:08:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4MjQxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459782411", "bodyText": "how do we confirm this?", "author": "pankti-m", "createdAt": "2020-07-23T23:27:40Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -489,11 +489,12 @@ public void processLockRelease() {\n      *   - Higher config id\n      *   - Potential cluster role change\n      *\n+     * Cluster change from active to standby is a two step process, we first confirm that\n+     * we are ready to do the cluster role change, so by the time we receive cluster change", "originalCommit": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwOTEyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459809125", "bodyText": "I guess we confirm it by query replication status.", "author": "zhangn49", "createdAt": "2020-07-24T01:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4MjQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MTMyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459791325", "bodyText": "remove before merging?", "author": "pankti-m", "createdAt": "2020-07-23T23:58:12Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -1,33 +1,49 @@\n package org.corfudb.infrastructure.logreplication.infrastructure.plugins;\n \n import lombok.Getter;\n+import lombok.NonNull;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.infrastructure.logreplication.infrastructure.ClusterDescriptor;\n import org.corfudb.infrastructure.logreplication.infrastructure.NodeDescriptor;\n import org.corfudb.infrastructure.logreplication.infrastructure.TopologyDescriptor;\n-import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo.TopologyConfigurationMsg;\n import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo.ClusterRole;\n+import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo.TopologyConfigurationMsg;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.CorfuStoreMetadata;\n+import org.corfudb.runtime.Messages;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuStreamEntries;\n+import org.corfudb.runtime.collections.CorfuStreamEntry;\n+import org.corfudb.runtime.collections.StreamListener;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.collections.TableSchema;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n \n import java.io.File;\n-import java.io.FileNotFoundException;\n import java.io.FileReader;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Properties;\n import java.util.Set;\n import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n \n-import static java.lang.Thread.sleep;\n-\n+/**\n+ * This class extends CorfuReplicationClusterManagerAdapter, provides topology config API\n+ * for integration tests. The initial topology config should be valid, which means it has only\n+ * one active cluster, and one or more standby clusters.\n+ */\n @Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")", "originalCommit": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMDI0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459810249", "bodyText": "Removed.", "author": "zhangn49", "createdAt": "2020-07-24T01:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MTMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MzEyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459793125", "bodyText": "this can be an inaccurate error message if the exception was not FileNotFound.  Why was the exception type changed?", "author": "pankti-m", "createdAt": "2020-07-24T00:04:49Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -112,9 +171,8 @@ public static TopologyDescriptor readConfig() throws IOException {\n             }\n             // TODO: add reading of node id (which is the APH node uuid)\n \n-            reader.close();\n-        } catch (FileNotFoundException e) {\n-            log.warn(\"Plugin Config File {} does not exist. Using default configs\", config_file);\n+        } catch (IOException e) {\n+            log.warn(\"Plugin Config File {} does not exist. Using default configs\", CONFIG_FILE_PATH);", "originalCommit": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwODgwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459808806", "bodyText": "Auto close will throw IOException. I think it is fine, since the entire default cluster manager is test only.", "author": "zhangn49", "createdAt": "2020-07-24T01:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MzEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5Njc3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459796773", "bodyText": "can you annotate it with @testonly or add it in the comment that this is only used by tests?", "author": "pankti-m", "createdAt": "2020-07-24T00:18:55Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -181,57 +229,161 @@ public TopologyConfigurationMsg queryTopologyConfig(boolean useCached) {\n     }\n \n     /**\n-     * Enforce one of the standby Cluster's to become the new active cluster and current active to become standby\n+     * Create a new topology config, which changes one of the standby as the active,\n+     * and active as standby. Data should flow in the reverse direction.", "originalCommit": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwNzUyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459807520", "bodyText": "Actually the entire DefaultClusterManager is test-only.", "author": "zhangn49", "createdAt": "2020-07-24T01:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5Njc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5Njk1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459796952", "bodyText": "can you add an annotation or comment that this in only for testing?", "author": "pankti-m", "createdAt": "2020-07-24T00:19:35Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -181,57 +229,161 @@ public TopologyConfigurationMsg queryTopologyConfig(boolean useCached) {\n     }\n \n     /**\n-     * Enforce one of the standby Cluster's to become the new active cluster and current active to become standby\n+     * Create a new topology config, which changes one of the standby as the active,\n+     * and active as standby. Data should flow in the reverse direction.\n      **/\n-    public static TopologyDescriptor changeActiveCluster(TopologyConfigurationMsg topologyConfig) {\n-        TopologyDescriptor topologyDescriptor = new TopologyDescriptor(topologyConfig);\n-\n-        // Convert the current active to standby\n-        ClusterDescriptor oldActive = topologyDescriptor.getActiveClusters().values().iterator().next();\n-        ClusterDescriptor newStandby = new ClusterDescriptor(oldActive, ClusterRole.STANDBY);\n-\n-        List<ClusterDescriptor> standbyClusters = Arrays.asList(newStandby);\n-        ClusterDescriptor newPrimary = null;\n-\n-        for (ClusterDescriptor standbyCluster : topologyDescriptor.getStandbyClusters().values()) {\n-            if (newPrimary == null) {\n-                newPrimary = new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE);\n+    public TopologyDescriptor generateConfigWithRoleSwitch() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>();\n+        List<ClusterDescriptor> newStandbyClusters = new ArrayList<>();\n+        currentConfig.getActiveClusters().values().forEach(activeCluster ->\n+                newStandbyClusters.add(new ClusterDescriptor(activeCluster, ClusterRole.STANDBY)));\n+        for (ClusterDescriptor standbyCluster : currentConfig.getStandbyClusters().values()) {\n+            if (newActiveClusters.isEmpty()) {\n+                newActiveClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE));\n             } else {\n-                standbyClusters.add(standbyCluster);\n+                newStandbyClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.STANDBY));\n             }\n         }\n \n-        TopologyDescriptor newSiteConf = new TopologyDescriptor(1L, Arrays.asList(newPrimary), standbyClusters);\n-        return newSiteConf;\n+        return new TopologyDescriptor(++configId, newActiveClusters, newStandbyClusters);\n+    }\n+\n+    /**\n+     * Create a new topology config, which marks all standby cluster as active on purpose.\n+     * System should drop messages between any two active clusters.\n+     **/\n+    public TopologyDescriptor generateConfigWithAllActive() {", "originalCommit": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwNzc0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459807748", "bodyText": "The same. I think I will refactor this part in the next PR.", "author": "zhangn49", "createdAt": "2020-07-24T01:06:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5Njk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5NzczNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459797735", "bodyText": "maybe we should also add a case with active also as invalid", "author": "pankti-m", "createdAt": "2020-07-24T00:23:04Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultClusterManager.java", "diffHunk": "@@ -181,57 +229,161 @@ public TopologyConfigurationMsg queryTopologyConfig(boolean useCached) {\n     }\n \n     /**\n-     * Enforce one of the standby Cluster's to become the new active cluster and current active to become standby\n+     * Create a new topology config, which changes one of the standby as the active,\n+     * and active as standby. Data should flow in the reverse direction.\n      **/\n-    public static TopologyDescriptor changeActiveCluster(TopologyConfigurationMsg topologyConfig) {\n-        TopologyDescriptor topologyDescriptor = new TopologyDescriptor(topologyConfig);\n-\n-        // Convert the current active to standby\n-        ClusterDescriptor oldActive = topologyDescriptor.getActiveClusters().values().iterator().next();\n-        ClusterDescriptor newStandby = new ClusterDescriptor(oldActive, ClusterRole.STANDBY);\n-\n-        List<ClusterDescriptor> standbyClusters = Arrays.asList(newStandby);\n-        ClusterDescriptor newPrimary = null;\n-\n-        for (ClusterDescriptor standbyCluster : topologyDescriptor.getStandbyClusters().values()) {\n-            if (newPrimary == null) {\n-                newPrimary = new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE);\n+    public TopologyDescriptor generateConfigWithRoleSwitch() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>();\n+        List<ClusterDescriptor> newStandbyClusters = new ArrayList<>();\n+        currentConfig.getActiveClusters().values().forEach(activeCluster ->\n+                newStandbyClusters.add(new ClusterDescriptor(activeCluster, ClusterRole.STANDBY)));\n+        for (ClusterDescriptor standbyCluster : currentConfig.getStandbyClusters().values()) {\n+            if (newActiveClusters.isEmpty()) {\n+                newActiveClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE));\n             } else {\n-                standbyClusters.add(standbyCluster);\n+                newStandbyClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.STANDBY));\n             }\n         }\n \n-        TopologyDescriptor newSiteConf = new TopologyDescriptor(1L, Arrays.asList(newPrimary), standbyClusters);\n-        return newSiteConf;\n+        return new TopologyDescriptor(++configId, newActiveClusters, newStandbyClusters);\n+    }\n+\n+    /**\n+     * Create a new topology config, which marks all standby cluster as active on purpose.\n+     * System should drop messages between any two active clusters.\n+     **/\n+    public TopologyDescriptor generateConfigWithAllActive() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+        ClusterDescriptor currentActive = currentConfig.getActiveClusters().values().iterator().next();\n+\n+        List<ClusterDescriptor> newActiveClusters = new ArrayList<>();\n+        currentConfig.getStandbyClusters().values().forEach(standbyCluster ->\n+                newActiveClusters.add(new ClusterDescriptor(standbyCluster, ClusterRole.ACTIVE)));\n+        newActiveClusters.add(currentActive);\n+\n+        return new TopologyDescriptor(++configId, newActiveClusters, new ArrayList<>());\n+    }\n+\n+    /**\n+     * Create a new topology config, which marks all cluster as standby on purpose.\n+     * System should not send messages in this case.\n+     **/\n+    public TopologyDescriptor generateConfigWithAllStandby() {\n+        TopologyDescriptor currentConfig = new TopologyDescriptor(topologyConfig);\n+        ClusterDescriptor currentActive = currentConfig.getActiveClusters().values().iterator().next();\n+\n+        List<ClusterDescriptor> newStandbyClusters = new ArrayList<>(currentConfig.getStandbyClusters().values());\n+        ClusterDescriptor newStandby = new ClusterDescriptor(currentActive, ClusterRole.STANDBY);\n+        newStandbyClusters.add(newStandby);\n+\n+        return new TopologyDescriptor(++configId, new ArrayList<>(), newStandbyClusters);\n+    }\n+\n+    /**\n+     * Create a new topology config, which marks all standby cluster as invalid on purpose.\n+     * System should not send messages in this case.\n+     **/\n+    public TopologyDescriptor generateConfigWithInvalid() {", "originalCommit": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwODI1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459808259", "bodyText": "Sounds good, will add it in the next PR.", "author": "zhangn49", "createdAt": "2020-07-24T01:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5NzczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5OTE2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459799167", "bodyText": "is this import needed?", "author": "pankti-m", "createdAt": "2020-07-24T00:29:19Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/StreamsSnapshotWriter.java", "diffHunk": "@@ -4,6 +4,7 @@\n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.infrastructure.logreplication.LogReplicationConfig;\n+import org.corfudb.infrastructure.logreplication.proto.LogReplicationMetadata.LogReplicationMetadataVal;", "originalCommit": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwNjc3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459806773", "bodyText": "Done.", "author": "zhangn49", "createdAt": "2020-07-24T01:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5OTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5OTYzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459799633", "bodyText": "do you plan to remove this?", "author": "pankti-m", "createdAt": "2020-07-24T00:31:15Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suite exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")", "originalCommit": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwNzg3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459807875", "bodyText": "I will keep this one, since it is an IT class.", "author": "zhangn49", "createdAt": "2020-07-24T01:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5OTYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMTkzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459801933", "bodyText": "Actually, role is not expected to change when in transfer phase.  Only when we report transfer as 100%, the flip happens.  Will have to decide how we want to handle this case.", "author": "pankti-m", "createdAt": "2020-07-24T00:41:09Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suite exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verifies config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entries to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n+\n+    /**\n+     * This test verifies config change with a role switch during a snapshot sync transfer phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Perform a role switch with corfu store\n+     * 5. Standby will drop messages and keep size 0", "originalCommit": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwODA0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459808045", "bodyText": "Yeah, these two cases are not very clear right now. We did know much about workflow when designed these two cases.", "author": "zhangn49", "createdAt": "2020-07-24T01:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMTkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwNDU1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459804557", "bodyText": "actually, writes do not happen on the standby.  Technically they can, but we should decide if from Corfu we want to allow them", "author": "pankti-m", "createdAt": "2020-07-24T00:52:53Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.corfudb.integration;\n+\n+import com.google.common.reflect.TypeToken;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.infrastructure.logreplication.infrastructure.plugins.DefaultClusterManager;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.Table;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;\n+import org.corfudb.utils.CommonTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntPredicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+\n+/**\n+ * This test suite exercises some topology config change scenarios.\n+ * Each test will start with two single node corfu servers, and two single node log replicators.\n+ */\n+@Slf4j\n+@SuppressWarnings(\"checkstyle:magicnumber\")\n+public class CorfuReplicationClusterConfigIT extends AbstractIT {\n+    public final static String nettyPluginPath = \"src/test/resources/transport/nettyConfig.properties\";\n+    private final static String streamName = \"Table001\";\n+\n+    private final static long shortInterval = 1L;\n+    private final static long mediumInterval = 10L;\n+    private final static int firstBatch = 10;\n+    private final static int secondBatch = 15;\n+    private final static int thirdBatch = 20;\n+    private final static int largeBatch = 50;\n+\n+    private final static int activeClusterCorfuPort = 9000;\n+    private final static int standbyClusterCorfuPort = 9001;\n+    private final static int activeReplicationServerPort = 9010;\n+    private final static int standbyReplicationServerPort = 9020;\n+    private final static String activeCorfuEndpoint = DEFAULT_HOST + \":\" + activeClusterCorfuPort;\n+    private final static String standbyCorfuEndpoint = DEFAULT_HOST + \":\" + standbyClusterCorfuPort;\n+\n+    private Process activeCorfuServer = null;\n+    private Process standbyCorfuServer = null;\n+    private Process activeReplicationServer = null;\n+    private Process standbyReplicationServer = null;\n+\n+    private CorfuRuntime activeRuntime;\n+    private CorfuRuntime standbyRuntime;\n+    private CorfuTable<String, Integer> mapActive;\n+    private CorfuTable<String, Integer> mapStandby;\n+\n+    private CorfuStore corfuStore;\n+    private Table<CommonTypes.Uuid, CommonTypes.Uuid, CommonTypes.Uuid> configTable;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        activeCorfuServer = runServer(activeClusterCorfuPort, true);\n+        standbyCorfuServer = runServer(standbyClusterCorfuPort, true);\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        activeRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        activeRuntime.parseConfigurationString(activeCorfuEndpoint).connect();\n+\n+        standbyRuntime = CorfuRuntime.fromParameters(params).setTransactionLogging(true);\n+        standbyRuntime.parseConfigurationString(standbyCorfuEndpoint).connect();\n+\n+        mapActive = activeRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        mapStandby = standbyRuntime.getObjectsView()\n+                .build()\n+                .setStreamName(streamName)\n+                .setTypeToken(new TypeToken<CorfuTable<String, Integer>>() {\n+                })\n+                .open();\n+\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+\n+        corfuStore = new CorfuStore(activeRuntime);\n+\n+        configTable = corfuStore.openTable(\n+                DefaultClusterManager.CONFIG_NAMESPACE, DefaultClusterManager.CONFIG_TABLE_NAME,\n+                CommonTypes.Uuid.class, CommonTypes.Uuid.class, CommonTypes.Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException, InterruptedException {\n+        if (activeRuntime != null) {\n+            activeRuntime.shutdown();\n+        }\n+\n+        if (standbyRuntime != null) {\n+            standbyRuntime.shutdown();\n+        }\n+\n+        shutdownCorfuServer(activeCorfuServer);\n+        shutdownCorfuServer(standbyCorfuServer);\n+        shutdownCorfuServer(activeReplicationServer);\n+        shutdownCorfuServer(standbyReplicationServer);\n+    }\n+\n+    /**\n+     * This test verifies config change with a role switch.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a role switch with corfu store\n+     * 7. Write 5 more entries to standby map, which becomes source right now.\n+     * 8. Verify data will be replicated in reverse direction.\n+     */\n+    @Test\n+    public void testNewConfigWithSwitchRole() throws Exception {\n+        // Write 10 entries to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Write 5 more entries to mapStandby\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            standbyRuntime.getObjectsView().TXBegin();\n+            mapStandby.put(String.valueOf(i), i);\n+            standbyRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == thirdBatch, mapActive, thirdBatch);\n+        log.info(\"Data is fully replicated again after role switch, both maps have size {}. \" +\n+                        \"Current active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                thirdBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n+    }\n+\n+    /**\n+     * This test verifies config change with a role switch during a snapshot sync transfer phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Perform a role switch with corfu store\n+     * 5. Standby will drop messages and keep size 0\n+     * 6. Verify active map becomes size 0, since source size is 0\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringTransferPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+        TimeUnit.SECONDS.sleep(shortInterval);\n+\n+        // Perform a role switch during transfer\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        assertThat(mapStandby.size()).isEqualTo(0);\n+\n+        // Wait until active map size becomes 0\n+        waitForReplication(size -> size == 0, mapActive, 0);\n+        log.info(\"After role switch during transfer phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isZero();\n+        assertThat(mapStandby.size()).isZero();\n+    }\n+\n+    /**\n+     * This test verifies config change with a role switch during a snapshot sync apply phase.\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 50 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync goes to apply phase\n+     * 5. Perform a role switch with corfu store\n+     * 6. Standby will continue apply and have size 50\n+     * 7. Verify both maps have size 50\n+     */\n+    //@Test\n+    public void testNewConfigWithSwitchRoleDuringApplyPhase() throws Exception {\n+        // Write 50 entry to active map\n+        for (int i = 0; i < largeBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", largeBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until apply phase\n+        UUID standbyStream = CorfuRuntime.getStreamID(streamName);\n+        while (!standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().containsKey(standbyStream)) {\n+            TimeUnit.MILLISECONDS.sleep(100L);\n+        }\n+\n+        log.info(\"======standby tail is : \" + standbyRuntime.getAddressSpaceView().getAllTails().getStreamTails().get(standbyStream));\n+\n+        // Perform a role switch\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_SWITCH,\n+                        DefaultClusterManager.OP_SWITCH, DefaultClusterManager.OP_SWITCH)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+\n+        // Should finish apply\n+        waitForReplication(size -> size == largeBatch, mapStandby, largeBatch);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        log.info(\"After role switch during apply phase, both maps have size {}. Current \" +\n+                        \"active corfu[{}] log tail is {}, standby corfu[{}] log tail is {}\",\n+                mapActive.size(), activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n+                standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(largeBatch);\n+        assertThat(mapStandby.size()).isEqualTo(largeBatch);\n+    }\n+\n+    /**\n+     * This test verifies config change with two active clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-active config update with corfu store\n+     * 7. Write 5 more entries to active map\n+     * 8. Verify data will not be replicated, since both are active\n+     */\n+    @Test\n+    public void testNewConfigWithTwoActive() throws Exception {\n+        // Write 10 entries to active map\n+        for (int i = 0; i < firstBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(firstBatch);\n+        assertThat(mapStandby.size()).isZero();\n+\n+        log.info(\"Before log replication, append {} entries to active map. Current active corfu\" +\n+                        \"[{}] log tail is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        activeReplicationServer = runReplicationServer(activeReplicationServerPort, nettyPluginPath);\n+        standbyReplicationServer = runReplicationServer(standbyReplicationServerPort, nettyPluginPath);\n+        log.info(\"Replication servers started, and replication is in progress...\");\n+\n+        // Wait until data is fully replicated\n+        waitForReplication(size -> size == firstBatch, mapStandby, firstBatch);\n+        log.info(\"After full sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", firstBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Write 5 entries to active map\n+        for (int i = firstBatch; i < secondBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(secondBatch);\n+\n+        // Wait until data is fully replicated again\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+        log.info(\"After delta sync, both maps have size {}. Current active corfu[{}] log tail \" +\n+                        \"is {}, standby corfu[{}] log tail is {}\", secondBatch, activeClusterCorfuPort,\n+                activeRuntime.getAddressSpaceView().getLogTail(), standbyClusterCorfuPort,\n+                standbyRuntime.getAddressSpaceView().getLogTail());\n+\n+        // Verify data\n+        for (int i = 0; i < secondBatch; i++) {\n+            assertThat(mapStandby.containsKey(String.valueOf(i))).isTrue();\n+        }\n+        log.info(\"Log replication succeeds without config change!\");\n+\n+        // Perform a config update with two active\n+        corfuStore.tx(DefaultClusterManager.CONFIG_NAMESPACE)\n+                .update(DefaultClusterManager.CONFIG_TABLE_NAME, DefaultClusterManager.OP_TWO_ACTIVE,\n+                        DefaultClusterManager.OP_TWO_ACTIVE, DefaultClusterManager.OP_TWO_ACTIVE)\n+                .commit();\n+        assertThat(configTable.count()).isOne();\n+        log.info(\"New topology config applied!\");\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+\n+        // Append to mapActive\n+        for (int i = secondBatch; i < thirdBatch; i++) {\n+            activeRuntime.getObjectsView().TXBegin();\n+            mapActive.put(String.valueOf(i), i);\n+            activeRuntime.getObjectsView().TXEnd();\n+        }\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        log.info(\"Active map has {} entries now!\", thirdBatch);\n+\n+        // Standby map should still have secondBatch size\n+        log.info(\"Standby map should still have {} size\", secondBatch);\n+        waitForReplication(size -> size == secondBatch, mapStandby, secondBatch);\n+\n+        // Double check after 10 seconds\n+        TimeUnit.SECONDS.sleep(mediumInterval);\n+        assertThat(mapActive.size()).isEqualTo(thirdBatch);\n+        assertThat(mapStandby.size()).isEqualTo(secondBatch);\n+    }\n+\n+    /**\n+     * This test verifies config change with two standby clusters\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Perform a two-standby config update with corfu store\n+     * 7. Write 5 more entries to active map", "originalCommit": "cb5ea7d22d7c8707897f92595c0d5fd7a6a5a8e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMTAzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2634#discussion_r459811037", "bodyText": "Good to know it", "author": "zhangn49", "createdAt": "2020-07-24T01:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwNDU1Nw=="}], "type": "inlineReview"}, {"oid": "c7fa2ef07f7cf6fb3ea7d52b68d06d3726090c14", "url": "https://github.com/CorfuDB/CorfuDB/commit/c7fa2ef07f7cf6fb3ea7d52b68d06d3726090c14", "message": "Address comments", "committedDate": "2020-07-24T01:21:55Z", "type": "commit"}, {"oid": "c7fa2ef07f7cf6fb3ea7d52b68d06d3726090c14", "url": "https://github.com/CorfuDB/CorfuDB/commit/c7fa2ef07f7cf6fb3ea7d52b68d06d3726090c14", "message": "Address comments", "committedDate": "2020-07-24T01:21:55Z", "type": "forcePushed"}]}