{"pr_number": 2812, "pr_title": "Protobuf Base RPCs", "pr_createdAt": "2020-11-03T23:36:07Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2812", "timeline": [{"oid": "e5790e0f35ebc947bbd7dd4460f84fb04ecaaacc", "url": "https://github.com/CorfuDB/CorfuDB/commit/e5790e0f35ebc947bbd7dd4460f84fb04ecaaacc", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-04T02:21:55Z", "type": "forcePushed"}, {"oid": "d3382899b66a4b5dc0c2d16e9387a95da63d3031", "url": "https://github.com/CorfuDB/CorfuDB/commit/d3382899b66a4b5dc0c2d16e9387a95da63d3031", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-04T02:27:02Z", "type": "forcePushed"}, {"oid": "99722c1d89a80062de39d17d226ab48136602bee", "url": "https://github.com/CorfuDB/CorfuDB/commit/99722c1d89a80062de39d17d226ab48136602bee", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-04T02:52:14Z", "type": "forcePushed"}, {"oid": "257172df5e3dd48580aa6f950002de833d16e739", "url": "https://github.com/CorfuDB/CorfuDB/commit/257172df5e3dd48580aa6f950002de833d16e739", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-04T03:00:18Z", "type": "forcePushed"}, {"oid": "6010a8355ec895a796810395ba937d130d8be49a", "url": "https://github.com/CorfuDB/CorfuDB/commit/6010a8355ec895a796810395ba937d130d8be49a", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-04T17:44:43Z", "type": "forcePushed"}, {"oid": "02dc3726c09b550ebb9f12f74c49360a76a0ca26", "url": "https://github.com/CorfuDB/CorfuDB/commit/02dc3726c09b550ebb9f12f74c49360a76a0ca26", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-04T20:41:18Z", "type": "forcePushed"}, {"oid": "7c92c2c79425bef438c7e0da357ddd7e622834d7", "url": "https://github.com/CorfuDB/CorfuDB/commit/7c92c2c79425bef438c7e0da357ddd7e622834d7", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-04T21:48:55Z", "type": "forcePushed"}, {"oid": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "url": "https://github.com/CorfuDB/CorfuDB/commit/6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-05T00:19:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNjQ0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517726448", "bodyText": "nit: if (!isServerReadyToHandleReq(req)) {", "author": "hisundar", "createdAt": "2020-11-05T01:21:45Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/AbstractServer.java", "diffHunk": "@@ -68,6 +109,33 @@ public final void handleMessage(CorfuMsg msg, ChannelHandlerContext ctx, IServer\n         processRequest(msg, ctx, r);\n     }\n \n+    /**\n+     * Handle a incoming request message.\n+     *\n+     * @param req An incoming request message.\n+     * @param ctx The channel handler context.\n+     * @param r   The router that took in the request message.\n+     */\n+    public final void handleRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if (getState() == ServerState.SHUTDOWN) {\n+            log.warn(\"handleRequest[{}]: Server received {} but is already shutdown.\",\n+                    req.getHeader().getRequestId(), req.getPayload().getPayloadCase().toString());\n+            return;\n+        }\n+\n+        if(!isServerReadyToHandleReq(req)) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTU1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489556", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNjQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzAyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517727024", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:23:50Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -27,15 +35,27 @@\n \n     private final ExecutorService executor;\n \n-    /** HandlerMethod for the base server. */\n+    /** [RM] HandlerMethod for the base server. */\n     @Getter\n     private final HandlerMethods handler = HandlerMethods.generateHandler(MethodHandles.lookup(), this);\n \n+    /**\n+     * RequestHandlerMethods for the Base server\n+     */\n+    @Getter\n+    private final RequestHandlerMethods handlerMethods =\n+            RequestHandlerMethods.generateHandler(MethodHandles.lookup(), this);\n+\n     @Override\n     public boolean isServerReadyToHandleMsg(CorfuMsg msg) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTY1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489659", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzMwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517727302", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:24:44Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -47,13 +67,19 @@ protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRo\n         executor.submit(() -> getHandler().handle(msg, ctx, r));", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTc3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489771", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzYwOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517727609", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:25:45Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -27,15 +35,27 @@\n \n     private final ExecutorService executor;\n \n-    /** HandlerMethod for the base server. */\n+    /** [RM] HandlerMethod for the base server. */", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTYxOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489619", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzY2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517727669", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:25:57Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/AbstractServer.java", "diffHunk": "@@ -48,6 +76,19 @@ protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRo\n     }\n \n     /**\n+     * A stub that handlers can override to manage their threading, otherwise\n+     * the requests will be executed on the IO threads\n+     * @param req An incoming request message.\n+     * @param ctx The channel handler context.\n+     * @param r The router that took in the request.\n+     */\n+    protected void processRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        getHandlerMethods().handle(req, ctx, r);\n+    }\n+\n+\n+    /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTQ4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489484", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzczMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517727731", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:26:06Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/AbstractServer.java", "diffHunk": "@@ -34,9 +50,21 @@ public void sealServerWithEpoch(long epoch) {\n         // Overridden in log unit to flush operations stamped with an old epoch\n     }\n \n+    // [RM] Remove this after Protobuf for RPC Completion\n     public abstract boolean isServerReadyToHandleMsg(CorfuMsg msg);\n \n     /**\n+     * Determine if the server is ready to handle a request.\n+     * @param request The incoming request message.\n+     * @return True if the server is ready to handle this request, and false otherwise.\n+     */\n+    public boolean isServerReadyToHandleReq(RequestMsg request) {\n+        //TODO: Make abstract once other servers are implemented\n+        return false;\n+    }\n+\n+    /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTQyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489420", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzc4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517727783", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:26:16Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/AbstractServer.java", "diffHunk": "@@ -19,12 +24,23 @@\n     private final AtomicReference<ServerState> state = new AtomicReference<>(ServerState.READY);\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTM2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489361", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzg0Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517727846", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:26:31Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -47,13 +67,19 @@ protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRo\n         executor.submit(() -> getHandler().handle(msg, ctx, r));\n     }\n \n+    @Override\n+    protected void processRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        executor.submit(() -> getHandlerMethods().handle(req, ctx, r));\n+    }\n+\n     @Override\n     public void shutdown() {\n         super.shutdown();\n         executor.shutdown();\n     }\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTgyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489828", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNzg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyODE4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517728186", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:27:41Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -78,7 +121,11 @@ private void keepAlive(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r)\n         r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n     }\n \n+    //TODO(Zach): Do we need a KEEP_ALIVE?\n+\n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTg2Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489866", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyODE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyOTQwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517729404", "bodyText": "just wondering why is only sendWrongEpochError handled a bit differently from other responses where the r.sendResponse(response, ctx) is replaced a specific function to do the work?", "author": "hisundar", "createdAt": "2020-11-05T01:31:45Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -125,6 +188,40 @@ public synchronized void handleMessageSetEpoch(@NonNull CorfuPayloadMsg<Long> ms\n     }\n \n     /**\n+     * Respond to a epoch change request.\n+     * This method also executes sealing logic on each individual server type.\n+     * @param req The incoming request message.\n+     * @param ctx The channel context.\n+     * @param r The server router.\n+     */\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.SEAL_REQUEST)\n+    private synchronized void handleSeal(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        try {\n+            final long epoch = req.getPayload().getSealRequest().getEpoch();\n+            String remoteHostAddress;\n+            try {\n+                remoteHostAddress = ((InetSocketAddress)ctx.channel().remoteAddress()).getAddress().getHostAddress();\n+            } catch(NullPointerException ex) {\n+                remoteHostAddress = \"unavailable\";\n+            }\n+\n+            log.info(\"handleSeal[{}]: Received SEAL from (clientId={}:{}), moving to new epoch {},\",\n+                    req.getHeader().getRequestId(), req.getHeader().getClientId(), remoteHostAddress, epoch);\n+\n+            serverContext.setServerEpoch(epoch, r);\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getSealResponseMsg());\n+            r.sendResponse(response, ctx);\n+        } catch (WrongEpochException e) {\n+            log.debug(\"handleSeal[{}]: Rejected SEAL current={}, requested={}\", req.getHeader().getRequestId(),\n+                    e.getCorrectEpoch(), req.getPayload().getSealRequest().getEpoch());\n+\n+            r.sendWrongEpochError(req.getHeader(), ctx, e.getCorrectEpoch());", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MzU0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518483549", "bodyText": "Good point. We did this a bit differently than the others because the other servers need to send a WrongEpochError too. This way, all of the server RPCs simply need to invoke this method with the original request header as well as the correct epoch.", "author": "zfrenette", "createdAt": "2020-11-06T02:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyOTQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM3NDg0Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526374846", "bodyText": "Note: this has since been addressed and is handled like the other responses.", "author": "zfrenette", "createdAt": "2020-11-18T19:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyOTQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyOTQ2Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517729462", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:31:55Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -125,6 +188,40 @@ public synchronized void handleMessageSetEpoch(@NonNull CorfuPayloadMsg<Long> ms\n     }\n \n     /**\n+     * Respond to a epoch change request.\n+     * This method also executes sealing logic on each individual server type.\n+     * @param req The incoming request message.\n+     * @param ctx The channel context.\n+     * @param r The server router.\n+     */\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.SEAL_REQUEST)\n+    private synchronized void handleSeal(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        try {\n+            final long epoch = req.getPayload().getSealRequest().getEpoch();\n+            String remoteHostAddress;\n+            try {\n+                remoteHostAddress = ((InetSocketAddress)ctx.channel().remoteAddress()).getAddress().getHostAddress();\n+            } catch(NullPointerException ex) {\n+                remoteHostAddress = \"unavailable\";\n+            }\n+\n+            log.info(\"handleSeal[{}]: Received SEAL from (clientId={}:{}), moving to new epoch {},\",\n+                    req.getHeader().getRequestId(), req.getHeader().getClientId(), remoteHostAddress, epoch);\n+\n+            serverContext.setServerEpoch(epoch, r);\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            ResponseMsg response = getResponseMsg(responseHeader, getSealResponseMsg());\n+            r.sendResponse(response, ctx);\n+        } catch (WrongEpochException e) {\n+            log.debug(\"handleSeal[{}]: Rejected SEAL current={}, requested={}\", req.getHeader().getRequestId(),\n+                    e.getCorrectEpoch(), req.getPayload().getSealRequest().getEpoch());\n+\n+            r.sendWrongEpochError(req.getHeader(), ctx, e.getCorrectEpoch());\n+        }\n+    }\n+\n+    /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTk0Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489943", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyOTQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyOTk1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517729950", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:33:43Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -141,6 +238,26 @@ private void doReset(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n     }\n \n     /**\n+     * Reset the JVM. This mechanism leverages that corfu_server runs in a bash script\n+     * which monitors the exit code of Corfu. If the exit code is 100, then it resets\n+     * the server and DELETES ALL EXISTING DATA.\n+     * @param req The incoming request message.\n+     * @param ctx The channel context.\n+     * @param r The server router.\n+     */\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.RESET_REQUEST)\n+    private void handleReset(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        log.warn(\"handleReset[{}]: Remote reset requested from client {}\",\n+                req.getHeader().getRequestId(), req.getHeader().getClientId());\n+\n+        HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getResetResponseMsg());\n+        r.sendResponse(response, ctx);\n+        CorfuServer.restartServer(true);\n+    }\n+\n+    /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTk5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518489995", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T02:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyOTk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDAwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517730006", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:33:56Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -21,8 +29,11 @@\n     // Lombok annotations are not allowed for the interfaces.\n     Logger log = LoggerFactory.getLogger(IServerRouter.class);\n \n+    // [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAxOTM3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519019375", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T21:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDI2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517730260", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:34:46Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -56,6 +67,8 @@\n     void setServerContext(ServerContext serverContext);\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAxOTQ3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519019471", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T21:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDI5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517730291", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:34:55Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -69,6 +82,8 @@ default void sendWrongEpochMessage(CorfuMsg msg, ChannelHandlerContext ctx) {\n     }\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyNzMwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519027304", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T22:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDMzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517730333", "bodyText": "Do you want to consider adding the @deprecated annotation over the method so the IDE itself flags these methods are deprecated?", "author": "hisundar", "createdAt": "2020-11-05T01:35:00Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -80,6 +95,8 @@ default void sendNoBootstrapMessage(CorfuMsg msg, ChannelHandlerContext ctx) {\n     }\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAxOTUzOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519019538", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T21:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDM4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517730384", "bodyText": "ditto", "author": "hisundar", "createdAt": "2020-11-05T01:35:12Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -94,6 +111,8 @@ default void sendWrongClusterIdMessage(CorfuMsg msg, ChannelHandlerContext ctx,\n     }\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyNzQ1NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519027454", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T22:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDQxOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517730419", "bodyText": "ditto", "author": "hisundar", "createdAt": "2020-11-05T01:35:19Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -112,6 +131,8 @@ default boolean epochIsValid(CorfuMsg msg, ChannelHandlerContext ctx) {\n     }\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAxOTYyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519019628", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T21:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDQ1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517730459", "bodyText": "ditto", "author": "hisundar", "createdAt": "2020-11-05T01:35:26Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -132,6 +153,8 @@ default boolean clusterIdIsValid(CorfuMsg msg, ChannelHandlerContext ctx, Layout\n     }\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAxOTY4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519019687", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T21:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDQ3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517730476", "bodyText": "ditto", "author": "hisundar", "createdAt": "2020-11-05T01:35:32Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -159,6 +182,8 @@ default boolean messageIsValid(CorfuMsg msg, ChannelHandlerContext ctx) {\n     }\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAxOTczNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519019735", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T21:42:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMDQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTA4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517731085", "bodyText": "nit: if (requestHeader.getEpoch() != serverEpoch) {", "author": "hisundar", "createdAt": "2020-11-05T01:37:40Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -170,4 +195,117 @@ default boolean messageIsValid(CorfuMsg msg, ChannelHandlerContext ctx) {\n      */\n     default void sendResponse(CorfuMsg inMsg, CorfuMsg outMsg) {}\n \n+    /**\n+     * Send a WRONG_EPOCH error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param correctEpoch The current epoch.\n+     */\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx, long correctEpoch) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(correctEpoch));\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongEpochError[{}]: Incoming request received with wrong epoch, got {}, expected {}, \" +\n+                \"request was {}\", requestHeader.getRequestId(), requestHeader.getEpoch(), correctEpoch, requestHeader);\n+    }\n+\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        sendWrongEpochError(requestHeader, ctx, getServerEpoch());\n+    }\n+\n+    /**\n+     * Send a NOT_BOOTSTRAPPED error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     */\n+    default void sendNoBootstrapError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getNotBootstrappedErrorMsg());\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendNoBootstrapError[{}]: Received request but not bootstrapped! Request was {}\",\n+                requestHeader.getRequestId(), requestHeader);\n+    }\n+\n+    /**\n+     * Send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param clusterId The current cluster id.\n+     */\n+    default void sendWrongClusterError(HeaderMsg requestHeader, ChannelHandlerContext ctx, UuidMsg clusterId) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader,\n+                getWrongClusterErrorMsg(clusterId, requestHeader.getClusterId()));\n+\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongClusterError[{}]: Incoming request with a wrong cluster id, got {}, expected {}, \" +\n+                \"request was: {}\", requestHeader.getRequestId(), requestHeader.getClusterId(), clusterId, requestHeader);\n+    }\n+\n+    /**\n+     * Validate the epoch of an incoming request and send a WRONG_EPOCH error response\n+     * if the server is in the wrong epoch.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @return True, if the epoch is correct, but false otherwise.\n+     */\n+    default boolean epochIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        final long serverEpoch = getServerEpoch();\n+        if(requestHeader.getEpoch() != serverEpoch) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTY4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517731682", "bodyText": "nit: if (!match) {", "author": "hisundar", "createdAt": "2020-11-05T01:39:40Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -170,4 +195,117 @@ default boolean messageIsValid(CorfuMsg msg, ChannelHandlerContext ctx) {\n      */\n     default void sendResponse(CorfuMsg inMsg, CorfuMsg outMsg) {}\n \n+    /**\n+     * Send a WRONG_EPOCH error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param correctEpoch The current epoch.\n+     */\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx, long correctEpoch) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(correctEpoch));\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongEpochError[{}]: Incoming request received with wrong epoch, got {}, expected {}, \" +\n+                \"request was {}\", requestHeader.getRequestId(), requestHeader.getEpoch(), correctEpoch, requestHeader);\n+    }\n+\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        sendWrongEpochError(requestHeader, ctx, getServerEpoch());\n+    }\n+\n+    /**\n+     * Send a NOT_BOOTSTRAPPED error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     */\n+    default void sendNoBootstrapError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getNotBootstrappedErrorMsg());\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendNoBootstrapError[{}]: Received request but not bootstrapped! Request was {}\",\n+                requestHeader.getRequestId(), requestHeader);\n+    }\n+\n+    /**\n+     * Send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param clusterId The current cluster id.\n+     */\n+    default void sendWrongClusterError(HeaderMsg requestHeader, ChannelHandlerContext ctx, UuidMsg clusterId) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader,\n+                getWrongClusterErrorMsg(clusterId, requestHeader.getClusterId()));\n+\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongClusterError[{}]: Incoming request with a wrong cluster id, got {}, expected {}, \" +\n+                \"request was: {}\", requestHeader.getRequestId(), requestHeader.getClusterId(), clusterId, requestHeader);\n+    }\n+\n+    /**\n+     * Validate the epoch of an incoming request and send a WRONG_EPOCH error response\n+     * if the server is in the wrong epoch.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @return True, if the epoch is correct, but false otherwise.\n+     */\n+    default boolean epochIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        final long serverEpoch = getServerEpoch();\n+        if(requestHeader.getEpoch() != serverEpoch) {\n+            sendWrongEpochError(requestHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Validate that the cluster ID of the incoming request is equal to the cluster ID of a\n+     * bootstrapped layout. If this is not the case, send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @param layout The layout a server was bootstrapped with.\n+     * @return True, if the cluster ID of the request matches the cluster ID of the layout, but false otherwise.\n+     */\n+    default boolean clusterIdIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx, Layout layout) {\n+        UuidMsg currentClusterID = getUuidMsg(layout.getClusterId());\n+        boolean match = requestHeader.getClusterId().equals(currentClusterID);\n+\n+        if(!match) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMzE4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517733189", "bodyText": "This function is doing more than just returning if epochIsValid() it is also sending a response back, so should the function name be something different to reflect that? or refactor this such that the response sent is separate from the check itself?", "author": "hisundar", "createdAt": "2020-11-05T01:44:33Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -170,4 +195,117 @@ default boolean messageIsValid(CorfuMsg msg, ChannelHandlerContext ctx) {\n      */\n     default void sendResponse(CorfuMsg inMsg, CorfuMsg outMsg) {}\n \n+    /**\n+     * Send a WRONG_EPOCH error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param correctEpoch The current epoch.\n+     */\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx, long correctEpoch) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(correctEpoch));\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongEpochError[{}]: Incoming request received with wrong epoch, got {}, expected {}, \" +\n+                \"request was {}\", requestHeader.getRequestId(), requestHeader.getEpoch(), correctEpoch, requestHeader);\n+    }\n+\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        sendWrongEpochError(requestHeader, ctx, getServerEpoch());\n+    }\n+\n+    /**\n+     * Send a NOT_BOOTSTRAPPED error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     */\n+    default void sendNoBootstrapError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getNotBootstrappedErrorMsg());\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendNoBootstrapError[{}]: Received request but not bootstrapped! Request was {}\",\n+                requestHeader.getRequestId(), requestHeader);\n+    }\n+\n+    /**\n+     * Send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param clusterId The current cluster id.\n+     */\n+    default void sendWrongClusterError(HeaderMsg requestHeader, ChannelHandlerContext ctx, UuidMsg clusterId) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader,\n+                getWrongClusterErrorMsg(clusterId, requestHeader.getClusterId()));\n+\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongClusterError[{}]: Incoming request with a wrong cluster id, got {}, expected {}, \" +\n+                \"request was: {}\", requestHeader.getRequestId(), requestHeader.getClusterId(), clusterId, requestHeader);\n+    }\n+\n+    /**\n+     * Validate the epoch of an incoming request and send a WRONG_EPOCH error response\n+     * if the server is in the wrong epoch.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @return True, if the epoch is correct, but false otherwise.\n+     */\n+    default boolean epochIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyMDE3NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519020174", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T21:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMzE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMzU5Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517733597", "bodyText": "this function is doing more than just validate the clusterId, it is also sending a response back.\nDo you want to consider either renaming the function or better still having separate methods, one to send an error and one to do the check?", "author": "hisundar", "createdAt": "2020-11-05T01:45:54Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -170,4 +195,117 @@ default boolean messageIsValid(CorfuMsg msg, ChannelHandlerContext ctx) {\n      */\n     default void sendResponse(CorfuMsg inMsg, CorfuMsg outMsg) {}\n \n+    /**\n+     * Send a WRONG_EPOCH error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param correctEpoch The current epoch.\n+     */\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx, long correctEpoch) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(correctEpoch));\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongEpochError[{}]: Incoming request received with wrong epoch, got {}, expected {}, \" +\n+                \"request was {}\", requestHeader.getRequestId(), requestHeader.getEpoch(), correctEpoch, requestHeader);\n+    }\n+\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        sendWrongEpochError(requestHeader, ctx, getServerEpoch());\n+    }\n+\n+    /**\n+     * Send a NOT_BOOTSTRAPPED error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     */\n+    default void sendNoBootstrapError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getNotBootstrappedErrorMsg());\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendNoBootstrapError[{}]: Received request but not bootstrapped! Request was {}\",\n+                requestHeader.getRequestId(), requestHeader);\n+    }\n+\n+    /**\n+     * Send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param clusterId The current cluster id.\n+     */\n+    default void sendWrongClusterError(HeaderMsg requestHeader, ChannelHandlerContext ctx, UuidMsg clusterId) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader,\n+                getWrongClusterErrorMsg(clusterId, requestHeader.getClusterId()));\n+\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongClusterError[{}]: Incoming request with a wrong cluster id, got {}, expected {}, \" +\n+                \"request was: {}\", requestHeader.getRequestId(), requestHeader.getClusterId(), clusterId, requestHeader);\n+    }\n+\n+    /**\n+     * Validate the epoch of an incoming request and send a WRONG_EPOCH error response\n+     * if the server is in the wrong epoch.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @return True, if the epoch is correct, but false otherwise.\n+     */\n+    default boolean epochIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        final long serverEpoch = getServerEpoch();\n+        if(requestHeader.getEpoch() != serverEpoch) {\n+            sendWrongEpochError(requestHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Validate that the cluster ID of the incoming request is equal to the cluster ID of a\n+     * bootstrapped layout. If this is not the case, send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @param layout The layout a server was bootstrapped with.\n+     * @return True, if the cluster ID of the request matches the cluster ID of the layout, but false otherwise.\n+     */\n+    default boolean clusterIdIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx, Layout layout) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyMDIyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519020229", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T21:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMzU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMzY3MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517733670", "bodyText": "Shouldn't this be returning true?\nalso nit: if (..) {\nreturn true;\n}", "author": "hisundar", "createdAt": "2020-11-05T01:46:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -170,4 +195,117 @@ default boolean messageIsValid(CorfuMsg msg, ChannelHandlerContext ctx) {\n      */\n     default void sendResponse(CorfuMsg inMsg, CorfuMsg outMsg) {}\n \n+    /**\n+     * Send a WRONG_EPOCH error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param correctEpoch The current epoch.\n+     */\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx, long correctEpoch) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(correctEpoch));\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongEpochError[{}]: Incoming request received with wrong epoch, got {}, expected {}, \" +\n+                \"request was {}\", requestHeader.getRequestId(), requestHeader.getEpoch(), correctEpoch, requestHeader);\n+    }\n+\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        sendWrongEpochError(requestHeader, ctx, getServerEpoch());\n+    }\n+\n+    /**\n+     * Send a NOT_BOOTSTRAPPED error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     */\n+    default void sendNoBootstrapError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getNotBootstrappedErrorMsg());\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendNoBootstrapError[{}]: Received request but not bootstrapped! Request was {}\",\n+                requestHeader.getRequestId(), requestHeader);\n+    }\n+\n+    /**\n+     * Send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param clusterId The current cluster id.\n+     */\n+    default void sendWrongClusterError(HeaderMsg requestHeader, ChannelHandlerContext ctx, UuidMsg clusterId) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader,\n+                getWrongClusterErrorMsg(clusterId, requestHeader.getClusterId()));\n+\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongClusterError[{}]: Incoming request with a wrong cluster id, got {}, expected {}, \" +\n+                \"request was: {}\", requestHeader.getRequestId(), requestHeader.getClusterId(), clusterId, requestHeader);\n+    }\n+\n+    /**\n+     * Validate the epoch of an incoming request and send a WRONG_EPOCH error response\n+     * if the server is in the wrong epoch.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @return True, if the epoch is correct, but false otherwise.\n+     */\n+    default boolean epochIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        final long serverEpoch = getServerEpoch();\n+        if(requestHeader.getEpoch() != serverEpoch) {\n+            sendWrongEpochError(requestHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Validate that the cluster ID of the incoming request is equal to the cluster ID of a\n+     * bootstrapped layout. If this is not the case, send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @param layout The layout a server was bootstrapped with.\n+     * @return True, if the cluster ID of the request matches the cluster ID of the layout, but false otherwise.\n+     */\n+    default boolean clusterIdIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx, Layout layout) {\n+        UuidMsg currentClusterID = getUuidMsg(layout.getClusterId());\n+        boolean match = requestHeader.getClusterId().equals(currentClusterID);\n+\n+        if(!match) {\n+            sendWrongClusterError(requestHeader, ctx, currentClusterID);\n+        }\n+\n+        return match;\n+    }\n+\n+    /**\n+     * Validate the incoming request. The request is valid if:\n+     *    1) The flag ignoreEpoch is set to true, or it's set to false and the epoch is valid.\n+     *    2) Also, if the flag ignoreClusterId is set to false,\n+     *           a. The current layout server should be bootstrapped and\n+     *           b. the request's cluster ID should be equal to the bootstrapped layout's cluster ID.\n+     *\n+     * @param req The incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @return True if the request is valid, and false otherwise.\n+     */\n+    default boolean requestIsValid(RequestMsg req, ChannelHandlerContext ctx) {\n+        HeaderMsg requestHeader = req.getHeader();\n+\n+        if(!requestHeader.getIgnoreEpoch() && epochIsValid(requestHeader, ctx)) return false;", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyNzk2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518927968", "bodyText": "Good catch. I was supposed to negate epochIsValid.", "author": "zfrenette", "createdAt": "2020-11-06T18:25:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMzY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMzg2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517733864", "bodyText": "do you want to consider splitting the functions into the ones that send the response and the ones that do the checks?", "author": "hisundar", "createdAt": "2020-11-05T01:46:50Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -170,4 +195,117 @@ default boolean messageIsValid(CorfuMsg msg, ChannelHandlerContext ctx) {\n      */\n     default void sendResponse(CorfuMsg inMsg, CorfuMsg outMsg) {}\n \n+    /**\n+     * Send a WRONG_EPOCH error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param correctEpoch The current epoch.\n+     */\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx, long correctEpoch) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(correctEpoch));\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongEpochError[{}]: Incoming request received with wrong epoch, got {}, expected {}, \" +\n+                \"request was {}\", requestHeader.getRequestId(), requestHeader.getEpoch(), correctEpoch, requestHeader);\n+    }\n+\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        sendWrongEpochError(requestHeader, ctx, getServerEpoch());\n+    }\n+\n+    /**\n+     * Send a NOT_BOOTSTRAPPED error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     */\n+    default void sendNoBootstrapError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getNotBootstrappedErrorMsg());\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendNoBootstrapError[{}]: Received request but not bootstrapped! Request was {}\",\n+                requestHeader.getRequestId(), requestHeader);\n+    }\n+\n+    /**\n+     * Send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param clusterId The current cluster id.\n+     */\n+    default void sendWrongClusterError(HeaderMsg requestHeader, ChannelHandlerContext ctx, UuidMsg clusterId) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader,\n+                getWrongClusterErrorMsg(clusterId, requestHeader.getClusterId()));\n+\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongClusterError[{}]: Incoming request with a wrong cluster id, got {}, expected {}, \" +\n+                \"request was: {}\", requestHeader.getRequestId(), requestHeader.getClusterId(), clusterId, requestHeader);\n+    }\n+\n+    /**\n+     * Validate the epoch of an incoming request and send a WRONG_EPOCH error response\n+     * if the server is in the wrong epoch.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @return True, if the epoch is correct, but false otherwise.\n+     */\n+    default boolean epochIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        final long serverEpoch = getServerEpoch();\n+        if(requestHeader.getEpoch() != serverEpoch) {\n+            sendWrongEpochError(requestHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Validate that the cluster ID of the incoming request is equal to the cluster ID of a\n+     * bootstrapped layout. If this is not the case, send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @param layout The layout a server was bootstrapped with.\n+     * @return True, if the cluster ID of the request matches the cluster ID of the layout, but false otherwise.\n+     */\n+    default boolean clusterIdIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx, Layout layout) {\n+        UuidMsg currentClusterID = getUuidMsg(layout.getClusterId());\n+        boolean match = requestHeader.getClusterId().equals(currentClusterID);\n+\n+        if(!match) {\n+            sendWrongClusterError(requestHeader, ctx, currentClusterID);\n+        }\n+\n+        return match;\n+    }\n+\n+    /**\n+     * Validate the incoming request. The request is valid if:\n+     *    1) The flag ignoreEpoch is set to true, or it's set to false and the epoch is valid.\n+     *    2) Also, if the flag ignoreClusterId is set to false,\n+     *           a. The current layout server should be bootstrapped and\n+     *           b. the request's cluster ID should be equal to the bootstrapped layout's cluster ID.\n+     *\n+     * @param req The incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @return True if the request is valid, and false otherwise.\n+     */\n+    default boolean requestIsValid(RequestMsg req, ChannelHandlerContext ctx) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzOTcwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518939701", "bodyText": "I am doing so with the methods above, but it's a bit awkward to do for requestIsValid since we need to distinguish between multiple error conditions. I can update the method name and Javadoc to specify that a response is sent in the case of an error.", "author": "zfrenette", "createdAt": "2020-11-06T18:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMzg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMzk1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517733959", "bodyText": "nit: if (!requestHeader.getIgnoreClusterId()) {", "author": "hisundar", "createdAt": "2020-11-05T01:47:06Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -170,4 +195,117 @@ default boolean messageIsValid(CorfuMsg msg, ChannelHandlerContext ctx) {\n      */\n     default void sendResponse(CorfuMsg inMsg, CorfuMsg outMsg) {}\n \n+    /**\n+     * Send a WRONG_EPOCH error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param correctEpoch The current epoch.\n+     */\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx, long correctEpoch) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(correctEpoch));\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongEpochError[{}]: Incoming request received with wrong epoch, got {}, expected {}, \" +\n+                \"request was {}\", requestHeader.getRequestId(), requestHeader.getEpoch(), correctEpoch, requestHeader);\n+    }\n+\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        sendWrongEpochError(requestHeader, ctx, getServerEpoch());\n+    }\n+\n+    /**\n+     * Send a NOT_BOOTSTRAPPED error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     */\n+    default void sendNoBootstrapError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getNotBootstrappedErrorMsg());\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendNoBootstrapError[{}]: Received request but not bootstrapped! Request was {}\",\n+                requestHeader.getRequestId(), requestHeader);\n+    }\n+\n+    /**\n+     * Send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param clusterId The current cluster id.\n+     */\n+    default void sendWrongClusterError(HeaderMsg requestHeader, ChannelHandlerContext ctx, UuidMsg clusterId) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader,\n+                getWrongClusterErrorMsg(clusterId, requestHeader.getClusterId()));\n+\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongClusterError[{}]: Incoming request with a wrong cluster id, got {}, expected {}, \" +\n+                \"request was: {}\", requestHeader.getRequestId(), requestHeader.getClusterId(), clusterId, requestHeader);\n+    }\n+\n+    /**\n+     * Validate the epoch of an incoming request and send a WRONG_EPOCH error response\n+     * if the server is in the wrong epoch.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @return True, if the epoch is correct, but false otherwise.\n+     */\n+    default boolean epochIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        final long serverEpoch = getServerEpoch();\n+        if(requestHeader.getEpoch() != serverEpoch) {\n+            sendWrongEpochError(requestHeader, ctx);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Validate that the cluster ID of the incoming request is equal to the cluster ID of a\n+     * bootstrapped layout. If this is not the case, send a WRONG_CLUSTER error response.\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param ctx The context of the channel handler.\n+     * @param layout The layout a server was bootstrapped with.\n+     * @return True, if the cluster ID of the request matches the cluster ID of the layout, but false otherwise.\n+     */\n+    default boolean clusterIdIsValid(HeaderMsg requestHeader, ChannelHandlerContext ctx, Layout layout) {\n+        UuidMsg currentClusterID = getUuidMsg(layout.getClusterId());\n+        boolean match = requestHeader.getClusterId().equals(currentClusterID);\n+\n+        if(!match) {\n+            sendWrongClusterError(requestHeader, ctx, currentClusterID);\n+        }\n+\n+        return match;\n+    }\n+\n+    /**\n+     * Validate the incoming request. The request is valid if:\n+     *    1) The flag ignoreEpoch is set to true, or it's set to false and the epoch is valid.\n+     *    2) Also, if the flag ignoreClusterId is set to false,\n+     *           a. The current layout server should be bootstrapped and\n+     *           b. the request's cluster ID should be equal to the bootstrapped layout's cluster ID.\n+     *\n+     * @param req The incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @return True if the request is valid, and false otherwise.\n+     */\n+    default boolean requestIsValid(RequestMsg req, ChannelHandlerContext ctx) {\n+        HeaderMsg requestHeader = req.getHeader();\n+\n+        if(!requestHeader.getIgnoreEpoch() && epochIsValid(requestHeader, ctx)) return false;\n+\n+        if(!requestHeader.getIgnoreClusterId()) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyMDQ4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519020481", "bodyText": "Fixed.", "author": "zfrenette", "createdAt": "2020-11-06T21:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMzk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDY3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517734673", "bodyText": "@deprecated ?", "author": "hisundar", "createdAt": "2020-11-05T01:49:32Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/NettyServerRouter.java", "diffHunk": "@@ -9,29 +9,37 @@\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.protocols.wireprotocol.CorfuMsg;\n import org.corfudb.protocols.wireprotocol.CorfuMsgType;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n import org.corfudb.runtime.view.Layout;\n \n import java.util.EnumMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.Set;\n-\n \n /**\n- * The netty server router routes incoming messages to registered roles using\n- * the\n+ * The netty server router routes incoming messages to registered roles using the\n+ * handlerMap (in the case of a legacy CorfuMsg) and requestTypeHandlerMap (in\n+ * the case of a Protobuf RequestMsg).\n  * Created by mwei on 12/1/15.\n  */\n @Slf4j\n @ChannelHandler.Sharable\n public class NettyServerRouter extends ChannelInboundHandlerAdapter implements IServerRouter {\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyODAyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519028022", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T22:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDgwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517734804", "bodyText": "@deprecated ?", "author": "hisundar", "createdAt": "2020-11-05T01:49:59Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/NettyServerRouter.java", "diffHunk": "@@ -89,6 +107,8 @@ public void setServerContext(ServerContext serverContext) {\n     }\n \n     /**\n+     * [RM] Remove this after Protobuf for RPC Completion", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NTA4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519055080", "bodyText": "Added.", "author": "zfrenette", "createdAt": "2020-11-06T23:32:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNTUwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517735502", "bodyText": "this is more than a check - it also sends out a message. Can we split the check and the action for clarity perhaps?", "author": "hisundar", "createdAt": "2020-11-05T01:52:28Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/NettyServerRouter.java", "diffHunk": "@@ -115,34 +146,64 @@ public void sendResponse(ChannelHandlerContext ctx, CorfuMsg inMsg, CorfuMsg out\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object msg) {\n         try {\n-            // The incoming message should have been transformed to a CorfuMsg earlier in the\n-            // pipeline.\n-            CorfuMsg m = ((CorfuMsg) msg);\n-            // We get the handler for this message from the map\n-            AbstractServer handler = handlerMap.get(m.getMsgType());\n-            if (handler == null) {\n-                // The message was unregistered, we are dropping it.\n-                log.warn(\"Received unregistered message {}, dropping\", m);\n-            } else {\n-                if (messageIsValid(m, ctx)) {\n-                    // Route the message to the handler.\n-                    if (log.isTraceEnabled()) {\n-                        log.trace(\"Message routed to {}: {}\", handler.getClass().getSimpleName(), msg);\n+            if (msg instanceof CorfuMsg) {\n+                // The incoming message should have been transformed to a CorfuMsg earlier in the pipeline.\n+                CorfuMsg m = ((CorfuMsg) msg);\n+                // We get the handler for this message from the map\n+                AbstractServer handler = handlerMap.get(m.getMsgType());\n+                if (handler == null) {\n+                    // The message was unregistered, we are dropping it.\n+                    log.warn(\"channelRead: Received unregistered message {}, dropping\", m);\n+                } else {\n+                    if (messageIsValid(m, ctx)) {\n+                        // Route the message to the handler.\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"channelRead: Message routed to {}: {}\", handler.getClass().getSimpleName(), msg);\n+                        }\n+\n+                        try {\n+                            handler.handleMessage(m, ctx, this);\n+                        } catch (Throwable t) {\n+                            log.error(\"channelRead: Handling {} failed due to {}:{}\",\n+                                    m != null ? m.getMsgType() : \"UNKNOWN\",\n+                                    t.getClass().getSimpleName(),\n+                                    t.getMessage(),\n+                                    t);\n+                        }\n                     }\n+                }\n+            } else if (msg instanceof RequestMsg) {\n+                RequestMsg request = ((RequestMsg) msg);\n+                RequestPayloadMsg payload = request.getPayload();\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"channelRead: Request {} from {}\",\n+                            payload.getPayloadCase().toString(), ctx.channel().remoteAddress());\n+                }\n \n-                    try {\n-                        handler.handleMessage(m, ctx, this);\n-                    } catch (Throwable t) {\n-                        log.error(\"channelRead: Handling {} failed due to {}:{}\",\n-                                m != null ? m.getMsgType() : \"UNKNOWN\",\n-                                t.getClass().getSimpleName(),\n-                                t.getMessage(),\n-                                t);\n+                AbstractServer handler = requestTypeHandlerMap.get(payload.getPayloadCase());\n+                if (handler == null) {\n+                    log.warn(\"channelRead: Received unregistered request {}, dropping\",\n+                            payload.getPayloadCase().toString());\n+                } else {\n+                    if (requestIsValid(request, ctx)) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NDc2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518974765", "bodyText": "See my comment above regarding the splitting of requestIsValid.", "author": "zfrenette", "createdAt": "2020-11-06T20:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNTUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNTg0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517735841", "bodyText": "nit: I think for java docs you might want to leave a line after the /**", "author": "hisundar", "createdAt": "2020-11-05T01:53:42Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/RequestHandlerMethods.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.corfudb.infrastructure;\n+\n+import com.codahale.metrics.Timer;\n+import io.netty.channel.ChannelHandlerContext;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuError;\n+import org.corfudb.util.CorfuComponent;\n+import org.corfudb.util.MetricsUtils;\n+\n+import static org.corfudb.protocols.CorfuProtocolServerErrors.getUnknownErrorMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+\n+@Slf4j\n+public class RequestHandlerMethods {\n+\n+    private final Map<RequestPayloadMsg.PayloadCase, String> timerNameCache = new HashMap<>();\n+\n+    /** The handler map. */\n+    private final Map<RequestPayloadMsg.PayloadCase, HandlerMethod> handlerMap;\n+\n+    /**\n+     * A functional interface for server request handlers. Server request handlers should\n+     * be fast and not block. If a handler blocks for an extended period of time, it will\n+     * exhaust the server's thread pool. I/O and other long operations should be handled\n+     * on another thread.\n+     */\n+    @FunctionalInterface\n+    public interface HandlerMethod {\n+        void handle(@Nonnull RequestMsg req,\n+                    @Nonnull ChannelHandlerContext ctx,\n+                    @Nonnull IServerRouter r);\n+    }\n+\n+    /** Get the types of requests this handler will handle.\n+     *\n+     * @return  A set containing the types of requests this handler will handle.\n+     */\n+    public Set<RequestPayloadMsg.PayloadCase> getHandledTypes() {\n+        return handlerMap.keySet();\n+    }\n+\n+    /** Construct a new instance of RequestHandlerMethods. */\n+    public RequestHandlerMethods() {\n+        handlerMap = new EnumMap<>(RequestPayloadMsg.PayloadCase.class);\n+    }\n+\n+    /** Handle an incoming Corfu request message.\n+     *\n+     * @param req       The request message to handle.\n+     * @param ctx       The channel handler context.\n+     * @param r         The server router.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void handle(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HandlerMethod handler = handlerMap.get(req.getPayload().getPayloadCase());\n+        try {\n+            handler.handle(req, ctx, r);\n+        } catch(Exception e) {\n+            log.error(\"handle[{}]: Unhandled exception processing {} request\",\n+                    req.getHeader().getRequestId(), req.getPayload().getPayloadCase(), e);\n+\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            r.sendResponse(getResponseMsg(responseHeader, getUnknownErrorMsg(e)), ctx);\n+        }\n+    }\n+\n+    /** Generate handlers for a particular server.", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NDY5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519054696", "bodyText": "Fixed.", "author": "zfrenette", "createdAt": "2020-11-06T23:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNjE4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517736189", "bodyText": "nit: if (handlerMap.containsKey(annotation.type())) {", "author": "hisundar", "createdAt": "2020-11-05T01:54:53Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/RequestHandlerMethods.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.corfudb.infrastructure;\n+\n+import com.codahale.metrics.Timer;\n+import io.netty.channel.ChannelHandlerContext;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuError;\n+import org.corfudb.util.CorfuComponent;\n+import org.corfudb.util.MetricsUtils;\n+\n+import static org.corfudb.protocols.CorfuProtocolServerErrors.getUnknownErrorMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+\n+@Slf4j\n+public class RequestHandlerMethods {\n+\n+    private final Map<RequestPayloadMsg.PayloadCase, String> timerNameCache = new HashMap<>();\n+\n+    /** The handler map. */\n+    private final Map<RequestPayloadMsg.PayloadCase, HandlerMethod> handlerMap;\n+\n+    /**\n+     * A functional interface for server request handlers. Server request handlers should\n+     * be fast and not block. If a handler blocks for an extended period of time, it will\n+     * exhaust the server's thread pool. I/O and other long operations should be handled\n+     * on another thread.\n+     */\n+    @FunctionalInterface\n+    public interface HandlerMethod {\n+        void handle(@Nonnull RequestMsg req,\n+                    @Nonnull ChannelHandlerContext ctx,\n+                    @Nonnull IServerRouter r);\n+    }\n+\n+    /** Get the types of requests this handler will handle.\n+     *\n+     * @return  A set containing the types of requests this handler will handle.\n+     */\n+    public Set<RequestPayloadMsg.PayloadCase> getHandledTypes() {\n+        return handlerMap.keySet();\n+    }\n+\n+    /** Construct a new instance of RequestHandlerMethods. */\n+    public RequestHandlerMethods() {\n+        handlerMap = new EnumMap<>(RequestPayloadMsg.PayloadCase.class);\n+    }\n+\n+    /** Handle an incoming Corfu request message.\n+     *\n+     * @param req       The request message to handle.\n+     * @param ctx       The channel handler context.\n+     * @param r         The server router.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void handle(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HandlerMethod handler = handlerMap.get(req.getPayload().getPayloadCase());\n+        try {\n+            handler.handle(req, ctx, r);\n+        } catch(Exception e) {\n+            log.error(\"handle[{}]: Unhandled exception processing {} request\",\n+                    req.getHeader().getRequestId(), req.getPayload().getPayloadCase(), e);\n+\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            r.sendResponse(getResponseMsg(responseHeader, getUnknownErrorMsg(e)), ctx);\n+        }\n+    }\n+\n+    /** Generate handlers for a particular server.\n+     *\n+     * @param caller    The context that is being used. Call MethodHandles.lookup() to obtain.\n+     * @param server    The object that implements the server.\n+     * @return          New request handlers for caller class.\n+     */\n+    public static RequestHandlerMethods generateHandler(@Nonnull final MethodHandles.Lookup caller,\n+                                                        @NonNull final AbstractServer server) {\n+        RequestHandlerMethods handler = new RequestHandlerMethods();\n+        Arrays.stream(server.getClass().getDeclaredMethods())\n+                .filter(method -> method.isAnnotationPresent(RequestHandler.class))\n+                .forEach(method -> handler.registerMethod(caller, server, method));\n+        return handler;\n+    }\n+\n+    private void registerMethod(@Nonnull final MethodHandles.Lookup caller,\n+                                @Nonnull final AbstractServer server,\n+                                @Nonnull final Method method) {\n+        final RequestHandler annotation = method.getAnnotation(RequestHandler.class);\n+\n+        if(handlerMap.containsKey(annotation.type())) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NTAyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519055024", "bodyText": "Fixed.", "author": "zfrenette", "createdAt": "2020-11-06T23:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNjE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzU0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517737541", "bodyText": "This function does a lot of reflection / analysis based generation. So perhaps some more inline or generic comments on the function to help understand better?", "author": "hisundar", "createdAt": "2020-11-05T01:59:33Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/RequestHandlerMethods.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.corfudb.infrastructure;\n+\n+import com.codahale.metrics.Timer;\n+import io.netty.channel.ChannelHandlerContext;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuError;\n+import org.corfudb.util.CorfuComponent;\n+import org.corfudb.util.MetricsUtils;\n+\n+import static org.corfudb.protocols.CorfuProtocolServerErrors.getUnknownErrorMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+\n+@Slf4j\n+public class RequestHandlerMethods {\n+\n+    private final Map<RequestPayloadMsg.PayloadCase, String> timerNameCache = new HashMap<>();\n+\n+    /** The handler map. */\n+    private final Map<RequestPayloadMsg.PayloadCase, HandlerMethod> handlerMap;\n+\n+    /**\n+     * A functional interface for server request handlers. Server request handlers should\n+     * be fast and not block. If a handler blocks for an extended period of time, it will\n+     * exhaust the server's thread pool. I/O and other long operations should be handled\n+     * on another thread.\n+     */\n+    @FunctionalInterface\n+    public interface HandlerMethod {\n+        void handle(@Nonnull RequestMsg req,\n+                    @Nonnull ChannelHandlerContext ctx,\n+                    @Nonnull IServerRouter r);\n+    }\n+\n+    /** Get the types of requests this handler will handle.\n+     *\n+     * @return  A set containing the types of requests this handler will handle.\n+     */\n+    public Set<RequestPayloadMsg.PayloadCase> getHandledTypes() {\n+        return handlerMap.keySet();\n+    }\n+\n+    /** Construct a new instance of RequestHandlerMethods. */\n+    public RequestHandlerMethods() {\n+        handlerMap = new EnumMap<>(RequestPayloadMsg.PayloadCase.class);\n+    }\n+\n+    /** Handle an incoming Corfu request message.\n+     *\n+     * @param req       The request message to handle.\n+     * @param ctx       The channel handler context.\n+     * @param r         The server router.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void handle(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HandlerMethod handler = handlerMap.get(req.getPayload().getPayloadCase());\n+        try {\n+            handler.handle(req, ctx, r);\n+        } catch(Exception e) {\n+            log.error(\"handle[{}]: Unhandled exception processing {} request\",\n+                    req.getHeader().getRequestId(), req.getPayload().getPayloadCase(), e);\n+\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            r.sendResponse(getResponseMsg(responseHeader, getUnknownErrorMsg(e)), ctx);\n+        }\n+    }\n+\n+    /** Generate handlers for a particular server.\n+     *\n+     * @param caller    The context that is being used. Call MethodHandles.lookup() to obtain.\n+     * @param server    The object that implements the server.\n+     * @return          New request handlers for caller class.\n+     */\n+    public static RequestHandlerMethods generateHandler(@Nonnull final MethodHandles.Lookup caller,\n+                                                        @NonNull final AbstractServer server) {\n+        RequestHandlerMethods handler = new RequestHandlerMethods();\n+        Arrays.stream(server.getClass().getDeclaredMethods())\n+                .filter(method -> method.isAnnotationPresent(RequestHandler.class))\n+                .forEach(method -> handler.registerMethod(caller, server, method));\n+        return handler;\n+    }\n+\n+    private void registerMethod(@Nonnull final MethodHandles.Lookup caller,", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM3MDM4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526370382", "bodyText": "Added a few inline comments below summarizing what is captured.", "author": "zfrenette", "createdAt": "2020-11-18T19:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzg0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517737841", "bodyText": "Wonder if we can embed the error message into the error itself?\nIt's generally preferable to not log and then throw an exception.", "author": "hisundar", "createdAt": "2020-11-05T02:00:35Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/RequestHandlerMethods.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.corfudb.infrastructure;\n+\n+import com.codahale.metrics.Timer;\n+import io.netty.channel.ChannelHandlerContext;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuError;\n+import org.corfudb.util.CorfuComponent;\n+import org.corfudb.util.MetricsUtils;\n+\n+import static org.corfudb.protocols.CorfuProtocolServerErrors.getUnknownErrorMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+\n+@Slf4j\n+public class RequestHandlerMethods {\n+\n+    private final Map<RequestPayloadMsg.PayloadCase, String> timerNameCache = new HashMap<>();\n+\n+    /** The handler map. */\n+    private final Map<RequestPayloadMsg.PayloadCase, HandlerMethod> handlerMap;\n+\n+    /**\n+     * A functional interface for server request handlers. Server request handlers should\n+     * be fast and not block. If a handler blocks for an extended period of time, it will\n+     * exhaust the server's thread pool. I/O and other long operations should be handled\n+     * on another thread.\n+     */\n+    @FunctionalInterface\n+    public interface HandlerMethod {\n+        void handle(@Nonnull RequestMsg req,\n+                    @Nonnull ChannelHandlerContext ctx,\n+                    @Nonnull IServerRouter r);\n+    }\n+\n+    /** Get the types of requests this handler will handle.\n+     *\n+     * @return  A set containing the types of requests this handler will handle.\n+     */\n+    public Set<RequestPayloadMsg.PayloadCase> getHandledTypes() {\n+        return handlerMap.keySet();\n+    }\n+\n+    /** Construct a new instance of RequestHandlerMethods. */\n+    public RequestHandlerMethods() {\n+        handlerMap = new EnumMap<>(RequestPayloadMsg.PayloadCase.class);\n+    }\n+\n+    /** Handle an incoming Corfu request message.\n+     *\n+     * @param req       The request message to handle.\n+     * @param ctx       The channel handler context.\n+     * @param r         The server router.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void handle(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HandlerMethod handler = handlerMap.get(req.getPayload().getPayloadCase());\n+        try {\n+            handler.handle(req, ctx, r);\n+        } catch(Exception e) {\n+            log.error(\"handle[{}]: Unhandled exception processing {} request\",\n+                    req.getHeader().getRequestId(), req.getPayload().getPayloadCase(), e);\n+\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            r.sendResponse(getResponseMsg(responseHeader, getUnknownErrorMsg(e)), ctx);\n+        }\n+    }\n+\n+    /** Generate handlers for a particular server.\n+     *\n+     * @param caller    The context that is being used. Call MethodHandles.lookup() to obtain.\n+     * @param server    The object that implements the server.\n+     * @return          New request handlers for caller class.\n+     */\n+    public static RequestHandlerMethods generateHandler(@Nonnull final MethodHandles.Lookup caller,\n+                                                        @NonNull final AbstractServer server) {\n+        RequestHandlerMethods handler = new RequestHandlerMethods();\n+        Arrays.stream(server.getClass().getDeclaredMethods())\n+                .filter(method -> method.isAnnotationPresent(RequestHandler.class))\n+                .forEach(method -> handler.registerMethod(caller, server, method));\n+        return handler;\n+    }\n+\n+    private void registerMethod(@Nonnull final MethodHandles.Lookup caller,\n+                                @Nonnull final AbstractServer server,\n+                                @Nonnull final Method method) {\n+        final RequestHandler annotation = method.getAnnotation(RequestHandler.class);\n+\n+        if(handlerMap.containsKey(annotation.type())) {\n+            throw new UnrecoverableCorfuError(\"HandlerMethod for \" + annotation.type() + \" already registered!\");\n+        }\n+\n+        try {\n+            HandlerMethod h;\n+            if (Modifier.isStatic(method.getModifiers())) {\n+                MethodHandle mh = caller.unreflect(method);\n+                h = (HandlerMethod) LambdaMetafactory.metafactory(caller,\n+                        \"handle\", MethodType.methodType(HandlerMethod.class),\n+                        mh.type(), mh, mh.type()).getTarget().invokeExact();\n+            } else {\n+                // Instance method, so we need to capture the type.\n+                MethodType mt = MethodType.methodType(method.getReturnType(), method.getParameterTypes());\n+                MethodHandle mh = caller.findVirtual(server.getClass(), method.getName(), mt);\n+                MethodType mtt = mh.type().dropParameterTypes(0, 1);\n+                h = (HandlerMethod) LambdaMetafactory.metafactory(caller, \"handle\",\n+                        MethodType.methodType(HandlerMethod.class, server.getClass()),\n+                        mtt, mh, mtt).getTarget().bindTo(server).invoke();\n+            }\n+\n+            // Install pre-conditions on handler and place the handler in the map\n+            final HandlerMethod handler = generateConditionalHandler(annotation.type(), h);\n+            handlerMap.put(annotation.type(), handler);\n+        } catch(Throwable e) {\n+            log.error(\"registerMethod: Exception during request handler registration\", e);\n+            throw new UnrecoverableCorfuError(e);", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyODg1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519028852", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T22:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczODQ3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517738473", "bodyText": "missing java doc for @return ?", "author": "hisundar", "createdAt": "2020-11-05T02:02:49Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolServerErrors.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import java.io.ObjectOutputStream;\n+\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.BootstrappedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.DataCorruptionErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.DataOutrankedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.NotBootstrappedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.NotReadyErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.OverwriteErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.TrimmedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.UnknownErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.WrongClusterErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.WrongEpochErrorMsg;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in server_errors.proto and are used by several of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolServerErrors {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolServerErrors() {}\n+\n+    /**\n+     * Returns the Protobuf representation of a WRONG_EPOCH error.\n+     *\n+     * @param correctEpoch   The correct epoch.\n+     */\n+    public static ServerErrorMsg getWrongEpochErrorMsg(long correctEpoch) {\n+        return ServerErrorMsg.newBuilder()\n+                .setWrongEpochError(WrongEpochErrorMsg.newBuilder()\n+                        .setCorrectEpoch(correctEpoch)\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a NOT_READY error.\n+     */\n+    public static ServerErrorMsg getNotReadyErrorMsg() {\n+        return ServerErrorMsg.newBuilder()\n+                .setNotReadyError(NotReadyErrorMsg.getDefaultInstance())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a WRONG_CLUSTER_ID error.\n+     * @param expectedClusterId   The cluster ID of the server.\n+     * @param providedClusterId   The ID of the cluster provided by the client.\n+     */\n+    public static ServerErrorMsg getWrongClusterErrorMsg(UuidMsg expectedClusterId, UuidMsg providedClusterId) {\n+        return ServerErrorMsg.newBuilder()\n+                .setWrongClusterError(WrongClusterErrorMsg.newBuilder()\n+                        .setExpectedClusterId(expectedClusterId)\n+                        .setProvidedClusterId(providedClusterId)\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a TRIMMED error.\n+     */\n+    public static ServerErrorMsg getTrimmedErrorMsg() {\n+        return ServerErrorMsg.newBuilder()\n+                .setTrimmedError(TrimmedErrorMsg.getDefaultInstance())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a OVERWRITE error.\n+     * @param causeId   The ID of the OverwriteCause in OverwriteException.", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NDYxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519054614", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T23:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczODQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczODU0Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517738543", "bodyText": "missing java doc for @return ?", "author": "hisundar", "createdAt": "2020-11-05T02:03:10Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolServerErrors.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import java.io.ObjectOutputStream;\n+\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.BootstrappedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.DataCorruptionErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.DataOutrankedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.NotBootstrappedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.NotReadyErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.OverwriteErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.TrimmedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.UnknownErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.WrongClusterErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.WrongEpochErrorMsg;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in server_errors.proto and are used by several of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolServerErrors {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolServerErrors() {}\n+\n+    /**\n+     * Returns the Protobuf representation of a WRONG_EPOCH error.\n+     *\n+     * @param correctEpoch   The correct epoch.\n+     */\n+    public static ServerErrorMsg getWrongEpochErrorMsg(long correctEpoch) {\n+        return ServerErrorMsg.newBuilder()\n+                .setWrongEpochError(WrongEpochErrorMsg.newBuilder()\n+                        .setCorrectEpoch(correctEpoch)\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a NOT_READY error.\n+     */\n+    public static ServerErrorMsg getNotReadyErrorMsg() {\n+        return ServerErrorMsg.newBuilder()\n+                .setNotReadyError(NotReadyErrorMsg.getDefaultInstance())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a WRONG_CLUSTER_ID error.\n+     * @param expectedClusterId   The cluster ID of the server.\n+     * @param providedClusterId   The ID of the cluster provided by the client.\n+     */\n+    public static ServerErrorMsg getWrongClusterErrorMsg(UuidMsg expectedClusterId, UuidMsg providedClusterId) {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NDQxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519054417", "bodyText": "Added these for CorfuProtocolServerErrors, and also the APIs from the previous PR.", "author": "zfrenette", "createdAt": "2020-11-06T23:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczODU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczODY1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517738657", "bodyText": "java doc?", "author": "hisundar", "createdAt": "2020-11-05T02:03:38Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolServerErrors.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import java.io.ObjectOutputStream;\n+\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.BootstrappedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.DataCorruptionErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.DataOutrankedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.NotBootstrappedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.NotReadyErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.OverwriteErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.TrimmedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.UnknownErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.WrongClusterErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.WrongEpochErrorMsg;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in server_errors.proto and are used by several of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolServerErrors {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolServerErrors() {}\n+\n+    /**\n+     * Returns the Protobuf representation of a WRONG_EPOCH error.\n+     *\n+     * @param correctEpoch   The correct epoch.\n+     */\n+    public static ServerErrorMsg getWrongEpochErrorMsg(long correctEpoch) {\n+        return ServerErrorMsg.newBuilder()\n+                .setWrongEpochError(WrongEpochErrorMsg.newBuilder()\n+                        .setCorrectEpoch(correctEpoch)\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a NOT_READY error.\n+     */\n+    public static ServerErrorMsg getNotReadyErrorMsg() {\n+        return ServerErrorMsg.newBuilder()\n+                .setNotReadyError(NotReadyErrorMsg.getDefaultInstance())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a WRONG_CLUSTER_ID error.\n+     * @param expectedClusterId   The cluster ID of the server.\n+     * @param providedClusterId   The ID of the cluster provided by the client.\n+     */\n+    public static ServerErrorMsg getWrongClusterErrorMsg(UuidMsg expectedClusterId, UuidMsg providedClusterId) {\n+        return ServerErrorMsg.newBuilder()\n+                .setWrongClusterError(WrongClusterErrorMsg.newBuilder()\n+                        .setExpectedClusterId(expectedClusterId)\n+                        .setProvidedClusterId(providedClusterId)\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a TRIMMED error.\n+     */\n+    public static ServerErrorMsg getTrimmedErrorMsg() {\n+        return ServerErrorMsg.newBuilder()\n+                .setTrimmedError(TrimmedErrorMsg.getDefaultInstance())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a OVERWRITE error.\n+     * @param causeId   The ID of the OverwriteCause in OverwriteException.\n+     */\n+    public static ServerErrorMsg getOverwriteErrorMsg(int causeId) {\n+        return ServerErrorMsg.newBuilder()\n+                .setOverwriteError(OverwriteErrorMsg.newBuilder()\n+                        .setOverwriteCauseId(causeId)\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a DATA_OUTRANKED error.\n+     */\n+    public static ServerErrorMsg getDataOutrankedErrorMsg() {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NDQ4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519054488", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T23:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczODY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczODg5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517738893", "bodyText": "please consider adding the java doc like @return for these public methods.", "author": "hisundar", "createdAt": "2020-11-05T02:04:28Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolServerErrors.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import java.io.ObjectOutputStream;\n+\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.BootstrappedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.DataCorruptionErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.DataOutrankedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.NotBootstrappedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.NotReadyErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.OverwriteErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.TrimmedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.UnknownErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.WrongClusterErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.WrongEpochErrorMsg;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in server_errors.proto and are used by several of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolServerErrors {", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NDU2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519054560", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T23:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczODg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczOTY3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517739671", "bodyText": "the last parameter of log.error can just be the throwable. This usage is more for log.warn()", "author": "hisundar", "createdAt": "2020-11-05T02:07:15Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolServerErrors.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import java.io.ObjectOutputStream;\n+\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.BootstrappedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.DataCorruptionErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.DataOutrankedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.NotBootstrappedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.NotReadyErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.OverwriteErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.TrimmedErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.UnknownErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.WrongClusterErrorMsg;\n+import org.corfudb.runtime.proto.ServerErrors.WrongEpochErrorMsg;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in server_errors.proto and are used by several of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolServerErrors {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolServerErrors() {}\n+\n+    /**\n+     * Returns the Protobuf representation of a WRONG_EPOCH error.\n+     *\n+     * @param correctEpoch   The correct epoch.\n+     */\n+    public static ServerErrorMsg getWrongEpochErrorMsg(long correctEpoch) {\n+        return ServerErrorMsg.newBuilder()\n+                .setWrongEpochError(WrongEpochErrorMsg.newBuilder()\n+                        .setCorrectEpoch(correctEpoch)\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a NOT_READY error.\n+     */\n+    public static ServerErrorMsg getNotReadyErrorMsg() {\n+        return ServerErrorMsg.newBuilder()\n+                .setNotReadyError(NotReadyErrorMsg.getDefaultInstance())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a WRONG_CLUSTER_ID error.\n+     * @param expectedClusterId   The cluster ID of the server.\n+     * @param providedClusterId   The ID of the cluster provided by the client.\n+     */\n+    public static ServerErrorMsg getWrongClusterErrorMsg(UuidMsg expectedClusterId, UuidMsg providedClusterId) {\n+        return ServerErrorMsg.newBuilder()\n+                .setWrongClusterError(WrongClusterErrorMsg.newBuilder()\n+                        .setExpectedClusterId(expectedClusterId)\n+                        .setProvidedClusterId(providedClusterId)\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a TRIMMED error.\n+     */\n+    public static ServerErrorMsg getTrimmedErrorMsg() {\n+        return ServerErrorMsg.newBuilder()\n+                .setTrimmedError(TrimmedErrorMsg.getDefaultInstance())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a OVERWRITE error.\n+     * @param causeId   The ID of the OverwriteCause in OverwriteException.\n+     */\n+    public static ServerErrorMsg getOverwriteErrorMsg(int causeId) {\n+        return ServerErrorMsg.newBuilder()\n+                .setOverwriteError(OverwriteErrorMsg.newBuilder()\n+                        .setOverwriteCauseId(causeId)\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a DATA_OUTRANKED error.\n+     */\n+    public static ServerErrorMsg getDataOutrankedErrorMsg() {\n+        return ServerErrorMsg.newBuilder()\n+                .setDataOutrankedError(DataOutrankedErrorMsg.getDefaultInstance())\n+                .build();\n+    }\n+\n+    // Method below will be added in later PR with other LogUnit updates\n+    // public static ServerErrorMsg getValueAdoptedErrorMsg(ReadResponse rr)\n+\n+    /**\n+     * Returns the Protobuf representation of a DATA_CORRUPTION error.\n+     * @param address   The address that caused the error.\n+     */\n+    public static ServerErrorMsg getDataCorruptionErrorMsg(long address) {\n+        return ServerErrorMsg.newBuilder()\n+                .setDataCorruptionError(DataCorruptionErrorMsg.newBuilder()\n+                        .setAddress(address)\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a BOOTSTRAPPED error.\n+     */\n+    public static ServerErrorMsg getBootstrappedErrorMsg() {\n+        return ServerErrorMsg.newBuilder()\n+                .setBootstrappedError(BootstrappedErrorMsg.getDefaultInstance())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a NOT_BOOTSTRAPPED error.\n+     */\n+    public static ServerErrorMsg getNotBootstrappedErrorMsg() {\n+        return ServerErrorMsg.newBuilder()\n+                .setNotBootstrappedError(NotBootstrappedErrorMsg.getDefaultInstance())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SERVER_EXCEPTION error.\n+     * This is used for errors that do not fit with the above types.\n+     * @param throwable   The underlying throwable cause.\n+     */\n+    public static ServerErrorMsg getUnknownErrorMsg(Throwable throwable) {\n+        UnknownErrorMsg.Builder unknownErrorBuilder = UnknownErrorMsg.newBuilder();\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (ObjectOutputStream oos = new ObjectOutputStream(bso)) {\n+                oos.writeObject(throwable);\n+                unknownErrorBuilder.setThrowable(bso.toByteString());\n+            }\n+        } catch (Exception ex) {\n+            //TODO(Zach): Any other handling? Wrap around SerializationFailedException?\n+            log.error(\"getUnknownErrorMsg: error=[{}, {}] \" +\n+                    \"while serializing throwable={}\", ex, ex.getCause(), throwable);", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM3MDQ4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526370481", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-18T19:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczOTY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczOTkxNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517739916", "bodyText": "won't this throw a parser exception if the json is malformed?", "author": "hisundar", "createdAt": "2020-11-05T02:08:16Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java", "diffHunk": "@@ -134,6 +134,15 @@ public static ResponsePayloadMsg getVersionResponseMsg(VersionInfo vi) {\n                 .build();\n     }\n \n+    /**\n+     * Returns a Java VersionInfo object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf VERSION response message\n+     */\n+    public static VersionInfo getVersionInfo(VersionResponseMsg msg) {\n+        final Gson parser = new GsonBuilder().create();\n+        return parser.fromJson(msg.getJsonPayloadMsg(), VersionInfo.class);", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NDIzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519054232", "bodyText": "Done. Added a try-catch block.", "author": "zfrenette", "createdAt": "2020-11-06T23:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczOTkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc0MTI3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517741271", "bodyText": "Is it ok to throw.. the method appears to want to return an Object right?", "author": "hisundar", "createdAt": "2020-11-05T02:12:50Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/BaseHandler.java", "diffHunk": "@@ -159,4 +186,182 @@ private static Object handleWrongClusterId(CorfuPayloadMsg<WrongClusterMsg> msg,\n         throw new WrongClusterException(wrongClusterMessage.getServerClusterId(),\n                 wrongClusterMessage.getClientClusterId());\n     }\n+\n+    // Protobuf region\n+\n+    /**\n+     * Handle a ping response from the server.\n+     * For old CorfuMsg, use {@link #handlePong(CorfuMsg, ChannelHandlerContext, IClientRouter)}\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return Always True, since the ping message was successful.\n+     */\n+    @ResponseHandler(type = PayloadCase.PING_RESPONSE)\n+    private static Object handlePingResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                             IClientRouter r) {\n+        log.info(\"Received PING_RESPONSE from the server - {}\", msg);\n+        return true;\n+    }\n+\n+    /**\n+     * Handle a restart response from the server.\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return Always True, since the restart message was successful.\n+     */\n+    @ResponseHandler(type = PayloadCase.RESTART_RESPONSE)\n+    private static Object handleRestartResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                IClientRouter r) {\n+        return true;\n+    }\n+\n+    /**\n+     * Handle a reset response from the server.\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return Always True, since the reset message was successful.\n+     */\n+    @ResponseHandler(type = PayloadCase.RESET_RESPONSE)\n+    private static Object handleResetResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                              IClientRouter r) {\n+        log.info(\"Received RESET_RESPONSE from the server - {}\", msg);\n+        return true;\n+    }\n+\n+    /**\n+     * Handle a seal response from the server.\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return Always True, since the seal message was successful.\n+     */\n+    @ResponseHandler(type = PayloadCase.SEAL_RESPONSE)\n+    private static Object handleSealResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                             IClientRouter r) {\n+        return true;\n+    }\n+\n+    /**\n+     * Handle a version response from the server.\n+     * For old CorfuMsg, use {@link #handleVersionResponse(JSONPayloadMsg, ChannelHandlerContext, IClientRouter)}\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return The VersionInfo object fetched from response msg.\n+     */\n+    @ResponseHandler(type = PayloadCase.VERSION_RESPONSE)\n+    private static Object handleVersionResponse(ResponseMsg msg, ChannelHandlerContext ctx, IClientRouter r) {\n+        VersionResponseMsg versionResponseMsg = msg.getPayload().getVersionResponse();\n+        return CorfuProtocolBase.getVersionInfo(versionResponseMsg);\n+    }\n+\n+    /**\n+     * Handle a UNKNOWN_ERROR response from the server.\n+     * For old CorfuMsg, use {@link #handleServerException(CorfuPayloadMsg, ChannelHandlerContext, IClientRouter)}\n+     *\n+     * @param msg The wrong epoch message\n+     * @param ctx The context the message was sent under\n+     * @param r   A reference to the router\n+     * @return none, throw a wrong epoch exception instead.\n+     */\n+    @ServerErrorsHandler(type = ErrorCase.UNKNOWN_ERROR)\n+    private static Object handleUnknownError(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                             IClientRouter r) throws Throwable {\n+        ByteString bs = msg.getPayload().getServerError().getUnknownError().getThrowable();\n+        byte[] bytes = new byte[bs.size()];\n+        bs.copyTo(bytes, 0);\n+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes)) {\n+            try (ObjectInputStream ois = new ObjectInputStream(bis)) {\n+                throw (Throwable) ois.readObject();", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg0ODIwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518848207", "bodyText": "Yeah, I think the signature is to align with the FunctionalInterface defined in ClientResponseHandler, but all the handlers for ServerErrors will throw an exception and we always want the router to invoke completeExceptionally() under these cases.", "author": "xcchang", "createdAt": "2020-11-06T16:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc0MTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc0MjAzNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517742034", "bodyText": "can we add the exception to the java doc please?", "author": "hisundar", "createdAt": "2020-11-05T02:13:55Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/BaseHandler.java", "diffHunk": "@@ -159,4 +186,182 @@ private static Object handleWrongClusterId(CorfuPayloadMsg<WrongClusterMsg> msg,\n         throw new WrongClusterException(wrongClusterMessage.getServerClusterId(),\n                 wrongClusterMessage.getClientClusterId());\n     }\n+\n+    // Protobuf region\n+\n+    /**\n+     * Handle a ping response from the server.\n+     * For old CorfuMsg, use {@link #handlePong(CorfuMsg, ChannelHandlerContext, IClientRouter)}\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return Always True, since the ping message was successful.\n+     */\n+    @ResponseHandler(type = PayloadCase.PING_RESPONSE)\n+    private static Object handlePingResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                             IClientRouter r) {\n+        log.info(\"Received PING_RESPONSE from the server - {}\", msg);\n+        return true;\n+    }\n+\n+    /**\n+     * Handle a restart response from the server.\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return Always True, since the restart message was successful.\n+     */\n+    @ResponseHandler(type = PayloadCase.RESTART_RESPONSE)\n+    private static Object handleRestartResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                IClientRouter r) {\n+        return true;\n+    }\n+\n+    /**\n+     * Handle a reset response from the server.\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return Always True, since the reset message was successful.\n+     */\n+    @ResponseHandler(type = PayloadCase.RESET_RESPONSE)\n+    private static Object handleResetResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                              IClientRouter r) {\n+        log.info(\"Received RESET_RESPONSE from the server - {}\", msg);\n+        return true;\n+    }\n+\n+    /**\n+     * Handle a seal response from the server.\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return Always True, since the seal message was successful.\n+     */\n+    @ResponseHandler(type = PayloadCase.SEAL_RESPONSE)\n+    private static Object handleSealResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                             IClientRouter r) {\n+        return true;\n+    }\n+\n+    /**\n+     * Handle a version response from the server.\n+     * For old CorfuMsg, use {@link #handleVersionResponse(JSONPayloadMsg, ChannelHandlerContext, IClientRouter)}\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return The VersionInfo object fetched from response msg.\n+     */\n+    @ResponseHandler(type = PayloadCase.VERSION_RESPONSE)\n+    private static Object handleVersionResponse(ResponseMsg msg, ChannelHandlerContext ctx, IClientRouter r) {\n+        VersionResponseMsg versionResponseMsg = msg.getPayload().getVersionResponse();\n+        return CorfuProtocolBase.getVersionInfo(versionResponseMsg);\n+    }\n+\n+    /**\n+     * Handle a UNKNOWN_ERROR response from the server.\n+     * For old CorfuMsg, use {@link #handleServerException(CorfuPayloadMsg, ChannelHandlerContext, IClientRouter)}\n+     *\n+     * @param msg The wrong epoch message\n+     * @param ctx The context the message was sent under\n+     * @param r   A reference to the router\n+     * @return none, throw a wrong epoch exception instead.\n+     */\n+    @ServerErrorsHandler(type = ErrorCase.UNKNOWN_ERROR)\n+    private static Object handleUnknownError(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                             IClientRouter r) throws Throwable {\n+        ByteString bs = msg.getPayload().getServerError().getUnknownError().getThrowable();\n+        byte[] bytes = new byte[bs.size()];\n+        bs.copyTo(bytes, 0);\n+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes)) {\n+            try (ObjectInputStream ois = new ObjectInputStream(bis)) {\n+                throw (Throwable) ois.readObject();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a WRONG_EPOCH_ERROR response from the server.\n+     * For old CorfuMsg, use {@link #handleWrongEpoch(CorfuPayloadMsg, ChannelHandlerContext, IClientRouter)}\n+     *\n+     * @param msg The wrong epoch message\n+     * @param ctx The context the message was sent under\n+     * @param r   A reference to the router\n+     * @return none, throw a wrong epoch exception instead.", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc0NTg3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517745873", "bodyText": "missing java doc?", "author": "hisundar", "createdAt": "2020-11-05T02:18:53Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/ClientResponseHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg.PayloadCase;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg.ErrorCase;\n+\n+/**\n+ * Invokes the message handler to handle Protobuf responses from server.\n+ */\n+@Slf4j\n+public class ClientResponseHandler {\n+\n+    @FunctionalInterface\n+    public interface Handler {\n+        Object handle(ResponseMsg msg, ChannelHandlerContext ctx, IClientRouter r) throws Exception;\n+    }\n+\n+    /**\n+     * The handler map for normal ResponseMsg.\n+     */\n+    private final Map<PayloadCase, Handler> handlerMap;\n+\n+    /**\n+     * The handler map for ServerErrorMsg.\n+     */\n+    private final Map<ErrorCase, Handler> errorHandlerMap;\n+\n+    /**\n+     * The client.\n+     */\n+    private final IClient client;\n+\n+    /**\n+     * Construct a new instance of ClientResponseHandler.\n+     *\n+     * @param client The client that this ClientResponseHandler will register.\n+     */\n+    public ClientResponseHandler(IClient client) {\n+        this.client = client;\n+        this.handlerMap = new ConcurrentHashMap<>();\n+        this.errorHandlerMap = new ConcurrentHashMap<>();\n+    }\n+\n+    /**\n+     * Add a handler to this ClientResponseHandler.\n+     *\n+     * @param payloadCase Response payload type.\n+     * @param handler The handler itself.\n+     * @return This handler, to support chaining.\n+     */\n+    @Deprecated\n+    public ClientResponseHandler addHandler(PayloadCase payloadCase, ClientResponseHandler.Handler handler) {\n+        if (!payloadCase.equals(PayloadCase.SERVER_ERROR)) {\n+            handlerMap.put(payloadCase, handler);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Handle an incoming Response from server.\n+     *\n+     * @param response The Response to handle.\n+     * @param ctx The channel handler context.\n+     * @return True if the message was handled successfully.\n+     */\n+    public boolean handle(ResponseMsg response, ChannelHandlerContext ctx) {\n+        IClientRouter router = client.getRouter();\n+        long requestId = response.getHeader().getRequestId();\n+        PayloadCase payloadCase = response.getPayload().getPayloadCase();\n+\n+        if (payloadCase.equals(PayloadCase.SERVER_ERROR)) {\n+            ErrorCase errorCase = response.getPayload().getServerError().getErrorCase();\n+            if (errorHandlerMap.containsKey(errorCase)) {\n+                try{\n+                    // For errors, we always want to completeExceptionally\n+                    errorHandlerMap.get(errorCase).handle(response, ctx, router);\n+                } catch (Throwable e) {\n+                    router.completeExceptionally(requestId, e);\n+                }\n+            }\n+        } else if (handlerMap.containsKey(payloadCase)) {\n+            try {\n+                Object ret = handlerMap.get(payloadCase).handle(response, ctx, router);\n+                if (ret != null) {\n+                    router.completeRequest(requestId, ret);\n+                }\n+            } catch (Throwable e) {\n+                router.completeExceptionally(requestId, e);\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public ClientResponseHandler generateHandlers(@NonNull final MethodHandles.Lookup caller,", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc0NjAyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r517746023", "bodyText": "missing java doc?", "author": "hisundar", "createdAt": "2020-11-05T02:19:04Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/ClientResponseHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg.PayloadCase;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg.ErrorCase;\n+\n+/**\n+ * Invokes the message handler to handle Protobuf responses from server.\n+ */\n+@Slf4j\n+public class ClientResponseHandler {\n+\n+    @FunctionalInterface\n+    public interface Handler {\n+        Object handle(ResponseMsg msg, ChannelHandlerContext ctx, IClientRouter r) throws Exception;\n+    }\n+\n+    /**\n+     * The handler map for normal ResponseMsg.\n+     */\n+    private final Map<PayloadCase, Handler> handlerMap;\n+\n+    /**\n+     * The handler map for ServerErrorMsg.\n+     */\n+    private final Map<ErrorCase, Handler> errorHandlerMap;\n+\n+    /**\n+     * The client.\n+     */\n+    private final IClient client;\n+\n+    /**\n+     * Construct a new instance of ClientResponseHandler.\n+     *\n+     * @param client The client that this ClientResponseHandler will register.\n+     */\n+    public ClientResponseHandler(IClient client) {\n+        this.client = client;\n+        this.handlerMap = new ConcurrentHashMap<>();\n+        this.errorHandlerMap = new ConcurrentHashMap<>();\n+    }\n+\n+    /**\n+     * Add a handler to this ClientResponseHandler.\n+     *\n+     * @param payloadCase Response payload type.\n+     * @param handler The handler itself.\n+     * @return This handler, to support chaining.\n+     */\n+    @Deprecated\n+    public ClientResponseHandler addHandler(PayloadCase payloadCase, ClientResponseHandler.Handler handler) {\n+        if (!payloadCase.equals(PayloadCase.SERVER_ERROR)) {\n+            handlerMap.put(payloadCase, handler);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Handle an incoming Response from server.\n+     *\n+     * @param response The Response to handle.\n+     * @param ctx The channel handler context.\n+     * @return True if the message was handled successfully.\n+     */\n+    public boolean handle(ResponseMsg response, ChannelHandlerContext ctx) {\n+        IClientRouter router = client.getRouter();\n+        long requestId = response.getHeader().getRequestId();\n+        PayloadCase payloadCase = response.getPayload().getPayloadCase();\n+\n+        if (payloadCase.equals(PayloadCase.SERVER_ERROR)) {\n+            ErrorCase errorCase = response.getPayload().getServerError().getErrorCase();\n+            if (errorHandlerMap.containsKey(errorCase)) {\n+                try{\n+                    // For errors, we always want to completeExceptionally\n+                    errorHandlerMap.get(errorCase).handle(response, ctx, router);\n+                } catch (Throwable e) {\n+                    router.completeExceptionally(requestId, e);\n+                }\n+            }\n+        } else if (handlerMap.containsKey(payloadCase)) {\n+            try {\n+                Object ret = handlerMap.get(payloadCase).handle(response, ctx, router);\n+                if (ret != null) {\n+                    router.completeRequest(requestId, ret);\n+                }\n+            } catch (Throwable e) {\n+                router.completeExceptionally(requestId, e);\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public ClientResponseHandler generateHandlers(@NonNull final MethodHandles.Lookup caller,\n+                                                  @NonNull final Object o) {\n+        Arrays.stream(o.getClass().getDeclaredMethods())\n+                .filter(method -> method.isAnnotationPresent(ResponseHandler.class))\n+                .forEach(method -> {\n+                    ResponseHandler handler = method.getAnnotation(ResponseHandler.class);\n+                    if (!method.getParameterTypes()[0]\n+                            .isAssignableFrom(ResponseMsg.class)) {\n+                        throw new RuntimeException(\"Incorrect message type, expected \"\n+                                + ResponseMsg.class + \" but provided \"\n+                                + method.getParameterTypes()[0]);\n+                    }\n+                    if (handlerMap.containsKey(handler.type())) {\n+                        throw new RuntimeException(\"Handler for \" + handler.type()\n+                                + \" already registered!\");\n+                    }\n+                    // convert the method into a Java8 Lambda for maximum execution speed...\n+                    try {\n+                        if (Modifier.isStatic(method.getModifiers())) {\n+                            MethodHandle mh = caller.unreflect(method);\n+                            handlerMap.put(handler.type(), (Handler) LambdaMetafactory\n+                                    .metafactory(caller, \"handle\",\n+                                            MethodType.methodType(Handler.class),\n+                                            mh.type(), mh, mh.type())\n+                                    .getTarget().invokeExact());\n+                        } else {\n+                            // instance method, so we need to capture the type.\n+                            MethodType mt = MethodType\n+                                    .methodType(method.getReturnType(), method.getParameterTypes());\n+                            MethodHandle mh = caller.findVirtual(o.getClass(), method.getName(), mt);\n+                            MethodType mtGeneric = mh.type()\n+                                    .changeReturnType(Object.class);\n+                            handlerMap.put(handler.type(), (Handler) LambdaMetafactory\n+                                    .metafactory(caller, \"handle\",\n+                                            MethodType.methodType(Handler.class,\n+                                                    o.getClass()),\n+                                            mtGeneric.dropParameterTypes(0, 1), mh, mh.type()\n+                                                    .dropParameterTypes(0, 1))\n+                                    .getTarget().bindTo(o).invoke());\n+                        }\n+                    } catch (Throwable e) {\n+                        log.error(\"Exception during incoming message handling\", e);\n+                        throw new RuntimeException(e);\n+                    }\n+                });\n+\n+        return this;\n+    }\n+\n+    public ClientResponseHandler generateErrorHandlers(@NonNull final MethodHandles.Lookup caller,", "originalCommit": "6dc8fab46d2b37ed108ee66779fbfa6788aaac7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "683c4e33c91fc50edbdff9cbf57ac80b44a5b5e3", "url": "https://github.com/CorfuDB/CorfuDB/commit/683c4e33c91fc50edbdff9cbf57ac80b44a5b5e3", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-05T02:50:28Z", "type": "forcePushed"}, {"oid": "11ad1c0c3fb12e1bdc687b12ba63579d1713ac45", "url": "https://github.com/CorfuDB/CorfuDB/commit/11ad1c0c3fb12e1bdc687b12ba63579d1713ac45", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-05T04:49:21Z", "type": "forcePushed"}, {"oid": "1319f3a461251903cc2e8a64291e9f4aff0a8a31", "url": "https://github.com/CorfuDB/CorfuDB/commit/1319f3a461251903cc2e8a64291e9f4aff0a8a31", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-05T19:32:48Z", "type": "forcePushed"}, {"oid": "c36b5f5cf7c45381ca36ed32663f938c7378fc6f", "url": "https://github.com/CorfuDB/CorfuDB/commit/c36b5f5cf7c45381ca36ed32663f938c7378fc6f", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-05T21:33:18Z", "type": "forcePushed"}, {"oid": "a9aff2725c6602a52058dbf0b7abaf3aa6e28193", "url": "https://github.com/CorfuDB/CorfuDB/commit/a9aff2725c6602a52058dbf0b7abaf3aa6e28193", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-05T23:24:52Z", "type": "forcePushed"}, {"oid": "edf277af98f79a8244428b9af5d4524dfd016441", "url": "https://github.com/CorfuDB/CorfuDB/commit/edf277af98f79a8244428b9af5d4524dfd016441", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-06T02:34:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwODUzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518808537", "bodyText": "Expand", "author": "xcchang", "createdAt": "2020-11-06T15:03:45Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/AbstractServer.java", "diffHunk": "@@ -1,11 +1,16 @@\n package org.corfudb.infrastructure;\n \n import io.netty.channel.ChannelHandlerContext;\n+import java.util.concurrent.atomic.AtomicReference;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.protocols.wireprotocol.CorfuMsg;\n import org.corfudb.protocols.wireprotocol.CorfuMsgType;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import static org.corfudb.protocols.CorfuProtocolServerErrors.getNotReadyErrorMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.*;", "originalCommit": "edf277af98f79a8244428b9af5d4524dfd016441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyOTUyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519029525", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T22:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwODUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwODkwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518808907", "bodyText": "Expand", "author": "xcchang", "createdAt": "2020-11-06T15:04:18Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -10,13 +10,20 @@\n import org.corfudb.protocols.wireprotocol.JSONPayloadMsg;\n import org.corfudb.protocols.wireprotocol.VersionInfo;\n import org.corfudb.runtime.exceptions.WrongEpochException;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n import javax.annotation.Nonnull;\n import java.lang.invoke.MethodHandles;\n import java.net.InetSocketAddress;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n \n+import static org.corfudb.protocols.service.CorfuProtocolBase.*;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.*;", "originalCommit": "edf277af98f79a8244428b9af5d4524dfd016441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyOTU1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519029552", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T22:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwODkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxNjE0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518816145", "bodyText": "Expand", "author": "xcchang", "createdAt": "2020-11-06T15:15:15Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -13,6 +17,10 @@\n import java.util.Optional;\n import java.util.UUID;\n \n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.CorfuProtocolServerErrors.*;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.*;", "originalCommit": "edf277af98f79a8244428b9af5d4524dfd016441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyOTU4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519029588", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-06T22:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxNjE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1MDc0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518850748", "bodyText": "Complete java doc", "author": "xcchang", "createdAt": "2020-11-06T16:08:38Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/NettyClientRouter.java", "diffHunk": "@@ -473,6 +530,94 @@ public void stop() {\n         return cfTimeout;\n     }\n \n+    /**\n+     * Send a request message and get a completable future to be fulfilled by the reply.\n+     *\n+     * @param payload         Payload message of the pending request.\n+     * @param epoch           Number of epoch.\n+     * @param clusterId       Cluster id.\n+     * @param priority        Priority level of the pending request\n+     * @param ignoreClusterId Boolean field indicates whether to ignore cluster id.\n+     * @param ignoreEpoch     Boolean field indicates whether to ignore epoch.\n+     * @param <T>             The type of completable to return.\n+     * @return A completable future which will be fulfilled by the reply, or a timeout in the case\n+     * there is no response.\n+     */\n+    @Override\n+    public <T> CompletableFuture<T> sendRequestAndGetCompletable(", "originalCommit": "edf277af98f79a8244428b9af5d4524dfd016441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1MzA2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518853060", "bodyText": "Expand", "author": "xcchang", "createdAt": "2020-11-06T16:12:20Z", "path": "test/src/test/java/org/corfudb/infrastructure/TestServerRouter.java", "diffHunk": "@@ -4,19 +4,19 @@\n import lombok.Getter;\n import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.service.CorfuProtocolMessage;\n import org.corfudb.protocols.wireprotocol.CorfuMsg;\n import org.corfudb.protocols.wireprotocol.CorfuMsgType;\n import org.corfudb.runtime.clients.TestChannelContext;\n import org.corfudb.runtime.clients.TestRule;\n import org.corfudb.runtime.view.Layout;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.util.*;", "originalCommit": "edf277af98f79a8244428b9af5d4524dfd016441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1MzI4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r518853287", "bodyText": "Expand", "author": "xcchang", "createdAt": "2020-11-06T16:12:44Z", "path": "test/src/test/java/org/corfudb/runtime/clients/TestChannelContext.java", "diffHunk": "@@ -2,9 +2,7 @@\n \n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n \n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufAllocator;\n-import io.netty.buffer.Unpooled;\n+import io.netty.buffer.*;", "originalCommit": "edf277af98f79a8244428b9af5d4524dfd016441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aa8ba43baf0a1e19e6ac75f1e452374b09b4dc97", "url": "https://github.com/CorfuDB/CorfuDB/commit/aa8ba43baf0a1e19e6ac75f1e452374b09b4dc97", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.\n\nJava doc", "committedDate": "2020-11-06T21:09:17Z", "type": "forcePushed"}, {"oid": "b28f0991364df0ee1dcbc270c02cab8af13ca769", "url": "https://github.com/CorfuDB/CorfuDB/commit/b28f0991364df0ee1dcbc270c02cab8af13ca769", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-06T21:31:23Z", "type": "forcePushed"}, {"oid": "5f4e1f03e4102b4bde5759b7f32e611431e1dcdd", "url": "https://github.com/CorfuDB/CorfuDB/commit/5f4e1f03e4102b4bde5759b7f32e611431e1dcdd", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-06T21:44:53Z", "type": "forcePushed"}, {"oid": "332c2ff3cd12f6f2cc51c7da04c6c6f90e129c23", "url": "https://github.com/CorfuDB/CorfuDB/commit/332c2ff3cd12f6f2cc51c7da04c6c6f90e129c23", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-06T22:35:40Z", "type": "forcePushed"}, {"oid": "e7c54fc6fd284da699764ad97d46400e2a8fc1a7", "url": "https://github.com/CorfuDB/CorfuDB/commit/e7c54fc6fd284da699764ad97d46400e2a8fc1a7", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-06T23:26:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1OTc3NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519059774", "bodyText": "What's the purpose of this method? Should this be for Protobuf requests?", "author": "zfrenette", "createdAt": "2020-11-06T23:52:30Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/AbstractClient.java", "diffHunk": "@@ -38,4 +38,9 @@ public AbstractClient(IClientRouter router, long epoch, UUID clusterID) {\n         return router.sendMessageAndGetCompletable(\n                 msg.setEpoch(epoch).setClusterID(clusterID).setPriorityLevel(priorityLevel));\n     }\n+\n+    <T> CompletableFuture<T> sendRequestWithFuture(CorfuMsg msg) {\n+        return router.sendMessageAndGetCompletable(\n+                msg.setEpoch(epoch).setClusterID(clusterID).setPriorityLevel(priorityLevel));\n+    }", "originalCommit": "e7c54fc6fd284da699764ad97d46400e2a8fc1a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MTI2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519061269", "bodyText": "We can likely delete this", "author": "zfrenette", "createdAt": "2020-11-06T23:58:39Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/IClient.java", "diffHunk": "@@ -29,32 +31,79 @@ default void setPriorityLevel(PriorityLevel level) {\n         //no-op\n     }\n \n+//    /**\n+//     * For old CorfuMsg, use {@link #setPriorityLevel(PriorityLevel)}\n+//     *\n+//     * @param level Priority Level.\n+//     */\n+//    void setPriorityLevel(Common.PriorityLevel level);\n+", "originalCommit": "e7c54fc6fd284da699764ad97d46400e2a8fc1a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MTg1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r519061858", "bodyText": "Note: these were separated into two since it was awkward to implement a TestRule that was functional for both message formats. They can be recombined once all messages are sent with Protobuf.", "author": "zfrenette", "createdAt": "2020-11-07T00:01:15Z", "path": "test/src/test/java/org/corfudb/runtime/view/ManagementViewTest.java", "diffHunk": "@@ -376,30 +377,42 @@ public void handleTransientFailure() throws Exception {\n         failureDetected.acquire(2);\n \n         log.info(\"Only allow SERVERS.PORT_0 to manage failures. Prevent the other servers from handling failures.\");\n-        TestRule testRule = new TestRule()\n-                .matches(corfuMsg -> corfuMsg.getMsgType().equals(CorfuMsgType.SEAL)\n-                        || corfuMsg.getMsgType().equals(CorfuMsgType.MANAGEMENT_FAILURE_DETECTED))\n+\n+        TestRule sealTestRule = new TestRule()\n+                .requestMatches(msg -> msg.getPayload().getPayloadCase().equals(PayloadCase.SEAL_REQUEST))\n+                .drop();\n+\n+        TestRule failureTestRule = new TestRule()\n+                .matches(msg -> msg.getMsgType().equals(CorfuMsgType.MANAGEMENT_FAILURE_DETECTED))\n                 .drop();", "originalCommit": "e7c54fc6fd284da699764ad97d46400e2a8fc1a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2f4d4e642ad9e1ee98be27d518c6aa8f920628a0", "url": "https://github.com/CorfuDB/CorfuDB/commit/2f4d4e642ad9e1ee98be27d518c6aa8f920628a0", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-07T01:06:02Z", "type": "forcePushed"}, {"oid": "5f58efeca5336be51757f84f0d82c5a9e8d0bb92", "url": "https://github.com/CorfuDB/CorfuDB/commit/5f58efeca5336be51757f84f0d82c5a9e8d0bb92", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-09T18:47:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5ODM5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520098390", "bodyText": "Removed these since they don't appear used.", "author": "zfrenette", "createdAt": "2020-11-09T20:25:36Z", "path": "test/src/test/java/org/corfudb/infrastructure/AbstractServerTest.java", "diffHunk": "@@ -119,7 +132,6 @@ public void resetTest() {\n         requestCounter.set(0);\n     }\n \n-\n     public CorfuMsg getLastMessage() {\n         if (router.getResponseMessages().size() == 0) return null;\n         return router.getResponseMessages().get(router.getResponseMessages().size() - 1);", "originalCommit": "5f58efeca5336be51757f84f0d82c5a9e8d0bb92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4a35dbc03a17e74a4a0ea81d53058b4b45ff8a04", "url": "https://github.com/CorfuDB/CorfuDB/commit/4a35dbc03a17e74a4a0ea81d53058b4b45ff8a04", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-09T20:30:29Z", "type": "forcePushed"}, {"oid": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "url": "https://github.com/CorfuDB/CorfuDB/commit/f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-09T21:24:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MjgyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520962820", "bodyText": "Its better to change this to abstract and add the stubs in the child classes. The child classes stubs can throw UnsupportedOperationException for their implementation.", "author": "Maithem", "createdAt": "2020-11-11T00:35:45Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/AbstractServer.java", "diffHunk": "@@ -23,8 +29,19 @@\n      *\n      * @return A message handler.\n      */\n+    @Deprecated\n     public abstract HandlerMethods getHandler();\n \n+    /**\n+     * Get the request handlers for this instance.\n+     *\n+     * @return The request handler methods.\n+     */\n+    public RequestHandlerMethods getHandlerMethods() {\n+        //TODO: Make abstract once other servers are implemented.\n+        return null;\n+    }", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMjI4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521632286", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-11T20:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MjgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MzY1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520963652", "bodyText": "I think its cleaner to just overload this and not introduce a new \"Req\" suffix naming scheme to differentiated the two paths. I would make this abstract and oberload it with public abstract boolean isServerReadyToHandleMsg(RequestMsg request);", "author": "Maithem", "createdAt": "2020-11-11T00:38:22Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/AbstractServer.java", "diffHunk": "@@ -34,26 +51,51 @@ public void sealServerWithEpoch(long epoch) {\n         // Overridden in log unit to flush operations stamped with an old epoch\n     }\n \n+    @Deprecated\n     public abstract boolean isServerReadyToHandleMsg(CorfuMsg msg);\n \n+    /**\n+     * Determine if the server is ready to handle a request.\n+     * @param request The incoming request message.\n+     * @return True if the server is ready to handle this request, and false otherwise.\n+     */\n+    public boolean isServerReadyToHandleReq(RequestMsg request) {", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMjQxMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521632412", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-11T20:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MzY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2NDYxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520964618", "bodyText": "Change this to abstract. The default implementation is not used anywhere, force concrete classes to handle the invocation (that way they can also manage their own thread dispatching).", "author": "Maithem", "createdAt": "2020-11-11T00:41:12Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/AbstractServer.java", "diffHunk": "@@ -34,26 +51,51 @@ public void sealServerWithEpoch(long epoch) {\n         // Overridden in log unit to flush operations stamped with an old epoch\n     }\n \n+    @Deprecated\n     public abstract boolean isServerReadyToHandleMsg(CorfuMsg msg);\n \n+    /**\n+     * Determine if the server is ready to handle a request.\n+     * @param request The incoming request message.\n+     * @return True if the server is ready to handle this request, and false otherwise.\n+     */\n+    public boolean isServerReadyToHandleReq(RequestMsg request) {\n+        //TODO: Make abstract once other servers are implemented\n+        return false;\n+    }\n+\n     /**\n      * A stub that handlers can override to manage their threading, otherwise\n      * the requests will be executed on the IO threads\n      * @param msg\n      * @param ctx\n      * @param r\n      */\n+    @Deprecated\n     protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n         getHandler().handle(msg, ctx, r);\n     }\n \n+    /**\n+     * A stub that handlers can override to manage their threading, otherwise\n+     * the requests will be executed on the IO threads\n+     * @param req An incoming request message.\n+     * @param ctx The channel handler context.\n+     * @param r The router that took in the request.\n+     */\n+    protected void processRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        getHandlerMethods().handle(req, ctx, r);\n+    }", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMjYwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521632601", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-11T20:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2NDYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2NDczNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520964735", "bodyText": "Can you also change this to abstract ?", "author": "Maithem", "createdAt": "2020-11-11T00:41:34Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/AbstractServer.java", "diffHunk": "@@ -34,26 +51,51 @@ public void sealServerWithEpoch(long epoch) {\n         // Overridden in log unit to flush operations stamped with an old epoch\n     }\n \n+    @Deprecated\n     public abstract boolean isServerReadyToHandleMsg(CorfuMsg msg);\n \n+    /**\n+     * Determine if the server is ready to handle a request.\n+     * @param request The incoming request message.\n+     * @return True if the server is ready to handle this request, and false otherwise.\n+     */\n+    public boolean isServerReadyToHandleReq(RequestMsg request) {\n+        //TODO: Make abstract once other servers are implemented\n+        return false;\n+    }\n+\n     /**\n      * A stub that handlers can override to manage their threading, otherwise\n      * the requests will be executed on the IO threads\n      * @param msg\n      * @param ctx\n      * @param r\n      */\n+    @Deprecated\n     protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMjY5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521632694", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-11T20:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2NDczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2NTY3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520965671", "bodyText": "This code path shouldn't be used right? Can you just throw an unsupported exception instead of having a default implementation and removing it later? its less error-prone that way.", "author": "Maithem", "createdAt": "2020-11-11T00:44:33Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -29,40 +38,65 @@\n \n     /** HandlerMethod for the base server. */\n     @Getter\n+    @Deprecated\n     private final HandlerMethods handler = HandlerMethods.generateHandler(MethodHandles.lookup(), this);\n \n+    /**\n+     * RequestHandlerMethods for the Base server\n+     */\n+    @Getter\n+    private final RequestHandlerMethods handlerMethods =\n+            RequestHandlerMethods.generateHandler(MethodHandles.lookup(), this);\n+\n     @Override\n+    @Deprecated\n     public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n         return getState() == ServerState.READY;\n     }\n \n+    @Override\n+    public boolean isServerReadyToHandleReq(RequestMsg request) {\n+        return getState() == ServerState.READY;\n+    }\n+\n     public BaseServer(@Nonnull ServerContext context) {\n         this.serverContext = context;\n         executor = Executors.newFixedThreadPool(serverContext.getBaseServerThreadCount(),\n                 new ServerThreadFactory(\"baseServer-\", new ServerThreadFactory.ExceptionHandler()));\n     }\n \n     @Override\n+    @Deprecated", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2ODgxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520968818", "bodyText": "It was used by KEEP_ALIVE, but I'll replace it by PING as suggested below and make the required changes in NettyClientRouter.", "author": "zfrenette", "createdAt": "2020-11-11T00:50:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2NTY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2Njk3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520966977", "bodyText": "You can remove the KEEP_ALIVE message type and use PING instead. You also need to make the corresponding changes for NettyClientRounter::keepAlive", "author": "Maithem", "createdAt": "2020-11-11T00:47:34Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -78,49 +112,54 @@ private void keepAlive(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r)\n         r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n     }\n \n+    //TODO(Zach): Do we need a KEEP_ALIVE?", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMzE4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521633188", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-11T20:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2Njk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2ODAxMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520968010", "bodyText": "vi can be improved. Maybe just use versionInfo", "author": "Maithem", "createdAt": "2020-11-11T00:48:58Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -78,49 +112,54 @@ private void keepAlive(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r)\n         r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n     }\n \n+    //TODO(Zach): Do we need a KEEP_ALIVE?\n+\n     /**\n      * Respond to a version request message.\n      *\n-     * @param msg   The incoming message\n+     * @param req   The incoming message\n      * @param ctx   The channel context\n      * @param r     The server router.\n      */\n-    @ServerHandler(type = CorfuMsgType.VERSION_REQUEST)\n-    private void getVersion(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        VersionInfo vi = new VersionInfo(serverContext.getServerConfig(),\n-                                         serverContext.getNodeIdBase64());\n-        r.sendResponse(ctx, msg, new JSONPayloadMsg<>(vi, CorfuMsgType.VERSION_RESPONSE));\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.VERSION_REQUEST)\n+    private void getVersion(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        VersionInfo vi = new VersionInfo(serverContext.getServerConfig(), serverContext.getNodeIdBase64());", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMzI5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521633291", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-11T20:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2ODAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2OTE1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520969150", "bodyText": "Info is too verbose for a ping. Change you change info to debug level.", "author": "Maithem", "createdAt": "2020-11-11T00:51:08Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -29,40 +38,65 @@\n \n     /** HandlerMethod for the base server. */\n     @Getter\n+    @Deprecated\n     private final HandlerMethods handler = HandlerMethods.generateHandler(MethodHandles.lookup(), this);\n \n+    /**\n+     * RequestHandlerMethods for the Base server\n+     */\n+    @Getter\n+    private final RequestHandlerMethods handlerMethods =\n+            RequestHandlerMethods.generateHandler(MethodHandles.lookup(), this);\n+\n     @Override\n+    @Deprecated\n     public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n         return getState() == ServerState.READY;\n     }\n \n+    @Override\n+    public boolean isServerReadyToHandleReq(RequestMsg request) {\n+        return getState() == ServerState.READY;\n+    }\n+\n     public BaseServer(@Nonnull ServerContext context) {\n         this.serverContext = context;\n         executor = Executors.newFixedThreadPool(serverContext.getBaseServerThreadCount(),\n                 new ServerThreadFactory(\"baseServer-\", new ServerThreadFactory.ExceptionHandler()));\n     }\n \n     @Override\n+    @Deprecated\n     protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n         executor.submit(() -> getHandler().handle(msg, ctx, r));\n     }\n \n+    @Override\n+    protected void processRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        executor.submit(() -> getHandlerMethods().handle(req, ctx, r));\n+    }\n+\n     @Override\n     public void shutdown() {\n         super.shutdown();\n         executor.shutdown();\n     }\n \n     /**\n-     * Respond to a ping message.\n+     * Respond to a ping request.\n      *\n-     * @param msg   The incoming message\n-     * @param ctx   The channel context\n+     * @param req   The incoming request message.\n+     * @param ctx   The channel context.\n      * @param r     The server router.\n      */\n-    @ServerHandler(type = CorfuMsgType.PING)\n-    private void ping(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        r.sendResponse(ctx, msg, CorfuMsgType.PONG.msg());\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.PING_REQUEST)\n+    private void handlePing(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        log.info(\"handlePing[{}]: Ping message received from {} {}\", req.getHeader().getRequestId(),", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMzQyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521633423", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-11T20:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2OTE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MTU4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520971584", "bodyText": "I know you haven't written this code, but how can the remoteAddress be unavailable if this call is invoked after the tcp connection is established?", "author": "Maithem", "createdAt": "2020-11-11T00:55:23Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -78,49 +112,54 @@ private void keepAlive(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r)\n         r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n     }\n \n+    //TODO(Zach): Do we need a KEEP_ALIVE?\n+\n     /**\n      * Respond to a version request message.\n      *\n-     * @param msg   The incoming message\n+     * @param req   The incoming message\n      * @param ctx   The channel context\n      * @param r     The server router.\n      */\n-    @ServerHandler(type = CorfuMsgType.VERSION_REQUEST)\n-    private void getVersion(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        VersionInfo vi = new VersionInfo(serverContext.getServerConfig(),\n-                                         serverContext.getNodeIdBase64());\n-        r.sendResponse(ctx, msg, new JSONPayloadMsg<>(vi, CorfuMsgType.VERSION_RESPONSE));\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.VERSION_REQUEST)\n+    private void getVersion(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        VersionInfo vi = new VersionInfo(serverContext.getServerConfig(), serverContext.getNodeIdBase64());\n+        HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getVersionResponseMsg(vi));\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n-     * Respond to a epoch change message.\n+     * Respond to a epoch change request.\n      * This method also executes sealing logic on each individual server type.\n      *\n-     * @param msg The incoming message\n-     * @param ctx The channel context\n-     * @param r   The server router.\n+     * @param req The incoming request message.\n+     * @param ctx The channel context.\n+     * @param r The server router.\n      */\n-    @ServerHandler(type = CorfuMsgType.SEAL)\n-    public synchronized void handleMessageSetEpoch(@NonNull CorfuPayloadMsg<Long> msg,\n-                                                   ChannelHandlerContext ctx,\n-                                                   @NonNull IServerRouter r) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.SEAL_REQUEST)\n+    private synchronized void handleSeal(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n         try {\n-            long epoch = msg.getPayload();\n+            final long epoch = req.getPayload().getSealRequest().getEpoch();\n             String remoteHostAddress;\n             try {\n                 remoteHostAddress = ((InetSocketAddress)ctx.channel().remoteAddress()).getAddress().getHostAddress();\n-            } catch (NullPointerException e) {\n+            } catch(NullPointerException ex) {", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MzMwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520973306", "bodyText": "Also, a cast to InetSocketAddress is not required because implementations of SocketAddress override the toString method.", "author": "Maithem", "createdAt": "2020-11-11T00:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MTU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1NjMyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521556324", "bodyText": "Is it possible that the connection becomes unavailable between this method's entry point and the call to remoteAddress?", "author": "zfrenette", "createdAt": "2020-11-11T18:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MTU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcxMDMyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521710327", "bodyText": "Yes, it is possible, but why would it unset the SocketAddress if it becomes unavailable?\nThere are other APIs to determine availability (i.e., https://netty.io/4.0/api/io/netty/channel/Channel.html#isOpen--)", "author": "Maithem", "createdAt": "2020-11-11T23:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MTU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3NTkyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520975923", "bodyText": "Now that you have replaces these message types can you also remove them from the CorfuMsgType enum.", "author": "Maithem", "createdAt": "2020-11-11T01:01:54Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -129,14 +168,18 @@ public synchronized void handleMessageSetEpoch(@NonNull CorfuPayloadMsg<Long> ms\n      * which monitors the exit code of Corfu. If the exit code is 100, then it resets\n      * the server and DELETES ALL EXISTING DATA.\n      *\n-     * @param msg   The incoming message\n-     * @param ctx   The channel context\n-     * @param r     The server router.\n+     * @param req The incoming request message.\n+     * @param ctx The channel context.\n+     * @param r The server router.\n      */\n-    @ServerHandler(type = CorfuMsgType.RESET)", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk4MjM1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520982352", "bodyText": "RESET is often confused with RESTART maybe we can call it something else like FLASH, or another descriptive verb that indicates that the state will be nuked.", "author": "Maithem", "createdAt": "2020-11-11T01:11:10Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -129,14 +168,18 @@ public synchronized void handleMessageSetEpoch(@NonNull CorfuPayloadMsg<Long> ms\n      * which monitors the exit code of Corfu. If the exit code is 100, then it resets\n      * the server and DELETES ALL EXISTING DATA.\n      *\n-     * @param msg   The incoming message\n-     * @param ctx   The channel context\n-     * @param r     The server router.\n+     * @param req The incoming request message.\n+     * @param ctx The channel context.\n+     * @param r The server router.\n      */\n-    @ServerHandler(type = CorfuMsgType.RESET)\n-    private void doReset(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        log.warn(\"Remote reset requested from client {}\", msg.getClientID());\n-        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.RESET_REQUEST)", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk5OTc3NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r520999774", "bodyText": "the release of the buffer should probably be in a finally block and not within the try itself.", "author": "Maithem", "createdAt": "2020-11-11T01:36:01Z", "path": "test/src/test/java/org/corfudb/runtime/clients/TestClientRouter.java", "diffHunk": "@@ -318,4 +509,18 @@ public CorfuMsg simulateSerialization(CorfuMsg message) {\n         return msg;\n     }\n \n+    public RequestMsg simulateSerialization(RequestMsg message) throws IOException {\n+        /* simulate serialization/deserialization */\n+        ByteBuf oBuf = Unpooled.buffer();\n+        try (ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(oBuf)) {\n+            message.writeTo(requestOutputStream);\n+            oBuf.resetReaderIndex();\n+            try (ByteBufInputStream msgInputStream = new ByteBufInputStream(oBuf)) {\n+                RequestMsg msg = RequestMsg.parseFrom(msgInputStream);\n+                oBuf.release();", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY5MjQyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521692429", "bodyText": "Good catch -- Done.", "author": "zfrenette", "createdAt": "2020-11-11T23:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk5OTc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwMDQ5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521000498", "bodyText": "Why is a timer needed for the test router?", "author": "Maithem", "createdAt": "2020-11-11T01:37:09Z", "path": "test/src/test/java/org/corfudb/runtime/clients/TestClientRouter.java", "diffHunk": "@@ -218,17 +276,99 @@ public IClientRouter addClient(IClient client) {\n         return cfTimeout;\n     }\n \n+    /**\n+     * Send a request message and get a completable future to be fulfilled by the reply.\n+     *\n+     * @param payload\n+     * @param epoch\n+     * @param clusterId\n+     * @param priority\n+     * @param ignoreClusterId\n+     * @param ignoreEpoch\n+     * @param <T> The type of completable to return.\n+     * @return A completable future which will be fulfilled by the reply,\n+     * or a timeout in the case there is no response.\n+     */\n+    @Override\n+    public  <T> CompletableFuture<T> sendRequestAndGetCompletable(CorfuMessage.RequestPayloadMsg payload,\n+                                                                  long epoch, RpcCommon.UuidMsg clusterId,\n+                                                                  CorfuMessage.PriorityLevel priority,\n+                                                                  boolean ignoreClusterId, boolean ignoreEpoch) {\n+        // Simulate a \"disconnected endpoint\"\n+        if (!connected) {\n+            log.trace(\"Disconnected endpoint \" + host + \":\" + port);\n+            throw new NetworkException(\"Disconnected endpoint\", NodeLocator.builder()\n+                    .host(host)\n+                    .port(port).build());\n+        }\n+\n+        // Set up the timer and context to measure request\n+        final Timer roundTripMsgTimer = getProtoTimer(payload.getPayloadCase());\n+        final Timer.Context roundTripMsgContext = MetricsUtils\n+                .getConditionalContext(roundTripMsgTimer);\n+\n+        // Get the next request ID.\n+        final long thisRequestId = requestID.getAndIncrement();\n+        RpcCommon.UuidMsg protoClientId = CorfuProtocolCommon.getUuidMsg(clientID);\n+\n+        // Set the base fields for this message.\n+        CorfuMessage.HeaderMsg header = CorfuProtocolMessage.getHeaderMsg(thisRequestId, priority,\n+                epoch, clusterId, protoClientId, ignoreClusterId, ignoreEpoch);\n+        CorfuMessage.RequestMsg request = CorfuMessage.RequestMsg.newBuilder().setHeader(header)\n+                .setPayload(payload).build();\n+\n+        // Generate a future and put it in the completion table.\n+        final CompletableFuture<T> cf = new CompletableFuture<>();\n+        outstandingRequests.put(thisRequestId, cf);\n+\n+        // Evaluate rules.\n+        if (rules.stream().allMatch(x -> x.evaluate(request, this))) {\n+            log.trace(Thread.currentThread().getId() + \":Sent request: {}\", request);\n+            // Write the message out to the channel\n+            try {\n+                RequestMsg requestMsg = simulateSerialization(request);\n+                serverRouter.sendServerMessage(requestMsg, channelContext);\n+            } catch (IOException e) {\n+                log.error(\"encode: Error during serialization or deserialization!\", e);\n+            }\n+        }\n+        // Generate a benchmarked future to measure the underlying request\n+        final CompletableFuture<T> cfBenchmarked = cf.thenApply(x -> {\n+            MetricsUtils.stopConditionalContext(roundTripMsgContext);\n+            return x;\n+        });\n+\n+        // Generate a timeout future, which will complete exceptionally if the main future is not completed.\n+        final CompletableFuture<T> cfTimeout = CFUtils.within(cfBenchmarked, Duration.ofMillis(timeoutResponse));\n+        cfTimeout.exceptionally(e -> {\n+            outstandingRequests.remove(thisRequestId);\n+            log.debug(\"Remove request {} due to timeout!\", thisRequestId);\n+            return null;\n+        });\n+        return cfTimeout;\n+    }\n+\n     // Create a timer using appropriate cached timer names\n     private Timer getTimer(@NonNull CorfuMsg message) {\n         if (!timerNameCache.containsKey(message.getMsgType())) {\n             timerNameCache.put(message.getMsgType(),\n-                               CorfuComponent.CLIENT_ROUTER.toString() +\n-                               message.getMsgType().name().toLowerCase());\n+                    CorfuComponent.CLIENT_ROUTER.toString() +\n+                            message.getMsgType().name().toLowerCase());\n         }\n         return CorfuRuntime.getDefaultMetrics()\n                 .timer(timerNameCache.get(message.getMsgType()));\n     }\n \n+    // Create a timer using appropriate cached timer names\n+    private Timer getProtoTimer(@NonNull RequestPayloadMsg.PayloadCase payloadCase) {\n+        if (!protoTimerNameCache.containsKey(payloadCase)) {\n+            protoTimerNameCache.put(payloadCase,\n+                    CorfuComponent.CLIENT_ROUTER.toString() + payloadCase.name().toLowerCase());\n+        }\n+        return CorfuRuntime.getDefaultMetrics()\n+                .timer(protoTimerNameCache.get(payloadCase));\n+    }\n+", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY5MjI0Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521692243", "bodyText": "Good point, I've cleaned it up.", "author": "zfrenette", "createdAt": "2020-11-11T23:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwMDQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxMjkyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r521012928", "bodyText": "The testing path doesnt actually test the encode/decode code paths. Since we are writing new code, I suggest we start writing proper test cases using mocks and abandon the current TestRouter, its slow, erroneous and has bad coverage.", "author": "Maithem", "createdAt": "2020-11-11T01:54:51Z", "path": "test/src/test/java/org/corfudb/infrastructure/TestServerRouter.java", "diffHunk": "@@ -4,16 +4,18 @@\n import lombok.Getter;\n import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.service.CorfuProtocolMessage;\n import org.corfudb.protocols.wireprotocol.CorfuMsg;\n import org.corfudb.protocols.wireprotocol.CorfuMsgType;", "originalCommit": "f18c1c4cd0ff0e50595a5162317b1c3980ca46ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cc52c816c88ab2852a65db5085b5252607472d95", "url": "https://github.com/CorfuDB/CorfuDB/commit/cc52c816c88ab2852a65db5085b5252607472d95", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-11T20:53:30Z", "type": "forcePushed"}, {"oid": "2f5879f169d0c97f11723c5408c21c71570b2be4", "url": "https://github.com/CorfuDB/CorfuDB/commit/2f5879f169d0c97f11723c5408c21c71570b2be4", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-11T23:08:05Z", "type": "forcePushed"}, {"oid": "e7496263d57ee765ed1ad48094343b1d0ad9a940", "url": "https://github.com/CorfuDB/CorfuDB/commit/e7496263d57ee765ed1ad48094343b1d0ad9a940", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-12T03:17:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI3ODMxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r522278318", "bodyText": "This should to be made into a proper integration test built on AbstractIT.", "author": "zfrenette", "createdAt": "2020-11-12T17:19:53Z", "path": "test/src/test/java/org/corfudb/runtime/clients/BaseClientTest.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.wireprotocol.VersionInfo;\n+import org.corfudb.runtime.RuntimeParameters;\n+import org.corfudb.util.NodeLocator;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.UUID;\n+\n+@Ignore(\"Required only for integration Tests with a Corfu server running on port 9000\")\n+public class BaseClientTest {\n+\n+    private BaseClient baseClient;\n+    private final int connTimeout = 10000000;\n+\n+    @Before\n+    public void setup() {\n+        NodeLocator nodeLocator = NodeLocator.parseString(\"localhost:9000\");\n+        UUID clientID = UUID.fromString(\"00000000-0000-0000-0000-000000000000\");\n+        RuntimeParameters runtimeParameters = new RuntimeParameters();\n+        runtimeParameters.setClientId(clientID);\n+        runtimeParameters.setCustomNettyChannelOptions(RuntimeParameters.DEFAULT_CHANNEL_OPTIONS);\n+        runtimeParameters.setConnectionTimeout(Duration.ofHours(1));\n+        runtimeParameters.setRequestTimeout(Duration.ofHours(1));\n+        runtimeParameters.setIdleConnectionTimeout(connTimeout);\n+        NettyClientRouter ncr = new NettyClientRouter(nodeLocator,\n+                new NioEventLoopGroup(),\n+                runtimeParameters);\n+        this.baseClient = new BaseClient(ncr, 0L, clientID);\n+    }", "originalCommit": "e7496263d57ee765ed1ad48094343b1d0ad9a940", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI4NzcyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r522287727", "bodyText": "Note: This will just invoke the RPC twice, and does not actually compare the old implementation with the new.", "author": "zfrenette", "createdAt": "2020-11-12T17:32:00Z", "path": "test/src/test/java/org/corfudb/runtime/clients/BaseClientTest.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.wireprotocol.VersionInfo;\n+import org.corfudb.runtime.RuntimeParameters;\n+import org.corfudb.util.NodeLocator;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.UUID;\n+\n+@Ignore(\"Required only for integration Tests with a Corfu server running on port 9000\")\n+public class BaseClientTest {\n+\n+    private BaseClient baseClient;\n+    private final int connTimeout = 10000000;\n+\n+    @Before\n+    public void setup() {\n+        NodeLocator nodeLocator = NodeLocator.parseString(\"localhost:9000\");\n+        UUID clientID = UUID.fromString(\"00000000-0000-0000-0000-000000000000\");\n+        RuntimeParameters runtimeParameters = new RuntimeParameters();\n+        runtimeParameters.setClientId(clientID);\n+        runtimeParameters.setCustomNettyChannelOptions(RuntimeParameters.DEFAULT_CHANNEL_OPTIONS);\n+        runtimeParameters.setConnectionTimeout(Duration.ofHours(1));\n+        runtimeParameters.setRequestTimeout(Duration.ofHours(1));\n+        runtimeParameters.setIdleConnectionTimeout(connTimeout);\n+        NettyClientRouter ncr = new NettyClientRouter(nodeLocator,\n+                new NioEventLoopGroup(),\n+                runtimeParameters);\n+        this.baseClient = new BaseClient(ncr, 0L, clientID);\n+    }\n+\n+    @Test\n+    public void pingTest() {\n+        Assertions.assertThat(baseClient.ping().join().booleanValue()).isTrue();\n+    }\n+\n+    @Test\n+    public void restartTest() {\n+        Assertions.assertThat(baseClient.restart().join().booleanValue()).isTrue();\n+    }\n+\n+    @Test\n+    public void resetTest() {\n+        Assertions.assertThat(baseClient.reset().join().booleanValue()).isTrue();\n+    }\n+\n+    @Test\n+    public void sealTest() {\n+        final long NEW_EPOCH = 1L;\n+        Assertions.assertThat(baseClient.sealRemoteServer(NEW_EPOCH).join().booleanValue()).isTrue();\n+    }\n+\n+    @Test\n+    public void versionTest() {\n+        VersionInfo viCorfuMsg = baseClient.getVersionInfo().join();\n+        VersionInfo viProtoMsg = baseClient.getVersionInfo().join();\n+        Assertions.assertThat(viCorfuMsg.getJvmUsed()).isEqualTo(viProtoMsg.getJvmUsed());\n+        Assertions.assertThat(viCorfuMsg.getStartupArgs()).isEqualTo(viProtoMsg.getStartupArgs());\n+        Assertions.assertThat(viCorfuMsg.getVersion()).isEqualTo(viProtoMsg.getVersion());\n+        Assertions.assertThat(viCorfuMsg.getNodeId()).isEqualTo(viProtoMsg.getNodeId());\n+    }", "originalCommit": "e7496263d57ee765ed1ad48094343b1d0ad9a940", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "17d2b43fbb09b6261722d7ca13a7944a012e37a1", "url": "https://github.com/CorfuDB/CorfuDB/commit/17d2b43fbb09b6261722d7ca13a7944a012e37a1", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-13T21:19:00Z", "type": "forcePushed"}, {"oid": "00d7241f7ad41b482008aab24056d05c59d94a00", "url": "https://github.com/CorfuDB/CorfuDB/commit/00d7241f7ad41b482008aab24056d05c59d94a00", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-14T03:17:00Z", "type": "forcePushed"}, {"oid": "166c1b8c803996fa255531348bc3350c5b5afed3", "url": "https://github.com/CorfuDB/CorfuDB/commit/166c1b8c803996fa255531348bc3350c5b5afed3", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-15T01:51:50Z", "type": "forcePushed"}, {"oid": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "url": "https://github.com/CorfuDB/CorfuDB/commit/fe64b4a913666532b41c2e80e298d6d50862a7b9", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-16T14:27:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMTE0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525511149", "bodyText": "Can you keep the name consistent with https://github.com/CorfuDB/CorfuDB/pull/2812/files#diff-b8f48a536562d8a1808b637fc91cba3ab703038172f68c7eaf35eac773e83f0dR89\nYou can overload the method.", "author": "Maithem", "createdAt": "2020-11-17T20:41:40Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/AbstractServer.java", "diffHunk": "@@ -68,6 +100,33 @@ public final void handleMessage(CorfuMsg msg, ChannelHandlerContext ctx, IServer\n         processRequest(msg, ctx, r);\n     }\n \n+    /**\n+     * Handle a incoming request message.\n+     *\n+     * @param req An incoming request message.\n+     * @param ctx The channel handler context.\n+     * @param r   The router that took in the request message.\n+     */\n+    public final void handleRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2ODE0MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526368140", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-18T19:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMTE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMzE3Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525513172", "bodyText": "I think the executor can be constructed and passed from the parent, but we can do those changes in another PR.", "author": "Maithem", "createdAt": "2020-11-17T20:45:42Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -27,24 +34,42 @@\n \n     private final ExecutorService executor;\n \n-    /** HandlerMethod for the base server. */\n     @Getter\n+    @Deprecated\n     private final HandlerMethods handler = HandlerMethods.generateHandler(MethodHandles.lookup(), this);\n \n+    /**\n+     * RequestHandlerMethods for the Base server\n+     */\n+    @Getter\n+    private final RequestHandlerMethods handlerMethods =\n+            RequestHandlerMethods.generateHandler(MethodHandles.lookup(), this);\n+\n     @Override\n+    @Deprecated\n     public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n+        throw new UnsupportedOperationException(\"This operation is not supported\");\n+    }\n+\n+    @Override\n+    public boolean isServerReadyToHandleMsg(RequestMsg request) {\n         return getState() == ServerState.READY;\n     }\n \n     public BaseServer(@Nonnull ServerContext context) {\n-        this.serverContext = context;\n-        executor = Executors.newFixedThreadPool(serverContext.getBaseServerThreadCount(),\n-                new ServerThreadFactory(\"baseServer-\", new ServerThreadFactory.ExceptionHandler()));\n+        serverContext = context;\n+        executor = serverContext.getExecutorService(serverContext.getBaseServerThreadCount(), \"baseServer-\");", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNDE3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525514171", "bodyText": "The parent class can implement this, that way you don't need to implement the unsupported method in the child classes.", "author": "Maithem", "createdAt": "2020-11-17T20:47:30Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -27,24 +34,42 @@\n \n     private final ExecutorService executor;\n \n-    /** HandlerMethod for the base server. */\n     @Getter\n+    @Deprecated\n     private final HandlerMethods handler = HandlerMethods.generateHandler(MethodHandles.lookup(), this);\n \n+    /**\n+     * RequestHandlerMethods for the Base server\n+     */\n+    @Getter\n+    private final RequestHandlerMethods handlerMethods =\n+            RequestHandlerMethods.generateHandler(MethodHandles.lookup(), this);\n+\n     @Override\n+    @Deprecated\n     public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n+        throw new UnsupportedOperationException(\"This operation is not supported\");\n+    }\n+\n+    @Override\n+    public boolean isServerReadyToHandleMsg(RequestMsg request) {\n         return getState() == ServerState.READY;\n     }\n \n     public BaseServer(@Nonnull ServerContext context) {\n-        this.serverContext = context;\n-        executor = Executors.newFixedThreadPool(serverContext.getBaseServerThreadCount(),\n-                new ServerThreadFactory(\"baseServer-\", new ServerThreadFactory.ExceptionHandler()));\n+        serverContext = context;\n+        executor = serverContext.getExecutorService(serverContext.getBaseServerThreadCount(), \"baseServer-\");\n     }\n \n     @Override\n+    @Deprecated\n     protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        executor.submit(() -> getHandler().handle(msg, ctx, r));\n+        throw new UnsupportedOperationException(\"This operation is not supported\");\n+    }", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2Nzk4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526367989", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-18T19:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNDE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNjE0Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525516143", "bodyText": "Comments unaddressed from previous PR. don't think you need a try-catch here.", "author": "Maithem", "createdAt": "2020-11-17T20:51:07Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -54,73 +79,70 @@ public void shutdown() {\n     }\n \n     /**\n-     * Respond to a ping message.\n-     *\n-     * @param msg   The incoming message\n-     * @param ctx   The channel context\n-     * @param r     The server router.\n-     */\n-    @ServerHandler(type = CorfuMsgType.PING)\n-    private void ping(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        r.sendResponse(ctx, msg, CorfuMsgType.PONG.msg());\n-    }\n-\n-    /**\n-     * Respond to a keep alive message.\n-     * Note: this message ignores epoch.\n+     * Respond to a ping request.\n      *\n-     * @param msg   The incoming message\n-     * @param ctx   The channel context\n+     * @param req   The incoming request message.\n+     * @param ctx   The channel context.\n      * @param r     The server router.\n      */\n-    @ServerHandler(type = CorfuMsgType.KEEP_ALIVE)\n-    private void keepAlive(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.PING_REQUEST)\n+    public void handlePing(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        log.debug(\"handlePing[{}]: Ping message received from {} {}\", req.getHeader().getRequestId(),\n+                req.getHeader().getClientId().getMsb(), req.getHeader().getClientId().getLsb());\n+\n+        HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getPingResponseMsg());\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * Respond to a version request message.\n      *\n-     * @param msg   The incoming message\n+     * @param req   The incoming message\n      * @param ctx   The channel context\n      * @param r     The server router.\n      */\n-    @ServerHandler(type = CorfuMsgType.VERSION_REQUEST)\n-    private void getVersion(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        VersionInfo vi = new VersionInfo(serverContext.getServerConfig(),\n-                                         serverContext.getNodeIdBase64());\n-        r.sendResponse(ctx, msg, new JSONPayloadMsg<>(vi, CorfuMsgType.VERSION_RESPONSE));\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.VERSION_REQUEST)\n+    private void getVersion(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        VersionInfo versionInfo = new VersionInfo(serverContext.getServerConfig(), serverContext.getNodeIdBase64());\n+        HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getVersionResponseMsg(versionInfo));\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n-     * Respond to a epoch change message.\n+     * Respond to a epoch change request.\n      * This method also executes sealing logic on each individual server type.\n      *\n-     * @param msg The incoming message\n-     * @param ctx The channel context\n-     * @param r   The server router.\n+     * @param req The incoming request message.\n+     * @param ctx The channel context.\n+     * @param r The server router.\n      */\n-    @ServerHandler(type = CorfuMsgType.SEAL)\n-    public synchronized void handleMessageSetEpoch(@NonNull CorfuPayloadMsg<Long> msg,\n-                                                   ChannelHandlerContext ctx,\n-                                                   @NonNull IServerRouter r) {\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.SEAL_REQUEST)\n+    private synchronized void handleSeal(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n         try {\n-            long epoch = msg.getPayload();\n+            final long epoch = req.getPayload().getSealRequest().getEpoch();\n             String remoteHostAddress;\n             try {\n                 remoteHostAddress = ((InetSocketAddress)ctx.channel().remoteAddress()).getAddress().getHostAddress();\n-            } catch (NullPointerException e) {\n+            } catch (NullPointerException ex) {", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0MTc3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526241776", "bodyText": "It's at least convenient for testing. The unit tests that do not use mocking fail because of this. See LayoutSealTest, for example.", "author": "zfrenette", "createdAt": "2020-11-18T16:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNjE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MzY0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525443644", "bodyText": "This message will pollute the log, please chane it trace", "author": "xnull", "createdAt": "2020-11-17T19:42:30Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/BaseServer.java", "diffHunk": "@@ -54,73 +79,70 @@ public void shutdown() {\n     }\n \n     /**\n-     * Respond to a ping message.\n-     *\n-     * @param msg   The incoming message\n-     * @param ctx   The channel context\n-     * @param r     The server router.\n-     */\n-    @ServerHandler(type = CorfuMsgType.PING)\n-    private void ping(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        r.sendResponse(ctx, msg, CorfuMsgType.PONG.msg());\n-    }\n-\n-    /**\n-     * Respond to a keep alive message.\n-     * Note: this message ignores epoch.\n+     * Respond to a ping request.\n      *\n-     * @param msg   The incoming message\n-     * @param ctx   The channel context\n+     * @param req   The incoming request message.\n+     * @param ctx   The channel context.\n      * @param r     The server router.\n      */\n-    @ServerHandler(type = CorfuMsgType.KEEP_ALIVE)\n-    private void keepAlive(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n+    @RequestHandler(type = RequestPayloadMsg.PayloadCase.PING_REQUEST)\n+    public void handlePing(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        log.debug(\"handlePing[{}]: Ping message received from {} {}\", req.getHeader().getRequestId(),", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2Nzc4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526367785", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-18T19:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MzY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0NzkyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525447923", "bodyText": "Please invert the \"if\" condition", "author": "xnull", "createdAt": "2020-11-17T19:45:56Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/IServerRouter.java", "diffHunk": "@@ -168,6 +186,118 @@ default boolean messageIsValid(CorfuMsg msg, ChannelHandlerContext ctx) {\n      * @param inMsg\n      * @param outMsg\n      */\n+    @Deprecated\n     default void sendResponse(CorfuMsg inMsg, CorfuMsg outMsg) {}\n \n+    /**\n+     * Send a WRONG_EPOCH error response.\n+     *\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     */\n+    default void sendWrongEpochError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        final long correctEpoch = getServerEpoch();\n+\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getWrongEpochErrorMsg(correctEpoch));\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongEpochError[{}]: Incoming request received with wrong epoch, got {}, expected {}, \" +\n+                \"request was {}\", requestHeader.getRequestId(), requestHeader.getEpoch(), correctEpoch, requestHeader);\n+    }\n+\n+    /**\n+     * Send a NOT_BOOTSTRAPPED error response.\n+     *\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     */\n+    default void sendNoBootstrapError(HeaderMsg requestHeader, ChannelHandlerContext ctx) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader, getNotBootstrappedErrorMsg());\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendNoBootstrapError[{}]: Received request but not bootstrapped! Request was {}\",\n+                requestHeader.getRequestId(), requestHeader);\n+    }\n+\n+    /**\n+     * Send a WRONG_CLUSTER error response.\n+     *\n+     * @param requestHeader The header of the incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @param clusterId The current cluster id.\n+     */\n+    default void sendWrongClusterError(HeaderMsg requestHeader, ChannelHandlerContext ctx, UuidMsg clusterId) {\n+        HeaderMsg responseHeader = getHeaderMsg(requestHeader, false, true);\n+        ResponseMsg response = getResponseMsg(responseHeader,\n+                getWrongClusterErrorMsg(clusterId, requestHeader.getClusterId()));\n+\n+        sendResponse(response, ctx);\n+\n+        log.trace(\"sendWrongClusterError[{}]: Incoming request with a wrong cluster id, got {}, expected {}, \" +\n+                \"request was: {}\", requestHeader.getRequestId(), requestHeader.getClusterId(), clusterId, requestHeader);\n+    }\n+\n+    /**\n+     * Validate the epoch of an incoming request.\n+     *\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @return True, if the epoch is correct, but false otherwise.\n+     */\n+    default boolean epochIsValid(HeaderMsg requestHeader) {\n+        final long serverEpoch = getServerEpoch();\n+        return requestHeader.getEpoch() == serverEpoch;\n+    }\n+\n+    /**\n+     * Validate that the cluster ID of the incoming request is equal to the\n+     * cluster ID of a bootstrapped layout.\n+     *\n+     * @param requestHeader The header of the incoming request to validate.\n+     * @param currentClusterID The cluster ID of the layout the server was bootstrapped with.\n+     * @return True, if the cluster ID of the request matches the cluster ID of the layout, but false otherwise.\n+     */\n+    default boolean clusterIdIsValid(HeaderMsg requestHeader, UuidMsg currentClusterID) {\n+        return requestHeader.getClusterId().equals(currentClusterID);\n+    }\n+\n+    /**\n+     * Validate the incoming request and send an error response if the request is invalid.\n+     * The request is valid if:\n+     *    1) The flag ignoreEpoch is set to true, or it's set to false and the epoch is valid.\n+     *    2) Also, if the flag ignoreClusterId is set to false,\n+     *           a. The current layout server should be bootstrapped and\n+     *           b. the request's cluster ID should be equal to the bootstrapped layout's cluster ID.\n+     *\n+     * @param req The incoming request.\n+     * @param ctx The context of the channel handler.\n+     * @return True if the request is valid, and false otherwise.\n+     */\n+    default boolean validateRequest(RequestMsg req, ChannelHandlerContext ctx) {\n+        HeaderMsg requestHeader = req.getHeader();\n+\n+        if (!requestHeader.getIgnoreEpoch() && !epochIsValid(requestHeader)) {\n+            sendWrongEpochError(requestHeader, ctx);\n+            return false;\n+        }\n+\n+        if (!requestHeader.getIgnoreClusterId()) {", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2NjUzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526366536", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-18T19:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0NzkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1MDU0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525450544", "bodyText": "please import \"RequestPayloadMsg.PayloadCase\". The code should be\n(req.getPayload().getPayloadCase().equals(PayloadCase.QUERY_NODE_REQUEST))", "author": "xnull", "createdAt": "2020-11-17T19:47:59Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ManagementServer.java", "diffHunk": "@@ -114,6 +128,16 @@ protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRo\n         }\n     }\n \n+    @Override\n+    protected void processRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        if (req.getPayload().getPayloadCase().equals(RequestPayloadMsg.PayloadCase.QUERY_NODE_REQUEST)) {", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2NTA0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526365041", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-18T19:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1MDU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1MTI1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525451256", "bodyText": "import RequestPayloadMsg", "author": "xnull", "createdAt": "2020-11-17T19:48:39Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/NettyServerRouter.java", "diffHunk": "@@ -30,8 +32,14 @@\n     /**\n      * This map stores the mapping from message type to netty server handler.\n      */\n+    @Deprecated\n     private final Map<CorfuMsgType, AbstractServer> handlerMap;\n \n+    /**\n+     * This map stores the mapping from message types to server handler.\n+     */\n+    private final Map<RequestPayloadMsg.PayloadCase, AbstractServer> requestTypeHandlerMap;", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3ODE4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525578189", "bodyText": "RequestPayloadMsg is already imported on line 13. Did you mean RequestPayloadMsg.PayloadCase as above? If so, done.", "author": "zfrenette", "createdAt": "2020-11-17T22:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1MTI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1ODgxMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525458813", "bodyText": "IDEA warns you, if you see that your code is yellow, please change it accordingly and make it green", "author": "xnull", "createdAt": "2020-11-17T19:54:50Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/NettyServerRouter.java", "diffHunk": "@@ -115,34 +141,64 @@ public void sendResponse(ChannelHandlerContext ctx, CorfuMsg inMsg, CorfuMsg out\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object msg) {\n         try {\n-            // The incoming message should have been transformed to a CorfuMsg earlier in the\n-            // pipeline.\n-            CorfuMsg m = ((CorfuMsg) msg);\n-            // We get the handler for this message from the map\n-            AbstractServer handler = handlerMap.get(m.getMsgType());\n-            if (handler == null) {\n-                // The message was unregistered, we are dropping it.\n-                log.warn(\"Received unregistered message {}, dropping\", m);\n-            } else {\n-                if (messageIsValid(m, ctx)) {\n-                    // Route the message to the handler.\n-                    if (log.isTraceEnabled()) {\n-                        log.trace(\"Message routed to {}: {}\", handler.getClass().getSimpleName(), msg);\n+            if (msg instanceof CorfuMsg) {\n+                // The incoming message should have been transformed to a CorfuMsg earlier in the pipeline.\n+                CorfuMsg m = ((CorfuMsg) msg);\n+                // We get the handler for this message from the map\n+                AbstractServer handler = handlerMap.get(m.getMsgType());\n+                if (handler == null) {\n+                    // The message was unregistered, we are dropping it.\n+                    log.warn(\"channelRead: Received unregistered message {}, dropping\", m);\n+                } else {\n+                    if (messageIsValid(m, ctx)) {\n+                        // Route the message to the handler.\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"channelRead: Message routed to {}: {}\", handler.getClass().getSimpleName(), msg);\n+                        }\n+\n+                        try {\n+                            handler.handleMessage(m, ctx, this);\n+                        } catch (Throwable t) {\n+                            log.error(\"channelRead: Handling {} failed due to {}:{}\",\n+                                    m != null ? m.getMsgType() : \"UNKNOWN\",\n+                                    t.getClass().getSimpleName(),\n+                                    t.getMessage(),\n+                                    t);\n+                        }\n                     }\n+                }\n+            } else if (msg instanceof RequestMsg) {\n+                RequestMsg request = ((RequestMsg) msg);\n+                RequestPayloadMsg payload = request.getPayload();\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"channelRead: Request {} from {}\",\n+                            payload.getPayloadCase().toString(), ctx.channel().remoteAddress());\n+                }\n \n-                    try {\n-                        handler.handleMessage(m, ctx, this);\n-                    } catch (Throwable t) {\n-                        log.error(\"channelRead: Handling {} failed due to {}:{}\",\n-                                m != null ? m.getMsgType() : \"UNKNOWN\",\n-                                t.getClass().getSimpleName(),\n-                                t.getMessage(),\n-                                t);\n+                AbstractServer handler = requestTypeHandlerMap.get(payload.getPayloadCase());\n+                if (handler == null) {\n+                    log.warn(\"channelRead: Received unregistered request {}, dropping\",\n+                            payload.getPayloadCase().toString());\n+                } else {\n+                    if (validateRequest(request, ctx)) {\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"channelRead: Request routed to {}: {}\",\n+                                    handler.getClass().getSimpleName(), request);\n+                        }\n+\n+                        try {\n+                            handler.handleRequest(request, ctx, this);\n+                        } catch (Throwable t) {\n+                            log.error(\"channelRead: Handling {} failed due to {}:{}\",", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwNjQyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525506429", "bodyText": "Would be  great if you also take a look at other parts of your code and try to fix most/all yellow spots", "author": "xnull", "createdAt": "2020-11-17T20:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1ODgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMzkwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525513903", "bodyText": "I don't like the idea of having two different hash maps for handling messages.\nOne question:\n\nCan we get rid of \"requestTypeHandlerMap\"? Let's just have a mapping function between CorfuMsgType and PayloadCase, then we won't need to have two maps.", "author": "xnull", "createdAt": "2020-11-17T20:47:02Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/NettyServerRouter.java", "diffHunk": "@@ -115,34 +141,64 @@ public void sendResponse(ChannelHandlerContext ctx, CorfuMsg inMsg, CorfuMsg out\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object msg) {\n         try {\n-            // The incoming message should have been transformed to a CorfuMsg earlier in the\n-            // pipeline.\n-            CorfuMsg m = ((CorfuMsg) msg);\n-            // We get the handler for this message from the map\n-            AbstractServer handler = handlerMap.get(m.getMsgType());\n-            if (handler == null) {\n-                // The message was unregistered, we are dropping it.\n-                log.warn(\"Received unregistered message {}, dropping\", m);\n-            } else {\n-                if (messageIsValid(m, ctx)) {\n-                    // Route the message to the handler.\n-                    if (log.isTraceEnabled()) {\n-                        log.trace(\"Message routed to {}: {}\", handler.getClass().getSimpleName(), msg);\n+            if (msg instanceof CorfuMsg) {\n+                // The incoming message should have been transformed to a CorfuMsg earlier in the pipeline.\n+                CorfuMsg m = ((CorfuMsg) msg);\n+                // We get the handler for this message from the map\n+                AbstractServer handler = handlerMap.get(m.getMsgType());", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNjcyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525516723", "bodyText": "Since you have deprecated a bunch  of methods in IServerRouter, I'd say it's better not to add new methods into IServerRouter but create another interface ProtobufServerRouter wich will contain all those new methods and in your code... there will be an \"if\"  condition that defines which router to use", "author": "xnull", "createdAt": "2020-11-17T20:52:08Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/NettyServerRouter.java", "diffHunk": "@@ -115,34 +141,64 @@ public void sendResponse(ChannelHandlerContext ctx, CorfuMsg inMsg, CorfuMsg out\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object msg) {\n         try {\n-            // The incoming message should have been transformed to a CorfuMsg earlier in the\n-            // pipeline.\n-            CorfuMsg m = ((CorfuMsg) msg);\n-            // We get the handler for this message from the map\n-            AbstractServer handler = handlerMap.get(m.getMsgType());\n-            if (handler == null) {\n-                // The message was unregistered, we are dropping it.\n-                log.warn(\"Received unregistered message {}, dropping\", m);\n-            } else {\n-                if (messageIsValid(m, ctx)) {\n-                    // Route the message to the handler.\n-                    if (log.isTraceEnabled()) {\n-                        log.trace(\"Message routed to {}: {}\", handler.getClass().getSimpleName(), msg);\n+            if (msg instanceof CorfuMsg) {\n+                // The incoming message should have been transformed to a CorfuMsg earlier in the pipeline.\n+                CorfuMsg m = ((CorfuMsg) msg);\n+                // We get the handler for this message from the map\n+                AbstractServer handler = handlerMap.get(m.getMsgType());\n+                if (handler == null) {\n+                    // The message was unregistered, we are dropping it.\n+                    log.warn(\"channelRead: Received unregistered message {}, dropping\", m);\n+                } else {\n+                    if (messageIsValid(m, ctx)) {", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1Njk0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525556942", "bodyText": "We had an offline discussion, an got to agrrement", "author": "xnull", "createdAt": "2020-11-17T22:07:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNjcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxODIxMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525518212", "bodyText": "can you wrap this with if (log.isTraceEnable)", "author": "Maithem", "createdAt": "2020-11-17T20:54:54Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/NettyServerRouter.java", "diffHunk": "@@ -95,12 +109,24 @@ public void setServerContext(ServerContext serverContext) {\n      * @param inMsg  Incoming message to respond to.\n      * @param outMsg Outgoing message.\n      */\n+    @Deprecated\n     public void sendResponse(ChannelHandlerContext ctx, CorfuMsg inMsg, CorfuMsg outMsg) {\n         outMsg.copyBaseFields(inMsg);\n         ctx.writeAndFlush(outMsg, ctx.voidPromise());\n         log.trace(\"Sent response: {}\", outMsg);\n     }\n \n+    /**\n+     * Send a response message through this router.\n+     *\n+     * @param response The response message to send.\n+     * @param ctx      The context of the channel handler.\n+     */\n+    public void sendResponse(ResponseMsg response, ChannelHandlerContext ctx) {\n+        ctx.writeAndFlush(response, ctx.voidPromise());\n+        log.trace(\"Sent response: {}\", response);", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2NDY2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526364665", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-18T19:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxODIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMjgzNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525522834", "bodyText": "Isn't it cleaner to just have a method in the parent class that that throws an UnsupportedOperationException instead of having these code paths that shouldn't be invoked?", "author": "Maithem", "createdAt": "2020-11-17T21:03:21Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -142,6 +150,11 @@ protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRo\n         executor.submit(() -> getHandler().handle(msg, ctx, r));\n     }\n \n+    @Override\n+    protected void processRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        executor.submit(() -> getHandlerMethods().handle(req, ctx, r));\n+    }\n+", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5MzA0Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526193043", "bodyText": "I'm not sure I understand. Each server has a new processRequest method that will be used by the new implementations of the RPCs. In a previous comment, you suggested making processRequest abstract in AbstractServer, so here we provide the implementation.", "author": "zfrenette", "createdAt": "2020-11-18T15:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMjgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNDMyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525524325", "bodyText": "Move this to the AbstractServer class all servers have the same logic (except the SequencerServer)", "author": "Maithem", "createdAt": "2020-11-17T21:06:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -417,6 +430,11 @@ public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n         return getState() == ServerState.READY;\n     }\n \n+    @Override\n+    public boolean isServerReadyToHandleMsg(RequestMsg request) {\n+        return getState() == ServerState.READY;\n+    }", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2NDUyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526364525", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-18T19:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNDMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNjI1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525526258", "bodyText": "Import?", "author": "Maithem", "createdAt": "2020-11-17T21:09:59Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/runtime/LogReplicationServerRouter.java", "diffHunk": "@@ -98,6 +98,11 @@ public void sendResponse(CorfuMsg inMsg, CorfuMsg outMsg) {\n         }\n     }\n \n+    @Override\n+    public void sendResponse(org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg response, ChannelHandlerContext ctx) {", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2NDQyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526364424", "bodyText": "Fixed.", "author": "zfrenette", "createdAt": "2020-11-18T19:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNjI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyODI5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525528295", "bodyText": "This method is not be used.", "author": "Maithem", "createdAt": "2020-11-17T21:13:55Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -92,9 +94,14 @@ public static UUID getUUID(UuidMsg msg) {\n     /**\n      * Returns the Protobuf representation of a Layout.\n      *\n-     * @param layout   the desired (Java) Layout\n+     * @param layout   the desired Java Layout object\n+     * @return         an equivalent Protobuf Layout message\n      */\n     public static LayoutMsg getLayoutMsg(Layout layout) {\n+        if (layout == null) {\n+            return LayoutMsg.getDefaultInstance();\n+        }\n+", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2NTc5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525565790", "bodyText": "You can see it used in PR 2823. We included it in common for easier availability since it will be required by both the management and layout RPCs.", "author": "zfrenette", "createdAt": "2020-11-17T22:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyODI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMjUyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525532525", "bodyText": "Why is this (true, true), on master it is (true, false)\nSEAL(3, new TypeToken<CorfuPayloadMsg<Long>>() {}, true, false),", "author": "Maithem", "createdAt": "2020-11-17T21:21:55Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/BaseClient.java", "diffHunk": "@@ -56,55 +41,52 @@ public boolean pingSync() {\n     }\n \n     /**\n-     * Sets the epoch on client router and on the target layout server.\n+     * Ping the endpoint, asynchronously.\n      *\n-     * @param newEpoch New Epoch to be set\n-     * @return Completable future which returns true on successful epoch set.\n+     * @return A completable future which will be completed with True if\n+     * the endpoint is reachable, otherwise False or exceptional completion.\n      */\n-    public CompletableFuture<Boolean> sealRemoteServer(long newEpoch) {\n-        CorfuMsg msg = new CorfuPayloadMsg<>(CorfuMsgType.SEAL, newEpoch).setEpoch(epoch).setClusterID(clusterId);\n-        log.info(\"sealRemoteServer: send SEAL from me(clientId={}) to new epoch {}\",\n-                msg.getClientID(), epoch);\n-        return router.sendMessageAndGetCompletable(msg);\n-    }\n-\n-    public CompletableFuture<VersionInfo> getVersionInfo() {\n-        return router.sendMessageAndGetCompletable(\n-                new CorfuMsg(CorfuMsgType.VERSION_REQUEST).setEpoch(epoch).setClusterID(clusterId));\n+    public CompletableFuture<Boolean> ping() {\n+        return sendRequestWithFuture(getPingRequestMsg(), true, true);\n     }\n \n-\n     /**\n-     * Ping the endpoint, asynchronously.\n+     * Restart the endpoint, asynchronously.\n      *\n      * @return A completable future which will be completed with True if\n-     * the endpoint is reachable, otherwise False or exceptional completion.\n+     * the endpoint restarts successfully, otherwise False or exceptional completion.\n      */\n-    public CompletableFuture<Boolean> ping() {\n-        return router.sendMessageAndGetCompletable(\n-                new CorfuMsg(CorfuMsgType.PING).setEpoch(epoch).setClusterID(clusterId));\n+    public CompletableFuture<Boolean> restart() {\n+        return sendRequestWithFuture(getRestartRequestMsg(), true, true);\n     }\n \n     /**\n      * Reset the endpoint, asynchronously.\n      * WARNING: ALL EXISTING DATA ON THIS NODE WILL BE LOST.\n      *\n      * @return A completable future which will be completed with True if\n-     * the endpoint acks, otherwise False or exceptional completion.\n+     * the endpoint resets successfully, otherwise False or exceptional completion.\n      */\n     public CompletableFuture<Boolean> reset() {\n-        return router.sendMessageAndGetCompletable(new CorfuMsg(CorfuMsgType.RESET)\n-                .setEpoch(epoch).setClusterID(clusterId));\n+        return sendRequestWithFuture(getResetRequestMsg(), true, true);\n     }\n \n     /**\n-     * Restart the endpoint, asynchronously.\n+     * Sets the epoch on client router and on the target layout server.\n      *\n-     * @return A completable future which will be completed with True if\n-     * the endpoint acks, otherwise False or exceptional completion.\n+     * @param newEpoch New Epoch to be set\n+     * @return Completable future which returns true on successful epoch set.\n      */\n-    public CompletableFuture<Boolean> restart() {\n-        return router.sendMessageAndGetCompletable(new CorfuMsg(CorfuMsgType.RESTART)\n-                .setEpoch(epoch).setClusterID(clusterId));\n+    public CompletableFuture<Boolean> sealRemoteServer(long newEpoch) {\n+        return sendRequestWithFuture(getSealRequestMsg(newEpoch), false, true);\n+    }\n+\n+    /**\n+     * Get the version info from the target layout server.\n+     *\n+     * @return Completable future which returns {@link VersionInfo} object.\n+     */\n+    public CompletableFuture<VersionInfo> getVersionInfo() {\n+        return sendRequestWithFuture(getVersionRequestMsg(), true, true);", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNDEwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525534107", "bodyText": "Never mind, the order is reversed.", "author": "Maithem", "createdAt": "2020-11-17T21:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMjUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNDYzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525534637", "bodyText": "Can you remove this now?", "author": "Maithem", "createdAt": "2020-11-17T21:25:42Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/BaseHandler.java", "diffHunk": "@@ -41,38 +49,18 @@\n      * The handler and handlers which implement this client.\n      */\n     @Getter\n+    @Deprecated\n     public ClientMsgHandler msgHandler = new ClientMsgHandler(this)\n             .generateHandlers(MethodHandles.lookup(), this);", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNTU2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525535567", "bodyText": "Why do we still need the handleNack, handleWrongEpoch and handleNotReady methods?", "author": "Maithem", "createdAt": "2020-11-17T21:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNDYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2NzQzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525567435", "bodyText": "Other servers not yet implemented with Protobuf messages can still send these, like the ManagementServer, for example. We can only remove them at the very end.", "author": "zfrenette", "createdAt": "2020-11-17T22:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNDYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NzQzOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525557439", "bodyText": "Can we throw something else but not this exception?", "author": "xnull", "createdAt": "2020-11-17T22:08:39Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/RequestHandlerMethods.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.corfudb.infrastructure;\n+\n+import com.codahale.metrics.Timer;\n+import io.netty.channel.ChannelHandlerContext;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuError;\n+import org.corfudb.util.CorfuComponent;\n+import org.corfudb.util.MetricsUtils;\n+\n+import static org.corfudb.protocols.CorfuProtocolServerErrors.getUnknownErrorMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+\n+@Slf4j\n+public class RequestHandlerMethods {\n+\n+    private final Map<RequestPayloadMsg.PayloadCase, String> timerNameCache = new HashMap<>();\n+\n+    /**\n+     * The handler map.\n+     */\n+    private final Map<RequestPayloadMsg.PayloadCase, HandlerMethod> handlerMap;\n+\n+    /**\n+     * A functional interface for server request handlers. Server request handlers should\n+     * be fast and not block. If a handler blocks for an extended period of time, it will\n+     * exhaust the server's thread pool. I/O and other long operations should be handled\n+     * on another thread.\n+     */\n+    @FunctionalInterface\n+    public interface HandlerMethod {\n+        void handle(@Nonnull RequestMsg req,\n+                    @Nonnull ChannelHandlerContext ctx,\n+                    @Nonnull IServerRouter r);\n+    }\n+\n+    /**\n+     * Get the types of requests this handler will handle.\n+     *\n+     * @return  A set containing the types of requests this handler will handle.\n+     */\n+    public Set<RequestPayloadMsg.PayloadCase> getHandledTypes() {\n+        return handlerMap.keySet();\n+    }\n+\n+    /**\n+     * Construct a new instance of RequestHandlerMethods.\n+     */\n+    public RequestHandlerMethods() {\n+        handlerMap = new EnumMap<>(RequestPayloadMsg.PayloadCase.class);\n+    }\n+\n+    /**\n+     * Handle an incoming Corfu request message.\n+     *\n+     * @param req       The request message to handle.\n+     * @param ctx       The channel handler context.\n+     * @param r         The server router.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void handle(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final HandlerMethod handler = handlerMap.get(req.getPayload().getPayloadCase());\n+        try {\n+            handler.handle(req, ctx, r);\n+        } catch (Exception e) {\n+            log.error(\"handle[{}]: Unhandled exception processing {} request\",\n+                    req.getHeader().getRequestId(), req.getPayload().getPayloadCase(), e);\n+\n+            HeaderMsg responseHeader = getHeaderMsg(req.getHeader(), false, true);\n+            r.sendResponse(getResponseMsg(responseHeader, getUnknownErrorMsg(e)), ctx);\n+        }\n+    }\n+\n+    /**\n+     * Generate handlers for a particular server.\n+     *\n+     * @param caller    The context that is being used. Call MethodHandles.lookup() to obtain.\n+     * @param server    The object that implements the server.\n+     * @return          New request handlers for caller class.\n+     */\n+    public static RequestHandlerMethods generateHandler(@Nonnull final MethodHandles.Lookup caller,\n+                                                        @NonNull final AbstractServer server) {\n+        RequestHandlerMethods handler = new RequestHandlerMethods();\n+        Arrays.stream(server.getClass().getDeclaredMethods())\n+                .filter(method -> method.isAnnotationPresent(RequestHandler.class))\n+                .forEach(method -> handler.registerMethod(caller, server, method));\n+        return handler;\n+    }\n+\n+    private void registerMethod(@Nonnull final MethodHandles.Lookup caller,\n+                                @Nonnull final AbstractServer server,\n+                                @Nonnull final Method method) {\n+        final RequestHandler annotation = method.getAnnotation(RequestHandler.class);\n+\n+        if (handlerMap.containsKey(annotation.type())) {\n+            throw new UnrecoverableCorfuError(\"HandlerMethod for \" + annotation.type() + \" already registered!\");", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2NDIxNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526364215", "bodyText": "Fixed.", "author": "zfrenette", "createdAt": "2020-11-18T19:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NzQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2OTg1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525569851", "bodyText": "The method looks weird. In what situation, you'd have NPE?", "author": "xnull", "createdAt": "2020-11-17T22:33:59Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -103,10 +110,18 @@ public static LayoutMsg getLayoutMsg(Layout layout) {\n     /**\n      * Returns a Layout object from its Protobuf representation.\n      *\n-     * @param msg   the Protobuf Layout message\n+     * @param msg   the desired Protobuf Layout message\n+     * @return      an equivalent, potentially null, Java Layout object\n+     * @throws      SerializerException if unable to deserialize the JSON payload\n      */\n     public static Layout getLayout(LayoutMsg msg) {\n-        return Layout.fromJSONString(msg.getLayoutJson());\n+        try {\n+            return Layout.fromJSONString(msg.getLayoutJson());\n+        } catch (NullPointerException npe) {", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NjcwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525576704", "bodyText": "There are some cases in the code base that send a null layout. I think @xcchang and I came across this in LayoutServerTest. In the LayoutServer, for example the LAYOUT_PREPARE rpc, the method getProposedLayout can return null. This gets converted into an empty json string I believe.", "author": "zfrenette", "createdAt": "2020-11-17T22:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2OTg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMTM2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525631369", "bodyText": "We found that more than half of the unit tests within LayoutSeverTest will produce a null value for proposedLayout during the RPCs are handling on the server side (prepareRejectsLowerRanks and handleMessageLayoutPrepare for example). In the LayoutSever there are multiple cases that proposedLayout == null ? is checked, so we also added a checking here to keep the current logic.", "author": "xcchang", "createdAt": "2020-11-18T01:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2OTg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0MTI3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525641275", "bodyText": "let's check for null instead of catching NPE", "author": "xnull", "createdAt": "2020-11-18T01:46:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2OTg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTc4MDA0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525780047", "bodyText": "I thought they are equivalent here, since the Layout.fromJSONString has a requireNonNull constraint for the given argument, and that's where the NPE gets thrown.", "author": "xcchang", "createdAt": "2020-11-18T04:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2OTg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MDc0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525570748", "bodyText": "please import org.corfudb.protocols.wireprotocol.PriorityLevel", "author": "xnull", "createdAt": "2020-11-17T22:35:41Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -26,6 +27,16 @@\n     // Prevent class from being instantiated\n     private CorfuProtocolMessage() {}\n \n+    /**\n+     * This type map provides clients with the ability to convert\n+     * between representations of PriorityLevel.\n+     */\n+    public static final EnumMap<org.corfudb.protocols.wireprotocol.PriorityLevel, PriorityLevel> priorityTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    org.corfudb.protocols.wireprotocol.PriorityLevel.NORMAL, PriorityLevel.NORMAL,", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYwODkxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525608918", "bodyText": "Note: this causes a conflict with org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel. I can instead import org.corfudb.runtime.proto.service.CorfuMessage and use CorfuMessage.PriorityLevel.Normal on the other end.", "author": "zfrenette", "createdAt": "2020-11-18T00:10:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MDc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2NDA4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526364087", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-18T19:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MDc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0Mjg4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525642887", "bodyText": "why not return boolean? Why object?", "author": "xnull", "createdAt": "2020-11-18T01:51:47Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/BaseHandler.java", "diffHunk": "@@ -137,26 +114,196 @@ private static Object handleNotReady(CorfuMsg msg, ChannelHandlerContext ctx, IC\n      * Generic handler for a server exception.\n      */\n     @ClientHandler(type = CorfuMsgType.ERROR_SERVER_EXCEPTION)\n+    @Deprecated\n     private static Object handleServerException(CorfuPayloadMsg<ExceptionMsg> msg,\n-                                                ChannelHandlerContext ctx, IClientRouter r)\n-            throws Throwable {\n+                                                ChannelHandlerContext ctx, IClientRouter r) throws Throwable {\n         log.warn(\"Server threw exception for request {}\", msg.getRequestID(),\n                 msg.getPayload().getThrowable());\n         throw msg.getPayload().getThrowable();\n     }\n \n     /**\n      * Handle a wrong cluster id exception.\n+     *\n      * @param msg Wrong cluster id exception message.\n      * @param ctx A context the message was sent under.\n-     * @param r A reference to the router.\n+     * @param r   A reference to the router.\n      * @return None, throw a wrong cluster id exception.\n      */\n     @ClientHandler(type = CorfuMsgType.WRONG_CLUSTER_ID)\n+    @Deprecated\n     private static Object handleWrongClusterId(CorfuPayloadMsg<WrongClusterMsg> msg,\n                                                ChannelHandlerContext ctx, IClientRouter r) {\n         WrongClusterMsg wrongClusterMessage = msg.getPayload();\n         throw new WrongClusterException(wrongClusterMessage.getServerClusterId(),\n                 wrongClusterMessage.getClientClusterId());\n     }\n+\n+    // Protobuf region\n+\n+    /**\n+     * Handle a ping response from the server.\n+     *\n+     * @param msg The ping response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router\n+     * @return Always True, since the ping message was successful.\n+     */\n+    @ResponseHandler(type = PayloadCase.PING_RESPONSE)\n+    private static Object handlePingResponse(ResponseMsg msg, ChannelHandlerContext ctx, IClientRouter r) {", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3MTk1NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526171954", "bodyText": "As implemented, all of the client handler methods have to match the functional interface defined in ClientResponseHandler. Having varying return types would complicate the reflection that occurs in the generateHandlers method. This is very similar to what we have in RequestHandlerMethods for the server, except that the return type is void.", "author": "zfrenette", "createdAt": "2020-11-18T15:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0Mjg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0MzM3NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r525643374", "bodyText": "==", "author": "xnull", "createdAt": "2020-11-18T01:53:23Z", "path": "runtime/src/main/java/org/corfudb/runtime/clients/ClientResponseHandler.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg.PayloadCase;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg.ErrorCase;\n+\n+/**\n+ * Invokes the message handler to handle Protobuf responses from server.\n+ */\n+@Slf4j\n+public class ClientResponseHandler {\n+\n+    @FunctionalInterface\n+    public interface Handler {\n+        Object handle(ResponseMsg msg, ChannelHandlerContext ctx, IClientRouter r) throws Exception;\n+    }\n+\n+    /**\n+     * The handler map for normal ResponseMsg.\n+     */\n+    private final Map<PayloadCase, Handler> handlerMap;\n+\n+    /**\n+     * The handler map for ServerErrorMsg.\n+     */\n+    private final Map<ErrorCase, Handler> errorHandlerMap;\n+\n+    /**\n+     * The client.\n+     */\n+    private final IClient client;\n+\n+    /**\n+     * Construct a new instance of ClientResponseHandler.\n+     *\n+     * @param client The client that this ClientResponseHandler will register.\n+     */\n+    public ClientResponseHandler(IClient client) {\n+        this.client = client;\n+        this.handlerMap = new ConcurrentHashMap<>();\n+        this.errorHandlerMap = new ConcurrentHashMap<>();\n+    }\n+\n+    /**\n+     * Handle an incoming Response from server.\n+     *\n+     * @param response The Response to handle.\n+     * @param ctx The channel handler context.\n+     * @return True if the message was handled successfully.\n+     */\n+    public boolean handle(ResponseMsg response, ChannelHandlerContext ctx) {\n+        IClientRouter router = client.getRouter();\n+        final long requestId = response.getHeader().getRequestId();\n+        PayloadCase payloadCase = response.getPayload().getPayloadCase();\n+\n+        if (payloadCase.equals(PayloadCase.SERVER_ERROR)) {", "originalCommit": "fe64b4a913666532b41c2e80e298d6d50862a7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2MzkwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r526363900", "bodyText": "Fixed.", "author": "zfrenette", "createdAt": "2020-11-18T19:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0MzM3NA=="}], "type": "inlineReview"}, {"oid": "f916ba526551938447d6b2465f0e49a2c7a6b751", "url": "https://github.com/CorfuDB/CorfuDB/commit/f916ba526551938447d6b2465f0e49a2c7a6b751", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-18T19:28:35Z", "type": "forcePushed"}, {"oid": "668b0b24e2910b7d18c0c65d2584dbd3983f229f", "url": "https://github.com/CorfuDB/CorfuDB/commit/668b0b24e2910b7d18c0c65d2584dbd3983f229f", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-18T19:34:03Z", "type": "forcePushed"}, {"oid": "9b8a2f9aa5ee2a614dd8ba2d5c730070e4e8899a", "url": "https://github.com/CorfuDB/CorfuDB/commit/9b8a2f9aa5ee2a614dd8ba2d5c730070e4e8899a", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-18T21:58:58Z", "type": "forcePushed"}, {"oid": "93cc2141ce4f9a31eb6acf430c92f58fd68806ff", "url": "https://github.com/CorfuDB/CorfuDB/commit/93cc2141ce4f9a31eb6acf430c92f58fd68806ff", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-19T18:28:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0MDY5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2812#discussion_r527140690", "bodyText": "@xnull As we discussed, I have removed the outer try-catch block.", "author": "zfrenette", "createdAt": "2020-11-19T19:24:35Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/NettyServerRouter.java", "diffHunk": "@@ -114,20 +148,19 @@ public void sendResponse(ChannelHandlerContext ctx, CorfuMsg inMsg, CorfuMsg out\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object msg) {\n-        try {", "originalCommit": "93cc2141ce4f9a31eb6acf430c92f58fd68806ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6c8e40a543b8d550becc50cafee92c7561541682", "url": "https://github.com/CorfuDB/CorfuDB/commit/6c8e40a543b8d550becc50cafee92c7561541682", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-19T22:30:11Z", "type": "commit"}, {"oid": "6c8e40a543b8d550becc50cafee92c7561541682", "url": "https://github.com/CorfuDB/CorfuDB/commit/6c8e40a543b8d550becc50cafee92c7561541682", "message": "Add Implementation of Base RPCs using Protobuf\n\nProvides routing support for Protobuf messages and an implementation\nof Base RPCs using Protobuf. Done as part of an effort to support\nrolling upgrades.", "committedDate": "2020-11-19T22:30:11Z", "type": "forcePushed"}]}