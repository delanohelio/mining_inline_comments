{"pr_number": 2783, "pr_title": "Internal Backup/Restore implementation", "pr_createdAt": "2020-10-07T22:55:13Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2783", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODI3Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048272", "bodyText": "Codacy found an issue: Perhaps 'sourceServer' could be replaced by a local variable.", "author": "corfudb-bot", "createdAt": "2020-10-12T05:36:59Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.runtime.collections.CorfuRecord;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.Query;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.collections.TxBuilder;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+\n+import org.corfudb.test.SampleSchema.Uuid;\n+\n+/**\n+ * Test the Corfu native backup and restore functionalities. Overall the tests bring up two CorfuServers,\n+ * one used as source server which is backed up, and the other as destination server which restores the data\n+ * using the backup file generated from the source server.\n+ */\n+@Slf4j\n+public class BackupRestoreIT extends AbstractIT {\n+\n+    final static public int numEntries = 1000;\n+    final static public int valSize = 20000;\n+    static final public int numTables = 5;\n+    static final String NAMESPACE = \"test_namespace\";\n+    static final String backupTable = \"test_table\";\n+\n+    static final String DEFAULT_HOST = \"localhost\";\n+    static final int DEFAULT_PORT = 9000;\n+    private static final int WRITER_PORT = DEFAULT_PORT + 1;\n+    private static final String SOURCE_ENDPOINT = DEFAULT_HOST + \":\" + DEFAULT_PORT;\n+    private static final String DESTINATION_ENDPOINT = DEFAULT_HOST + \":\" + WRITER_PORT;\n+\n+    // Log path of source server\n+    static final String LOG_PATH1 = getCorfuServerLogPath(DEFAULT_HOST, DEFAULT_PORT);\n+\n+    // Location where the backup tar file is stored\n+     static final String BACKUP_TAR_FILE_PATH = new File(LOG_PATH1).getParent() + File.separator + \"backup.tar\";\n+\n+    private Process sourceServer;", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODI3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048279", "bodyText": "Codacy found an issue: Avoid unused private fields such as 'destinationServer'.", "author": "corfudb-bot", "createdAt": "2020-10-12T05:37:00Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.runtime.collections.CorfuRecord;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.Query;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.collections.TxBuilder;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+\n+import org.corfudb.test.SampleSchema.Uuid;\n+\n+/**\n+ * Test the Corfu native backup and restore functionalities. Overall the tests bring up two CorfuServers,\n+ * one used as source server which is backed up, and the other as destination server which restores the data\n+ * using the backup file generated from the source server.\n+ */\n+@Slf4j\n+public class BackupRestoreIT extends AbstractIT {\n+\n+    final static public int numEntries = 1000;\n+    final static public int valSize = 20000;\n+    static final public int numTables = 5;\n+    static final String NAMESPACE = \"test_namespace\";\n+    static final String backupTable = \"test_table\";\n+\n+    static final String DEFAULT_HOST = \"localhost\";\n+    static final int DEFAULT_PORT = 9000;\n+    private static final int WRITER_PORT = DEFAULT_PORT + 1;\n+    private static final String SOURCE_ENDPOINT = DEFAULT_HOST + \":\" + DEFAULT_PORT;\n+    private static final String DESTINATION_ENDPOINT = DEFAULT_HOST + \":\" + WRITER_PORT;\n+\n+    // Log path of source server\n+    static final String LOG_PATH1 = getCorfuServerLogPath(DEFAULT_HOST, DEFAULT_PORT);\n+\n+    // Location where the backup tar file is stored\n+     static final String BACKUP_TAR_FILE_PATH = new File(LOG_PATH1).getParent() + File.separator + \"backup.tar\";\n+\n+    private Process sourceServer;\n+    private Process destinationServer;", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODI5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048296", "bodyText": "Codacy found an issue: Use explicit scoping instead of the default package private level", "author": "corfudb-bot", "createdAt": "2020-10-12T05:37:03Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.runtime.collections.CorfuRecord;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.Query;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.collections.TxBuilder;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+\n+import org.corfudb.test.SampleSchema.Uuid;\n+\n+/**\n+ * Test the Corfu native backup and restore functionalities. Overall the tests bring up two CorfuServers,\n+ * one used as source server which is backed up, and the other as destination server which restores the data\n+ * using the backup file generated from the source server.\n+ */\n+@Slf4j\n+public class BackupRestoreIT extends AbstractIT {\n+\n+    final static public int numEntries = 1000;\n+    final static public int valSize = 20000;\n+    static final public int numTables = 5;\n+    static final String NAMESPACE = \"test_namespace\";\n+    static final String backupTable = \"test_table\";\n+\n+    static final String DEFAULT_HOST = \"localhost\";\n+    static final int DEFAULT_PORT = 9000;\n+    private static final int WRITER_PORT = DEFAULT_PORT + 1;\n+    private static final String SOURCE_ENDPOINT = DEFAULT_HOST + \":\" + DEFAULT_PORT;\n+    private static final String DESTINATION_ENDPOINT = DEFAULT_HOST + \":\" + WRITER_PORT;\n+\n+    // Log path of source server\n+    static final String LOG_PATH1 = getCorfuServerLogPath(DEFAULT_HOST, DEFAULT_PORT);\n+\n+    // Location where the backup tar file is stored\n+     static final String BACKUP_TAR_FILE_PATH = new File(LOG_PATH1).getParent() + File.separator + \"backup.tar\";", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODMwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048300", "bodyText": "Codacy found an issue: Avoid really long methods.", "author": "corfudb-bot", "createdAt": "2020-10-12T05:37:04Z", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -597,6 +737,162 @@ public void testNewConfigWithInvalidClusters() throws Exception {\n         assertThat(mapStandby.size()).isEqualTo(thirdBatch);\n     }\n \n+    private Table<LogReplicationMetadataKey, LogReplicationMetadataVal, LogReplicationMetadataVal> getMetadataTable(CorfuRuntime runtime) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        CorfuStore corfuStore = new CorfuStore(runtime);\n+        CorfuStoreMetadata.TableName metadataTableName = null;\n+        Table<LogReplicationMetadataKey, LogReplicationMetadataVal, LogReplicationMetadataVal> metadataTable = null;\n+\n+        for (CorfuStoreMetadata.TableName name : corfuStore.listTables(LogReplicationMetadataManager.NAMESPACE)){\n+            if(name.getTableName().contains(LogReplicationMetadataManager.METADATA_TABLE_PREFIX_NAME)) {\n+                metadataTableName = name;\n+            }\n+        }\n+\n+        metadataTable = corfuStore.openTable(\n+                    LogReplicationMetadataManager.NAMESPACE,\n+                    metadataTableName.getTableName(),\n+                    LogReplicationMetadataKey.class,\n+                    LogReplicationMetadataVal.class,\n+                    null,\n+                    TableOptions.builder().build());\n+\n+        return metadataTable;\n+    }\n+\n+\n+    /**\n+     * This test verifies enforceSnapshotSync API\n+     * <p>\n+     * 1. Init with corfu 9000 active and 9001 standby\n+     * 2. Write 10 entries to active map\n+     * 3. Start log replication: Node 9010 - active, Node 9020 - standby\n+     * 4. Wait for Snapshot Sync, both maps have size 10\n+     * 5. Write 5 more entries to active map, to verify Log Entry Sync\n+     * 6. Write 5 more entries to active map and perform an enforced full snapshot sync\n+     * 7. Verify a full snapshot sync is triggered\n+     * 8. Verify a full snapshot sync is completed and data is correctly replicated.\n+     */\n+    @Test\n+    public void testEnforceSnapshotSync() throws Exception {", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODMwNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048305", "bodyText": "Codacy found an issue: Perhaps 'runtime' could be replaced by a local variable.", "author": "corfudb-bot", "createdAt": "2020-10-12T05:37:05Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxBuilder;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.*;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Runtime which is performing the restore\n+    private CorfuRuntime runtime;", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODMxMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048312", "bodyText": "Codacy found an issue: Use explicit scoping instead of the default package private level", "author": "corfudb-bot", "createdAt": "2020-10-12T05:37:06Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.runtime.collections.CorfuRecord;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.Query;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.collections.TxBuilder;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+\n+import org.corfudb.test.SampleSchema.Uuid;\n+\n+/**\n+ * Test the Corfu native backup and restore functionalities. Overall the tests bring up two CorfuServers,\n+ * one used as source server which is backed up, and the other as destination server which restores the data\n+ * using the backup file generated from the source server.\n+ */\n+@Slf4j\n+public class BackupRestoreIT extends AbstractIT {\n+\n+    final static public int numEntries = 1000;\n+    final static public int valSize = 20000;\n+    static final public int numTables = 5;\n+    static final String NAMESPACE = \"test_namespace\";\n+    static final String backupTable = \"test_table\";\n+\n+    static final String DEFAULT_HOST = \"localhost\";\n+    static final int DEFAULT_PORT = 9000;\n+    private static final int WRITER_PORT = DEFAULT_PORT + 1;\n+    private static final String SOURCE_ENDPOINT = DEFAULT_HOST + \":\" + DEFAULT_PORT;\n+    private static final String DESTINATION_ENDPOINT = DEFAULT_HOST + \":\" + WRITER_PORT;\n+\n+    // Log path of source server\n+    static final String LOG_PATH1 = getCorfuServerLogPath(DEFAULT_HOST, DEFAULT_PORT);", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODMxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048317", "bodyText": "Codacy found an issue: Use explicit scoping instead of the default package private level", "author": "corfudb-bot", "createdAt": "2020-10-12T05:37:07Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.runtime.collections.CorfuRecord;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.Query;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.collections.TxBuilder;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+\n+import org.corfudb.test.SampleSchema.Uuid;\n+\n+/**\n+ * Test the Corfu native backup and restore functionalities. Overall the tests bring up two CorfuServers,\n+ * one used as source server which is backed up, and the other as destination server which restores the data\n+ * using the backup file generated from the source server.\n+ */\n+@Slf4j\n+public class BackupRestoreIT extends AbstractIT {\n+\n+    final static public int numEntries = 1000;\n+    final static public int valSize = 20000;\n+    static final public int numTables = 5;\n+    static final String NAMESPACE = \"test_namespace\";", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODMyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048326", "bodyText": "Codacy found an issue: Use explicit scoping instead of the default package private level", "author": "corfudb-bot", "createdAt": "2020-10-12T05:37:09Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.runtime.collections.CorfuRecord;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.Query;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.collections.TxBuilder;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+\n+import org.corfudb.test.SampleSchema.Uuid;\n+\n+/**\n+ * Test the Corfu native backup and restore functionalities. Overall the tests bring up two CorfuServers,\n+ * one used as source server which is backed up, and the other as destination server which restores the data\n+ * using the backup file generated from the source server.\n+ */\n+@Slf4j\n+public class BackupRestoreIT extends AbstractIT {\n+\n+    final static public int numEntries = 1000;\n+    final static public int valSize = 20000;\n+    static final public int numTables = 5;\n+    static final String NAMESPACE = \"test_namespace\";\n+    static final String backupTable = \"test_table\";\n+\n+    static final String DEFAULT_HOST = \"localhost\";\n+    static final int DEFAULT_PORT = 9000;", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODMzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048332", "bodyText": "Codacy found an issue: Use explicit scoping instead of the default package private level", "author": "corfudb-bot", "createdAt": "2020-10-12T05:37:09Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.runtime.collections.CorfuRecord;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.Query;\n+import org.corfudb.runtime.collections.TableOptions;\n+import org.corfudb.runtime.collections.TxBuilder;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+\n+import org.corfudb.test.SampleSchema.Uuid;\n+\n+/**\n+ * Test the Corfu native backup and restore functionalities. Overall the tests bring up two CorfuServers,\n+ * one used as source server which is backed up, and the other as destination server which restores the data\n+ * using the backup file generated from the source server.\n+ */\n+@Slf4j\n+public class BackupRestoreIT extends AbstractIT {\n+\n+    final static public int numEntries = 1000;\n+    final static public int valSize = 20000;\n+    static final public int numTables = 5;\n+    static final String NAMESPACE = \"test_namespace\";\n+    static final String backupTable = \"test_table\";", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODMzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048333", "bodyText": "Codacy found an issue: The utility class name 'Utility' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "author": "corfudb-bot", "createdAt": "2020-10-12T05:37:10Z", "path": "runtime/src/main/java/org/corfudb/protocols/logprotocol/Utility.java", "diffHunk": "@@ -1,13 +1,12 @@\n-package org.corfudb.infrastructure.logreplication.replication.send.logreader;\n+package org.corfudb.protocols.logprotocol;\n \n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-\n import java.util.List;\n \n @Slf4j\n-public class ReaderUtility {\n+public class Utility {", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODMzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r503048335", "bodyText": "Codacy found an issue: Use explicit scoping instead of the default package private level", "author": "corfudb-bot", "createdAt": "2020-10-12T05:37:11Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "diffHunk": "@@ -360,6 +362,10 @@ void addToWriteSet(UUID streamId, SMREntry updateEntry) {\n         getWriteSetInfo().add(streamId, updateEntry);\n     }\n \n+    void addToWriteSet(UUID streamId, List<SMREntry> updateEntries) {", "originalCommit": "e512b5c7ba0c2155466161fbb5bcff6f53825adb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0OTYyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538949625", "bodyText": "please address comments from codacy", "author": "annym", "createdAt": "2020-12-09T02:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA0ODMzNQ=="}], "type": "inlineReview"}, {"oid": "de09afa9a42676e5e4784093bc603a5cf6aa9a28", "url": "https://github.com/CorfuDB/CorfuDB/commit/de09afa9a42676e5e4784093bc603a5cf6aa9a28", "message": "1. Change temp dir location\n2. Remove runtime and streamId as arguments\n3. Add some comments", "committedDate": "2020-10-10T01:31:38Z", "type": "forcePushed"}, {"oid": "d2377cd6775fa2de9ad0da68b559b0d5c9b6edee", "url": "https://github.com/CorfuDB/CorfuDB/commit/d2377cd6775fa2de9ad0da68b559b0d5c9b6edee", "message": "Corfu Native Backup and Restore\n\nAdd backup/restore one table API.\nSome cleanup.\nOptimize backup.\n   * Implement the test with IT.\nFix some errors.\nUsing fileInput/fileOutput API.\noptimize br test\nmerge table backups to a single tar file\nAdd backup clean()\nBackup/Restore multiple tables; Some tests.\nAdd fields in Backup and Restore classes to represent file locations.\nRefactor and clean up code.\n1. Change temp dir location\n2. Remove runtime and streamId as arguments\n3. Add some comments\nFix corfudb-bot warnings", "committedDate": "2020-10-12T17:40:06Z", "type": "forcePushed"}, {"oid": "4f52594c5dddabc46f9b43f05b3aad3195ada3e8", "url": "https://github.com/CorfuDB/CorfuDB/commit/4f52594c5dddabc46f9b43f05b3aad3195ada3e8", "message": "Corfu Native Backup and Restore\n\nAdd backup/restore one table API.\nSome cleanup.\nOptimize backup.\n   * Implement the test with IT.\nFix some errors.\nUsing fileInput/fileOutput API.\noptimize br test\nmerge table backups to a single tar file\nAdd backup clean()\nBackup/Restore multiple tables; Some tests.\nAdd fields in Backup and Restore classes to represent file locations.\nRefactor and clean up code.\n1. Change temp dir location\n2. Remove runtime and streamId as arguments\n3. Add some comments\nFix corfudb-bot warnings\nClean up test env.", "committedDate": "2020-10-13T21:08:51Z", "type": "forcePushed"}, {"oid": "aa975f62da035093365f302f34a7f7d6fbbba33a", "url": "https://github.com/CorfuDB/CorfuDB/commit/aa975f62da035093365f302f34a7f7d6fbbba33a", "message": "Corfu Native Backup and Restore\n\nAdd backup/restore one table API.\nSome cleanup.\nOptimize backup.\n   * Implement the test with IT.\nFix some errors.\nUsing fileInput/fileOutput API.\noptimize br test\nmerge table backups to a single tar file\nAdd backup clean()\nBackup/Restore multiple tables; Some tests.\nAdd fields in Backup and Restore classes to represent file locations.\nRefactor and clean up code.\n1. Change temp dir location\n2. Remove runtime and streamId as arguments\n3. Add some comments\nFix corfudb-bot warnings\nClean up test env.", "committedDate": "2020-10-13T21:23:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI2OTIzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r504269235", "bodyText": "Codacy found an issue: The utility class name 'Utility' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "author": "corfudb-bot", "createdAt": "2020-10-13T21:28:53Z", "path": "runtime/src/main/java/org/corfudb/protocols/logprotocol/Utility.java", "diffHunk": "@@ -1,13 +1,12 @@\n-package org.corfudb.infrastructure.logreplication.replication.send.logreader;\n+package org.corfudb.protocols.logprotocol;\n \n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.protocols.logprotocol.OpaqueEntry;\n import org.corfudb.protocols.logprotocol.SMREntry;\n-\n import java.util.List;\n \n @Slf4j\n-public class ReaderUtility {\n+public class Utility {", "originalCommit": "aa975f62da035093365f302f34a7f7d6fbbba33a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI2OTI0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r504269242", "bodyText": "Codacy found an issue: Use explicit scoping instead of the default package private level", "author": "corfudb-bot", "createdAt": "2020-10-13T21:28:54Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "diffHunk": "@@ -360,6 +362,10 @@ void addToWriteSet(UUID streamId, SMREntry updateEntry) {\n         getWriteSetInfo().add(streamId, updateEntry);\n     }\n \n+    void addToWriteSet(UUID streamId, List<SMREntry> updateEntries) {", "originalCommit": "aa975f62da035093365f302f34a7f7d6fbbba33a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk4ODA2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r504988061", "bodyText": "If the* log is trimmed", "author": "hisundar", "createdAt": "2020-10-14T21:40:26Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.exceptions.TrimmedException;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private final long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+    }\n+\n+    public boolean start() throws IOException {\n+        if (!backup()) {\n+            cleanup();\n+            return false;\n+        }\n+\n+        generateTarFile();\n+        cleanup();\n+        return true;\n+    }\n+\n+    /**\n+     * All temp backupTable files will be put at BACKUP_DIR_PATH directory.\n+     * @return\n+     */\n+    private boolean backup() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            if (!backupTable(fileName, streamId)) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * If th log is trimmed at timestamp, the backupTable will fail.", "originalCommit": "aa975f62da035093365f302f34a7f7d6fbbba33a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk4MjIxMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r532982210", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-11-30T23:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk4ODA2MQ=="}], "type": "inlineReview"}, {"oid": "49e26108578146b27327aa684562f638c433c086", "url": "https://github.com/CorfuDB/CorfuDB/commit/49e26108578146b27327aa684562f638c433c086", "message": "Backup and Restore", "committedDate": "2020-11-25T04:02:06Z", "type": "forcePushed"}, {"oid": "804bde0adb0eb4891be1fc22e932b7ca54dc9a52", "url": "https://github.com/CorfuDB/CorfuDB/commit/804bde0adb0eb4891be1fc22e932b7ca54dc9a52", "message": "Backup and Restore", "committedDate": "2020-11-25T04:15:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1MjY3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r535852673", "bodyText": "It would be better to use try-with-resources or close it in a finally block.", "author": "zhangn49", "createdAt": "2020-12-04T05:49:24Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private final long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which requires back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    public boolean start() throws IOException {\n+        if (!backup()) {\n+            cleanup();\n+            return false;\n+        }\n+\n+        generateTarFile();\n+        cleanup();\n+        return true;\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     * @return true if backup succeeded\n+     */\n+    private boolean backup() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            if (!backupTable(fileName, streamId)) {\n+                log.error(\"failed to back up table {} to {} temp file\", streamId, fileName);\n+                return false;\n+            }\n+        }\n+        log.debug(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+        return true;\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.\n+     * If the table has no data to backupTable, it will create a file with empty contents.\n+     */\n+    private boolean backupTable(String fileName, UUID uuid) throws IOException {\n+        FileOutputStream fileOutput = null;\n+        try {\n+            fileOutput = new FileOutputStream(fileName);", "originalCommit": "730b605625dae8ce05095cc6dcef8d87ea5fbd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwMjE1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r535902156", "bodyText": "Modified to use try-with-resources. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-04T07:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1MjY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1NDc5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r535854790", "bodyText": "Same here", "author": "zhangn49", "createdAt": "2020-12-04T05:55:50Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private final long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which requires back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    public boolean start() throws IOException {\n+        if (!backup()) {\n+            cleanup();\n+            return false;\n+        }\n+\n+        generateTarFile();\n+        cleanup();\n+        return true;\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     * @return true if backup succeeded\n+     */\n+    private boolean backup() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            if (!backupTable(fileName, streamId)) {\n+                log.error(\"failed to back up table {} to {} temp file\", streamId, fileName);\n+                return false;\n+            }\n+        }\n+        log.debug(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+        return true;\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.\n+     * If the table has no data to backupTable, it will create a file with empty contents.\n+     */\n+    private boolean backupTable(String fileName, UUID uuid) throws IOException {\n+        FileOutputStream fileOutput = null;\n+        try {\n+            fileOutput = new FileOutputStream(fileName);\n+        } catch (FileNotFoundException e) {\n+            log.error(\"failed to create the temp file {} for table {}\", fileName, uuid);\n+            return false;\n+        }\n+        StreamOptions options = StreamOptions.builder()\n+                .ignoreTrimmed(false)\n+                .cacheEntries(false)\n+                .build();\n+\n+        Stream<OpaqueEntry> stream = (new OpaqueStream(runtime, runtime.getStreamsView().get(uuid, options))).streamUpTo(timestamp);\n+        Iterator<OpaqueEntry> iterator = stream.iterator();\n+\n+        try {\n+            while (iterator.hasNext()) {\n+                OpaqueEntry lastEntry = iterator.next();\n+                List<SMREntry> smrEntries = lastEntry.getEntries().get(uuid);\n+                if (smrEntries != null) {\n+                    Map<UUID, List<SMREntry>> map = new HashMap<>();\n+                    map.put(uuid, smrEntries);\n+                    OpaqueEntry newOpaqueEntry = new OpaqueEntry(lastEntry.getVersion(), map);\n+                    OpaqueEntry.write(fileOutput, newOpaqueEntry);\n+                }\n+            }\n+\n+            fileOutput.flush();\n+            fileOutput.close();\n+        } catch (IOException e) {\n+            log.error(\"failed to write the table {} to temp backup file {}\", uuid, fileName);\n+            return false;\n+        }\n+\n+        log.debug(\"{} table is backed up and stored to temp file {}\", uuid, fileName);\n+        return true;\n+    }\n+\n+    /**\n+     * All generated files under tmp directory will be composed into one tar file\n+     */\n+    private void generateTarFile() throws IOException {\n+        File folder = new File(backupTempDirPath);\n+        File[] srcFiles = folder.listFiles();\n+\n+        FileOutputStream fileOutput;\n+        TarArchiveOutputStream tarOutput;\n+        try {\n+            fileOutput = new FileOutputStream(filePath);\n+            tarOutput = new TarArchiveOutputStream(fileOutput);", "originalCommit": "730b605625dae8ce05095cc6dcef8d87ea5fbd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNjAyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r535926025", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-04T08:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1NDc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxNjQwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r536316402", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-04T19:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1NDc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1NTYyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r535855628", "bodyText": "Would be nice if we can have some logs here", "author": "zhangn49", "createdAt": "2020-12-04T05:58:05Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.*;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    public boolean start() throws IOException {\n+        File backupTarFile = new File(filePath);\n+        if (!backupTarFile.exists()) {\n+            return false;\n+        }\n+\n+        openTarFile();\n+\n+        if (!verify()) {\n+            return false;\n+        }\n+\n+        if (!restore()) {\n+            cleanup();\n+            return false;\n+        }\n+\n+        cleanup();\n+        return true;\n+    }", "originalCommit": "730b605625dae8ce05095cc6dcef8d87ea5fbd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0Njk1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r536346958", "bodyText": "Done", "author": "Lujie1996", "createdAt": "2020-12-04T19:59:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1NTYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1Nzg5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r535857890", "bodyText": "Should this line be outside of the while loop?", "author": "zhangn49", "createdAt": "2020-12-04T06:05:00Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.*;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    public boolean start() throws IOException {\n+        File backupTarFile = new File(filePath);\n+        if (!backupTarFile.exists()) {\n+            return false;\n+        }\n+\n+        openTarFile();\n+\n+        if (!verify()) {\n+            return false;\n+        }\n+\n+        if (!restore()) {\n+            cleanup();\n+            return false;\n+        }\n+\n+        cleanup();\n+        return true;\n+    }\n+\n+    private boolean restore() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = restoreTempDirPath + File.separator + streamId;\n+            if (!restoreTable(fileName, streamId)) {\n+                log.error(\"Failed to restore table {} from temp file {}\", streamId, fileName);\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Restore a single table\n+     * @param fileName   - the name of the temp backup file\n+     * @param streamId   - the stream ID of the table which is to be restored\n+     * @return true if restore succeeded\n+     * @throws IOException when 1) backup file is not found or 2) failed to read file\n+     */\n+    private boolean restoreTable(String fileName, UUID streamId) throws IOException {\n+        FileInputStream fileInput = null;\n+        try {\n+            fileInput = new FileInputStream(fileName);\n+        } catch (FileNotFoundException e) {\n+            log.error(\"restoreTable can not find file {}\", fileName);\n+            return false;\n+        }\n+        long numEntries = 0;\n+\n+        // Clear table before restore\n+        TxnContext txn = corfuStore.txn(CORFU_SYSTEM_NAMESPACE);\n+        SMREntry entry = new SMREntry(\"clear\", new Array[0], Serializers.PRIMITIVE);\n+        txn.logUpdate(streamId, entry);\n+\n+        // For each opaque entry, write a transaction to the database.\n+        try {\n+            while (fileInput.available()> 0) {\n+                OpaqueEntry opaqueEntry = OpaqueEntry.read(fileInput);\n+                List<SMREntry> smrEntries = opaqueEntry.getEntries().get(streamId);\n+                if (smrEntries == null || smrEntries.isEmpty()) {\n+                    continue;\n+                }\n+\n+                txn.logUpdate(streamId, smrEntries);\n+                numEntries++;\n+                log.debug(\"write uuid {} with {} numEntries\", streamId, numEntries);", "originalCommit": "730b605625dae8ce05095cc6dcef8d87ea5fbd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxOTQxOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r536319419", "bodyText": "Done.", "author": "Lujie1996", "createdAt": "2020-12-04T19:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1Nzg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1ODE1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r535858156", "bodyText": "IOException is not thrown by this function.", "author": "zhangn49", "createdAt": "2020-12-04T06:05:45Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.*;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    public boolean start() throws IOException {\n+        File backupTarFile = new File(filePath);\n+        if (!backupTarFile.exists()) {\n+            return false;\n+        }\n+\n+        openTarFile();\n+\n+        if (!verify()) {\n+            return false;\n+        }\n+\n+        if (!restore()) {\n+            cleanup();\n+            return false;\n+        }\n+\n+        cleanup();\n+        return true;\n+    }\n+\n+    private boolean restore() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = restoreTempDirPath + File.separator + streamId;\n+            if (!restoreTable(fileName, streamId)) {\n+                log.error(\"Failed to restore table {} from temp file {}\", streamId, fileName);\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Restore a single table\n+     * @param fileName   - the name of the temp backup file\n+     * @param streamId   - the stream ID of the table which is to be restored\n+     * @return true if restore succeeded\n+     * @throws IOException when 1) backup file is not found or 2) failed to read file\n+     */\n+    private boolean restoreTable(String fileName, UUID streamId) throws IOException {", "originalCommit": "730b605625dae8ce05095cc6dcef8d87ea5fbd25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1OTE5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r535859194", "bodyText": "Javadoc comment for public method", "author": "zhangn49", "createdAt": "2020-12-04T06:08:47Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "diffHunk": "@@ -263,6 +263,8 @@ public void syncWithRetryUnsafe(VersionLockedObject vlo,\n \n     public abstract void logUpdate(UUID streamId, SMREntry updateEntry);\n \n+    public abstract void logUpdate(UUID streamId, List<SMREntry> updateEntries);", "originalCommit": "730b605625dae8ce05095cc6dcef8d87ea5fbd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzMDUwOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r536330508", "bodyText": "Done.", "author": "Lujie1996", "createdAt": "2020-12-04T19:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1OTE5NA=="}], "type": "inlineReview"}, {"oid": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "url": "https://github.com/CorfuDB/CorfuDB/commit/bc91ce54685b139e8c85389285f1583a64bf9bf7", "message": "Rewrite using try-with-resource", "committedDate": "2020-12-04T19:46:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NTc4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538955780", "bodyText": "Can we add some class description, with a brief description on how backup and restore works... if it's based on file-based backup, all tables or selective.. etc. where is this data placed, format?, location... how is it restored, running a script, specifying the file path, etc..", "author": "annym", "createdAt": "2020-12-09T02:25:08Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class Backup {", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0MDQxMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539640410", "bodyText": "Added class description to both Backup and Restore. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-09T20:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NTc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MjQwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538962407", "bodyText": "requires -> require", "author": "annym", "createdAt": "2020-12-09T02:43:30Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private final long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which requires back up from their tags.", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0MDU4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539640585", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-09T20:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MjQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MjYyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538962620", "bodyText": "should we add a check if streamIDs is empty, and print a warning?", "author": "annym", "createdAt": "2020-12-09T02:44:12Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private final long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0NDE0Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539644143", "bodyText": "Added a check in backup():\nif (streamIDs.isEmpty()) {\n     log.warn(\"back up is called with empty streamIDs!\");\n}", "author": "Lujie1996", "createdAt": "2020-12-09T21:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MjYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NDI4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538964283", "bodyText": "in the workflow, could it be that there is a long time between the moment Backup is instantiated and backup actually started? I'm just wondering if it makes more sense to get the backup timestamp at the time of start() instead.", "author": "annym", "createdAt": "2020-12-09T02:48:58Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private final long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0NDcyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539644727", "bodyText": "Good point. I moved the this.timestamp = runtime.getAddressSpaceView().getLogTail(); to method start().", "author": "Lujie1996", "createdAt": "2020-12-09T21:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NDI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NTMwOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538965308", "bodyText": "if this throws a TrimmedException, do we want to stop and crash all backup, or print the error and backup the ones that don't have issues? not saying if it's correct or not, just making sure which is the behavior that we want.", "author": "annym", "createdAt": "2020-12-09T02:51:47Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private final long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which requires back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    /**\n+     * Start the backup process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            backup();\n+            generateTarFile();\n+        } catch (IOException e) {\n+            log.debug(\"failed to backup tables: {}\", streamIDs);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.debug(\"backup completed\");\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     *\n+     * @throws IOException\n+     */\n+    private void backup() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            backupTable(fileName, streamId);\n+        }\n+        log.debug(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.\n+     * If the table has no data to backupTable, it will create a file with empty contents.\n+     *\n+     * @param fileName   - the name of the backup file\n+     * @param uuid       - the uuid of the table which is being backed up\n+     * @throws IOException\n+     */\n+    private void backupTable(String fileName, UUID uuid) throws IOException {\n+        try (FileOutputStream fileOutput = new FileOutputStream(fileName)) {\n+            StreamOptions options = StreamOptions.builder()\n+                    .ignoreTrimmed(false)\n+                    .cacheEntries(false)\n+                    .build();\n+            Stream<OpaqueEntry> stream = (new OpaqueStream(runtime, runtime.getStreamsView().get(uuid, options))).streamUpTo(timestamp);", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1OTA5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539659092", "bodyText": "Good point. I thinking failing the whole backup would be easier for users to implement some retry mechanism. We don't want users to say backup 6 in 10 tables (because the other 4 failed) and backup the remaining 4 tables in a second run, and then merge the two tar files. I understand your point is that if some tables failed at least we don't lose other successful backups. I think we need some comments from Graham to see how they want to handle this exception.", "author": "Lujie1996", "createdAt": "2020-12-09T21:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NjQzOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538966438", "bodyText": "since backup/restore is a workflow running occasionally should this be set to info?", "author": "annym", "createdAt": "2020-12-09T02:54:53Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private final long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which requires back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    /**\n+     * Start the backup process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            backup();\n+            generateTarFile();\n+        } catch (IOException e) {\n+            log.debug(\"failed to backup tables: {}\", streamIDs);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.debug(\"backup completed\");\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     *\n+     * @throws IOException\n+     */\n+    private void backup() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            backupTable(fileName, streamId);\n+        }\n+        log.debug(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.\n+     * If the table has no data to backupTable, it will create a file with empty contents.\n+     *\n+     * @param fileName   - the name of the backup file\n+     * @param uuid       - the uuid of the table which is being backed up\n+     * @throws IOException\n+     */\n+    private void backupTable(String fileName, UUID uuid) throws IOException {\n+        try (FileOutputStream fileOutput = new FileOutputStream(fileName)) {\n+            StreamOptions options = StreamOptions.builder()\n+                    .ignoreTrimmed(false)\n+                    .cacheEntries(false)\n+                    .build();\n+            Stream<OpaqueEntry> stream = (new OpaqueStream(runtime, runtime.getStreamsView().get(uuid, options))).streamUpTo(timestamp);\n+\n+            writeTableToFile(fileOutput, stream, uuid);\n+        } catch (IOException e) {\n+            log.error(\"failed to backup table {} to file {}\", uuid, fileName);\n+            throw e;\n+        }\n+\n+        log.debug(\"{} table is backed up and stored to temp file {}\", uuid, fileName);", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0NjMyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539646325", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-09T21:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NjQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2ODQwOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538968408", "bodyText": "do we want to preserve the file or delete original after in the TAR? or is this done in the cleanup?", "author": "annym", "createdAt": "2020-12-09T03:00:14Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private final long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which requires back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    /**\n+     * Start the backup process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            backup();\n+            generateTarFile();\n+        } catch (IOException e) {\n+            log.debug(\"failed to backup tables: {}\", streamIDs);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.debug(\"backup completed\");\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     *\n+     * @throws IOException\n+     */\n+    private void backup() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            backupTable(fileName, streamId);\n+        }\n+        log.debug(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.\n+     * If the table has no data to backupTable, it will create a file with empty contents.\n+     *\n+     * @param fileName   - the name of the backup file\n+     * @param uuid       - the uuid of the table which is being backed up\n+     * @throws IOException\n+     */\n+    private void backupTable(String fileName, UUID uuid) throws IOException {\n+        try (FileOutputStream fileOutput = new FileOutputStream(fileName)) {\n+            StreamOptions options = StreamOptions.builder()\n+                    .ignoreTrimmed(false)\n+                    .cacheEntries(false)\n+                    .build();\n+            Stream<OpaqueEntry> stream = (new OpaqueStream(runtime, runtime.getStreamsView().get(uuid, options))).streamUpTo(timestamp);\n+\n+            writeTableToFile(fileOutput, stream, uuid);\n+        } catch (IOException e) {\n+            log.error(\"failed to backup table {} to file {}\", uuid, fileName);\n+            throw e;\n+        }\n+\n+        log.debug(\"{} table is backed up and stored to temp file {}\", uuid, fileName);\n+    }\n+\n+    private void writeTableToFile(FileOutputStream fileOutput, Stream<OpaqueEntry> stream, UUID uuid) throws IOException {\n+        Iterator<OpaqueEntry> iterator = stream.iterator();\n+        while (iterator.hasNext()) {\n+            OpaqueEntry lastEntry = iterator.next();\n+            List<SMREntry> smrEntries = lastEntry.getEntries().get(uuid);\n+            if (smrEntries != null) {\n+                Map<UUID, List<SMREntry>> map = new HashMap<>();\n+                map.put(uuid, smrEntries);\n+                OpaqueEntry newOpaqueEntry = new OpaqueEntry(lastEntry.getVersion(), map);\n+                OpaqueEntry.write(fileOutput, newOpaqueEntry);\n+            }\n+        }\n+        fileOutput.flush();\n+    }\n+\n+    /**\n+     * All generated files under tmp directory will be composed into one tar file\n+     *\n+     * @throws IOException\n+     */\n+    private void generateTarFile() throws IOException {\n+        File folder = new File(backupTempDirPath);\n+        File[] srcFiles = folder.listFiles();\n+        if (srcFiles == null) {\n+            log.debug(\"no backup file found under directory {}\", backupTempDirPath);\n+            return;\n+        }\n+\n+        try (FileOutputStream fileOutput = new FileOutputStream(filePath);\n+             TarArchiveOutputStream tarOutput = new TarArchiveOutputStream(fileOutput)) {\n+            for (File srcFile : srcFiles) {\n+                addToTarFile(srcFile, tarOutput);", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0NzQyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539647425", "bodyText": "Those files are under backupTempDirPath and are deleted in cleanup() at the end of the whole process.", "author": "Lujie1996", "createdAt": "2020-12-09T21:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2ODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MDE4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538970181", "bodyText": "we're restoring whatever is available in that TAR... imagine someone manipulates that TAR and removes some files... should we have a validation similar to the case of Backup, where if a list of streams to restore is given, or tagged streams is specified as preferred option, at the end we consider successful, if and only if we have restored everything requested in the API.", "author": "annym", "createdAt": "2020-12-09T03:05:21Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MTA2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539651064", "bodyText": "The requirement for restore is to restore whatever inside the given TAR file. We used to let users input a list of tables they want to restore in the restore API but Graham's team said they don't really need that feature. That's why we remove that parameter and just restore whatever they give us.", "author": "Lujie1996", "createdAt": "2020-12-09T21:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MDE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3OTg3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544079876", "bodyText": "on similar lines that the backed up tar file can get corrupted, should we add a checksum to the tar file?  On restore, verify if the checksum is as expected and fail if not?", "author": "pankti-m", "createdAt": "2020-12-16T07:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MDE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MDY0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538970645", "bodyText": "info?", "author": "annym", "createdAt": "2020-12-09T03:06:37Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    /**\n+     * Start the restore process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            openTarFile();\n+            verify();\n+            restore();\n+        } catch (IOException e) {\n+            log.error(\"failed to restore from backup tar file {}\", filePath);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.debug(\"restore completed\");", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MTI1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539651258", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-09T21:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MDY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MDkzNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538970934", "bodyText": "I think this actually has to do with my comment.. should we solve this now?", "author": "annym", "createdAt": "2020-12-09T03:07:25Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    /**\n+     * Start the restore process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            openTarFile();\n+            verify();\n+            restore();\n+        } catch (IOException e) {\n+            log.error(\"failed to restore from backup tar file {}\", filePath);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.debug(\"restore completed\");\n+    }\n+\n+    private void restore() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = restoreTempDirPath + File.separator + streamId;\n+            try {\n+                restoreTable(fileName, streamId);\n+            } catch (IOException e) {\n+                log.error(\"failed to restore table {} from temp file {}\", streamId, fileName);\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Restore a single table\n+     *\n+     * @param fileName   - the name of the temp backup file\n+     * @param streamId   - the stream ID of the table which is to be restored\n+     * @throws IOException\n+     */\n+    private void restoreTable(String fileName, UUID streamId) throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(fileName)) {\n+            // Clear table before restore\n+            TxnContext txn = corfuStore.txn(CORFU_SYSTEM_NAMESPACE);\n+            SMREntry entry = new SMREntry(\"clear\", new Array[0], Serializers.PRIMITIVE);\n+            txn.logUpdate(streamId, entry);\n+\n+            long numEntries = 0;\n+            while (fileInput.available()> 0) {\n+                OpaqueEntry opaqueEntry = OpaqueEntry.read(fileInput);\n+                List<SMREntry> smrEntries = opaqueEntry.getEntries().get(streamId);\n+                if (smrEntries == null || smrEntries.isEmpty()) {\n+                    continue;\n+                }\n+\n+                txn.logUpdate(streamId, smrEntries);\n+                numEntries++;\n+            }\n+            txn.commit();\n+            log.debug(\"write uuid {} with {} numEntries\", streamId, numEntries);\n+        } catch (FileNotFoundException e) {\n+            log.error(\"restoreTable can not find file {}\", fileName);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Open the backup tar file and save the table backups to tableDir directory\n+     */\n+    private void openTarFile() throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(filePath);\n+             TarArchiveInputStream tarInput = new TarArchiveInputStream(fileInput)) {\n+            getTablesFromTarFile(tarInput);\n+        } catch (IOException e) {\n+            log.error(\"failed to get tables from tar file {}\", filePath);\n+            throw e;\n+        }\n+    }\n+\n+    private void getTablesFromTarFile(TarArchiveInputStream tarInput) throws IOException {\n+        int count;\n+        byte[] buf = new byte[1024];\n+        TarArchiveEntry entry;\n+        while ((entry = tarInput.getNextTarEntry()) != null) {\n+            streamIDs.add(UUID.fromString(entry.getName()));\n+            String tablePath = restoreTempDirPath + File.separator + entry.getName();\n+            try (FileOutputStream fos = new FileOutputStream(tablePath)) {\n+                while ((count = tarInput.read(buf, 0, 1024)) != -1) {\n+                    fos.write(buf, 0, count);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Some verification logic (TBD) such as\n+     * - Compare the user provided streamIds and names of table backups under tmp directory, or some metadata file\n+     * - Checksum\n+     */\n+    private void verify() {\n+        // TODO: verification logic to be implemented", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1Mjg5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539652898", "bodyText": "I haven't decided what to check as verification. Also since it's a nice-to-have feature and not currently asked for by Graham's team, I think it might be better to not put too many efforts in this very first backup restore PR.", "author": "Lujie1996", "createdAt": "2020-12-09T21:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MDkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MTMzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538971331", "bodyText": "can we add an explicit log.info stating: 'Completed restore of table {}' ... (something in that line)", "author": "annym", "createdAt": "2020-12-09T03:08:43Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    /**\n+     * Start the restore process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            openTarFile();\n+            verify();\n+            restore();\n+        } catch (IOException e) {\n+            log.error(\"failed to restore from backup tar file {}\", filePath);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.debug(\"restore completed\");\n+    }\n+\n+    private void restore() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = restoreTempDirPath + File.separator + streamId;\n+            try {\n+                restoreTable(fileName, streamId);\n+            } catch (IOException e) {\n+                log.error(\"failed to restore table {} from temp file {}\", streamId, fileName);\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Restore a single table\n+     *\n+     * @param fileName   - the name of the temp backup file\n+     * @param streamId   - the stream ID of the table which is to be restored\n+     * @throws IOException\n+     */\n+    private void restoreTable(String fileName, UUID streamId) throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(fileName)) {\n+            // Clear table before restore\n+            TxnContext txn = corfuStore.txn(CORFU_SYSTEM_NAMESPACE);\n+            SMREntry entry = new SMREntry(\"clear\", new Array[0], Serializers.PRIMITIVE);\n+            txn.logUpdate(streamId, entry);\n+\n+            long numEntries = 0;\n+            while (fileInput.available()> 0) {\n+                OpaqueEntry opaqueEntry = OpaqueEntry.read(fileInput);\n+                List<SMREntry> smrEntries = opaqueEntry.getEntries().get(streamId);\n+                if (smrEntries == null || smrEntries.isEmpty()) {\n+                    continue;\n+                }\n+\n+                txn.logUpdate(streamId, smrEntries);\n+                numEntries++;\n+            }\n+            txn.commit();\n+            log.debug(\"write uuid {} with {} numEntries\", streamId, numEntries);", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MzY1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539653659", "bodyText": "Changed to log.info(\"completed restore of table {} with {} numEntries\", streamId, numEntries);. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-09T21:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MTMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MzY1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538973657", "bodyText": "we only have a test case where all tables are tagged as required for backup, can we have a test that combines non-tagged with tagged? so we validate that it is selective.", "author": "annym", "createdAt": "2020-12-09T03:15:40Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,338 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.runtime.collections.*;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+\n+import org.corfudb.test.SampleSchema.Uuid;\n+\n+/**\n+ * Test the Corfu native backup and restore functionalities. Overall the tests bring up two CorfuServers,\n+ * one used as source server which is backed up, and the other as destination server which restores the data\n+ * using the backup file generated from the source server.\n+ */\n+@Slf4j\n+public class BackupRestoreIT extends AbstractIT {\n+\n+    final static public int numEntries = 100;\n+    final static public int valSize = 2000;\n+    static final public int numTables = 5;\n+    static final private String NAMESPACE = \"test_namespace\";\n+    static final private String backupTable = \"test_table\";\n+\n+    static final private String DEFAULT_HOST = \"localhost\";\n+    static final private int DEFAULT_PORT = 9000;\n+    private static final int WRITER_PORT = DEFAULT_PORT + 1;\n+    private static final String SOURCE_ENDPOINT = DEFAULT_HOST + \":\" + DEFAULT_PORT;\n+    private static final String DESTINATION_ENDPOINT = DEFAULT_HOST + \":\" + WRITER_PORT;\n+\n+    // Log path of source server\n+    static final private String LOG_PATH1 = getCorfuServerLogPath(DEFAULT_HOST, DEFAULT_PORT);\n+\n+    // Location where the backup tar file is stored\n+     static final private String BACKUP_TAR_FILE_PATH = new File(LOG_PATH1).getParent() + File.separator + \"backup.tar\";\n+\n+    // Connect to sourceServer to generate data\n+    private CorfuRuntime srcDataRuntime = null;\n+\n+    // Connect to sourceServer to backup data\n+    private CorfuRuntime backupRuntime = null;\n+\n+    // Connect to destinationServer to restore data\n+    private CorfuRuntime restoreRuntime = null;\n+\n+    // Connect to destinationServer to verify data\n+    private CorfuRuntime destDataRuntime = null;\n+\n+    private SampleSchema.Uuid uuidKey = null;\n+\n+    /**\n+     * Setup Test Environment\n+     *\n+     * - Two independent Corfu Servers (source and destination)\n+     * - Four Corfu Runtimes connected to Corfu Servers\n+     */\n+    private void setupEnv() throws IOException {\n+        // Source Corfu Server (data will be written to this server)\n+        new CorfuServerRunner()\n+                .setHost(DEFAULT_HOST)\n+                .setPort(DEFAULT_PORT)\n+                .setSingle(true)\n+                .runServer();\n+\n+        // Destination Corfu Server (data will be replicated into this server)\n+        new CorfuServerRunner()\n+                .setHost(DEFAULT_HOST)\n+                .setPort(WRITER_PORT)\n+                .setSingle(true)\n+                .runServer();\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        srcDataRuntime = CorfuRuntime\n+                .fromParameters(params)\n+                .setTransactionLogging(true)\n+                .parseConfigurationString(SOURCE_ENDPOINT)\n+                .connect();\n+\n+        backupRuntime = CorfuRuntime\n+                .fromParameters(params)\n+                .setTransactionLogging(true)\n+                .parseConfigurationString(SOURCE_ENDPOINT)\n+                .connect();\n+\n+        restoreRuntime = CorfuRuntime\n+                .fromParameters(params)\n+                .setTransactionLogging(true)\n+                .parseConfigurationString(DESTINATION_ENDPOINT)\n+                .connect();\n+\n+        destDataRuntime = CorfuRuntime\n+                .fromParameters(params)\n+                .setTransactionLogging(true)\n+                .parseConfigurationString(DESTINATION_ENDPOINT)\n+                .connect();\n+    }\n+\n+    /**\n+     * Shutdown all Corfu Runtimes\n+     */\n+    private void cleanEnv() {\n+        if (srcDataRuntime != null)\n+            srcDataRuntime.shutdown();\n+\n+        if (backupRuntime != null)\n+            backupRuntime.shutdown();\n+\n+        if (restoreRuntime != null)\n+            restoreRuntime.shutdown();\n+\n+        if (destDataRuntime != null)\n+            destDataRuntime.shutdown();\n+    }\n+\n+    /**\n+     * Generate a list of tableNames\n+     *\n+     * @param numTables     the number of table name to generate\n+     * @return tableNames   a list of String representing table names\n+     */\n+    private List<String> getTableNames(int numTables) {\n+        List<String> tableNames = new ArrayList<>();\n+        for (int i = 0; i < numTables; i++) {\n+            tableNames.add(backupTable + \"_\" + i);\n+        }\n+        return tableNames;\n+    }\n+\n+    /**\n+     * Open a simple table using the tableName on the given Corfu Store.\n+     * - Key type is Uuid\n+     * - Value type is EventInfo\n+     * - Metadata type is UUid\n+     *\n+     * @param corfuStore    the Corfu Store at which new table is opened\n+     * @param tableName     the name of table to open\n+     */\n+    private Table<SampleSchema.Uuid, SampleSchema.EventInfo, SampleSchema.Uuid>\n+    openTableWithoutBackupTag(CorfuStore corfuStore, String tableName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        return corfuStore.openTable(NAMESPACE,\n+                tableName,\n+                SampleSchema.Uuid.class,\n+                SampleSchema.EventInfo.class,\n+                SampleSchema.Uuid.class,\n+                TableOptions.builder().build());\n+    }\n+\n+    /**\n+     * Open a simple table using the tableName on the given Corfu Store.\n+     * Payload 'SampleTableAMsg' has requires_backup_support set to true.\n+     * - Key type is Uuid\n+     * - Value type is SampleTableAMsg\n+     * - Metadata type is UUid\n+     *\n+     * @param corfuStore    the Corfu Store at which new table is opened\n+     * @param tableName     the name of table to open\n+     */\n+    private Table<SampleSchema.Uuid, SampleSchema.SampleTableAMsg, SampleSchema.Uuid>\n+    openTableWithBackupTag(CorfuStore corfuStore, String tableName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        return corfuStore.openTable(NAMESPACE,\n+                tableName,\n+                SampleSchema.Uuid.class,\n+                SampleSchema.SampleTableAMsg.class,\n+                SampleSchema.Uuid.class,\n+                TableOptions.builder().build());\n+    }\n+\n+    /**\n+     * Generate random EventInfo entries and save into the given Corfu DataStore.\n+     *\n+     * @param dataStore     the data store used\n+     * @param tableName     the table which generated entries are added to\n+     * */\n+    private void generateData(CorfuStore dataStore, String tableName, boolean hasBackupTag) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        Table table = hasBackupTag ? openTableWithBackupTag(dataStore, tableName) :\n+                openTableWithoutBackupTag(dataStore, tableName);\n+\n+        TxnContext txn = dataStore.txn(NAMESPACE);\n+        for (int i = 0; i < numEntries; i++) {\n+            uuidKey = SampleSchema.Uuid.newBuilder()\n+                    .setMsb(i)\n+                    .setLsb(i)\n+                    .build();\n+\n+            String name = RandomStringUtils.random(valSize, true, true);\n+            if (hasBackupTag) {\n+                SampleSchema.SampleTableAMsg payload = SampleSchema.SampleTableAMsg.newBuilder().setPayload(name).build();\n+                txn.putRecord(table, uuidKey, payload, uuidKey);\n+            } else {\n+                SampleSchema.EventInfo eventInfo = SampleSchema.EventInfo.newBuilder().setName(name).build();\n+                txn.putRecord(table, uuidKey, eventInfo, uuidKey);\n+            }\n+        }\n+        txn.commit();\n+    }\n+\n+    /**\n+     * Compare the entries inside two CorfuStore tables\n+     *\n+     * @param corfuStore1   the first corfuStore\n+     * @param tableName1    the table which is compared in the first corfuStore\n+     * @param corfuStore2   the second corfuStore\n+     * @param tableName2    the table in the second corfuStore which is compared with tableName1\n+     */\n+    private void compareCorfuStoreTables(CorfuStore corfuStore1, String tableName1, CorfuStore corfuStore2, String tableName2) {\n+        TxnContext aTxn = corfuStore1.txn(NAMESPACE);\n+        List<CorfuStoreEntry<Uuid, SampleSchema.SampleTableAMsg, Uuid>> aValueSet = new ArrayList<>();\n+        for (int i = 0; i < numEntries; i++) {\n+            uuidKey = SampleSchema.Uuid.newBuilder()\n+                    .setMsb(i)\n+                    .setLsb(i)\n+                    .build();\n+            aValueSet.add(aTxn.getRecord(tableName1, uuidKey));\n+        }\n+        aTxn.close();\n+\n+        TxnContext bTxn = corfuStore2.txn(NAMESPACE);\n+        List<CorfuStoreEntry<Uuid, SampleSchema.SampleTableAMsg, Uuid>> bValueSet = new ArrayList<>();\n+        for (int i = 0; i < numEntries; i++) {\n+            uuidKey = SampleSchema.Uuid.newBuilder()\n+                    .setMsb(i)\n+                    .setLsb(i)\n+                    .build();\n+            bValueSet.add(bTxn.getRecord(tableName2, uuidKey));\n+        }\n+        bTxn.close();\n+\n+        // Check if values are the same\n+        for (int i = 0; i < numEntries; i++) {\n+            assertThat(aValueSet.get(i)).isEqualTo(bValueSet.get(i));\n+        }\n+    }\n+\n+    /**\n+     * Implement an end-to-end Backup and Restore test for multiple tables.\n+     *\n+     * 1. Open multiple tables and generate random entries.\n+     * 2. Backup a list of tables and obtain a tar file.\n+     * 3. Use the tar file to restore tables.\n+     * 4. Compare the table contents before and after the backup/restore.\n+     */\n+    @Test\n+    public void backupRestoreMultipleTablesTest() throws IOException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+\n+        // Set up the test environment\n+        setupEnv();\n+\n+        // Create Corfu Store to add entries into server\n+        CorfuStore srcDataCorfuStore = new CorfuStore(srcDataRuntime);\n+        CorfuStore destDataCorfuStore = new CorfuStore(destDataRuntime);\n+\n+        List<String> tableNames = getTableNames(numTables);\n+\n+        // Generate random entries and save into sourceServer\n+        for (String tableName : tableNames) {\n+            generateData(srcDataCorfuStore, tableName, false);\n+        }\n+\n+        // Obtain the corresponding streamIDs for the tables in sourceServer\n+        List<UUID> streamIDs = new ArrayList<>();\n+        for (String tableName : tableNames) {\n+            streamIDs.add(CorfuRuntime.getStreamID(TableRegistry.getFullyQualifiedTableName(NAMESPACE, tableName)));\n+        }\n+\n+        // Backup\n+        Backup backup = new Backup(BACKUP_TAR_FILE_PATH, streamIDs, backupRuntime);\n+        backup.start();\n+\n+        // Verify that backup tar file exists\n+        File backupTarFile = new File(BACKUP_TAR_FILE_PATH);\n+        assertThat(backupTarFile).exists();\n+\n+        // Restore using backup files\n+        Restore restore = new Restore(BACKUP_TAR_FILE_PATH, restoreRuntime);\n+        restore.start();\n+\n+        // Compare data entries in CorfuStore before and after the Backup/Restore\n+        for (String tableName : tableNames) {\n+            openTableWithoutBackupTag(destDataCorfuStore, tableName);\n+            compareCorfuStoreTables(srcDataCorfuStore, tableName, destDataCorfuStore, tableName);\n+        }\n+\n+        // Close servers and runtime before exiting\n+        cleanEnv();\n+    }\n+\n+    /**\n+     * Backup and restore tables which have requires_backup_support tag set\n+     */\n+    @Test\n+    public void backupRestoreTaggedTables() throws IOException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        // Set up the test environment\n+        setupEnv();\n+\n+        // Create Corfu Store to add entries into server\n+        CorfuStore srcDataCorfuStore = new CorfuStore(srcDataRuntime);\n+        CorfuStore destDataCorfuStore = new CorfuStore(destDataRuntime);\n+\n+        List<String> tableNames = getTableNames(numTables);\n+\n+        // Generate random entries and save into sourceServer\n+        for (String tableName : tableNames) {\n+            generateData(srcDataCorfuStore, tableName, true);", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1OTM4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r540559388", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-10T22:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MzY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3NDU5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r538974593", "bodyText": "I think we can add a bit of more tests to cover more scenarios:\n\nA test where the TAR is deleted before restore, to validate exception is thrown..\nA test where only a subset of specified streamIds are backed (not all, like in test 1)\nA test where the log is trimmed before backup...", "author": "annym", "createdAt": "2020-12-09T03:18:23Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,338 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.runtime.collections.*;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+\n+import org.corfudb.test.SampleSchema.Uuid;\n+\n+/**\n+ * Test the Corfu native backup and restore functionalities. Overall the tests bring up two CorfuServers,\n+ * one used as source server which is backed up, and the other as destination server which restores the data\n+ * using the backup file generated from the source server.\n+ */\n+@Slf4j\n+public class BackupRestoreIT extends AbstractIT {\n+\n+    final static public int numEntries = 100;\n+    final static public int valSize = 2000;\n+    static final public int numTables = 5;\n+    static final private String NAMESPACE = \"test_namespace\";\n+    static final private String backupTable = \"test_table\";\n+\n+    static final private String DEFAULT_HOST = \"localhost\";\n+    static final private int DEFAULT_PORT = 9000;\n+    private static final int WRITER_PORT = DEFAULT_PORT + 1;\n+    private static final String SOURCE_ENDPOINT = DEFAULT_HOST + \":\" + DEFAULT_PORT;\n+    private static final String DESTINATION_ENDPOINT = DEFAULT_HOST + \":\" + WRITER_PORT;\n+\n+    // Log path of source server\n+    static final private String LOG_PATH1 = getCorfuServerLogPath(DEFAULT_HOST, DEFAULT_PORT);\n+\n+    // Location where the backup tar file is stored\n+     static final private String BACKUP_TAR_FILE_PATH = new File(LOG_PATH1).getParent() + File.separator + \"backup.tar\";\n+\n+    // Connect to sourceServer to generate data\n+    private CorfuRuntime srcDataRuntime = null;\n+\n+    // Connect to sourceServer to backup data\n+    private CorfuRuntime backupRuntime = null;\n+\n+    // Connect to destinationServer to restore data\n+    private CorfuRuntime restoreRuntime = null;\n+\n+    // Connect to destinationServer to verify data\n+    private CorfuRuntime destDataRuntime = null;\n+\n+    private SampleSchema.Uuid uuidKey = null;\n+\n+    /**\n+     * Setup Test Environment\n+     *\n+     * - Two independent Corfu Servers (source and destination)\n+     * - Four Corfu Runtimes connected to Corfu Servers\n+     */\n+    private void setupEnv() throws IOException {\n+        // Source Corfu Server (data will be written to this server)\n+        new CorfuServerRunner()\n+                .setHost(DEFAULT_HOST)\n+                .setPort(DEFAULT_PORT)\n+                .setSingle(true)\n+                .runServer();\n+\n+        // Destination Corfu Server (data will be replicated into this server)\n+        new CorfuServerRunner()\n+                .setHost(DEFAULT_HOST)\n+                .setPort(WRITER_PORT)\n+                .setSingle(true)\n+                .runServer();\n+\n+        CorfuRuntime.CorfuRuntimeParameters params = CorfuRuntime.CorfuRuntimeParameters\n+                .builder()\n+                .build();\n+\n+        srcDataRuntime = CorfuRuntime\n+                .fromParameters(params)\n+                .setTransactionLogging(true)\n+                .parseConfigurationString(SOURCE_ENDPOINT)\n+                .connect();\n+\n+        backupRuntime = CorfuRuntime\n+                .fromParameters(params)\n+                .setTransactionLogging(true)\n+                .parseConfigurationString(SOURCE_ENDPOINT)\n+                .connect();\n+\n+        restoreRuntime = CorfuRuntime\n+                .fromParameters(params)\n+                .setTransactionLogging(true)\n+                .parseConfigurationString(DESTINATION_ENDPOINT)\n+                .connect();\n+\n+        destDataRuntime = CorfuRuntime\n+                .fromParameters(params)\n+                .setTransactionLogging(true)\n+                .parseConfigurationString(DESTINATION_ENDPOINT)\n+                .connect();\n+    }\n+\n+    /**\n+     * Shutdown all Corfu Runtimes\n+     */\n+    private void cleanEnv() {\n+        if (srcDataRuntime != null)\n+            srcDataRuntime.shutdown();\n+\n+        if (backupRuntime != null)\n+            backupRuntime.shutdown();\n+\n+        if (restoreRuntime != null)\n+            restoreRuntime.shutdown();\n+\n+        if (destDataRuntime != null)\n+            destDataRuntime.shutdown();\n+    }\n+\n+    /**\n+     * Generate a list of tableNames\n+     *\n+     * @param numTables     the number of table name to generate\n+     * @return tableNames   a list of String representing table names\n+     */\n+    private List<String> getTableNames(int numTables) {\n+        List<String> tableNames = new ArrayList<>();\n+        for (int i = 0; i < numTables; i++) {\n+            tableNames.add(backupTable + \"_\" + i);\n+        }\n+        return tableNames;\n+    }\n+\n+    /**\n+     * Open a simple table using the tableName on the given Corfu Store.\n+     * - Key type is Uuid\n+     * - Value type is EventInfo\n+     * - Metadata type is UUid\n+     *\n+     * @param corfuStore    the Corfu Store at which new table is opened\n+     * @param tableName     the name of table to open\n+     */\n+    private Table<SampleSchema.Uuid, SampleSchema.EventInfo, SampleSchema.Uuid>\n+    openTableWithoutBackupTag(CorfuStore corfuStore, String tableName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        return corfuStore.openTable(NAMESPACE,\n+                tableName,\n+                SampleSchema.Uuid.class,\n+                SampleSchema.EventInfo.class,\n+                SampleSchema.Uuid.class,\n+                TableOptions.builder().build());\n+    }\n+\n+    /**\n+     * Open a simple table using the tableName on the given Corfu Store.\n+     * Payload 'SampleTableAMsg' has requires_backup_support set to true.\n+     * - Key type is Uuid\n+     * - Value type is SampleTableAMsg\n+     * - Metadata type is UUid\n+     *\n+     * @param corfuStore    the Corfu Store at which new table is opened\n+     * @param tableName     the name of table to open\n+     */\n+    private Table<SampleSchema.Uuid, SampleSchema.SampleTableAMsg, SampleSchema.Uuid>\n+    openTableWithBackupTag(CorfuStore corfuStore, String tableName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        return corfuStore.openTable(NAMESPACE,\n+                tableName,\n+                SampleSchema.Uuid.class,\n+                SampleSchema.SampleTableAMsg.class,\n+                SampleSchema.Uuid.class,\n+                TableOptions.builder().build());\n+    }\n+\n+    /**\n+     * Generate random EventInfo entries and save into the given Corfu DataStore.\n+     *\n+     * @param dataStore     the data store used\n+     * @param tableName     the table which generated entries are added to\n+     * */\n+    private void generateData(CorfuStore dataStore, String tableName, boolean hasBackupTag) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        Table table = hasBackupTag ? openTableWithBackupTag(dataStore, tableName) :\n+                openTableWithoutBackupTag(dataStore, tableName);\n+\n+        TxnContext txn = dataStore.txn(NAMESPACE);\n+        for (int i = 0; i < numEntries; i++) {\n+            uuidKey = SampleSchema.Uuid.newBuilder()\n+                    .setMsb(i)\n+                    .setLsb(i)\n+                    .build();\n+\n+            String name = RandomStringUtils.random(valSize, true, true);\n+            if (hasBackupTag) {\n+                SampleSchema.SampleTableAMsg payload = SampleSchema.SampleTableAMsg.newBuilder().setPayload(name).build();\n+                txn.putRecord(table, uuidKey, payload, uuidKey);\n+            } else {\n+                SampleSchema.EventInfo eventInfo = SampleSchema.EventInfo.newBuilder().setName(name).build();\n+                txn.putRecord(table, uuidKey, eventInfo, uuidKey);\n+            }\n+        }\n+        txn.commit();\n+    }\n+\n+    /**\n+     * Compare the entries inside two CorfuStore tables\n+     *\n+     * @param corfuStore1   the first corfuStore\n+     * @param tableName1    the table which is compared in the first corfuStore\n+     * @param corfuStore2   the second corfuStore\n+     * @param tableName2    the table in the second corfuStore which is compared with tableName1\n+     */\n+    private void compareCorfuStoreTables(CorfuStore corfuStore1, String tableName1, CorfuStore corfuStore2, String tableName2) {\n+        TxnContext aTxn = corfuStore1.txn(NAMESPACE);\n+        List<CorfuStoreEntry<Uuid, SampleSchema.SampleTableAMsg, Uuid>> aValueSet = new ArrayList<>();\n+        for (int i = 0; i < numEntries; i++) {\n+            uuidKey = SampleSchema.Uuid.newBuilder()\n+                    .setMsb(i)\n+                    .setLsb(i)\n+                    .build();\n+            aValueSet.add(aTxn.getRecord(tableName1, uuidKey));\n+        }\n+        aTxn.close();\n+\n+        TxnContext bTxn = corfuStore2.txn(NAMESPACE);\n+        List<CorfuStoreEntry<Uuid, SampleSchema.SampleTableAMsg, Uuid>> bValueSet = new ArrayList<>();\n+        for (int i = 0; i < numEntries; i++) {\n+            uuidKey = SampleSchema.Uuid.newBuilder()\n+                    .setMsb(i)\n+                    .setLsb(i)\n+                    .build();\n+            bValueSet.add(bTxn.getRecord(tableName2, uuidKey));\n+        }\n+        bTxn.close();\n+\n+        // Check if values are the same\n+        for (int i = 0; i < numEntries; i++) {\n+            assertThat(aValueSet.get(i)).isEqualTo(bValueSet.get(i));\n+        }\n+    }\n+\n+    /**\n+     * Implement an end-to-end Backup and Restore test for multiple tables.\n+     *\n+     * 1. Open multiple tables and generate random entries.\n+     * 2. Backup a list of tables and obtain a tar file.\n+     * 3. Use the tar file to restore tables.\n+     * 4. Compare the table contents before and after the backup/restore.\n+     */\n+    @Test\n+    public void backupRestoreMultipleTablesTest() throws IOException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+\n+        // Set up the test environment\n+        setupEnv();\n+\n+        // Create Corfu Store to add entries into server\n+        CorfuStore srcDataCorfuStore = new CorfuStore(srcDataRuntime);\n+        CorfuStore destDataCorfuStore = new CorfuStore(destDataRuntime);\n+\n+        List<String> tableNames = getTableNames(numTables);\n+\n+        // Generate random entries and save into sourceServer\n+        for (String tableName : tableNames) {\n+            generateData(srcDataCorfuStore, tableName, false);\n+        }\n+\n+        // Obtain the corresponding streamIDs for the tables in sourceServer\n+        List<UUID> streamIDs = new ArrayList<>();\n+        for (String tableName : tableNames) {\n+            streamIDs.add(CorfuRuntime.getStreamID(TableRegistry.getFullyQualifiedTableName(NAMESPACE, tableName)));\n+        }\n+\n+        // Backup\n+        Backup backup = new Backup(BACKUP_TAR_FILE_PATH, streamIDs, backupRuntime);\n+        backup.start();\n+\n+        // Verify that backup tar file exists\n+        File backupTarFile = new File(BACKUP_TAR_FILE_PATH);\n+        assertThat(backupTarFile).exists();\n+\n+        // Restore using backup files\n+        Restore restore = new Restore(BACKUP_TAR_FILE_PATH, restoreRuntime);\n+        restore.start();\n+\n+        // Compare data entries in CorfuStore before and after the Backup/Restore\n+        for (String tableName : tableNames) {\n+            openTableWithoutBackupTag(destDataCorfuStore, tableName);\n+            compareCorfuStoreTables(srcDataCorfuStore, tableName, destDataCorfuStore, tableName);\n+        }\n+\n+        // Close servers and runtime before exiting\n+        cleanEnv();\n+    }\n+\n+    /**\n+     * Backup and restore tables which have requires_backup_support tag set\n+     */\n+    @Test\n+    public void backupRestoreTaggedTables() throws IOException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {", "originalCommit": "bc91ce54685b139e8c85389285f1583a64bf9bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAxMjE1NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539012154", "bodyText": "Some other tests I thought would be relevant are:\n\nSpecify a StreamX for backup (through the API where streams for backup are given) which has never been open by any client (not in the registry).\nSpecify a StreamY for backup which is open but empty, so we validate that empty tables are restored with no issues.", "author": "annym", "createdAt": "2020-12-09T05:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3NDU5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MjAwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r539662001", "bodyText": "They are all very good test cases. I'll add them soon.", "author": "Lujie1996", "createdAt": "2020-12-09T21:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3NDU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA1MDIxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544050217", "bodyText": "where is BACKUP_TEMP_DIR defined?", "author": "pankti-m", "createdAt": "2020-12-16T07:01:15Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Provides Corfu native backup support.\n+ *\n+ * Backup a selective set of tables specified by stream id or UFO table option.\n+ *\n+ * Steps:\n+ * 1. Open the selective set of tables as OpaqueStreams\n+ * 2. Write each table to individual temporary file\n+ * 3. Merge temporary backup files into a single .tar file under a user-given path\n+ */\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    // All tables in Corfu Db\n+    private List<UUID> allTablesInDb;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczNzAzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544737037", "bodyText": "The backup temporary directory is generated by this line of code:\nthis.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString(); (https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.lang.String-java.nio.file.attribute.FileAttribute...-)\nThe directory is created in system default temp path.", "author": "Lujie1996", "createdAt": "2020-12-17T01:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA1MDIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA1MDM1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544050357", "bodyText": "where is BACKUP_TEMP_DIR defined?", "author": "pankti-m", "createdAt": "2020-12-16T07:01:25Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Provides Corfu native backup support.\n+ *\n+ * Backup a selective set of tables specified by stream id or UFO table option.\n+ *\n+ * Steps:\n+ * 1. Open the selective set of tables as OpaqueStreams\n+ * 2. Write each table to individual temporary file\n+ * 3. Merge temporary backup files into a single .tar file under a user-given path\n+ */\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    // All tables in Corfu Db\n+    private List<UUID> allTablesInDb;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczODk1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544738950", "bodyText": "as explained above", "author": "Lujie1996", "createdAt": "2020-12-17T01:16:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA1MDM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA1MjE0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544052148", "bodyText": "instead of repeating the below code, you can call the previous constructor from here -\nBackup(filePath, getTaggedTables(), runtime)", "author": "pankti-m", "createdAt": "2020-12-16T07:03:29Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Provides Corfu native backup support.\n+ *\n+ * Backup a selective set of tables specified by stream id or UFO table option.\n+ *\n+ * Steps:\n+ * 1. Open the selective set of tables as OpaqueStreams\n+ * 2. Write each table to individual temporary file\n+ * 3. Merge temporary backup files into a single .tar file under a user-given path\n+ */\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    // All tables in Corfu Db\n+    private List<UUID> allTablesInDb;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which require back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyNTQyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544825421", "bodyText": "Backup() is constructor. Calling this(filePath, getTaggedTables(), runtime) will trigger Error:(83, 24) java: cannot reference this before supertype constructor has been called", "author": "Lujie1996", "createdAt": "2020-12-17T05:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA1MjE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA1ODI5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544058293", "bodyText": "should we add a null check aslo?", "author": "pankti-m", "createdAt": "2020-12-16T07:10:24Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Provides Corfu native backup support.\n+ *\n+ * Backup a selective set of tables specified by stream id or UFO table option.\n+ *\n+ * Steps:\n+ * 1. Open the selective set of tables as OpaqueStreams\n+ * 2. Write each table to individual temporary file\n+ * 3. Merge temporary backup files into a single .tar file under a user-given path\n+ */\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    // All tables in Corfu Db\n+    private List<UUID> allTablesInDb;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which require back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    /**\n+     * Start the backup process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+\n+        try {\n+            backup();\n+            generateTarFile();\n+        } catch (IOException e) {\n+            log.error(\"failed to backup tables: {}\", streamIDs);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"backup completed\");\n+    }\n+\n+    /**\n+     * Check if table exists in Corfu Db\n+     *\n+     * @param streamId   the stream id of the table which is being checked\n+     * @return           true if table exists\n+     */\n+    private boolean tableExists(UUID streamId) {\n+        if (allTablesInDb == null) {\n+            allTablesInDb = runtime.getTableRegistry().listTables()\n+                    .stream()\n+                    .map(tableName -> CorfuRuntime.getStreamID(TableRegistry.getFullyQualifiedTableName(tableName)))\n+                    .collect(Collectors.toList());\n+        }\n+        return allTablesInDb.contains(streamId);\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     *\n+     * @throws IOException\n+     */\n+    private void backup() throws IOException {\n+        if (streamIDs.isEmpty()) {", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyNzE1NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544827154", "bodyText": "Just added null check in start() and abort backup in case of null streamIDs. Thanks!", "author": "Lujie1996", "createdAt": "2020-12-17T05:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA1ODI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA2MTMwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544061306", "bodyText": "nit: backupTable -> backup", "author": "pankti-m", "createdAt": "2020-12-16T07:14:08Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Provides Corfu native backup support.\n+ *\n+ * Backup a selective set of tables specified by stream id or UFO table option.\n+ *\n+ * Steps:\n+ * 1. Open the selective set of tables as OpaqueStreams\n+ * 2. Write each table to individual temporary file\n+ * 3. Merge temporary backup files into a single .tar file under a user-given path\n+ */\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    // All tables in Corfu Db\n+    private List<UUID> allTablesInDb;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which require back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    /**\n+     * Start the backup process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+\n+        try {\n+            backup();\n+            generateTarFile();\n+        } catch (IOException e) {\n+            log.error(\"failed to backup tables: {}\", streamIDs);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"backup completed\");\n+    }\n+\n+    /**\n+     * Check if table exists in Corfu Db\n+     *\n+     * @param streamId   the stream id of the table which is being checked\n+     * @return           true if table exists\n+     */\n+    private boolean tableExists(UUID streamId) {\n+        if (allTablesInDb == null) {\n+            allTablesInDb = runtime.getTableRegistry().listTables()\n+                    .stream()\n+                    .map(tableName -> CorfuRuntime.getStreamID(TableRegistry.getFullyQualifiedTableName(tableName)))\n+                    .collect(Collectors.toList());\n+        }\n+        return allTablesInDb.contains(streamId);\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     *\n+     * @throws IOException\n+     */\n+    private void backup() throws IOException {\n+        if (streamIDs.isEmpty()) {\n+            log.warn(\"back up is called with empty streamIDs!\");\n+        }\n+\n+        for (UUID streamId : streamIDs) {\n+            if (!tableExists(streamId)) {\n+                log.warn(\"cannot back up a non-existent table: {}\", streamId);\n+                continue;\n+            }\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            backupTable(fileName, streamId);\n+        }\n+        log.info(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.\n+     * If the table has no data to backupTable, it will create a file with empty contents.", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyNzQwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544827407", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-17T05:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA2MTMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA2MzQ1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544063456", "bodyText": "in that case, is there no way to backup data which is checkpointed and trimmed?", "author": "pankti-m", "createdAt": "2020-12-16T07:16:28Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Provides Corfu native backup support.\n+ *\n+ * Backup a selective set of tables specified by stream id or UFO table option.\n+ *\n+ * Steps:\n+ * 1. Open the selective set of tables as OpaqueStreams\n+ * 2. Write each table to individual temporary file\n+ * 3. Merge temporary backup files into a single .tar file under a user-given path\n+ */\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    // All tables in Corfu Db\n+    private List<UUID> allTablesInDb;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which require back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    /**\n+     * Start the backup process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+\n+        try {\n+            backup();\n+            generateTarFile();\n+        } catch (IOException e) {\n+            log.error(\"failed to backup tables: {}\", streamIDs);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"backup completed\");\n+    }\n+\n+    /**\n+     * Check if table exists in Corfu Db\n+     *\n+     * @param streamId   the stream id of the table which is being checked\n+     * @return           true if table exists\n+     */\n+    private boolean tableExists(UUID streamId) {\n+        if (allTablesInDb == null) {\n+            allTablesInDb = runtime.getTableRegistry().listTables()\n+                    .stream()\n+                    .map(tableName -> CorfuRuntime.getStreamID(TableRegistry.getFullyQualifiedTableName(tableName)))\n+                    .collect(Collectors.toList());\n+        }\n+        return allTablesInDb.contains(streamId);\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     *\n+     * @throws IOException\n+     */\n+    private void backup() throws IOException {\n+        if (streamIDs.isEmpty()) {\n+            log.warn(\"back up is called with empty streamIDs!\");\n+        }\n+\n+        for (UUID streamId : streamIDs) {\n+            if (!tableExists(streamId)) {\n+                log.warn(\"cannot back up a non-existent table: {}\", streamId);\n+                continue;\n+            }\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            backupTable(fileName, streamId);\n+        }\n+        log.info(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3MTc2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r545571767", "bodyText": "As discussed, this happens extremely rarely. In case of such scenario, users can do a retry.", "author": "Lujie1996", "createdAt": "2020-12-18T04:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA2MzQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA2Mzk4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544063981", "bodyText": "should TrimmedException also be caught and rethrown like this?", "author": "pankti-m", "createdAt": "2020-12-16T07:17:11Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Provides Corfu native backup support.\n+ *\n+ * Backup a selective set of tables specified by stream id or UFO table option.\n+ *\n+ * Steps:\n+ * 1. Open the selective set of tables as OpaqueStreams\n+ * 2. Write each table to individual temporary file\n+ * 3. Merge temporary backup files into a single .tar file under a user-given path\n+ */\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    // All tables in Corfu Db\n+    private List<UUID> allTablesInDb;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which require back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    /**\n+     * Start the backup process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+\n+        try {\n+            backup();\n+            generateTarFile();\n+        } catch (IOException e) {\n+            log.error(\"failed to backup tables: {}\", streamIDs);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"backup completed\");\n+    }\n+\n+    /**\n+     * Check if table exists in Corfu Db\n+     *\n+     * @param streamId   the stream id of the table which is being checked\n+     * @return           true if table exists\n+     */\n+    private boolean tableExists(UUID streamId) {\n+        if (allTablesInDb == null) {\n+            allTablesInDb = runtime.getTableRegistry().listTables()\n+                    .stream()\n+                    .map(tableName -> CorfuRuntime.getStreamID(TableRegistry.getFullyQualifiedTableName(tableName)))\n+                    .collect(Collectors.toList());\n+        }\n+        return allTablesInDb.contains(streamId);\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     *\n+     * @throws IOException\n+     */\n+    private void backup() throws IOException {\n+        if (streamIDs.isEmpty()) {\n+            log.warn(\"back up is called with empty streamIDs!\");\n+        }\n+\n+        for (UUID streamId : streamIDs) {\n+            if (!tableExists(streamId)) {\n+                log.warn(\"cannot back up a non-existent table: {}\", streamId);\n+                continue;\n+            }\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            backupTable(fileName, streamId);\n+        }\n+        log.info(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.\n+     * If the table has no data to backupTable, it will create a file with empty contents.\n+     *\n+     * @param fileName   - the name of the backup file\n+     * @param uuid       - the uuid of the table which is being backed up\n+     * @throws IOException\n+     */\n+    private void backupTable(String fileName, UUID uuid) throws IOException {\n+        try (FileOutputStream fileOutput = new FileOutputStream(fileName)) {\n+            StreamOptions options = StreamOptions.builder()\n+                    .ignoreTrimmed(false)\n+                    .cacheEntries(false)\n+                    .build();\n+            Stream<OpaqueEntry> stream = (new OpaqueStream(runtime, runtime.getStreamsView().get(uuid, options))).streamUpTo(timestamp);\n+\n+            writeTableToFile(fileOutput, stream, uuid);\n+        } catch (IOException e) {", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3Mjg3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r545572878", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-18T04:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA2Mzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3MTc3NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544071774", "bodyText": "can it be private?", "author": "pankti-m", "createdAt": "2020-12-16T07:29:42Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Provides Corfu native backup support.\n+ *\n+ * Backup a selective set of tables specified by stream id or UFO table option.\n+ *\n+ * Steps:\n+ * 1. Open the selective set of tables as OpaqueStreams\n+ * 2. Write each table to individual temporary file\n+ * 3. Merge temporary backup files into a single .tar file under a user-given path\n+ */\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    // All tables in Corfu Db\n+    private List<UUID> allTablesInDb;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which require back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    /**\n+     * Start the backup process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+\n+        try {\n+            backup();\n+            generateTarFile();\n+        } catch (IOException e) {\n+            log.error(\"failed to backup tables: {}\", streamIDs);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"backup completed\");\n+    }\n+\n+    /**\n+     * Check if table exists in Corfu Db\n+     *\n+     * @param streamId   the stream id of the table which is being checked\n+     * @return           true if table exists\n+     */\n+    private boolean tableExists(UUID streamId) {\n+        if (allTablesInDb == null) {\n+            allTablesInDb = runtime.getTableRegistry().listTables()\n+                    .stream()\n+                    .map(tableName -> CorfuRuntime.getStreamID(TableRegistry.getFullyQualifiedTableName(tableName)))\n+                    .collect(Collectors.toList());\n+        }\n+        return allTablesInDb.contains(streamId);\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     *\n+     * @throws IOException\n+     */\n+    private void backup() throws IOException {\n+        if (streamIDs.isEmpty()) {\n+            log.warn(\"back up is called with empty streamIDs!\");\n+        }\n+\n+        for (UUID streamId : streamIDs) {\n+            if (!tableExists(streamId)) {\n+                log.warn(\"cannot back up a non-existent table: {}\", streamId);\n+                continue;\n+            }\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            backupTable(fileName, streamId);\n+        }\n+        log.info(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.\n+     * If the table has no data to backupTable, it will create a file with empty contents.\n+     *\n+     * @param fileName   - the name of the backup file\n+     * @param uuid       - the uuid of the table which is being backed up\n+     * @throws IOException\n+     */\n+    private void backupTable(String fileName, UUID uuid) throws IOException {\n+        try (FileOutputStream fileOutput = new FileOutputStream(fileName)) {\n+            StreamOptions options = StreamOptions.builder()\n+                    .ignoreTrimmed(false)\n+                    .cacheEntries(false)\n+                    .build();\n+            Stream<OpaqueEntry> stream = (new OpaqueStream(runtime, runtime.getStreamsView().get(uuid, options))).streamUpTo(timestamp);\n+\n+            writeTableToFile(fileOutput, stream, uuid);\n+        } catch (IOException e) {\n+            log.error(\"failed to backup table {} to file {}\", uuid, fileName);\n+            throw e;\n+        }\n+\n+        log.info(\"{} table is backed up and stored to temp file {}\", uuid, fileName);\n+    }\n+\n+    private void writeTableToFile(FileOutputStream fileOutput, Stream<OpaqueEntry> stream, UUID uuid) throws IOException {\n+        Iterator<OpaqueEntry> iterator = stream.iterator();\n+        while (iterator.hasNext()) {\n+            OpaqueEntry lastEntry = iterator.next();\n+            List<SMREntry> smrEntries = lastEntry.getEntries().get(uuid);\n+            if (smrEntries != null) {\n+                Map<UUID, List<SMREntry>> map = new HashMap<>();\n+                map.put(uuid, smrEntries);\n+                OpaqueEntry newOpaqueEntry = new OpaqueEntry(lastEntry.getVersion(), map);\n+                OpaqueEntry.write(fileOutput, newOpaqueEntry);\n+            }\n+        }\n+        fileOutput.flush();\n+    }\n+\n+    /**\n+     * All generated files under tmp directory will be composed into one tar file\n+     *\n+     * @throws IOException\n+     */\n+    private void generateTarFile() throws IOException {\n+        File folder = new File(backupTempDirPath);\n+        File[] srcFiles = folder.listFiles();\n+        if (srcFiles == null) {\n+            log.debug(\"no backup file found under directory {}\", backupTempDirPath);\n+            return;\n+        }\n+\n+        try (FileOutputStream fileOutput = new FileOutputStream(filePath);\n+             TarArchiveOutputStream tarOutput = new TarArchiveOutputStream(fileOutput)) {\n+            for (File srcFile : srcFiles) {\n+                addToTarFile(srcFile, tarOutput);\n+            }\n+        } catch (IOException e) {\n+            log.error(\"failed to generate a backup tar file {}\", filePath);\n+            throw e;\n+        }\n+\n+        log.info(\"backup tar file is generated at {}\", filePath);\n+    }\n+\n+    /**\n+     * Add the table backup file to the backup tar file which contains all tables\n+     *\n+     * @param tableFile    - the table backup file\n+     * @param tarOutput    - the backup tar file which contains all tables\n+     * @throws IOException\n+     */\n+    private void addToTarFile(File tableFile,TarArchiveOutputStream tarOutput) throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(tableFile)) {\n+            TarArchiveEntry tarEntry = new TarArchiveEntry(tableFile);\n+            tarEntry.setName(tableFile.getName());\n+            tarOutput.putArchiveEntry(tarEntry);\n+\n+            int count;\n+            byte[] buf = new byte[1024];\n+            while ((count = fileInput.read(buf, 0, 1024)) != -1) {\n+                tarOutput.write(buf, 0, count);\n+            }\n+            tarOutput.closeArchiveEntry();\n+        } catch (IOException e) {\n+            log.error(\"failed to add table backup file {} to tar file\", tableFile.getName());\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Find tables which have the requires_backup_support tag set\n+     *\n+     * @return  List<UUID>   - a list of UUIDs for all the tables which require backup support\n+     */\n+    public List<UUID> getTaggedTables() {", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg0MTczMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544841730", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-17T06:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3MTc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NDMyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544074321", "bodyText": "do we want to print names of all tables?  this will only print the list reference, right?", "author": "pankti-m", "createdAt": "2020-12-16T07:35:03Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Provides Corfu native backup support.\n+ *\n+ * Backup a selective set of tables specified by stream id or UFO table option.\n+ *\n+ * Steps:\n+ * 1. Open the selective set of tables as OpaqueStreams\n+ * 2. Write each table to individual temporary file\n+ * 3. Merge temporary backup files into a single .tar file under a user-given path\n+ */\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    // All tables in Corfu Db\n+    private List<UUID> allTablesInDb;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which require back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    /**\n+     * Start the backup process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+\n+        try {\n+            backup();\n+            generateTarFile();\n+        } catch (IOException e) {\n+            log.error(\"failed to backup tables: {}\", streamIDs);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"backup completed\");\n+    }\n+\n+    /**\n+     * Check if table exists in Corfu Db\n+     *\n+     * @param streamId   the stream id of the table which is being checked\n+     * @return           true if table exists\n+     */\n+    private boolean tableExists(UUID streamId) {\n+        if (allTablesInDb == null) {\n+            allTablesInDb = runtime.getTableRegistry().listTables()\n+                    .stream()\n+                    .map(tableName -> CorfuRuntime.getStreamID(TableRegistry.getFullyQualifiedTableName(tableName)))\n+                    .collect(Collectors.toList());\n+        }\n+        return allTablesInDb.contains(streamId);\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     *\n+     * @throws IOException\n+     */\n+    private void backup() throws IOException {\n+        if (streamIDs.isEmpty()) {\n+            log.warn(\"back up is called with empty streamIDs!\");\n+        }\n+\n+        for (UUID streamId : streamIDs) {\n+            if (!tableExists(streamId)) {\n+                log.warn(\"cannot back up a non-existent table: {}\", streamId);\n+                continue;\n+            }\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            backupTable(fileName, streamId);\n+        }\n+        log.info(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.\n+     * If the table has no data to backupTable, it will create a file with empty contents.\n+     *\n+     * @param fileName   - the name of the backup file\n+     * @param uuid       - the uuid of the table which is being backed up\n+     * @throws IOException\n+     */\n+    private void backupTable(String fileName, UUID uuid) throws IOException {\n+        try (FileOutputStream fileOutput = new FileOutputStream(fileName)) {\n+            StreamOptions options = StreamOptions.builder()\n+                    .ignoreTrimmed(false)\n+                    .cacheEntries(false)\n+                    .build();\n+            Stream<OpaqueEntry> stream = (new OpaqueStream(runtime, runtime.getStreamsView().get(uuid, options))).streamUpTo(timestamp);\n+\n+            writeTableToFile(fileOutput, stream, uuid);\n+        } catch (IOException e) {\n+            log.error(\"failed to backup table {} to file {}\", uuid, fileName);\n+            throw e;\n+        }\n+\n+        log.info(\"{} table is backed up and stored to temp file {}\", uuid, fileName);\n+    }\n+\n+    private void writeTableToFile(FileOutputStream fileOutput, Stream<OpaqueEntry> stream, UUID uuid) throws IOException {\n+        Iterator<OpaqueEntry> iterator = stream.iterator();\n+        while (iterator.hasNext()) {\n+            OpaqueEntry lastEntry = iterator.next();\n+            List<SMREntry> smrEntries = lastEntry.getEntries().get(uuid);\n+            if (smrEntries != null) {\n+                Map<UUID, List<SMREntry>> map = new HashMap<>();\n+                map.put(uuid, smrEntries);\n+                OpaqueEntry newOpaqueEntry = new OpaqueEntry(lastEntry.getVersion(), map);\n+                OpaqueEntry.write(fileOutput, newOpaqueEntry);\n+            }\n+        }\n+        fileOutput.flush();\n+    }\n+\n+    /**\n+     * All generated files under tmp directory will be composed into one tar file\n+     *\n+     * @throws IOException\n+     */\n+    private void generateTarFile() throws IOException {\n+        File folder = new File(backupTempDirPath);\n+        File[] srcFiles = folder.listFiles();\n+        if (srcFiles == null) {\n+            log.debug(\"no backup file found under directory {}\", backupTempDirPath);\n+            return;\n+        }\n+\n+        try (FileOutputStream fileOutput = new FileOutputStream(filePath);\n+             TarArchiveOutputStream tarOutput = new TarArchiveOutputStream(fileOutput)) {\n+            for (File srcFile : srcFiles) {\n+                addToTarFile(srcFile, tarOutput);\n+            }\n+        } catch (IOException e) {\n+            log.error(\"failed to generate a backup tar file {}\", filePath);\n+            throw e;\n+        }\n+\n+        log.info(\"backup tar file is generated at {}\", filePath);\n+    }\n+\n+    /**\n+     * Add the table backup file to the backup tar file which contains all tables\n+     *\n+     * @param tableFile    - the table backup file\n+     * @param tarOutput    - the backup tar file which contains all tables\n+     * @throws IOException\n+     */\n+    private void addToTarFile(File tableFile,TarArchiveOutputStream tarOutput) throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(tableFile)) {\n+            TarArchiveEntry tarEntry = new TarArchiveEntry(tableFile);\n+            tarEntry.setName(tableFile.getName());\n+            tarOutput.putArchiveEntry(tarEntry);\n+\n+            int count;\n+            byte[] buf = new byte[1024];\n+            while ((count = fileInput.read(buf, 0, 1024)) != -1) {\n+                tarOutput.write(buf, 0, count);\n+            }\n+            tarOutput.closeArchiveEntry();\n+        } catch (IOException e) {\n+            log.error(\"failed to add table backup file {} to tar file\", tableFile.getName());\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Find tables which have the requires_backup_support tag set\n+     *\n+     * @return  List<UUID>   - a list of UUIDs for all the tables which require backup support\n+     */\n+    public List<UUID> getTaggedTables() {\n+        TableRegistry tableRegistry = runtime.getTableRegistry();\n+        List<UUID> tables = tableRegistry\n+                .listTables()\n+                .stream()\n+                .filter(tableName -> tableRegistry\n+                        .getRegistryTable()\n+                        .get(tableName)\n+                        .getMetadata()\n+                        .getTableOptions()\n+                        .getRequiresBackupSupport())\n+                .map(tableName -> CorfuRuntime\n+                        .getStreamID(TableRegistry.getFullyQualifiedTableName(tableName)))\n+                .collect(Collectors.toList());\n+        log.info(\"{} tables need to be backed up: {}\", tables.size(), tables);", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NTAzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544075033", "bodyText": "is it possible that the user-specified path for backup tar is inside this temp directory?", "author": "pankti-m", "createdAt": "2020-12-16T07:36:34Z", "path": "runtime/src/main/java/org/corfudb/runtime/Backup.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.OpaqueStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Provides Corfu native backup support.\n+ *\n+ * Backup a selective set of tables specified by stream id or UFO table option.\n+ *\n+ * Steps:\n+ * 1. Open the selective set of tables as OpaqueStreams\n+ * 2. Write each table to individual temporary file\n+ * 3. Merge temporary backup files into a single .tar file under a user-given path\n+ */\n+@Slf4j\n+public class Backup {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which table's backup files are stored\n+    private final String backupTempDirPath;\n+\n+    // The stream IDs of tables which are backed up\n+    private final List<UUID> streamIDs;\n+\n+    // The snapshot address to back up\n+    private long timestamp;\n+\n+    // The Corfu Runtime which is performing the back up\n+    private final CorfuRuntime runtime;\n+\n+    // All tables in Corfu Db\n+    private List<UUID> allTablesInDb;\n+\n+    /**\n+     * Backup files of tables are temporarily stored under BACKUP_TEMP_DIR. They are deleted after backup finishes.\n+     */\n+    private static final String BACKUP_TEMP_DIR_PREFIX = \"corfu_backup_\";\n+\n+    /**\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param streamIDs     - the stream IDs of tables which are backed up\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, List<UUID> streamIDs, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = streamIDs;\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * The difference from the constructor above is that this one will automatically discover\n+     * tables which require back up from their tags.\n+     *\n+     * @param filePath      - the filePath where the generated backup tar file will be placed\n+     * @param runtime       - the runtime which is performing the back up\n+     * @throws IOException  - when failed to create the temp directory\n+     */\n+    public Backup(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.backupTempDirPath = Files.createTempDirectory(BACKUP_TEMP_DIR_PREFIX).toString();\n+        this.runtime = runtime;\n+        this.streamIDs = getTaggedTables();\n+    }\n+\n+    /**\n+     * Start the backup process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        this.timestamp = runtime.getAddressSpaceView().getLogTail();\n+\n+        try {\n+            backup();\n+            generateTarFile();\n+        } catch (IOException e) {\n+            log.error(\"failed to backup tables: {}\", streamIDs);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"backup completed\");\n+    }\n+\n+    /**\n+     * Check if table exists in Corfu Db\n+     *\n+     * @param streamId   the stream id of the table which is being checked\n+     * @return           true if table exists\n+     */\n+    private boolean tableExists(UUID streamId) {\n+        if (allTablesInDb == null) {\n+            allTablesInDb = runtime.getTableRegistry().listTables()\n+                    .stream()\n+                    .map(tableName -> CorfuRuntime.getStreamID(TableRegistry.getFullyQualifiedTableName(tableName)))\n+                    .collect(Collectors.toList());\n+        }\n+        return allTablesInDb.contains(streamId);\n+    }\n+\n+    /**\n+     * All temp backupTable files will be placed under BACKUP_DIR_PATH directory.\n+     *\n+     * @throws IOException\n+     */\n+    private void backup() throws IOException {\n+        if (streamIDs.isEmpty()) {\n+            log.warn(\"back up is called with empty streamIDs!\");\n+        }\n+\n+        for (UUID streamId : streamIDs) {\n+            if (!tableExists(streamId)) {\n+                log.warn(\"cannot back up a non-existent table: {}\", streamId);\n+                continue;\n+            }\n+            String fileName = backupTempDirPath + File.separator + streamId;\n+            backupTable(fileName, streamId);\n+        }\n+        log.info(\"successfully backed up {} tables to {} directory\", streamIDs.size(), backupTempDirPath);\n+    }\n+\n+    /**\n+     * Back up a single table\n+     *\n+     * If the log is trimmed at timestamp, the backupTable will fail.\n+     * If the table has no data to backupTable, it will create a file with empty contents.\n+     *\n+     * @param fileName   - the name of the backup file\n+     * @param uuid       - the uuid of the table which is being backed up\n+     * @throws IOException\n+     */\n+    private void backupTable(String fileName, UUID uuid) throws IOException {\n+        try (FileOutputStream fileOutput = new FileOutputStream(fileName)) {\n+            StreamOptions options = StreamOptions.builder()\n+                    .ignoreTrimmed(false)\n+                    .cacheEntries(false)\n+                    .build();\n+            Stream<OpaqueEntry> stream = (new OpaqueStream(runtime, runtime.getStreamsView().get(uuid, options))).streamUpTo(timestamp);\n+\n+            writeTableToFile(fileOutput, stream, uuid);\n+        } catch (IOException e) {\n+            log.error(\"failed to backup table {} to file {}\", uuid, fileName);\n+            throw e;\n+        }\n+\n+        log.info(\"{} table is backed up and stored to temp file {}\", uuid, fileName);\n+    }\n+\n+    private void writeTableToFile(FileOutputStream fileOutput, Stream<OpaqueEntry> stream, UUID uuid) throws IOException {\n+        Iterator<OpaqueEntry> iterator = stream.iterator();\n+        while (iterator.hasNext()) {\n+            OpaqueEntry lastEntry = iterator.next();\n+            List<SMREntry> smrEntries = lastEntry.getEntries().get(uuid);\n+            if (smrEntries != null) {\n+                Map<UUID, List<SMREntry>> map = new HashMap<>();\n+                map.put(uuid, smrEntries);\n+                OpaqueEntry newOpaqueEntry = new OpaqueEntry(lastEntry.getVersion(), map);\n+                OpaqueEntry.write(fileOutput, newOpaqueEntry);\n+            }\n+        }\n+        fileOutput.flush();\n+    }\n+\n+    /**\n+     * All generated files under tmp directory will be composed into one tar file\n+     *\n+     * @throws IOException\n+     */\n+    private void generateTarFile() throws IOException {\n+        File folder = new File(backupTempDirPath);\n+        File[] srcFiles = folder.listFiles();\n+        if (srcFiles == null) {\n+            log.debug(\"no backup file found under directory {}\", backupTempDirPath);\n+            return;\n+        }\n+\n+        try (FileOutputStream fileOutput = new FileOutputStream(filePath);\n+             TarArchiveOutputStream tarOutput = new TarArchiveOutputStream(fileOutput)) {\n+            for (File srcFile : srcFiles) {\n+                addToTarFile(srcFile, tarOutput);\n+            }\n+        } catch (IOException e) {\n+            log.error(\"failed to generate a backup tar file {}\", filePath);\n+            throw e;\n+        }\n+\n+        log.info(\"backup tar file is generated at {}\", filePath);\n+    }\n+\n+    /**\n+     * Add the table backup file to the backup tar file which contains all tables\n+     *\n+     * @param tableFile    - the table backup file\n+     * @param tarOutput    - the backup tar file which contains all tables\n+     * @throws IOException\n+     */\n+    private void addToTarFile(File tableFile,TarArchiveOutputStream tarOutput) throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(tableFile)) {\n+            TarArchiveEntry tarEntry = new TarArchiveEntry(tableFile);\n+            tarEntry.setName(tableFile.getName());\n+            tarOutput.putArchiveEntry(tarEntry);\n+\n+            int count;\n+            byte[] buf = new byte[1024];\n+            while ((count = fileInput.read(buf, 0, 1024)) != -1) {\n+                tarOutput.write(buf, 0, count);\n+            }\n+            tarOutput.closeArchiveEntry();\n+        } catch (IOException e) {\n+            log.error(\"failed to add table backup file {} to tar file\", tableFile.getName());\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Find tables which have the requires_backup_support tag set\n+     *\n+     * @return  List<UUID>   - a list of UUIDs for all the tables which require backup support\n+     */\n+    public List<UUID> getTaggedTables() {\n+        TableRegistry tableRegistry = runtime.getTableRegistry();\n+        List<UUID> tables = tableRegistry\n+                .listTables()\n+                .stream()\n+                .filter(tableName -> tableRegistry\n+                        .getRegistryTable()\n+                        .get(tableName)\n+                        .getMetadata()\n+                        .getTableOptions()\n+                        .getRequiresBackupSupport())\n+                .map(tableName -> CorfuRuntime\n+                        .getStreamID(TableRegistry.getFullyQualifiedTableName(tableName)))\n+                .collect(Collectors.toList());\n+        log.info(\"{} tables need to be backed up: {}\", tables.size(), tables);\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Cleanup the table backup files under the backupDir directory.\n+     */\n+    private void cleanup() {\n+        try {\n+            FileUtils.deleteDirectory(new File(backupTempDirPath));", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg0NzI0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544847245", "bodyText": "It is somehow possible. But considering the temporary directory is actually created in the middle of Backup process with a prefix in dir nameFiles.createTempDirectory(BACKUP_TEMP_DIR_PREFIX), I think it's really unlike that someone would give this exact filePath if not being deliberate.", "author": "Lujie1996", "createdAt": "2020-12-17T06:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4MDY5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544080696", "bodyText": "nit - indentation", "author": "pankti-m", "createdAt": "2020-12-16T07:48:10Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+/**\n+ * Provides Corfu native restore support. Works together with Backup.\n+ *\n+ * Restore all tables in the given backup .tar file which is generated by Corfu Backup.\n+ *\n+ * Steps:\n+ * 1. Open the given .tar file, obtain a set of backup files for tables\n+ * 2. Restore tables by committing transactions using the OpaqueEntries from table backup files\n+ */\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    /**\n+     * Start the restore process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            openTarFile();\n+            verify();\n+            restore();\n+        } catch (IOException e) {\n+            log.error(\"failed to restore from backup tar file {}\", filePath);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"restore completed\");\n+    }\n+\n+    private void restore() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = restoreTempDirPath + File.separator + streamId;\n+            try {\n+                restoreTable(fileName, streamId);\n+            } catch (IOException e) {\n+                log.error(\"failed to restore table {} from temp file {}\", streamId, fileName);\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Restore a single table\n+     *\n+     * @param fileName   - the name of the temp backup file\n+     * @param streamId   - the stream ID of the table which is to be restored\n+     * @throws IOException\n+     */\n+    private void restoreTable(String fileName, UUID streamId) throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(fileName)) {\n+            // Clear table before restore\n+            TxnContext txn = corfuStore.txn(CORFU_SYSTEM_NAMESPACE);\n+            SMREntry entry = new SMREntry(\"clear\", new Array[0], Serializers.PRIMITIVE);\n+            txn.logUpdate(streamId, entry);\n+\n+            long numEntries = 0;\n+            while (fileInput.available()> 0) {\n+                OpaqueEntry opaqueEntry = OpaqueEntry.read(fileInput);\n+                List<SMREntry> smrEntries = opaqueEntry.getEntries().get(streamId);\n+                if (smrEntries == null || smrEntries.isEmpty()) {\n+                    continue;\n+                }\n+\n+                txn.logUpdate(streamId, smrEntries);\n+                numEntries++;\n+            }\n+            txn.commit();\n+            log.info(\"completed restore of table {} with {} numEntries\", streamId, numEntries);\n+        } catch (FileNotFoundException e) {\n+            log.error(\"restoreTable can not find file {}\", fileName);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Open the backup tar file and save the table backups to tableDir directory\n+     */\n+    private void openTarFile() throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(filePath);\n+             TarArchiveInputStream tarInput = new TarArchiveInputStream(fileInput)) {\n+            getTablesFromTarFile(tarInput);", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg0OTEyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544849124", "bodyText": "Interesting. I tried to make it align but line 136 and 137 are actually auto-indented by pressing Enter from the line above them. Line 136 is aligned with FileInputStream and line 137 is indented as an inner scope code block.", "author": "Lujie1996", "createdAt": "2020-12-17T06:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4MDY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4NDU3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544084576", "bodyText": "it seems we read multiple SMR entries in each iteration.  Should this be incremented by only 1?", "author": "pankti-m", "createdAt": "2020-12-16T07:55:36Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+/**\n+ * Provides Corfu native restore support. Works together with Backup.\n+ *\n+ * Restore all tables in the given backup .tar file which is generated by Corfu Backup.\n+ *\n+ * Steps:\n+ * 1. Open the given .tar file, obtain a set of backup files for tables\n+ * 2. Restore tables by committing transactions using the OpaqueEntries from table backup files\n+ */\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    /**\n+     * Start the restore process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            openTarFile();\n+            verify();\n+            restore();\n+        } catch (IOException e) {\n+            log.error(\"failed to restore from backup tar file {}\", filePath);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"restore completed\");\n+    }\n+\n+    private void restore() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = restoreTempDirPath + File.separator + streamId;\n+            try {\n+                restoreTable(fileName, streamId);\n+            } catch (IOException e) {\n+                log.error(\"failed to restore table {} from temp file {}\", streamId, fileName);\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Restore a single table\n+     *\n+     * @param fileName   - the name of the temp backup file\n+     * @param streamId   - the stream ID of the table which is to be restored\n+     * @throws IOException\n+     */\n+    private void restoreTable(String fileName, UUID streamId) throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(fileName)) {\n+            // Clear table before restore\n+            TxnContext txn = corfuStore.txn(CORFU_SYSTEM_NAMESPACE);\n+            SMREntry entry = new SMREntry(\"clear\", new Array[0], Serializers.PRIMITIVE);\n+            txn.logUpdate(streamId, entry);\n+\n+            long numEntries = 0;\n+            while (fileInput.available()> 0) {\n+                OpaqueEntry opaqueEntry = OpaqueEntry.read(fileInput);\n+                List<SMREntry> smrEntries = opaqueEntry.getEntries().get(streamId);\n+                if (smrEntries == null || smrEntries.isEmpty()) {\n+                    continue;\n+                }\n+\n+                txn.logUpdate(streamId, smrEntries);\n+                numEntries++;", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MDA2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544850069", "bodyText": "Good point. Changed to numEntries += smrEntries.size();", "author": "Lujie1996", "createdAt": "2020-12-17T06:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4NDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4NTI0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544085241", "bodyText": "does this mean there is no backed up data for this stream?  If so, should we break here instead of continuing?", "author": "pankti-m", "createdAt": "2020-12-16T07:56:45Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+/**\n+ * Provides Corfu native restore support. Works together with Backup.\n+ *\n+ * Restore all tables in the given backup .tar file which is generated by Corfu Backup.\n+ *\n+ * Steps:\n+ * 1. Open the given .tar file, obtain a set of backup files for tables\n+ * 2. Restore tables by committing transactions using the OpaqueEntries from table backup files\n+ */\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    /**\n+     * Start the restore process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            openTarFile();\n+            verify();\n+            restore();\n+        } catch (IOException e) {\n+            log.error(\"failed to restore from backup tar file {}\", filePath);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"restore completed\");\n+    }\n+\n+    private void restore() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = restoreTempDirPath + File.separator + streamId;\n+            try {\n+                restoreTable(fileName, streamId);\n+            } catch (IOException e) {\n+                log.error(\"failed to restore table {} from temp file {}\", streamId, fileName);\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Restore a single table\n+     *\n+     * @param fileName   - the name of the temp backup file\n+     * @param streamId   - the stream ID of the table which is to be restored\n+     * @throws IOException\n+     */\n+    private void restoreTable(String fileName, UUID streamId) throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(fileName)) {\n+            // Clear table before restore\n+            TxnContext txn = corfuStore.txn(CORFU_SYSTEM_NAMESPACE);\n+            SMREntry entry = new SMREntry(\"clear\", new Array[0], Serializers.PRIMITIVE);\n+            txn.logUpdate(streamId, entry);\n+\n+            long numEntries = 0;\n+            while (fileInput.available()> 0) {\n+                OpaqueEntry opaqueEntry = OpaqueEntry.read(fileInput);\n+                List<SMREntry> smrEntries = opaqueEntry.getEntries().get(streamId);\n+                if (smrEntries == null || smrEntries.isEmpty()) {\n+                    continue;", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTI4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544851280", "bodyText": "continue and break should have the same effect here. continue will go back to while(fileInput.available() > 0) and then exits the loop.", "author": "Lujie1996", "createdAt": "2020-12-17T06:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4NTI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4NjI5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544086295", "bodyText": "Question - do we ever delete the backup tar file?  I think we dont.  Is it the expected behavior?", "author": "pankti-m", "createdAt": "2020-12-16T07:59:02Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+/**\n+ * Provides Corfu native restore support. Works together with Backup.\n+ *\n+ * Restore all tables in the given backup .tar file which is generated by Corfu Backup.\n+ *\n+ * Steps:\n+ * 1. Open the given .tar file, obtain a set of backup files for tables\n+ * 2. Restore tables by committing transactions using the OpaqueEntries from table backup files\n+ */\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    /**\n+     * Start the restore process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            openTarFile();\n+            verify();\n+            restore();\n+        } catch (IOException e) {\n+            log.error(\"failed to restore from backup tar file {}\", filePath);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"restore completed\");\n+    }\n+\n+    private void restore() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = restoreTempDirPath + File.separator + streamId;\n+            try {\n+                restoreTable(fileName, streamId);\n+            } catch (IOException e) {\n+                log.error(\"failed to restore table {} from temp file {}\", streamId, fileName);\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Restore a single table\n+     *\n+     * @param fileName   - the name of the temp backup file\n+     * @param streamId   - the stream ID of the table which is to be restored\n+     * @throws IOException\n+     */\n+    private void restoreTable(String fileName, UUID streamId) throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(fileName)) {\n+            // Clear table before restore\n+            TxnContext txn = corfuStore.txn(CORFU_SYSTEM_NAMESPACE);\n+            SMREntry entry = new SMREntry(\"clear\", new Array[0], Serializers.PRIMITIVE);\n+            txn.logUpdate(streamId, entry);\n+\n+            long numEntries = 0;\n+            while (fileInput.available()> 0) {\n+                OpaqueEntry opaqueEntry = OpaqueEntry.read(fileInput);\n+                List<SMREntry> smrEntries = opaqueEntry.getEntries().get(streamId);\n+                if (smrEntries == null || smrEntries.isEmpty()) {\n+                    continue;\n+                }\n+\n+                txn.logUpdate(streamId, smrEntries);\n+                numEntries++;\n+            }\n+            txn.commit();\n+            log.info(\"completed restore of table {} with {} numEntries\", streamId, numEntries);\n+        } catch (FileNotFoundException e) {\n+            log.error(\"restoreTable can not find file {}\", fileName);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Open the backup tar file and save the table backups to tableDir directory\n+     */\n+    private void openTarFile() throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(filePath);\n+             TarArchiveInputStream tarInput = new TarArchiveInputStream(fileInput)) {\n+            getTablesFromTarFile(tarInput);\n+        } catch (IOException e) {\n+            log.error(\"failed to get tables from tar file {}\", filePath);\n+            throw e;\n+        }\n+    }\n+\n+    private void getTablesFromTarFile(TarArchiveInputStream tarInput) throws IOException {\n+        int count;\n+        byte[] buf = new byte[1024];\n+        TarArchiveEntry entry;\n+        while ((entry = tarInput.getNextTarEntry()) != null) {\n+            streamIDs.add(UUID.fromString(entry.getName()));\n+            String tablePath = restoreTempDirPath + File.separator + entry.getName();\n+            try (FileOutputStream fos = new FileOutputStream(tablePath)) {\n+                while ((count = tarInput.read(buf, 0, 1024)) != -1) {\n+                    fos.write(buf, 0, count);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Some verification logic (TBD) such as\n+     * - Compare the user provided streamIds and names of table backups under tmp directory, or some metadata file\n+     * - Checksum\n+     */\n+    private void verify() {\n+        // TODO: verification logic to be implemented\n+    }\n+\n+    /**\n+     * Cleanup the table backup files under the tableDir directory.\n+     */\n+    private void cleanup() throws IOException {\n+        FileUtils.deleteDirectory(new File(restoreTempDirPath));", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MzIxMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544853213", "bodyText": "I think this is expected behavior. The tar file is provided by user and I think is better to be users' responsibility to collect or remove. Also deleting such tar file might be unexpected  for some users if they didn't read documents carefully. It's just safer to keep it instead of deleting it.", "author": "Lujie1996", "createdAt": "2020-12-17T06:55:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4NjI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4NzY3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544087675", "bodyText": "should we also clear the stream and get rid of any ongoing updates?", "author": "pankti-m", "createdAt": "2020-12-16T08:01:41Z", "path": "runtime/src/main/java/org/corfudb/runtime/Restore.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.corfudb.runtime;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.io.FileUtils;\n+import org.corfudb.protocols.logprotocol.OpaqueEntry;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.runtime.collections.CorfuStore;\n+import org.corfudb.runtime.collections.TxnContext;\n+import org.corfudb.util.serializer.Serializers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;\n+\n+/**\n+ * Provides Corfu native restore support. Works together with Backup.\n+ *\n+ * Restore all tables in the given backup .tar file which is generated by Corfu Backup.\n+ *\n+ * Steps:\n+ * 1. Open the given .tar file, obtain a set of backup files for tables\n+ * 2. Restore tables by committing transactions using the OpaqueEntries from table backup files\n+ */\n+@Slf4j\n+public class Restore {\n+\n+    // The path of backup tar file\n+    private final String filePath;\n+\n+    // The path of a temporary directory under which the unpacked table's backup files are stored\n+    private final String restoreTempDirPath;\n+\n+    // The stream IDs of tables which are restored\n+    private List<UUID> streamIDs;\n+\n+    // The Corfu Store associated with the runtime\n+    private CorfuStore corfuStore;\n+\n+    /**\n+     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.\n+     */\n+    private static final String RESTORE_TEMP_DIR_PREFIX = \"corfu_restore_\";\n+\n+    /***\n+     * @param filePath      - the path of backup tar file\n+     * @param runtime       - the runtime which is performing the restore\n+     * @throws IOException when failed to create the temp directory\n+     */\n+    public Restore(String filePath, CorfuRuntime runtime) throws IOException {\n+        this.filePath = filePath;\n+        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();\n+        this.streamIDs = new ArrayList<>();\n+        this.corfuStore = new CorfuStore(runtime);\n+    }\n+\n+    /**\n+     * Start the restore process\n+     *\n+     * @throws IOException\n+     */\n+    public void start() throws IOException {\n+        try {\n+            openTarFile();\n+            verify();\n+            restore();\n+        } catch (IOException e) {\n+            log.error(\"failed to restore from backup tar file {}\", filePath);\n+            throw e;\n+        } finally {\n+            cleanup();\n+        }\n+        log.info(\"restore completed\");\n+    }\n+\n+    private void restore() throws IOException {\n+        for (UUID streamId : streamIDs) {\n+            String fileName = restoreTempDirPath + File.separator + streamId;\n+            try {\n+                restoreTable(fileName, streamId);\n+            } catch (IOException e) {\n+                log.error(\"failed to restore table {} from temp file {}\", streamId, fileName);\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Restore a single table\n+     *\n+     * @param fileName   - the name of the temp backup file\n+     * @param streamId   - the stream ID of the table which is to be restored\n+     * @throws IOException\n+     */\n+    private void restoreTable(String fileName, UUID streamId) throws IOException {\n+        try (FileInputStream fileInput = new FileInputStream(fileName)) {\n+            // Clear table before restore\n+            TxnContext txn = corfuStore.txn(CORFU_SYSTEM_NAMESPACE);\n+            SMREntry entry = new SMREntry(\"clear\", new Array[0], Serializers.PRIMITIVE);", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NDYwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544854600", "bodyText": "When this particular SMREntry gets committed it will clear the stream to empty. Also, the team using this Restore guarantees that all services are shut down during restore so there will be no more ongoing updates after the clear request.", "author": "Lujie1996", "createdAt": "2020-12-17T06:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4NzY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5Mzg0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544093849", "bodyText": "nit - group all static imports together", "author": "pankti-m", "createdAt": "2020-12-16T08:13:04Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,640 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.collections.*;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TrimmedException;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n+import static org.junit.jupiter.api.Assertions.assertThrows;", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NDc3MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544854770", "bodyText": "Done. Thanks.", "author": "Lujie1996", "createdAt": "2020-12-17T06:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5Mzg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5NDI4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544094284", "bodyText": "Do we allow wildcard imports in tests?  If not, please do remove them", "author": "pankti-m", "createdAt": "2020-12-16T08:13:57Z", "path": "test/src/test/java/org/corfudb/runtime/BackupRestoreIT.java", "diffHunk": "@@ -0,0 +1,640 @@\n+package org.corfudb.runtime;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.corfudb.integration.AbstractIT;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.collections.*;", "originalCommit": "ef75599711f19eae54c59d89891e7ae6a7515ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NzEyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2783#discussion_r544857127", "bodyText": "Not sure if it is allowed. Just removed.", "author": "Lujie1996", "createdAt": "2020-12-17T07:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5NDI4NA=="}], "type": "inlineReview"}, {"oid": "f0f93ef2df99ae6b70f845358e5c69d04cc90579", "url": "https://github.com/CorfuDB/CorfuDB/commit/f0f93ef2df99ae6b70f845358e5c69d04cc90579", "message": "Backup and Restore", "committedDate": "2021-01-04T18:15:13Z", "type": "commit"}, {"oid": "f0f93ef2df99ae6b70f845358e5c69d04cc90579", "url": "https://github.com/CorfuDB/CorfuDB/commit/f0f93ef2df99ae6b70f845358e5c69d04cc90579", "message": "Backup and Restore", "committedDate": "2021-01-04T18:15:13Z", "type": "forcePushed"}]}