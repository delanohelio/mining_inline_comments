{"pr_number": 2641, "pr_title": "Support queryReplicationStatus() on non-leader Active Node.", "pr_createdAt": "2020-07-18T22:49:51Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2641", "timeline": [{"oid": "20469b160f9f302cd0634811caece580526b792c", "url": "https://github.com/CorfuDB/CorfuDB/commit/20469b160f9f302cd0634811caece580526b792c", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-20T19:10:34Z", "type": "forcePushed"}, {"oid": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "url": "https://github.com/CorfuDB/CorfuDB/commit/885eb3bff6b5f8440469a6e1f95049d1d48017f7", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-21T01:35:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNjk4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459126980", "bodyText": "this TODO was going to be exactly my question. Are you returning 0, 1?", "author": "annym", "createdAt": "2020-07-22T22:49:13Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -648,46 +647,26 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  Writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n-    public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n-        } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-        }\n-    }\n+    public void prepareToBecomeStandby() { }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n     public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            return replicationManager.queryReplicationStatus();\n-        } else {\n-            log.warn(\"Illegal queryReplicationStatus when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-            return INVALID_REPLICATION_STATUS;\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n+            return Integer.parseInt(logReplicationMetadataManager.getReplicationStatus());\n         }\n+        // TODO pankti - boolean cannot be parsed to int", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMjc4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459232783", "bodyText": "I changed it a bit but I think it will be best to change the metadata schema a bit and not have string for all types...", "author": "pankti-m", "createdAt": "2020-07-23T06:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNjk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNzQyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459127420", "bodyText": "we should probably have an else (localClusterDescriptor.getRole() == ClusterRole.Standby). Because what if the role of that node is INVALID, we probably shouldn't return anything and log an error/warning.", "author": "annym", "createdAt": "2020-07-22T22:50:28Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -648,46 +647,26 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  Writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n-    public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n-        } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-        }\n-    }\n+    public void prepareToBecomeStandby() { }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n     public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            return replicationManager.queryReplicationStatus();\n-        } else {\n-            log.warn(\"Illegal queryReplicationStatus when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-            return INVALID_REPLICATION_STATUS;\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTExMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459129112", "bodyText": "this commented code can be removed right? and also please move the comment up to where the runtime is now being created so we keep this reminder around for future references.", "author": "annym", "createdAt": "2020-07-22T22:55:16Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +67,108 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(0);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor();\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n+        this.parameters = params;\n \n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n+        this.config = parameters.getReplicationConfig();\n+        if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n+            // Avoid FSM being initialized if there are no streams to replicate\n+            throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n+        }\n \n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n+        DataSender dataSender = new CorfuDataSender(client);\n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTYyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459129629", "bodyText": "can we have the poll interval as a static field? we might want to also move this param to be configurable as we might need to adjust according to UI / SM polling frequency.", "author": "annym", "createdAt": "2020-07-22T22:56:47Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +67,108 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(0);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor();\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n+        this.parameters = params;\n \n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n+        this.config = parameters.getReplicationConfig();\n+        if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n+            // Avoid FSM being initialized if there are no streams to replicate\n+            throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n+        }\n \n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n+        DataSender dataSender = new CorfuDataSender(client);\n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n+        //this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n+\n+        this.logReplicationFSM = new LogReplicationFSM(this.runtime, config, params.getRemoteClusterDescriptor(),\n+                dataSender, readProcessor, logReplicationFSMWorkers);\n+\n+        this.logReplicationFSM.setTopologyConfigId(params.getTopologyConfigId());\n+\n+        this.metadataManager = metadataManager;\n+        lastAckedTsPoller.scheduleWithFixedDelay(new TsPollingTask(), 0, 15, TimeUnit.SECONDS);", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMDA0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459130048", "bodyText": "Also, it might be nice to give this thread some name that allows us to easily identify it.", "author": "annym", "createdAt": "2020-07-22T22:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxNjkyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459216920", "bodyText": "to make it configurable, will we have to make it a parameter of the serverContext?", "author": "pankti-m", "createdAt": "2020-07-23T05:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1MzM3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459853373", "bodyText": "Yes, if its too late to address in this PR you can add it to our issues list.", "author": "annym", "createdAt": "2020-07-24T05:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMDgxNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459130816", "bodyText": "this code seems to be repeated, right? We can call this(params, metadataManager, new DataSender(client)) from the above constructor and remove the repeated code?", "author": "annym", "createdAt": "2020-07-22T23:00:10Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +67,108 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(0);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor();\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n+        this.parameters = params;\n \n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n+        this.config = parameters.getReplicationConfig();\n+        if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n+            // Avoid FSM being initialized if there are no streams to replicate\n+            throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n+        }\n \n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n+        DataSender dataSender = new CorfuDataSender(client);\n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n+        //this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n+\n+        this.logReplicationFSM = new LogReplicationFSM(this.runtime, config, params.getRemoteClusterDescriptor(),\n+                dataSender, readProcessor, logReplicationFSMWorkers);\n+\n+        this.logReplicationFSM.setTopologyConfigId(params.getTopologyConfigId());\n+\n+        this.metadataManager = metadataManager;\n+        lastAckedTsPoller.scheduleWithFixedDelay(new TsPollingTask(), 0, 15, TimeUnit.SECONDS);\n     }\n \n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (transformation)\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n+    @VisibleForTesting\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params,\n+                                       LogReplicationMetadataManager metadataManager,\n+                                       DataSender dataSender) {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMjE0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459132145", "bodyText": "missing -> how many entries 'remain' to be...", "author": "annym", "createdAt": "2020-07-22T23:04:21Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,16 +242,58 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long queryStreamTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp, calculate how many entries to be sent for all replicated streams.", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMjgyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459132828", "bodyText": "probably this is a good use case to have an API to query the tails of a specific set of streams. Not that we have to do this now or on this PR, but we can keep this in mind!", "author": "annym", "createdAt": "2020-07-22T23:06:30Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,16 +242,58 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long queryStreamTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNDQ5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459134496", "bodyText": "maybe the name of this method could be more suggestive, so when reading the calculateRemainingEntriesToSend it's easier to understand the flow, perhaps queryMaxReplicatedStreamsTail? (or something in that line)", "author": "annym", "createdAt": "2020-07-22T23:11:54Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,16 +242,58 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long queryStreamTail() {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMTg3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459221873", "bodyText": "I changed it to getMaxReplicatedStreamsTail.  Let me know if it is clearer.", "author": "pankti-m", "createdAt": "2020-07-23T05:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNDQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNTc5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459135791", "bodyText": "Can we add a comment stating that this way of calculating the remaining entries to send might not be accurate...\nAlso, will we include the other precise option we discussed about?", "author": "annym", "createdAt": "2020-07-22T23:15:55Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,16 +242,58 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long queryStreamTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp, calculate how many entries to be sent for all replicated streams.\n+     *\n+     * @param\n+     */\n+    private int calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long timestamp = queryStreamTail();\n+        long remainingEntriesToSend = timestamp - ackedTimestamp;", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMzk2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459223965", "bodyText": "yes, I was not sure how to calculate that, but I think it should be in the same way - getAllTails().getStreamTails().filter(.....)", "author": "pankti-m", "createdAt": "2020-07-23T05:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1Mzc3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459853771", "bodyText": "Instead of the tails we need to query the address maps for each streams to replicate.", "author": "annym", "createdAt": "2020-07-24T05:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNTc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDY4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459154680", "bodyText": "I'm curious, if we update the topologyConfigId, do we always need to reset all other values? Let's say a new standby is added.. is this still needed?", "author": "annym", "createdAt": "2020-07-23T00:21:37Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -91,61 +91,64 @@ public long query(CorfuStoreMetadata.Timestamp timestamp, LogReplicationMetadata\n     }\n \n     public long getTopologyConfigId() {\n-        return query(null, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n+        return query(null, LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID);\n     }\n \n-    public String getVersion() { return queryString(null, LogReplicationMetadataType.VERSION); }\n+    public String getVersion() { return queryString(null, LogReplicationMetadataKey.KeyType.VERSION); }\n \n     public long getLastSnapStartTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_STARTED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_START);\n     }\n \n \n     public long getLastSnapTransferDoneTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_TRANSFERRED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_TRANSFERRED);\n     }\n \n     public long getLastSrcBaseSnapshotTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_APPLIED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_APPLIED);\n     }\n \n     public long getLastSnapSeqNum() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_SEQ_NUM);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_SEQ_NUM);\n     }\n \n     public long getLastProcessedLogTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_LOG_PROCESSED);\n+        return query(null, LogReplicationMetadataKey.KeyType.LAST_LOG_ENTRY_PROCESSED);\n     }\n \n-    public void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataType key, long val) {\n-        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key.getVal()).build();\n+    public void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataKey.KeyType type, long val) {\n+        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(type).build();\n         LogReplicationMetadataVal txVal = LogReplicationMetadataVal.newBuilder().setVal(Long.toString(val)).build();\n         txBuilder.update(metadataTableName, txKey, txVal, null);\n     }\n \n-    private void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataType key, String val) {\n-        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key.getVal()).build();\n+    private void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataKey.KeyType key, String val) {\n+        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key).build();\n         LogReplicationMetadataVal txVal = LogReplicationMetadataVal.newBuilder().setVal(val).build();\n         txBuilder.update(metadataTableName, txKey, txVal, null);\n     }\n \n     public void setupTopologyConfigId(long topologyConfigId) {\n         CorfuStoreMetadata.Timestamp timestamp = corfuStore.getTimestamp();\n-        long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n+        long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID);\n \n         if (topologyConfigId <= persistedTopologyConfigId) {\n             log.warn(\"Skip setupTopologyConfigId. the current topologyConfigId \" + topologyConfigId + \" is not larger than the persistedTopologyConfigID \" + persistedTopologyConfigId);\n-            return;\n         }\n \n         TxBuilder txBuilder = corfuStore.tx(namespace);\n \n-        for (LogReplicationMetadataType key : LogReplicationMetadataType.values()) {\n+        // TODO pankti: Change to set the topology config id and not other fields.  This cannot be changed now as it\n+        // fails later if anything is found not set.\n+        for (LogReplicationMetadataKey.KeyType type : LogReplicationMetadataKey.KeyType.values()) {\n             long val = Address.NON_ADDRESS;\n-            if (key == LogReplicationMetadataType.TOPOLOGY_CONFIG_ID) {\n+            if (type == LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID) {\n                 val = topologyConfigId;\n             }\n-            appendUpdate(txBuilder, key, val);\n+            if (type != LogReplicationMetadataKey.KeyType.UNRECOGNIZED) {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNTI3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459225277", "bodyText": "good question.  No we should not set everything, but that was being done when I made the change.  I removed it to only set topologyConfigId but later somewhere(I think negotiation response) we have a validation for version field not being empty, where it failed.  We should clean this up and fix it.\nI am thinking version is a valid thing to set in metadata so I can expose it in LogReplicationConfig alongwith streamsToReplicate.  But yes, here we should only set topologyConfigId.\nAlso, afaik topologyConfigId does not change when a standby is added.", "author": "pankti-m", "createdAt": "2020-07-23T05:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE5NDAzOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461194038", "bodyText": "I think we should not update other values in this function, because it causes more TX conflicts, and discovery service will shutdown. If the version filed is empty, we should initialize version somewhere...", "author": "zhangn49", "createdAt": "2020-07-27T21:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI5NzI5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461297298", "bodyText": "If the active cluster doesn't change, the source of data doesn't change, we don't need to reset the log replication metadata. So, we should have two API s:\n\njust  updateTopologyConfigId, if the active cluster doesn't change.\nupdate Topology Id and reset logReplicationMetadata if the active cluster change, as the source of data change.", "author": "xiaoqin2012", "createdAt": "2020-07-28T03:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NzYyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459157622", "bodyText": "We can remove this commented code.", "author": "annym", "createdAt": "2020-07-23T00:33:01Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/SinkBufferManager.java", "diffHunk": "@@ -161,6 +161,10 @@ public LogReplicationEntry processMsgAndBuffer(LogReplicationEntry dataMessage)\n         return null;\n     }\n \n+    /*private int calculateRemainingEntriesToReplicate() {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODc3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459158775", "bodyText": "Do we need an executor service for the standby? Cause it would only be updated to true (or 100) once the snapshot is applied, right? so we can just do it directly, instead of having a thread for this every 15 seconds... anyways its not changing.", "author": "annym", "createdAt": "2020-07-23T00:37:28Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -79,6 +84,13 @@\n     @Getter\n     private ObservableValue rxMessageCount = new ObservableValue(rxMessageCounter);\n \n+    /*\n+     * Periodic Thread which reads the sequence number of entries processed\n+     */\n+    private ScheduledExecutorService lastReplicatedEntryPoller = Executors.newSingleThreadScheduledExecutor();", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNzE3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459227175", "bodyText": "good idea.", "author": "pankti-m", "createdAt": "2020-07-23T05:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2MDE0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459160145", "bodyText": "rxState needs to be thread safe right?\nAlso, do we really need this distinction? anyways if it is in LOG_ENTRY_SYNC , data_consistent was set to true (maybe we need to confirm that it is set to true even if on re-instantiation it enters directly in log entry sync)", "author": "annym", "createdAt": "2020-07-23T00:43:05Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -386,4 +402,24 @@ public void shutdown() {\n         SNAPSHOT_SYNC,\n         LOG_ENTRY_SYNC\n     }\n+\n+    /**\n+     * In Snapshot Sync, if the StreamsSnapshotWriter is in the apply phase, the data is not yet\n+     * consistent and cannot be read by applications.  Data is always consistent during Log Entry Sync,\n+     * so always return true in that case.\n+     * @return boolean\n+     */\n+    private boolean isDataConsistent() {\n+        if (RxState.LOG_ENTRY_SYNC == rxState) {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2MTExMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459161111", "bodyText": "Pankti, do we have any test?", "author": "annym", "createdAt": "2020-07-23T00:46:47Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -648,46 +647,26 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  Writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n-    public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n-        } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-        }\n-    }\n+    public void prepareToBecomeStandby() { }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n     public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            return replicationManager.queryReplicationStatus();\n-        } else {\n-            log.warn(\"Illegal queryReplicationStatus when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-            return INVALID_REPLICATION_STATUS;\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n+            return Integer.parseInt(logReplicationMetadataManager.getReplicationStatus());", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIwMjA5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459202098", "bodyText": "no.. I did not add any tests for this change", "author": "pankti-m", "createdAt": "2020-07-23T03:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2MTExMQ=="}], "type": "inlineReview"}, {"oid": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "url": "https://github.com/CorfuDB/CorfuDB/commit/e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-23T06:15:43Z", "type": "forcePushed"}, {"oid": "86a7762a977595715cf79214e59c879f74a7a8bf", "url": "https://github.com/CorfuDB/CorfuDB/commit/86a7762a977595715cf79214e59c879f74a7a8bf", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-23T17:04:02Z", "type": "forcePushed"}, {"oid": "6a7f5abb89e68b88cd5edab548637f916f62a511", "url": "https://github.com/CorfuDB/CorfuDB/commit/6a7f5abb89e68b88cd5edab548637f916f62a511", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-23T18:41:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1MjI2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459652267", "bodyText": "Do we still need this function?", "author": "zhangn49", "createdAt": "2020-07-23T18:39:42Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -648,46 +648,29 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  Writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n-    public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n-        } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-        }\n-    }\n+    public void prepareToBecomeStandby() { }", "originalCommit": "86a7762a977595715cf79214e59c879f74a7a8bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NjcyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459666720", "bodyText": "We do not do anything here, but the SiteManager has a workflow for prepareToBecomeStandby().  So the SM adapter calls this function.  We can change the adapter to not invoke and remove this function, but I thought it is better to keep it in case something needs to be added here in future.", "author": "pankti-m", "createdAt": "2020-07-23T19:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1MjI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1NTU4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r460255583", "bodyText": "Pankti I was thinking given this, it might be safe to have a logging? .. not that we would do anything, but at least if they claim to have started the workflow we can confirm.", "author": "annym", "createdAt": "2020-07-24T19:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1MjI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1NzI5Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459657297", "bodyText": "Looks like remainingEntriesToSend is not used?", "author": "zhangn49", "createdAt": "2020-07-23T18:48:31Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,16 +221,61 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp\n+     * Note: This method of calculating the remaining entries to send is inaccurate because we consider the tail\n+     * of all streams(replicated and otherwise) in Corfu and compare it with the current entry sent.  It is possible\n+     * that the tail is far ahead but replicated streams have few entries to send.\n+     */\n+    private int calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long timestamp = getMaxReplicatedStreamsTail();\n+        long remainingEntriesToSend = timestamp - ackedTimestamp;\n+        int percentDone = (int) (ackedTimestamp/timestamp * 100);", "originalCommit": "6a7f5abb89e68b88cd5edab548637f916f62a511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2ODA4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459668086", "bodyText": "right.  I intended to use it somehow to calculate the remaining entries in a more accurate way, but it is not needed now.  Will remove.", "author": "pankti-m", "createdAt": "2020-07-23T19:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1NzI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1OTQ4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459659484", "bodyText": "Can we have a short comment on this dataConsistent?", "author": "zhangn49", "createdAt": "2020-07-23T18:52:31Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -79,6 +81,8 @@\n     @Getter\n     private ObservableValue rxMessageCount = new ObservableValue(rxMessageCounter);\n \n+    private AtomicInteger dataConsistent = new AtomicInteger(1);", "originalCommit": "6a7f5abb89e68b88cd5edab548637f916f62a511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2ODY2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459668667", "bodyText": "I have it in initCommonParams() where it first gets initialized but can move it here.", "author": "pankti-m", "createdAt": "2020-07-23T19:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1OTQ4NA=="}], "type": "inlineReview"}, {"oid": "4ff6b7041f13a0f5ca789ba2f351f3f79153d5f6", "url": "https://github.com/CorfuDB/CorfuDB/commit/4ff6b7041f13a0f5ca789ba2f351f3f79153d5f6", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-23T19:13:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4NjMwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459786301", "bodyText": "I am a little confused about why the dataConsistent is initialized as 1.\nIf a SNAPSHOT_MESSAGE comes, dataConsistent is still 1. Is it correct?", "author": "zhangn49", "createdAt": "2020-07-23T23:40:49Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -311,14 +313,17 @@ private void applySnapshotSync(LogReplicationEntry message) {\n         switch (message.getMetadata().getMessageMetadataType()) {\n             case SNAPSHOT_MESSAGE:\n                 snapshotWriter.apply(message);\n-                return;\n+                break;\n             case SNAPSHOT_END:\n+                dataConsistent.set(0);\n+                logReplicationMetadataManager.setDataConsistentOnStandby(String.valueOf(dataConsistent));", "originalCommit": "4ff6b7041f13a0f5ca789ba2f351f3f79153d5f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMzYyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459813620", "bodyText": "Yes, dataConsistent is 1 in any phase other than apply phase of the snapshot sync.  This is because only during apply phase we have an intermediate state where replicated data is being applied and applications can read inconsistent data.", "author": "pankti-m", "createdAt": "2020-07-24T01:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4NjMwMQ=="}], "type": "inlineReview"}, {"oid": "addc71bef331cfbb64a0be476e681efccc5ab88c", "url": "https://github.com/CorfuDB/CorfuDB/commit/addc71bef331cfbb64a0be476e681efccc5ab88c", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-25T22:23:17Z", "type": "forcePushed"}, {"oid": "e0b70b2971593b447f9c933c83f0af84a4b56bb2", "url": "https://github.com/CorfuDB/CorfuDB/commit/e0b70b2971593b447f9c933c83f0af84a4b56bb2", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-25T23:41:40Z", "type": "forcePushed"}, {"oid": "683566e7eb4d4b694027262a9c7e09c2ab50bbc0", "url": "https://github.com/CorfuDB/CorfuDB/commit/683566e7eb4d4b694027262a9c7e09c2ab50bbc0", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-26T01:29:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExNzQxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461117411", "bodyText": "Why don't we return here?", "author": "zhangn49", "createdAt": "2020-07-27T19:26:30Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -95,60 +95,63 @@ public long query(CorfuStoreMetadata.Timestamp timestamp, LogReplicationMetadata\n     }\n \n     public long getTopologyConfigId() {\n-        return query(null, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n+        return query(null, LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID);\n     }\n \n-    public String getVersion() { return queryString(null, LogReplicationMetadataType.VERSION); }\n+    public String getVersion() { return queryString(null, LogReplicationMetadataKey.KeyType.VERSION); }\n \n     public long getLastSnapStartTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_STARTED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_START);\n     }\n \n     public long getLastSnapTransferDoneTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_TRANSFERRED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_TRANSFERRED);\n     }\n \n     public long getLastAppliedBaseSnapshotTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_APPLIED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_APPLIED);\n     }\n \n     public long getLastSnapSeqNum() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_SEQ_NUM);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_SEQ_NUM);\n     }\n \n     public long getLastProcessedLogTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_LOG_PROCESSED);\n+        return query(null, LogReplicationMetadataKey.KeyType.LAST_LOG_ENTRY_PROCESSED);\n     }\n \n-    public void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataType key, long val) {\n-        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key.getVal()).build();\n+    public void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataKey.KeyType type, long val) {\n+        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(type).build();\n         LogReplicationMetadataVal txVal = LogReplicationMetadataVal.newBuilder().setVal(Long.toString(val)).build();\n         txBuilder.update(metadataTableName, txKey, txVal, null);\n     }\n \n-    private void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataType key, String val) {\n-        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key.getVal()).build();\n+    private void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataKey.KeyType key, String val) {\n+        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key).build();\n         LogReplicationMetadataVal txVal = LogReplicationMetadataVal.newBuilder().setVal(val).build();\n         txBuilder.update(metadataTableName, txKey, txVal, null);\n     }\n \n     public void setupTopologyConfigId(long topologyConfigId) {\n         CorfuStoreMetadata.Timestamp timestamp = corfuStore.getTimestamp();\n-        long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n+        long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID);\n \n         if (topologyConfigId <= persistedTopologyConfigId) {\n             log.warn(\"Skip setupTopologyConfigId. the current topologyConfigId \" + topologyConfigId + \" is not larger than the persistedTopologyConfigID \" + persistedTopologyConfigId);\n-            return;", "originalCommit": "683566e7eb4d4b694027262a9c7e09c2ab50bbc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE5NDc3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461194773", "bodyText": "I think it will bring some concurrent updates to some extent.", "author": "zhangn49", "createdAt": "2020-07-27T21:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExNzQxMQ=="}], "type": "inlineReview"}, {"oid": "31dc845d397c2c677b1720574629f03c01bc9393", "url": "https://github.com/CorfuDB/CorfuDB/commit/31dc845d397c2c677b1720574629f03c01bc9393", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-28T01:41:20Z", "type": "forcePushed"}, {"oid": "d7e300c9a33a8fa79f4ad19fb290139d1ce8c578", "url": "https://github.com/CorfuDB/CorfuDB/commit/d7e300c9a33a8fa79f4ad19fb290139d1ce8c578", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-28T21:49:01Z", "type": "forcePushed"}, {"oid": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "url": "https://github.com/CorfuDB/CorfuDB/commit/70a6226e297abbadcc0a92c03d35d15de8b2f86f", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-28T23:28:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDEwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461954102", "bodyText": "Remove not used code.", "author": "xiaoqin2012", "createdAt": "2020-07-28T23:39:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +70,89 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;\n+\n+    private static int FULL_REPLICATION_REMAINING_PERCENT = 100;\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this(params, metadataManager, new CorfuDataSender(client));\n     }\n \n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    @VisibleForTesting\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params,\n+                                       LogReplicationMetadataManager metadataManager,\n+                                       DataSender dataSender) {\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n-\n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n-\n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (transformation)\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n         this.parameters = params;\n+\n         this.config = parameters.getReplicationConfig();\n         if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n             // Avoid FSM being initialized if there are no streams to replicate\n             throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n         }\n \n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n         // If this runtime has opened other streams, it appends non opaque entries and because\n         // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n         // for log replication exclusively.\n-        this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n-        this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n+        //this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MjI0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462582241", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T20:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDk4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461954987", "bodyText": "For snapshot messages, should it be msgSeqNum? All snapshot messages have the same timestamp.", "author": "xiaoqin2012", "createdAt": "2020-07-28T23:41:56Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NDU0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462584548", "bodyText": "we are going to change this implementation before merging the PR", "author": "pankti-m", "createdAt": "2020-07-29T20:58:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1MzUwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461953502", "bodyText": "Can we use thread name : last-ackd-ts-reader?", "author": "zhangn49", "createdAt": "2020-07-28T23:37:08Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +70,89 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;\n+\n+    private static int FULL_REPLICATION_REMAINING_PERCENT = 100;\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this(params, metadataManager, new CorfuDataSender(client));\n     }\n \n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    @VisibleForTesting\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params,\n+                                       LogReplicationMetadataManager metadataManager,\n+                                       DataSender dataSender) {\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n-\n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n-\n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (transformation)\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n         this.parameters = params;\n+\n         this.config = parameters.getReplicationConfig();\n         if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n             // Avoid FSM being initialized if there are no streams to replicate\n             throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n         }\n \n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n         // If this runtime has opened other streams, it appends non opaque entries and because\n         // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n         // for log replication exclusively.\n-        this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n-        this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n+        //this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n \n         this.logReplicationFSM = new LogReplicationFSM(this.runtime, config, params.getRemoteClusterDescriptor(),\n                 dataSender, readProcessor, logReplicationFSMWorkers);\n+\n         this.logReplicationFSM.setTopologyConfigId(params.getTopologyConfigId());\n+\n+        this.metadataManager = metadataManager;\n+        lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor(\n+            new ThreadFactoryBuilder().setNameFormat(\"Last Ackd Ts Reader\").build());", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTMyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462009321", "bodyText": "+1 maybe ack-timestamp-poller or ack-timestamp-reader", "author": "annym", "createdAt": "2020-07-29T03:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1MzUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4Mjk5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462582994", "bodyText": "done.  changed to ack-timestamp-reader", "author": "pankti-m", "createdAt": "2020-07-29T20:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1MzUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1Mzk2Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461953966", "bodyText": "Should we remove these lines? as well as the above comments?", "author": "zhangn49", "createdAt": "2020-07-28T23:38:39Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +70,89 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;\n+\n+    private static int FULL_REPLICATION_REMAINING_PERCENT = 100;\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this(params, metadataManager, new CorfuDataSender(client));\n     }\n \n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    @VisibleForTesting\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params,\n+                                       LogReplicationMetadataManager metadataManager,\n+                                       DataSender dataSender) {\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n-\n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n-\n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (transformation)\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n         this.parameters = params;\n+\n         this.config = parameters.getReplicationConfig();\n         if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n             // Avoid FSM being initialized if there are no streams to replicate\n             throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n         }\n \n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n         // If this runtime has opened other streams, it appends non opaque entries and because\n         // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n         // for log replication exclusively.\n-        this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n-        this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n+        //this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODM2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462008364", "bodyText": "+1", "author": "annym", "createdAt": "2020-07-29T02:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1Mzk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MjAxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462582011", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T20:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1Mzk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDUwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461954504", "bodyText": "Will we add retry to each tx commit in metadata manager? I think we should have a max retry limit here.", "author": "zhangn49", "createdAt": "2020-07-28T23:40:22Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -137,21 +145,36 @@ public void setupTopologyConfigId(long topologyConfigId) {\n         long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n \n         if (topologyConfigId <= persistedTopologyConfigId) {\n-            log.warn(\"Skip setupTopologyConfigId. the current topologyConfigId \" + topologyConfigId + \" is not larger than the persistedTopologyConfigID \" + persistedTopologyConfigId);\n+            log.warn(\"Skip setupTopologyConfigId. the current topologyConfigId {} is not larger than the persistedTopologyConfigID {}\",\n+                topologyConfigId, persistedTopologyConfigId);\n             return;\n         }\n \n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n \n-        for (LogReplicationMetadataType key : LogReplicationMetadataType.values()) {\n-            long val = Address.NON_ADDRESS;\n-            if (key == LogReplicationMetadataType.TOPOLOGY_CONFIG_ID) {\n-                val = topologyConfigId;\n+        for (LogReplicationMetadataType type : LogReplicationMetadataType.values()) {\n+            if (type == LogReplicationMetadataType.TOPOLOGY_CONFIG_ID) {\n+                appendUpdate(txBuilder, type, topologyConfigId);\n+                try {\n+                    IRetry.build(IntervalRetry.class, () -> {", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDc4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461954782", "bodyText": "Is this correct to remove?", "author": "zhangn49", "createdAt": "2020-07-28T23:41:20Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -281,7 +304,6 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n         if (siteConfigID != persistSiteConfigID || ts != persistSnapStart || ts != persistSnapTranferDone) {\n             log.warn(\"topologyConfigId \" + siteConfigID + \" != \" + \" persist \" + persistSiteConfigID +  \" ts \" + ts +\n                     \" != \" + \"persistSnapTransferDone \" + persistSnapTranferDone);\n-            return;", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NzAyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462597028", "bodyText": "no.. dont know how it got removed..", "author": "pankti-m", "createdAt": "2020-07-29T21:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NTA2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461955064", "bodyText": "Is this correct to remove?", "author": "zhangn49", "createdAt": "2020-07-28T23:42:11Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -253,15 +277,14 @@ public void setLastSnapTransferDoneTimestamp(long topologyConfigId, long ts) {\n         if (topologyConfigId != persistedTopologyConfigId || ts <= persistedTopologyConfigId) {\n             log.warn(\"The metadata is older than the persisted one. Set snapshotStart topologyConfigId \" + topologyConfigId + \" ts \" + ts +\n                     \" persisteSiteConfigID \" + persistedTopologyConfigId + \" persistSnapStart \" + persistSnapStart);\n-            return;", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NTk3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462595977", "bodyText": "good catch.", "author": "pankti-m", "createdAt": "2020-07-29T21:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NTA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NTkxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461955918", "bodyText": "Should we init topologyConfigId in this function?", "author": "zhangn49", "createdAt": "2020-07-28T23:44:52Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -130,31 +128,37 @@ public LogReplicationSinkManager(String localCorfuEndpoint, LogReplicationConfig\n     @VisibleForTesting\n     public LogReplicationSinkManager(String localCorfuEndpoint, LogReplicationConfig config,\n                                      LogReplicationMetadataManager metadataManager, String pluginConfigFilePath) {\n-        this.logReplicationMetadataManager = metadataManager;\n         this.runtime =  CorfuRuntime.fromParameters(CorfuRuntime.CorfuRuntimeParameters.builder().build())\n                 .parseConfigurationString(localCorfuEndpoint).connect();\n         this.pluginConfigFilePath = pluginConfigFilePath;\n+        initCommonParams(metadataManager, config);\n+    }\n \n-        /*\n-         * When the server is up, it will be at LOG_ENTRY_SYNC state by default.\n-         * The sender will query receiver's status and decide what type of replication to start with.\n-         * It will transit to SNAPSHOT_SYNC state if it received a SNAPSHOT_START message from the sender.\n-         */\n-        this.rxState = RxState.LOG_ENTRY_SYNC;\n+    private void initCommonParams(LogReplicationMetadataManager metadataManager, LogReplicationConfig config) {", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNzM5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462607396", "bodyText": "topologyConfigId is not set for the test constructor.  But good catch, it is now not getting set in the first constructor also.  Adding it back.", "author": "pankti-m", "createdAt": "2020-07-29T21:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NTkxOA=="}], "type": "inlineReview"}, {"oid": "e96a7df7b17765518a44909363ab3b7260064e7b", "url": "https://github.com/CorfuDB/CorfuDB/commit/e96a7df7b17765518a44909363ab3b7260064e7b", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-29T01:46:58Z", "type": "forcePushed"}, {"oid": "3b5a84dac4f787ac072b979e2843c94450b85682", "url": "https://github.com/CorfuDB/CorfuDB/commit/3b5a84dac4f787ac072b979e2843c94450b85682", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-29T02:08:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTEwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461999107", "bodyText": "We can leave this for later, but we might need to change this API a bit, because in line with my previous comment, there can be multiple standby's, so we might want to return a map if no cluster Id is specified (so we return the status for all standby's), and accept the cluster Id as argument for another API.", "author": "annym", "createdAt": "2020-07-29T02:21:44Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -660,46 +659,38 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  If in the Active state, writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n     public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n+            log.info(\"Received a Request to Become Standby\");\n         } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n+            log.error(\"Received a Request to Become Standby in current role {}\", localClusterDescriptor.getRole());\n         }\n     }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n     public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxODAwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462518002", "bodyText": "we will have to do it now if we change the key in the replication status metadata protobuf", "author": "pankti-m", "createdAt": "2020-07-29T18:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTI5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461999298", "bodyText": "Should this be returning our proto ReplicationStatusVal?", "author": "annym", "createdAt": "2020-07-29T02:22:39Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -660,46 +659,38 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  If in the Active state, writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n     public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n+            log.info(\"Received a Request to Become Standby\");\n         } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n+            log.error(\"Received a Request to Become Standby in current role {}\", localClusterDescriptor.getRole());\n         }\n     }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n     public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMzkwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462523906", "bodyText": "ultimately yes.  But we will have to change the Cluster Manager adapter interfaces for that..", "author": "pankti-m", "createdAt": "2020-07-29T19:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMDc5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462000794", "bodyText": "nit -> Skip update of current version {} to {}, as they are the same.", "author": "annym", "createdAt": "2020-07-29T02:28:38Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -160,7 +173,8 @@ public void updateVersion(String version) {\n         String  persistedVersion = queryString(timestamp, LogReplicationMetadataType.VERSION);\n \n         if (persistedVersion.equals(version)) {\n-            log.warn(\"Skip update the current version {} with new version {} as they are the same\", persistedVersion, version);\n+            log.warn(\"Skip update the current version {} with new version {} as they are the same\",", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDg0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462594842", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMDc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMTEyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462001126", "bodyText": "typo -> STARTED", "author": "annym", "createdAt": "2020-07-29T02:29:54Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -217,14 +231,14 @@ public boolean setSrcBaseSnapshotStart(long topologyConfigId, long ts) {\n         // Update the topologyConfigId to fence all other transactions that update the metadata at the same time\n         appendUpdate(txBuilder, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID, topologyConfigId);\n \n-        // Setup the LAST_SNAPSHOT_STARTED\n+        // Setup the LAST_LAST_SNAPSHOT_STARTEDED", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NTI2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462595260", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMTEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMTIwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462001204", "bodyText": "same typo -> STARTED", "author": "annym", "createdAt": "2020-07-29T02:30:11Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -253,15 +267,14 @@ public void setLastSnapTransferDoneTimestamp(long topologyConfigId, long ts) {\n         if (topologyConfigId != persistedTopologyConfigId || ts <= persistedTopologyConfigId) {\n             log.warn(\"The metadata is older than the persisted one. Set snapshotStart topologyConfigId \" + topologyConfigId + \" ts \" + ts +\n                     \" persisteSiteConfigID \" + persistedTopologyConfigId + \" persistSnapStart \" + persistSnapStart);\n-            return;\n         }\n \n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n \n         //Update the topologyConfigId to fence all other transactions that update the metadata at the same time\n         appendUpdate(txBuilder, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID, topologyConfigId);\n \n-        //Setup the LAST_SNAPSHOT_STARTED\n+        //Setup the LAST_LAST_SNAPSHOT_STARTEDED", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjAzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462002036", "bodyText": "maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.", "author": "annym", "createdAt": "2020-07-29T02:33:13Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -301,21 +313,85 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n+    public void setReplicationRemainingPercent(long percentComplete) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public long getReplicationRemainingPercent() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record == null) {\n+            return 0;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMDcyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462600725", "bodyText": "From here we will only return the protobuf.. will have to add the log message in the adapter", "author": "pankti-m", "createdAt": "2020-07-29T21:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjY2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462002664", "bodyText": "Also here we can print some warning message or something for us to know its not yet persisted.", "author": "annym", "createdAt": "2020-07-29T02:35:34Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -301,21 +313,85 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n+    public void setReplicationRemainingPercent(long percentComplete) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public long getReplicationRemainingPercent() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record == null) {\n+            return 0;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getReplicationCompletion();\n+    }\n+\n+    public void setDataConsistentOnStandby(boolean isConsistent) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public boolean getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+\n+        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n+        // the standby rebooted?  In that case it is consistent\n+        if (record == null) {\n+            return false;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNTAyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462605022", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjg2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462002861", "bodyText": "Even If the standby rebooted it should be persisted, right? unless it rebooted right before updating this value. (Maybe we should ensure it is atomically updated when the last snapshot entry is written)", "author": "annym", "createdAt": "2020-07-29T02:36:24Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -301,21 +313,85 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n+    public void setReplicationRemainingPercent(long percentComplete) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public long getReplicationRemainingPercent() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record == null) {\n+            return 0;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getReplicationCompletion();\n+    }\n+\n+    public void setDataConsistentOnStandby(boolean isConsistent) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public boolean getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+\n+        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMzcyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462603726", "bodyText": "oh yes.. I think the todo is not required.  The last snapshot timestamp will have been set on reboot, unless it stopped just before updating this field.  In that case, will the transfer resume?", "author": "pankti-m", "createdAt": "2020-07-29T21:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMzEwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462003103", "bodyText": "break;", "author": "annym", "createdAt": "2020-07-29T02:37:27Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -301,21 +313,85 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n+    public void setReplicationRemainingPercent(long percentComplete) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public long getReplicationRemainingPercent() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record == null) {\n+            return 0;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getReplicationCompletion();\n+    }\n+\n+    public void setDataConsistentOnStandby(boolean isConsistent) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public boolean getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+\n+        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n+        // the standby rebooted?  In that case it is consistent\n+        if (record == null) {\n+            return false;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getDataConsistent();\n+    }\n+\n     @Override\n     public String toString() {\n-        String s = new String();\n-        s.concat(LogReplicationMetadataType.TOPOLOGY_CONFIG_ID.getVal() + \" \" + getTopologyConfigId() +\" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_STARTED.getVal() + \" \" + getLastSnapStartTimestamp() +\" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_TRANSFERRED.getVal() + \" \" + getLastSnapTransferDoneTimestamp() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_APPLIED.getVal() + \" \" + getLastAppliedBaseSnapshotTimestamp() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_SEQ_NUM.getVal() + \" \" + getLastSnapSeqNum() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_LOG_PROCESSED.getVal() + \" \" + getLastProcessedLogTimestamp() + \" \");\n-\n-        return s;\n+        StringBuilder builder = new StringBuilder();\n+        for (LogReplicationMetadataType type : LogReplicationMetadataType.values()) {\n+            builder.append(type).append(\": \");\n+            switch (type) {\n+                case TOPOLOGY_CONFIG_ID:\n+                    builder.append(getTopologyConfigId());\n+                    break;\n+                case LAST_SNAPSHOT_STARTED:\n+                   builder.append(getLastSnapStartTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_TRANSFERRED:\n+                   builder.append(getLastSnapTransferDoneTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_APPLIED:\n+                   builder.append(getLastAppliedBaseSnapshotTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_SEQ_NUM:\n+                   builder.append(getLastSnapSeqNum());\n+                   break;\n+                case LAST_LOG_ENTRY_PROCESSED:\n+                   builder.append(getLastProcessedLogTimestamp());\n+                   break;\n+                case REMAINING_REPLICATION_PERCENT:\n+                    builder.append(getReplicationRemainingPercent());", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNjEyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462606121", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMzEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMzM5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462003394", "bodyText": "missing DATA_CONSISTENT_ON_STANDBY?", "author": "annym", "createdAt": "2020-07-29T02:38:40Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -301,21 +313,85 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n+    public void setReplicationRemainingPercent(long percentComplete) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public long getReplicationRemainingPercent() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record == null) {\n+            return 0;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getReplicationCompletion();\n+    }\n+\n+    public void setDataConsistentOnStandby(boolean isConsistent) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public boolean getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+\n+        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n+        // the standby rebooted?  In that case it is consistent\n+        if (record == null) {\n+            return false;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getDataConsistent();\n+    }\n+\n     @Override\n     public String toString() {\n-        String s = new String();\n-        s.concat(LogReplicationMetadataType.TOPOLOGY_CONFIG_ID.getVal() + \" \" + getTopologyConfigId() +\" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_STARTED.getVal() + \" \" + getLastSnapStartTimestamp() +\" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_TRANSFERRED.getVal() + \" \" + getLastSnapTransferDoneTimestamp() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_APPLIED.getVal() + \" \" + getLastAppliedBaseSnapshotTimestamp() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_SEQ_NUM.getVal() + \" \" + getLastSnapSeqNum() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_LOG_PROCESSED.getVal() + \" \" + getLastProcessedLogTimestamp() + \" \");\n-\n-        return s;\n+        StringBuilder builder = new StringBuilder();\n+        for (LogReplicationMetadataType type : LogReplicationMetadataType.values()) {\n+            builder.append(type).append(\": \");\n+            switch (type) {\n+                case TOPOLOGY_CONFIG_ID:\n+                    builder.append(getTopologyConfigId());\n+                    break;\n+                case LAST_SNAPSHOT_STARTED:\n+                   builder.append(getLastSnapStartTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_TRANSFERRED:\n+                   builder.append(getLastSnapTransferDoneTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_APPLIED:\n+                   builder.append(getLastAppliedBaseSnapshotTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_SEQ_NUM:\n+                   builder.append(getLastSnapSeqNum());\n+                   break;\n+                case LAST_LOG_ENTRY_PROCESSED:\n+                   builder.append(getLastProcessedLogTimestamp());\n+                   break;\n+                case REMAINING_REPLICATION_PERCENT:\n+                    builder.append(getReplicationRemainingPercent());\n+                default:", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTE1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462005155", "bodyText": "This class has a receive method where we first receive messages. And there we have some logic to process a SNAPSHOT_START marker, so I think we should set dataConsistent to false in processSnapshotStart. As we now we're starting the transfer of a snapshot sync, so from that point until the snapshot_end is received and applied is when we'll set to true.", "author": "annym", "createdAt": "2020-07-29T02:45:25Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -398,14 +401,17 @@ private void processSnapshotMessage(LogReplicationEntry message) {\n         switch (message.getMetadata().getMessageMetadataType()) {\n             case SNAPSHOT_MESSAGE:\n                 snapshotWriter.apply(message);\n-                return;\n+                break;\n             case SNAPSHOT_END:\n+                dataConsistent.set(false);", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjcyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462006728", "bodyText": "So we can remove it from here and set it on the reception of the start marker.", "author": "annym", "createdAt": "2020-07-29T02:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxMjgyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462612829", "bodyText": "but the data will be consistent and can be read during the transfer, right?  Only when it is being applied, it is not consistent.", "author": "pankti-m", "createdAt": "2020-07-29T21:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTUzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462005531", "bodyText": "To keep a sense of atomicity maybe we can have a private method setDataConsistency(boolean consistent) something like that where we update the local variable and the persisted...", "author": "annym", "createdAt": "2020-07-29T02:47:00Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -398,14 +401,17 @@ private void processSnapshotMessage(LogReplicationEntry message) {\n         switch (message.getMetadata().getMessageMetadataType()) {\n             case SNAPSHOT_MESSAGE:\n                 snapshotWriter.apply(message);\n-                return;\n+                break;\n             case SNAPSHOT_END:\n+                dataConsistent.set(false);\n+                logReplicationMetadataManager.setDataConsistentOnStandby(dataConsistent.get());\n                 snapshotWriter.snapshotTransferDone(message);\n                 completeSnapshotApply(message);\n-                return;\n+                dataConsistent.set(true);", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNjM5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462616396", "bodyText": "sure", "author": "pankti-m", "createdAt": "2020-07-29T22:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMDgzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462000835", "bodyText": "Perhaps we can add some validation that this indeed a correct percent from 0 to 100. We just store it as a string later and then parse back as an integer. If it's incorrect it will throw a NumberFormatException", "author": "PavelZaytsev", "createdAt": "2020-07-29T02:28:51Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp acked by the receiver, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp Timestamp ack'd by the receiver\n+     *\n+     * For Log Entry Sync, this function returns the total number of entries remaining to be sent across all replicated\n+     * streams.\n+     * For Snapshot Sync, each entry sent is a snapshot.  So this function returns the total number of snapshots\n+     * remaining to be sent.\n+     * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n+     */\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n+\n+        if (ackedTimestamp == Address.NON_ADDRESS) {\n+            return FULL_REPLICATION_REMAINING_PERCENT;\n+        }\n+        long remainingEntriesToSend = 0;\n+        for (String stream : config.getStreamsToReplicate()) {\n+            UUID streamId = CorfuRuntime.getStreamID(stream);\n+            StreamAddressRange range = new StreamAddressRange(streamId, maxReplicatedStreamTail, ackedTimestamp);\n+            StreamAddressSpace addressSpace = runtime.getSequencerView().getStreamAddressSpace(range);\n+            Roaring64NavigableMap map = addressSpace.getAddressesInRange(range);\n+            remainingEntriesToSend += map.getLongCardinality();\n+        }\n+        return remainingEntriesToSend;\n+    }\n+\n+    /**\n+     * Task which periodically updates the metadata table with replication completion percentage\n+     */\n+    private class TsPollingTask implements Runnable {\n+        @Override\n+        public void run() {\n+            long remainingReplicationStatus = calculateRemainingEntriesToSend(lastAckedTimestamp.get());", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5Mzg1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462593856", "bodyText": "This protobuf has changed and takes a long now.. so there is no conversion.", "author": "pankti-m", "createdAt": "2020-07-29T21:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMDgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjgwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462002804", "bodyText": "Does not seem to be used", "author": "PavelZaytsev", "createdAt": "2020-07-29T02:36:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java", "diffHunk": "@@ -21,12 +21,12 @@\n import java.util.UUID;\n \n /**\n- * This class manages Log Replication for multiple remote (standby) cluster's.\n+ * This class manages Log Replication for multiple remote (standby) clusters.\n  */\n @Slf4j\n public class CorfuReplicationManager {\n \n-    public final static int PERCENTAGE_BASE = 100;\n+    public final static int PERCENTAGE_HUNDRED = 100;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODQxMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462008412", "bodyText": "I just want to clarify. ackedTimestamp is the last timestamp acked by the receiver that we receive when the entry is replicated, so it should be smaller than the maxReplicatedStreamTail, for the range to be valid right?", "author": "PavelZaytsev", "createdAt": "2020-07-29T02:57:48Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp acked by the receiver, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp Timestamp ack'd by the receiver\n+     *\n+     * For Log Entry Sync, this function returns the total number of entries remaining to be sent across all replicated\n+     * streams.\n+     * For Snapshot Sync, each entry sent is a snapshot.  So this function returns the total number of snapshots\n+     * remaining to be sent.\n+     * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n+     */\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n+\n+        if (ackedTimestamp == Address.NON_ADDRESS) {\n+            return FULL_REPLICATION_REMAINING_PERCENT;\n+        }\n+        long remainingEntriesToSend = 0;\n+        for (String stream : config.getStreamsToReplicate()) {\n+            UUID streamId = CorfuRuntime.getStreamID(stream);\n+            StreamAddressRange range = new StreamAddressRange(streamId, maxReplicatedStreamTail, ackedTimestamp);", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MTUwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462591503", "bodyText": "good question.  This range is used in StreamAddressSpace.getAddressesInRange() below on line 284.  That function takes a range where start>end.", "author": "pankti-m", "createdAt": "2020-07-29T21:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTc2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462009769", "bodyText": "no need to do this for this review, but we might add an issue to track the fact that we should move this configuration out to the config file.", "author": "annym", "createdAt": "2020-07-29T03:02:38Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +70,89 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MDg5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462580898", "bodyText": "I will add it in the follow up PR #2657", "author": "pankti-m", "createdAt": "2020-07-29T20:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMTAwOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462011008", "bodyText": "Actually, this is a bit weird. But I realized it the other day while looking at other things. This method for the Source is not really never called. All the logic for processing ACKs is taken care in the SnapshotSender and LogEntrySender respectively, so it is there where we should be setting this lastAckedTimestamp.", "author": "annym", "createdAt": "2020-07-29T03:07:35Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjIyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462012222", "bodyText": "Actually, I think we have a major concern here and its that SnapshotSender does not really accumulate intermediate SNAPSHOT_REPLICATED, so it only updates at the end.. But you can bypass that (for now) by updating when you send something...", "author": "annym", "createdAt": "2020-07-29T03:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMTAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjU3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462012577", "bodyText": "s -> streamName", "author": "annym", "createdAt": "2020-07-29T03:14:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NTM3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462585373", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T20:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjc2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462012768", "bodyText": "if tailMap.contains(streamUuid)?", "author": "annym", "createdAt": "2020-07-29T03:14:45Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NjU5Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462586597", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNjQ2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462016463", "bodyText": "Is this true? what if the maxReplicatedStreamTail is -1, that means there is no data so remaining is 0%, right?", "author": "annym", "createdAt": "2020-07-29T03:29:12Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp acked by the receiver, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp Timestamp ack'd by the receiver\n+     *\n+     * For Log Entry Sync, this function returns the total number of entries remaining to be sent across all replicated\n+     * streams.\n+     * For Snapshot Sync, each entry sent is a snapshot.  So this function returns the total number of snapshots\n+     * remaining to be sent.\n+     * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n+     */\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n+\n+        if (ackedTimestamp == Address.NON_ADDRESS) {\n+            return FULL_REPLICATION_REMAINING_PERCENT;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNjU3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462016576", "bodyText": "We should add tests to cover all these cases!", "author": "annym", "createdAt": "2020-07-29T03:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNjQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4OTk2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462589964", "bodyText": "Added the case for maxTail = -1.\nYes for tests.", "author": "pankti-m", "createdAt": "2020-07-29T21:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNjQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzM1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462017350", "bodyText": "No need, the address map you requested is already confined to that range, you can directly: addressSpace.getAddressMap().getLongCardinality()", "author": "annym", "createdAt": "2020-07-29T03:32:59Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp acked by the receiver, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp Timestamp ack'd by the receiver\n+     *\n+     * For Log Entry Sync, this function returns the total number of entries remaining to be sent across all replicated\n+     * streams.\n+     * For Snapshot Sync, each entry sent is a snapshot.  So this function returns the total number of snapshots\n+     * remaining to be sent.\n+     * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n+     */\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n+\n+        if (ackedTimestamp == Address.NON_ADDRESS) {\n+            return FULL_REPLICATION_REMAINING_PERCENT;\n+        }\n+        long remainingEntriesToSend = 0;\n+        for (String stream : config.getStreamsToReplicate()) {\n+            UUID streamId = CorfuRuntime.getStreamID(stream);\n+            StreamAddressRange range = new StreamAddressRange(streamId, maxReplicatedStreamTail, ackedTimestamp);\n+            StreamAddressSpace addressSpace = runtime.getSequencerView().getStreamAddressSpace(range);\n+            Roaring64NavigableMap map = addressSpace.getAddressesInRange(range);", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MjM0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462592349", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzQ3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462017477", "bodyText": "should we add a logging before returning?", "author": "annym", "createdAt": "2020-07-29T03:33:35Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp acked by the receiver, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp Timestamp ack'd by the receiver\n+     *\n+     * For Log Entry Sync, this function returns the total number of entries remaining to be sent across all replicated\n+     * streams.\n+     * For Snapshot Sync, each entry sent is a snapshot.  So this function returns the total number of snapshots\n+     * remaining to be sent.\n+     * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n+     */\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n+\n+        if (ackedTimestamp == Address.NON_ADDRESS) {\n+            return FULL_REPLICATION_REMAINING_PERCENT;\n+        }\n+        long remainingEntriesToSend = 0;\n+        for (String stream : config.getStreamsToReplicate()) {\n+            UUID streamId = CorfuRuntime.getStreamID(stream);\n+            StreamAddressRange range = new StreamAddressRange(streamId, maxReplicatedStreamTail, ackedTimestamp);\n+            StreamAddressSpace addressSpace = runtime.getSequencerView().getStreamAddressSpace(range);\n+            Roaring64NavigableMap map = addressSpace.getAddressesInRange(range);\n+            remainingEntriesToSend += map.getLongCardinality();\n+        }\n+        return remainingEntriesToSend;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MzE5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462593193", "bodyText": "we can add a trace.. because this thread runs every 15seconds right now and other levels will flood the log.", "author": "pankti-m", "createdAt": "2020-07-29T21:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzc0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462017747", "bodyText": "Where is this being used?", "author": "annym", "createdAt": "2020-07-29T03:34:39Z", "path": "test/src/test/java/org/corfudb/integration/LogReplicationIT.java", "diffHunk": "@@ -1380,6 +1377,11 @@ private void verifyPersistedLogEntryMetadata() {\n         assertThat(expectedAckTimestamp == lastLogProcessed).isTrue();\n     }\n \n+    private void verifyRemainingReplicationPercent(long remainingPercent) {", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNjY1NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462616654", "bodyText": "I did not remove so that it can be used later when we add tests", "author": "pankti-m", "createdAt": "2020-07-29T22:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzc0Nw=="}], "type": "inlineReview"}, {"oid": "d8915819849936664d64ecd85853c30a9296398b", "url": "https://github.com/CorfuDB/CorfuDB/commit/d8915819849936664d64ecd85853c30a9296398b", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-30T01:01:40Z", "type": "forcePushed"}, {"oid": "4995f5222b57ea20528dc2e336e532affae0c17a", "url": "https://github.com/CorfuDB/CorfuDB/commit/4995f5222b57ea20528dc2e336e532affae0c17a", "message": "Cleanup Snapshot Sync ACK handling\n\n- Remove LogReplicationSource logic for handling ACKs (not used)", "committedDate": "2020-07-30T20:03:29Z", "type": "forcePushed"}, {"oid": "4b3c2c042cebde1c55ccbc7969989adc597b21df", "url": "https://github.com/CorfuDB/CorfuDB/commit/4b3c2c042cebde1c55ccbc7969989adc597b21df", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-31T20:55:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwMjk5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r463902992", "bodyText": "It's not guaranteed to always place the local cluster in the 0th index position right?\nAm I mistaken?", "author": "hisundar", "createdAt": "2020-08-01T01:24:13Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/CorfuReplicationClusterManagerBaseAdapter.java", "diffHunk": "@@ -45,7 +46,8 @@ public void prepareToBecomeStandby() {\n         corfuReplicationDiscoveryService.prepareToBecomeStandby();\n     }\n \n-    public int queryReplicationStatus() {\n-        return corfuReplicationDiscoveryService.queryReplicationStatus();\n+    public LogReplicationMetadata.ReplicationStatusVal queryReplicationStatus() {\n+        return corfuReplicationDiscoveryService.queryReplicationStatus(\n+            topologyConfig.getClusters(0).getId());", "originalCommit": "4b3c2c042cebde1c55ccbc7969989adc597b21df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwMzM5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r463903394", "bodyText": "I only see one type - is it possible to overload the queryReplicationStatus to return the full map?", "author": "hisundar", "createdAt": "2020-08-01T01:27:36Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -660,46 +664,36 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  If in the Active state, writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n     public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n+            log.info(\"Received a Request to Become Standby\");\n         } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n+            log.error(\"Received a Request to Become Standby in current role {}\", localClusterDescriptor.getRole());\n         }\n     }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n-    public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            return replicationManager.queryReplicationStatus();\n-        } else {\n-            log.warn(\"Illegal queryReplicationStatus when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-            return INVALID_REPLICATION_STATUS;\n+    public LogReplicationMetadata.ReplicationStatusVal queryReplicationStatus(String clusterId) {", "originalCommit": "4b3c2c042cebde1c55ccbc7969989adc597b21df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "052970b14bbad9f8e0c8a401351736b0c7bd8e65", "url": "https://github.com/CorfuDB/CorfuDB/commit/052970b14bbad9f8e0c8a401351736b0c7bd8e65", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-08-01T02:41:10Z", "type": "commit"}, {"oid": "052970b14bbad9f8e0c8a401351736b0c7bd8e65", "url": "https://github.com/CorfuDB/CorfuDB/commit/052970b14bbad9f8e0c8a401351736b0c7bd8e65", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-08-01T02:41:10Z", "type": "forcePushed"}]}