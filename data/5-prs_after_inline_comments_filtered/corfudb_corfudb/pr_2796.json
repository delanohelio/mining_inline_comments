{"pr_number": 2796, "pr_title": "Protobuf RPC Schema and Protobuf handshake", "pr_createdAt": "2020-10-20T23:26:47Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2796", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2MjI4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509662289", "bodyText": "You don't need this check. It's already done above.", "author": "vjeko", "createdAt": "2020-10-21T20:21:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n \n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n             log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n                     READ_TIMEOUT_HANDLER);\n+\n             // Remove the handler from the pipeline. Also remove the reference of the context from\n             // the handler so that it does not disconnect the channel.\n             ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n+\n+            clientId = getUUID(handshakeRequest.getClientId());\n+            serverId = getUUID(handshakeRequest.getServerId());\n+        } else {\n+            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n             if (this.state.completed()) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2NDI3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509664279", "bodyText": "Also, can we change state to handshake? It clearer this way and more consistent.", "author": "vjeko", "createdAt": "2020-10-21T20:23:48Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n \n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n             log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n                     READ_TIMEOUT_HANDLER);\n+\n             // Remove the handler from the pipeline. Also remove the reference of the context from\n             // the handler so that it does not disconnect the channel.\n             ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n+\n+            clientId = getUUID(handshakeRequest.getClientId());\n+            serverId = getUUID(handshakeRequest.getServerId());\n+        } else {\n+            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n             if (this.state.completed()) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2NzYxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509667614", "bodyText": "Is the first RequestMsg always going to be a handshake request? It might be a good idea to check anyways.", "author": "vjeko", "createdAt": "2020-10-21T20:27:14Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2ODMzMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509668330", "bodyText": "You should really try to avoid unassigned variables. Take a look at my comment about the return statement below.", "author": "vjeko", "createdAt": "2020-10-21T20:28:24Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3MDYzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509670637", "bodyText": "You should make this a precondition check as well. Currently you have:\n\nif (A) {\n  X...\n} else {\n  Y...\n}\n\nZ...\n\nYou can re-organize this:\nif (!A) {\n  Y...\n}\n\nX...\nZ...\n\nThis way you avoid unassigned variables.", "author": "vjeko", "createdAt": "2020-10-21T20:32:12Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n \n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n             log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n                     READ_TIMEOUT_HANDLER);\n+\n             // Remove the handler from the pipeline. Also remove the reference of the context from\n             // the handler so that it does not disconnect the channel.\n             ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n+\n+            clientId = getUUID(handshakeRequest.getClientId());\n+            serverId = getUUID(handshakeRequest.getServerId());\n+        } else {\n+            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n             if (this.state.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    log.debug(\"channelRead: Dropping message: {}\", ((CorfuMsg) m).getMsgType().name());\n-                } catch (Exception ex) {\n-                    log.error(\"channelRead: Message received by Server is not a valid \" +\n-                            \"CorfuMsg type.\");\n-                }\n+                // The message was unregistered, we are dropping it.\n+                log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);\n             }\n+\n             return;", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY4MzIzOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509683238", "bodyText": "You should make this a precondition check and return. This will reduce the amount of if-else nesting.", "author": "vjeko", "createdAt": "2020-10-21T20:47:57Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -231,7 +244,14 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n             log.debug(\"write: Handshake already completed, not appending corfu message to queue\");\n             super.write(ctx, msg, promise);", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5NzQ1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509697451", "bodyText": "Style: space after if.", "author": "vjeko", "createdAt": "2020-10-21T21:07:25Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5NzU4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509697588", "bodyText": "Style.", "author": "vjeko", "createdAt": "2020-10-21T21:07:34Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwMDA2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509700067", "bodyText": "Check not needed.", "author": "vjeko", "createdAt": "2020-10-21T21:10:47Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {\n+                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n+                        READ_TIMEOUT_HANDLER);\n+\n+                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+                corfuVersion = handshakeResponse.getCorfuVersion();\n+                serverId = getUUID(handshakeResponse.getServerId());\n \n-        try {\n-            handshakeResponse = (CorfuPayloadMsg<HandshakeResponse>) m;\n-            log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler. \" +\n-                    \"Send upstream only if handshake succeeded.\", e);\n-            if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n-                super.channelRead(ctx, m);\n+                // Remove the handler from the pipeline. Also remove the reference of the context from\n+                // the handler so that it does not disconnect the channel.\n+                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    CorfuMsg msg = (CorfuMsg) m;\n+                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n+                if (this.handshakeState.completed()) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI4MDQ0Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r510280446", "bodyText": "@vjeko Is there a reason why this is checked multiple times in the original code? I was under the impression that the handshake state could change between the first check and the second, so this was needed to avoid message loss.", "author": "zfrenette", "createdAt": "2020-10-22T16:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwMDA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNTkzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509705936", "bodyText": "Avoid unassigned variables.", "author": "vjeko", "createdAt": "2020-10-21T21:17:56Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNjgzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509706835", "bodyText": "Is there a reason why return is omitted here? In this case, you still go on and do your handshake computation.", "author": "vjeko", "createdAt": "2020-10-21T21:18:59Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {\n+                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n+                        READ_TIMEOUT_HANDLER);\n+\n+                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+                corfuVersion = handshakeResponse.getCorfuVersion();\n+                serverId = getUUID(handshakeResponse.getServerId());\n \n-        try {\n-            handshakeResponse = (CorfuPayloadMsg<HandshakeResponse>) m;\n-            log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler. \" +\n-                    \"Send upstream only if handshake succeeded.\", e);\n-            if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n-                super.channelRead(ctx, m);\n+                // Remove the handler from the pipeline. Also remove the reference of the context from\n+                // the handler so that it does not disconnect the channel.\n+                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    CorfuMsg msg = (CorfuMsg) m;\n+                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n+                if (this.handshakeState.completed()) {\n+                    // Only send upstream if handshake is complete.\n+                    super.channelRead(ctx, m);\n+                }\n+            }\n+        } else {\n+            try {\n+                CorfuMsg msg = (CorfuMsg) m;\n+                if (this.handshakeState.completed()) {\n+                    // Only send upstream if handshake is complete.\n+                    super.channelRead(ctx, msg);\n+                } else {\n                     log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n-                } catch (Exception ex) {\n-                    log.error(\"channelRead: Message received is not a valid CorfuMsg type.\");\n                 }\n+            } catch (Exception ex) {\n+                log.error(\"channelRead: Message received is not a valid CorfuMsg or ResponseMsg type.\");\n             }\n-            return;", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwOTU2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509709564", "bodyText": "I would make this your base-case. It should simplify your logic.", "author": "vjeko", "createdAt": "2020-10-21T21:22:15Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {\n+                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n+                        READ_TIMEOUT_HANDLER);\n+\n+                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+                corfuVersion = handshakeResponse.getCorfuVersion();\n+                serverId = getUUID(handshakeResponse.getServerId());\n \n-        try {\n-            handshakeResponse = (CorfuPayloadMsg<HandshakeResponse>) m;\n-            log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler. \" +\n-                    \"Send upstream only if handshake succeeded.\", e);\n-            if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n-                super.channelRead(ctx, m);\n+                // Remove the handler from the pipeline. Also remove the reference of the context from\n+                // the handler so that it does not disconnect the channel.\n+                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    CorfuMsg msg = (CorfuMsg) m;\n+                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n+                if (this.handshakeState.completed()) {\n+                    // Only send upstream if handshake is complete.\n+                    super.channelRead(ctx, m);\n+                }\n+            }\n+        } else {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NzQ0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509787445", "bodyText": "You might want to throw an InvalidStateException insated in the default block.", "author": "vjeko", "createdAt": "2020-10-21T23:12:52Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5MjE2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509792165", "bodyText": "Style: missing space.", "author": "vjeko", "createdAt": "2020-10-21T23:27:10Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try(ByteString.Output bso = ByteString.newOutput()) {\n+            try(DataOutputStream dos = new DataOutputStream(bso)) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5Mjc2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509792760", "bodyText": "It might make sense to fail early and fail loudly here. An exception?", "author": "vjeko", "createdAt": "2020-10-21T23:29:01Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try(ByteString.Output bso = ByteString.newOutput()) {\n+            try(DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (Exception ex) {\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +\n+                    \"while serializing roaring64NavigableMap\", ex, ex.getCause());", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5Mjg4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509792880", "bodyText": "Style: missing space.", "author": "vjeko", "createdAt": "2020-10-21T23:29:26Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try(ByteString.Output bso = ByteString.newOutput()) {\n+            try(DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (Exception ex) {\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +\n+                    \"while serializing roaring64NavigableMap\", ex, ex.getCause());\n+        }\n+\n+        return addressSpaceMsgBuilder.build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressSpace object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf StreamAddressSpace message\n+     */\n+    public static StreamAddressSpace getStreamAddressSpace(StreamAddressSpaceMsg msg) {\n+        Roaring64NavigableMap roaring64NavigableMap = new Roaring64NavigableMap();\n+\n+        try(DataInputStream dis = new DataInputStream(msg.getAddressMap().newInput())) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5MzQ5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509793494", "bodyText": "No need for an empty line.", "author": "vjeko", "createdAt": "2020-10-21T23:31:19Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.VersionInfo;\n+import org.corfudb.runtime.proto.service.Base.HandshakeRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.HandshakeResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.PingRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.PingResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.SealRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.SealResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+\n+import java.util.UUID;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in base.proto. These provide the interface for performing the RPCs\n+ * handled by the Base server, as well as the handshake.\n+ */\n+", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NTAyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509795026", "bodyText": "Can't you do HeaderMsg.newBuilder().mergeFrom(header).setPriority(PriorityLevel.HIGH);?", "author": "vjeko", "createdAt": "2020-10-21T23:36:35Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in corfu_message.proto. These provide the interface for obtaining headers,\n+ * as well as the main request and response (Protobuf) messages sent by the\n+ * client and server.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolMessage {\n+    public static final ProtocolVersion CURRENT_VERSION = ProtocolVersion.V0;\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     *\n+     * @param requestId         the request id, generated by the client\n+     * @param priority          the priority of the message\n+     * @param epoch             the epoch of the message\n+     * @param clusterId         the cluster id\n+     * @param clientId          the clients own id\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     */\n+    public static HeaderMsg getHeaderMsg(long requestId, PriorityLevel priority, long epoch, UuidMsg clusterId,\n+                                         UuidMsg clientId, boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return HeaderMsg.newBuilder()\n+                .setVersion(CURRENT_VERSION)\n+                .setRequestId(requestId)\n+                .setPriority(priority)\n+                .setEpoch(epoch)\n+                .setClusterId(clusterId)\n+                .setClientId(clientId)\n+                .setIgnoreClusterId(ignoreClusterId)\n+                .setIgnoreEpoch(ignoreEpoch)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     *\n+     * @param requestId         the request id, generated by the client\n+     * @param priority          the priority of the message\n+     * @param epoch             the epoch of the message\n+     * @param clusterId         the cluster id\n+     * @param clientId          the clients own id\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     */\n+    public static HeaderMsg getHeaderMsg(long requestId, PriorityLevel priority, long epoch, UUID clusterId,\n+                                         UUID clientId, boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestId, priority, epoch, getUuidMsg(clusterId),\n+                getUuidMsg(clientId), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     * Used by the server as a convenient way to copy reusable field values.\n+     *\n+     * @param header            the original request header\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     */\n+    public static HeaderMsg getHeaderMsg(HeaderMsg header, boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(header.getRequestId(),\n+                header.getPriority(),\n+                header.getEpoch(),\n+                header.getClusterId(),\n+                header.getClientId(),\n+                ignoreClusterId,\n+                ignoreEpoch);\n+    }\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     * Use by the server to increase the priority of certain requests.\n+     *\n+     * @param header   the original request header\n+     */\n+    public static HeaderMsg getHighPriorityHeaderMsg(HeaderMsg header) {\n+        return getHeaderMsg(header.getRequestId(),\n+                PriorityLevel.HIGH,\n+                header.getEpoch(),\n+                header.getClusterId(),\n+                header.getClientId(),\n+                header.getIgnoreClusterId(),\n+                header.getIgnoreEpoch());", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NTc1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509795759", "bodyText": "Try-with-resource might be a better approach:\ntry (ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf)) {", "author": "vjeko", "createdAt": "2020-10-21T23:39:06Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,34 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {\n+            list.add(CorfuMsg.deserialize(byteBuf));\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){\n+            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n+            try {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NTk0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509795947", "bodyText": "Same here -- try-with-resource.", "author": "vjeko", "createdAt": "2020-10-21T23:39:41Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,34 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {\n+            list.add(CorfuMsg.deserialize(byteBuf));\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){\n+            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n+            try {\n+                RequestMsg request = RequestMsg.parseFrom(msgInputStream);\n+                list.add(request);\n+            } catch (Exception e) {\n+                log.error(\"decode: An exception occurred during parsing request from ByteBufInputStream of byteBuf.\", e);\n+            } finally {\n+                msgInputStream.close();\n+            }\n+        } else if (msgMark == PROTO_CORFU_RESPONSE_MSG_MARK){\n+            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n+            try {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NjI0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509796244", "bodyText": "Style: missing space.", "author": "vjeko", "createdAt": "2020-10-21T23:40:30Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,34 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {\n+            list.add(CorfuMsg.deserialize(byteBuf));\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NjYzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509796633", "bodyText": "throws does not seem to be necessary.", "author": "vjeko", "createdAt": "2020-10-21T23:41:51Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NzQxMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509797410", "bodyText": "try-with-resource?", "author": "vjeko", "createdAt": "2020-10-21T23:44:36Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {\n         try {\n-            corfuMsg.serialize(byteBuf);\n-            if(log.isDebugEnabled()) {\n+            if (object instanceof CorfuMsg) {\n+                CorfuMsg corfuMsg = (CorfuMsg) object;\n+                byteBuf.writeByte(LEGACY_CORFU_MSG_MARK); // Temporary -- Marks the Corfu msg as legacy.\n+                corfuMsg.serialize(byteBuf);\n+            } else if (object instanceof RequestMsg) {\n+                RequestMsg request = (RequestMsg) object;\n+                ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NzQyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509797428", "bodyText": "try-with-resource?", "author": "vjeko", "createdAt": "2020-10-21T23:44:41Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {\n         try {\n-            corfuMsg.serialize(byteBuf);\n-            if(log.isDebugEnabled()) {\n+            if (object instanceof CorfuMsg) {\n+                CorfuMsg corfuMsg = (CorfuMsg) object;\n+                byteBuf.writeByte(LEGACY_CORFU_MSG_MARK); // Temporary -- Marks the Corfu msg as legacy.\n+                corfuMsg.serialize(byteBuf);\n+            } else if (object instanceof RequestMsg) {\n+                RequestMsg request = (RequestMsg) object;\n+                ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {\n+                    requestOutputStream.writeByte(PROTO_CORFU_REQUEST_MSG_MARK); // Temporary - Marks the Corfu msg as protobuf.\n+                    request.writeTo(requestOutputStream);\n+                } catch(IOException e) {\n+                    log.warn(\"encode[{}]: Exception occurred when encoding request {}, caused by {}\",\n+                            request.getHeader().getRequestId(), request.getHeader(), e.getCause(), e);\n+                } finally {\n+                    IOUtils.closeQuietly(requestOutputStream);\n+                }\n+            } else if (object instanceof ResponseMsg) {\n+                ResponseMsg response = (ResponseMsg) object;\n+                ByteBufOutputStream responseOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMzNTI4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r510335286", "bodyText": "Good idea. Will do.", "author": "zfrenette", "createdAt": "2020-10-22T17:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NzQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5ODMyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509798323", "bodyText": "Style: missing space.", "author": "vjeko", "createdAt": "2020-10-21T23:47:32Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {\n         try {\n-            corfuMsg.serialize(byteBuf);\n-            if(log.isDebugEnabled()) {\n+            if (object instanceof CorfuMsg) {\n+                CorfuMsg corfuMsg = (CorfuMsg) object;\n+                byteBuf.writeByte(LEGACY_CORFU_MSG_MARK); // Temporary -- Marks the Corfu msg as legacy.\n+                corfuMsg.serialize(byteBuf);\n+            } else if (object instanceof RequestMsg) {\n+                RequestMsg request = (RequestMsg) object;\n+                ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {\n+                    requestOutputStream.writeByte(PROTO_CORFU_REQUEST_MSG_MARK); // Temporary - Marks the Corfu msg as protobuf.\n+                    request.writeTo(requestOutputStream);\n+                } catch(IOException e) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "url": "https://github.com/CorfuDB/CorfuDB/commit/2c0b73903e2701cad9c10e549f0d4eeff57f877a", "message": "CorfuStore: Stream tails per table api needed for search\n\nMinor fix to getRecord() to handle null values.\nUse getOrCreate on SharedMetricRegistry for compatability with 3.1.0", "committedDate": "2020-10-22T22:02:16Z", "type": "forcePushed"}, {"oid": "db6c5e8bb0f73ccb5219701127c9692b969babce", "url": "https://github.com/CorfuDB/CorfuDB/commit/db6c5e8bb0f73ccb5219701127c9692b969babce", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-22T23:03:09Z", "type": "forcePushed"}, {"oid": "e31e8e8fcc9e88972fc485f27323fa7b3c00c76a", "url": "https://github.com/CorfuDB/CorfuDB/commit/e31e8e8fcc9e88972fc485f27323fa7b3c00c76a", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-26T23:50:51Z", "type": "forcePushed"}, {"oid": "6825f6572b1059a89600514235cdb1607a52f58b", "url": "https://github.com/CorfuDB/CorfuDB/commit/6825f6572b1059a89600514235cdb1607a52f58b", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-27T14:58:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjI3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772276", "bodyText": "Codacy found an issue: The method 'channelRead(ChannelHandlerContext, Object)' has an NPath complexity of 288, current threshold is 200", "author": "corfudb-bot", "createdAt": "2020-10-27T15:06:13Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,50 +80,44 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjI4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772286", "bodyText": "Codacy found an issue: The utility class name 'CorfuProtocolMessage' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "author": "corfudb-bot", "createdAt": "2020-10-27T15:06:14Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in corfu_message.proto. These provide the interface for obtaining headers,\n+ * as well as the main request and response (Protobuf) messages sent by the\n+ * client and server.\n+ */\n+@Slf4j\n+public class CorfuProtocolMessage {", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjMwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772302", "bodyText": "Codacy found an issue: Avoid unused imports such as 'org.corfudb.protocols.CorfuProtocolCommon'", "author": "corfudb-bot", "createdAt": "2020-10-27T15:06:16Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjMyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772321", "bodyText": "Codacy found an issue: The utility class name 'CorfuProtocolCommon' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "author": "corfudb-bot", "createdAt": "2020-10-27T15:06:17Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,211 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjM1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772355", "bodyText": "Codacy found an issue: The utility class name 'CorfuProtocolBase' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "author": "corfudb-bot", "createdAt": "2020-10-27T15:06:19Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.VersionInfo;\n+import org.corfudb.runtime.proto.service.Base.HandshakeRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.HandshakeResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.PingRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.PingResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.SealRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.SealResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+\n+import java.util.UUID;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in base.proto. These provide the interface for performing the RPCs\n+ * handled by the Base server, as well as the handshake.\n+ */\n+@Slf4j\n+public class CorfuProtocolBase {", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTgzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513549836", "bodyText": "I noticed that some other 1-line if clause below are inside curly braces, maybe we should add to make style consistent?", "author": "xcchang", "createdAt": "2020-10-28T15:42:19Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNDUwNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513804505", "bodyText": "+1 we seem to expand all the if statements with curly braces. If ever a check is enforced on this it might help to keep things consistent.", "author": "hisundar", "createdAt": "2020-10-28T22:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4OTMxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514689314", "bodyText": "Done", "author": "zfrenette", "createdAt": "2020-10-30T01:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NzM0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513557349", "bodyText": "should we expand this? I think only the getUuidMsg is used", "author": "xcchang", "createdAt": "2020-10-28T15:51:35Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4ODg5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514688895", "bodyText": "Done", "author": "zfrenette", "createdAt": "2020-10-30T01:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NzM0OQ=="}], "type": "inlineReview"}, {"oid": "2673f515f96423392e648ae7999ce732741ecc3c", "url": "https://github.com/CorfuDB/CorfuDB/commit/2673f515f96423392e648ae7999ce732741ecc3c", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-29T17:41:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTMwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513805306", "bodyText": "should this be m.toString() won't just printing m display just the address of the object and not its contents?", "author": "hisundar", "createdAt": "2020-10-28T22:43:33Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-\n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n-\n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3NDg0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514474844", "bodyText": "I believe that .toString() is automatically invoked in the case of complex objects: See the section \"How can I log the string contents of a single (possibly complex) object?\" in http://www.slf4j.org/faq.html", "author": "zfrenette", "createdAt": "2020-10-29T18:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTM2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513805361", "bodyText": "do you want this to be m.toString()?", "author": "hisundar", "createdAt": "2020-10-28T22:43:43Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-\n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n-\n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    log.debug(\"channelRead: Dropping message: {}\", ((CorfuMsg) m).getMsgType().name());\n-                } catch (Exception ex) {\n-                    log.error(\"channelRead: Message received by Server is not a valid \" +\n-                            \"CorfuMsg type.\");\n-                }\n+                log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3NzkxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514477917", "bodyText": "See my comment above", "author": "zfrenette", "createdAt": "2020-10-29T18:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMzg0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514603842", "bodyText": "can we add the missing java doc for this method?", "author": "hisundar", "createdAt": "2020-10-29T22:28:49Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,33 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,", "originalCommit": "2673f515f96423392e648ae7999ce732741ecc3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4NzMyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514687321", "bodyText": "Done", "author": "zfrenette", "createdAt": "2020-10-30T01:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMzg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwNDU4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514604586", "bodyText": "can we consider adding the missing java doc for this method?", "author": "hisundar", "createdAt": "2020-10-29T22:30:45Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,66 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n-    protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n-                          ByteBuf byteBuf) throws Exception {\n+    protected void encode(ChannelHandlerContext channelHandlerContext, Object object, ByteBuf byteBuf) {", "originalCommit": "2673f515f96423392e648ae7999ce732741ecc3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4NzIyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514687229", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-10-30T01:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwNDU4Ng=="}], "type": "inlineReview"}, {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "url": "https://github.com/CorfuDB/CorfuDB/commit/8b2e1495801fd780d8a9ae682c49477941fe9b35", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-30T01:49:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNDA1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515234057", "bodyText": "let's add a log line here, otherwise, it'd be pretty hard to know if a handshake failed", "author": "xnull", "createdAt": "2020-10-30T16:46:45Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,33 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n-\n-        if (this.state.failed()) {\n+        if (this.handshakeState.failed()) {", "originalCommit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTk4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515321983", "bodyText": "Done. Added a log line in both the server and client handshake handlers.", "author": "zfrenette", "createdAt": "2020-10-30T19:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNDA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNjUwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515236506", "bodyText": "Please don't add more logs here, ServerHandshakeHandler already a huge problem in terms of log generation.", "author": "xnull", "createdAt": "2020-10-30T16:50:29Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -121,16 +111,26 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         log.debug(\"channelRead: Sending handshake response: Node Id: {} Corfu Version: {}\",\n                 this.nodeId, this.corfuVersion);\n \n-        CorfuMsg handshakeResponse = CorfuMsgType.HANDSHAKE_RESPONSE\n-                .payloadMsg(new HandshakeResponse(this.nodeId, this.corfuVersion));\n-        ctx.writeAndFlush(handshakeResponse);\n \n-        // Flush messages in queue\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(((RequestMsg) m).getHeader(),\n+                getHandshakeResponseMsg(this.nodeId, this.corfuVersion));\n+\n+        ctx.writeAndFlush(response);\n+\n+        // Flush messages in queues\n         log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n+        log.debug(\"channelRead: There are [{}] responseMessages in queue to be flushed.\", this.responseMessages.size());", "originalCommit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMjA4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515322085", "bodyText": "Done. These have been removed.", "author": "zfrenette", "createdAt": "2020-10-30T19:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNjUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzOTg4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515239880", "bodyText": "this looks weird, why not reuse SequencerStatus and get rid of SequencerMetrics? or vise versa", "author": "xnull", "createdAt": "2020-10-30T16:55:53Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;", "originalCommit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI3Njk0Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515276946", "bodyText": "Here we mimicked how the SequencerMetrics Java object is currently represented. Our goal was to allow for the possibility of (easily) extending the message should the RPC ever evolve. If more information about the Sequencer is ever needed, fields in the message wrapper can be added without significant changes.", "author": "zfrenette", "createdAt": "2020-10-30T17:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzOTg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MTk3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515241976", "bodyText": "There is a rule: never write an error in the log if you throw an exception. They are mutually exclusive.", "author": "xnull", "createdAt": "2020-10-30T16:59:14Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (IOException ex) {\n+            // Log the error and rethrow the exception\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +", "originalCommit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTQxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515319418", "bodyText": "Sounds good. I'll stick to logging the error for the time being. Will update shortly.", "author": "zfrenette", "createdAt": "2020-10-30T19:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MTk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMjIyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515322222", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-10-30T19:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515248733", "bodyText": "I'm concerned about the enclosed try blocks. Also, as I know we never used DataOutputStream, so not sure if we need it here.\nQuestions:\n\nwhy treamAddressSpaceMsg#addressMap is a string when it should be a map?\nIOException is a very hard exception to deal with, it would be great not to have it (but of course we shouldn't just silently ignore it)", "author": "xnull", "createdAt": "2020-10-30T17:10:01Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {", "originalCommit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI2OTY5Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515269697", "bodyText": "The map stored in a StreamAddressSpaceMsg is a RoaringBitmap, which we represent in Protobuf as a sequence of bytes. I am not sure how we would otherwise represent it. Currently, DataOutputStream is used in ICorfuPayload to serialize the RoaringBitmap into a ByteBuf.  I tried emulating the approach by using DataOutputStream as an intermediate step since I wasn't able to serialize the map directly into a ByteString, which is how Protobuf represents a sequence of bytes.\nAs for the IO exception, the only things that seem appropriate in response to the serialization error is 1) logging an error and continuing silently, or 2), throwing an exception. Is there a more appropriate response that we haven't considered?", "author": "zfrenette", "createdAt": "2020-10-30T17:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMjI4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515322281", "bodyText": "For the sake of consistency, I'd say the best approach that I know, could be:\npublic static Optional<StreamAddressSpaceMsg> getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n        \n        Optional<ByteString> maybeAddressMap = Optional.empty();\n        try (ByteString.Output bso = ByteString.newOutput()) {\n            try (DataOutputStream dos = new DataOutputStream(bso)) {\n                addressSpace.getAddressMap().serialize(dos);\n                maybeAddressMap = Optional.of(bso.toByteString());\n            }\n        } catch (IOException ex) {\n            String msg = \"getStreamAddressSpaceMsg: error=[{}] while serializing roaring64NavigableMap\";\n            log.error(msg, ex.getCause(), ex);\n        }\n        \n        return maybeAddressMap.map(addressMap ->{\n            StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n            addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n            addressSpaceMsgBuilder.setAddressMap(addressMap);\n            return addressSpaceMsgBuilder.build();\n        });\n    }\n\nBTW, who's using getStreamAddressSpaceMsg? I didn't find anything in Corfu which uses it", "author": "xnull", "createdAt": "2020-10-30T19:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNDMxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515324311", "bodyText": "This method in the API isn't used yet. It will be used by the SequencerClient/Server and LogUnitServer when the PRs replacing the implementation of these RPCs are ready to go. For example, the SequencerClient will invoke this method when performing a bootstrap to convert the streamAddressSpaceMap into a Protobuf representation before sending it over the wire.", "author": "zfrenette", "createdAt": "2020-10-30T19:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw=="}], "type": "inlineReview"}, {"oid": "61a057f8b427b71c07ff630292a1c10d0333cf59", "url": "https://github.com/CorfuDB/CorfuDB/commit/61a057f8b427b71c07ff630292a1c10d0333cf59", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-30T19:12:53Z", "type": "forcePushed"}, {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "url": "https://github.com/CorfuDB/CorfuDB/commit/64c340b533b7c60139dd7cb0efeb33b297ccccda", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-11-02T19:40:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTM4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516295385", "bodyText": "Would be great to use enum instead of static variables, like:\nenum MessageMarker {\n  LEGACY_CORFU_MSG_MARK(0x1), PROTO_CORFU_REQUEST_MSG_MARK(0x2), PROTO_CORFU_RESPONSE_MSG_MARK(0x3)\n\n  private final byte value;\n}", "author": "xnull", "createdAt": "2020-11-02T22:33:16Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTgyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516295829", "bodyText": "Also you don't need \"CORFU\" prefix in their names (it reduces length a bit)", "author": "xnull", "createdAt": "2020-11-02T22:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjQzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516352432", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T00:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516301676", "bodyText": "please rename e to something meaningful", "author": "xnull", "createdAt": "2020-11-02T22:42:52Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {\n+                Roaring64NavigableMap rm = addressSpace.getAddressMap();\n+                // Improve compression\n+                rm.runOptimize();\n+                rm.serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (IOException ex) {\n+            throw new SerializerException(\"Unexpected error while serializing roaring64NavigableMap\", ex);\n+        }\n+\n+        return addressSpaceMsgBuilder.build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressSpace object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf StreamAddressSpace message\n+     */\n+    public static StreamAddressSpace getStreamAddressSpace(StreamAddressSpaceMsg msg) {\n+        Roaring64NavigableMap roaring64NavigableMap = new Roaring64NavigableMap();\n+\n+        try (DataInputStream dis = new DataInputStream(msg.getAddressMap().newInput())) {\n+            roaring64NavigableMap.deserialize(dis);\n+        } catch (IOException ex) {\n+            throw new SerializerException(\"Unexpected error while deserializing roaring64NavigableMap\", ex);\n+        }\n+\n+        return new StreamAddressSpace(msg.getTrimMark(), roaring64NavigableMap);\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressRange object.\n+     *\n+     * @param streamAddressRange   the desired (Java) StreamAddressRange\n+     */\n+    public static StreamAddressRangeMsg getStreamAddressRangeMsg(StreamAddressRange streamAddressRange) {\n+        return StreamAddressRangeMsg.newBuilder()\n+                .setStreamId(getUuidMsg(streamAddressRange.getStreamID()))\n+                .setStart(streamAddressRange.getStart())\n+                .setEnd(streamAddressRange.getEnd())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressResponse object from its log tail and List\n+     * of address map entries, each consisting of a UUID and a StreamAddressSpace,\n+     * represented in Protobuf.\n+     *\n+     * @param tail   the log tail\n+     * @param map    a list of address map entries represented in Protobuf\n+     */\n+    public static StreamsAddressResponse getStreamsAddressResponse(long tail, List<UuidToStreamAddressSpacePairMsg> map) {\n+        return new StreamsAddressResponse(tail, map.stream()\n+                .collect(Collectors.<UuidToStreamAddressSpacePairMsg, UUID, StreamAddressSpace>toMap(\n+                        e -> getUUID(e.getStreamUuid()),", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MzIwNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516353205", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T00:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODM1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516308358", "bodyText": "we'd have a race condition here, in a multithreaded environment having a LinkedList. causing race conditions.\n\n\nCould you please replace it with a BlockingQueue?\n\n\nNext step - I don't see the motivation for having a queue here, can we replace it with ConcurrentHashMap? or concurrent set (ConcurrentHashMap.newKeySet())?\n\n\nSince you touched it, could you please also replace messages with a concurrent version or a concurrenthashmap? In this class and in serverhandler?", "author": "xnull", "createdAt": "2020-11-02T22:54:26Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,12 +137,16 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n+\n+        // Flush messages in queues\n         while (!messages.isEmpty()) {\n             ctx.writeAndFlush(messages.poll());\n         }\n \n+        while (!requestMessages.isEmpty()) {", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjYzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516352632", "bodyText": "Done! Used a ConcurrentHashMap as suggested.", "author": "zfrenette", "createdAt": "2020-11-03T00:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODkyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516308926", "bodyText": "Let's make \"00000000-0000-0000-0000-000000000000\" a constant, put it in to a utility class and use the constant instead of a string", "author": "xnull", "createdAt": "2020-11-02T22:55:23Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -145,19 +157,19 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n      * Channel event that is triggered when a new connected channel is created.\n      *\n      * @param ctx channel handler context\n-     * @throws Exception\n      */\n     @Override\n-    public void channelActive(ChannelHandlerContext ctx)\n-        throws Exception {\n-        log.info(\"channelActive: Outgoing connection established to: {} from id={}\", ctx.channel().remoteAddress(), ctx.channel().localAddress());\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        log.info(\"channelActive: Outgoing connection established to: {} from id={}\",\n+                ctx.channel().remoteAddress(), ctx.channel().localAddress());\n+\n+        // Note: Some fields in the header are unused during the handshake process.\n+        HeaderMsg header = getHeaderMsg(0, CorfuMessage.PriorityLevel.NORMAL, 0,\n+                UUID.fromString(\"00000000-0000-0000-0000-000000000000\"), this.clientId, false, true);", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MzM1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516353350", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T00:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMDU4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516310587", "bodyText": "Would be great to have an enum here (I mentioned above) and replace if conditions with switch statement", "author": "xnull", "createdAt": "2020-11-02T22:58:19Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -1,25 +1,66 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n+import java.io.IOException;\n import java.util.List;\n-\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n public class NettyCorfuMessageDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Decodes an inbound corfu message from a ByteBuf. The corfu message is either\n+     * legacy (of type CorfuMsg) or Protobuf (of type RequestMsg/ResponseMsg).\n+     *\n+     * @param channelHandlerContext   the Netty channel handler context\n+     * @param byteBuf                 the underlying ByteBuf\n+     * @param list                    a list of decoded objects given to the\n+     *                                next pipeline handler\n+     */\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjcwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516352704", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T00:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMDU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMTQ2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516311464", "bodyText": "why object? Can it be a proto message?", "author": "xnull", "createdAt": "2020-11-02T22:59:43Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,74 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMjgxMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516312813", "bodyText": "This is because it has to work for multiple Protobuf types: RequestMsg and ResponseMsg. And for the time being, it also has to work with legacy CorfuMsg types.", "author": "zfrenette", "createdAt": "2020-11-02T23:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMTQ2NA=="}], "type": "inlineReview"}, {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "url": "https://github.com/CorfuDB/CorfuDB/commit/2b32e68f880358f0ab0566e491a9f81e56a590ee", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-11-03T00:11:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDMzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516364331", "bodyText": "This is a tricky part: imagine another thread is adding messages at the same time when you clean the set, as a result, you would delete messages (with clear method) from the set without executing \"writeAndFlush\".\nthe code should be:\nSet< CorfuMsg> messagesToFlush = new HashSet<>(messages);\nmessagesToFlush.forEach(msg ->{\n  messages.remove(msg);\n  ctx.writeAndFlush(msg);\n});", "author": "xnull", "createdAt": "2020-11-03T00:38:19Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,11 +138,12 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n-        while (!messages.isEmpty()) {\n-            ctx.writeAndFlush(messages.poll());\n-        }\n+\n+        // Flush messages in backlog\n+        messages.forEach(ctx::writeAndFlush);", "originalCommit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NjI1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516396259", "bodyText": "Note: after internal discussion, this will be addressed in a separate PR.", "author": "zfrenette", "createdAt": "2020-11-03T02:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDQ5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516364491", "bodyText": "same here", "author": "xnull", "createdAt": "2020-11-03T00:38:39Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,11 +138,12 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n-        while (!messages.isEmpty()) {\n-            ctx.writeAndFlush(messages.poll());\n-        }\n+\n+        // Flush messages in backlog\n+        messages.forEach(ctx::writeAndFlush);\n+        messages.clear();\n+        requestMessages.forEach(ctx::writeAndFlush);\n+        requestMessages.clear();", "originalCommit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NjQ1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516396455", "bodyText": "Note: after internal discussion, this will be addressed in a separate PR.", "author": "zfrenette", "createdAt": "2020-11-03T02:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MjU5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516382598", "bodyText": "Can you put return on a new line?", "author": "WenbinZhu", "createdAt": "2020-11-03T01:25:23Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    @AllArgsConstructor\n+    public enum MessageMarker {\n+        LEGACY_MSG_MARK(0x1),\n+        PROTO_REQUEST_MSG_MARK(0x2),\n+        PROTO_RESPONSE_MSG_MARK(0x3);\n+\n+        private final int value;\n+\n+        public byte asByte() {\n+            return (byte) value;\n+        }\n+\n+        public static Map<Byte, MessageMarker> typeMap =\n+                Arrays.<MessageMarker>stream(MessageMarker.values())\n+                    .collect(Collectors.toMap(MessageMarker::asByte, Function.identity()));\n+    }\n+\n+    public static final UUID DEFAULT_UUID = UUID.fromString(\"00000000-0000-0000-0000-000000000000\");\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;", "originalCommit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMDExMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516410113", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T03:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MjU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDIyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516394223", "bodyText": "Add the reason for dropping message?", "author": "WenbinZhu", "createdAt": "2020-11-03T02:14:41Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,54 +81,51 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n-\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n+            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n             return;\n         }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, msg);\n+            } else {\n+                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());", "originalCommit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMDEyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516410128", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T03:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5Nzk0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516397947", "bodyText": "I think the original comment is more clear, can you restore that?", "author": "WenbinZhu", "createdAt": "2020-11-03T02:31:18Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,54 +81,51 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n-\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n+            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n             return;\n         }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.", "originalCommit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMDE1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516410151", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T03:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5Nzk0Nw=="}], "type": "inlineReview"}, {"oid": "f55d3e1f35d97404f571eb24b4ef157575ba978b", "url": "https://github.com/CorfuDB/CorfuDB/commit/f55d3e1f35d97404f571eb24b4ef157575ba978b", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-11-03T03:25:53Z", "type": "commit"}, {"oid": "f55d3e1f35d97404f571eb24b4ef157575ba978b", "url": "https://github.com/CorfuDB/CorfuDB/commit/f55d3e1f35d97404f571eb24b4ef157575ba978b", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-11-03T03:25:53Z", "type": "forcePushed"}]}