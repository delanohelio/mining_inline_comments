{"pr_number": 833, "pr_title": "Make POW work on GTSs and Lists the same way numerical functions do", "pr_createdAt": "2020-09-17T15:16:35Z", "pr_url": "https://github.com/senx/warp10-platform/pull/833", "timeline": [{"oid": "b1133aa1b60e5595b041544aa367c8b9a9a2d468", "url": "https://github.com/senx/warp10-platform/commit/b1133aa1b60e5595b041544aa367c8b9a9a2d468", "message": "Make POW work on GTSs and Lists the same way numerical functions do", "committedDate": "2020-09-17T15:16:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0MDMwMQ==", "url": "https://github.com/senx/warp10-platform/pull/833#discussion_r490340301", "bodyText": "This does not depend on the operands, can it be instantiated once and reused?", "author": "hbs", "createdAt": "2020-09-17T15:24:06Z", "path": "warp10/src/main/java/io/warp10/script/binary/POW.java", "diffHunk": "@@ -16,35 +16,138 @@\n \n package io.warp10.script.binary;\n \n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GTSOpsHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n- * Raise the first operand to the power of the second\n+ * Raise the first operand to the power of the second.\n  */\n public class POW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n \n+  private final String typeCheckErrorMsg;\n+\n   public POW(String name) {\n     super(name);\n+    typeCheckErrorMsg = getName() + \" can only operate on numeric values, vectors and numeric Geo Time Series.\";\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object op2 = stack.pop();\n     Object op1 = stack.pop();\n-    \n+\n     if (op2 instanceof Number && op1 instanceof Number) {\n+      double pow = Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue());\n       if (op1 instanceof Double || op2 instanceof Double) {\n-        stack.push(Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue()));\n+        stack.push(pow);\n       } else {\n-        stack.push((long) Math.pow(((Number) op1).longValue(), ((Number) op2).longValue()));        \n+        stack.push((long) pow);\n+      }\n+    } else if ((op1 instanceof Number && op2 instanceof List) || (op1 instanceof List && op2 instanceof Number)) {\n+      List list = op1 instanceof List ? (List) op1 : (List) op2;\n+      Number operand = op1 instanceof Number ? (Number) op1 : (Number) op2;\n+      double operandD = operand.doubleValue();\n+\n+      ArrayList<Object> result = new ArrayList<Object>(list.size());\n+\n+      for (Object element: list) {\n+        if (!(element instanceof Number)) {\n+          throw new WarpScriptException(getName() + \" expects lists to contain numerical values.\");\n+        }\n+\n+        // Compute the power, taking into account parameter order.\n+        double pow;\n+        if (op1 instanceof List) {\n+          pow = Math.pow(((Number) element).doubleValue(), operandD);\n+        } else {\n+          pow = Math.pow(operandD, ((Number) element).doubleValue());\n+        }\n+\n+        // Cast result to long if both operands are not floating-point values.\n+        if (element instanceof Double || operand instanceof Double) {\n+          result.add(pow);\n+        } else {\n+          result.add((long) pow);\n+        }\n+      }\n+\n+      stack.push(result);\n+    } else if (op1 instanceof GeoTimeSerie && op2 instanceof GeoTimeSerie) {\n+      GeoTimeSerie gts1 = (GeoTimeSerie) op1;\n+      GeoTimeSerie gts2 = (GeoTimeSerie) op2;\n+\n+      if (!(gts1.getType() == GeoTimeSerie.TYPE.DOUBLE || gts1.getType() == GeoTimeSerie.TYPE.LONG) || !(gts2.getType() == GeoTimeSerie.TYPE.DOUBLE || gts2.getType() == GeoTimeSerie.TYPE.LONG)) {\n+        throw new WarpScriptException(typeCheckErrorMsg);\n+      }\n+\n+      // The result type is LONG if both inputs are LONG.\n+      GeoTimeSerie result = new GeoTimeSerie(Math.max(GTSHelper.nvalues(gts1), GTSHelper.nvalues(gts2)));\n+      GeoTimeSerie.TYPE type = (gts1.getType() == GeoTimeSerie.TYPE.LONG && gts2.getType() == GeoTimeSerie.TYPE.LONG) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n+      result.setType(type);\n+\n+      GTSOpsHelper.GTSBinaryOp op = new GTSOpsHelper.GTSBinaryOp() {", "originalCommit": "b1133aa1b60e5595b041544aa367c8b9a9a2d468", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0MDg2OQ==", "url": "https://github.com/senx/warp10-platform/pull/833#discussion_r490340869", "bodyText": "missing hint if op2 is a GTS", "author": "hbs", "createdAt": "2020-09-17T15:24:52Z", "path": "warp10/src/main/java/io/warp10/script/binary/POW.java", "diffHunk": "@@ -16,35 +16,138 @@\n \n package io.warp10.script.binary;\n \n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GTSOpsHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n- * Raise the first operand to the power of the second\n+ * Raise the first operand to the power of the second.\n  */\n public class POW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n \n+  private final String typeCheckErrorMsg;\n+\n   public POW(String name) {\n     super(name);\n+    typeCheckErrorMsg = getName() + \" can only operate on numeric values, vectors and numeric Geo Time Series.\";\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object op2 = stack.pop();\n     Object op1 = stack.pop();\n-    \n+\n     if (op2 instanceof Number && op1 instanceof Number) {\n+      double pow = Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue());\n       if (op1 instanceof Double || op2 instanceof Double) {\n-        stack.push(Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue()));\n+        stack.push(pow);\n       } else {\n-        stack.push((long) Math.pow(((Number) op1).longValue(), ((Number) op2).longValue()));        \n+        stack.push((long) pow);\n+      }\n+    } else if ((op1 instanceof Number && op2 instanceof List) || (op1 instanceof List && op2 instanceof Number)) {\n+      List list = op1 instanceof List ? (List) op1 : (List) op2;\n+      Number operand = op1 instanceof Number ? (Number) op1 : (Number) op2;\n+      double operandD = operand.doubleValue();\n+\n+      ArrayList<Object> result = new ArrayList<Object>(list.size());\n+\n+      for (Object element: list) {\n+        if (!(element instanceof Number)) {\n+          throw new WarpScriptException(getName() + \" expects lists to contain numerical values.\");\n+        }\n+\n+        // Compute the power, taking into account parameter order.\n+        double pow;\n+        if (op1 instanceof List) {\n+          pow = Math.pow(((Number) element).doubleValue(), operandD);\n+        } else {\n+          pow = Math.pow(operandD, ((Number) element).doubleValue());\n+        }\n+\n+        // Cast result to long if both operands are not floating-point values.\n+        if (element instanceof Double || operand instanceof Double) {\n+          result.add(pow);\n+        } else {\n+          result.add((long) pow);\n+        }\n+      }\n+\n+      stack.push(result);\n+    } else if (op1 instanceof GeoTimeSerie && op2 instanceof GeoTimeSerie) {\n+      GeoTimeSerie gts1 = (GeoTimeSerie) op1;\n+      GeoTimeSerie gts2 = (GeoTimeSerie) op2;\n+\n+      if (!(gts1.getType() == GeoTimeSerie.TYPE.DOUBLE || gts1.getType() == GeoTimeSerie.TYPE.LONG) || !(gts2.getType() == GeoTimeSerie.TYPE.DOUBLE || gts2.getType() == GeoTimeSerie.TYPE.LONG)) {\n+        throw new WarpScriptException(typeCheckErrorMsg);\n+      }\n+\n+      // The result type is LONG if both inputs are LONG.\n+      GeoTimeSerie result = new GeoTimeSerie(Math.max(GTSHelper.nvalues(gts1), GTSHelper.nvalues(gts2)));\n+      GeoTimeSerie.TYPE type = (gts1.getType() == GeoTimeSerie.TYPE.LONG && gts2.getType() == GeoTimeSerie.TYPE.LONG) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n+      result.setType(type);\n+\n+      GTSOpsHelper.GTSBinaryOp op = new GTSOpsHelper.GTSBinaryOp() {\n+        @Override\n+        public Object op(GeoTimeSerie gtsa, GeoTimeSerie gtsb, int idxa, int idxb) {\n+          return Math.pow(((Number) GTSHelper.valueAtIndex(gtsa, idxa)).doubleValue(), ((Number) GTSHelper.valueAtIndex(gtsb, idxb)).doubleValue());\n+        }\n+      };\n+\n+      GTSOpsHelper.applyBinaryOp(result, gts1, gts2, op);\n+\n+      // If result is empty, set type and sizehint to default.\n+      if (0 == result.size()) {\n+        result = result.cloneEmpty();\n+      }\n+\n+      stack.push(result);\n+    } else if ((op1 instanceof GeoTimeSerie && op2 instanceof Number) || (op1 instanceof Number && op2 instanceof GeoTimeSerie)) {\n+      boolean op1gts = op1 instanceof GeoTimeSerie;\n+\n+      int n = op1gts ? GTSHelper.nvalues((GeoTimeSerie) op1) : GTSHelper.nvalues((GeoTimeSerie) op2);\n+\n+      GeoTimeSerie result = op1gts ? ((GeoTimeSerie) op1).cloneEmpty(n) : ((GeoTimeSerie) op2).cloneEmpty();", "originalCommit": "b1133aa1b60e5595b041544aa367c8b9a9a2d468", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0MTM4Mw==", "url": "https://github.com/senx/warp10-platform/pull/833#discussion_r490341383", "bodyText": "GeoTimeSerie.TYPE.LONG == gts.getType()", "author": "hbs", "createdAt": "2020-09-17T15:25:34Z", "path": "warp10/src/main/java/io/warp10/script/binary/POW.java", "diffHunk": "@@ -16,35 +16,138 @@\n \n package io.warp10.script.binary;\n \n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GTSOpsHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n- * Raise the first operand to the power of the second\n+ * Raise the first operand to the power of the second.\n  */\n public class POW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n \n+  private final String typeCheckErrorMsg;\n+\n   public POW(String name) {\n     super(name);\n+    typeCheckErrorMsg = getName() + \" can only operate on numeric values, vectors and numeric Geo Time Series.\";\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object op2 = stack.pop();\n     Object op1 = stack.pop();\n-    \n+\n     if (op2 instanceof Number && op1 instanceof Number) {\n+      double pow = Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue());\n       if (op1 instanceof Double || op2 instanceof Double) {\n-        stack.push(Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue()));\n+        stack.push(pow);\n       } else {\n-        stack.push((long) Math.pow(((Number) op1).longValue(), ((Number) op2).longValue()));        \n+        stack.push((long) pow);\n+      }\n+    } else if ((op1 instanceof Number && op2 instanceof List) || (op1 instanceof List && op2 instanceof Number)) {\n+      List list = op1 instanceof List ? (List) op1 : (List) op2;\n+      Number operand = op1 instanceof Number ? (Number) op1 : (Number) op2;\n+      double operandD = operand.doubleValue();\n+\n+      ArrayList<Object> result = new ArrayList<Object>(list.size());\n+\n+      for (Object element: list) {\n+        if (!(element instanceof Number)) {\n+          throw new WarpScriptException(getName() + \" expects lists to contain numerical values.\");\n+        }\n+\n+        // Compute the power, taking into account parameter order.\n+        double pow;\n+        if (op1 instanceof List) {\n+          pow = Math.pow(((Number) element).doubleValue(), operandD);\n+        } else {\n+          pow = Math.pow(operandD, ((Number) element).doubleValue());\n+        }\n+\n+        // Cast result to long if both operands are not floating-point values.\n+        if (element instanceof Double || operand instanceof Double) {\n+          result.add(pow);\n+        } else {\n+          result.add((long) pow);\n+        }\n+      }\n+\n+      stack.push(result);\n+    } else if (op1 instanceof GeoTimeSerie && op2 instanceof GeoTimeSerie) {\n+      GeoTimeSerie gts1 = (GeoTimeSerie) op1;\n+      GeoTimeSerie gts2 = (GeoTimeSerie) op2;\n+\n+      if (!(gts1.getType() == GeoTimeSerie.TYPE.DOUBLE || gts1.getType() == GeoTimeSerie.TYPE.LONG) || !(gts2.getType() == GeoTimeSerie.TYPE.DOUBLE || gts2.getType() == GeoTimeSerie.TYPE.LONG)) {\n+        throw new WarpScriptException(typeCheckErrorMsg);\n+      }\n+\n+      // The result type is LONG if both inputs are LONG.\n+      GeoTimeSerie result = new GeoTimeSerie(Math.max(GTSHelper.nvalues(gts1), GTSHelper.nvalues(gts2)));\n+      GeoTimeSerie.TYPE type = (gts1.getType() == GeoTimeSerie.TYPE.LONG && gts2.getType() == GeoTimeSerie.TYPE.LONG) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n+      result.setType(type);\n+\n+      GTSOpsHelper.GTSBinaryOp op = new GTSOpsHelper.GTSBinaryOp() {\n+        @Override\n+        public Object op(GeoTimeSerie gtsa, GeoTimeSerie gtsb, int idxa, int idxb) {\n+          return Math.pow(((Number) GTSHelper.valueAtIndex(gtsa, idxa)).doubleValue(), ((Number) GTSHelper.valueAtIndex(gtsb, idxb)).doubleValue());\n+        }\n+      };\n+\n+      GTSOpsHelper.applyBinaryOp(result, gts1, gts2, op);\n+\n+      // If result is empty, set type and sizehint to default.\n+      if (0 == result.size()) {\n+        result = result.cloneEmpty();\n+      }\n+\n+      stack.push(result);\n+    } else if ((op1 instanceof GeoTimeSerie && op2 instanceof Number) || (op1 instanceof Number && op2 instanceof GeoTimeSerie)) {\n+      boolean op1gts = op1 instanceof GeoTimeSerie;\n+\n+      int n = op1gts ? GTSHelper.nvalues((GeoTimeSerie) op1) : GTSHelper.nvalues((GeoTimeSerie) op2);\n+\n+      GeoTimeSerie result = op1gts ? ((GeoTimeSerie) op1).cloneEmpty(n) : ((GeoTimeSerie) op2).cloneEmpty();\n+      GeoTimeSerie gts = op1gts ? (GeoTimeSerie) op1 : (GeoTimeSerie) op2;\n+\n+      // Returns immediately a new clone if gts is empty.\n+      if (0 == n) {\n+        stack.push(result);\n+        return stack;\n       }\n+\n+      if (!(gts.getType() == GeoTimeSerie.TYPE.LONG || gts.getType() == GeoTimeSerie.TYPE.DOUBLE)) {\n+        throw new WarpScriptException(typeCheckErrorMsg);\n+      }\n+\n+      Number op = op1gts ? (Number) op2 : (Number) op1;\n+\n+      // The result type is LONG if both inputs are LONG.\n+      GeoTimeSerie.TYPE type = (gts.getType() == GeoTimeSerie.TYPE.LONG && op instanceof Long) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;", "originalCommit": "b1133aa1b60e5595b041544aa367c8b9a9a2d468", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "33e50423d61d04f7c0ff265a474e78aed059d581", "url": "https://github.com/senx/warp10-platform/commit/33e50423d61d04f7c0ff265a474e78aed059d581", "message": "Remove POW and use NumericalBinaryFunction for **", "committedDate": "2020-09-18T08:17:27Z", "type": "commit"}]}