{"pr_number": 849, "pr_title": "Implement Hyndman's 9 types of percentile computation", "pr_createdAt": "2020-09-23T09:56:55Z", "pr_url": "https://github.com/senx/warp10-platform/pull/849", "timeline": [{"oid": "ddb081abe586e1e16ade29a28af8ca738ddcb6c5", "url": "https://github.com/senx/warp10-platform/commit/ddb081abe586e1e16ade29a28af8ca738ddcb6c5", "message": "Fix percentile computation and expose interpolation", "committedDate": "2020-09-23T09:55:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3Mzg4Mw==", "url": "https://github.com/senx/warp10-platform/pull/849#discussion_r494973883", "bodyText": "Can't you use just Math.ceil() instead ?", "author": "randomboolean", "createdAt": "2020-09-25T13:06:34Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -138,65 +150,99 @@ public int compare(Integer idx1, Integer idx2) {\n     }\n \n     int nonNullLength = values.length - nullCounter;\n+\n     //\n     // Compute rank\n     //\n \n-    int n = (int) Math.round(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n+    double p = this.percentile / 100.0D;\n+\n+    double pn = p * nonNullLength;\n \n     if (!this.interpolate) {\n-      if (n >= nonNullLength) {\n-        n--;\n+      // Type 1 in Hyndman, Rob & Fan, Yanan. (1996). Sample Quantiles in Statistical Packages. The American Statistician.\n+      int j = (int) Math.floor(pn);\n+      if (pn > j) {\n+        j++;\n       }", "originalCommit": "ddb081abe586e1e16ade29a28af8ca738ddcb6c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwMzExNw==", "url": "https://github.com/senx/warp10-platform/pull/849#discussion_r495003117", "bodyText": "Actually I think it's cleaner to do\nMath.floor(p*(nonNullLength -1))\nso there is no need to reindex from 1-indexed to 0-indexed", "author": "randomboolean", "createdAt": "2020-09-25T13:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3Mzg4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1NDMwOQ==", "url": "https://github.com/senx/warp10-platform/pull/849#discussion_r495754309", "bodyText": "That would lead to a different result. For instance with nonNullLength = 4 and p = 0.9:\nMath.ceil(p * nonNullLength) - 1 = 3\nMath.floor(p * (nonNullLength - 1)) = 2", "author": "ftence", "createdAt": "2020-09-28T07:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3Mzg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3NDE4Nw==", "url": "https://github.com/senx/warp10-platform/pull/849#discussion_r494974187", "bodyText": "why do you choose Type 8 ?", "author": "randomboolean", "createdAt": "2020-09-25T13:07:08Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -138,65 +150,99 @@ public int compare(Integer idx1, Integer idx2) {\n     }\n \n     int nonNullLength = values.length - nullCounter;\n+\n     //\n     // Compute rank\n     //\n \n-    int n = (int) Math.round(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n+    double p = this.percentile / 100.0D;\n+\n+    double pn = p * nonNullLength;\n \n     if (!this.interpolate) {\n-      if (n >= nonNullLength) {\n-        n--;\n+      // Type 1 in Hyndman, Rob & Fan, Yanan. (1996). Sample Quantiles in Statistical Packages. The American Statistician.\n+      int j = (int) Math.floor(pn);\n+      if (pn > j) {\n+        j++;\n       }\n-      return new Object[] {ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};\n+\n+      // Formula is 1-indexed, switch to 0-indexed.\n+      if (j > 0) {\n+        j--;\n+      }\n+\n+      return new Object[] {ticks[indices[j]], locations[indices[j]], elevations[indices[j]], values[indices[j]]};\n     } else {\n-      int m = (int) Math.floor(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n-\n-      double pn = (100.0 / nonNullLength) * (n + 1 - 0.5D);\n-      double pm = (100.0 / nonNullLength) * (m + 1 - 0.5D);\n-\n-      if (0 == n && this.percentile < pn) {\n-        return new Object[] {ticks[indices[0]], locations[indices[0]], elevations[indices[0]], values[indices[0]]};\n-      } else if (m == nonNullLength - 1 && this.percentile > pm) {\n-        return new Object[] {ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]]};\n-      } else if (pn == this.percentile) {\n-        return new Object[] {ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};\n-      } else if (pm == this.percentile) {\n-        return new Object[] {ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]]};\n-      } else if (pm < this.percentile && this.percentile < pn) {\n-        double factor = nonNullLength * (this.percentile - pm) / 100.0D;\n-\n-        long tick = (long) (ticks[indices[m]] + factor * (ticks[indices[n]] - ticks[indices[m]]));\n-        double v;\n-\n-        if (values[indices[m]] instanceof Long) {\n-          v = ((Number) values[indices[m]]).longValue() + factor * (((Number) values[indices[n]]).longValue() - ((Number) values[indices[m]]).longValue());\n-        } else {\n-          v = ((Number) values[indices[m]]).doubleValue() + factor * (((Number) values[indices[n]]).doubleValue() - ((Number) values[indices[m]]).doubleValue());\n-        }\n+      // Type 8 in Hyndman, Rob & Fan, Yanan. (1996). Sample Quantiles in Statistical Packages. The American Statistician.", "originalCommit": "ddb081abe586e1e16ade29a28af8ca738ddcb6c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3NTMwMg==", "url": "https://github.com/senx/warp10-platform/pull/849#discussion_r494975302", "bodyText": "The naming of this variable is confusing. The behaviour with interpolate = false is a type of interpolation.", "author": "randomboolean", "createdAt": "2020-09-25T13:09:09Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -57,26 +57,33 @@ public Builder(String name, boolean forbidNulls) {\n \n     @Override\n     public Object apply(WarpScriptStack stack) throws WarpScriptException {\n-      Object value = stack.pop();\n+      Object top = stack.pop();\n \n-      if (!(value instanceof Number)) {\n+      boolean interpolate = false;", "originalCommit": "ddb081abe586e1e16ade29a28af8ca738ddcb6c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA1MjcwNA==", "url": "https://github.com/senx/warp10-platform/pull/849#discussion_r495052704", "bodyText": "I disagree. Even if it isn't the term used by Hyndman (discontinuous and continuous is), interpolation make the behavior very clear: we're interpolating between GTS points or not. This is equally true for users which may not be experts in percentile but want to choose between a point in the original GTS or an interpolated point.", "author": "ftence", "createdAt": "2020-09-25T15:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3NTMwMg=="}], "type": "inlineReview"}, {"oid": "91dcb937ad3aa13e17dedeec409819e4cda35145", "url": "https://github.com/senx/warp10-platform/commit/91dcb937ad3aa13e17dedeec409819e4cda35145", "message": "Simplify code and more comments", "committedDate": "2020-09-25T15:16:02Z", "type": "commit"}, {"oid": "0ba2e8cc7aca416cf51af7571fc1f19ee44d67ea", "url": "https://github.com/senx/warp10-platform/commit/0ba2e8cc7aca416cf51af7571fc1f19ee44d67ea", "message": "Implement all Hyndman and Fan types", "committedDate": "2020-10-01T10:24:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk2ODYzNA==", "url": "https://github.com/senx/warp10-platform/pull/849#discussion_r500968634", "bodyText": "This will lead to invalid WarpScript, the type needs to be enclosed in single quotes.", "author": "hbs", "createdAt": "2020-10-07T12:24:45Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -138,73 +163,199 @@ public int compare(Integer idx1, Integer idx2) {\n     }\n \n     int nonNullLength = values.length - nullCounter;\n+\n     //\n     // Compute rank\n     //\n \n-    int n = (int) Math.round(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n+    double p = this.percentile / 100.0D;\n+\n+    double pn = p * nonNullLength;\n+\n+    //\n+    // Return the percentile depending on type.\n+    // As in the Hyndman paper we handle differently discontinuous types 1 to 3 and continuous types 4 to 9.\n+    // We first test type 1 because it is the default and can be optimized. It does not interpolate, gamma is either 0 or 1.\n+    // Types 2 and 3 must be handled separately because type 2 interpolates, gamma can take the value 0.5, while 3 does not.\n+    // Types 4 to 9 interpolate and only the m values changes so they are handled together.\n+    // Types 1 and 3, which do not interpolate, return the same type as the original GTS, either LONG or DOUBLE.\n+    // Other types return a DOUBLE GTS because they may interpolate between the original GTS datapoints.\n+    //\n+\n+    if (1 == type) {\n+      // If we strictly follow the formula we would code the following, but it can be simplified using ceil.\n+      // int j = (int) Math.floor(pn);\n+      // if (pn > j) {\n+      //   j++;\n+      // }\n+      int j = (int) Math.ceil(pn);\n+\n+      // Formula is 1-indexed, switch to 0-indexed.\n+      // If j==0 then the lowest value is taken, so keep j at 0.\n+      if (j > 0) {\n+        j--;\n+      }\n+\n+      return new Object[] {ticks[indices[j]], locations[indices[j]], elevations[indices[j]], values[indices[j]]};\n+    } else if (2 >= type) {\n+      // Type 2\n+\n+      int j = (int) Math.floor(pn);\n+      double g = pn - j;\n+\n+      double gamma = 1;\n+      if (Math.abs(g) < EPSILON) {\n+        // g ~= 0\n+        gamma = 0.5;\n+      }\n+\n+      // Formula is 1-indexed, switch to 0-indexed.\n+      j--;\n+\n+      return interpolate(nonNullLength, j, gamma, indices, ticks, locations, elevations, values);\n+    } else if (3 >= type) {\n+      // Type 3\n+      double m = -0.5D;\n+\n+      int j = (int) Math.floor(pn + m);\n+      double g = pn + m - j;\n+\n+      // A little simplification here. gamma can only be 0 or 1 which will respectively return X(j) or X(j+1).\n+      // So we make gamma an integer and return X(j+gamma).\n+      int gamma = 1;\n+      if (Math.abs(g) < EPSILON && 0 == (j % 2)) {\n+        // g ~= 0 and j even\n+        gamma = 0;\n+      }\n \n-    if (!this.interpolate) {\n-      if (n >= nonNullLength) {\n-        n--;\n+      // Formula is 1-indexed, switch to 0-indexed.\n+      // If (j + gamma)==0 then the lowest value is taken, so keep j + gamma at 0.\n+      if (j + gamma > 0) {\n+        j--;\n       }\n-      return new Object[] {ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};\n+\n+      return new Object[] {ticks[indices[j + gamma]], locations[indices[j + gamma]], elevations[indices[j + gamma]], values[indices[j + gamma]]};\n     } else {\n-      int m = (int) Math.floor(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n-\n-      double pn = (100.0 / nonNullLength) * (n + 1 - 0.5D);\n-      double pm = (100.0 / nonNullLength) * (m + 1 - 0.5D);\n-\n-      if (0 == n && this.percentile < pn) {\n-        return new Object[] {ticks[indices[0]], locations[indices[0]], elevations[indices[0]], values[indices[0]]};\n-      } else if (m == nonNullLength - 1 && this.percentile > pm) {\n-        return new Object[] {ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]]};\n-      } else if (pn == this.percentile) {\n-        return new Object[] {ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};\n-      } else if (pm == this.percentile) {\n-        return new Object[] {ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]]};\n-      } else if (pm < this.percentile && this.percentile < pn) {\n-        double factor = nonNullLength * (this.percentile - pm) / 100.0D;\n-\n-        long tick = (long) (ticks[indices[m]] + factor * (ticks[indices[n]] - ticks[indices[m]]));\n-        double v;\n-\n-        if (values[indices[m]] instanceof Long) {\n-          v = ((Number) values[indices[m]]).longValue() + factor * (((Number) values[indices[n]]).longValue() - ((Number) values[indices[m]]).longValue());\n-        } else {\n-          v = ((Number) values[indices[m]]).doubleValue() + factor * (((Number) values[indices[n]]).doubleValue() - ((Number) values[indices[m]]).doubleValue());\n-        }\n+      // Type 4 to 9\n+      // Type 7 is used by defaut in R.\n+      // Type 8 is the recommended by Hyndman and Fan.\n+      // Except on small samples, the difference between types is negligible.\n+\n+      double m;\n+      switch (type) {\n+        case 4:\n+          m = 0D;\n+          break;\n+        case 5:\n+          m = 0.5D;\n+          break;\n+        case 6:\n+          m = p;\n+          break;\n+        case 7:\n+          m = 1 - p;\n+          break;\n+        case 8:\n+          m = (p + 1) / 3D;\n+          break;\n+        case 9:\n+          m = p / 4D + 3.0D / 8.0D;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" given invalid type.\");\n+      }\n \n-        long location = GeoTimeSerie.NO_LOCATION;\n+      int j = (int) Math.floor(pn + m);\n+      double gamma = pn + m - j;\n \n-        if (GeoTimeSerie.NO_LOCATION != locations[indices[m]] && GeoTimeSerie.NO_LOCATION != locations[indices[n]]) {\n-          double[] latlonm = GeoXPLib.fromGeoXPPoint(locations[indices[m]]);\n-          double[] latlonn = GeoXPLib.fromGeoXPPoint(locations[indices[n]]);\n+      // Formula is 1-indexed, switch to 0-indexed.\n+      j--;\n \n-          double lat = latlonm[0] + factor * (latlonn[0] - latlonm[0]);\n-          double lon = latlonm[1] + factor * (latlonn[1] - latlonm[1]);\n+      return interpolate(nonNullLength, j, gamma, indices, ticks, locations, elevations, values);\n+    }\n+  }\n \n-          location = GeoXPLib.toGeoXPPoint(lat, lon);\n-        }\n+  private Object[] interpolate(int nonNullLength, int j, double gamma, Integer indices[], long[] ticks, long[] locations, long[] elevations, Object[] values) throws WarpScriptException {\n+    if (j < 0) {\n+      // j is -1, directly return the lowest value\n+      return new Object[] {ticks[indices[0]], locations[indices[0]], elevations[indices[0]], ((Number) values[indices[0]]).doubleValue()};\n+    }\n+    if (j >= nonNullLength - 1) {\n+      // j+1 is OOB, directly return highest value.\n+      return new Object[] {ticks[indices[nonNullLength - 1]], locations[indices[nonNullLength - 1]], elevations[indices[nonNullLength - 1]], ((Number) values[indices[nonNullLength - 1]]).doubleValue()};\n+    }\n \n-        long elevation = GeoTimeSerie.NO_ELEVATION;\n+    if (j + 1 == nonNullLength || Math.abs(gamma) < EPSILON) {\n+      // gamma ~= 0, in that case, do not interpolate and return value at j\n+      return new Object[] {ticks[indices[j]], locations[indices[j]], elevations[indices[j]], ((Number) values[indices[j]]).doubleValue()};\n+    }\n \n-        if (GeoTimeSerie.NO_LOCATION != elevations[indices[m]] && GeoTimeSerie.NO_ELEVATION != elevations[indices[n]]) {\n-          elevation = (long) (elevations[indices[m]] + factor * (elevations[indices[n]] - elevations[indices[m]]));\n-        }\n+    if (Math.abs(gamma - 1) < EPSILON) {\n+      // gamma ~= 1, in that case, do not interpolate and return value at j+1\n+      return new Object[] {ticks[indices[j + 1]], locations[indices[j + 1]], elevations[indices[j + 1]], ((Number) values[indices[j + 1]]).doubleValue()};\n+    }\n+\n+    // Check values are numeric\n+    if (!(values[0] instanceof Number)) {\n+      throw new WarpScriptException(getName() + \" can only interpolate on numeric values\");\n+    }\n+\n+    // Tick\n+    long tick = Math.round((1 - gamma) * ticks[indices[j]] + gamma * ticks[indices[j + 1]]);\n \n-        return new Object[] {tick, location, elevation, v};\n+    // Location\n+    long location;\n+    if (GeoTimeSerie.NO_LOCATION == locations[indices[j]]) {\n+      if (GeoTimeSerie.NO_LOCATION == locations[indices[j + 1]]) {\n+        location = GeoTimeSerie.NO_LOCATION;\n       } else {\n-        throw new WarpScriptException(\"Twilight zone!\");\n+        location = locations[indices[j + 1]];\n+      }\n+    } else {\n+      if (GeoTimeSerie.NO_LOCATION == locations[indices[j + 1]]) {\n+        location = locations[indices[j]];\n+      } else {\n+        // Both locations are valid, interpolate.\n+        double[] latlonj = GeoXPLib.fromGeoXPPoint(locations[indices[j]]);\n+        double[] latlonjp1 = GeoXPLib.fromGeoXPPoint(locations[indices[j + 1]]);\n+\n+        double lat = (1 - gamma) * latlonj[0] + gamma * latlonjp1[0];\n+        double lon = (1 - gamma) * latlonj[1] + gamma * latlonjp1[1];\n+\n+        location = GeoXPLib.toGeoXPPoint(lat, lon);\n       }\n     }\n+\n+    // Elevation\n+    long elevation;\n+    if (GeoTimeSerie.NO_ELEVATION == elevations[indices[j]]) {\n+      if (GeoTimeSerie.NO_ELEVATION == elevations[indices[j + 1]]) {\n+        elevation = GeoTimeSerie.NO_ELEVATION;\n+      } else {\n+        elevation = elevations[indices[j + 1]];\n+      }\n+    } else {\n+      if (GeoTimeSerie.NO_ELEVATION == elevations[indices[j + 1]]) {\n+        elevation = elevations[indices[j]];\n+      } else {\n+        // Both elevations are valid, interpolate.\n+        elevation = Math.round((1 - gamma) * elevations[indices[j]] + gamma * elevations[indices[j + 1]]);\n+      }\n+    }\n+\n+    // Value\n+    double value = (1 - gamma) * ((Number) values[indices[j]]).doubleValue() + gamma * ((Number) values[indices[j + 1]]).doubleValue();\n+\n+    return new Object[] {tick, location, elevation, value};\n   }\n \n   @Override\n   public String toString() {\n     StringBuilder sb = new StringBuilder();\n     sb.append(StackUtils.toString(this.percentile));\n     sb.append(\" \");\n+    sb.append(\"type\" + type);", "originalCommit": "0ba2e8cc7aca416cf51af7571fc1f19ee44d67ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "378055077283bbe2dcb91f60db2421db78a8bdbe", "url": "https://github.com/senx/warp10-platform/commit/378055077283bbe2dcb91f60db2421db78a8bdbe", "message": "Fix toString by adding quotes", "committedDate": "2020-10-07T15:21:27Z", "type": "commit"}]}