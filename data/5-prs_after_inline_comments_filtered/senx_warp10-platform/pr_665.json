{"pr_number": 665, "pr_title": "Duration.bucketize", "pr_createdAt": "2020-02-14T14:26:58Z", "pr_url": "https://github.com/senx/warp10-platform/pull/665", "timeline": [{"oid": "0ad901cb465741dc4612cb59f5555faf4566cc74", "url": "https://github.com/senx/warp10-platform/commit/0ad901cb465741dc4612cb59f5555faf4566cc74", "message": "refactor ADDDURATION for optimized use in other functions", "committedDate": "2020-02-14T14:23:13Z", "type": "commit"}, {"oid": "7c7d11c21c7973029790cb47668263d600a453a6", "url": "https://github.com/senx/warp10-platform/commit/7c7d11c21c7973029790cb47668263d600a453a6", "message": "minor changes addduration", "committedDate": "2020-02-14T14:23:13Z", "type": "commit"}, {"oid": "ae6495d55ef12e512f56a71608926be2bbbf8910", "url": "https://github.com/senx/warp10-platform/commit/ae6495d55ef12e512f56a71608926be2bbbf8910", "message": "add default method in bucketizer interface", "committedDate": "2020-02-14T14:23:13Z", "type": "commit"}, {"oid": "34c9c80509d096e6e59a34531ffe24fe6b4ace59", "url": "https://github.com/senx/warp10-platform/commit/34c9c80509d096e6e59a34531ffe24fe6b4ace59", "message": "duration.BUCKETIZE", "committedDate": "2020-02-14T14:23:13Z", "type": "commit"}, {"oid": "055a5212db999e9608b6ac4a4cb608777bda7910", "url": "https://github.com/senx/warp10-platform/commit/055a5212db999e9608b6ac4a4cb608777bda7910", "message": "to warpscriptlib", "committedDate": "2020-02-14T14:23:13Z", "type": "commit"}, {"oid": "7a9148840df6b42a6ece78e4792ec4702ec66f2a", "url": "https://github.com/senx/warp10-platform/commit/7a9148840df6b42a6ece78e4792ec4702ec66f2a", "message": "bugfix", "committedDate": "2020-02-14T14:23:13Z", "type": "commit"}, {"oid": "57487b799be1ee169dd6d4631f10f61ed89a5101", "url": "https://github.com/senx/warp10-platform/commit/57487b799be1ee169dd6d4631f10f61ed89a5101", "message": "DURATION.UNBUCKETIZE", "committedDate": "2020-02-14T14:23:13Z", "type": "commit"}, {"oid": "79e91277e7d7299cae51d47ddfc2d0fa6fb6393e", "url": "https://github.com/senx/warp10-platform/commit/79e91277e7d7299cae51d47ddfc2d0fa6fb6393e", "message": "update WarpScriptLib", "committedDate": "2020-02-14T14:23:13Z", "type": "commit"}, {"oid": "f42648207572f1850be981d25771eb9342019b69", "url": "https://github.com/senx/warp10-platform/commit/f42648207572f1850be981d25771eb9342019b69", "message": "bugfix", "committedDate": "2020-02-14T14:23:13Z", "type": "commit"}, {"oid": "46be149c8797dc014e8905d414010db37364b1df", "url": "https://github.com/senx/warp10-platform/commit/46be149c8797dc014e8905d414010db37364b1df", "message": "adapt to source 1.7", "committedDate": "2020-02-14T15:18:27Z", "type": "commit"}, {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "url": "https://github.com/senx/warp10-platform/commit/f8a5ecd6a6dff62faee2564121d0c539578e2f37", "message": "remove unecessary changes", "committedDate": "2020-02-14T15:19:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMTI1OA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379501258", "bodyText": "No underscore in class names", "author": "hbs", "createdAt": "2020-02-14T15:44:54Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {", "originalCommit": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMjI5Mw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379502293", "bodyText": "or a Geo Time Serie", "author": "hbs", "createdAt": "2020-02-14T15:46:37Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = \"DURATION.BUCKETIZE\";\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATION_BUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATION_BUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");", "originalCommit": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMzA0NQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379503045", "bodyText": "\"are not set\"\n\"duration-unbucketize IT first\"", "author": "hbs", "createdAt": "2020-02-14T15:47:58Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = \"DURATION.BUCKETIZE\";\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATION_BUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATION_BUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function, a macro, or NULL as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not be set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize them first before applying a new duration-bucketization.\");", "originalCommit": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMzM1Mw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379503353", "bodyText": "On line 90 you said you could use NULL", "author": "hbs", "createdAt": "2020-02-14T15:48:31Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = \"DURATION.BUCKETIZE\";\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATION_BUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATION_BUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function, a macro, or NULL as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not be set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize them first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");", "originalCommit": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMzY5OQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379503699", "bodyText": "Initialize it with the known size of series", "author": "hbs", "createdAt": "2020-02-14T15:49:03Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = \"DURATION.BUCKETIZE\";\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATION_BUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATION_BUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function, a macro, or NULL as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not be set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize them first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>();", "originalCommit": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMzg5Mw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379503893", "bodyText": "Use putToAttributes as attributes could be null", "author": "hbs", "createdAt": "2020-02-14T15:49:24Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = \"DURATION.BUCKETIZE\";\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATION_BUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATION_BUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function, a macro, or NULL as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not be set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize them first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>();\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().getAttributes().put(DURATION_ATTRIBUTE_KEY, bucketduration);", "originalCommit": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwNDgxNw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379504817", "bodyText": "Remove underscore", "author": "hbs", "createdAt": "2020-02-14T15:51:00Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_UNBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,81 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.GTSStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_UNBUCKETIZE extends GTSStackFunction {", "originalCommit": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwNTIxMg==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379505212", "bodyText": "Better define the name here and reference it in the function", "author": "hbs", "createdAt": "2020-02-14T15:51:41Z", "path": "warp10/src/main/java/io/warp10/script/WarpScriptLib.java", "diffHunk": "@@ -806,6 +806,7 @@\n   public static final String BUCKETSPAN = \"BUCKETSPAN\";\n   public static final String BUCKETCOUNT = \"BUCKETCOUNT\";\n   public static final String UNBUCKETIZE = \"UNBUCKETIZE\";\n+  public static final String DURATION_UNBUCKETIZE = io.warp10.script.functions.DURATION_UNBUCKETIZE.getDefaultName();", "originalCommit": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwNTI4OA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379505288", "bodyText": "ditto", "author": "hbs", "createdAt": "2020-02-14T15:51:49Z", "path": "warp10/src/main/java/io/warp10/script/WarpScriptLib.java", "diffHunk": "@@ -868,6 +869,7 @@\n   public static final String NBOUNDS = \"NBOUNDS\";\n   public static final String LBOUNDS = \"LBOUNDS\";\n   public static final String BUCKETIZE = \"BUCKETIZE\";\n+  public static final String DURATION_BUCKETIZE = io.warp10.script.functions.DURATION_BUCKETIZE.getDefaultName();", "originalCommit": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwNTU1Ng==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379505556", "bodyText": "Use a constant known to be a valid timezone for the parsing library", "author": "hbs", "createdAt": "2020-02-14T15:52:19Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,16 +78,75 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    if (null == tz) {\n+      tz = \"UTC\";", "originalCommit": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4e0d018283de1c312e2e2913f213111929ce5a63", "url": "https://github.com/senx/warp10-platform/commit/4e0d018283de1c312e2e2913f213111929ce5a63", "message": "renaming", "committedDate": "2020-02-14T16:03:48Z", "type": "commit"}, {"oid": "3cd5c179d602e0b69ade8412dcfae4f6f38f4fad", "url": "https://github.com/senx/warp10-platform/commit/3cd5c179d602e0b69ade8412dcfae4f6f38f4fad", "message": "improve error messages", "committedDate": "2020-02-14T16:06:24Z", "type": "commit"}, {"oid": "2478fd914cfad5b725730e6b85f8ca2557e32f6e", "url": "https://github.com/senx/warp10-platform/commit/2478fd914cfad5b725730e6b85f8ca2557e32f6e", "message": "fix put to attributes", "committedDate": "2020-02-14T16:10:39Z", "type": "commit"}, {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "url": "https://github.com/senx/warp10-platform/commit/687c8238516a57d7f5c8abfbabe823cbc5f517b4", "message": "resolve string comments", "committedDate": "2020-02-14T16:14:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3Mjc5NQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380772795", "bodyText": "@hbs Is UnsafeString allowed for new code?", "author": "ftence", "createdAt": "2020-02-18T16:07:58Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,16 +78,75 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (null != tz) {\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n     //\n     // Handle duration\n     //\n \n+    ReadWritablePeriodWithSubSecondOffset period = durationToPeriod(duration);\n+\n+    //\n+    // Do the computation\n+    //\n+\n+    boolean tselements = false;\n+    if (stack.peek() instanceof List) {\n+      FROMTSELEMENTS.apply(stack);\n+      tselements = true;\n+    }\n+\n+    long instant = ((Number) stack.pop()).longValue();\n+    stack.push(addPeriod(instant, period, dtz, N));\n+\n+    if (tselements) {\n+      TSELEMENTS.apply(stack);\n+    }\n+\n+    return stack;\n+  }\n+\n+  /**\n+   * A joda time period with sub second precision (the long offset).\n+   */\n+  public static class ReadWritablePeriodWithSubSecondOffset  {\n+    private final ReadWritablePeriod period;\n+    private final long offset;\n+\n+    public ReadWritablePeriodWithSubSecondOffset(ReadWritablePeriod period, long offset) {\n+     this.period = period;\n+     this.offset = offset;\n+    }\n+\n+    public ReadWritablePeriod getPeriod() {\n+      return period;\n+    }\n+\n+    public long getOffset() {\n+      return offset;\n+    }\n+  }\n+\n+  /**\n+   * Convert an ISO8601 duration to a Period.\n+   * @param duration\n+   * @return\n+   * @throws WarpScriptException\n+   */\n+  public static ReadWritablePeriodWithSubSecondOffset durationToPeriod(String duration) throws WarpScriptException {\n     // Separate seconds from  digits below second precision\n     String[] tokens = UnsafeString.split(duration, '.');", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyNzE4OQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382127189", "bodyText": "UnsafeString is a helper class which today uses Unsafe but will no longer do so in the JDK11+ branch, so using it is safe (!) as its split method will be refactored to drop the use of Unsafe in the future.", "author": "hbs", "createdAt": "2020-02-20T16:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3Mjc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3NDI4Nw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380774287", "bodyText": "Can throw a WarpScriptException without any info on the function name: rethrow with that info or add the function name to parameters of this method to build an exception with the function name.", "author": "ftence", "createdAt": "2020-02-18T16:10:04Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,16 +78,75 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (null != tz) {\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n     //\n     // Handle duration\n     //\n \n+    ReadWritablePeriodWithSubSecondOffset period = durationToPeriod(duration);", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NjIzMg==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381996232", "bodyText": "I think there was an previous case where @hbs disagreed. See #468 (comment)", "author": "randomboolean", "createdAt": "2020-02-20T13:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3NDI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA0ODQ4Mg==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382048482", "bodyText": "Then, use the other solution, that is wrap the exception in another one with the name.", "author": "ftence", "createdAt": "2020-02-20T14:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3NDI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3ODM4NA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380778384", "bodyText": "Check returned code to see if the parsing failed or not and throw if it is the case.", "author": "ftence", "createdAt": "2020-02-18T16:16:14Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();\n     ISOPeriodFormat.standard().getParser().parseInto(period, duration, 0, Locale.US);", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3OTk3OA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380779978", "bodyText": "Handle exceptions coming from the Double d_offset = Double.valueOf(\"0.\" + tmp) * STU; line above.", "author": "ftence", "createdAt": "2020-02-18T16:18:33Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4MjIwOQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380782209", "bodyText": "Also d_offset does not follow naming conventions.", "author": "ftence", "createdAt": "2020-02-18T16:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3OTk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4NTI2Ng==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380785266", "bodyText": "Also STU can be replaced by Constants.TIME_UNITS_PER_S and STU removed.", "author": "ftence", "createdAt": "2020-02-18T16:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3OTk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyOTcyOA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383329728", "bodyText": "Remove boxing around Constants.TIME_UNITS_PER_S.", "author": "ftence", "createdAt": "2020-02-24T15:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3OTk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzNTM1NA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383335354", "bodyText": "You can use Double.parseDouble instead of Double.valueOf to avoid boxing.", "author": "ftence", "createdAt": "2020-02-24T15:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3OTk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4ODgxOQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380788819", "bodyText": "Indentation.", "author": "ftence", "createdAt": "2020-02-18T16:31:50Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,16 +78,75 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (null != tz) {\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n     //\n     // Handle duration\n     //\n \n+    ReadWritablePeriodWithSubSecondOffset period = durationToPeriod(duration);\n+\n+    //\n+    // Do the computation\n+    //\n+\n+    boolean tselements = false;\n+    if (stack.peek() instanceof List) {\n+      FROMTSELEMENTS.apply(stack);\n+      tselements = true;\n+    }\n+\n+    long instant = ((Number) stack.pop()).longValue();\n+    stack.push(addPeriod(instant, period, dtz, N));\n+\n+    if (tselements) {\n+      TSELEMENTS.apply(stack);\n+    }\n+\n+    return stack;\n+  }\n+\n+  /**\n+   * A joda time period with sub second precision (the long offset).\n+   */\n+  public static class ReadWritablePeriodWithSubSecondOffset  {\n+    private final ReadWritablePeriod period;\n+    private final long offset;\n+\n+    public ReadWritablePeriodWithSubSecondOffset(ReadWritablePeriod period, long offset) {\n+     this.period = period;\n+     this.offset = offset;", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTA3NA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380789074", "bodyText": "Extra space before {.", "author": "ftence", "createdAt": "2020-02-18T16:32:14Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,16 +78,75 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (null != tz) {\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n     //\n     // Handle duration\n     //\n \n+    ReadWritablePeriodWithSubSecondOffset period = durationToPeriod(duration);\n+\n+    //\n+    // Do the computation\n+    //\n+\n+    boolean tselements = false;\n+    if (stack.peek() instanceof List) {\n+      FROMTSELEMENTS.apply(stack);\n+      tselements = true;\n+    }\n+\n+    long instant = ((Number) stack.pop()).longValue();\n+    stack.push(addPeriod(instant, period, dtz, N));\n+\n+    if (tselements) {\n+      TSELEMENTS.apply(stack);\n+    }\n+\n+    return stack;\n+  }\n+\n+  /**\n+   * A joda time period with sub second precision (the long offset).\n+   */\n+  public static class ReadWritablePeriodWithSubSecondOffset  {", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NDg4OA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380794888", "bodyText": "Not thrown.", "author": "ftence", "createdAt": "2020-02-18T16:41:15Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();\n     ISOPeriodFormat.standard().getParser().parseInto(period, duration, 0, Locale.US);\n \n-    //\n-    // Handle time zone\n-    //\n+    return new ReadWritablePeriodWithSubSecondOffset(period, offset);\n+  }\n \n-    if (null == tz) {\n-      tz = \"UTC\";\n-    }\n-    DateTimeZone dtz = DateTimeZone.forID(tz);\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz) {\n+    return addPeriod(instant, period, dtz, 1);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz, long N) {\n+    return addPeriod(instant, new ReadWritablePeriodWithSubSecondOffset(period, 0), dtz, N);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriodWithSubSecondOffset periodAndOffset, DateTimeZone dtz) {\n+    return addPeriod(instant, periodAndOffset, dtz, 1);\n+  }\n+\n+  /**\n+   * Add a duration in ISO8601 duration format to a timestamp\n+   * @param instant a timestamp since Unix Epoch\n+   * @param periodAndOffset a period (with subsecond precision) to add\n+   * @param dtz timezone\n+   * @param N number of times the period is added\n+   * @return\n+   * @throws WarpScriptException", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NTI3OA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380795278", "bodyText": "Add @return info.", "author": "ftence", "createdAt": "2020-02-18T16:41:51Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();\n     ISOPeriodFormat.standard().getParser().parseInto(period, duration, 0, Locale.US);\n \n-    //\n-    // Handle time zone\n-    //\n+    return new ReadWritablePeriodWithSubSecondOffset(period, offset);\n+  }\n \n-    if (null == tz) {\n-      tz = \"UTC\";\n-    }\n-    DateTimeZone dtz = DateTimeZone.forID(tz);\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz) {\n+    return addPeriod(instant, period, dtz, 1);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz, long N) {\n+    return addPeriod(instant, new ReadWritablePeriodWithSubSecondOffset(period, 0), dtz, N);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriodWithSubSecondOffset periodAndOffset, DateTimeZone dtz) {\n+    return addPeriod(instant, periodAndOffset, dtz, 1);\n+  }\n+\n+  /**\n+   * Add a duration in ISO8601 duration format to a timestamp\n+   * @param instant a timestamp since Unix Epoch\n+   * @param periodAndOffset a period (with subsecond precision) to add\n+   * @param dtz timezone\n+   * @param N number of times the period is added\n+   * @return", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NjA5Ng==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380796096", "bodyText": "Below is non_negative which do not follow naming conventions and also avoid negative forms.", "author": "ftence", "createdAt": "2020-02-18T16:43:12Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();\n     ISOPeriodFormat.standard().getParser().parseInto(period, duration, 0, Locale.US);\n \n-    //\n-    // Handle time zone\n-    //\n+    return new ReadWritablePeriodWithSubSecondOffset(period, offset);\n+  }\n \n-    if (null == tz) {\n-      tz = \"UTC\";\n-    }\n-    DateTimeZone dtz = DateTimeZone.forID(tz);\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz) {\n+    return addPeriod(instant, period, dtz, 1);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz, long N) {\n+    return addPeriod(instant, new ReadWritablePeriodWithSubSecondOffset(period, 0), dtz, N);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriodWithSubSecondOffset periodAndOffset, DateTimeZone dtz) {\n+    return addPeriod(instant, periodAndOffset, dtz, 1);\n+  }\n+\n+  /**\n+   * Add a duration in ISO8601 duration format to a timestamp\n+   * @param instant a timestamp since Unix Epoch\n+   * @param periodAndOffset a period (with subsecond precision) to add\n+   * @param dtz timezone\n+   * @param N number of times the period is added\n+   * @return\n+   * @throws WarpScriptException\n+   */\n+  public static long addPeriod(long instant, ReadWritablePeriodWithSubSecondOffset periodAndOffset, DateTimeZone dtz, long N) {\n+\n+    ReadWritablePeriod period = periodAndOffset.getPeriod();\n+    long offset = periodAndOffset.getOffset();\n \n     //\n     // Do the computation\n     //\n \n-    boolean tselements = false;\n-    if (stack.peek() instanceof List) {\n-      FROMTSELEMENTS.apply(stack);\n-      tselements = true;\n-    }\n-\n-    long instant = ((Number) stack.pop()).longValue();\n     DateTime dt = new DateTime(instant / Constants.TIME_UNITS_PER_MS, dtz);\n \n     //", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwOTE5NQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382009195", "bodyText": "In english, non-negative is used to refer to a number that is either positive or zero.", "author": "randomboolean", "createdAt": "2020-02-20T13:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NjA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwNzg3Mg==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380807872", "bodyText": "This is unclear what this class does with only this info. Maybe explaining the difference between duration and span can help.", "author": "ftence", "createdAt": "2020-02-18T17:01:55Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMTQ1MA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382011450", "bodyText": "Shouldn't the explanation be left to the documentation ?", "author": "randomboolean", "createdAt": "2020-02-20T13:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwNzg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA1MDExNQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382050115", "bodyText": "Keep it short if possible without too much detail. In this state, the current comment does not help.", "author": "ftence", "createdAt": "2020-02-20T14:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwNzg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDQxMA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380810410", "bodyText": "Instead of the negative lookahead, you can simply check that the length of the string is >2.\nThe (\\d+|\\d.(\\d)+) part is not good:\n\n\"1x234\" matches\n\"12.345\" does not matches", "author": "ftence", "createdAt": "2020-02-18T17:06:05Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyODQyMw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382128423", "bodyText": "Actually checking that it starts with a P and can be parsed by a time library is probably safer.", "author": "hbs", "createdAt": "2020-02-20T16:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxNDI4Mw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381314283", "bodyText": "Missing space before \"expects\".", "author": "ftence", "createdAt": "2020-02-19T14:12:09Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0ODY5Ng==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381848696", "bodyText": "Naming convention.", "author": "ftence", "createdAt": "2020-02-20T08:32:46Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1MDA4OQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381850089", "bodyText": "Will be checked in durationBucketize, is it really useful to pre-check here?", "author": "ftence", "createdAt": "2020-02-20T08:35:54Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxNDQ1Mw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382014453", "bodyText": "durationBucketize checks if it is of the correct type, and the error message will only inform that it is not. Here the error message also specifies that it was null, and save some computations.", "author": "randomboolean", "createdAt": "2020-02-20T13:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1MDA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1MjM4NQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381852385", "bodyText": "Would be easier to read by using a variable to store the attributes instead of repeating gts.getMetadata().getAttributes().", "author": "ftence", "createdAt": "2020-02-20T08:40:45Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1Mzg0Mg==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381853842", "bodyText": "You have to find another way or find an heuristic to speed-up this as it takes forever to run\n[\n  NEWGTS\n  bucketizer.last\n  NOW\n  'PT1.2S'\n  3\n]\nDURATION.BUCKETIZE", "author": "ftence", "createdAt": "2020-02-20T08:43:44Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1NDYwMQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382154601", "bodyText": "fixed by 728b407", "author": "randomboolean", "createdAt": "2020-02-20T17:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1Mzg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1NTA0Mw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381855043", "bodyText": "Why do you rename this constant?", "author": "ftence", "createdAt": "2020-02-20T08:46:03Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxODA5OA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382018098", "bodyText": "Initially that was the other way around but made a modification after a PR comment that kept it this way.", "author": "randomboolean", "createdAt": "2020-02-20T14:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1NTA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1OTg0NQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381859845", "bodyText": "You could merge that with the filling of series.", "author": "ftence", "createdAt": "2020-02-20T08:55:09Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg2MjI4NQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381862285", "bodyText": "Missing function name.", "author": "ftence", "createdAt": "2020-02-20T08:59:45Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg2OTg0NA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381869844", "bodyText": "Is it useful to check the format as it will also be checked by durationToPeriod?", "author": "ftence", "createdAt": "2020-02-20T09:13:56Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAyMzM5OA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382023398", "bodyText": "Yes, since here we do not support negative values but we do in durationToPeriod.", "author": "randomboolean", "createdAt": "2020-02-20T14:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg2OTg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3MDg4Mw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381870883", "bodyText": "Make it static.", "author": "ftence", "createdAt": "2020-02-20T09:15:50Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3MTU2OA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381871568", "bodyText": "Make it static.", "author": "ftence", "createdAt": "2020-02-20T09:17:01Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};\n+      parms[3] = GTSHelper.getTicks(subgts);\n+      if (subgts.hasLocations()) {\n+        parms[4] = GTSHelper.getLocations(subgts);\n+      } else {\n+        parms[4] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[4], GeoTimeSerie.NO_LOCATION);\n+      }\n+      if (subgts.hasElevations()) {\n+        parms[5] = GTSHelper.getElevations(subgts);\n+      } else {\n+        parms[5] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[5], GeoTimeSerie.NO_ELEVATION);\n+      }\n+      parms[6] = new Object[subgts.size()];\n+      parms[7] = new long[] {0, -1, bucketindex, bucketindex};\n+\n+      for (int j = 0; j < subgts.size(); j++) {\n+        ((Object[]) parms[6])[j] = GTSHelper.valueAtIndex(subgts, j);\n+      }\n+\n+      aggregated = (Object[]) ((WarpScriptBucketizerFunction) aggregator).apply(parms);\n+    }\n+\n+    //\n+    // Only set value if it is non null\n+    //\n+\n+    if (null != aggregated[3]) {\n+      GTSHelper.setValue(bucketized, bucketindex, (long) aggregated[1], (long) aggregated[2], aggregated[3], false);\n+    }\n+  }\n+\n+\n+  public GeoTimeSerie durationBucketize(GeoTimeSerie gts, ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod, DateTimeZone dtz, long bucketcount, long lastbucket, int lastbucket_index, Object aggregator, long maxbuckets, WarpScriptStack stack) throws WarpScriptException {", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MTA2MA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381881060", "bodyText": "Naming convention: lastbucket_index", "author": "ftence", "createdAt": "2020-02-20T09:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3MTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3MzIxOQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381873219", "bodyText": "Remove extra space.", "author": "ftence", "createdAt": "2020-02-20T09:20:09Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3MzYwNA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381873604", "bodyText": "Add space after [].", "author": "ftence", "createdAt": "2020-02-20T09:20:49Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MDI5Ng==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381880296", "bodyText": "Typo: firstTick", "author": "ftence", "createdAt": "2020-02-20T09:32:10Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};\n+      parms[3] = GTSHelper.getTicks(subgts);\n+      if (subgts.hasLocations()) {\n+        parms[4] = GTSHelper.getLocations(subgts);\n+      } else {\n+        parms[4] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[4], GeoTimeSerie.NO_LOCATION);\n+      }\n+      if (subgts.hasElevations()) {\n+        parms[5] = GTSHelper.getElevations(subgts);\n+      } else {\n+        parms[5] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[5], GeoTimeSerie.NO_ELEVATION);\n+      }\n+      parms[6] = new Object[subgts.size()];\n+      parms[7] = new long[] {0, -1, bucketindex, bucketindex};\n+\n+      for (int j = 0; j < subgts.size(); j++) {\n+        ((Object[]) parms[6])[j] = GTSHelper.valueAtIndex(subgts, j);\n+      }\n+\n+      aggregated = (Object[]) ((WarpScriptBucketizerFunction) aggregator).apply(parms);\n+    }\n+\n+    //\n+    // Only set value if it is non null\n+    //\n+\n+    if (null != aggregated[3]) {\n+      GTSHelper.setValue(bucketized, bucketindex, (long) aggregated[1], (long) aggregated[2], aggregated[3], false);\n+    }\n+  }\n+\n+\n+  public GeoTimeSerie durationBucketize(GeoTimeSerie gts, ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod, DateTimeZone dtz, long bucketcount, long lastbucket, int lastbucket_index, Object aggregator, long maxbuckets, WarpScriptStack stack) throws WarpScriptException {\n+\n+    long lastTick = GTSHelper.lasttick(gts);\n+    long firsTick = GTSHelper.firsttick(gts);", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MTgzNw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381881837", "bodyText": "No need to call String.valueOf.", "author": "ftence", "createdAt": "2020-02-20T09:34:48Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};\n+      parms[3] = GTSHelper.getTicks(subgts);\n+      if (subgts.hasLocations()) {\n+        parms[4] = GTSHelper.getLocations(subgts);\n+      } else {\n+        parms[4] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[4], GeoTimeSerie.NO_LOCATION);\n+      }\n+      if (subgts.hasElevations()) {\n+        parms[5] = GTSHelper.getElevations(subgts);\n+      } else {\n+        parms[5] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[5], GeoTimeSerie.NO_ELEVATION);\n+      }\n+      parms[6] = new Object[subgts.size()];\n+      parms[7] = new long[] {0, -1, bucketindex, bucketindex};\n+\n+      for (int j = 0; j < subgts.size(); j++) {\n+        ((Object[]) parms[6])[j] = GTSHelper.valueAtIndex(subgts, j);\n+      }\n+\n+      aggregated = (Object[]) ((WarpScriptBucketizerFunction) aggregator).apply(parms);\n+    }\n+\n+    //\n+    // Only set value if it is non null\n+    //\n+\n+    if (null != aggregated[3]) {\n+      GTSHelper.setValue(bucketized, bucketindex, (long) aggregated[1], (long) aggregated[2], aggregated[3], false);\n+    }\n+  }\n+\n+\n+  public GeoTimeSerie durationBucketize(GeoTimeSerie gts, ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod, DateTimeZone dtz, long bucketcount, long lastbucket, int lastbucket_index, Object aggregator, long maxbuckets, WarpScriptStack stack) throws WarpScriptException {\n+\n+    long lastTick = GTSHelper.lasttick(gts);\n+    long firsTick = GTSHelper.firsttick(gts);\n+    int hint = Math.min(gts.size(), (int) (1.05 * (lastTick - firsTick) / ADDDURATION.addPeriod(0, bucketperiod, dtz)));\n+\n+    GeoTimeSerie durationBucketized = gts.cloneEmpty(hint);\n+\n+    //\n+    // We loop through the input GTS values in reverse order\n+    // We feed a buffer of values while traversing\n+    //\n+\n+    GTSHelper.sort(gts);\n+    GeoTimeSerie subgts = gts.cloneEmpty();\n+\n+    if (null != stack) {\n+      if (!(aggregator instanceof Macro)) {\n+        throw new WarpScriptException(\"Expected a macro as bucketizer.\");\n+      }\n+    } else {\n+      if (!(aggregator instanceof WarpScriptBucketizerFunction)) {\n+        throw new WarpScriptException(\"Invalid bucketizer function.\");\n+      }\n+    }\n+\n+    // initialize bucketstart (start boundary), and bucketindex of current tick\n+    long bucketstart = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz, -1) + 1;\n+    int bucketindex = lastbucket_index;\n+\n+    for (int i = gts.size() - 1; i >= 0; i--) {\n+      long tick = GTSHelper.tickAtIndex(gts, i);\n+\n+      if (tick < bucketstart) {\n+\n+        //\n+        // Break off the loop if bucketcount is exceeded (except if it is equal to 0)\n+        //\n+\n+        if (bucketcount != 0 && lastbucket_index - bucketindex + 1 >= bucketcount) {\n+          break;\n+        }\n+\n+        if (lastbucket_index - bucketindex + 2 > maxbuckets) {\n+          throw new WarpScriptException(\"Bucket count (\" + String.valueOf(lastbucket_index - bucketindex + 2) + \") is exceeding maximum value of \" + maxbuckets);", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4Njk0NQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381886945", "bodyText": "Does not throw.", "author": "ftence", "createdAt": "2020-02-20T09:43:49Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};\n+      parms[3] = GTSHelper.getTicks(subgts);\n+      if (subgts.hasLocations()) {\n+        parms[4] = GTSHelper.getLocations(subgts);\n+      } else {\n+        parms[4] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[4], GeoTimeSerie.NO_LOCATION);\n+      }\n+      if (subgts.hasElevations()) {\n+        parms[5] = GTSHelper.getElevations(subgts);\n+      } else {\n+        parms[5] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[5], GeoTimeSerie.NO_ELEVATION);\n+      }\n+      parms[6] = new Object[subgts.size()];\n+      parms[7] = new long[] {0, -1, bucketindex, bucketindex};\n+\n+      for (int j = 0; j < subgts.size(); j++) {\n+        ((Object[]) parms[6])[j] = GTSHelper.valueAtIndex(subgts, j);\n+      }\n+\n+      aggregated = (Object[]) ((WarpScriptBucketizerFunction) aggregator).apply(parms);\n+    }\n+\n+    //\n+    // Only set value if it is non null\n+    //\n+\n+    if (null != aggregated[3]) {\n+      GTSHelper.setValue(bucketized, bucketindex, (long) aggregated[1], (long) aggregated[2], aggregated[3], false);\n+    }\n+  }\n+\n+\n+  public GeoTimeSerie durationBucketize(GeoTimeSerie gts, ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod, DateTimeZone dtz, long bucketcount, long lastbucket, int lastbucket_index, Object aggregator, long maxbuckets, WarpScriptStack stack) throws WarpScriptException {\n+\n+    long lastTick = GTSHelper.lasttick(gts);\n+    long firsTick = GTSHelper.firsttick(gts);\n+    int hint = Math.min(gts.size(), (int) (1.05 * (lastTick - firsTick) / ADDDURATION.addPeriod(0, bucketperiod, dtz)));\n+\n+    GeoTimeSerie durationBucketized = gts.cloneEmpty(hint);\n+\n+    //\n+    // We loop through the input GTS values in reverse order\n+    // We feed a buffer of values while traversing\n+    //\n+\n+    GTSHelper.sort(gts);\n+    GeoTimeSerie subgts = gts.cloneEmpty();\n+\n+    if (null != stack) {\n+      if (!(aggregator instanceof Macro)) {\n+        throw new WarpScriptException(\"Expected a macro as bucketizer.\");\n+      }\n+    } else {\n+      if (!(aggregator instanceof WarpScriptBucketizerFunction)) {\n+        throw new WarpScriptException(\"Invalid bucketizer function.\");\n+      }\n+    }\n+\n+    // initialize bucketstart (start boundary), and bucketindex of current tick\n+    long bucketstart = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz, -1) + 1;\n+    int bucketindex = lastbucket_index;\n+\n+    for (int i = gts.size() - 1; i >= 0; i--) {\n+      long tick = GTSHelper.tickAtIndex(gts, i);\n+\n+      if (tick < bucketstart) {\n+\n+        //\n+        // Break off the loop if bucketcount is exceeded (except if it is equal to 0)\n+        //\n+\n+        if (bucketcount != 0 && lastbucket_index - bucketindex + 1 >= bucketcount) {\n+          break;\n+        }\n+\n+        if (lastbucket_index - bucketindex + 2 > maxbuckets) {\n+          throw new WarpScriptException(\"Bucket count (\" + String.valueOf(lastbucket_index - bucketindex + 2) + \") is exceeding maximum value of \" + maxbuckets);\n+        }\n+\n+        //\n+        // Call the aggregation function on the last batch\n+        //\n+\n+        if (subgts.size() > 0) {\n+          aggregateAndSet(aggregator, subgts, durationBucketized, bucketindex, stack);\n+\n+          //\n+          // Reset buffer\n+          //\n+\n+          subgts = GTSHelper.shrinkTo(subgts, 0);\n+        }\n+      }\n+\n+      // update bucketstart and bucketindex\n+      while (tick < bucketstart) {\n+        bucketstart = ADDDURATION.addPeriod(bucketstart, bucketperiod, dtz, -1);\n+        bucketindex--;\n+      }\n+\n+      //  save value in subgts (if tick is not more recent than lastbucket)\n+      if (tick <= lastbucket) {\n+        GTSHelper.setValue(subgts, tick, GTSHelper.locationAtIndex(gts, i), GTSHelper.elevationAtIndex(gts, i), GTSHelper.valueAtIndex(gts, i), false);\n+      }\n+    }\n+\n+    //\n+    // Aggregate on the last batch\n+    //\n+\n+    if (subgts.size() > 0) {\n+      aggregateAndSet(aggregator, subgts, durationBucketized, bucketindex, stack);\n+    }\n+\n+    //\n+    // Set bucket parameters\n+    //\n+\n+    GTSHelper.setLastBucket(durationBucketized, lastbucket_index);\n+    GTSHelper.setBucketSpan(durationBucketized, 1);\n+    GTSHelper.setBucketCount(durationBucketized, bucketcount == 0 ? durationBucketized.size() : Math.toIntExact(bucketcount));\n+\n+    //\n+    // Reverse the order\n+    //\n+\n+    GTSHelper.sort(durationBucketized);\n+\n+    return durationBucketized;\n+  }\n+\n+  public static boolean isDurationBucketized(GeoTimeSerie gts) throws WarpScriptException {", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4Nzc3MA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381887770", "bodyText": "Fix and make it clearer.", "author": "ftence", "createdAt": "2020-02-20T09:45:18Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONUNBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,82 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.GTSStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAzMjQ0Ng==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382032446", "bodyText": "ditto", "author": "randomboolean", "createdAt": "2020-02-20T14:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4Nzc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4ODAxNg==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381888016", "bodyText": "Constant renaming?", "author": "ftence", "createdAt": "2020-02-20T09:45:43Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONUNBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,82 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.GTSStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONUNBUCKETIZE extends GTSStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_UNBUCKETIZE;", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNDYyNA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383324624", "bodyText": "Has not been addressed.", "author": "ftence", "createdAt": "2020-02-24T15:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4ODAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4OTYxNg==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381889616", "bodyText": "Handle exceptions if attributes have been tempered with.", "author": "ftence", "createdAt": "2020-02-20T09:48:27Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONUNBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,82 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.GTSStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONUNBUCKETIZE extends GTSStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_UNBUCKETIZE;\n+\n+  public DURATIONUNBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONUNBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  protected Map<String, Object> retrieveParameters(WarpScriptStack stack) throws WarpScriptException {\n+    return null;\n+  }\n+\n+  @Override\n+  protected Object gtsOp(Map<String, Object> params, GeoTimeSerie gts) throws WarpScriptException {\n+\n+    if (!GTSHelper.isBucketized(gts)) {\n+      throw new WarpScriptException(getName() + \" expects input GTS to be bucketized.\");\n+    }\n+\n+    if (!DURATIONBUCKETIZE.isDurationBucketized(gts)) {\n+      throw new WarpScriptException(getName() + \" expects input GTS to be duration-bucketized. This information is stored in attributes.\");\n+    }\n+\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(gts.getMetadata().getAttributes().get(DURATIONBUCKETIZE.DURATION_ATTRIBUTE_KEY));\n+    long bucketoffset = Long.parseLong(gts.getMetadata().getAttributes().get(DURATIONBUCKETIZE.OFFSET_ATTRIBUTE_KEY));\n+    DateTimeZone dtz = DateTimeZone.forID(gts.getMetadata().getAttributes().get(DURATIONBUCKETIZE.TIMEZONE_ATTRIBUTE_KEY));", "originalCommit": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAzNTAxMw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382035013", "bodyText": "This is done on the previous line by DURATIONBUCKETIZE.isDurationBucketized(gts).", "author": "randomboolean", "createdAt": "2020-02-20T14:32:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4OTYxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMTcwOQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383321709", "bodyText": "Not if they have been modified (not removed).", "author": "ftence", "createdAt": "2020-02-24T15:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4OTYxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxMDk3OA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r384510978", "bodyText": "If they have been modified by the user then it's up to him to know what this function is doing. (Similarly, for a bucketized GTS you can also only set its bucketize parameters for then applying functions that take into account that bucketize structure).", "author": "randomboolean", "createdAt": "2020-02-26T14:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4OTYxNg=="}], "type": "inlineReview"}, {"oid": "a51daf28d5dba7c00e0ad46209f2ae7f398a8a44", "url": "https://github.com/senx/warp10-platform/commit/a51daf28d5dba7c00e0ad46209f2ae7f398a8a44", "message": "throw error on parsing fail", "committedDate": "2020-02-20T14:21:53Z", "type": "commit"}, {"oid": "803b5ef1f2d386b22df4f9423ba5e7a02e56ef9c", "url": "https://github.com/senx/warp10-platform/commit/803b5ef1f2d386b22df4f9423ba5e7a02e56ef9c", "message": "resolve pr comments on ADDDURATION", "committedDate": "2020-02-20T14:21:53Z", "type": "commit"}, {"oid": "47f44964e53780261be5fca9fecc711e454b40c7", "url": "https://github.com/senx/warp10-platform/commit/47f44964e53780261be5fca9fecc711e454b40c7", "message": "resolve comments on DURATION.BUCKETIZE", "committedDate": "2020-02-20T14:21:53Z", "type": "commit"}, {"oid": "b8351b62c787f635e20bbb634e1098f57ad8503d", "url": "https://github.com/senx/warp10-platform/commit/b8351b62c787f635e20bbb634e1098f57ad8503d", "message": "fix unresolved resolved comment", "committedDate": "2020-02-20T14:28:38Z", "type": "commit"}, {"oid": "d7f625810d19ee6b24c03214419bb9f6cf1c9e48", "url": "https://github.com/senx/warp10-platform/commit/d7f625810d19ee6b24c03214419bb9f6cf1c9e48", "message": "resolve DURATION.UNBUCKETIZE comments", "committedDate": "2020-02-20T14:32:45Z", "type": "commit"}, {"oid": "17d0263a7d9b1efcf2aac9fa216e0153f4fc6ecc", "url": "https://github.com/senx/warp10-platform/commit/17d0263a7d9b1efcf2aac9fa216e0153f4fc6ecc", "message": "bugfix", "committedDate": "2020-02-20T15:49:52Z", "type": "commit"}, {"oid": "c3dcda580245cbfe097d70ae9f3af9cc7aa9424e", "url": "https://github.com/senx/warp10-platform/commit/c3dcda580245cbfe097d70ae9f3af9cc7aa9424e", "message": "more comments", "committedDate": "2020-02-20T15:57:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyODkyOA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382128928", "bodyText": "Why positive coefficients? Wouldn't P1M-1d be legitimate to support?", "author": "hbs", "createdAt": "2020-02-20T16:54:34Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,370 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ * The tick of the resulting buckets will be their index (number of bucketduration since Unix Epoch).\n+ * The goal is to make possible to apply functions for bucketized series on a series with bucket of irregular calendar bucket span.\n+ * To restore timestamp for ticks, there is DURATION.UNBUCKETIZE.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(getDefaultName());\n+  }\n+\n+  public static String getDefaultName() {\n+    return WarpScriptLib.DURATION_BUCKETIZE;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(getName() + \" error: bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      Map<String, String> attributes = gts.getMetadata().getAttributes();\n+      if (attributes.get(DURATION_ATTRIBUTE_KEY) != null || attributes.get(OFFSET_ATTRIBUTE_KEY) != null || attributes.get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \" expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");", "originalCommit": "c3dcda580245cbfe097d70ae9f3af9cc7aa9424e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MTMxNw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382151317", "bodyText": "Yes it could be. We could just check that the overall duration is positive.", "author": "randomboolean", "createdAt": "2020-02-20T17:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyODkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1ODE3Ng==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382158176", "bodyText": "Actually this one is tricky, the duration can be positive from some date and negative from others. For example, allowing P1M-31DT1H would make the computation go back and forth.", "author": "randomboolean", "createdAt": "2020-02-20T17:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyODkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2MjQ0OQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382162449", "bodyText": "You can throw an exception if you encounter an inconsistency while generating the indices", "author": "hbs", "createdAt": "2020-02-20T17:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyODkyOA=="}], "type": "inlineReview"}, {"oid": "728b40792447f0569e299dc4d2288e4fb1866557", "url": "https://github.com/senx/warp10-platform/commit/728b40792447f0569e299dc4d2288e4fb1866557", "message": "speed up small bucketduration", "committedDate": "2020-02-20T17:28:24Z", "type": "commit"}, {"oid": "870fd8724e66277d8dbf1b2f4dd2310784d822c3", "url": "https://github.com/senx/warp10-platform/commit/870fd8724e66277d8dbf1b2f4dd2310784d822c3", "message": "changes to checks on bucketduration", "committedDate": "2020-02-21T10:22:41Z", "type": "commit"}, {"oid": "243fd4675131fa5596146c570de2446b209ab360", "url": "https://github.com/senx/warp10-platform/commit/243fd4675131fa5596146c570de2446b209ab360", "message": "improve error messages", "committedDate": "2020-02-21T10:38:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjk2Nw==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383326967", "bodyText": "I think you should remove the space between oand :, correct me if I'm mistaken @hbs.\nSeveral occurrences in this PR.", "author": "ftence", "createdAt": "2020-02-24T15:19:59Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,420 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.continuum.store.Constants;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ * The tick of the resulting buckets will be their index (number of bucketduration since Unix Epoch).\n+ * The goal is to make possible to apply functions for bucketized series on a series with bucket of irregular calendar bucket span.\n+ * To restore timestamp for ticks, there is DURATION.UNBUCKETIZE.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(getDefaultName());\n+  }\n+\n+  public static String getDefaultName() {\n+    return WarpScriptLib.DURATION_BUCKETIZE;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {", "originalCommit": "243fd4675131fa5596146c570de2446b209ab360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4NTIyOQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383385229", "bodyText": "Are you sure about creating a new Instant each time?\nCould it be better to chose a fixed instant away from known special dates for instance to avoid leap-second, February and daylight saving changes?", "author": "ftence", "createdAt": "2020-02-24T16:50:35Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,420 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.continuum.store.Constants;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ * The tick of the resulting buckets will be their index (number of bucketduration since Unix Epoch).\n+ * The goal is to make possible to apply functions for bucketized series on a series with bucket of irregular calendar bucket span.\n+ * To restore timestamp for ticks, there is DURATION.UNBUCKETIZE.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(getDefaultName());\n+  }\n+\n+  public static String getDefaultName() {\n+    return WarpScriptLib.DURATION_BUCKETIZE;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(getName() + \" error: bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      Map<String, String> attributes = gts.getMetadata().getAttributes();\n+      if (attributes.get(DURATION_ATTRIBUTE_KEY) != null || attributes.get(OFFSET_ATTRIBUTE_KEY) != null || attributes.get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if ('P' != bucketduration.charAt(0)) {\n+      throw new WarpScriptException(getName() + \" expects that the bucketduration is in ISO8601 duration format.\");\n+    }\n+\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod;\n+    try {\n+      bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" encountered an exception: \" + wse.getMessage());\n+    }\n+\n+    //\n+    // Check that the bucketduration is positive\n+    //\n+\n+    long averageSpan = bucketperiod.getPeriod().toPeriod().toDurationFrom(new Instant()).getMillis() * Constants.TIME_UNITS_PER_MS + bucketperiod.getOffset();", "originalCommit": "243fd4675131fa5596146c570de2446b209ab360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNzI0NA==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r384507244", "bodyText": "Leap seconds are not supported by Unix timestamp. We don't use any particular timezone here so it is UTC which does not has daylight saving time. There can be a point with February but 1970 is not a leap year so that would only applies for durations > 2 years and that's not very impactful on our index hint.", "author": "randomboolean", "createdAt": "2020-02-26T13:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4NTIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MjU5OQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r385052599", "bodyText": "While you're right about leap seconds (Joda doesn't even support it) and daylight saving time, there are still 2 issues:\n\nnew Instant() is set to the system current milliseconds, so if you have a period of 1 month and you run that in February, you won't have the same result as if you run than in January.\nYou are instantiating an object each time while a single instance (static or not) should be enough.", "author": "ftence", "createdAt": "2020-02-27T10:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4NTIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4ODU3Ng==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383388576", "bodyText": "That's working very well to speed-up things for small bucket durations, congrats.\nHowever it seems it is extremely slow with negative last bucket:\n-1582560100948303 'now' STORE\n\n[\n  NEWGTS\n  $now NaN NaN NaN T ADDVALUE\n  bucketizer.last\n  $now 1.2 s +\n  'PT1.2S'\n  3\n]\nDURATION.BUCKETIZE", "author": "ftence", "createdAt": "2020-02-24T16:56:12Z", "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,420 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.continuum.store.Constants;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ * The tick of the resulting buckets will be their index (number of bucketduration since Unix Epoch).\n+ * The goal is to make possible to apply functions for bucketized series on a series with bucket of irregular calendar bucket span.\n+ * To restore timestamp for ticks, there is DURATION.UNBUCKETIZE.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(getDefaultName());\n+  }\n+\n+  public static String getDefaultName() {\n+    return WarpScriptLib.DURATION_BUCKETIZE;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(getName() + \" error: bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      Map<String, String> attributes = gts.getMetadata().getAttributes();\n+      if (attributes.get(DURATION_ATTRIBUTE_KEY) != null || attributes.get(OFFSET_ATTRIBUTE_KEY) != null || attributes.get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if ('P' != bucketduration.charAt(0)) {\n+      throw new WarpScriptException(getName() + \" expects that the bucketduration is in ISO8601 duration format.\");\n+    }\n+\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod;\n+    try {\n+      bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" encountered an exception: \" + wse.getMessage());\n+    }\n+\n+    //\n+    // Check that the bucketduration is positive\n+    //\n+\n+    long averageSpan = bucketperiod.getPeriod().toPeriod().toDurationFrom(new Instant()).getMillis() * Constants.TIME_UNITS_PER_MS + bucketperiod.getOffset();\n+    if (averageSpan < 0) {\n+      throw new WarpScriptException(getName() + \" expects the bucketduration parameter to be a positive ISO8601 duration.\");\n+    }\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long flag = 0; // always equal to epoch modulo period\n+    long bucketoffset;\n+    int lastbucketIndex;\n+\n+    //\n+    // Starting from Epoch, we make a hint and land the flag close to lastbucket\n+    //\n+\n+    if (lastbucket > 0) {\n+      int lastbucketIndexHint = Math.toIntExact(lastbucket / averageSpan);\n+      flag = addNonNegativePeriod(flag, bucketperiod, dtz, lastbucketIndexHint + 1);\n+      lastbucketIndex = lastbucketIndexHint;\n+\n+    } else {\n+      int lastbucketIndexHint = - Math.toIntExact(lastbucket / averageSpan);\n+      flag = addNonNegativePeriod(flag, bucketperiod, dtz, lastbucketIndexHint);\n+      lastbucketIndex = lastbucketIndexHint - 1;\n+    }\n+\n+    //\n+    // We move the flag left and right on the time axis to make sure lastbucket is its leftmost bucketend\n+    //\n+\n+    while (flag > lastbucket) {\n+      flag = addNonNegativePeriod(flag, bucketperiod, dtz, -1);\n+      lastbucketIndex--;\n+    }\n+\n+    while (flag <= lastbucket) {\n+      flag = addNonNegativePeriod(flag, bucketperiod, dtz, 1);\n+      lastbucketIndex++;\n+    }\n+\n+    bucketoffset = flag - (lastbucket + 1);", "originalCommit": "243fd4675131fa5596146c570de2446b209ab360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM4NDM2OQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r384384369", "bodyText": "Bugfix ac3ddee", "author": "randomboolean", "createdAt": "2020-02-26T09:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4ODU3Ng=="}], "type": "inlineReview"}, {"oid": "66e1127765473f77e05f477de2872d5eb9f7c38f", "url": "https://github.com/senx/warp10-platform/commit/66e1127765473f77e05f477de2872d5eb9f7c38f", "message": "Merge branch 'master' of github.com:senx/warp10-platform into DURATION.BUCKETIZE", "committedDate": "2020-02-26T09:06:52Z", "type": "commit"}, {"oid": "0709690162218106d638072bdecc420b73a48ec9", "url": "https://github.com/senx/warp10-platform/commit/0709690162218106d638072bdecc420b73a48ec9", "message": "handle long indices in ADDDURATION", "committedDate": "2020-02-26T09:53:15Z", "type": "commit"}, {"oid": "ac3ddee77f4c9c250b9cf57ecf13d6514e78cd30", "url": "https://github.com/senx/warp10-platform/commit/ac3ddee77f4c9c250b9cf57ecf13d6514e78cd30", "message": "bugfix negative timestamp", "committedDate": "2020-02-26T09:53:55Z", "type": "commit"}, {"oid": "b7ab4b76867bb7c32170836afc6f9a86b51765f3", "url": "https://github.com/senx/warp10-platform/commit/b7ab4b76867bb7c32170836afc6f9a86b51765f3", "message": "handle very big and small lasbuckets", "committedDate": "2020-02-26T13:47:18Z", "type": "commit"}, {"oid": "9acd6b98df82230f445ce717d89e36734d2778eb", "url": "https://github.com/senx/warp10-platform/commit/9acd6b98df82230f445ce717d89e36734d2778eb", "message": "default name Unbuck", "committedDate": "2020-02-26T14:06:00Z", "type": "commit"}, {"oid": "ab9215bd971e7e4a2bf7c968d0457cf9d5c0188d", "url": "https://github.com/senx/warp10-platform/commit/ab9215bd971e7e4a2bf7c968d0457cf9d5c0188d", "message": "boxing", "committedDate": "2020-02-26T14:11:49Z", "type": "commit"}, {"oid": "5f81bb772e56a4e8ced2a3726d82587ea6c6f527", "url": "https://github.com/senx/warp10-platform/commit/5f81bb772e56a4e8ced2a3726d82587ea6c6f527", "message": "semicolon", "committedDate": "2020-02-26T14:16:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxNjU1NQ==", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r385016555", "bodyText": "Better to add wse as a cause to the new Exception than only getting the message.", "author": "ftence", "createdAt": "2020-02-27T09:49:06Z", "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,48 +77,130 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (null != tz) {\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n     //\n     // Handle duration\n     //\n \n+    ReadWritablePeriodWithSubSecondOffset period;\n+    try {\n+      period = durationToPeriod(duration);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" encountered an exception: \" + wse.getMessage());", "originalCommit": "5f81bb772e56a4e8ced2a3726d82587ea6c6f527", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b8a42caa4705afa345789e6216c3a87fee2bba83", "url": "https://github.com/senx/warp10-platform/commit/b8a42caa4705afa345789e6216c3a87fee2bba83", "message": "get cause of wse", "committedDate": "2020-02-27T11:14:37Z", "type": "commit"}, {"oid": "e6fbd9aea710ea989a5c8e5e2a01c01289dcd069", "url": "https://github.com/senx/warp10-platform/commit/e6fbd9aea710ea989a5c8e5e2a01c01289dcd069", "message": "use EPOCH", "committedDate": "2020-02-27T11:19:24Z", "type": "commit"}, {"oid": "9fe160bbc1967ff9d7cf00f28d6c4f331137caee", "url": "https://github.com/senx/warp10-platform/commit/9fe160bbc1967ff9d7cf00f28d6c4f331137caee", "message": "remove message in wse", "committedDate": "2020-02-27T11:58:04Z", "type": "commit"}, {"oid": "d965df7232dded18dd0c2364a581937eaf7221fc", "url": "https://github.com/senx/warp10-platform/commit/d965df7232dded18dd0c2364a581937eaf7221fc", "message": "renaming by swapping DURATION from prefix to suffix", "committedDate": "2020-02-27T13:13:05Z", "type": "commit"}, {"oid": "8f63fda8b7f82995b1fb4758b8371e087962e15e", "url": "https://github.com/senx/warp10-platform/commit/8f63fda8b7f82995b1fb4758b8371e087962e15e", "message": "remove getCause()", "committedDate": "2020-02-27T13:14:32Z", "type": "commit"}, {"oid": "69412ce8204664ddfb91983bbd7014bf119c2747", "url": "https://github.com/senx/warp10-platform/commit/69412ce8204664ddfb91983bbd7014bf119c2747", "message": "renaming ..DURATION to ..CALENDAR", "committedDate": "2020-02-27T14:20:33Z", "type": "commit"}]}