{"pr_number": 858, "pr_title": "Make DTW work on locations and elevations and add window parameter", "pr_createdAt": "2020-10-09T11:23:58Z", "pr_url": "https://github.com/senx/warp10-platform/pull/858", "timeline": [{"oid": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "url": "https://github.com/senx/warp10-platform/commit/ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "message": "Make DTW work on locations and elevations and add window parameter", "committedDate": "2020-10-09T11:23:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0MTkwNQ==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502441905", "bodyText": "<= 0.0D", "author": "hbs", "createdAt": "2020-10-09T13:52:05Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -16,186 +16,372 @@\n \n package io.warp10.script.functions;\n \n-import java.math.BigDecimal;\n-\n+import com.geoxp.GeoXPLib;\n import io.warp10.DoubleUtils;\n import io.warp10.continuum.gts.GTSHelper;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.continuum.gts.GeoTimeSerie.TYPE;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.Arrays;\n \n /**\n- * Perform Dynamic Time Warping distance computation\n- * between values of two GTS.\n- * \n+ * Perform Dynamic Time Warping pseudo-distance computation between two GTSs.\n+ * It can be done on values, locations, elevations or timestamps.\n  */\n public class DTW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-  \n+\n+  // Constants to specify on which characteristic of the GTSs we want to do the DTW.\n+  // Define as power of 2 in case we want to combine them.\n+  public static final int TIMESTAMPS = 1;\n+  public static final int LOCATIONS = 2;\n+  public static final int ELEVATIONS = 4;\n+  public static final int VALUES = 8;\n+\n   /**\n    * Should we normalize?\n    */\n   private final boolean normalize;\n-  \n+\n   /**\n    * Should we do Z-Normalization or 0-1 normalization?\n    */\n   private final boolean znormalize;\n-  \n+\n   public DTW(String name, boolean normalize, boolean znormalize) {\n     super(name);\n     this.normalize = normalize;\n     this.znormalize = znormalize;\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object o = stack.pop();\n-    \n+\n+    int type = VALUES;\n+    DTWDistance distance = DTW::manhattan;\n+\n+    // Optional GTS characteristic to apply DTW on.\n+    if (o instanceof String) {\n+      String charac = ((String) o).toLowerCase();\n+      switch (charac) {\n+        case \"values\":\n+          type = VALUES;\n+          break;\n+        case \"locations\":\n+          type = LOCATIONS;\n+          break;\n+        case \"elevations\":\n+          type = ELEVATIONS;\n+          break;\n+        case \"timestamps\":\n+          type = TIMESTAMPS;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the characteristic of the GTS to compute the DTW on to be values, locations, elevations or timestamps.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n+    // Optional distance spec\n+    if (o instanceof String) {\n+      String dist = ((String) o).toLowerCase();\n+\n+      switch (dist) {\n+        case \"manhattan\":\n+          distance = DTW::manhattan;\n+          break;\n+        case \"euclidean\":\n+          distance = DTW::euclidean;\n+          break;\n+        case \"loxodromic\":\n+          distance = DTW::loxodromic;\n+          break;\n+        case \"orthodromic\":\n+          distance = DTW::orthodromic;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the distance to use in the DTW to be manhattan, euclidean, loxodromic or orthodromic.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof Number)) {\n       throw new WarpScriptException(getName() + \" expects a numeric threshold on top of the stack.\");\n     }\n-    \n+\n     double threshold = ((Number) o).doubleValue();\n-    \n+\n+    // If the threshold is not strictly positive, consider there is no threshold.\n+    if (threshold <= 0) {", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0MjE2MQ==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502442161", "bodyText": "threshold is a double, why set it to Long.MAX_VALUE?", "author": "hbs", "createdAt": "2020-10-09T13:52:30Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -16,186 +16,372 @@\n \n package io.warp10.script.functions;\n \n-import java.math.BigDecimal;\n-\n+import com.geoxp.GeoXPLib;\n import io.warp10.DoubleUtils;\n import io.warp10.continuum.gts.GTSHelper;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.continuum.gts.GeoTimeSerie.TYPE;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.Arrays;\n \n /**\n- * Perform Dynamic Time Warping distance computation\n- * between values of two GTS.\n- * \n+ * Perform Dynamic Time Warping pseudo-distance computation between two GTSs.\n+ * It can be done on values, locations, elevations or timestamps.\n  */\n public class DTW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-  \n+\n+  // Constants to specify on which characteristic of the GTSs we want to do the DTW.\n+  // Define as power of 2 in case we want to combine them.\n+  public static final int TIMESTAMPS = 1;\n+  public static final int LOCATIONS = 2;\n+  public static final int ELEVATIONS = 4;\n+  public static final int VALUES = 8;\n+\n   /**\n    * Should we normalize?\n    */\n   private final boolean normalize;\n-  \n+\n   /**\n    * Should we do Z-Normalization or 0-1 normalization?\n    */\n   private final boolean znormalize;\n-  \n+\n   public DTW(String name, boolean normalize, boolean znormalize) {\n     super(name);\n     this.normalize = normalize;\n     this.znormalize = znormalize;\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object o = stack.pop();\n-    \n+\n+    int type = VALUES;\n+    DTWDistance distance = DTW::manhattan;\n+\n+    // Optional GTS characteristic to apply DTW on.\n+    if (o instanceof String) {\n+      String charac = ((String) o).toLowerCase();\n+      switch (charac) {\n+        case \"values\":\n+          type = VALUES;\n+          break;\n+        case \"locations\":\n+          type = LOCATIONS;\n+          break;\n+        case \"elevations\":\n+          type = ELEVATIONS;\n+          break;\n+        case \"timestamps\":\n+          type = TIMESTAMPS;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the characteristic of the GTS to compute the DTW on to be values, locations, elevations or timestamps.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n+    // Optional distance spec\n+    if (o instanceof String) {\n+      String dist = ((String) o).toLowerCase();\n+\n+      switch (dist) {\n+        case \"manhattan\":\n+          distance = DTW::manhattan;\n+          break;\n+        case \"euclidean\":\n+          distance = DTW::euclidean;\n+          break;\n+        case \"loxodromic\":\n+          distance = DTW::loxodromic;\n+          break;\n+        case \"orthodromic\":\n+          distance = DTW::orthodromic;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the distance to use in the DTW to be manhattan, euclidean, loxodromic or orthodromic.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof Number)) {\n       throw new WarpScriptException(getName() + \" expects a numeric threshold on top of the stack.\");\n     }\n-    \n+\n     double threshold = ((Number) o).doubleValue();\n-    \n+\n+    // If the threshold is not strictly positive, consider there is no threshold.\n+    if (threshold <= 0) {\n+      threshold = Long.MAX_VALUE;", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0MjY0Ng==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502442646", "bodyText": "Since the window is actually a LONG, it would be better if the parameter was checked as being a LONG", "author": "hbs", "createdAt": "2020-10-09T13:53:12Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -16,186 +16,372 @@\n \n package io.warp10.script.functions;\n \n-import java.math.BigDecimal;\n-\n+import com.geoxp.GeoXPLib;\n import io.warp10.DoubleUtils;\n import io.warp10.continuum.gts.GTSHelper;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.continuum.gts.GeoTimeSerie.TYPE;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.Arrays;\n \n /**\n- * Perform Dynamic Time Warping distance computation\n- * between values of two GTS.\n- * \n+ * Perform Dynamic Time Warping pseudo-distance computation between two GTSs.\n+ * It can be done on values, locations, elevations or timestamps.\n  */\n public class DTW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-  \n+\n+  // Constants to specify on which characteristic of the GTSs we want to do the DTW.\n+  // Define as power of 2 in case we want to combine them.\n+  public static final int TIMESTAMPS = 1;\n+  public static final int LOCATIONS = 2;\n+  public static final int ELEVATIONS = 4;\n+  public static final int VALUES = 8;\n+\n   /**\n    * Should we normalize?\n    */\n   private final boolean normalize;\n-  \n+\n   /**\n    * Should we do Z-Normalization or 0-1 normalization?\n    */\n   private final boolean znormalize;\n-  \n+\n   public DTW(String name, boolean normalize, boolean znormalize) {\n     super(name);\n     this.normalize = normalize;\n     this.znormalize = znormalize;\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object o = stack.pop();\n-    \n+\n+    int type = VALUES;\n+    DTWDistance distance = DTW::manhattan;\n+\n+    // Optional GTS characteristic to apply DTW on.\n+    if (o instanceof String) {\n+      String charac = ((String) o).toLowerCase();\n+      switch (charac) {\n+        case \"values\":\n+          type = VALUES;\n+          break;\n+        case \"locations\":\n+          type = LOCATIONS;\n+          break;\n+        case \"elevations\":\n+          type = ELEVATIONS;\n+          break;\n+        case \"timestamps\":\n+          type = TIMESTAMPS;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the characteristic of the GTS to compute the DTW on to be values, locations, elevations or timestamps.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n+    // Optional distance spec\n+    if (o instanceof String) {\n+      String dist = ((String) o).toLowerCase();\n+\n+      switch (dist) {\n+        case \"manhattan\":\n+          distance = DTW::manhattan;\n+          break;\n+        case \"euclidean\":\n+          distance = DTW::euclidean;\n+          break;\n+        case \"loxodromic\":\n+          distance = DTW::loxodromic;\n+          break;\n+        case \"orthodromic\":\n+          distance = DTW::orthodromic;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the distance to use in the DTW to be manhattan, euclidean, loxodromic or orthodromic.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof Number)) {\n       throw new WarpScriptException(getName() + \" expects a numeric threshold on top of the stack.\");\n     }\n-    \n+\n     double threshold = ((Number) o).doubleValue();\n-    \n+\n+    // If the threshold is not strictly positive, consider there is no threshold.\n+    if (threshold <= 0) {\n+      threshold = Long.MAX_VALUE;\n+    }\n+\n     o = stack.pop();\n-    \n+\n+    // Optional window parameter.\n+    int window = Integer.MAX_VALUE;\n+\n+    if (o instanceof Number) {", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0Mzc5Mg==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502443792", "bodyText": "Explain in a comment why valuesX now have 2 dimensions.", "author": "hbs", "createdAt": "2020-10-09T13:54:55Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -16,186 +16,372 @@\n \n package io.warp10.script.functions;\n \n-import java.math.BigDecimal;\n-\n+import com.geoxp.GeoXPLib;\n import io.warp10.DoubleUtils;\n import io.warp10.continuum.gts.GTSHelper;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.continuum.gts.GeoTimeSerie.TYPE;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.Arrays;\n \n /**\n- * Perform Dynamic Time Warping distance computation\n- * between values of two GTS.\n- * \n+ * Perform Dynamic Time Warping pseudo-distance computation between two GTSs.\n+ * It can be done on values, locations, elevations or timestamps.\n  */\n public class DTW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-  \n+\n+  // Constants to specify on which characteristic of the GTSs we want to do the DTW.\n+  // Define as power of 2 in case we want to combine them.\n+  public static final int TIMESTAMPS = 1;\n+  public static final int LOCATIONS = 2;\n+  public static final int ELEVATIONS = 4;\n+  public static final int VALUES = 8;\n+\n   /**\n    * Should we normalize?\n    */\n   private final boolean normalize;\n-  \n+\n   /**\n    * Should we do Z-Normalization or 0-1 normalization?\n    */\n   private final boolean znormalize;\n-  \n+\n   public DTW(String name, boolean normalize, boolean znormalize) {\n     super(name);\n     this.normalize = normalize;\n     this.znormalize = znormalize;\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object o = stack.pop();\n-    \n+\n+    int type = VALUES;\n+    DTWDistance distance = DTW::manhattan;\n+\n+    // Optional GTS characteristic to apply DTW on.\n+    if (o instanceof String) {\n+      String charac = ((String) o).toLowerCase();\n+      switch (charac) {\n+        case \"values\":\n+          type = VALUES;\n+          break;\n+        case \"locations\":\n+          type = LOCATIONS;\n+          break;\n+        case \"elevations\":\n+          type = ELEVATIONS;\n+          break;\n+        case \"timestamps\":\n+          type = TIMESTAMPS;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the characteristic of the GTS to compute the DTW on to be values, locations, elevations or timestamps.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n+    // Optional distance spec\n+    if (o instanceof String) {\n+      String dist = ((String) o).toLowerCase();\n+\n+      switch (dist) {\n+        case \"manhattan\":\n+          distance = DTW::manhattan;\n+          break;\n+        case \"euclidean\":\n+          distance = DTW::euclidean;\n+          break;\n+        case \"loxodromic\":\n+          distance = DTW::loxodromic;\n+          break;\n+        case \"orthodromic\":\n+          distance = DTW::orthodromic;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the distance to use in the DTW to be manhattan, euclidean, loxodromic or orthodromic.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof Number)) {\n       throw new WarpScriptException(getName() + \" expects a numeric threshold on top of the stack.\");\n     }\n-    \n+\n     double threshold = ((Number) o).doubleValue();\n-    \n+\n+    // If the threshold is not strictly positive, consider there is no threshold.\n+    if (threshold <= 0) {\n+      threshold = Long.MAX_VALUE;\n+    }\n+\n     o = stack.pop();\n-    \n+\n+    // Optional window parameter.\n+    int window = Integer.MAX_VALUE;\n+\n+    if (o instanceof Number) {\n+      window = (int) Math.min(Integer.MAX_VALUE, ((Number) o).longValue());\n+\n+      // If the window is negative, consider there is no window.\n+      if (window < 0) {\n+        window = Integer.MAX_VALUE;\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts1 = (GeoTimeSerie) o;\n \n     o = stack.pop();\n-    \n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts2 = (GeoTimeSerie) o;\n \n-    stack.push(compute(gts1,gts2,threshold));\n+    //\n+    // Compute DTW and push it to the stack\n+    //\n+\n+    double d;\n+    try {\n+      d = compute(gts1, gts2, window, threshold, type, distance);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" failed.\", wse);\n+    }\n+\n+    stack.push(d);\n \n     return stack;\n   }\n-  \n+\n   /**\n-   * Compute Dynamic Time Warping on two GTS, aborting if the threshold is exceeded\n-   * \n-   * @param gts1 First GTS\n-   * @param gts2 Second GTS\n-   * @param threshold Threshold used to abort, use 0.0D if you don't want to abort the DTW\n-   * @return The computed DTW distance or -1 if the threshold is exceeded\n-   * \n-   * @throws WarpScriptException If an error occurs\n+   * Compute the DTW pseudo-distance on two GTS.\n+   * @param gts1 One of the two GTSs to compare to the other.\n+   * @param gts2 One of the two GTSs to compare to the other.\n+   * @param window The window defining th maximum index difference when matching the GTSs. Integer.MAX_VALUE for no window constraint.\n+   * @param threshold The maximum value of DTW. If the computed pseudo-distance is over this value, it is aborted and returns -1;\n+   * @param type The characteristic of the GTSs to run the DTW on.\n+   * @param distance The distance to use to compare GTS values.\n+   * @return The pseudo-distance, -1 if the value would be over threshold.\n+   * @throws WarpScriptException in case the DTW cannot be computed given the parameters.\n    */\n-  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, double threshold) throws WarpScriptException {\n-        \n+  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, int window, double threshold, int type, DTWDistance distance) throws WarpScriptException {\n+\n     //\n     // Check that the type of the GTS is numerical\n     //\n-    \n-    if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n-    }\n-    \n-    if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+    if (VALUES == type) {\n+      if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n+\n+      if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n     }\n \n     //\n     // Sort GTS in chronological order\n     //\n-    \n+\n     GTSHelper.sort(gts1);\n     GTSHelper.sort(gts2);\n-    \n+\n     //\n     // Extract values, compute min/max and quantize values (x - max/(max - min))\n     //\n-    \n-    double[] values1 = GTSHelper.getValuesAsDouble(gts1);        \n-    double[] values2 = GTSHelper.getValuesAsDouble(gts2);\n+    double[][] values1;", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0NDQ2NA==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502444464", "bodyText": "applied to them", "author": "hbs", "createdAt": "2020-10-09T13:55:50Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -16,186 +16,372 @@\n \n package io.warp10.script.functions;\n \n-import java.math.BigDecimal;\n-\n+import com.geoxp.GeoXPLib;\n import io.warp10.DoubleUtils;\n import io.warp10.continuum.gts.GTSHelper;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.continuum.gts.GeoTimeSerie.TYPE;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.Arrays;\n \n /**\n- * Perform Dynamic Time Warping distance computation\n- * between values of two GTS.\n- * \n+ * Perform Dynamic Time Warping pseudo-distance computation between two GTSs.\n+ * It can be done on values, locations, elevations or timestamps.\n  */\n public class DTW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-  \n+\n+  // Constants to specify on which characteristic of the GTSs we want to do the DTW.\n+  // Define as power of 2 in case we want to combine them.\n+  public static final int TIMESTAMPS = 1;\n+  public static final int LOCATIONS = 2;\n+  public static final int ELEVATIONS = 4;\n+  public static final int VALUES = 8;\n+\n   /**\n    * Should we normalize?\n    */\n   private final boolean normalize;\n-  \n+\n   /**\n    * Should we do Z-Normalization or 0-1 normalization?\n    */\n   private final boolean znormalize;\n-  \n+\n   public DTW(String name, boolean normalize, boolean znormalize) {\n     super(name);\n     this.normalize = normalize;\n     this.znormalize = znormalize;\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object o = stack.pop();\n-    \n+\n+    int type = VALUES;\n+    DTWDistance distance = DTW::manhattan;\n+\n+    // Optional GTS characteristic to apply DTW on.\n+    if (o instanceof String) {\n+      String charac = ((String) o).toLowerCase();\n+      switch (charac) {\n+        case \"values\":\n+          type = VALUES;\n+          break;\n+        case \"locations\":\n+          type = LOCATIONS;\n+          break;\n+        case \"elevations\":\n+          type = ELEVATIONS;\n+          break;\n+        case \"timestamps\":\n+          type = TIMESTAMPS;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the characteristic of the GTS to compute the DTW on to be values, locations, elevations or timestamps.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n+    // Optional distance spec\n+    if (o instanceof String) {\n+      String dist = ((String) o).toLowerCase();\n+\n+      switch (dist) {\n+        case \"manhattan\":\n+          distance = DTW::manhattan;\n+          break;\n+        case \"euclidean\":\n+          distance = DTW::euclidean;\n+          break;\n+        case \"loxodromic\":\n+          distance = DTW::loxodromic;\n+          break;\n+        case \"orthodromic\":\n+          distance = DTW::orthodromic;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the distance to use in the DTW to be manhattan, euclidean, loxodromic or orthodromic.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof Number)) {\n       throw new WarpScriptException(getName() + \" expects a numeric threshold on top of the stack.\");\n     }\n-    \n+\n     double threshold = ((Number) o).doubleValue();\n-    \n+\n+    // If the threshold is not strictly positive, consider there is no threshold.\n+    if (threshold <= 0) {\n+      threshold = Long.MAX_VALUE;\n+    }\n+\n     o = stack.pop();\n-    \n+\n+    // Optional window parameter.\n+    int window = Integer.MAX_VALUE;\n+\n+    if (o instanceof Number) {\n+      window = (int) Math.min(Integer.MAX_VALUE, ((Number) o).longValue());\n+\n+      // If the window is negative, consider there is no window.\n+      if (window < 0) {\n+        window = Integer.MAX_VALUE;\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts1 = (GeoTimeSerie) o;\n \n     o = stack.pop();\n-    \n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts2 = (GeoTimeSerie) o;\n \n-    stack.push(compute(gts1,gts2,threshold));\n+    //\n+    // Compute DTW and push it to the stack\n+    //\n+\n+    double d;\n+    try {\n+      d = compute(gts1, gts2, window, threshold, type, distance);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" failed.\", wse);\n+    }\n+\n+    stack.push(d);\n \n     return stack;\n   }\n-  \n+\n   /**\n-   * Compute Dynamic Time Warping on two GTS, aborting if the threshold is exceeded\n-   * \n-   * @param gts1 First GTS\n-   * @param gts2 Second GTS\n-   * @param threshold Threshold used to abort, use 0.0D if you don't want to abort the DTW\n-   * @return The computed DTW distance or -1 if the threshold is exceeded\n-   * \n-   * @throws WarpScriptException If an error occurs\n+   * Compute the DTW pseudo-distance on two GTS.\n+   * @param gts1 One of the two GTSs to compare to the other.\n+   * @param gts2 One of the two GTSs to compare to the other.\n+   * @param window The window defining th maximum index difference when matching the GTSs. Integer.MAX_VALUE for no window constraint.\n+   * @param threshold The maximum value of DTW. If the computed pseudo-distance is over this value, it is aborted and returns -1;\n+   * @param type The characteristic of the GTSs to run the DTW on.\n+   * @param distance The distance to use to compare GTS values.\n+   * @return The pseudo-distance, -1 if the value would be over threshold.\n+   * @throws WarpScriptException in case the DTW cannot be computed given the parameters.\n    */\n-  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, double threshold) throws WarpScriptException {\n-        \n+  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, int window, double threshold, int type, DTWDistance distance) throws WarpScriptException {\n+\n     //\n     // Check that the type of the GTS is numerical\n     //\n-    \n-    if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n-    }\n-    \n-    if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+    if (VALUES == type) {\n+      if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n+\n+      if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n     }\n \n     //\n     // Sort GTS in chronological order\n     //\n-    \n+\n     GTSHelper.sort(gts1);\n     GTSHelper.sort(gts2);\n-    \n+\n     //\n     // Extract values, compute min/max and quantize values (x - max/(max - min))\n     //\n-    \n-    double[] values1 = GTSHelper.getValuesAsDouble(gts1);        \n-    double[] values2 = GTSHelper.getValuesAsDouble(gts2);\n+    double[][] values1;\n+    double[][] values2;\n \n-    if (this.normalize) {\n-      if (this.znormalize) {\n-        //\n-        // Perform Z-Normalization of values1 and values2\n-        //\n-        \n-        double[] musigma = DoubleUtils.musigma(values1, true);\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          values1[i] = (values1[i] - musigma[0]) / musigma[1];\n-        }\n-        \n-        musigma = DoubleUtils.muvar(values2);\n-        for (int i = 0; i < values2.length; i++) {\n-          values2[i] = (values2[i] - musigma[0]) / musigma[1];\n+    if (VALUES == type) {\n+      values1 = new double[][] {GTSHelper.getValuesAsDouble(gts1)};\n+      values2 = new double[][] {GTSHelper.getValuesAsDouble(gts2)};\n+    } else if (LOCATIONS == type) {\n+      long[] locations1 = GTSHelper.getOriginalLocations(gts1);\n+      if (null == locations1) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n+      }\n+\n+      values1 = new double[2][locations1.length];\n+      for (int i = 0; i < locations1.length; i++) {\n+        if (GeoTimeSerie.NO_LOCATION == locations1[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0NDUzNw==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502444537", "bodyText": "applied to them", "author": "hbs", "createdAt": "2020-10-09T13:55:57Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -16,186 +16,372 @@\n \n package io.warp10.script.functions;\n \n-import java.math.BigDecimal;\n-\n+import com.geoxp.GeoXPLib;\n import io.warp10.DoubleUtils;\n import io.warp10.continuum.gts.GTSHelper;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.continuum.gts.GeoTimeSerie.TYPE;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.Arrays;\n \n /**\n- * Perform Dynamic Time Warping distance computation\n- * between values of two GTS.\n- * \n+ * Perform Dynamic Time Warping pseudo-distance computation between two GTSs.\n+ * It can be done on values, locations, elevations or timestamps.\n  */\n public class DTW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-  \n+\n+  // Constants to specify on which characteristic of the GTSs we want to do the DTW.\n+  // Define as power of 2 in case we want to combine them.\n+  public static final int TIMESTAMPS = 1;\n+  public static final int LOCATIONS = 2;\n+  public static final int ELEVATIONS = 4;\n+  public static final int VALUES = 8;\n+\n   /**\n    * Should we normalize?\n    */\n   private final boolean normalize;\n-  \n+\n   /**\n    * Should we do Z-Normalization or 0-1 normalization?\n    */\n   private final boolean znormalize;\n-  \n+\n   public DTW(String name, boolean normalize, boolean znormalize) {\n     super(name);\n     this.normalize = normalize;\n     this.znormalize = znormalize;\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object o = stack.pop();\n-    \n+\n+    int type = VALUES;\n+    DTWDistance distance = DTW::manhattan;\n+\n+    // Optional GTS characteristic to apply DTW on.\n+    if (o instanceof String) {\n+      String charac = ((String) o).toLowerCase();\n+      switch (charac) {\n+        case \"values\":\n+          type = VALUES;\n+          break;\n+        case \"locations\":\n+          type = LOCATIONS;\n+          break;\n+        case \"elevations\":\n+          type = ELEVATIONS;\n+          break;\n+        case \"timestamps\":\n+          type = TIMESTAMPS;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the characteristic of the GTS to compute the DTW on to be values, locations, elevations or timestamps.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n+    // Optional distance spec\n+    if (o instanceof String) {\n+      String dist = ((String) o).toLowerCase();\n+\n+      switch (dist) {\n+        case \"manhattan\":\n+          distance = DTW::manhattan;\n+          break;\n+        case \"euclidean\":\n+          distance = DTW::euclidean;\n+          break;\n+        case \"loxodromic\":\n+          distance = DTW::loxodromic;\n+          break;\n+        case \"orthodromic\":\n+          distance = DTW::orthodromic;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the distance to use in the DTW to be manhattan, euclidean, loxodromic or orthodromic.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof Number)) {\n       throw new WarpScriptException(getName() + \" expects a numeric threshold on top of the stack.\");\n     }\n-    \n+\n     double threshold = ((Number) o).doubleValue();\n-    \n+\n+    // If the threshold is not strictly positive, consider there is no threshold.\n+    if (threshold <= 0) {\n+      threshold = Long.MAX_VALUE;\n+    }\n+\n     o = stack.pop();\n-    \n+\n+    // Optional window parameter.\n+    int window = Integer.MAX_VALUE;\n+\n+    if (o instanceof Number) {\n+      window = (int) Math.min(Integer.MAX_VALUE, ((Number) o).longValue());\n+\n+      // If the window is negative, consider there is no window.\n+      if (window < 0) {\n+        window = Integer.MAX_VALUE;\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts1 = (GeoTimeSerie) o;\n \n     o = stack.pop();\n-    \n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts2 = (GeoTimeSerie) o;\n \n-    stack.push(compute(gts1,gts2,threshold));\n+    //\n+    // Compute DTW and push it to the stack\n+    //\n+\n+    double d;\n+    try {\n+      d = compute(gts1, gts2, window, threshold, type, distance);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" failed.\", wse);\n+    }\n+\n+    stack.push(d);\n \n     return stack;\n   }\n-  \n+\n   /**\n-   * Compute Dynamic Time Warping on two GTS, aborting if the threshold is exceeded\n-   * \n-   * @param gts1 First GTS\n-   * @param gts2 Second GTS\n-   * @param threshold Threshold used to abort, use 0.0D if you don't want to abort the DTW\n-   * @return The computed DTW distance or -1 if the threshold is exceeded\n-   * \n-   * @throws WarpScriptException If an error occurs\n+   * Compute the DTW pseudo-distance on two GTS.\n+   * @param gts1 One of the two GTSs to compare to the other.\n+   * @param gts2 One of the two GTSs to compare to the other.\n+   * @param window The window defining th maximum index difference when matching the GTSs. Integer.MAX_VALUE for no window constraint.\n+   * @param threshold The maximum value of DTW. If the computed pseudo-distance is over this value, it is aborted and returns -1;\n+   * @param type The characteristic of the GTSs to run the DTW on.\n+   * @param distance The distance to use to compare GTS values.\n+   * @return The pseudo-distance, -1 if the value would be over threshold.\n+   * @throws WarpScriptException in case the DTW cannot be computed given the parameters.\n    */\n-  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, double threshold) throws WarpScriptException {\n-        \n+  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, int window, double threshold, int type, DTWDistance distance) throws WarpScriptException {\n+\n     //\n     // Check that the type of the GTS is numerical\n     //\n-    \n-    if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n-    }\n-    \n-    if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+    if (VALUES == type) {\n+      if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n+\n+      if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n     }\n \n     //\n     // Sort GTS in chronological order\n     //\n-    \n+\n     GTSHelper.sort(gts1);\n     GTSHelper.sort(gts2);\n-    \n+\n     //\n     // Extract values, compute min/max and quantize values (x - max/(max - min))\n     //\n-    \n-    double[] values1 = GTSHelper.getValuesAsDouble(gts1);        \n-    double[] values2 = GTSHelper.getValuesAsDouble(gts2);\n+    double[][] values1;\n+    double[][] values2;\n \n-    if (this.normalize) {\n-      if (this.znormalize) {\n-        //\n-        // Perform Z-Normalization of values1 and values2\n-        //\n-        \n-        double[] musigma = DoubleUtils.musigma(values1, true);\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          values1[i] = (values1[i] - musigma[0]) / musigma[1];\n-        }\n-        \n-        musigma = DoubleUtils.muvar(values2);\n-        for (int i = 0; i < values2.length; i++) {\n-          values2[i] = (values2[i] - musigma[0]) / musigma[1];\n+    if (VALUES == type) {\n+      values1 = new double[][] {GTSHelper.getValuesAsDouble(gts1)};\n+      values2 = new double[][] {GTSHelper.getValuesAsDouble(gts2)};\n+    } else if (LOCATIONS == type) {\n+      long[] locations1 = GTSHelper.getOriginalLocations(gts1);\n+      if (null == locations1) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0NjA2MA==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502446060", "bodyText": "You should explain earlier that the locations1.length is used as the second dimension so you allocate less arrays", "author": "hbs", "createdAt": "2020-10-09T13:58:17Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -16,186 +16,372 @@\n \n package io.warp10.script.functions;\n \n-import java.math.BigDecimal;\n-\n+import com.geoxp.GeoXPLib;\n import io.warp10.DoubleUtils;\n import io.warp10.continuum.gts.GTSHelper;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.continuum.gts.GeoTimeSerie.TYPE;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.Arrays;\n \n /**\n- * Perform Dynamic Time Warping distance computation\n- * between values of two GTS.\n- * \n+ * Perform Dynamic Time Warping pseudo-distance computation between two GTSs.\n+ * It can be done on values, locations, elevations or timestamps.\n  */\n public class DTW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-  \n+\n+  // Constants to specify on which characteristic of the GTSs we want to do the DTW.\n+  // Define as power of 2 in case we want to combine them.\n+  public static final int TIMESTAMPS = 1;\n+  public static final int LOCATIONS = 2;\n+  public static final int ELEVATIONS = 4;\n+  public static final int VALUES = 8;\n+\n   /**\n    * Should we normalize?\n    */\n   private final boolean normalize;\n-  \n+\n   /**\n    * Should we do Z-Normalization or 0-1 normalization?\n    */\n   private final boolean znormalize;\n-  \n+\n   public DTW(String name, boolean normalize, boolean znormalize) {\n     super(name);\n     this.normalize = normalize;\n     this.znormalize = znormalize;\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object o = stack.pop();\n-    \n+\n+    int type = VALUES;\n+    DTWDistance distance = DTW::manhattan;\n+\n+    // Optional GTS characteristic to apply DTW on.\n+    if (o instanceof String) {\n+      String charac = ((String) o).toLowerCase();\n+      switch (charac) {\n+        case \"values\":\n+          type = VALUES;\n+          break;\n+        case \"locations\":\n+          type = LOCATIONS;\n+          break;\n+        case \"elevations\":\n+          type = ELEVATIONS;\n+          break;\n+        case \"timestamps\":\n+          type = TIMESTAMPS;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the characteristic of the GTS to compute the DTW on to be values, locations, elevations or timestamps.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n+    // Optional distance spec\n+    if (o instanceof String) {\n+      String dist = ((String) o).toLowerCase();\n+\n+      switch (dist) {\n+        case \"manhattan\":\n+          distance = DTW::manhattan;\n+          break;\n+        case \"euclidean\":\n+          distance = DTW::euclidean;\n+          break;\n+        case \"loxodromic\":\n+          distance = DTW::loxodromic;\n+          break;\n+        case \"orthodromic\":\n+          distance = DTW::orthodromic;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the distance to use in the DTW to be manhattan, euclidean, loxodromic or orthodromic.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof Number)) {\n       throw new WarpScriptException(getName() + \" expects a numeric threshold on top of the stack.\");\n     }\n-    \n+\n     double threshold = ((Number) o).doubleValue();\n-    \n+\n+    // If the threshold is not strictly positive, consider there is no threshold.\n+    if (threshold <= 0) {\n+      threshold = Long.MAX_VALUE;\n+    }\n+\n     o = stack.pop();\n-    \n+\n+    // Optional window parameter.\n+    int window = Integer.MAX_VALUE;\n+\n+    if (o instanceof Number) {\n+      window = (int) Math.min(Integer.MAX_VALUE, ((Number) o).longValue());\n+\n+      // If the window is negative, consider there is no window.\n+      if (window < 0) {\n+        window = Integer.MAX_VALUE;\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts1 = (GeoTimeSerie) o;\n \n     o = stack.pop();\n-    \n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts2 = (GeoTimeSerie) o;\n \n-    stack.push(compute(gts1,gts2,threshold));\n+    //\n+    // Compute DTW and push it to the stack\n+    //\n+\n+    double d;\n+    try {\n+      d = compute(gts1, gts2, window, threshold, type, distance);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" failed.\", wse);\n+    }\n+\n+    stack.push(d);\n \n     return stack;\n   }\n-  \n+\n   /**\n-   * Compute Dynamic Time Warping on two GTS, aborting if the threshold is exceeded\n-   * \n-   * @param gts1 First GTS\n-   * @param gts2 Second GTS\n-   * @param threshold Threshold used to abort, use 0.0D if you don't want to abort the DTW\n-   * @return The computed DTW distance or -1 if the threshold is exceeded\n-   * \n-   * @throws WarpScriptException If an error occurs\n+   * Compute the DTW pseudo-distance on two GTS.\n+   * @param gts1 One of the two GTSs to compare to the other.\n+   * @param gts2 One of the two GTSs to compare to the other.\n+   * @param window The window defining th maximum index difference when matching the GTSs. Integer.MAX_VALUE for no window constraint.\n+   * @param threshold The maximum value of DTW. If the computed pseudo-distance is over this value, it is aborted and returns -1;\n+   * @param type The characteristic of the GTSs to run the DTW on.\n+   * @param distance The distance to use to compare GTS values.\n+   * @return The pseudo-distance, -1 if the value would be over threshold.\n+   * @throws WarpScriptException in case the DTW cannot be computed given the parameters.\n    */\n-  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, double threshold) throws WarpScriptException {\n-        \n+  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, int window, double threshold, int type, DTWDistance distance) throws WarpScriptException {\n+\n     //\n     // Check that the type of the GTS is numerical\n     //\n-    \n-    if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n-    }\n-    \n-    if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+    if (VALUES == type) {\n+      if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n+\n+      if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n     }\n \n     //\n     // Sort GTS in chronological order\n     //\n-    \n+\n     GTSHelper.sort(gts1);\n     GTSHelper.sort(gts2);\n-    \n+\n     //\n     // Extract values, compute min/max and quantize values (x - max/(max - min))\n     //\n-    \n-    double[] values1 = GTSHelper.getValuesAsDouble(gts1);        \n-    double[] values2 = GTSHelper.getValuesAsDouble(gts2);\n+    double[][] values1;\n+    double[][] values2;\n \n-    if (this.normalize) {\n-      if (this.znormalize) {\n-        //\n-        // Perform Z-Normalization of values1 and values2\n-        //\n-        \n-        double[] musigma = DoubleUtils.musigma(values1, true);\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          values1[i] = (values1[i] - musigma[0]) / musigma[1];\n-        }\n-        \n-        musigma = DoubleUtils.muvar(values2);\n-        for (int i = 0; i < values2.length; i++) {\n-          values2[i] = (values2[i] - musigma[0]) / musigma[1];\n+    if (VALUES == type) {\n+      values1 = new double[][] {GTSHelper.getValuesAsDouble(gts1)};\n+      values2 = new double[][] {GTSHelper.getValuesAsDouble(gts2)};\n+    } else if (LOCATIONS == type) {\n+      long[] locations1 = GTSHelper.getOriginalLocations(gts1);\n+      if (null == locations1) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n+      }\n+\n+      values1 = new double[2][locations1.length];", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0NjY4NQ==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502446685", "bodyText": "applied to them", "author": "hbs", "createdAt": "2020-10-09T13:59:07Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -16,186 +16,372 @@\n \n package io.warp10.script.functions;\n \n-import java.math.BigDecimal;\n-\n+import com.geoxp.GeoXPLib;\n import io.warp10.DoubleUtils;\n import io.warp10.continuum.gts.GTSHelper;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.continuum.gts.GeoTimeSerie.TYPE;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.Arrays;\n \n /**\n- * Perform Dynamic Time Warping distance computation\n- * between values of two GTS.\n- * \n+ * Perform Dynamic Time Warping pseudo-distance computation between two GTSs.\n+ * It can be done on values, locations, elevations or timestamps.\n  */\n public class DTW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-  \n+\n+  // Constants to specify on which characteristic of the GTSs we want to do the DTW.\n+  // Define as power of 2 in case we want to combine them.\n+  public static final int TIMESTAMPS = 1;\n+  public static final int LOCATIONS = 2;\n+  public static final int ELEVATIONS = 4;\n+  public static final int VALUES = 8;\n+\n   /**\n    * Should we normalize?\n    */\n   private final boolean normalize;\n-  \n+\n   /**\n    * Should we do Z-Normalization or 0-1 normalization?\n    */\n   private final boolean znormalize;\n-  \n+\n   public DTW(String name, boolean normalize, boolean znormalize) {\n     super(name);\n     this.normalize = normalize;\n     this.znormalize = znormalize;\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object o = stack.pop();\n-    \n+\n+    int type = VALUES;\n+    DTWDistance distance = DTW::manhattan;\n+\n+    // Optional GTS characteristic to apply DTW on.\n+    if (o instanceof String) {\n+      String charac = ((String) o).toLowerCase();\n+      switch (charac) {\n+        case \"values\":\n+          type = VALUES;\n+          break;\n+        case \"locations\":\n+          type = LOCATIONS;\n+          break;\n+        case \"elevations\":\n+          type = ELEVATIONS;\n+          break;\n+        case \"timestamps\":\n+          type = TIMESTAMPS;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the characteristic of the GTS to compute the DTW on to be values, locations, elevations or timestamps.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n+    // Optional distance spec\n+    if (o instanceof String) {\n+      String dist = ((String) o).toLowerCase();\n+\n+      switch (dist) {\n+        case \"manhattan\":\n+          distance = DTW::manhattan;\n+          break;\n+        case \"euclidean\":\n+          distance = DTW::euclidean;\n+          break;\n+        case \"loxodromic\":\n+          distance = DTW::loxodromic;\n+          break;\n+        case \"orthodromic\":\n+          distance = DTW::orthodromic;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the distance to use in the DTW to be manhattan, euclidean, loxodromic or orthodromic.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof Number)) {\n       throw new WarpScriptException(getName() + \" expects a numeric threshold on top of the stack.\");\n     }\n-    \n+\n     double threshold = ((Number) o).doubleValue();\n-    \n+\n+    // If the threshold is not strictly positive, consider there is no threshold.\n+    if (threshold <= 0) {\n+      threshold = Long.MAX_VALUE;\n+    }\n+\n     o = stack.pop();\n-    \n+\n+    // Optional window parameter.\n+    int window = Integer.MAX_VALUE;\n+\n+    if (o instanceof Number) {\n+      window = (int) Math.min(Integer.MAX_VALUE, ((Number) o).longValue());\n+\n+      // If the window is negative, consider there is no window.\n+      if (window < 0) {\n+        window = Integer.MAX_VALUE;\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts1 = (GeoTimeSerie) o;\n \n     o = stack.pop();\n-    \n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts2 = (GeoTimeSerie) o;\n \n-    stack.push(compute(gts1,gts2,threshold));\n+    //\n+    // Compute DTW and push it to the stack\n+    //\n+\n+    double d;\n+    try {\n+      d = compute(gts1, gts2, window, threshold, type, distance);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" failed.\", wse);\n+    }\n+\n+    stack.push(d);\n \n     return stack;\n   }\n-  \n+\n   /**\n-   * Compute Dynamic Time Warping on two GTS, aborting if the threshold is exceeded\n-   * \n-   * @param gts1 First GTS\n-   * @param gts2 Second GTS\n-   * @param threshold Threshold used to abort, use 0.0D if you don't want to abort the DTW\n-   * @return The computed DTW distance or -1 if the threshold is exceeded\n-   * \n-   * @throws WarpScriptException If an error occurs\n+   * Compute the DTW pseudo-distance on two GTS.\n+   * @param gts1 One of the two GTSs to compare to the other.\n+   * @param gts2 One of the two GTSs to compare to the other.\n+   * @param window The window defining th maximum index difference when matching the GTSs. Integer.MAX_VALUE for no window constraint.\n+   * @param threshold The maximum value of DTW. If the computed pseudo-distance is over this value, it is aborted and returns -1;\n+   * @param type The characteristic of the GTSs to run the DTW on.\n+   * @param distance The distance to use to compare GTS values.\n+   * @return The pseudo-distance, -1 if the value would be over threshold.\n+   * @throws WarpScriptException in case the DTW cannot be computed given the parameters.\n    */\n-  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, double threshold) throws WarpScriptException {\n-        \n+  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, int window, double threshold, int type, DTWDistance distance) throws WarpScriptException {\n+\n     //\n     // Check that the type of the GTS is numerical\n     //\n-    \n-    if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n-    }\n-    \n-    if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+    if (VALUES == type) {\n+      if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n+\n+      if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n     }\n \n     //\n     // Sort GTS in chronological order\n     //\n-    \n+\n     GTSHelper.sort(gts1);\n     GTSHelper.sort(gts2);\n-    \n+\n     //\n     // Extract values, compute min/max and quantize values (x - max/(max - min))\n     //\n-    \n-    double[] values1 = GTSHelper.getValuesAsDouble(gts1);        \n-    double[] values2 = GTSHelper.getValuesAsDouble(gts2);\n+    double[][] values1;\n+    double[][] values2;\n \n-    if (this.normalize) {\n-      if (this.znormalize) {\n-        //\n-        // Perform Z-Normalization of values1 and values2\n-        //\n-        \n-        double[] musigma = DoubleUtils.musigma(values1, true);\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          values1[i] = (values1[i] - musigma[0]) / musigma[1];\n-        }\n-        \n-        musigma = DoubleUtils.muvar(values2);\n-        for (int i = 0; i < values2.length; i++) {\n-          values2[i] = (values2[i] - musigma[0]) / musigma[1];\n+    if (VALUES == type) {\n+      values1 = new double[][] {GTSHelper.getValuesAsDouble(gts1)};\n+      values2 = new double[][] {GTSHelper.getValuesAsDouble(gts2)};\n+    } else if (LOCATIONS == type) {\n+      long[] locations1 = GTSHelper.getOriginalLocations(gts1);\n+      if (null == locations1) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n+      }\n+\n+      values1 = new double[2][locations1.length];\n+      for (int i = 0; i < locations1.length; i++) {\n+        if (GeoTimeSerie.NO_LOCATION == locations1[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n         }\n-      } else {\n-        double min = Double.POSITIVE_INFINITY;\n-        double max = Double.NEGATIVE_INFINITY;\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          if (values1[i] < min) {\n-            min = values1[i];\n-          }\n-          if (values1[i] > max) {\n-            max = values1[i];\n-          }\n+        double[] latLon = GeoXPLib.fromGeoXPPoint(locations1[i]);\n+        values1[0][i] = latLon[0];\n+        values1[1][i] = latLon[1];\n+      }\n+\n+      long[] locations2 = GTSHelper.getOriginalLocations(gts2);\n+      if (null == locations2) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n+      }\n+\n+      values2 = new double[2][locations2.length];\n+      for (int i = 0; i < locations2.length; i++) {\n+        if (GeoTimeSerie.NO_LOCATION == locations2[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n         }\n-        \n-        if (min == max) {\n-          throw new WarpScriptException(getName() + \" cannot (yet) operate on constant GTS.\");\n+        double[] latLon = GeoXPLib.fromGeoXPPoint(locations2[i]);\n+        values2[0][i] = latLon[0];\n+        values2[1][i] = latLon[1];\n+      }\n+    } else if (ELEVATIONS == type) {\n+      long[] elev1 = GTSHelper.getOriginalElevations(gts1);\n+      if (null == elev1) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have elevations when DTW is applied on them.\");", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0ODIyNg==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502448226", "bodyText": "should make this a constant with an attached comment. Also why 10E-6?", "author": "hbs", "createdAt": "2020-10-09T14:01:18Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -16,186 +16,372 @@\n \n package io.warp10.script.functions;\n \n-import java.math.BigDecimal;\n-\n+import com.geoxp.GeoXPLib;\n import io.warp10.DoubleUtils;\n import io.warp10.continuum.gts.GTSHelper;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.continuum.gts.GeoTimeSerie.TYPE;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.Arrays;\n \n /**\n- * Perform Dynamic Time Warping distance computation\n- * between values of two GTS.\n- * \n+ * Perform Dynamic Time Warping pseudo-distance computation between two GTSs.\n+ * It can be done on values, locations, elevations or timestamps.\n  */\n public class DTW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-  \n+\n+  // Constants to specify on which characteristic of the GTSs we want to do the DTW.\n+  // Define as power of 2 in case we want to combine them.\n+  public static final int TIMESTAMPS = 1;\n+  public static final int LOCATIONS = 2;\n+  public static final int ELEVATIONS = 4;\n+  public static final int VALUES = 8;\n+\n   /**\n    * Should we normalize?\n    */\n   private final boolean normalize;\n-  \n+\n   /**\n    * Should we do Z-Normalization or 0-1 normalization?\n    */\n   private final boolean znormalize;\n-  \n+\n   public DTW(String name, boolean normalize, boolean znormalize) {\n     super(name);\n     this.normalize = normalize;\n     this.znormalize = znormalize;\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object o = stack.pop();\n-    \n+\n+    int type = VALUES;\n+    DTWDistance distance = DTW::manhattan;\n+\n+    // Optional GTS characteristic to apply DTW on.\n+    if (o instanceof String) {\n+      String charac = ((String) o).toLowerCase();\n+      switch (charac) {\n+        case \"values\":\n+          type = VALUES;\n+          break;\n+        case \"locations\":\n+          type = LOCATIONS;\n+          break;\n+        case \"elevations\":\n+          type = ELEVATIONS;\n+          break;\n+        case \"timestamps\":\n+          type = TIMESTAMPS;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the characteristic of the GTS to compute the DTW on to be values, locations, elevations or timestamps.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n+    // Optional distance spec\n+    if (o instanceof String) {\n+      String dist = ((String) o).toLowerCase();\n+\n+      switch (dist) {\n+        case \"manhattan\":\n+          distance = DTW::manhattan;\n+          break;\n+        case \"euclidean\":\n+          distance = DTW::euclidean;\n+          break;\n+        case \"loxodromic\":\n+          distance = DTW::loxodromic;\n+          break;\n+        case \"orthodromic\":\n+          distance = DTW::orthodromic;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the distance to use in the DTW to be manhattan, euclidean, loxodromic or orthodromic.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof Number)) {\n       throw new WarpScriptException(getName() + \" expects a numeric threshold on top of the stack.\");\n     }\n-    \n+\n     double threshold = ((Number) o).doubleValue();\n-    \n+\n+    // If the threshold is not strictly positive, consider there is no threshold.\n+    if (threshold <= 0) {\n+      threshold = Long.MAX_VALUE;\n+    }\n+\n     o = stack.pop();\n-    \n+\n+    // Optional window parameter.\n+    int window = Integer.MAX_VALUE;\n+\n+    if (o instanceof Number) {\n+      window = (int) Math.min(Integer.MAX_VALUE, ((Number) o).longValue());\n+\n+      // If the window is negative, consider there is no window.\n+      if (window < 0) {\n+        window = Integer.MAX_VALUE;\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts1 = (GeoTimeSerie) o;\n \n     o = stack.pop();\n-    \n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts2 = (GeoTimeSerie) o;\n \n-    stack.push(compute(gts1,gts2,threshold));\n+    //\n+    // Compute DTW and push it to the stack\n+    //\n+\n+    double d;\n+    try {\n+      d = compute(gts1, gts2, window, threshold, type, distance);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" failed.\", wse);\n+    }\n+\n+    stack.push(d);\n \n     return stack;\n   }\n-  \n+\n   /**\n-   * Compute Dynamic Time Warping on two GTS, aborting if the threshold is exceeded\n-   * \n-   * @param gts1 First GTS\n-   * @param gts2 Second GTS\n-   * @param threshold Threshold used to abort, use 0.0D if you don't want to abort the DTW\n-   * @return The computed DTW distance or -1 if the threshold is exceeded\n-   * \n-   * @throws WarpScriptException If an error occurs\n+   * Compute the DTW pseudo-distance on two GTS.\n+   * @param gts1 One of the two GTSs to compare to the other.\n+   * @param gts2 One of the two GTSs to compare to the other.\n+   * @param window The window defining th maximum index difference when matching the GTSs. Integer.MAX_VALUE for no window constraint.\n+   * @param threshold The maximum value of DTW. If the computed pseudo-distance is over this value, it is aborted and returns -1;\n+   * @param type The characteristic of the GTSs to run the DTW on.\n+   * @param distance The distance to use to compare GTS values.\n+   * @return The pseudo-distance, -1 if the value would be over threshold.\n+   * @throws WarpScriptException in case the DTW cannot be computed given the parameters.\n    */\n-  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, double threshold) throws WarpScriptException {\n-        \n+  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, int window, double threshold, int type, DTWDistance distance) throws WarpScriptException {\n+\n     //\n     // Check that the type of the GTS is numerical\n     //\n-    \n-    if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n-    }\n-    \n-    if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+    if (VALUES == type) {\n+      if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n+\n+      if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n     }\n \n     //\n     // Sort GTS in chronological order\n     //\n-    \n+\n     GTSHelper.sort(gts1);\n     GTSHelper.sort(gts2);\n-    \n+\n     //\n     // Extract values, compute min/max and quantize values (x - max/(max - min))\n     //\n-    \n-    double[] values1 = GTSHelper.getValuesAsDouble(gts1);        \n-    double[] values2 = GTSHelper.getValuesAsDouble(gts2);\n+    double[][] values1;\n+    double[][] values2;\n \n-    if (this.normalize) {\n-      if (this.znormalize) {\n-        //\n-        // Perform Z-Normalization of values1 and values2\n-        //\n-        \n-        double[] musigma = DoubleUtils.musigma(values1, true);\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          values1[i] = (values1[i] - musigma[0]) / musigma[1];\n-        }\n-        \n-        musigma = DoubleUtils.muvar(values2);\n-        for (int i = 0; i < values2.length; i++) {\n-          values2[i] = (values2[i] - musigma[0]) / musigma[1];\n+    if (VALUES == type) {\n+      values1 = new double[][] {GTSHelper.getValuesAsDouble(gts1)};\n+      values2 = new double[][] {GTSHelper.getValuesAsDouble(gts2)};\n+    } else if (LOCATIONS == type) {\n+      long[] locations1 = GTSHelper.getOriginalLocations(gts1);\n+      if (null == locations1) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n+      }\n+\n+      values1 = new double[2][locations1.length];\n+      for (int i = 0; i < locations1.length; i++) {\n+        if (GeoTimeSerie.NO_LOCATION == locations1[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n         }\n-      } else {\n-        double min = Double.POSITIVE_INFINITY;\n-        double max = Double.NEGATIVE_INFINITY;\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          if (values1[i] < min) {\n-            min = values1[i];\n-          }\n-          if (values1[i] > max) {\n-            max = values1[i];\n-          }\n+        double[] latLon = GeoXPLib.fromGeoXPPoint(locations1[i]);\n+        values1[0][i] = latLon[0];\n+        values1[1][i] = latLon[1];\n+      }\n+\n+      long[] locations2 = GTSHelper.getOriginalLocations(gts2);\n+      if (null == locations2) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n+      }\n+\n+      values2 = new double[2][locations2.length];\n+      for (int i = 0; i < locations2.length; i++) {\n+        if (GeoTimeSerie.NO_LOCATION == locations2[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n         }\n-        \n-        if (min == max) {\n-          throw new WarpScriptException(getName() + \" cannot (yet) operate on constant GTS.\");\n+        double[] latLon = GeoXPLib.fromGeoXPPoint(locations2[i]);\n+        values2[0][i] = latLon[0];\n+        values2[1][i] = latLon[1];\n+      }\n+    } else if (ELEVATIONS == type) {\n+      long[] elev1 = GTSHelper.getOriginalElevations(gts1);\n+      if (null == elev1) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have elevations when DTW is applied on them.\");\n+      }\n+\n+      values1 = new double[1][elev1.length];\n+      for (int i = 0; i < elev1.length; i++) {\n+        if (GeoTimeSerie.NO_ELEVATION == elev1[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have elevations when DTW is applied on them.\");\n         }\n-        \n-        double range = max - min;\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          values1[i] = (values1[i] - min) / range;\n+        values1[0][i] = elev1[i];\n+      }\n+\n+      long[] elev2 = GTSHelper.getOriginalElevations(gts2);\n+      if (null == elev2) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have elevations when DTW is applied on them.\");\n+      }\n+\n+      values2 = new double[1][elev2.length];\n+      for (int i = 0; i < elev1.length; i++) {\n+        if (GeoTimeSerie.NO_ELEVATION == elev2[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have elevations when DTW is applied on them.\");\n         }\n+        values2[0][i] = elev2[i];\n+      }\n+    } else if (TIMESTAMPS == type) {\n+      double[] timestamps1 = Arrays.stream(GTSHelper.getTicks(gts1)).asDoubleStream().toArray();\n+      double[] timestamps2 = Arrays.stream(GTSHelper.getTicks(gts2)).asDoubleStream().toArray();\n+      values1 = new double[][] {timestamps1};\n+      values2 = new double[][] {timestamps2};\n+    } else {\n+      throw new IllegalArgumentException(\"DTW type is unknown: \" + type);\n+    }\n+\n+    if (this.normalize) {\n+      //\n+      // Perform normalization of values1 and values2, on each dimension.\n+      //\n+      for (int dimension = 0; dimension < values1.length; dimension++) {\n \n-        min = Double.POSITIVE_INFINITY;\n-        max = Double.NEGATIVE_INFINITY;\n+        double[] dimVal1 = values1[dimension];\n+        double[] dimVal2 = values2[dimension];\n+        if (this.znormalize) {\n+          double[] musigma = DoubleUtils.musigma(dimVal1, true);\n \n-        for (int i = 0; i < values2.length; i++) {\n-          if (values2[i] < min) {\n-            min = values2[i];\n+          for (int i = 0; i < dimVal1.length; i++) {\n+            dimVal1[i] = (dimVal1[i] - musigma[0]) / musigma[1];\n           }\n-          if (values2[i] > max) {\n-            max = values2[i];\n+\n+          musigma = DoubleUtils.muvar(dimVal2);\n+          for (int i = 0; i < dimVal2.length; i++) {\n+            dimVal2[i] = (dimVal2[i] - musigma[0]) / musigma[1];\n+          }\n+        } else {\n+          double min = Double.POSITIVE_INFINITY;\n+          double max = Double.NEGATIVE_INFINITY;\n+\n+          for (int i = 0; i < dimVal1.length; i++) {\n+            if (dimVal1[i] < min) {\n+              min = dimVal1[i];\n+            }\n+            if (dimVal1[i] > max) {\n+              max = dimVal1[i];\n+            }\n+          }\n+\n+          if (max - min < 0.000001) {", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0ODQ2Mg==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502448462", "bodyText": "ditto", "author": "hbs", "createdAt": "2020-10-09T14:01:33Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -16,186 +16,372 @@\n \n package io.warp10.script.functions;\n \n-import java.math.BigDecimal;\n-\n+import com.geoxp.GeoXPLib;\n import io.warp10.DoubleUtils;\n import io.warp10.continuum.gts.GTSHelper;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.continuum.gts.GeoTimeSerie.TYPE;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.Arrays;\n \n /**\n- * Perform Dynamic Time Warping distance computation\n- * between values of two GTS.\n- * \n+ * Perform Dynamic Time Warping pseudo-distance computation between two GTSs.\n+ * It can be done on values, locations, elevations or timestamps.\n  */\n public class DTW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-  \n+\n+  // Constants to specify on which characteristic of the GTSs we want to do the DTW.\n+  // Define as power of 2 in case we want to combine them.\n+  public static final int TIMESTAMPS = 1;\n+  public static final int LOCATIONS = 2;\n+  public static final int ELEVATIONS = 4;\n+  public static final int VALUES = 8;\n+\n   /**\n    * Should we normalize?\n    */\n   private final boolean normalize;\n-  \n+\n   /**\n    * Should we do Z-Normalization or 0-1 normalization?\n    */\n   private final boolean znormalize;\n-  \n+\n   public DTW(String name, boolean normalize, boolean znormalize) {\n     super(name);\n     this.normalize = normalize;\n     this.znormalize = znormalize;\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object o = stack.pop();\n-    \n+\n+    int type = VALUES;\n+    DTWDistance distance = DTW::manhattan;\n+\n+    // Optional GTS characteristic to apply DTW on.\n+    if (o instanceof String) {\n+      String charac = ((String) o).toLowerCase();\n+      switch (charac) {\n+        case \"values\":\n+          type = VALUES;\n+          break;\n+        case \"locations\":\n+          type = LOCATIONS;\n+          break;\n+        case \"elevations\":\n+          type = ELEVATIONS;\n+          break;\n+        case \"timestamps\":\n+          type = TIMESTAMPS;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the characteristic of the GTS to compute the DTW on to be values, locations, elevations or timestamps.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n+    // Optional distance spec\n+    if (o instanceof String) {\n+      String dist = ((String) o).toLowerCase();\n+\n+      switch (dist) {\n+        case \"manhattan\":\n+          distance = DTW::manhattan;\n+          break;\n+        case \"euclidean\":\n+          distance = DTW::euclidean;\n+          break;\n+        case \"loxodromic\":\n+          distance = DTW::loxodromic;\n+          break;\n+        case \"orthodromic\":\n+          distance = DTW::orthodromic;\n+          break;\n+        default:\n+          throw new WarpScriptException(getName() + \" expects the distance to use in the DTW to be manhattan, euclidean, loxodromic or orthodromic.\");\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof Number)) {\n       throw new WarpScriptException(getName() + \" expects a numeric threshold on top of the stack.\");\n     }\n-    \n+\n     double threshold = ((Number) o).doubleValue();\n-    \n+\n+    // If the threshold is not strictly positive, consider there is no threshold.\n+    if (threshold <= 0) {\n+      threshold = Long.MAX_VALUE;\n+    }\n+\n     o = stack.pop();\n-    \n+\n+    // Optional window parameter.\n+    int window = Integer.MAX_VALUE;\n+\n+    if (o instanceof Number) {\n+      window = (int) Math.min(Integer.MAX_VALUE, ((Number) o).longValue());\n+\n+      // If the window is negative, consider there is no window.\n+      if (window < 0) {\n+        window = Integer.MAX_VALUE;\n+      }\n+\n+      o = stack.pop();\n+    }\n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts1 = (GeoTimeSerie) o;\n \n     o = stack.pop();\n-    \n+\n     if (!(o instanceof GeoTimeSerie)) {\n       throw new WarpScriptException(getName() + \" expects two Geo Time Series below the threshold.\");\n     }\n \n     GeoTimeSerie gts2 = (GeoTimeSerie) o;\n \n-    stack.push(compute(gts1,gts2,threshold));\n+    //\n+    // Compute DTW and push it to the stack\n+    //\n+\n+    double d;\n+    try {\n+      d = compute(gts1, gts2, window, threshold, type, distance);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" failed.\", wse);\n+    }\n+\n+    stack.push(d);\n \n     return stack;\n   }\n-  \n+\n   /**\n-   * Compute Dynamic Time Warping on two GTS, aborting if the threshold is exceeded\n-   * \n-   * @param gts1 First GTS\n-   * @param gts2 Second GTS\n-   * @param threshold Threshold used to abort, use 0.0D if you don't want to abort the DTW\n-   * @return The computed DTW distance or -1 if the threshold is exceeded\n-   * \n-   * @throws WarpScriptException If an error occurs\n+   * Compute the DTW pseudo-distance on two GTS.\n+   * @param gts1 One of the two GTSs to compare to the other.\n+   * @param gts2 One of the two GTSs to compare to the other.\n+   * @param window The window defining th maximum index difference when matching the GTSs. Integer.MAX_VALUE for no window constraint.\n+   * @param threshold The maximum value of DTW. If the computed pseudo-distance is over this value, it is aborted and returns -1;\n+   * @param type The characteristic of the GTSs to run the DTW on.\n+   * @param distance The distance to use to compare GTS values.\n+   * @return The pseudo-distance, -1 if the value would be over threshold.\n+   * @throws WarpScriptException in case the DTW cannot be computed given the parameters.\n    */\n-  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, double threshold) throws WarpScriptException {\n-        \n+  public final double compute(GeoTimeSerie gts1, GeoTimeSerie gts2, int window, double threshold, int type, DTWDistance distance) throws WarpScriptException {\n+\n     //\n     // Check that the type of the GTS is numerical\n     //\n-    \n-    if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n-    }\n-    \n-    if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n-      throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+    if (VALUES == type) {\n+      if (TYPE.LONG != gts1.getType() && TYPE.DOUBLE != gts1.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n+\n+      if (TYPE.LONG != gts2.getType() && TYPE.DOUBLE != gts2.getType()) {\n+        throw new WarpScriptException(getName() + \" can only operate on numerical Geo Time Series.\");\n+      }\n     }\n \n     //\n     // Sort GTS in chronological order\n     //\n-    \n+\n     GTSHelper.sort(gts1);\n     GTSHelper.sort(gts2);\n-    \n+\n     //\n     // Extract values, compute min/max and quantize values (x - max/(max - min))\n     //\n-    \n-    double[] values1 = GTSHelper.getValuesAsDouble(gts1);        \n-    double[] values2 = GTSHelper.getValuesAsDouble(gts2);\n+    double[][] values1;\n+    double[][] values2;\n \n-    if (this.normalize) {\n-      if (this.znormalize) {\n-        //\n-        // Perform Z-Normalization of values1 and values2\n-        //\n-        \n-        double[] musigma = DoubleUtils.musigma(values1, true);\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          values1[i] = (values1[i] - musigma[0]) / musigma[1];\n-        }\n-        \n-        musigma = DoubleUtils.muvar(values2);\n-        for (int i = 0; i < values2.length; i++) {\n-          values2[i] = (values2[i] - musigma[0]) / musigma[1];\n+    if (VALUES == type) {\n+      values1 = new double[][] {GTSHelper.getValuesAsDouble(gts1)};\n+      values2 = new double[][] {GTSHelper.getValuesAsDouble(gts2)};\n+    } else if (LOCATIONS == type) {\n+      long[] locations1 = GTSHelper.getOriginalLocations(gts1);\n+      if (null == locations1) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n+      }\n+\n+      values1 = new double[2][locations1.length];\n+      for (int i = 0; i < locations1.length; i++) {\n+        if (GeoTimeSerie.NO_LOCATION == locations1[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n         }\n-      } else {\n-        double min = Double.POSITIVE_INFINITY;\n-        double max = Double.NEGATIVE_INFINITY;\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          if (values1[i] < min) {\n-            min = values1[i];\n-          }\n-          if (values1[i] > max) {\n-            max = values1[i];\n-          }\n+        double[] latLon = GeoXPLib.fromGeoXPPoint(locations1[i]);\n+        values1[0][i] = latLon[0];\n+        values1[1][i] = latLon[1];\n+      }\n+\n+      long[] locations2 = GTSHelper.getOriginalLocations(gts2);\n+      if (null == locations2) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n+      }\n+\n+      values2 = new double[2][locations2.length];\n+      for (int i = 0; i < locations2.length; i++) {\n+        if (GeoTimeSerie.NO_LOCATION == locations2[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have locations when DTW is applied on them.\");\n         }\n-        \n-        if (min == max) {\n-          throw new WarpScriptException(getName() + \" cannot (yet) operate on constant GTS.\");\n+        double[] latLon = GeoXPLib.fromGeoXPPoint(locations2[i]);\n+        values2[0][i] = latLon[0];\n+        values2[1][i] = latLon[1];\n+      }\n+    } else if (ELEVATIONS == type) {\n+      long[] elev1 = GTSHelper.getOriginalElevations(gts1);\n+      if (null == elev1) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have elevations when DTW is applied on them.\");\n+      }\n+\n+      values1 = new double[1][elev1.length];\n+      for (int i = 0; i < elev1.length; i++) {\n+        if (GeoTimeSerie.NO_ELEVATION == elev1[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have elevations when DTW is applied on them.\");\n         }\n-        \n-        double range = max - min;\n-        \n-        for (int i = 0; i < values1.length; i++) {\n-          values1[i] = (values1[i] - min) / range;\n+        values1[0][i] = elev1[i];\n+      }\n+\n+      long[] elev2 = GTSHelper.getOriginalElevations(gts2);\n+      if (null == elev2) {\n+        throw new WarpScriptException(getName() + \" expects GTSs to have elevations when DTW is applied on them.\");\n+      }\n+\n+      values2 = new double[1][elev2.length];\n+      for (int i = 0; i < elev1.length; i++) {\n+        if (GeoTimeSerie.NO_ELEVATION == elev2[i]) {\n+          throw new WarpScriptException(getName() + \" expects GTSs to have elevations when DTW is applied on them.\");\n         }\n+        values2[0][i] = elev2[i];\n+      }\n+    } else if (TIMESTAMPS == type) {\n+      double[] timestamps1 = Arrays.stream(GTSHelper.getTicks(gts1)).asDoubleStream().toArray();\n+      double[] timestamps2 = Arrays.stream(GTSHelper.getTicks(gts2)).asDoubleStream().toArray();\n+      values1 = new double[][] {timestamps1};\n+      values2 = new double[][] {timestamps2};\n+    } else {\n+      throw new IllegalArgumentException(\"DTW type is unknown: \" + type);\n+    }\n+\n+    if (this.normalize) {\n+      //\n+      // Perform normalization of values1 and values2, on each dimension.\n+      //\n+      for (int dimension = 0; dimension < values1.length; dimension++) {\n \n-        min = Double.POSITIVE_INFINITY;\n-        max = Double.NEGATIVE_INFINITY;\n+        double[] dimVal1 = values1[dimension];\n+        double[] dimVal2 = values2[dimension];\n+        if (this.znormalize) {\n+          double[] musigma = DoubleUtils.musigma(dimVal1, true);\n \n-        for (int i = 0; i < values2.length; i++) {\n-          if (values2[i] < min) {\n-            min = values2[i];\n+          for (int i = 0; i < dimVal1.length; i++) {\n+            dimVal1[i] = (dimVal1[i] - musigma[0]) / musigma[1];\n           }\n-          if (values2[i] > max) {\n-            max = values2[i];\n+\n+          musigma = DoubleUtils.muvar(dimVal2);\n+          for (int i = 0; i < dimVal2.length; i++) {\n+            dimVal2[i] = (dimVal2[i] - musigma[0]) / musigma[1];\n+          }\n+        } else {\n+          double min = Double.POSITIVE_INFINITY;\n+          double max = Double.NEGATIVE_INFINITY;\n+\n+          for (int i = 0; i < dimVal1.length; i++) {\n+            if (dimVal1[i] < min) {\n+              min = dimVal1[i];\n+            }\n+            if (dimVal1[i] > max) {\n+              max = dimVal1[i];\n+            }\n+          }\n+\n+          if (max - min < 0.000001) {\n+            throw new WarpScriptException(getName() + \" cannot normalize a constant GTS.\");\n+          }\n+\n+          double range = max - min;\n+\n+          for (int i = 0; i < dimVal1.length; i++) {\n+            dimVal1[i] = (dimVal1[i] - min) / range;\n+          }\n+\n+          min = Double.POSITIVE_INFINITY;\n+          max = Double.NEGATIVE_INFINITY;\n+\n+          for (int i = 0; i < dimVal2.length; i++) {\n+            if (dimVal2[i] < min) {\n+              min = dimVal2[i];\n+            }\n+            if (dimVal2[i] > max) {\n+              max = dimVal2[i];\n+            }\n+          }\n+\n+          if (max - min < 0.000001) {", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1MDcxOA==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502450718", "bodyText": "if you do not need the actual distance you could remove the call to sqrt, it would not change the result", "author": "hbs", "createdAt": "2020-10-09T14:04:25Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -205,77 +391,159 @@ public double compute(double[] values1, int offset1, int len1, double[] values2,\n       len1 = len2;\n       len2 = tmpint;\n     }\n-    \n+\n     //\n     // Now run DTW.\n-    // We allocate two columns so we can run DTW, only allocating\n+    // We allocate two columns so we can run DTW, only allocating.\n+    // To better visualize the algorithm, and understand the terminology used below, imagine the problem like this,\n+    // values1 and values2 are 1-dimension:\n     //\n-    \n+    //         \\    .\n+    //          |   .\n+    //          \\   .\n+    //           \\  .\n+    // values1    | 9\n+    // (turned    / 7\n+    //   90\u00b0)    |  5 ?\n+    //           |  3 7\n+    //          /   2 4\n+    //              _ / \u00af \\ _           / \u00af \u00af \u00af \u00af \\ _ _ _ _ _\n+    //                        \\ _ _ _ /\n+    //                          values2\n+    //              a b\n+    // When computing \"?\" we will compute the distance between values1[0][2] and values2[0][1] then add it to the lowest\n+    // distance between the left one (5), the bottom one (7) or the bottom-left (3) one. When b is filled, a is of\n+    // no use anymore, so b is stored in a, and a will be used as the new b, discarding its values.\n+    // All the values taken by a and b are called the matching matrix in the following.\n+    //\n+\n     double[] a = new double[len1];\n     double[] b = new double[len1];\n-    \n-    int w = values2.length;\n-    \n+\n+    // Tell if any value in the current column is below the threshold.\n     boolean belowThreshold = false;\n-    \n-    for (int i = 0; i < len2; i++) {\n-      int start = Math.max(0, i - w);\n-      int end = Math.min(len1 - 1, i + w);\n-      \n-      belowThreshold = false;\n-      \n-      for (int j = start; j <= end; j++) {\n-        \n-        //\n-        // Compute distance.\n-        // DTW simply considers the delta in values, not the delta in indices\n-        //\n-        \n-        double d = manhattan ? Math.abs(values1[offset1 + j] - values2[offset2 + i]) : Math.pow(values1[offset1 + j] - values2[offset2 + i], 2.0D);\n-        \n+\n+    // There's no need for the window to be greater than len2-1 and cannot be smaller than len2-len1, else it won't\n+    // be able to match the last point of values1 to the last point of values2.\n+    window = Math.max(Math.min(window, len2 - 1), len2 - len1);\n+\n+    for (int i = offset2; i < len2; i++) {\n+      // i - window cannot overflow but i + window + 1 can.\n+      // Check for an overflow, knowing that i + 1 cannot overflow.\n+      int maxWindow;\n+      try {\n+        maxWindow = Math.addExact(i + 1, window);\n+      } catch (ArithmeticException ae) {\n+        maxWindow = Integer.MAX_VALUE;\n+      }\n+      for (int j = Math.max(offset1, i - window); j < Math.min(len1, maxWindow); j++) {\n+\n         //\n         // Extract surrounding values\n         //\n-        \n-        double left = a[j];\n-        double bottom = j > start ? b[j - 1] : Double.POSITIVE_INFINITY;\n-        double sw = j > start ? a[j - 1] : Double.POSITIVE_INFINITY;\n-        \n-        b[j] = d + Math.min(left, Math.min(bottom, sw));\n-        //System.out.println(i + \" \" + j + \" \" + d + \" \" + left + \" \" + bottom + \" \" + sw + \" >>> \" + b[j]);\n-        \n-        if (!belowThreshold && (0.0D == threshold || b[j] <= threshold)) {\n-          belowThreshold = true;\n+\n+        double bestPreviousTotalDistance;\n+\n+        if (0 == i && 0 == j) {\n+          // At the bottom-left of the matching matrix, so there is not previous distance.\n+          bestPreviousTotalDistance = 0D;\n+        } else {\n+          // If at the first element of values2, the value at the left in not valid because it is outside the matching matrix.\n+          // If at the end of the window, the value at the left in not valid because it was outside the previous window.\n+          double left = (i > 0 && (i + window) != j) ? a[j] : Double.POSITIVE_INFINITY;\n+          // If at the bottom of the matrix, bottom values does not exist.\n+          // If at the start of the window, the value at the bottom in not valid because it was not computed.\n+          double bottom = (j > 0 && (i - window) != j) ? b[j - 1] : Double.POSITIVE_INFINITY;\n+          // If at the bottom of the matrix, bottom-left values does not exist.\n+          double bottomLeft = j > 0 ? a[j - 1] : Double.POSITIVE_INFINITY;\n+\n+          bestPreviousTotalDistance = Math.min(left, Math.min(bottom, bottomLeft));\n+        }\n+\n+        // Avoid computing the distance if the best total previous distance is already over the threshold.\n+        if (threshold >= bestPreviousTotalDistance) {\n+          //\n+          // Compute distance.\n+          // DTW simply considers the delta in values, not the delta in indices\n+          //\n+\n+          double d = distance.measure(values1, j, values2, i);\n+\n+          b[j] = d + bestPreviousTotalDistance;\n+\n+          if (!belowThreshold && b[j] <= threshold) {\n+            belowThreshold = true;\n+          }\n+        } else {\n+          b[j] = Double.POSITIVE_INFINITY;\n         }\n       }\n-      \n+\n       // Exit if no value is below threshold\n       if (!belowThreshold) {\n-        break;\n+        return -1.0D;\n       }\n-      \n+\n       // Shift b into a\n       double[] tmp = a;\n-      a = b;           \n+      a = b;\n       b = tmp;\n     }\n-    \n-    if (!belowThreshold) {\n-      return -1.0D;\n+\n+    // Result is the top right value of the match matrix.\n+    // It may be over the threshold if a[k] <= threshold for some k<(len1-1);\n+    if (a[len1 - 1] <= threshold) {\n+      return a[len1 - 1];\n+    } else {\n+      return -1;\n+    }\n+  }\n+\n+  // Functional interface defining a distance function used by DTW.\n+  @FunctionalInterface\n+  public interface DTWDistance {\n+    double measure(double[][] values1, int index1, double[][] values2, int index2) throws WarpScriptException;\n+  }\n+\n+  public static double manhattan(double[][] values1, int index1, double[][] values2, int index2) throws WarpScriptException {\n+    double d = 0D;\n+    for (int dimension = 0; dimension < values1.length; dimension++) {\n+      d += Math.abs(values1[dimension][index1] - values2[dimension][index2]);\n     }\n-    \n-    double dtwDist = Double.POSITIVE_INFINITY;\n-    \n-    for (int i = 0; i < a.length; i++) {\n-      if (a[i] < dtwDist) {\n-        dtwDist = a[i];\n-      }\n+    return d;\n+  }\n+\n+  public static double euclidean(double[][] values1, int index1, double[][] values2, int index2) throws WarpScriptException {\n+    double d = 0D;\n+    for (int dimension = 0; dimension < values1.length; dimension++) {\n+      d += Math.pow(values1[dimension][index1] - values2[dimension][index2], 2.0D);\n     }\n-    \n-    if (!manhattan) {\n-      dtwDist = Math.sqrt(dtwDist);\n+    return Math.sqrt(d);", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3MDgxOA==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r503270818", "bodyText": "This affects how the threshold works and the final result, so it's better to keep the sqrt.\nI'll add euclideansq as a new distance to speed up computation while making sure the user knows the value is squared.", "author": "ftence", "createdAt": "2020-10-12T12:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1MDcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1MjY3MA==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502452670", "bodyText": "You should re-implement the distance computation directly on lat/lon instead of converting to HHCode then letting loxodromicDistance split the HHCode. Same goes for the orthodromic distance below.", "author": "hbs", "createdAt": "2020-10-09T14:07:14Z", "path": "warp10/src/main/java/io/warp10/script/functions/DTW.java", "diffHunk": "@@ -205,77 +391,159 @@ public double compute(double[] values1, int offset1, int len1, double[] values2,\n       len1 = len2;\n       len2 = tmpint;\n     }\n-    \n+\n     //\n     // Now run DTW.\n-    // We allocate two columns so we can run DTW, only allocating\n+    // We allocate two columns so we can run DTW, only allocating.\n+    // To better visualize the algorithm, and understand the terminology used below, imagine the problem like this,\n+    // values1 and values2 are 1-dimension:\n     //\n-    \n+    //         \\    .\n+    //          |   .\n+    //          \\   .\n+    //           \\  .\n+    // values1    | 9\n+    // (turned    / 7\n+    //   90\u00b0)    |  5 ?\n+    //           |  3 7\n+    //          /   2 4\n+    //              _ / \u00af \\ _           / \u00af \u00af \u00af \u00af \\ _ _ _ _ _\n+    //                        \\ _ _ _ /\n+    //                          values2\n+    //              a b\n+    // When computing \"?\" we will compute the distance between values1[0][2] and values2[0][1] then add it to the lowest\n+    // distance between the left one (5), the bottom one (7) or the bottom-left (3) one. When b is filled, a is of\n+    // no use anymore, so b is stored in a, and a will be used as the new b, discarding its values.\n+    // All the values taken by a and b are called the matching matrix in the following.\n+    //\n+\n     double[] a = new double[len1];\n     double[] b = new double[len1];\n-    \n-    int w = values2.length;\n-    \n+\n+    // Tell if any value in the current column is below the threshold.\n     boolean belowThreshold = false;\n-    \n-    for (int i = 0; i < len2; i++) {\n-      int start = Math.max(0, i - w);\n-      int end = Math.min(len1 - 1, i + w);\n-      \n-      belowThreshold = false;\n-      \n-      for (int j = start; j <= end; j++) {\n-        \n-        //\n-        // Compute distance.\n-        // DTW simply considers the delta in values, not the delta in indices\n-        //\n-        \n-        double d = manhattan ? Math.abs(values1[offset1 + j] - values2[offset2 + i]) : Math.pow(values1[offset1 + j] - values2[offset2 + i], 2.0D);\n-        \n+\n+    // There's no need for the window to be greater than len2-1 and cannot be smaller than len2-len1, else it won't\n+    // be able to match the last point of values1 to the last point of values2.\n+    window = Math.max(Math.min(window, len2 - 1), len2 - len1);\n+\n+    for (int i = offset2; i < len2; i++) {\n+      // i - window cannot overflow but i + window + 1 can.\n+      // Check for an overflow, knowing that i + 1 cannot overflow.\n+      int maxWindow;\n+      try {\n+        maxWindow = Math.addExact(i + 1, window);\n+      } catch (ArithmeticException ae) {\n+        maxWindow = Integer.MAX_VALUE;\n+      }\n+      for (int j = Math.max(offset1, i - window); j < Math.min(len1, maxWindow); j++) {\n+\n         //\n         // Extract surrounding values\n         //\n-        \n-        double left = a[j];\n-        double bottom = j > start ? b[j - 1] : Double.POSITIVE_INFINITY;\n-        double sw = j > start ? a[j - 1] : Double.POSITIVE_INFINITY;\n-        \n-        b[j] = d + Math.min(left, Math.min(bottom, sw));\n-        //System.out.println(i + \" \" + j + \" \" + d + \" \" + left + \" \" + bottom + \" \" + sw + \" >>> \" + b[j]);\n-        \n-        if (!belowThreshold && (0.0D == threshold || b[j] <= threshold)) {\n-          belowThreshold = true;\n+\n+        double bestPreviousTotalDistance;\n+\n+        if (0 == i && 0 == j) {\n+          // At the bottom-left of the matching matrix, so there is not previous distance.\n+          bestPreviousTotalDistance = 0D;\n+        } else {\n+          // If at the first element of values2, the value at the left in not valid because it is outside the matching matrix.\n+          // If at the end of the window, the value at the left in not valid because it was outside the previous window.\n+          double left = (i > 0 && (i + window) != j) ? a[j] : Double.POSITIVE_INFINITY;\n+          // If at the bottom of the matrix, bottom values does not exist.\n+          // If at the start of the window, the value at the bottom in not valid because it was not computed.\n+          double bottom = (j > 0 && (i - window) != j) ? b[j - 1] : Double.POSITIVE_INFINITY;\n+          // If at the bottom of the matrix, bottom-left values does not exist.\n+          double bottomLeft = j > 0 ? a[j - 1] : Double.POSITIVE_INFINITY;\n+\n+          bestPreviousTotalDistance = Math.min(left, Math.min(bottom, bottomLeft));\n+        }\n+\n+        // Avoid computing the distance if the best total previous distance is already over the threshold.\n+        if (threshold >= bestPreviousTotalDistance) {\n+          //\n+          // Compute distance.\n+          // DTW simply considers the delta in values, not the delta in indices\n+          //\n+\n+          double d = distance.measure(values1, j, values2, i);\n+\n+          b[j] = d + bestPreviousTotalDistance;\n+\n+          if (!belowThreshold && b[j] <= threshold) {\n+            belowThreshold = true;\n+          }\n+        } else {\n+          b[j] = Double.POSITIVE_INFINITY;\n         }\n       }\n-      \n+\n       // Exit if no value is below threshold\n       if (!belowThreshold) {\n-        break;\n+        return -1.0D;\n       }\n-      \n+\n       // Shift b into a\n       double[] tmp = a;\n-      a = b;           \n+      a = b;\n       b = tmp;\n     }\n-    \n-    if (!belowThreshold) {\n-      return -1.0D;\n+\n+    // Result is the top right value of the match matrix.\n+    // It may be over the threshold if a[k] <= threshold for some k<(len1-1);\n+    if (a[len1 - 1] <= threshold) {\n+      return a[len1 - 1];\n+    } else {\n+      return -1;\n+    }\n+  }\n+\n+  // Functional interface defining a distance function used by DTW.\n+  @FunctionalInterface\n+  public interface DTWDistance {\n+    double measure(double[][] values1, int index1, double[][] values2, int index2) throws WarpScriptException;\n+  }\n+\n+  public static double manhattan(double[][] values1, int index1, double[][] values2, int index2) throws WarpScriptException {\n+    double d = 0D;\n+    for (int dimension = 0; dimension < values1.length; dimension++) {\n+      d += Math.abs(values1[dimension][index1] - values2[dimension][index2]);\n     }\n-    \n-    double dtwDist = Double.POSITIVE_INFINITY;\n-    \n-    for (int i = 0; i < a.length; i++) {\n-      if (a[i] < dtwDist) {\n-        dtwDist = a[i];\n-      }\n+    return d;\n+  }\n+\n+  public static double euclidean(double[][] values1, int index1, double[][] values2, int index2) throws WarpScriptException {\n+    double d = 0D;\n+    for (int dimension = 0; dimension < values1.length; dimension++) {\n+      d += Math.pow(values1[dimension][index1] - values2[dimension][index2], 2.0D);\n     }\n-    \n-    if (!manhattan) {\n-      dtwDist = Math.sqrt(dtwDist);\n+    return Math.sqrt(d);\n+  }\n+\n+  public static double loxodromic(double[][] values1, int index1, double[][] values2, int index2) throws WarpScriptException {\n+    if (2 != values1.length) {\n+      throw new WarpScriptException(\"Loxodromic distance must be given two dimensions: lat, lon.\");\n+    }\n+\n+    double lat1 = values1[0][index1];\n+    double lat2 = values2[0][index2];\n+    double lon1 = values1[1][index1];\n+    double lon2 = values2[1][index2];\n+\n+    return GeoXPLib.loxodromicDistance(GeoXPLib.toGeoXPPoint(lat1, lon1), GeoXPLib.toGeoXPPoint(lat2, lon2));", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1Mjg1OA==", "url": "https://github.com/senx/warp10-platform/pull/858#discussion_r502452858", "bodyText": "Should check that it is a LONG rather than a number", "author": "hbs", "createdAt": "2020-10-09T14:07:33Z", "path": "warp10/src/main/java/io/warp10/script/functions/OPTDTW.java", "diffHunk": "@@ -53,6 +51,20 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     int count = ((Number) o).intValue();\n     \n     o = stack.pop();\n+\n+    // Optional window parameter.\n+    int window = Integer.MAX_VALUE;\n+\n+    if (o instanceof Number) {", "originalCommit": "ed75f1cb62972b71c75fdba4ab74f7f884ac1709", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9324e6e629e679fac445addb0da8063dcae134a6", "url": "https://github.com/senx/warp10-platform/commit/9324e6e629e679fac445addb0da8063dcae134a6", "message": "Address PR comments", "committedDate": "2020-10-12T13:50:15Z", "type": "commit"}]}