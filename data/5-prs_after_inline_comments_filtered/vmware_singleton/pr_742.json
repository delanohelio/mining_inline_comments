{"pr_number": 742, "pr_title": "add L2 cache expire logic", "pr_createdAt": "2020-08-26T03:15:55Z", "pr_url": "https://github.com/vmware/singleton/pull/742", "timeline": [{"oid": "4edbc4ebde1715cad60dc217259b547391f15a81", "url": "https://github.com/vmware/singleton/commit/4edbc4ebde1715cad60dc217259b547391f15a81", "message": "add L2 cache expire logic", "committedDate": "2020-08-26T03:12:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMzMxNg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477013316", "bodyText": "Add synchronized keyword to this method, otherwise there will be a bug calculating expiration.", "author": "Xiaochao8", "createdAt": "2020-08-26T03:36:48Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n+\tpublic synchronized String getEtag() {\n+\t\treturn etag;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tpublic synchronized void setEtag(String etag) {\n+\t\tthis.etag = etag;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic synchronized long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tpublic synchronized void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n+\t}\n+\n+\tpublic synchronized Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n+\t}\n+\n+\tpublic synchronized void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n+\t}\n+\n+\tpublic boolean isExpired() {", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzMDg3Nw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481430877", "bodyText": "Do not add synchronized to this method. It will affect performance as many threads checking for expiration would have to do it one at a time.\nInstead, set all the factors that go together (etag, timestamp and maxAgeMillis, and cachedData) in only one synchronized setter method. Remove the individual setters from here. This is to prevent mismatched etag, timestamp and maxAgeMillis due to lack of thread safety.\nSince you created LocaleCacheItem and PatternCacheItem separately, then you should put the said setter method in those 2 classes.\nAdded note: I think we should remove synchronized from MessgaeCacheItem.isExpired as well.", "author": "jessiejuachon", "createdAt": "2020-09-01T21:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMzMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2OTczOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r491769738", "bodyText": "fix as Jessiely's suggestion.", "author": "huihuiw01", "createdAt": "2020-09-21T02:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMzMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDQyOQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477020429", "bodyText": "It seems responseTimeStamp won't be null in any case.", "author": "Xiaochao8", "createdAt": "2020-08-26T04:04:34Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n+\tpublic synchronized String getEtag() {\n+\t\treturn etag;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tpublic synchronized void setEtag(String etag) {\n+\t\tthis.etag = etag;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic synchronized long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tpublic synchronized void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n+\t}\n+\n+\tpublic synchronized Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n+\t}\n+\n+\tpublic synchronized void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n+\t}\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong responseTimeStamp = this.getTimestamp();\n+\t\tif (responseTimeStamp == null) {", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MTMzMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481441330", "bodyText": "I agree with Xiaochao. Default value of long timestamp is 0, so if timestamp is not set, it effectively renders the cache item as expired.\nYou do not need to convert to Long responseTimestamp. You can remove lines 53-56.\nI think we should do the same for MessageCacheItem.isExpired.", "author": "jessiejuachon", "createdAt": "2020-09-01T21:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDY4MA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477020680", "bodyText": "Why use two types of long?", "author": "Xiaochao8", "createdAt": "2020-08-26T04:05:22Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzNjA2NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481436064", "bodyText": "maxAgeMillis must be null if the VIP server does not send cache-control max-age. That is why this is a Long type, same as in MessageCacheItem.", "author": "jessiejuachon", "createdAt": "2020-09-01T21:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDc3MA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477020770", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\treturn System.currentTimeMillis() - responseTimeStamp > maxAgeMillis;\n          \n          \n            \n            \t\treturn System.currentTimeMillis() - responseTimeStamp >= maxAgeMillis;", "author": "Xiaochao8", "createdAt": "2020-08-26T04:05:46Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n+\tpublic synchronized String getEtag() {\n+\t\treturn etag;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tpublic synchronized void setEtag(String etag) {\n+\t\tthis.etag = etag;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic synchronized long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tpublic synchronized void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n+\t}\n+\n+\tpublic synchronized Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n+\t}\n+\n+\tpublic synchronized void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n+\t}\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong responseTimeStamp = this.getTimestamp();\n+\t\tif (responseTimeStamp == null) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tLong maxAgeResponse = this.getMaxAgeMillis();\n+\t\tif (maxAgeResponse != null) {\n+\t\t\tmaxAgeMillis = maxAgeResponse;\n+\t\t}\n+\n+\t\treturn System.currentTimeMillis() - responseTimeStamp > maxAgeMillis;", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MzI2MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481443261", "bodyText": "I agree, it should be >=. The prefix \"max\" in maxAgeMillis means that the value is the maximum acceptable age. This means = should return true.\nWe should do this for MessageCacheItem.isExpired too.", "author": "jessiejuachon", "createdAt": "2020-09-01T21:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyNTEzMQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477025131", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n          \n          \n            \n            \t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));", "author": "Xiaochao8", "createdAt": "2020-08-26T04:22:42Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477032085", "bodyText": "This will never expire because it's from local.", "author": "Xiaochao8", "createdAt": "2020-08-26T04:49:55Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1NzkyNw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485057927", "bodyText": "Local should expire also to give a chance to try to fetch from service once it expires.", "author": "jessiejuachon", "createdAt": "2020-09-08T16:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEwNDE2Nw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494104167", "bodyText": "I don't agree, it redundant and unnecessary because local bundles aren't allow change. Here has nothing with service.", "author": "Xiaochao8", "createdAt": "2020-09-24T07:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMTE5MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494631191", "bodyText": "After reviewing again, will the information in cache ever be updated either from service or from local?\n\nIt looks like formattingCacehService.addLanguageNames is only used for local data. If this is the case, then the cached data will never be refreshed from service.\nThe local data in jar is included at compile time. This means that there will never be any updated jar file unless application is restarted correct?\n\nIf the above 2 points are true, then we do not need an expire logic here...no need to check isExpired,  and no need for populateLanguagesCache, correct?\nDo we actually need to put this data in cache at all? I know that the content is a map of language tags and display names that is specific to a requested display language. The data is used for LocaleService.getSupportedDisplayNamesByLocale, which is already caching the supported languages and names per requested display language. I think the caching in  LocaleService.getSupportedDisplayNamesByLocale is enough so that no call to LocalLocaleOpt.getLanguagesNamesFromCLDR will be called for the same display language more than once. Hence, no need for caching in LocalLocaleOpt.\nAs a result, you may remove associated code:\n\nFormattingCacheItem.addLanguagesNames\nFormattingCacheItem.getLanguagesNames\nFormattingCacheItem.getLanguagesNamesCacheKey\nConstantsKeys.LANGUAGES_PREFIX", "author": "jessiejuachon", "createdAt": "2020-09-24T21:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTIwODA1Mg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r505208052", "bodyText": "@jessiejuachon Your above 2 points are correct.\nIn online mode, when fetching supported languages from data source, I needn't do anything except sending request to '/i18n/api/v2/locale/supportedLanguageList' API in Singleton service to get the result, since all the logic is handled by Singleton service;\nbut in offline mode, I need implement the logic as the same as Singleton service.\nFirstly need get the supported languageTags;\nSecondly get the languages' name of the requested locale;\nThen get the supported languageTags' name.\nSince Singleton service use the same pattern jar with Java client, and it caches the languages' names, so I cache the languages' names in client, too.\nThough the code is there, it may not be executed. Because in online&mix mode, supported languages are get from Singleton service; in offline mode, the result of condition 'languagesNames.isExpired()' is false.\nThis is left just for future extension when local bundle can be updated at runtime.", "author": "huihuiw01", "createdAt": "2020-10-15T06:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyODY0MA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506728640", "bodyText": "First, local bundle will never be updated at runtime. The reason is this is against product integrity. Any updates to local bundles must be done using an official product upgrade/patch/hotfix.\nSecond, the implementation that you copied from Singleton service (caching the language names) is not optimal. You do not need to copy it. We have to remove it from here, especially because adding the languages' names to the cache is going to unnecessarily add to the memory footprint of the client application, not just in Singleton service. Removing the caching logic for language names entirely will avoid this problem. We should eventually remove this same non-optimal behavior from the Singleton service too.\nMoreover, you are incorrect when you say that the code will not be used. The expire logic in formatCacheItem.isExpired will always be applied in mixed mode, and so the formatCacheItem in cache will expire even if it previously came from the offline jar. Anyway, this is not the primary concern, but removing the caching logic for language names entirely will avoid this problem.\nHence, please remove:\n\nFormattingCacheItem.addLanguagesNames\nFormattingCacheItem.getLanguagesNames\nFormattingCacheItem.getLanguagesNamesCacheKey\nConstantsKeys.LANGUAGES_PREFIX\nOther related code", "author": "jessiejuachon", "createdAt": "2020-10-16T21:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjkyNw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477032927", "bodyText": "Set time stamp in service because it's common in different origins.", "author": "Xiaochao8", "createdAt": "2020-08-26T04:52:59Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tif (!languagesNames.getCachedData().isEmpty()) {\n \t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n \t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n \t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn null;\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tcacheItem.addCachedData((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES));\n+\t\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg3ODg1NQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r491878855", "bodyText": "To avoid mismatched etag, timestamp and maxAgeMillis due to thread unsafety, have to set all the factors that go together (etag, timestamp and maxAgeMillis, and cachedData) in one synchronized setter method.\nSo can't move set timestamp to service layer.", "author": "huihuiw01", "createdAt": "2020-09-21T08:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMzEwMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477033100", "bodyText": "same as above.", "author": "Xiaochao8", "createdAt": "2020-08-26T04:53:43Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tif (!languagesNames.getCachedData().isEmpty()) {\n \t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n \t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n \t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn null;\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tcacheItem.addCachedData((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES));\n+\t\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-        return null;\n \t}\n \n-\tpublic JSONObject getRegions(String locale) {\n+\tpublic void getRegions(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> regionsData = (Map<String, Object>) new JSONParser().parse(regionsJsonStr);\n+\t\t\tif (regionsData != null) {\n+\t\t\t\tcacheItem.addCachedData((Map<String, String>) regionsData.get(PatternKeys.TERRITORIES));\n+\t\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg3OTIzNQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r491879235", "bodyText": "To avoid mismatched etag, timestamp and maxAgeMillis due to thread unsafety, have to set all the factors that go together (etag, timestamp and maxAgeMillis, and cachedData) in one synchronized setter method.\nSo can't move set timestamp to service layer.", "author": "huihuiw01", "createdAt": "2020-09-21T08:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMzEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMzI2NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477033264", "bodyText": "I think this is unnecessary because this is in locale bundle.", "author": "Xiaochao8", "createdAt": "2020-08-26T04:54:24Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tif (!languagesNames.getCachedData().isEmpty()) {\n \t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n \t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n \t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn null;\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tcacheItem.addCachedData((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES));\n+\t\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-        return null;\n \t}\n \n-\tpublic JSONObject getRegions(String locale) {\n+\tpublic void getRegions(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> regionsData = (Map<String, Object>) new JSONParser().parse(regionsJsonStr);\n+\t\t\tif (regionsData != null) {\n+\t\t\t\tcacheItem.addCachedData((Map<String, String>) regionsData.get(PatternKeys.TERRITORIES));\n+\t\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-\t\treturn null;\n+\t}\n+\n+\tprivate void populateLanguagesCache(String locale, LocaleCacheItem cacheItem) {\n+\t\tCallable<LocaleCacheItem> callable = () -> {\n+\t\t\ttry {\n+\n+\t\t\t\t// Pass cacheItem to getMessages so that:\n+\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t// \t with new properties from the next HTTP response.\n+\t\t\t\tgetLanguagesNamesFromBundle(locale, cacheItem);\n+\t\t\t\treturn cacheItem;\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t// To make sure that the thread will close\n+\t\t\t\t// even when an exception is thrown\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t};\n+\t\tFutureTask<LocaleCacheItem> task = new FutureTask<LocaleCacheItem>(callable);\n+\t\tThread thread = new Thread(task);\n+\t\tthread.start();\n \t}", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQyNDM5OA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495424398", "bodyText": "Locale disk access can be slow too, but I agree that this is unnecessary. Please see my explanation in getLanguagesNamesFromCLDR", "author": "jessiejuachon", "createdAt": "2020-09-26T06:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMzI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0OTMxMQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477049311", "bodyText": "Should judge regionMap is null?", "author": "Xiaochao8", "createdAt": "2020-08-26T05:50:32Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +27,49 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            List<Map<String, Object>> dataNode = (List<Map<String, Object>>) getDataFromResponse(\n+                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                ConstantsKeys.GET, null, cacheItem);\n+            if (dataNode != null && !dataNode.isEmpty()) {\n+                Map<String, Object> regionMap = dataNode.get(0);\n+                Map<String, String> territories = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1MzU4Mw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477053583", "bodyText": "The code is full of this kind of logic, could you think merging them?", "author": "Xiaochao8", "createdAt": "2020-08-26T06:03:11Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;", "originalCommit": "4edbc4ebde1715cad60dc217259b547391f15a81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "url": "https://github.com/vmware/singleton/commit/a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "message": "fix CI reporting issue: update copyright year for new added files according to new CI checking rule", "committedDate": "2020-08-27T14:03:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA2OTgwOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481069808", "bodyText": "This is unnecessary because it has been save to cache at line 74.", "author": "Xiaochao8", "createdAt": "2020-09-01T11:32:48Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0MjgwNQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485042805", "bodyText": "@Xiaochao8 , in line 74, the fallback locale's cache item was mapped to the fallback locale itself. In here, she is mapping the same fallback locale's cacheItem to the requested locale.", "author": "jessiejuachon", "createdAt": "2020-09-08T16:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA2OTgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTExMTMxNA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481111314", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t        \t\tif (respBody!=null && getResponseCode(respBody) == 200){\n          \n          \n            \n            \t        \t\tif (respBody!=null && (getResponseCode(respBody) >= 200 && getResponseCode(respBody) < 300 || getResponseCode(respBody) >= 600 && getResponseCode(respBody) < 700) ){", "author": "Xiaochao8", "createdAt": "2020-09-01T12:48:36Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{\n+    private final Logger      logger = LoggerFactory.getLogger(L2RemoteBaseOpt.class.getName());\n+\n+\n+    public L2RemoteBaseOpt() {\n+\n+    }\n+\n+    public Object getDataFromResponse(String url, String method, Object requestData, FormatCacheItem cacheItem) {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        if (cacheItem.getEtag() != null)\n+        \theaders.put(URLUtils.IF_NONE_MATCH_HEADER, cacheItem.getEtag());\n+        \n+        Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n+        \t\t.request(url, method, requestData, headers);\n+        \n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+        \n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) || \n+        \t\tresponseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+        \t\n+        \tif (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+\t        \tcacheItem.setTimestamp((long) response.get(URLUtils.RESPONSE_TIMESTAMP) );\n+        \tif (response.get(URLUtils.HEADERS) != null)\n+\t        \tcacheItem.setEtag(URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS)));\n+\t        if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+\t        \tcacheItem.setMaxAgeMillis((Long) response.get(URLUtils.MAX_AGE_MILLIS));\n+\t\t\t      \n+\t        if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+\t\t\t\ttry {\n+\t\t\t\t\tString responseStr = (String) response.get(URLUtils.BODY);\n+\t\t\t\t\tif (null == responseStr || responseStr.equals(\"\"))\n+\t\t\t\t\t\treturn null;\n+\t\t        \tJSONObject respBody = (JSONObject) JSONValue.parse(responseStr);\n+\t        \t\tif (respBody!=null && getResponseCode(respBody) == 200){", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg4NzI4NQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r491887285", "bodyText": "What do below business codes you suggested mean?\n\n200 <= code < 300\n600<= code < 700", "author": "huihuiw01", "createdAt": "2020-09-21T08:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTExMTMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1Mjc0NQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481452745", "bodyText": "As I said in my comment in FormaCacheItem, you should not set the cachedData separately from the other properties (etag, timestamp and maxAgeMillis). Create a setter method here that will update all 4 of them together as a set.", "author": "jessiejuachon", "createdAt": "2020-09-01T21:52:06Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/LocaleCacheItem.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class LocaleCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    public LocaleCacheItem() {\n+\n+    }\n+\n+    public LocaleCacheItem (Map<String, String> dataMap) {\n+        super();\n+        this.addCachedData(dataMap);\n+    }\n+\n+    public final Map<String, String> cachedData = new HashMap<String, String>();\n+\n+    public void addCachedData(Map<String, String> cachedData) {\n+        if (cachedData != null)\n+            this.cachedData.putAll(cachedData);\n+    }", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1MjgzMg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481452832", "bodyText": "As I said in my comment in FormaCacheItem, you should not set the cachedData separately from the other properties (etag, timestamp and maxAgeMillis). Create a setter method here that will update all 4 of them together as a set.", "author": "jessiejuachon", "createdAt": "2020-09-01T21:52:23Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/PatternCacheItem.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class PatternCacheItem extends FormatCacheItem implements CacheItem {\n+\tpublic PatternCacheItem() {\n+\n+\t}\n+\n+\tpublic PatternCacheItem(Map<String, Object> dataMap) {\n+\t\tsuper();\n+\t\tthis.addCachedData(dataMap);\n+\t}\n+\t\n+\tpublic final Map<String, Object> cachedData = new HashMap<String, Object>();\n+\t\n+\tpublic void addCachedData(Map<String, Object> cachedData) {\n+\t\tif (cachedData != null)\n+\t\t\tthis.cachedData.putAll(cachedData);\n+\t}", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1NjAzMg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481456032", "bodyText": "Add isExpired in CacheItem interface", "author": "jessiejuachon", "createdAt": "2020-09-01T21:59:58Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MDc5Mg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481460792", "bodyText": "I think I accidentally deleted Xiaochao's comment to reuse L3 method here. This is my reply: I think it is better to separate because the 2 different VIP service URLs (L2 and L3) may have different response bodies and/or codes in the future, which we may also have to handle differently here.", "author": "jessiejuachon", "createdAt": "2020-09-01T22:11:44Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{\n+    private final Logger      logger = LoggerFactory.getLogger(L2RemoteBaseOpt.class.getName());\n+\n+\n+    public L2RemoteBaseOpt() {\n+\n+    }\n+\n+    public Object getDataFromResponse(String url, String method, Object requestData, FormatCacheItem cacheItem) {", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNzUwNg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481507506", "bodyText": "I want to remove the word \"base/d\" from the name of Opt classes because it does not help describe, so here is my suggestion:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class L2RemoteBaseOpt extends BaseOpt{\n          \n          \n            \n            public class RemoteL2Opt extends BaseOpt {", "author": "jessiejuachon", "createdAt": "2020-09-02T00:38:28Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxNTk0Mw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494015943", "bodyText": "Since it extends BaseOpt, so I want to keep Base which means it can be extended by sub-classes.\nSo change the class name to 'RemoteL2BaseOpt'", "author": "huihuiw01", "createdAt": "2020-09-24T03:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNzUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNTU3NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481515574", "bodyText": "Set timestamp, maxAgeMillis, etag and cachedData using 1 single synchronized setter for thread-safety. Please see my comment in FormatCacheItem. See recent changes in ComponentBasedOpt.getComponentMessages for reference.", "author": "jessiejuachon", "createdAt": "2020-09-02T00:55:33Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{\n+    private final Logger      logger = LoggerFactory.getLogger(L2RemoteBaseOpt.class.getName());\n+\n+\n+    public L2RemoteBaseOpt() {\n+\n+    }\n+\n+    public Object getDataFromResponse(String url, String method, Object requestData, FormatCacheItem cacheItem) {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        if (cacheItem.getEtag() != null)\n+        \theaders.put(URLUtils.IF_NONE_MATCH_HEADER, cacheItem.getEtag());\n+        \n+        Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n+        \t\t.request(url, method, requestData, headers);\n+        \n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+        \n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) || \n+        \t\tresponseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+        \t\n+        \tif (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+\t        \tcacheItem.setTimestamp((long) response.get(URLUtils.RESPONSE_TIMESTAMP) );\n+        \tif (response.get(URLUtils.HEADERS) != null)\n+\t        \tcacheItem.setEtag(URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS)));\n+\t        if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+\t        \tcacheItem.setMaxAgeMillis((Long) response.get(URLUtils.MAX_AGE_MILLIS));\n+\t\t\t      \n+\t        if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+\t\t\t\ttry {\n+\t\t\t\t\tString responseStr = (String) response.get(URLUtils.BODY);\n+\t\t\t\t\tif (null == responseStr || responseStr.equals(\"\"))\n+\t\t\t\t\t\treturn null;\n+\t\t        \tJSONObject respBody = (JSONObject) JSONValue.parse(responseStr);\n+\t        \t\tif (respBody!=null && getResponseCode(respBody) == 200){\n+\t\t\t\t        return respBody.get(ConstantsKeys.DATA);\n+        \t\t\t}\n+\t        \t} catch (Exception e) {\n+\t        \t\tlogger.error(\"Failed to get L2 data from remote!\");\n+\t        \t}\n+\t        }", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNjgyNw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481516827", "bodyText": "This logic applies to L3. Does the VIP service also return either 200 or 304 successful response for all L2 service urls?", "author": "jessiejuachon", "createdAt": "2020-09-02T00:57:03Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{\n+    private final Logger      logger = LoggerFactory.getLogger(L2RemoteBaseOpt.class.getName());\n+\n+\n+    public L2RemoteBaseOpt() {\n+\n+    }\n+\n+    public Object getDataFromResponse(String url, String method, Object requestData, FormatCacheItem cacheItem) {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        if (cacheItem.getEtag() != null)\n+        \theaders.put(URLUtils.IF_NONE_MATCH_HEADER, cacheItem.getEtag());\n+        \n+        Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n+        \t\t.request(url, method, requestData, headers);\n+        \n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+        \n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) || \n+        \t\tresponseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyMTQyMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493721420", "bodyText": "Confirmed with backend team members, the eTag in Singleton Service was added by you, so could you confirm if the eTag applied to L2 API?", "author": "huihuiw01", "createdAt": "2020-09-23T16:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNjgyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1ODI2OA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494058268", "bodyText": "etag should be available for all get methods.", "author": "Xiaochao8", "createdAt": "2020-09-24T06:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNjgyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQzODc3NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494438774", "bodyText": "Yes, all GET.", "author": "jessiejuachon", "createdAt": "2020-09-24T16:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNjgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNzUzMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481517530", "bodyText": "This logic applies to L3. Does this logic also apply to all L2 urls? In other words, what are the various \"business codes\" that the VIP service returns with http 200 response for each L2 url?", "author": "jessiejuachon", "createdAt": "2020-09-02T00:59:49Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{\n+    private final Logger      logger = LoggerFactory.getLogger(L2RemoteBaseOpt.class.getName());\n+\n+\n+    public L2RemoteBaseOpt() {\n+\n+    }\n+\n+    public Object getDataFromResponse(String url, String method, Object requestData, FormatCacheItem cacheItem) {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        if (cacheItem.getEtag() != null)\n+        \theaders.put(URLUtils.IF_NONE_MATCH_HEADER, cacheItem.getEtag());\n+        \n+        Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n+        \t\t.request(url, method, requestData, headers);\n+        \n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+        \n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) || \n+        \t\tresponseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+        \t\n+        \tif (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+\t        \tcacheItem.setTimestamp((long) response.get(URLUtils.RESPONSE_TIMESTAMP) );\n+        \tif (response.get(URLUtils.HEADERS) != null)\n+\t        \tcacheItem.setEtag(URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS)));\n+\t        if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+\t        \tcacheItem.setMaxAgeMillis((Long) response.get(URLUtils.MAX_AGE_MILLIS));\n+\t\t\t      \n+\t        if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+\t\t\t\ttry {\n+\t\t\t\t\tString responseStr = (String) response.get(URLUtils.BODY);\n+\t\t\t\t\tif (null == responseStr || responseStr.equals(\"\"))\n+\t\t\t\t\t\treturn null;\n+\t\t        \tJSONObject respBody = (JSONObject) JSONValue.parse(responseStr);\n+\t        \t\tif (respBody!=null && getResponseCode(respBody) == 200){\n+\t\t\t\t        return respBody.get(ConstantsKeys.DATA);\n+        \t\t\t}", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyMTk4OQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481521989", "bodyText": "Set timestamp, maxAgeMillis, etag and cachedData using 1 single synchronized setter for thread-safety. Please see my comment in FormatCacheItem. See recent changes in ComponentBasedOpt.getComponentMessages for reference.\nSuggestion: Because you have 2 child classes RemoteLocaleOpt and RemotePatternOpt, call the new synchronized setter method that sets all 4 (timestamp, maxAgeMillis, etag and cachedData) in these child classes. Do not pass the original cacheItem object to getDataFromResponse anymore. Instead, inside getDataFromResponse, just return a map that holds the timestamp, etag, maxAgeMillis and responseBody object from the response from the service. Then in here (the child class), use the values in the  map to populate the original cacheItem object using the single synchronized setter method I mentioned above.", "author": "jessiejuachon", "createdAt": "2020-09-02T01:17:27Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +27,49 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            List<Map<String, Object>> dataNode = (List<Map<String, Object>>) getDataFromResponse(\n+                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                ConstantsKeys.GET, null, cacheItem);\n+            if (dataNode != null && !dataNode.isEmpty()) {\n+                Map<String, Object> regionMap = dataNode.get(0);\n+                Map<String, String> territories = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+                if (territories != null) {\n+                    cacheItem.addCachedData(territories);", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyMjI5NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481522294", "bodyText": "See my comment in RemoteLocaleOpt.java line 40", "author": "jessiejuachon", "createdAt": "2020-09-02T01:18:47Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +27,49 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            List<Map<String, Object>> dataNode = (List<Map<String, Object>>) getDataFromResponse(\n+                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                ConstantsKeys.GET, null, cacheItem);\n+            if (dataNode != null && !dataNode.isEmpty()) {\n+                Map<String, Object> regionMap = dataNode.get(0);\n+                Map<String, String> territories = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+                if (territories != null) {\n+                    cacheItem.addCachedData(territories);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> dataNode = (Map<String, Object>) getDataFromResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n+                        ConstantsKeys.GET, null, cacheItem);\n+            if (dataNode == null || dataNode.isEmpty()) {\n+                return;\n             }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+            List<Map<String, String>> languagesArray = (List<Map<String, String>>) dataNode.get(ConstantsKeys.LANGUAGES);\n+            if (languagesArray != null && !languagesArray.isEmpty()) {\n+                Map<String, String> dispMap = new HashMap<String, String>();\n+                for (int i = 0; i < languagesArray.size(); i++) {\n+                    Map<String, String> languageNode = languagesArray.get(i);\n+                    dispMap.put(languageNode.get(ConstantsKeys.LANGUAGE_TAG),\n+                            languageNode.get(ConstantsKeys.DISPLAY_NAME));\n                 }\n+                cacheItem.addCachedData(dispMap);", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyMjM3MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481522371", "bodyText": "See my comment in RemoteLocaleOpt.java line 40", "author": "jessiejuachon", "createdAt": "2020-09-02T01:19:02Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,54 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends L2RemoteBaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+        Map<String, Object> data = (Map<String, Object>) getDataFromResponse(url, method, requestData, cacheItem);\n+        if (null != data && !data.isEmpty()) {\n+            Map<String, Object> categoriesData = this.getCategoriesFromData(data);\n+            if (categoriesData != null) {\n+                cacheItem.addCachedData(categoriesData);", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyNDI4Mg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481524282", "bodyText": "Remove addCachedData setter method. Set cachedData together with the other properties in a single synchronized setter method. See my comment in RemoteLocaleOpt.java line 40\nDo this sorting inside that setter, right before setting the cacheItem's cachedData.", "author": "jessiejuachon", "createdAt": "2020-09-02T01:23:20Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java", "diffHunk": "@@ -20,56 +20,58 @@ public FormattingCacheService() {\n \n     }\n \n-    public void addPatterns(String locale, JSONObject o) {\n+    public void addPatterns(String locale, PatternCacheItem o) {\n         String cacheKey = getPatternsCacheKey(locale);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addPatterns(String language, String region, JSONObject o) {\n+    public void addPatterns(String language, String region, PatternCacheItem o) {\n         String cacheKey = getPatternsCacheKey(language, region);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addSupportedLanguages(BaseDTO dto, String locale, Map<String, String> o) {\n-        o = JSONUtils.map2SortMap(o);\n+    public void addSupportedLanguages(BaseDTO dto, String locale, LocaleCacheItem o) {\n+        Map<String, String> map = JSONUtils.map2SortMap(o.getCachedData());\n+        o.addCachedData(map);", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyNDU4MA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481524580", "bodyText": "See comment in lines 34-35", "author": "jessiejuachon", "createdAt": "2020-09-02T01:23:48Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java", "diffHunk": "@@ -20,56 +20,58 @@ public FormattingCacheService() {\n \n     }\n \n-    public void addPatterns(String locale, JSONObject o) {\n+    public void addPatterns(String locale, PatternCacheItem o) {\n         String cacheKey = getPatternsCacheKey(locale);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addPatterns(String language, String region, JSONObject o) {\n+    public void addPatterns(String language, String region, PatternCacheItem o) {\n         String cacheKey = getPatternsCacheKey(language, region);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addSupportedLanguages(BaseDTO dto, String locale, Map<String, String> o) {\n-        o = JSONUtils.map2SortMap(o);\n+    public void addSupportedLanguages(BaseDTO dto, String locale, LocaleCacheItem o) {\n+        Map<String, String> map = JSONUtils.map2SortMap(o.getCachedData());\n+        o.addCachedData(map);\n         String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addLanguagesNames(String locale, Map<String, String> o) {\n+    public void addLanguagesNames(String locale, LocaleCacheItem o) {\n         String cacheKey = getLanguagesNamesCacheKey(locale);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addRegions(String locale, Map<String, String> o) {\n-        o = JSONUtils.map2SortMap(o);\n+    public void addRegions(String locale, LocaleCacheItem o) {\n+        Map<String, String> map = JSONUtils.map2SortMap(o.getCachedData());\n+        o.addCachedData(map);", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4NTEyNQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r482185125", "bodyText": "This is erroneous for 2 reasons:\n\n\nThe cacheItem retrieved in line 63 may be that of a fallback locale, and not of the locale passed to getRegionsByLocale. In other words, fallback locale is previously mapped to the requested locale in line 49. If this is the case, populateRegionsCache in line 67, which calls getRegionsFromDS, will mistakenly populate the properties of fallback locale's cacheItem with data of the requested locale.\n\n\nMultiple locales may be using the cacheItem retrieved in line 63 as fallback. Any one of those locales can trigger populateRegionsCache. When this happens, all the other locales that are using this cacheItem will not enter the if block in line 65 and will just return the fallback locale's cacheItem in line 70. However, we want each requested locale to try and fetch its own data after some time. This means we want each of those locales to have its own timestamp, so that it will expire on its own. When it expires, it should try to fetch for its own data from data store.\n\n\nFor both #1 and #2, this is what I did:\nAdd a property in cacheItem called \"locale\" to describe what was actually cached. This will be the same as the requested locale if the requested locale was retrieved from DS. Otherwise, this will be the fallback locale (locale of the fallback cacheItem).\nFor #1, when refreshing expired cacheItem in populateRegionsCache, read the cacheItem.locale to see what the actual locale to be retrieved from data store. See ComponentService.refreshCacheItemTask for reference.\nFor #2, this is what I recently did in ComponentService :\nIf the requested locale is not available, the cacheItem to be stored will have the following properties (ComponentService line 146):\n\nlocale = fallback locale\netag = null;\nmaxAgeMillis = maxAgeMillis of the fallback locale's cacheItem\ncachedData = null (indicates that the fallback locale's cacheItem must be used)\ntimestamp = System.currentTimeMillis()\n\nWhen retrieving data from cache and you find that the cachedData is empty, retrieve and return the cacheItem of the fallback locale (cacheItem.locale) instead. See ComponentService lines 105-116", "author": "jessiejuachon", "createdAt": "2020-09-02T15:59:44Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,177 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addRegions(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMDk0Ng==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r482210946", "bodyText": "For locales that are not found in cache, we need to immediately return fallback locale's cacheItem first and do line 72-77 in a separate thread. Reason:\nFor some product applications, this slowness at the very first uncached request is not acceptable. So we give the option to initialize cache at application start up by setting initializeCache config to true. This will populate the cache for all supported locales. However, cache will not be populated for non-supported locales. Hence, for the very first uncached request for any locale (supported or not), we want to return the fallback locale's cacheItem, assuming that at the very least, the fallback locale's cacheItem is in cache.", "author": "jessiejuachon", "createdAt": "2020-09-02T16:40:26Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,177 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addRegions(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (!cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n+            formattingCacheService.addRegions(locale, cacheItem);\n             logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMjIwNg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r482212206", "bodyText": "See my comments for regions. They should apply to display names too.", "author": "jessiejuachon", "createdAt": "2020-09-02T16:42:30Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,177 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addRegions(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (!cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n+            formattingCacheService.addRegions(locale, cacheItem);\n             logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n         }\n-        return regionMap;\n+        return cacheItem;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n+    private void getRegionsFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL);\n-            return regions;\n+            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString());\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getRegions(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getRegionsFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return regions;\n     }\n \n     public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n+        LocaleCacheItem cacheItem = getSupportedDisplayNamesByLocale(locale);\n+        if(!cacheItem.getCachedData().isEmpty()){\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find supported languages for locale [{}], look for fallback locale [{}] languages as fallback!\", locale, fallbackLocale);\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale);\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+            cacheItem = getSupportedDisplayNamesByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n                         fallbackLocale, dto.getProductID(), dto.getVersion(), locale);\n                 break;\n             }\n         }\n-        return dispMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+    public LocaleCacheItem getSupportedDisplayNamesByLocale(String locale) {\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n+        cacheItem = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateSupportedLanguagesCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+            return cacheItem;\n         }\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n+        cacheItem = new LocaleCacheItem();\n+        getSupportedLanguagesFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (!cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n             logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n         }\n-        return dispMap;\n+        return cacheItem;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private void getSupportedLanguagesFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL);\n-            return dispMap;\n+            logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n-        if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString());\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getSupportedLanguages(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getSupportedLanguagesFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return dispMap;\n+    }", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjcyOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r482686728", "bodyText": "First get from service, then get from local. In this way, local L2 doesn't depend on local L3.", "author": "Xiaochao8", "createdAt": "2020-09-03T03:50:17Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxOTk1Mw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494019953", "bodyText": "This is in offline mode, so supportedLanguages local L2 need should get from local L3 bundle.", "author": "huihuiw01", "createdAt": "2020-09-24T03:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjcyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNDU4OA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494614588", "bodyText": "In reply to Xiaochao's comment:  Yes, in LocaleService,  it will only use LocalLocaleOpt.getSupportedLanguages if RemoteLocaleOpt.getSupportedLanguages failed", "author": "jessiejuachon", "createdAt": "2020-09-24T21:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NzAyMw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r482687023", "bodyText": "Remove unused BUNDLE_PREFIX and BUNDLE_SUFFIX", "author": "Xiaochao8", "createdAt": "2020-09-03T03:51:27Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -7,19 +7,21 @@\n import com.vmware.i18n.PatternUtil;", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0NDQwNA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485044404", "bodyText": "This is erroneous. Same comment as in LocaleService.getRegionsByLocale", "author": "jessiejuachon", "createdAt": "2020-09-08T16:20:22Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1Njk3NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485056974", "bodyText": "Why do we need this method if we already have getPatterns(String locale, PatternCacheItem cacheItem) in line 23? I find that the 2 VIP service URLs are redundant. We can derive the 'language' and 'region' from the 'locale' and vice versa, correct?\nI suggest we only keep getPatterns(String locale, PatternCacheItem cacheItem). Compose/normalize the locale from language and region in PatternService.java. This locale is the used for the service URL's GET /i18n/api/v2/formatting/patterns/locales/{locale} so verify that this URL gives the exact same response as the service's GET /i18n/api/v2/formatting/patterns.", "author": "jessiejuachon", "createdAt": "2020-09-08T16:41:29Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,54 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends L2RemoteBaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcxODcyOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493718728", "bodyText": "Same reason as I replied to xiaochao's comment on PR #629, copy to here:\nYeah, but this depends on doing locale fallback/normalization first, and currently locale fallback/normalization is based on cldr locale related data. So this means L2 data needed for locale fallback/normalization must be always included in Java client package.\nBut currently to reduce the size of Java client package, pattern data is put into a separate jar, and for online mode this jar isn't neccessary. If product choose online mode and don't add this jar, change as your suggestion will lead to program broken.\nSo I prefer to remove this after we can guarantee data needed for locale fallback/normalization is always included or we define new locale fallback/normalization rule which doesn't relies on cldr data.", "author": "huihuiw01", "createdAt": "2020-09-23T16:13:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1Njk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4ODE1NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494588154", "bodyText": "Let's discuss this after this PR. We need to revisit the design workflow for L2.", "author": "jessiejuachon", "createdAt": "2020-09-24T20:22:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1Njk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1NzMzNA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485057334", "bodyText": "Why do we need this method if we already have getPatterns(String locale, PatternCacheItem cacheItem) in line 25? See my comment in RemotePatternOpt.java line 30", "author": "jessiejuachon", "createdAt": "2020-09-08T16:42:08Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -22,33 +22,35 @@\n public class LocalPatternOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n         String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n         logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n     @Override\n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2Mzg1OQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485063859", "bodyText": "We do not need getPatternByLanguageRegion. Just normalize/compose the locale here from the language and region, and then call getPatterns(String locale). See my comment in RemotePatternOpt.java line 30.", "author": "jessiejuachon", "createdAt": "2020-09-08T16:53:35Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (cacheItem.getCachedData() != null && !cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            formattingCacheService.addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, cacheItem);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n-        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLanguageRegion(language, region);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(new Locale(language, region).toLanguageTag()))\n                 continue;\n             logger.info(\"Can't find pattern for language [{}] region [{}], look for fallback locale [{}] pattern as fallback!\", language, region, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(language, region, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(language, region, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for language [{}], region [{}]!\\n\\n\", fallbackLocale, language, region);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NDE1OA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485064158", "bodyText": "We do not need this method. See comment above (lines 81-98)", "author": "jessiejuachon", "createdAt": "2020-09-08T16:54:07Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (cacheItem.getCachedData() != null && !cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            formattingCacheService.addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, cacheItem);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n-        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLanguageRegion(language, region);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(new Locale(language, region).toLanguageTag()))\n                 continue;\n             logger.info(\"Can't find pattern for language [{}] region [{}], look for fallback locale [{}] pattern as fallback!\", language, region, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(language, region, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(language, region, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for language [{}], region [{}]!\\n\\n\", fallbackLocale, language, region);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+    public PatternCacheItem getPatternsByLanguageRegion(String language, String region) {", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NDQ3OA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485064478", "bodyText": "We do not need this method. See comment above (lines 81-98)", "author": "jessiejuachon", "createdAt": "2020-09-08T16:54:41Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (cacheItem.getCachedData() != null && !cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            formattingCacheService.addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, cacheItem);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n-        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLanguageRegion(language, region);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(new Locale(language, region).toLanguageTag()))\n                 continue;\n             logger.info(\"Can't find pattern for language [{}] region [{}], look for fallback locale [{}] pattern as fallback!\", language, region, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(language, region, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(language, region, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for language [{}], region [{}]!\\n\\n\", fallbackLocale, language, region);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+    public PatternCacheItem getPatternsByLanguageRegion(String language, String region) {\n         language = language.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(language, region);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(language, region, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(language, region, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (!cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            formattingCacheService.addPatterns(language, region, patterns);\n+            formattingCacheService.addPatterns(language, region, cacheItem);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n-    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        JSONObject patterns = null;\n+    private void getPatternsFromDS(String locale, PatternCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext())\n-            return patterns;\n+            return;\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        patterns = dataSource.createPatternOpt().getPatterns(locale);\n-        if (patterns == null || patterns.isEmpty()) {\n-            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createPatternOpt().getPatterns(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED, locale, dataSource.toString()));\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            if (msgSourceQueueIter.hasNext()) {\n+                getPatternsFromDS(locale, cacheItem, msgSourceQueueIter);\n+            }else{\n+                logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED_ALL, locale));\n+            }\n         }\n-        return patterns;\n     }\n \n-    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        JSONObject patterns = null;\n+    private void getPatternsFromDS(String language, String region, PatternCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NDc5NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485064794", "bodyText": "We do not need this method. See comment above (lines 81-98)", "author": "jessiejuachon", "createdAt": "2020-09-08T16:55:16Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (cacheItem.getCachedData() != null && !cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            formattingCacheService.addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, cacheItem);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n-        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLanguageRegion(language, region);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(new Locale(language, region).toLanguageTag()))\n                 continue;\n             logger.info(\"Can't find pattern for language [{}] region [{}], look for fallback locale [{}] pattern as fallback!\", language, region, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(language, region, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(language, region, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for language [{}], region [{}]!\\n\\n\", fallbackLocale, language, region);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+    public PatternCacheItem getPatternsByLanguageRegion(String language, String region) {\n         language = language.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(language, region);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(language, region, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(language, region, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (!cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            formattingCacheService.addPatterns(language, region, patterns);\n+            formattingCacheService.addPatterns(language, region, cacheItem);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n-    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        JSONObject patterns = null;\n+    private void getPatternsFromDS(String locale, PatternCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext())\n-            return patterns;\n+            return;\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        patterns = dataSource.createPatternOpt().getPatterns(locale);\n-        if (patterns == null || patterns.isEmpty()) {\n-            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createPatternOpt().getPatterns(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED, locale, dataSource.toString()));\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            if (msgSourceQueueIter.hasNext()) {\n+                getPatternsFromDS(locale, cacheItem, msgSourceQueueIter);\n+            }else{\n+                logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED_ALL, locale));\n+            }\n         }\n-        return patterns;\n     }\n \n-    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        JSONObject patterns = null;\n+    private void getPatternsFromDS(String language, String region, PatternCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext())\n-            return patterns;\n+            return;\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        patterns = dataSource.createPatternOpt().getPatterns(language, region);\n-        if (patterns == null || patterns.isEmpty()) {\n-            patterns = getPatternsFromDS(language, region, msgSourceQueueIter);\n+        dataSource.createPatternOpt().getPatterns(language, region, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED_1, language, region, dataSource.toString()));\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            if (msgSourceQueueIter.hasNext()) {\n+                getPatternsFromDS(language, region, cacheItem, msgSourceQueueIter);\n+            }else{\n+                logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED_ALL_1, language, region));\n+            }\n         }\n-        return patterns;\n+    }\n+\n+    private void populateCacheTask(String locale, PatternCacheItem cacheItem) {\n+        Callable<PatternCacheItem> callable = () -> {\n+            try {\n+\n+                // Pass cacheItem to getMessages so that:\n+                // 1. A previously stored etag, if any, can be used for the next HTTP request.\n+                // 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+                // \t with new properties from the next HTTP response.\n+                getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+                return cacheItem;\n+            } catch (Exception e) {\n+                // To make sure that the thread will close\n+                // even when an exception is thrown\n+                return null;\n+            }\n+        };\n+        FutureTask<PatternCacheItem> task = new FutureTask<PatternCacheItem>(callable);\n+        Thread thread = new Thread(task);\n+        thread.start();\n+    }\n+\n+    private void populateCacheTask(String language, String region, PatternCacheItem cacheItem) {", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NTQ0MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485065441", "bodyText": "This is erroneous. Same comment as in LocaleService.getRegionsByLocale", "author": "jessiejuachon", "createdAt": "2020-09-08T16:56:18Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (cacheItem.getCachedData() != null && !cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            formattingCacheService.addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, cacheItem);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n-        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLanguageRegion(language, region);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(new Locale(language, region).toLanguageTag()))\n                 continue;\n             logger.info(\"Can't find pattern for language [{}] region [{}], look for fallback locale [{}] pattern as fallback!\", language, region, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(language, region, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(language, region, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for language [{}], region [{}]!\\n\\n\", fallbackLocale, language, region);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+    public PatternCacheItem getPatternsByLanguageRegion(String language, String region) {\n         language = language.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(language, region);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(language, region, cacheItem);", "originalCommit": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2cd329d43a74dc04e36131c4c39cf89442102c32", "url": "https://github.com/vmware/singleton/commit/2cd329d43a74dc04e36131c4c39cf89442102c32", "message": "fix review comment: set all the cache expiration related variables in one synchronized method to make them matched", "committedDate": "2020-09-21T06:51:13Z", "type": "commit"}, {"oid": "2cd329d43a74dc04e36131c4c39cf89442102c32", "url": "https://github.com/vmware/singleton/commit/2cd329d43a74dc04e36131c4c39cf89442102c32", "message": "fix review comment: set all the cache expiration related variables in one synchronized method to make them matched", "committedDate": "2020-09-21T06:51:13Z", "type": "forcePushed"}, {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "url": "https://github.com/vmware/singleton/commit/aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "message": "fix review comments:\n1. mistakenly populate fallback locale's cacheItem with request locale's cacheItem\n2. CacheItem of locales that fallback at first fetch can't be updated", "committedDate": "2020-09-23T16:04:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwMjcyMQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493902721", "bodyText": "Remove all setter methods from FormatCacheItem so that only the synchronized set methods in LocaleCacheItem and PatternCacheItem will be used.", "author": "jessiejuachon", "createdAt": "2020-09-23T21:21:37Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n \tpublic FormatCacheItem() {\n-\t\t\n+\n+\t}\n+\n+\tpublic String getEtag() {\n+\t\treturn etag;\n+\t}\n+\n+\tprotected void setEtag(String etag) {", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg4MjE2Nw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494882167", "bodyText": "Since these properties are private, can't be accessed by sub-classes, so I have to make the setter methods as protected or make the properties themselves as protect to enable them be accessed by sub-classes.\nAnd I remember you said before it's a good practice to change the property's value with its' setter method instead of change the value directly, so I make the setter methods as protected.\nSo the setter methods can only be called in the sub-classes and in the package, can't be called by other classes outside.", "author": "huihuiw01", "createdAt": "2020-09-25T09:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwMjcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNTE3NQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493905175", "bodyText": "Let's remove this setter and only use the other synchronized setter methods. This is to avoid retrieving CacheItem from cache and then modifying CacheItem properties individually. I am planning to remove this from MessageCacheItem as well.", "author": "jessiejuachon", "createdAt": "2020-09-23T21:26:55Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/LocaleCacheItem.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class LocaleCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    private final Map<String, String> cachedData = new HashMap<String, String>();\n+\n+    public LocaleCacheItem() {\n+\n+    }\n+\n+    public LocaleCacheItem (Map<String, String> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n+        this.set(dataMap, etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(Map<String, String> dataMap, long timestamp) {\n+        this.set(dataMap, null, timestamp, null);\n+    }\n+\n+    public synchronized void set(Map<String, String> dataToCache, String etag, long timestamp, Long maxAgeMillis) {\n+        if (dataToCache != null)\n+            this.cachedData.putAll(dataToCache);\n+        this.set(etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(String etag, long timestamp, Long maxAgeMillis) {\n+        if (etag != null && !etag.isEmpty())\n+            setEtag(etag);\n+        setTimestamp(timestamp);\n+        if (maxAgeMillis != null)\n+            setMaxAgeMillis(maxAgeMillis);\n+    }\n+\n+    public synchronized void set(LocaleCacheItem cacheItem) {\n+        this.set(cacheItem.getCachedData(), cacheItem.getEtag(), cacheItem.getTimestamp(), cacheItem.getMaxAgeMillis());\n+    }", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MzMxNg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495783316", "bodyText": "I remove this method as it's not used.\nBut I wonder the CacheItem properties can be modified individually even if CacheItem is retrieved from cache? Because no individually setter methods are provided.", "author": "huihuiw01", "createdAt": "2020-09-28T08:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxMjc5Nw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506712797", "bodyText": "Hmm, I think I do not understand your comment. The point is to NOT allow individual modification of these properties, so 1 thread will lock the object first, set all three, then release the lock. These props should always be updated as a set.", "author": "jessiejuachon", "createdAt": "2020-10-16T20:45:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNTE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNjQwMw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493906403", "bodyText": "Please remove this. We want to use only the synchronized setter methods with multiple parameters so that the dataMap, timestamp, eTag and maxAgeMillis are updated as a set in a single thread. We want to avoid mismatched dataMap, etag, timestamp and/or maxAgeMillis due to conflicting threads.", "author": "jessiejuachon", "createdAt": "2020-09-23T21:29:37Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/LocaleCacheItem.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class LocaleCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    private final Map<String, String> cachedData = new HashMap<String, String>();\n+\n+    public LocaleCacheItem() {\n+\n+    }\n+\n+    public LocaleCacheItem (Map<String, String> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n+        this.set(dataMap, etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(Map<String, String> dataMap, long timestamp) {\n+        this.set(dataMap, null, timestamp, null);\n+    }\n+\n+    public synchronized void set(Map<String, String> dataToCache, String etag, long timestamp, Long maxAgeMillis) {\n+        if (dataToCache != null)\n+            this.cachedData.putAll(dataToCache);\n+        this.set(etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(String etag, long timestamp, Long maxAgeMillis) {\n+        if (etag != null && !etag.isEmpty())\n+            setEtag(etag);\n+        setTimestamp(timestamp);\n+        if (maxAgeMillis != null)\n+            setMaxAgeMillis(maxAgeMillis);\n+    }\n+\n+    public synchronized void set(LocaleCacheItem cacheItem) {\n+        this.set(cacheItem.getCachedData(), cacheItem.getEtag(), cacheItem.getTimestamp(), cacheItem.getMaxAgeMillis());\n+    }\n+\n+    public synchronized void set(long timestamp) {\n+        setTimestamp(timestamp);\n+    }", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNzE5MA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493917190", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tLong maxAgeResponse = this.getMaxAgeMillis();\n          \n          \n            \n            \t\tif (maxAgeResponse != null) {\n          \n          \n            \n            \t\t\tmaxAgeMillis = maxAgeResponse;\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif (maxAgeMillis == null) \n          \n          \n            \n            \t\t\treturn false;", "author": "jessiejuachon", "createdAt": "2020-09-23T21:54:13Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n \tpublic FormatCacheItem() {\n-\t\t\n+\n+\t}\n+\n+\tpublic String getEtag() {\n+\t\treturn etag;\n+\t}\n+\n+\tprotected void setEtag(String etag) {\n+\t\tthis.etag = etag;\n+\t}\n+\n+\tpublic long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tprotected void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tpublic Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tprotected void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong maxAgeResponse = this.getMaxAgeMillis();\n+\t\tif (maxAgeResponse != null) {\n+\t\t\tmaxAgeMillis = maxAgeResponse;\n+\t\t}", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxODE4OQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493918189", "bodyText": "Same comment as above: \"Please remove this. We want to use only the synchronized setter methods with multiple parameters so that the dataMap, timestamp, eTag and maxAgeMillis are updated as a set in a single thread. We want to avoid mismatched dataMap, etag, timestamp and/or maxAgeMillis due to conflicting threads.\"", "author": "jessiejuachon", "createdAt": "2020-09-23T21:56:01Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/PatternCacheItem.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class PatternCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    private final Map<String, Object> cachedData = new HashMap<String, Object>();\n+\n+    public PatternCacheItem() {\n+\n+\t}\n+\n+\tpublic PatternCacheItem(Map<String, Object> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n+\t\tthis.set(dataMap, etag, timestamp, maxAgeMillis);\n+\t}\n+\n+    public synchronized void set(Map<String, Object> dataMap, long timestamp) {\n+        this.set(dataMap, null, timestamp, null);\n+    }\n+\n+    public synchronized void set(Map<String, Object> dataToCache, String etag, long timestamp, Long maxAgeMillis) {\n+        if (dataToCache != null)\n+            this.cachedData.putAll(dataToCache);\n+        this.set(etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(String etag, long timestamp, Long maxAgeMillis) {\n+        if (etag != null && !etag.isEmpty())\n+            setEtag(etag);\n+        setTimestamp(timestamp);\n+        if (maxAgeMillis != null)\n+            setMaxAgeMillis(maxAgeMillis);\n+    }\n+\n+    public synchronized void set(PatternCacheItem cacheItem) {\n+        this.set(cacheItem.getCachedData(), cacheItem.getEtag(), cacheItem.getTimestamp(), cacheItem.getMaxAgeMillis());\n+    }\n+\n+    public synchronized void set(long timestamp) {\n+        setTimestamp(timestamp);\n+    }", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxODI1Mw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493918253", "bodyText": "Same comment as above: \"Let's remove this setter and only use the other synchronized setter methods. This is to avoid retrieving CacheItem from cache and then modifying CacheItem properties individually. I am planning to remove this from MessageCacheItem as well.\"", "author": "jessiejuachon", "createdAt": "2020-09-23T21:56:12Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/PatternCacheItem.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class PatternCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    private final Map<String, Object> cachedData = new HashMap<String, Object>();\n+\n+    public PatternCacheItem() {\n+\n+\t}\n+\n+\tpublic PatternCacheItem(Map<String, Object> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n+\t\tthis.set(dataMap, etag, timestamp, maxAgeMillis);\n+\t}\n+\n+    public synchronized void set(Map<String, Object> dataMap, long timestamp) {\n+        this.set(dataMap, null, timestamp, null);\n+    }\n+\n+    public synchronized void set(Map<String, Object> dataToCache, String etag, long timestamp, Long maxAgeMillis) {\n+        if (dataToCache != null)\n+            this.cachedData.putAll(dataToCache);\n+        this.set(etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(String etag, long timestamp, Long maxAgeMillis) {\n+        if (etag != null && !etag.isEmpty())\n+            setEtag(etag);\n+        setTimestamp(timestamp);\n+        if (maxAgeMillis != null)\n+            setMaxAgeMillis(maxAgeMillis);\n+    }\n+\n+    public synchronized void set(PatternCacheItem cacheItem) {\n+        this.set(cacheItem.getCachedData(), cacheItem.getEtag(), cacheItem.getTimestamp(), cacheItem.getMaxAgeMillis());\n+    }", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwOTkwOQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495809909", "bodyText": "I remove this method as it's not used.\nBut I wonder the CacheItem properties can be modified individually even if CacheItem is retrieved from cache? Because no individually setter methods are provided.", "author": "huihuiw01", "createdAt": "2020-09-28T09:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxODI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxNTM0Ng==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506715346", "bodyText": "Same reply as I have in LocaleCacheItem: \"Hmm, I think I do not understand your comment. The point is to NOT allow individual modification of these properties, so 1 thread will lock the object first, set all three, then release the lock. These props should always be updated as a set.\"", "author": "jessiejuachon", "createdAt": "2020-10-16T20:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxODI1Mw=="}], "type": "inlineReview"}, {"oid": "3e59d2a75f4bce4122ffaad1a53c68095a13205b", "url": "https://github.com/vmware/singleton/commit/3e59d2a75f4bce4122ffaad1a53c68095a13205b", "message": "fix some minor comments", "committedDate": "2020-09-24T03:53:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAwNjIxMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494006210", "bodyText": "Suggest moving this to parent class CacheItem because they are common.", "author": "Xiaochao8", "createdAt": "2020-09-24T02:44:51Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQyMzE5NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495423194", "bodyText": "Maybe let's do code clean up in a separate PR because this affects MessageCacheItem too. If you both agree, @huihuiw01 , please create an issue to track this.", "author": "jessiejuachon", "createdAt": "2020-09-26T06:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAwNjIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAwOTg1OQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494009859", "bodyText": "It seems these lines do nothing because it assigns maxAgeMillis to itself.", "author": "Xiaochao8", "createdAt": "2020-09-24T02:59:55Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n \tpublic FormatCacheItem() {\n-\t\t\n+\n+\t}\n+\n+\tpublic String getEtag() {\n+\t\treturn etag;\n+\t}\n+\n+\tprotected void setEtag(String etag) {\n+\t\tthis.etag = etag;\n+\t}\n+\n+\tpublic long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tprotected void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tpublic Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tprotected void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong maxAgeResponse = this.getMaxAgeMillis();\n+\t\tif (maxAgeResponse != null) {\n+\t\t\tmaxAgeMillis = maxAgeResponse;\n+\t\t}", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxMDE4MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494010181", "bodyText": "Put these lines into a synchronized block to make sure maxAgeMillis and timeStamp are matched.", "author": "Xiaochao8", "createdAt": "2020-09-24T03:01:13Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n \tpublic FormatCacheItem() {\n-\t\t\n+\n+\t}\n+\n+\tpublic String getEtag() {\n+\t\treturn etag;\n+\t}\n+\n+\tprotected void setEtag(String etag) {\n+\t\tthis.etag = etag;\n+\t}\n+\n+\tpublic long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tprotected void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tpublic Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tprotected void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong maxAgeResponse = this.getMaxAgeMillis();\n+\t\tif (maxAgeResponse != null) {\n+\t\t\tmaxAgeMillis = maxAgeResponse;\n+\t\t}\n+\n+\t\treturn System.currentTimeMillis() - this.getTimestamp() >= maxAgeMillis;", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQyMjk3MA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495422970", "bodyText": "@Xiaochao8 , never put or invoke getter methods in synchronized blocks. This will affect performance. All threads must be able to get data simultaneously, and not have to wait in line.\nThe new setter methods accept the properties as set. They are also synchronized. This prevents threads from modifying individual properties at the same time which could lead to unmatched properties.", "author": "jessiejuachon", "createdAt": "2020-09-26T06:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxMDE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY2MTQ1NQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495661455", "bodyText": "Without synchronized keyword, how can you make sure the 2 variables are matched?\nAfter this.getMaxAgeMillis() but before this.getTimestamp() , other thread may have changed timestamp, they are not matched in this case.", "author": "Xiaochao8", "createdAt": "2020-09-28T02:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxMDE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNTQ1Nw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497215457", "bodyText": "@jessiejuachon I have tested with multiple threads, the scenario xiaochao mentioned can happen, so I add it to synchronized block.\nYou can also have a test.", "author": "huihuiw01", "createdAt": "2020-09-30T03:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxMDE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxNjMwMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506716300", "bodyText": "You are right, thanks. Also, performance will not be impacted as we always return whatever is in cache first while simultaneously checking for expiration.", "author": "jessiejuachon", "createdAt": "2020-10-16T20:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxMDE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxMzQyOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494013428", "bodyText": "Suggest to move this into CacheItem because it's common, change the type to Object.\nThen all the logic about expiration can move into CacheItem.", "author": "Xiaochao8", "createdAt": "2020-09-24T03:15:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/LocaleCacheItem.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class LocaleCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    private final Map<String, String> cachedData = new HashMap<String, String>();", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQyMzQ5Mg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495423492", "bodyText": "@Xiaochao8 , @huihuiw01 , please do not do this in this PR as it also affects MessageCacheItem. Let's discuss this separately. @Xiaochao8 , please log an issue for this to track it.", "author": "jessiejuachon", "createdAt": "2020-09-26T06:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxMzQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxNDYzNw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494014637", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n            \t\t\tlogger.debug(\"Didn't find supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "author": "Xiaochao8", "createdAt": "2020-09-24T03:20:15Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +40,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxNzY4OQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494017689", "bodyText": "Can remove all these from code? There are 6 in total.", "author": "Xiaochao8", "createdAt": "2020-09-24T03:33:15Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +40,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMTcxNw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494621717", "bodyText": "In reply to Xiaochao's comment: Please log as a separate \"issue\" (or just directly create a separate PR if you have the time now) in GitHub.", "author": "jessiejuachon", "createdAt": "2020-09-24T21:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxNzY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQwNDIzOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r505404238", "bodyText": "@Xiaochao8 It can help us find the problem faster, so I think it's necessary to keep it.", "author": "huihuiw01", "createdAt": "2020-10-15T09:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxNzY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyMzIzOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494023238", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate void populateLanguagesCache(String locale, LocaleCacheItem cacheItem) {\n          \n          \n            \n            \t\tCallable<LocaleCacheItem> callable = () -> {\n          \n          \n            \n            \t\t\ttry {\n          \n          \n            \n            \n          \n          \n            \n            \t\t\t\t// Pass cacheItem to getMessages so that:\n          \n          \n            \n            \t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n          \n          \n            \n            \t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n          \n          \n            \n            \t\t\t\t// \t with new properties from the next HTTP response.\n          \n          \n            \n            \t\t\t\tgetLanguagesNamesFromBundle(locale, cacheItem);\n          \n          \n            \n            \t\t\t\treturn cacheItem;\n          \n          \n            \n            \t\t\t} catch (Exception e) {\n          \n          \n            \n            \t\t\t\t// To make sure that the thread will close\n          \n          \n            \n            \t\t\t\t// even when an exception is thrown\n          \n          \n            \n            \t\t\t\treturn null;\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t};\n          \n          \n            \n            \t\tFutureTask<LocaleCacheItem> task = new FutureTask<LocaleCacheItem>(callable);\n          \n          \n            \n            \t\tThread thread = new Thread(task);\n          \n          \n            \n            \t\tthread.start();\n          \n          \n            \n            \t}\n          \n          \n            \n            \tprivate void populateLanguagesCache(String locale, LocaleCacheItem cacheItem) {\n          \n          \n            \n            \t\tRunnable runnable = () -> {\n          \n          \n            \n            \t\t\ttry {\n          \n          \n            \n            \t\t\t\tgetLanguagesNamesFromBundle(locale, cacheItem);\n          \n          \n            \n            \t\t\t} catch (Exception e) {\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t};\n          \n          \n            \n            \t\tnew Thread(runnable).start();\n          \n          \n            \n            \t}", "author": "Xiaochao8", "createdAt": "2020-09-24T03:56:16Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +40,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-        return null;\n \t}\n \n-\tpublic JSONObject getRegions(String locale) {\n+\tpublic void getRegions(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> regionsData = (Map<String, Object>) new JSONParser().parse(regionsJsonStr);\n+\t\t\tif (regionsData != null) {\n+\t\t\t\tMap<String, String> territories = (Map<String, String>) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\t\tif(territories != null) {\n+\t\t\t\t\tlogger.debug(\"Find the regions from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\t\tterritories = JSONUtils.map2SortMap(territories);\n+\t\t\t\t\tcacheItem.set(territories, System.currentTimeMillis());\n+\t\t\t\t}else{\n+\t\t\t\t\tlogger.debug(\"Doesn't find the regions from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t\t}\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-\t\treturn null;\n+\t}\n+\n+\tprivate void populateLanguagesCache(String locale, LocaleCacheItem cacheItem) {\n+\t\tCallable<LocaleCacheItem> callable = () -> {\n+\t\t\ttry {\n+\n+\t\t\t\t// Pass cacheItem to getMessages so that:\n+\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t// \t with new properties from the next HTTP response.\n+\t\t\t\tgetLanguagesNamesFromBundle(locale, cacheItem);\n+\t\t\t\treturn cacheItem;\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t// To make sure that the thread will close\n+\t\t\t\t// even when an exception is thrown\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t};\n+\t\tFutureTask<LocaleCacheItem> task = new FutureTask<LocaleCacheItem>(callable);\n+\t\tThread thread = new Thread(task);\n+\t\tthread.start();\n \t}", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNTk4OA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497215988", "bodyText": "Could you explain the difference?", "author": "huihuiw01", "createdAt": "2020-09-30T03:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyMzIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIzMzI3Mw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497233273", "bodyText": "We don't need a return value, so Callable is unnecessary and has more code lines than Runnable.", "author": "Xiaochao8", "createdAt": "2020-09-30T04:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyMzIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyNDU0NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494024544", "bodyText": "Remove all these comments, they are for translations.", "author": "Xiaochao8", "createdAt": "2020-09-24T04:01:15Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        return regionMap;\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addRegions(locale, cacheItem);\n+        logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+        return cacheItem;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n+    private void getRegionsFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL);\n-            return regions;\n+            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString());\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getRegions(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getRegionsFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return regions;\n     }\n \n     public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n+        LocaleCacheItem cacheItem = getSupportedDisplayNamesByLocale(locale);\n+        if(!cacheItem.getCachedData().isEmpty()){\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find supported languages for locale [{}], look for fallback locale [{}] languages as fallback!\", locale, fallbackLocale);\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale);\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Fallback locale [{}] displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        fallbackLocale, dto.getProductID(), dto.getVersion(), locale);\n+            cacheItem = getSupportedDisplayNamesByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return dispMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+    public LocaleCacheItem getSupportedDisplayNamesByLocale(String locale) {\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n+        cacheItem = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateSupportedLanguagesCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+            return cacheItem;\n         }\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        return dispMap;\n+        cacheItem = new LocaleCacheItem();\n+        getSupportedLanguagesFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n+        logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n+        return cacheItem;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private void getSupportedLanguagesFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL);\n-            return dispMap;\n+            logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n-        if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString());\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getSupportedLanguages(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getSupportedLanguagesFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return dispMap;\n+    }\n+\n+    private void populateRegionsCache(String locale, LocaleCacheItem cacheItem) {\n+        Callable<LocaleCacheItem> callable = () -> {\n+            try {\n+\n+                // Pass cacheItem to getMessages so that:", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQyMzk4NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495423984", "bodyText": "or just change \"getMessages\" to \"getRegionsFromDS\". Better yet, put this explanation in a javadoc block.", "author": "jessiejuachon", "createdAt": "2020-09-26T06:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyNDU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyNTc3MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494025771", "bodyText": "May you call BaseOpt.getMessagesFromResponse to get the data?", "author": "Xiaochao8", "createdAt": "2020-09-24T04:06:07Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends L2RemoteBaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                try {\n+                    String responseBody = (String) response.get(URLUtils.BODY);\n+                    Map<String, Object> patterns = getPatternsFromResponse(responseBody);\n+                    if (patterns != null) {\n+                        logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(patterns, etag, timestamp, maxAgeMillis);\n+                    }else{\n+                        logger.debug(\"Doesn't find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(etag, timestamp, maxAgeMillis);\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Failed to get pattern data from remote!\");\n+                }\n+            }else{\n+                logger.debug(\"There is no update on Singleton Service for the pattern of locale [{}].\\n\", locale);\n+                cacheItem.set(etag, timestamp, maxAgeMillis);\n             }\n-            return msgObject;\n         }\n     }\n \n-    private Object getCategoriesFromResponse(String responseStr, String node) {\n-        Object msgObject = null;\n-        try {\n-            JSONObject responseObj = (JSONObject) JSONValue.parseWithException(responseStr);\n-            if (responseObj != null) {\n-                Object dataObj = responseObj.get(ConstantsKeys.DATA);\n-                if (dataObj != null && dataObj instanceof JSONObject) {\n-                    msgObject = ((JSONObject) dataObj).get(node);\n-                }\n+    private Map<String, Object> getPatternsFromResponse(String responseBody) {\n+        Map<String, Object> categoriesObj = null;\n+        Map<String, Object> dataObj = (Map<String, Object>) getDataFromResponse(responseBody);\n+        if (dataObj != null && dataObj instanceof JSONObject) {\n+            Object obj = dataObj.get(PatternKeys.CATEGORIES);\n+            if (obj != null && obj instanceof JSONObject) {\n+                categoriesObj = (Map<String, Object>) obj;\n             }\n-        } catch (ParseException e) {\n-            // TODO Auto-generated catch block\n-            logger.error(e.getMessage());\n         }\n-        return msgObject;\n+        return categoriesObj;", "originalCommit": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NTc0Mg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494595742", "bodyText": "In reply to Xiaochao's comment: I actually do not think we should put any parsing in BaseOpt. Each API will have a different json content, and therefore, must be parsed differently. Like here, Huihui is getting PatternKeys.CATEGORIES. In RemoteL2BaseOpt.getDataFromResponse, she is parsing the business code (although not handling anything other than 200. We can improve this in the future).\nThat being said, I do not understand the design pattern of having a BaseOpt.java with methods that are for very specific, not related cases. We should revisit and clean this up in the future.", "author": "jessiejuachon", "createdAt": "2020-09-24T20:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyNTc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI3NzQwMg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497277402", "bodyText": "@Xiaochao8 I think the method name 'getMessagesFromResponse' is not appropriate, can't represent what the method do, if I call it I'm afraid of causing confusion when read it again after some time. If I change the method's name now, will introduce L3 code change which may let the PR scope more big, so I write new method.\nI also agree with @jessiejuachon we shouldn't put specific parse for one API to BaseOpt, then revisit and clean this up in future.\nDo you agree?", "author": "huihuiw01", "createdAt": "2020-09-30T06:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyNTc3MQ=="}], "type": "inlineReview"}, {"oid": "98e09fa956d7acfcedb65b34247965107188c808", "url": "https://github.com/vmware/singleton/commit/98e09fa956d7acfcedb65b34247965107188c808", "message": "Merge branch 'g11n-java-client' of https://github.com/vmware/singleton into g11n-java-client_L2CacheExpire", "committedDate": "2020-09-24T04:18:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0MTMxNw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494441317", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            long timestamp = 0;\n          \n          \n            \n                            String etag = null;\n          \n          \n            \n                            Long maxAgeMillis = null;\n          \n          \n            \n                            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n          \n          \n            \n                                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                            if (response.get(URLUtils.HEADERS) != null)\n          \n          \n            \n                                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n          \n          \n            \n                                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n          \n          \n            \n                          long timestamp = response.get(URLUtils.RESPONSE_TIMESTAMP) == null ?\n          \n          \n            \n                                System.currentTimeMillis() : (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                          String etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                          Long maxAgeMillis = response.get(URLUtils.MAX_AGE_MILLIS) == null ? null : (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "author": "jessiejuachon", "createdAt": "2020-09-24T16:10:12Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0Njc0Mg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494446742", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            long timestamp = 0;\n          \n          \n            \n                            String etag = null;\n          \n          \n            \n                            Long maxAgeMillis = null;\n          \n          \n            \n                            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n          \n          \n            \n                                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                            if (response.get(URLUtils.HEADERS) != null)\n          \n          \n            \n                                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n          \n          \n            \n                                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n          \n          \n            \n                          long timestamp = response.get(URLUtils.RESPONSE_TIMESTAMP) == null ?\n          \n          \n            \n                                System.currentTimeMillis() : (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                          String etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                          Long maxAgeMillis = response.get(URLUtils.MAX_AGE_MILLIS) == null ? null : (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "author": "jessiejuachon", "createdAt": "2020-09-24T16:18:41Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);\n+                        }\n+                    } catch (Exception e) {\n+                        logger.error(\"Failed to get region data from Singleton Service!\");\n+                    }\n+                }else{\n+                    logger.debug(\"There is no update on Singleton Service for the regions of locale [{}].\\n\", locale);\n+                    cacheItem.set(etag, timestamp, maxAgeMillis);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> response = (Map<String, Object>) getResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n-            }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+                        ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0NzExOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494447118", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n          \n          \n            \n                                        logger.debug(\"Found the regions from Singleton Service for locale [{}].\\n\", locale);", "author": "jessiejuachon", "createdAt": "2020-09-24T16:19:14Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0NzQ0NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494447444", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n          \n          \n            \n                                        logger.debug(\"Didn't find the regions from Singleton Service for locale [{}].\\n\", locale);", "author": "jessiejuachon", "createdAt": "2020-09-24T16:19:45Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0ODM1Nw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494448357", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        cacheItem.set(etag, timestamp, maxAgeMillis);\n          \n          \n            \n                                        \n          \n      \n    \n    \n  \n\nRemove this line. We do not want to update anything in the cacheItem in any case of failure of fetch from service.", "author": "jessiejuachon", "createdAt": "2020-09-24T16:21:08Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM0NzkwMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497347900", "bodyText": "This is for handling non-supported locales, just want to add an empty fetch result to cache, it's the same as you new  an empty MessageCacheItem and add it to cache.", "author": "huihuiw01", "createdAt": "2020-09-30T08:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0ODM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyOTQyMg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506729422", "bodyText": "_\"The cacheItem object here was passed a parameter. It could be an object that was retrieved from the cache (not a new cacheItem), updating its timestamp here incorrectly \"un-expires\" the cacheItem. We want to keep the old timestamp if the fetch failed.\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, remove this line please.\"_", "author": "jessiejuachon", "createdAt": "2020-10-16T21:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0ODM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAwNjgwMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r510006800", "bodyText": "Yeah, I know your optimization for this. That's great!\nBut currently it's impossible for L2 do the same as L3. Because to judge if the requested locale is supported or not, we need get the supported locale list first like L3, but currently there is no API for getting supported locale list of L2 in Singleton service. Maybe this can't be done in the next PR/in a short time. So for L2 currently I can't resolve the slowness at first request, only can avoid the slowness in later request by adding an empty CacheItem.\nYou're right the cacheItem object maybe retrieved from the cache, but updating its timestamp happens after cacheItem expires, I think it's correct to update the timestamp to un-expires the cacheItem no matter fetch success or failed, then next fetch will happen after cacheItem expired. But keeping the old timestamp will always make the cacheItem expire and fetch from data source until fetch success which may take up resources.\nSo I don't agree with you on keeping the old timestamp.", "author": "huihuiw01", "createdAt": "2020-10-22T09:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0ODM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU0OTE2Nw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r510549167", "bodyText": "I now understand why you cannot resolve the slowness on first request. We can think more about it later.\nHowever, your expire logic goes against the agreed upon design (update expiry only when successful to fetch from a data source). Any design change is outside of the scope of this PR. https://confluence.eng.vmware.com/pages/viewpage.action?pageId=530637182#SingletonClientLibrary-Caching,FallbackMechanism,andOtherFeatures-L10nFetch\nBasically, the flaw in your implementation logic is that you would mark a stale cacheItem as not expired, even if you actually weren't able to refresh the data. In other words, the same data that didn't change is actually still expired! Marking it as unexpired is misleading and incorrect. The next request for the same cache item must know that it is actually expired, and therefore try to refresh it.. and yes, it MUST rightfully take up resources to do so. Basically, the client must know whenever it has been using stale data.", "author": "jessiejuachon", "createdAt": "2020-10-23T01:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0ODM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMTk0NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r511021944", "bodyText": "Hi @huihuiw01 . It looks like you have not filed an issue regarding this yet so I did: #841\nI will now approve this Pr, and you can separately fix the new issue.", "author": "jessiejuachon", "createdAt": "2020-10-23T17:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0ODM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcyODM5Ng==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r514728396", "bodyText": "Thanks for helping log the issue, @jessiejuachon\nBut the reason I didn't log the issue is that I don't think my implementation is a issue but a fix solution for below 2 problems exsiting in current design/flow:\nThink about such scenario, there are dozens of strings on product's UI page need be translated or formatted, which will call L3 API 'getMessage' or L2 API dozens of times, and at this time Singleton service is down(online mode)\n\n\nWhen the first fetch failed, the rest call of 'getMessage' will trigger dozens of failed fetch since no cache for failed fetch which may impact performance;\n\n\nWhen cache expired will trigger dozens of new thread to update cache but since service is down then fetch failed, these failed fetch is resource-intensive. BTW, this problem is tracked by issue #605", "author": "huihuiw01", "createdAt": "2020-10-30T02:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0ODM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTMzMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494449330", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.debug(\"Find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                                        logger.debug(\"Found the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "author": "jessiejuachon", "createdAt": "2020-09-24T16:22:39Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);\n+                        }\n+                    } catch (Exception e) {\n+                        logger.error(\"Failed to get region data from Singleton Service!\");\n+                    }\n+                }else{\n+                    logger.debug(\"There is no update on Singleton Service for the regions of locale [{}].\\n\", locale);\n+                    cacheItem.set(etag, timestamp, maxAgeMillis);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> response = (Map<String, Object>) getResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n-            }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+                        ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> languages = getLanguagesFromResponse(responseBody);\n+                        if (languages != null) {\n+                            logger.debug(\"Find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTQzNQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494449435", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.debug(\"Doesn't find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                                        logger.debug(\"Didn't find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "author": "jessiejuachon", "createdAt": "2020-09-24T16:22:51Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);\n+                        }\n+                    } catch (Exception e) {\n+                        logger.error(\"Failed to get region data from Singleton Service!\");\n+                    }\n+                }else{\n+                    logger.debug(\"There is no update on Singleton Service for the regions of locale [{}].\\n\", locale);\n+                    cacheItem.set(etag, timestamp, maxAgeMillis);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> response = (Map<String, Object>) getResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n-            }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+                        ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> languages = getLanguagesFromResponse(responseBody);\n+                        if (languages != null) {\n+                            logger.debug(\"Find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+                            languages = JSONUtils.map2SortMap(languages);\n+                            cacheItem.set(languages, etag, timestamp, maxAgeMillis);\n+                        }else{\n+                            logger.debug(\"Doesn't find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTY2MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494449661", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        cacheItem.set(etag, timestamp, maxAgeMillis);\n          \n          \n            \n                                       \n          \n      \n    \n    \n  \n\nRemove this line. We do not want to update anything in the cacheItem in any case of failure of fetch from service.", "author": "jessiejuachon", "createdAt": "2020-09-24T16:23:15Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);\n+                        }\n+                    } catch (Exception e) {\n+                        logger.error(\"Failed to get region data from Singleton Service!\");\n+                    }\n+                }else{\n+                    logger.debug(\"There is no update on Singleton Service for the regions of locale [{}].\\n\", locale);\n+                    cacheItem.set(etag, timestamp, maxAgeMillis);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> response = (Map<String, Object>) getResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n-            }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+                        ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> languages = getLanguagesFromResponse(responseBody);\n+                        if (languages != null) {\n+                            logger.debug(\"Find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+                            languages = JSONUtils.map2SortMap(languages);\n+                            cacheItem.set(languages, etag, timestamp, maxAgeMillis);\n+                        }else{\n+                            logger.debug(\"Doesn't find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM0OTg4Mw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497349883", "bodyText": "This is for handling non-supported locales, just want to add an empty fetch result to cache, it's the same as you new an empty MessageCacheItem and add it to cache.", "author": "huihuiw01", "createdAt": "2020-09-30T08:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyOTUyNg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506729526", "bodyText": "Same:\n_The cacheItem object here was passed a parameter. It could be an object that was retrieved from the cache (not a new cacheItem), updating its timestamp here incorrectly \"un-expires\" the cacheItem. We want to keep the old timestamp if the fetch failed.\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, remove this line please._", "author": "jessiejuachon", "createdAt": "2020-10-16T21:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAzNTQ3Ng==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r510035476", "bodyText": "Yeah, I know your optimization for this. That's great!\nBut currently it's impossible for L2 do the same as L3. Because to judge if the requested locale is supported or not, we need get the supported locale list first like L3, but currently there is no API for getting supported locale list of L2 in Singleton service. Maybe this can't be done in the next PR/in a short time. So for L2 currently I can't resolve the slowness at first request, only can avoid the slowness in later request by adding an empty CacheItem.\nYou're right the cacheItem object maybe retrieved from the cache, but updating its timestamp happens after cacheItem expires, I think it's correct to update the timestamp to un-expires the cacheItem no matter fetch success or failed, then next fetch will happen after cacheItem expired. But keeping the old timestamp will always make the cacheItem expire and fetch from data source until fetch success which may take up resources.\nSo I don't agree with you on keeping the old timestamp.", "author": "huihuiw01", "createdAt": "2020-10-22T09:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MDEzMg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494590132", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        long timestamp = 0;\n          \n          \n            \n                        String etag = null;\n          \n          \n            \n                        Long maxAgeMillis = null;\n          \n          \n            \n            \n          \n          \n            \n                        if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n          \n          \n            \n                            timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                        if (response.get(URLUtils.HEADERS) != null)\n          \n          \n            \n                            etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                        if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n          \n          \n            \n                            maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n          \n          \n            \n                        long timestamp = response.get(URLUtils.RESPONSE_TIMESTAMP) == null ?\n          \n          \n            \n                                System.currentTimeMillis() : (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                         String etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                          Long maxAgeMillis = response.get(URLUtils.MAX_AGE_MILLIS) == null ? null : (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "author": "jessiejuachon", "createdAt": "2020-09-24T20:26:11Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends RemoteL2BaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTM2MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494591361", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);\n          \n          \n            \n                                    logger.debug(\"Found the pattern from Singleton Service for locale [{}].\\n\", locale);", "author": "jessiejuachon", "createdAt": "2020-09-24T20:28:31Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends RemoteL2BaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                try {\n+                    String responseBody = (String) response.get(URLUtils.BODY);\n+                    Map<String, Object> patterns = getPatternsFromResponse(responseBody);\n+                    if (patterns != null) {\n+                        logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTQzMw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494591433", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    logger.debug(\"Doesn't find the pattern from Singleton Service for locale [{}].\\n\", locale);\n          \n          \n            \n                                    logger.debug(\"Didn't find the pattern from Singleton Service for locale [{}].\\n\", locale);", "author": "jessiejuachon", "createdAt": "2020-09-24T20:28:41Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends RemoteL2BaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                try {\n+                    String responseBody = (String) response.get(URLUtils.BODY);\n+                    Map<String, Object> patterns = getPatternsFromResponse(responseBody);\n+                    if (patterns != null) {\n+                        logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(patterns, etag, timestamp, maxAgeMillis);\n+                    }else{\n+                        logger.debug(\"Doesn't find the pattern from Singleton Service for locale [{}].\\n\", locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTUzMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494591530", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    cacheItem.set(etag, timestamp, maxAgeMillis);\n          \n          \n            \n                                   \n          \n      \n    \n    \n  \n\nRemove this line. We do not want to update anything in the cacheItem in any case of failure of fetch from service.", "author": "jessiejuachon", "createdAt": "2020-09-24T20:28:52Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends RemoteL2BaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                try {\n+                    String responseBody = (String) response.get(URLUtils.BODY);\n+                    Map<String, Object> patterns = getPatternsFromResponse(responseBody);\n+                    if (patterns != null) {\n+                        logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(patterns, etag, timestamp, maxAgeMillis);\n+                    }else{\n+                        logger.debug(\"Doesn't find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(etag, timestamp, maxAgeMillis);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM1MDY3OA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497350678", "bodyText": "This is for handling non-supported locales, just want to add an empty fetch result to cache, it's the same as you new an empty MessageCacheItem and add it to cache.", "author": "huihuiw01", "createdAt": "2020-09-30T08:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyOTY1OA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506729658", "bodyText": "Same reply as in RemoteLocaleOpt\n_\"The cacheItem object here was passed a parameter. It could be an object that was retrieved from the cache (not a new cacheItem), updating its timestamp here incorrectly \"un-expires\" the cacheItem. We want to keep the old timestamp if the fetch failed.\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, remove this line please.\"_", "author": "jessiejuachon", "createdAt": "2020-10-16T21:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAzNTcyOQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r510035729", "bodyText": "Yeah, I know your optimization for this. That's great!\nBut currently it's impossible for L2 do the same as L3. Because to judge if the requested locale is supported or not, we need get the supported locale list first like L3, but currently there is no API for getting supported locale list of L2 in Singleton service. Maybe this can't be done in the next PR/in a short time. So for L2 currently I can't resolve the slowness at first request, only can avoid the slowness in later request by adding an empty CacheItem.\nYou're right the cacheItem object maybe retrieved from the cache, but updating its timestamp happens after cacheItem expires, I think it's correct to update the timestamp to un-expires the cacheItem no matter fetch success or failed, then next fetch will happen after cacheItem expired. But keeping the old timestamp will always make the cacheItem expire and fetch from data source until fetch success which may take up resources.\nSo I don't agree with you on keeping the old timestamp.", "author": "huihuiw01", "createdAt": "2020-10-22T09:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMTcyNA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494631724", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n          \n          \n            \n            \t\t\tlogger.debug(\"Found languages' names from cache for locale [{}]!\", locale);", "author": "jessiejuachon", "createdAt": "2020-09-24T21:53:06Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMjcxMQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494632711", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tlogger.debug(\"Doesn't find the regions from local bundle for locale [{}].\\n\", locale);\n          \n          \n            \n            \t\t\t\t\tlogger.debug(\"Didn't find the regions from local bundle for locale [{}].\\n\", locale);", "author": "jessiejuachon", "createdAt": "2020-09-24T21:55:23Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-        return null;\n \t}\n \n-\tpublic JSONObject getRegions(String locale) {\n+\tpublic void getRegions(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> regionsData = (Map<String, Object>) new JSONParser().parse(regionsJsonStr);\n+\t\t\tif (regionsData != null) {\n+\t\t\t\tMap<String, String> territories = (Map<String, String>) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\t\tif(territories != null) {\n+\t\t\t\t\tlogger.debug(\"Find the regions from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\t\tterritories = JSONUtils.map2SortMap(territories);\n+\t\t\t\t\tcacheItem.set(territories, System.currentTimeMillis());\n+\t\t\t\t}else{\n+\t\t\t\t\tlogger.debug(\"Doesn't find the regions from local bundle for locale [{}].\\n\", locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzA3Mw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494633073", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tcacheItem.set(System.currentTimeMillis());\n          \n          \n            \n            \t\t\t\t\t\n          \n      \n    \n    \n  \n\nRemove this line. We do not want to change anything in the cache item if fetch from bundle failed.", "author": "jessiejuachon", "createdAt": "2020-09-24T21:56:15Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-        return null;\n \t}\n \n-\tpublic JSONObject getRegions(String locale) {\n+\tpublic void getRegions(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> regionsData = (Map<String, Object>) new JSONParser().parse(regionsJsonStr);\n+\t\t\tif (regionsData != null) {\n+\t\t\t\tMap<String, String> territories = (Map<String, String>) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\t\tif(territories != null) {\n+\t\t\t\t\tlogger.debug(\"Find the regions from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\t\tterritories = JSONUtils.map2SortMap(territories);\n+\t\t\t\t\tcacheItem.set(territories, System.currentTimeMillis());\n+\t\t\t\t}else{\n+\t\t\t\t\tlogger.debug(\"Doesn't find the regions from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\t\tcacheItem.set(System.currentTimeMillis());", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM1MTYwNg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497351606", "bodyText": "This is for handling non-supported locales, just want to add an empty fetch result to cache, it's the same as you new an empty MessageCacheItem and add it to cache.", "author": "huihuiw01", "createdAt": "2020-09-30T08:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNDgxNA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506724814", "bodyText": "Same reply as in RemoteLocaleOpt and RemotePatternOpt:\n_\"The cacheItem object here was passed a parameter. It could be an object that was retrieved from the cache (not a new cacheItem), updating its timestamp here incorrectly \"un-expires\" the cacheItem. We want to keep the old timestamp if the fetch failed.\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, remove this line please.\"_", "author": "jessiejuachon", "createdAt": "2020-10-16T21:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzIwOQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494633209", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n          \n          \n            \n            \t\t\t\tlogger.debug(\"Didn't find the languages' names from local bundle for locale [{}].\\n\", locale);", "author": "jessiejuachon", "createdAt": "2020-09-24T21:56:39Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzI5OQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494633299", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tcacheItem.set(System.currentTimeMillis());\n          \n          \n            \n            \t\t\t\n          \n      \n    \n    \n  \n\nRemove this line. We do not want to change anything in the cache item if fetch from bundle failed.", "author": "jessiejuachon", "createdAt": "2020-09-24T21:56:49Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM1MjA4NQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497352085", "bodyText": "This is for handling non-supported locales, just want to add an empty fetch result to cache, it's the same as you new an empty MessageCacheItem and add it to cache.", "author": "huihuiw01", "createdAt": "2020-09-30T08:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzI5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNTAxNQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506725015", "bodyText": "Same reply as in RemoteLocaleOpt and RemotePatternOpt:\n_\"The cacheItem object here was passed a parameter. It could be an object that was retrieved from the cache (not a new cacheItem), updating its timestamp here incorrectly \"un-expires\" the cacheItem. We want to keep the old timestamp if the fetch failed.\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, remove this line please.\"_", "author": "jessiejuachon", "createdAt": "2020-10-16T21:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzM3OA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494633378", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n          \n          \n            \n            \t\t\t\tlogger.debug(\"Found the languages' names from local bundle for locale [{}].\\n\", locale);", "author": "jessiejuachon", "createdAt": "2020-09-24T21:57:01Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzNDYyNQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494634625", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tcacheItem.set(System.currentTimeMillis());\n          \n          \n            \n            \t\t\t\n          \n      \n    \n    \n  \n\nRemove this line. We do not want to update anything in the cacheItem if fetch failed.", "author": "jessiejuachon", "createdAt": "2020-09-24T21:59:54Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM1MjU2NA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497352564", "bodyText": "This is for handling non-supported locales, just want to add an empty fetch result to cache, it's the same as you new an empty MessageCacheItem and add it to cache.", "author": "huihuiw01", "createdAt": "2020-09-30T08:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzNDYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNTUyOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506725528", "bodyText": "Same reply as in RemoteLocaleOpt and RemotePatternOpt:\n_\"The cacheItem object here was passed a parameter. It could be an object that was retrieved from the cache (not a new cacheItem), updating its timestamp here incorrectly \"un-expires\" the cacheItem. We want to keep the old timestamp if the fetch failed.\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, remove this line please.\"_", "author": "jessiejuachon", "createdAt": "2020-10-16T21:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzNDYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MzM3Mw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494693373", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Doesn't find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);\n          \n          \n            \n                            logger.debug(\"Didn't find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);", "author": "jessiejuachon", "createdAt": "2020-09-25T01:15:28Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -22,33 +22,38 @@\n public class LocalPatternOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n         String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n         logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n     @Override\n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n         LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n         String normalizedLocale = resultData.getLocale();\n         logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n-    private JSONObject getPatternsByLocale(String normalizedLocale) {\n+    private void getPatternsByLocale(String normalizedLocale, PatternCacheItem cacheItem) {\n         if(normalizedLocale == null || normalizedLocale.isEmpty())\n-            return null;\n+            return;\n         try {\n             String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n             Map<String, Object> patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n-            return (JSONObject) patterns.get(PatternKeys.CATEGORIES);\n+            if(patterns != null) {\n+                logger.debug(\"Find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);\n+                cacheItem.set((Map<String, Object>) patterns.get(PatternKeys.CATEGORIES), System.currentTimeMillis());\n+            }else{\n+                logger.debug(\"Doesn't find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MzQwOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494693408", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);\n          \n          \n            \n                            logger.debug(\"Found the pattern from local bundle for locale [{}].\\n\", normalizedLocale);", "author": "jessiejuachon", "createdAt": "2020-09-25T01:15:36Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -22,33 +22,38 @@\n public class LocalPatternOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n         String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n         logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n     @Override\n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n         LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n         String normalizedLocale = resultData.getLocale();\n         logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n-    private JSONObject getPatternsByLocale(String normalizedLocale) {\n+    private void getPatternsByLocale(String normalizedLocale, PatternCacheItem cacheItem) {\n         if(normalizedLocale == null || normalizedLocale.isEmpty())\n-            return null;\n+            return;\n         try {\n             String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n             Map<String, Object> patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n-            return (JSONObject) patterns.get(PatternKeys.CATEGORIES);\n+            if(patterns != null) {\n+                logger.debug(\"Find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MzU2Mw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494693563", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            cacheItem.set(System.currentTimeMillis());\n          \n          \n            \n                       \n          \n      \n    \n    \n  \n\nRemove this line. We do not want to update anything in the cache item if fetch failed.", "author": "jessiejuachon", "createdAt": "2020-09-25T01:16:13Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -22,33 +22,38 @@\n public class LocalPatternOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n         String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n         logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n     @Override\n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n         LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n         String normalizedLocale = resultData.getLocale();\n         logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n-    private JSONObject getPatternsByLocale(String normalizedLocale) {\n+    private void getPatternsByLocale(String normalizedLocale, PatternCacheItem cacheItem) {\n         if(normalizedLocale == null || normalizedLocale.isEmpty())\n-            return null;\n+            return;\n         try {\n             String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n             Map<String, Object> patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n-            return (JSONObject) patterns.get(PatternKeys.CATEGORIES);\n+            if(patterns != null) {\n+                logger.debug(\"Find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);\n+                cacheItem.set((Map<String, Object>) patterns.get(PatternKeys.CATEGORIES), System.currentTimeMillis());\n+            }else{\n+                logger.debug(\"Doesn't find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);\n+                cacheItem.set(System.currentTimeMillis());", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM1Mjc1MA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497352750", "bodyText": "This is for handling non-supported locales, just want to add an empty fetch result to cache, it's the same as you new an empty MessageCacheItem and add it to cache.", "author": "huihuiw01", "createdAt": "2020-09-30T08:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MzU2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNTMxNA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506725314", "bodyText": "Same reply as in RemoteLocaleOpt and RemotePatternOpt and LocalLoclaeOpt:\n_\"The cacheItem object here was passed a parameter. It could be an object that was retrieved from the cache (not a new cacheItem), updating its timestamp here incorrectly \"un-expires\" the cacheItem. We want to keep the old timestamp if the fetch failed.\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, remove this line please.\"_", "author": "jessiejuachon", "createdAt": "2020-10-16T21:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MzU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwMzk4OA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495403988", "bodyText": "You should not add the cacheItem to the cache fetch if getRegionsFromDS failed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    formattingCacheService.addRegions(locale, cacheItem);\n          \n          \n            \n                    logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n          \n          \n            \n                    if (!cacheItem.getCachedData().isEmpty()) {\n          \n          \n            \n                        formattingCacheService.addRegions(locale, cacheItem);\n          \n          \n            \n                        logger.debug(\"Regions has been cached for locale [{}]!\\n\\n\", locale);\n          \n          \n            \n                    }", "author": "jessiejuachon", "createdAt": "2020-09-26T03:07:42Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        return regionMap;\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addRegions(locale, cacheItem);\n+        logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM1MzU5MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497353591", "bodyText": "This is for handling non-supported locales, just want to add an empty fetch result to cache, it's the same as you new an empty MessageCacheItem and add it to cache.", "author": "huihuiw01", "createdAt": "2020-09-30T09:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwMzk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyOTc3MA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506729770", "bodyText": "Same:\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, add the if statement.", "author": "jessiejuachon", "createdAt": "2020-10-16T21:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwMzk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwOTgzMA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495409830", "bodyText": "For next PR:\n\nCheck here if the requested locale is supported or not. If not supported, do not try to fetch from datastore anymore and just do the following:\n\n\nCheck if the requested locale matches a supported locale (e.g. fr_CA matches fr). If it matches, return fr regions.\nIf it does not match any supported locale, iterate over the fallback locales.", "author": "jessiejuachon", "createdAt": "2020-09-26T03:42:54Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY2NDU2OQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495664569", "bodyText": "Here supported means supported by CLDR rather than product, right?\nThis will need the CLDR data to support this.\nAt last, we should make sure the locale of translation matches the locale of pattern data.", "author": "Xiaochao8", "createdAt": "2020-09-28T02:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwOTgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE4MjU4NQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r503182585", "bodyText": "Maybe this can't be done in the next PR/in a short time.\nBecause to judge if the requested locale is supported or not, we need get the supported locale list first like L3, but currently there is no API for getting supported locale list of L2 in Singleton service.", "author": "huihuiw01", "createdAt": "2020-10-12T10:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwOTgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQyMTQ3MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495421471", "bodyText": "You should not add the cacheItem to the cache fetch if getSupportedLanguagesFromDS failed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n          \n          \n            \n                    logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                    if (cacheItem.getCachedData().isEmpty() {\n          \n          \n            \n                        formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n          \n          \n            \n                        logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                    }", "author": "jessiejuachon", "createdAt": "2020-09-26T06:14:52Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        return regionMap;\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addRegions(locale, cacheItem);\n+        logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+        return cacheItem;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n+    private void getRegionsFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL);\n-            return regions;\n+            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString());\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getRegions(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getRegionsFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return regions;\n     }\n \n     public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n+        LocaleCacheItem cacheItem = getSupportedDisplayNamesByLocale(locale);\n+        if(!cacheItem.getCachedData().isEmpty()){\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find supported languages for locale [{}], look for fallback locale [{}] languages as fallback!\", locale, fallbackLocale);\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale);\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Fallback locale [{}] displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        fallbackLocale, dto.getProductID(), dto.getVersion(), locale);\n+            cacheItem = getSupportedDisplayNamesByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return dispMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+    public LocaleCacheItem getSupportedDisplayNamesByLocale(String locale) {\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n+        cacheItem = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateSupportedLanguagesCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+            return cacheItem;\n         }\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        return dispMap;\n+        cacheItem = new LocaleCacheItem();\n+        getSupportedLanguagesFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n+        logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM1Mzg3Nw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497353877", "bodyText": "This is for handling non-supported locales, just want to add an empty fetch result to cache, it's the same as you new an empty MessageCacheItem and add it to cache.", "author": "huihuiw01", "createdAt": "2020-09-30T09:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQyMTQ3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyOTgzMg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506729832", "bodyText": "Same reply:\n_If you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, add the if statement._", "author": "jessiejuachon", "createdAt": "2020-10-16T21:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQyMTQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA5NDYzMg==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494094632", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n          \n          \n            \n                private Map<String, String> getLanguagesNamesFromCache(String locale){", "author": "Xiaochao8", "createdAt": "2020-09-24T07:25:33Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA2ODA4MQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r503068081", "bodyText": "This method is for getting languages' names of specified locale not only from cache, but also from data source, so it's not good to change to 'getLanguagesNamesFromCache'. Just change it to 'getLanguagesNames'.", "author": "huihuiw01", "createdAt": "2020-10-12T06:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA5NDYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA5NDgzMw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494094833", "bodyText": "Log an error message before return?", "author": "Xiaochao8", "createdAt": "2020-09-24T07:26:00Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyNzM3OQ==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494127379", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public PatternCacheItem getPatternsByLocale(String locale) {\n          \n          \n            \n                public PatternCacheItem getPatternsFromCache(String locale) {", "author": "Xiaochao8", "createdAt": "2020-09-24T08:20:19Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,172 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n-                logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM1NzUxOA==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497357518", "bodyText": "This method is for getting pattern of specified locale not only from cache, but also from data source, so it's not good to change to 'getPatternsFromCache'.", "author": "huihuiw01", "createdAt": "2020-09-30T09:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyNzM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY2NDA0Nw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495664047", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LocaleCacheItem getRegionsByLocale(String locale){\n          \n          \n            \n                public LocaleCacheItem getRegionsFromCache(String locale){", "author": "Xiaochao8", "createdAt": "2020-09-28T02:50:23Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){", "originalCommit": "98e09fa956d7acfcedb65b34247965107188c808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM1ODM3Nw==", "url": "https://github.com/vmware/singleton/pull/742#discussion_r497358377", "bodyText": "This method is for getting regions of specified locale(without locale fallback) not only from cache, but also from data source, so it's not good to change to 'getRegionsFromCache'.", "author": "huihuiw01", "createdAt": "2020-09-30T09:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY2NDA0Nw=="}], "type": "inlineReview"}, {"oid": "fdfc50320d97ed80d321816dfd1abfcb85655adb", "url": "https://github.com/vmware/singleton/commit/fdfc50320d97ed80d321816dfd1abfcb85655adb", "message": "fix review comments about CacheItem related objects", "committedDate": "2020-09-30T02:52:37Z", "type": "commit"}, {"oid": "fdfc50320d97ed80d321816dfd1abfcb85655adb", "url": "https://github.com/vmware/singleton/commit/fdfc50320d97ed80d321816dfd1abfcb85655adb", "message": "fix review comments about CacheItem related objects", "committedDate": "2020-09-30T02:52:37Z", "type": "forcePushed"}, {"oid": "fc2c55f08844eefaeebf34afb083b418901733e1", "url": "https://github.com/vmware/singleton/commit/fc2c55f08844eefaeebf34afb083b418901733e1", "message": "optimize code in RemoteLocaleOpt and RemotePatternOpt", "committedDate": "2020-09-30T08:09:53Z", "type": "commit"}, {"oid": "acd7b18906f7badb4fd2818c2629afdb4f4ed71b", "url": "https://github.com/vmware/singleton/commit/acd7b18906f7badb4fd2818c2629afdb4f4ed71b", "message": "fix 2 minor comments about LocalLocaleOpt:\n 1. rename method name\n 2. log an error before return sentense", "committedDate": "2020-10-15T06:42:19Z", "type": "commit"}, {"oid": "17a6154a22777e96e806547b8002a8c97e54b846", "url": "https://github.com/vmware/singleton/commit/17a6154a22777e96e806547b8002a8c97e54b846", "message": "fix review comments:\n 1. change Callable to Runnable when start a new thread to update cache\n 2. correct related comments", "committedDate": "2020-10-15T08:59:10Z", "type": "commit"}, {"oid": "1495a227b346e69ded20002a354b066b63ee75b0", "url": "https://github.com/vmware/singleton/commit/1495a227b346e69ded20002a354b066b63ee75b0", "message": "fix review comment: correct some debug logs", "committedDate": "2020-10-15T14:27:25Z", "type": "commit"}, {"oid": "c6104fe1ad5970b1fa0596632f224ca614ee248c", "url": "https://github.com/vmware/singleton/commit/c6104fe1ad5970b1fa0596632f224ca614ee248c", "message": "Merge branch 'g11n-java-client' of https://github.com/vmware/singleton into g11n-java-client_L2CacheExpire", "committedDate": "2020-10-15T15:02:37Z", "type": "commit"}, {"oid": "7c69fd525b204458cbedcb2616c9711241b6951a", "url": "https://github.com/vmware/singleton/commit/7c69fd525b204458cbedcb2616c9711241b6951a", "message": "fix as review comment: remove expire logic for languages' names cache which is from local bundle", "committedDate": "2020-10-20T08:34:49Z", "type": "commit"}, {"oid": "aad9aebb7b14b3c6653ae9779d05ea3dff5998f9", "url": "https://github.com/vmware/singleton/commit/aad9aebb7b14b3c6653ae9779d05ea3dff5998f9", "message": "fix as review comment: remove cache logic for languages' names which is from local bundle", "committedDate": "2020-10-20T15:14:01Z", "type": "commit"}, {"oid": "11e79660d44d53c49c310a4e96cbbb8b106284b3", "url": "https://github.com/vmware/singleton/commit/11e79660d44d53c49c310a4e96cbbb8b106284b3", "message": "Change the judgement condition to do data source fallback", "committedDate": "2020-10-22T15:29:40Z", "type": "commit"}]}