{"pr_number": 1900, "pr_title": "Allow using LM routing algo factory standalone", "pr_createdAt": "2020-02-12T08:15:40Z", "pr_url": "https://github.com/graphhopper/graphhopper/pull/1900", "timeline": [{"oid": "4c3aebcd0f0fd8457c8e0bc607a163d88e3b466f", "url": "https://github.com/graphhopper/graphhopper/commit/4c3aebcd0f0fd8457c8e0bc607a163d88e3b466f", "message": "Allow using LM routing algo factory standalone", "committedDate": "2020-02-12T08:12:22Z", "type": "commit"}, {"oid": "2dbdc02d77db12fd37e27cd23d2a7de3d965814c", "url": "https://github.com/graphhopper/graphhopper/commit/2dbdc02d77db12fd37e27cd23d2a7de3d965814c", "message": "Merge branch 'master' into lm_routing_factory\n\n# Conflicts:\n#\tcore/src/main/java/com/graphhopper/routing/lm/LMPreparationHandler.java\n#\tcore/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java\n#\tcore/src/test/java/com/graphhopper/routing/lm/LMApproximatorTest.java\n#\tcore/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java\n#\tcore/src/test/java/com/graphhopper/routing/weighting/DirectedRoutingTest.java\n#\tcore/src/test/java/com/graphhopper/routing/weighting/RandomizedRoutingTest.java", "committedDate": "2020-02-12T08:25:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMDgxOQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r378100819", "bodyText": "The minimal requirement to create an LM routing factory should be a LandmarkStorage, similar as a CH routing factory needs a CHGraph (the pre-processed data). defaultActiveLandmarks is also needed to provide the default number of active landmarks which is used when AlgoOpts does not specify a value for this in createAlgo(). The numBaseNodes paramater is quite ugly however, maybe we can somehow store/retrieve this information from LandmarkStorage as well?", "author": "easbar", "createdAt": "2020-02-12T08:30:15Z", "path": "core/src/main/java/com/graphhopper/routing/lm/LMRoutingAlgorithmFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.lm;\n+\n+import com.graphhopper.routing.*;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.util.Parameters;\n+\n+public class LMRoutingAlgorithmFactory implements RoutingAlgorithmFactory {\n+    private final RoutingAlgorithmFactory defaultAlgoFactory;\n+    private final LandmarkStorage lms;\n+    private final Weighting prepareWeighting;\n+    private final int defaultActiveLandmarks;\n+    private final int numBaseNodes;\n+\n+    public LMRoutingAlgorithmFactory(LandmarkStorage lms, int defaultActiveLandmarks, int numBaseNodes) {", "originalCommit": "2dbdc02d77db12fd37e27cd23d2a7de3d965814c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMjk2MA==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r378102960", "bodyText": "And we should avoid successive parameters of the same type if possible.", "author": "otbutz", "createdAt": "2020-02-12T08:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMDgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwNzkwOA==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r378107908", "bodyText": "Ok, if the numBaseNodes parameter stays (which I do not hope) we can at least change the order of parameters", "author": "easbar", "createdAt": "2020-02-12T08:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMDgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NTc0OQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382295749", "bodyText": "The numBaseNodes paramater is quite ugly however, maybe we can somehow store/retrieve this information from LandmarkStorage as well?\n\nYes, this is easy as the GraphHopperStorage is available in LandmarkStorage", "author": "karussell", "createdAt": "2020-02-20T22:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMDgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg5NDU1MA==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382894550", "bodyText": "Oh right I must have missed this somehow -> removed the parameter.", "author": "easbar", "createdAt": "2020-02-22T07:40:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMDgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMTU3NA==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r378101574", "bodyText": "Currently we create the 'default' algo with the RoutingAlgorithmFactorySimple, and afterwards we use instanceof to figure which algorithm we got and set the approximator. This is rather ugly, maybe we can simply create the algorithm in a single method (without the defaultAlgoFactory?)", "author": "easbar", "createdAt": "2020-02-12T08:32:00Z", "path": "core/src/main/java/com/graphhopper/routing/lm/LMRoutingAlgorithmFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.lm;\n+\n+import com.graphhopper.routing.*;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.util.Parameters;\n+\n+public class LMRoutingAlgorithmFactory implements RoutingAlgorithmFactory {\n+    private final RoutingAlgorithmFactory defaultAlgoFactory;\n+    private final LandmarkStorage lms;\n+    private final Weighting prepareWeighting;\n+    private final int defaultActiveLandmarks;\n+    private final int numBaseNodes;\n+\n+    public LMRoutingAlgorithmFactory(LandmarkStorage lms, int defaultActiveLandmarks, int numBaseNodes) {\n+        this.defaultAlgoFactory = new RoutingAlgorithmFactorySimple();\n+        this.lms = lms;\n+        this.defaultActiveLandmarks = defaultActiveLandmarks;\n+        this.prepareWeighting = lms.getWeighting();\n+        this.numBaseNodes = numBaseNodes;\n+    }\n+\n+    @Override\n+    public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {\n+        RoutingAlgorithm algo = defaultAlgoFactory.createAlgo(g, opts);", "originalCommit": "2dbdc02d77db12fd37e27cd23d2a7de3d965814c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MTkyMQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382291921", "bodyText": "What do you mean here? If we have a single method like this - wouldn't we repeat the code from RoutingAlgorithmFactorySimple here again? (not sure if that is bad :) )", "author": "karussell", "createdAt": "2020-02-20T22:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMTU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg5NDc1NA==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382894754", "bodyText": "Yes we repeat some of the code in RoutingAlgorithmFactorySimple, but really not that much and some of the code in the simple factory is 'overwritten' (for example because another approximator ist set). In my last commit I rewrote the createAlgo method without the simple factory and I like it better now. Note that its also more strict now: An error is thrown when an algorithm other than astar,astarbi,alternative_route is requested (because LM does not work with dijkstra for example). For CH its similar, it throws an error if we request non-bidir Dijkstra with CH. What do you think, does that make sense?", "author": "easbar", "createdAt": "2020-02-22T07:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMTU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwMjM5Nw==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r383002397", "bodyText": "Ok, yes makes sense.", "author": "karussell", "createdAt": "2020-02-23T13:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMTU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMjIzMQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r378102231", "bodyText": "Are there any cases besides AStar, AStarBidirection and AlternativeRoute (especially since we removed the CH+LM combination for now?). If not this code could be simplified.", "author": "easbar", "createdAt": "2020-02-12T08:33:35Z", "path": "core/src/main/java/com/graphhopper/routing/lm/LMRoutingAlgorithmFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.lm;\n+\n+import com.graphhopper.routing.*;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.util.Parameters;\n+\n+public class LMRoutingAlgorithmFactory implements RoutingAlgorithmFactory {\n+    private final RoutingAlgorithmFactory defaultAlgoFactory;\n+    private final LandmarkStorage lms;\n+    private final Weighting prepareWeighting;\n+    private final int defaultActiveLandmarks;\n+    private final int numBaseNodes;\n+\n+    public LMRoutingAlgorithmFactory(LandmarkStorage lms, int defaultActiveLandmarks, int numBaseNodes) {\n+        this.defaultAlgoFactory = new RoutingAlgorithmFactorySimple();\n+        this.lms = lms;\n+        this.defaultActiveLandmarks = defaultActiveLandmarks;\n+        this.prepareWeighting = lms.getWeighting();\n+        this.numBaseNodes = numBaseNodes;\n+    }\n+\n+    @Override\n+    public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {\n+        RoutingAlgorithm algo = defaultAlgoFactory.createAlgo(g, opts);\n+        return getPreparedRoutingAlgorithm(g, algo, opts);\n+    }\n+\n+    private RoutingAlgorithm getPreparedRoutingAlgorithm(Graph qGraph, RoutingAlgorithm algo, AlgorithmOptions opts) {\n+        int activeLM = Math.max(1, opts.getHints().getInt(Parameters.Landmark.ACTIVE_COUNT, defaultActiveLandmarks));\n+        if (algo instanceof AStar) {\n+            if (!lms.isInitialized())\n+                throw new IllegalStateException(\"Initialize landmark storage before creating algorithms\");\n+\n+            double epsilon = opts.getHints().getDouble(Parameters.Algorithms.AStar.EPSILON, 1);\n+            AStar astar = (AStar) algo;\n+            astar.setApproximation(new LMApproximator(qGraph, prepareWeighting, numBaseNodes, lms, activeLM, lms.getFactor(), false).\n+                    setEpsilon(epsilon));\n+            return algo;\n+        } else if (algo instanceof AStarBidirection) {\n+            if (!lms.isInitialized())\n+                throw new IllegalStateException(\"Initialize landmark storage before creating algorithms\");\n+\n+            double epsilon = opts.getHints().getDouble(Parameters.Algorithms.AStarBi.EPSILON, 1);\n+            AStarBidirection astarbi = (AStarBidirection) algo;\n+            astarbi.setApproximation(new LMApproximator(qGraph, prepareWeighting, numBaseNodes, lms, activeLM, lms.getFactor(), false).\n+                    setEpsilon(epsilon));\n+            return algo;\n+        } else if (algo instanceof AlternativeRoute) {\n+            if (!lms.isInitialized())\n+                throw new IllegalStateException(\"Initialize landmark storage before creating algorithms\");\n+\n+            double epsilon = opts.getHints().getDouble(Parameters.Algorithms.AStarBi.EPSILON, 1);\n+            AlternativeRoute altRoute = (AlternativeRoute) algo;\n+            altRoute.setApproximation(new LMApproximator(qGraph, prepareWeighting, numBaseNodes, lms, activeLM, lms.getFactor(), false).\n+                    setEpsilon(epsilon));\n+            // landmark algorithm follows good compromise between fast response and exploring 'interesting' paths so we\n+            // can decrease this exploration factor further (1->dijkstra, 0.8->bidir. A*)\n+            altRoute.setMaxExplorationFactor(0.6);\n+        }\n+        return algo;", "originalCommit": "2dbdc02d77db12fd37e27cd23d2a7de3d965814c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Nzk1NA==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382287954", "bodyText": "I don't think there are more possibilities.", "author": "karussell", "createdAt": "2020-02-20T22:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMjIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMjU5NQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r378102595", "bodyText": "defaultActiveLandmarks has nothing to do with LM preparation, but its only needed when creating the algorithm, so I removed this here.", "author": "easbar", "createdAt": "2020-02-12T08:34:24Z", "path": "core/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java", "diffHunk": "@@ -45,17 +43,10 @@\n     private final Graph graph;\n     private final LandmarkStorage lms;\n     private final LMProfile lmProfile;\n-    private int defaultActiveLandmarks;", "originalCommit": "2dbdc02d77db12fd37e27cd23d2a7de3d965814c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMzA4NA==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r378103084", "bodyText": "Having the defaultActiveLandmarks parameter here is a bit ugly. Maybe we can derive some sane default from landmark storage instead (and provide an optional setter on the routing factory or something?)", "author": "easbar", "createdAt": "2020-02-12T08:35:31Z", "path": "core/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java", "diffHunk": "@@ -135,40 +125,11 @@ public void doSpecificWork() {\n                 + \", nodes:\" + graph.getNodes() + \", \" + Helper.getMemInfo());\n     }\n \n-    public RoutingAlgorithm getPreparedRoutingAlgorithm(Graph qGraph, RoutingAlgorithm algo, AlgorithmOptions opts) {\n-        int activeLM = Math.max(1, opts.getHints().getInt(Landmark.ACTIVE_COUNT, defaultActiveLandmarks));\n-        if (algo instanceof AStar) {\n-            if (!lms.isInitialized())\n-                throw new IllegalStateException(\"Initialize landmark storage before creating algorithms\");\n-\n-            double epsilon = opts.getHints().getDouble(Parameters.Algorithms.AStar.EPSILON, 1);\n-            AStar astar = (AStar) algo;\n-            astar.setApproximation(new LMApproximator(qGraph, lmProfile.getWeighting(), this.graph.getNodes(), lms, activeLM, lms.getFactor(), false).\n-                    setEpsilon(epsilon));\n-            return algo;\n-        } else if (algo instanceof AStarBidirection) {\n-            if (!lms.isInitialized())\n-                throw new IllegalStateException(\"Initialize landmark storage before creating algorithms\");\n-\n-            double epsilon = opts.getHints().getDouble(Parameters.Algorithms.AStarBi.EPSILON, 1);\n-            AStarBidirection astarbi = (AStarBidirection) algo;\n-            astarbi.setApproximation(new LMApproximator(qGraph, lmProfile.getWeighting(), this.graph.getNodes(), lms, activeLM, lms.getFactor(), false).\n-                    setEpsilon(epsilon));\n-            return algo;\n-        } else if (algo instanceof AlternativeRoute) {\n-            if (!lms.isInitialized())\n-                throw new IllegalStateException(\"Initialize landmark storage before creating algorithms\");\n-\n-            double epsilon = opts.getHints().getDouble(Parameters.Algorithms.AStarBi.EPSILON, 1);\n-            AlternativeRoute altRoute = (AlternativeRoute) algo;\n-            altRoute.setApproximation(new LMApproximator(qGraph, lmProfile.getWeighting(), this.graph.getNodes(), lms, activeLM, lms.getFactor(), false).\n-                    setEpsilon(epsilon));\n-            // landmark algorithm follows good compromise between fast response and exploring 'interesting' paths so we\n-            // can decrease this exploration factor further (1->dijkstra, 0.8->bidir. A*)\n-            altRoute.setMaxExplorationFactor(0.6);\n-        }\n-\n-        return algo;\n+    /**\n+     * Convenience method to obtain a routing algo factory from the preparation.\n+     */\n+    public RoutingAlgorithmFactory getRoutingAlgorithmFactory(int defaultActiveLandmarks) {", "originalCommit": "2dbdc02d77db12fd37e27cd23d2a7de3d965814c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4ODg2NQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382288865", "bodyText": "Yeah, the defaultActiveLandmarks should probably guessed from the landmark storage (or be half of all landmarks but at least 12 or something)", "author": "karussell", "createdAt": "2020-02-20T22:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMzA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg5NDg0NA==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382894844", "bodyText": "Ok I think as long as we keep this parameter it should be a property of the LM routing algorithm factory, but I removed it from the constructor parameter list and set it to a default as you suggested. It can be changed using a setter.", "author": "easbar", "createdAt": "2020-02-22T07:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMzA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwMzg3Ng==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r378103876", "bodyText": "Should we keep some kind of option to create the prepared LM algorithm given an algorithm (like we had for AStar here)? Or maybe some kind of getApproximator or setApproximatorForAlgo` method?", "author": "easbar", "createdAt": "2020-02-12T08:37:11Z", "path": "core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java", "diffHunk": "@@ -133,28 +139,28 @@ public void testLandmarkStorageAndRouting() {\n         // TODO should better select 0 and 224?\n         assertEquals(Arrays.asList(224, 70), list);\n \n-        AlgorithmOptions opts = AlgorithmOptions.start().weighting(weighting).traversalMode(tm).\n-                build();\n-\n-        PrepareLandmarks prepare = new PrepareLandmarks(new RAMDirectory(), graph, lmProfile, 4, 2);\n+        PrepareLandmarks prepare = new PrepareLandmarks(new RAMDirectory(), graph, lmProfile, 4);\n         prepare.setMinimumNodes(2);\n         prepare.doWork();\n \n         AStar expectedAlgo = new AStar(graph, weighting, tm);\n         Path expectedPath = expectedAlgo.calcPath(41, 183);\n \n+        final int activeLandmarks = 2;\n+\n         // landmarks with A*\n-        RoutingAlgorithm oneDirAlgoWithLandmarks = prepare.getPreparedRoutingAlgorithm(graph, new AStar(graph, weighting, tm), opts);\n+        RoutingAlgorithm oneDirAlgoWithLandmarks = prepare.getRoutingAlgorithmFactory(activeLandmarks).createAlgo(graph,", "originalCommit": "2dbdc02d77db12fd37e27cd23d2a7de3d965814c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwNDMzMQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r378104331", "bodyText": "What is this lm.recalc_count parameter, does it still exist? I could not find it anywhere.", "author": "easbar", "createdAt": "2020-02-12T08:38:10Z", "path": "core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java", "diffHunk": "@@ -133,28 +139,28 @@ public void testLandmarkStorageAndRouting() {\n         // TODO should better select 0 and 224?\n         assertEquals(Arrays.asList(224, 70), list);\n \n-        AlgorithmOptions opts = AlgorithmOptions.start().weighting(weighting).traversalMode(tm).\n-                build();\n-\n-        PrepareLandmarks prepare = new PrepareLandmarks(new RAMDirectory(), graph, lmProfile, 4, 2);\n+        PrepareLandmarks prepare = new PrepareLandmarks(new RAMDirectory(), graph, lmProfile, 4);\n         prepare.setMinimumNodes(2);\n         prepare.doWork();\n \n         AStar expectedAlgo = new AStar(graph, weighting, tm);\n         Path expectedPath = expectedAlgo.calcPath(41, 183);\n \n+        final int activeLandmarks = 2;\n+\n         // landmarks with A*\n-        RoutingAlgorithm oneDirAlgoWithLandmarks = prepare.getPreparedRoutingAlgorithm(graph, new AStar(graph, weighting, tm), opts);\n+        RoutingAlgorithm oneDirAlgoWithLandmarks = prepare.getRoutingAlgorithmFactory(activeLandmarks).createAlgo(graph,\n+                AlgorithmOptions.start().algorithm(ASTAR).weighting(weighting).traversalMode(tm).build());\n+\n         Path path = oneDirAlgoWithLandmarks.calcPath(41, 183);\n \n         assertEquals(expectedPath.getWeight(), path.getWeight(), .1);\n         assertEquals(expectedPath.calcNodes(), path.calcNodes());\n         assertEquals(expectedAlgo.getVisitedNodes() - 133, oneDirAlgoWithLandmarks.getVisitedNodes());\n \n         // landmarks with bidir A*\n-        opts.getHints().put(\"lm.recalc_count\", 50);\n-        RoutingAlgorithm biDirAlgoWithLandmarks = prepare.getPreparedRoutingAlgorithm(graph,\n-                new AStarBidirection(graph, weighting, tm), opts);\n+        RoutingAlgorithm biDirAlgoWithLandmarks = prepare.getRoutingAlgorithmFactory(activeLandmarks).createAlgo(graph,\n+                AlgorithmOptions.start().algorithm(ASTAR_BI).weighting(weighting).traversalMode(tm).hints(new PMap(\"lm.recalc_count=50\")).build());", "originalCommit": "2dbdc02d77db12fd37e27cd23d2a7de3d965814c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MDA0Mw==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382290043", "bodyText": "The recalc_count was once there and with it, it was possible to reset the underlying datastructure in a special way to reuse it partly for a different target. Unfortunately I never got it properly working, so I removed it and obviously not fully. I.e. it can be removed.", "author": "karussell", "createdAt": "2020-02-20T22:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwNDMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg5NDg3OQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382894879", "bodyText": "Ok I removed it", "author": "easbar", "createdAt": "2020-02-22T07:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwNDMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwNTQ3NA==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r378105474", "bodyText": "Do we really want the prepareWeighting (the one from LandmarkStorage) here or should it rather be opts.getWeighting()?", "author": "easbar", "createdAt": "2020-02-12T08:40:43Z", "path": "core/src/main/java/com/graphhopper/routing/lm/LMRoutingAlgorithmFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.lm;\n+\n+import com.graphhopper.routing.*;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.util.Parameters;\n+\n+public class LMRoutingAlgorithmFactory implements RoutingAlgorithmFactory {\n+    private final RoutingAlgorithmFactory defaultAlgoFactory;\n+    private final LandmarkStorage lms;\n+    private final Weighting prepareWeighting;\n+    private final int defaultActiveLandmarks;\n+    private final int numBaseNodes;\n+\n+    public LMRoutingAlgorithmFactory(LandmarkStorage lms, int defaultActiveLandmarks, int numBaseNodes) {\n+        this.defaultAlgoFactory = new RoutingAlgorithmFactorySimple();\n+        this.lms = lms;\n+        this.defaultActiveLandmarks = defaultActiveLandmarks;\n+        this.prepareWeighting = lms.getWeighting();\n+        this.numBaseNodes = numBaseNodes;\n+    }\n+\n+    @Override\n+    public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {\n+        RoutingAlgorithm algo = defaultAlgoFactory.createAlgo(g, opts);\n+        return getPreparedRoutingAlgorithm(g, algo, opts);\n+    }\n+\n+    private RoutingAlgorithm getPreparedRoutingAlgorithm(Graph qGraph, RoutingAlgorithm algo, AlgorithmOptions opts) {\n+        int activeLM = Math.max(1, opts.getHints().getInt(Parameters.Landmark.ACTIVE_COUNT, defaultActiveLandmarks));\n+        if (algo instanceof AStar) {\n+            if (!lms.isInitialized())\n+                throw new IllegalStateException(\"Initialize landmark storage before creating algorithms\");\n+\n+            double epsilon = opts.getHints().getDouble(Parameters.Algorithms.AStar.EPSILON, 1);\n+            AStar astar = (AStar) algo;\n+            astar.setApproximation(new LMApproximator(qGraph, prepareWeighting, numBaseNodes, lms, activeLM, lms.getFactor(), false).", "originalCommit": "2dbdc02d77db12fd37e27cd23d2a7de3d965814c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MDY2OQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382290669", "bodyText": "At the moment we do not allow \"cross weighting\" query, i.e. we use the weighting that was used from preparation i.e. prepareWeighting is correct (should be identical to CH)", "author": "karussell", "createdAt": "2020-02-20T22:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwNTQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg5NDk3Ng==", "url": "https://github.com/graphhopper/graphhopper/pull/1900#discussion_r382894976", "bodyText": "Ok I see and yes its the same for CH. Its just a bit misleading because RoutingAlgorithmFactory#createAlgo(Graph, AlgoOpts) allows passing in a weighting and then its ignored, but maybe this is for another issue.", "author": "easbar", "createdAt": "2020-02-22T07:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwNTQ3NA=="}], "type": "inlineReview"}, {"oid": "603782b107a96bfb47077c8e1019815e8af8e107", "url": "https://github.com/graphhopper/graphhopper/commit/603782b107a96bfb47077c8e1019815e8af8e107", "message": "Merge branch 'master' into lm_routing_factory\n\n# Conflicts:\n#\tcore/src/main/java/com/graphhopper/routing/lm/LMPreparationHandler.java", "committedDate": "2020-02-18T08:02:42Z", "type": "commit"}, {"oid": "a84fc281e846f74797c590b54a5fa585c241b1f4", "url": "https://github.com/graphhopper/graphhopper/commit/a84fc281e846f74797c590b54a5fa585c241b1f4", "message": "Merge branch 'master' into lm_routing_factory", "committedDate": "2020-02-21T21:13:36Z", "type": "commit"}, {"oid": "39300e47321b150eeee53bdee3aea7129cf1626e", "url": "https://github.com/graphhopper/graphhopper/commit/39300e47321b150eeee53bdee3aea7129cf1626e", "message": "Remove base nodes from factory constructor", "committedDate": "2020-02-21T21:37:42Z", "type": "commit"}, {"oid": "e77c9b838e263f8db6d131f3144deb94ab6b4fa0", "url": "https://github.com/graphhopper/graphhopper/commit/e77c9b838e263f8db6d131f3144deb94ab6b4fa0", "message": "Remove no longer existing recalc parameter", "committedDate": "2020-02-21T21:40:18Z", "type": "commit"}, {"oid": "bbfaf68ec0600565e3004a62bbe21db67371234c", "url": "https://github.com/graphhopper/graphhopper/commit/bbfaf68ec0600565e3004a62bbe21db67371234c", "message": "Remove active landmark parameter from lm algo factory constructor", "committedDate": "2020-02-22T07:06:38Z", "type": "commit"}, {"oid": "9a21955415817c541bedb368414da8ff482f95d6", "url": "https://github.com/graphhopper/graphhopper/commit/9a21955415817c541bedb368414da8ff482f95d6", "message": "No longer use simple factory for LM, error if non-LM algo is requested", "committedDate": "2020-02-22T07:35:36Z", "type": "commit"}, {"oid": "2f16bb11bc76d550f0e4922653a2b5d4a118650e", "url": "https://github.com/graphhopper/graphhopper/commit/2f16bb11bc76d550f0e4922653a2b5d4a118650e", "message": "Merge branch 'master' into lm_routing_factory", "committedDate": "2020-02-22T19:13:37Z", "type": "commit"}, {"oid": "e78ece172cb77381dce01f3aa977097637561b0f", "url": "https://github.com/graphhopper/graphhopper/commit/e78ece172cb77381dce01f3aa977097637561b0f", "message": "Merge branch 'master' into lm_routing_factory", "committedDate": "2020-02-23T16:40:40Z", "type": "commit"}, {"oid": "1a8691988316cbb4e505b760624e38d02338642f", "url": "https://github.com/graphhopper/graphhopper/commit/1a8691988316cbb4e505b760624e38d02338642f", "message": "Minor whitespace", "committedDate": "2020-02-23T16:42:26Z", "type": "commit"}]}