{"pr_number": 2132, "pr_title": "Use temporary helper graph to speed up CH preparation", "pr_createdAt": "2020-09-15T10:41:57Z", "pr_url": "https://github.com/graphhopper/graphhopper/pull/2132", "timeline": [{"oid": "b7a327bb7ae704f7a00b61a119da3c4932fd8fc7", "url": "https://github.com/graphhopper/graphhopper/commit/b7a327bb7ae704f7a00b61a119da3c4932fd8fc7", "message": "Use temporary helper graph to speed up CH preparation", "committedDate": "2020-09-14T14:52:56Z", "type": "commit"}, {"oid": "1f5211deb7cf018bff31d50d76a32e978eb0823f", "url": "https://github.com/graphhopper/graphhopper/commit/1f5211deb7cf018bff31d50d76a32e978eb0823f", "message": "Use split Array2D", "committedDate": "2020-09-15T09:12:06Z", "type": "commit"}, {"oid": "47e9077efff7ffe7d38e5eee6806762a934bf490", "url": "https://github.com/graphhopper/graphhopper/commit/47e9077efff7ffe7d38e5eee6806762a934bf490", "message": "Make sure memory for CH preparation is not retained after contraction or loading", "committedDate": "2020-09-15T10:33:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5MzI3NQ==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489393275", "bodyText": "Why do we need those 4 methods? The methods getOrigEdgeKeyLastBA and getOrigEdgeKeyFirstBA\nand then getOrigEdgeKeyFirstAB and getOrigEdgeKeyLastAB look identical and could we just omit two of them as this isn't used elsewhere? Also instead of\nif (nodeA > nodeB) keyFwd += 1;\nreturn keyFwd;\n\nwe could write:\nreturn nodeA > nodeB? keyFwd + 1 : keyFwd;\n\nbut probably this is done from the JIT already", "author": "karussell", "createdAt": "2020-09-16T12:21:47Z", "path": "core/src/main/java/com/graphhopper/routing/ch/CHPreparationGraph.java", "diffHunk": "@@ -0,0 +1,870 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.ch;\n+\n+import com.carrotsearch.hppc.*;\n+import com.carrotsearch.hppc.sorting.IndirectComparator;\n+import com.carrotsearch.hppc.sorting.IndirectSort;\n+import com.graphhopper.routing.ev.BooleanEncodedValue;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.TurnCost;\n+import com.graphhopper.routing.util.AllEdgesIterator;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.storage.TurnCostStorage;\n+import com.graphhopper.util.BitUtil;\n+import com.graphhopper.util.EdgeIterator;\n+import com.graphhopper.util.GHUtility;\n+\n+/**\n+ * Graph data structure used for CH preparation. It allows caching weights and edges that are not needed anymore\n+ * (those adjacent to contracted nodes) can be removed (see {@link #disconnect}.\n+ */\n+public class CHPreparationGraph {\n+    private final int nodes;\n+    private final int edges;\n+    private final boolean edgeBased;\n+    private final TurnCostFunction turnCostFunction;\n+    // each edge/shortcut between nodes a/b is represented as a single object and we maintain a list of references\n+    // to these objects at every node. this needs to be memory-efficient especially for node-based (because there\n+    // are less shortcuts overall so the size of the prepare graph is crucial, while for edge-based most memory is\n+    // consumed towards the end of the preparation anyway). for edge-based it would actually be better/faster to keep\n+    // separate lists of incoming/outgoing edges and even use uni-directional edge-objects.\n+    private SplitArray2D<PrepareEdge> prepareEdges;\n+    private IntSet neighborSet;\n+    private OrigGraph origGraph;\n+    private OrigGraph.Builder origGraphBuilder;\n+    private int nextShortcutId;\n+    private boolean ready;\n+\n+    public static CHPreparationGraph nodeBased(int nodes, int edges) {\n+        return new CHPreparationGraph(nodes, edges, false, (in, via, out) -> 0);\n+    }\n+\n+    public static CHPreparationGraph edgeBased(int nodes, int edges, TurnCostFunction turnCostFunction) {\n+        return new CHPreparationGraph(nodes, edges, true, turnCostFunction);\n+    }\n+\n+    /**\n+     * @param nodes (fixed) number of nodes of the graph\n+     * @param edges the maximum number of (non-shortcut) edges in this graph. edges-1 is the maximum edge id that may\n+     *              be used.\n+     */\n+    private CHPreparationGraph(int nodes, int edges, boolean edgeBased, TurnCostFunction turnCostFunction) {\n+        this.turnCostFunction = turnCostFunction;\n+        this.nodes = nodes;\n+        this.edges = edges;\n+        this.edgeBased = edgeBased;\n+        prepareEdges = new SplitArray2D<>(nodes, 2);\n+        origGraphBuilder = edgeBased ? new OrigGraph.Builder() : null;\n+        neighborSet = new IntHashSet();\n+        nextShortcutId = edges;\n+    }\n+\n+    public static void buildFromGraph(CHPreparationGraph prepareGraph, Graph graph, Weighting weighting) {\n+        if (graph.getNodes() != prepareGraph.getNodes())\n+            throw new IllegalArgumentException(\"Cannot initialize from given graph. The number of nodes does not match: \" +\n+                    graph.getNodes() + \" vs. \" + prepareGraph.getNodes());\n+        if (graph.getEdges() != prepareGraph.getOriginalEdges())\n+            throw new IllegalArgumentException(\"Cannot initialize from given graph. The number of edges does not match: \" +\n+                    graph.getEdges() + \" vs. \" + prepareGraph.getOriginalEdges());\n+        BooleanEncodedValue accessEnc = weighting.getFlagEncoder().getAccessEnc();\n+        AllEdgesIterator iter = graph.getAllEdges();\n+        while (iter.next()) {\n+            double weightFwd = iter.get(accessEnc) ? weighting.calcEdgeWeight(iter, false) : Double.POSITIVE_INFINITY;\n+            double weightBwd = iter.getReverse(accessEnc) ? weighting.calcEdgeWeight(iter, true) : Double.POSITIVE_INFINITY;\n+            prepareGraph.addEdge(iter.getBaseNode(), iter.getAdjNode(), iter.getEdge(), weightFwd, weightBwd);\n+        }\n+        prepareGraph.prepareForContraction();\n+    }\n+\n+    /**\n+     * Builds a turn cost function for a given graph('s turn cost storage) and a weighting.\n+     * The trivial implementation would be simply returning {@link Weighting#calcTurnWeight}. However, it turned out\n+     * that reading all turn costs for the current encoder and then storing them in separate arrays upfront speeds up\n+     * edge-based CH preparation by about 25%. See #2084\n+     */\n+    public static TurnCostFunction buildTurnCostFunctionFromTurnCostStorage(Graph graph, Weighting weighting) {\n+        FlagEncoder encoder = weighting.getFlagEncoder();\n+        String key = TurnCost.key(encoder.toString());\n+        if (!encoder.hasEncodedValue(key))\n+            return (inEdge, viaNode, outEdge) -> 0;\n+\n+        DecimalEncodedValue turnCostEnc = encoder.getDecimalEncodedValue(key);\n+        TurnCostStorage turnCostStorage = graph.getTurnCostStorage();\n+        // we maintain a list of inEdge/outEdge/turn-cost triples (we use two arrays for this) that is sorted by nodes\n+        LongArrayList turnCostEdgePairs = new LongArrayList();\n+        DoubleArrayList turnCosts = new DoubleArrayList();\n+        // for each node we store the index of the first turn cost entry/triple in the list\n+        final int[] turnCostNodes = new int[graph.getNodes() + 1];\n+        // todonow: get rid of this hack... / obtain the u-turn costs directly from weighting\n+        double uTurnCosts = weighting.calcTurnWeight(1, 0, 1);\n+        TurnCostStorage.TurnRelationIterator tcIter = turnCostStorage.getAllTurnRelations();\n+        int lastNode = -1;\n+        while (tcIter.next()) {\n+            int viaNode = tcIter.getViaNode();\n+            if (viaNode < lastNode)\n+                throw new IllegalStateException();\n+            long edgePair = BitUtil.LITTLE.combineIntsToLong(tcIter.getFromEdge(), tcIter.getToEdge());\n+            double turnCost = tcIter.getCost(turnCostEnc);\n+            // todonow: do not forget that for pure OSM this is always infinite currently...\n+            int index = turnCostEdgePairs.size();\n+            turnCostEdgePairs.add(edgePair);\n+            turnCosts.add(turnCost);\n+            if (viaNode != lastNode) {\n+                for (int i = lastNode + 1; i <= viaNode; i++) {\n+                    turnCostNodes[i] = index;\n+                }\n+            }\n+            lastNode = viaNode;\n+        }\n+        for (int i = lastNode + 1; i <= turnCostNodes.length - 1; i++) {\n+            turnCostNodes[i] = turnCostEdgePairs.size();\n+        }\n+        turnCostNodes[turnCostNodes.length - 1] = turnCostEdgePairs.size();\n+\n+        return (inEdge, viaNode, outEdge) -> {\n+            if (!EdgeIterator.Edge.isValid(inEdge) || !EdgeIterator.Edge.isValid(outEdge))\n+                return 0;\n+            else if (inEdge == outEdge)\n+                return uTurnCosts;\n+            // traverse all turn cost entries we have for this viaNode and return the turn costs if we find a match\n+            for (int i = turnCostNodes[viaNode]; i < turnCostNodes[viaNode + 1]; i++) {\n+                long l = turnCostEdgePairs.get(i);\n+                if (inEdge == BitUtil.LITTLE.getIntLow(l) && outEdge == BitUtil.LITTLE.getIntHigh(l))\n+                    return turnCosts.get(i);\n+            }\n+            return 0;\n+        };\n+    }\n+\n+    public int getNodes() {\n+        return nodes;\n+    }\n+\n+    public int getOriginalEdges() {\n+        return edges;\n+    }\n+\n+    public int getDegree(int node) {\n+        return prepareEdges.size(node);\n+    }\n+\n+    public void addEdge(int from, int to, int edge, double weightFwd, double weightBwd) {\n+        checkNotReady();\n+        boolean fwd = Double.isFinite(weightFwd);\n+        boolean bwd = Double.isFinite(weightBwd);\n+        if (!fwd && !bwd)\n+            return;\n+        // todonow: is it ok to cast to float? maybe add some check that asserts certain precision? especially inf?\n+        PrepareBaseEdge prepareEdge = new PrepareBaseEdge(edge, from, to, (float) weightFwd, (float) weightBwd);\n+        if (Double.isFinite(weightFwd)) {\n+            addOutEdge(from, prepareEdge);\n+            addInEdge(to, prepareEdge);\n+        }\n+        if (Double.isFinite(weightBwd) && from != to) {\n+            addOutEdge(to, prepareEdge);\n+            addInEdge(from, prepareEdge);\n+        }\n+        if (edgeBased)\n+            origGraphBuilder.addEdge(from, to, edge, fwd, bwd);\n+    }\n+\n+    public int addShortcut(int from, int to, int origEdgeKeyFirst, int origEdgeKeyLast, int skipped1,\n+                           int skipped2, double weight, int origEdgeCount) {\n+        checkReady();\n+        PrepareEdge prepareEdge = edgeBased\n+                ? new EdgeBasedPrepareShortcut(nextShortcutId, from, to, origEdgeKeyFirst, origEdgeKeyLast, weight, skipped1, skipped2, origEdgeCount)\n+                : new PrepareShortcut(nextShortcutId, from, to, weight, skipped1, skipped2, origEdgeCount);\n+        addOutEdge(from, prepareEdge);\n+        addInEdge(to, prepareEdge);\n+        return nextShortcutId++;\n+    }\n+\n+    public void prepareForContraction() {\n+        checkNotReady();\n+        origGraph = edgeBased ? origGraphBuilder.build() : null;\n+        origGraphBuilder = null;\n+        // todo: performance - maybe sort the edges in some clever way?\n+        ready = true;\n+    }\n+\n+    public PrepareGraphEdgeExplorer createOutEdgeExplorer() {\n+        checkReady();\n+        return new PrepareGraphEdgeExplorerImpl(prepareEdges, false);\n+    }\n+\n+    public PrepareGraphEdgeExplorer createInEdgeExplorer() {\n+        checkReady();\n+        return new PrepareGraphEdgeExplorerImpl(prepareEdges, true);\n+    }\n+\n+    public PrepareGraphOrigEdgeExplorer createOutOrigEdgeExplorer() {\n+        checkReady();\n+        if (!edgeBased)\n+            throw new IllegalStateException(\"orig out explorer is not available for node-based graph\");\n+        return origGraph.createOutOrigEdgeExplorer();\n+    }\n+\n+    public PrepareGraphOrigEdgeExplorer createInOrigEdgeExplorer() {\n+        checkReady();\n+        if (!edgeBased)\n+            throw new IllegalStateException(\"orig in explorer is not available for node-based graph\");\n+        return origGraph.createInOrigEdgeExplorer();\n+    }\n+\n+    public double getTurnWeight(int inEdge, int viaNode, int outEdge) {\n+        return turnCostFunction.getTurnWeight(inEdge, viaNode, outEdge);\n+    }\n+\n+    public IntContainer disconnect(int node) {\n+        checkReady();\n+        // we use this neighbor set to guarantee a deterministic order of the returned\n+        // node ids\n+        neighborSet.clear();\n+        IntArrayList neighbors = new IntArrayList(getDegree(node));\n+        for (int i = 0; i < prepareEdges.size(node); i++) {\n+            PrepareEdge prepareEdge = prepareEdges.get(node, i);\n+            int adjNode = prepareEdge.getNodeB();\n+            if (adjNode == node)\n+                adjNode = prepareEdge.getNodeA();\n+            if (adjNode == node)\n+                // this is a loop\n+                continue;\n+            prepareEdges.remove(adjNode, prepareEdge);\n+            if (neighborSet.add(adjNode))\n+                neighbors.add(adjNode);\n+        }\n+        prepareEdges.clear(node);\n+        return neighbors;\n+    }\n+\n+    public void close() {\n+        checkReady();\n+        prepareEdges = null;\n+        neighborSet = null;\n+        if (edgeBased)\n+            origGraph = null;\n+    }\n+\n+    private void addOutEdge(int node, PrepareEdge prepareEdge) {\n+        prepareEdges.addPartTwo(node, prepareEdge);\n+    }\n+\n+    private void addInEdge(int node, PrepareEdge prepareEdge) {\n+        prepareEdges.addPartOne(node, prepareEdge);\n+    }\n+\n+    private void checkReady() {\n+        if (!ready)\n+            throw new IllegalStateException(\"You need to call prepareForContraction() before calling this method\");\n+    }\n+\n+    private void checkNotReady() {\n+        if (ready)\n+            throw new IllegalStateException(\"You cannot call this method after calling prepareForContraction()\");\n+    }\n+\n+    @FunctionalInterface\n+    public interface TurnCostFunction {\n+        double getTurnWeight(int inEdge, int viaNode, int outEdge);\n+    }\n+\n+    private static class PrepareGraphEdgeExplorerImpl implements PrepareGraphEdgeExplorer, PrepareGraphEdgeIterator {\n+        private final SplitArray2D<PrepareEdge> prepareEdges;\n+        private final boolean reverse;\n+        private int node = -1;\n+        private int end;\n+        private PrepareEdge currEdge;\n+        private int index;\n+\n+        PrepareGraphEdgeExplorerImpl(SplitArray2D<PrepareEdge> prepareEdges, boolean reverse) {\n+            this.prepareEdges = prepareEdges;\n+            this.reverse = reverse;\n+        }\n+\n+        @Override\n+        public PrepareGraphEdgeIterator setBaseNode(int node) {\n+            this.node = node;\n+            // we store the in edges in the first and the out edges in the second part of the prepareEdges\n+            this.index = reverse ? -1 : (prepareEdges.mid(node) - 1);\n+            this.end = reverse ? prepareEdges.mid(node) : prepareEdges.size(node);\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean next() {\n+            index++;\n+            if (index == end) {\n+                currEdge = null;\n+                return false;\n+            }\n+            currEdge = prepareEdges.get(node, index);\n+            return true;\n+        }\n+\n+        @Override\n+        public int getBaseNode() {\n+            return node;\n+        }\n+\n+        @Override\n+        public int getAdjNode() {\n+            return nodeAisBase() ? currEdge.getNodeB() : currEdge.getNodeA();\n+        }\n+\n+        @Override\n+        public int getPrepareEdge() {\n+            return currEdge.getPrepareEdge();\n+        }\n+\n+        @Override\n+        public boolean isShortcut() {\n+            return currEdge.isShortcut();\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirst() {\n+            return nodeAisBase() ? currEdge.getOrigEdgeKeyFirstAB() : currEdge.getOrigEdgeKeyFirstBA();\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLast() {\n+            return nodeAisBase() ? currEdge.getOrigEdgeKeyLastAB() : currEdge.getOrigEdgeKeyLastBA();\n+        }\n+\n+        @Override\n+        public int getSkipped1() {\n+            return currEdge.getSkipped1();\n+        }\n+\n+        @Override\n+        public int getSkipped2() {\n+            return currEdge.getSkipped2();\n+        }\n+\n+        @Override\n+        public double getWeight() {\n+            if (nodeAisBase()) {\n+                return reverse ? currEdge.getWeightBA() : currEdge.getWeightAB();\n+            } else {\n+                return reverse ? currEdge.getWeightAB() : currEdge.getWeightBA();\n+            }\n+        }\n+\n+        @Override\n+        public int getOrigEdgeCount() {\n+            return currEdge.getOrigEdgeCount();\n+        }\n+\n+        @Override\n+        public void setSkippedEdges(int skipped1, int skipped2) {\n+            currEdge.setSkipped1(skipped1);\n+            currEdge.setSkipped2(skipped2);\n+        }\n+\n+        @Override\n+        public void setWeight(double weight) {\n+            assert Double.isFinite(weight);\n+            currEdge.setWeight(weight);\n+        }\n+\n+        @Override\n+        public void setOrigEdgeCount(int origEdgeCount) {\n+            currEdge.setOrigEdgeCount(origEdgeCount);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return currEdge == null ? \"not_started\" : getBaseNode() + \"-\" + getAdjNode();\n+        }\n+\n+        private boolean nodeAisBase() {\n+            // in some cases we need to determine which direction of the (bidirectional) edge we want\n+            return currEdge.getNodeA() == node;\n+        }\n+    }\n+\n+    interface PrepareEdge {\n+        boolean isShortcut();\n+\n+        int getPrepareEdge();\n+\n+        int getNodeA();\n+\n+        int getNodeB();\n+\n+        double getWeightAB();\n+\n+        double getWeightBA();\n+\n+        int getOrigEdgeKeyFirstAB();\n+\n+        int getOrigEdgeKeyFirstBA();\n+\n+        int getOrigEdgeKeyLastAB();\n+\n+        int getOrigEdgeKeyLastBA();\n+\n+        int getSkipped1();\n+\n+        int getSkipped2();\n+\n+        int getOrigEdgeCount();\n+\n+        void setSkipped1(int skipped1);\n+\n+        void setSkipped2(int skipped2);\n+\n+        void setWeight(double weight);\n+\n+        void setOrigEdgeCount(int origEdgeCount);\n+    }\n+\n+    public static class PrepareBaseEdge implements PrepareEdge {\n+        private final int prepareEdge;\n+        private final int nodeA;\n+        private final int nodeB;\n+        private final float weightAB;\n+        private final float weightBA;\n+\n+        public PrepareBaseEdge(int prepareEdge, int nodeA, int nodeB, float weightAB, float weightBA) {\n+            this.prepareEdge = prepareEdge;\n+            this.nodeA = nodeA;\n+            this.nodeB = nodeB;\n+            this.weightAB = weightAB;\n+            this.weightBA = weightBA;\n+        }\n+\n+        @Override\n+        public boolean isShortcut() {\n+            return false;\n+        }\n+\n+        @Override\n+        public int getPrepareEdge() {\n+            return prepareEdge;\n+        }\n+\n+        @Override\n+        public int getNodeA() {\n+            return nodeA;\n+        }\n+\n+        @Override\n+        public int getNodeB() {\n+            return nodeB;\n+        }\n+\n+        @Override\n+        public double getWeightAB() {\n+            return weightAB;\n+        }\n+\n+        @Override\n+        public double getWeightBA() {\n+            return weightBA;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstAB() {\n+            int keyFwd = prepareEdge << 1;\n+            if (nodeA > nodeB)\n+                keyFwd += 1;\n+            return keyFwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstBA() {\n+            int keyBwd = prepareEdge << 1;\n+            if (nodeB > nodeA)\n+                keyBwd += 1;\n+            return keyBwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastAB() {\n+            int keyFwd = prepareEdge << 1;\n+            if (nodeA > nodeB)\n+                keyFwd += 1;\n+            return keyFwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastBA() {\n+            int keyBwd = prepareEdge << 1;\n+            if (nodeB > nodeA)\n+                keyBwd += 1;\n+            return keyBwd;\n+        }", "originalCommit": "47e9077efff7ffe7d38e5eee6806762a934bf490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5Mzg0Nw==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489393847", "bodyText": "Ah, sorry. Forget this comment I just found another usage (EdgeBasedPrepareShortcut)...", "author": "karussell", "createdAt": "2020-09-16T12:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5MzI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwNzYyNg==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489607626", "bodyText": "Ok I forgot it already :) (but I made use of the ternary operator as its a bit more concise). And yes we need four methods because for base edges we use the same BasePrepareEdge for both directions (AB vs BA) and for edge-based shortcuts we only store one direction but there is a difference between first/last orig edge.", "author": "easbar", "createdAt": "2020-09-16T17:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5MzI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5NTgwNg==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489395806", "bodyText": "This is a bit low. Can we avoid this reduction to 30 bits somehow? (we could use 5 bytes and a RAMDataAccess?)", "author": "karussell", "createdAt": "2020-09-16T12:26:06Z", "path": "core/src/main/java/com/graphhopper/routing/ch/CHPreparationGraph.java", "diffHunk": "@@ -0,0 +1,870 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.ch;\n+\n+import com.carrotsearch.hppc.*;\n+import com.carrotsearch.hppc.sorting.IndirectComparator;\n+import com.carrotsearch.hppc.sorting.IndirectSort;\n+import com.graphhopper.routing.ev.BooleanEncodedValue;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.TurnCost;\n+import com.graphhopper.routing.util.AllEdgesIterator;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.storage.TurnCostStorage;\n+import com.graphhopper.util.BitUtil;\n+import com.graphhopper.util.EdgeIterator;\n+import com.graphhopper.util.GHUtility;\n+\n+/**\n+ * Graph data structure used for CH preparation. It allows caching weights and edges that are not needed anymore\n+ * (those adjacent to contracted nodes) can be removed (see {@link #disconnect}.\n+ */\n+public class CHPreparationGraph {\n+    private final int nodes;\n+    private final int edges;\n+    private final boolean edgeBased;\n+    private final TurnCostFunction turnCostFunction;\n+    // each edge/shortcut between nodes a/b is represented as a single object and we maintain a list of references\n+    // to these objects at every node. this needs to be memory-efficient especially for node-based (because there\n+    // are less shortcuts overall so the size of the prepare graph is crucial, while for edge-based most memory is\n+    // consumed towards the end of the preparation anyway). for edge-based it would actually be better/faster to keep\n+    // separate lists of incoming/outgoing edges and even use uni-directional edge-objects.\n+    private SplitArray2D<PrepareEdge> prepareEdges;\n+    private IntSet neighborSet;\n+    private OrigGraph origGraph;\n+    private OrigGraph.Builder origGraphBuilder;\n+    private int nextShortcutId;\n+    private boolean ready;\n+\n+    public static CHPreparationGraph nodeBased(int nodes, int edges) {\n+        return new CHPreparationGraph(nodes, edges, false, (in, via, out) -> 0);\n+    }\n+\n+    public static CHPreparationGraph edgeBased(int nodes, int edges, TurnCostFunction turnCostFunction) {\n+        return new CHPreparationGraph(nodes, edges, true, turnCostFunction);\n+    }\n+\n+    /**\n+     * @param nodes (fixed) number of nodes of the graph\n+     * @param edges the maximum number of (non-shortcut) edges in this graph. edges-1 is the maximum edge id that may\n+     *              be used.\n+     */\n+    private CHPreparationGraph(int nodes, int edges, boolean edgeBased, TurnCostFunction turnCostFunction) {\n+        this.turnCostFunction = turnCostFunction;\n+        this.nodes = nodes;\n+        this.edges = edges;\n+        this.edgeBased = edgeBased;\n+        prepareEdges = new SplitArray2D<>(nodes, 2);\n+        origGraphBuilder = edgeBased ? new OrigGraph.Builder() : null;\n+        neighborSet = new IntHashSet();\n+        nextShortcutId = edges;\n+    }\n+\n+    public static void buildFromGraph(CHPreparationGraph prepareGraph, Graph graph, Weighting weighting) {\n+        if (graph.getNodes() != prepareGraph.getNodes())\n+            throw new IllegalArgumentException(\"Cannot initialize from given graph. The number of nodes does not match: \" +\n+                    graph.getNodes() + \" vs. \" + prepareGraph.getNodes());\n+        if (graph.getEdges() != prepareGraph.getOriginalEdges())\n+            throw new IllegalArgumentException(\"Cannot initialize from given graph. The number of edges does not match: \" +\n+                    graph.getEdges() + \" vs. \" + prepareGraph.getOriginalEdges());\n+        BooleanEncodedValue accessEnc = weighting.getFlagEncoder().getAccessEnc();\n+        AllEdgesIterator iter = graph.getAllEdges();\n+        while (iter.next()) {\n+            double weightFwd = iter.get(accessEnc) ? weighting.calcEdgeWeight(iter, false) : Double.POSITIVE_INFINITY;\n+            double weightBwd = iter.getReverse(accessEnc) ? weighting.calcEdgeWeight(iter, true) : Double.POSITIVE_INFINITY;\n+            prepareGraph.addEdge(iter.getBaseNode(), iter.getAdjNode(), iter.getEdge(), weightFwd, weightBwd);\n+        }\n+        prepareGraph.prepareForContraction();\n+    }\n+\n+    /**\n+     * Builds a turn cost function for a given graph('s turn cost storage) and a weighting.\n+     * The trivial implementation would be simply returning {@link Weighting#calcTurnWeight}. However, it turned out\n+     * that reading all turn costs for the current encoder and then storing them in separate arrays upfront speeds up\n+     * edge-based CH preparation by about 25%. See #2084\n+     */\n+    public static TurnCostFunction buildTurnCostFunctionFromTurnCostStorage(Graph graph, Weighting weighting) {\n+        FlagEncoder encoder = weighting.getFlagEncoder();\n+        String key = TurnCost.key(encoder.toString());\n+        if (!encoder.hasEncodedValue(key))\n+            return (inEdge, viaNode, outEdge) -> 0;\n+\n+        DecimalEncodedValue turnCostEnc = encoder.getDecimalEncodedValue(key);\n+        TurnCostStorage turnCostStorage = graph.getTurnCostStorage();\n+        // we maintain a list of inEdge/outEdge/turn-cost triples (we use two arrays for this) that is sorted by nodes\n+        LongArrayList turnCostEdgePairs = new LongArrayList();\n+        DoubleArrayList turnCosts = new DoubleArrayList();\n+        // for each node we store the index of the first turn cost entry/triple in the list\n+        final int[] turnCostNodes = new int[graph.getNodes() + 1];\n+        // todonow: get rid of this hack... / obtain the u-turn costs directly from weighting\n+        double uTurnCosts = weighting.calcTurnWeight(1, 0, 1);\n+        TurnCostStorage.TurnRelationIterator tcIter = turnCostStorage.getAllTurnRelations();\n+        int lastNode = -1;\n+        while (tcIter.next()) {\n+            int viaNode = tcIter.getViaNode();\n+            if (viaNode < lastNode)\n+                throw new IllegalStateException();\n+            long edgePair = BitUtil.LITTLE.combineIntsToLong(tcIter.getFromEdge(), tcIter.getToEdge());\n+            double turnCost = tcIter.getCost(turnCostEnc);\n+            // todonow: do not forget that for pure OSM this is always infinite currently...\n+            int index = turnCostEdgePairs.size();\n+            turnCostEdgePairs.add(edgePair);\n+            turnCosts.add(turnCost);\n+            if (viaNode != lastNode) {\n+                for (int i = lastNode + 1; i <= viaNode; i++) {\n+                    turnCostNodes[i] = index;\n+                }\n+            }\n+            lastNode = viaNode;\n+        }\n+        for (int i = lastNode + 1; i <= turnCostNodes.length - 1; i++) {\n+            turnCostNodes[i] = turnCostEdgePairs.size();\n+        }\n+        turnCostNodes[turnCostNodes.length - 1] = turnCostEdgePairs.size();\n+\n+        return (inEdge, viaNode, outEdge) -> {\n+            if (!EdgeIterator.Edge.isValid(inEdge) || !EdgeIterator.Edge.isValid(outEdge))\n+                return 0;\n+            else if (inEdge == outEdge)\n+                return uTurnCosts;\n+            // traverse all turn cost entries we have for this viaNode and return the turn costs if we find a match\n+            for (int i = turnCostNodes[viaNode]; i < turnCostNodes[viaNode + 1]; i++) {\n+                long l = turnCostEdgePairs.get(i);\n+                if (inEdge == BitUtil.LITTLE.getIntLow(l) && outEdge == BitUtil.LITTLE.getIntHigh(l))\n+                    return turnCosts.get(i);\n+            }\n+            return 0;\n+        };\n+    }\n+\n+    public int getNodes() {\n+        return nodes;\n+    }\n+\n+    public int getOriginalEdges() {\n+        return edges;\n+    }\n+\n+    public int getDegree(int node) {\n+        return prepareEdges.size(node);\n+    }\n+\n+    public void addEdge(int from, int to, int edge, double weightFwd, double weightBwd) {\n+        checkNotReady();\n+        boolean fwd = Double.isFinite(weightFwd);\n+        boolean bwd = Double.isFinite(weightBwd);\n+        if (!fwd && !bwd)\n+            return;\n+        // todonow: is it ok to cast to float? maybe add some check that asserts certain precision? especially inf?\n+        PrepareBaseEdge prepareEdge = new PrepareBaseEdge(edge, from, to, (float) weightFwd, (float) weightBwd);\n+        if (Double.isFinite(weightFwd)) {\n+            addOutEdge(from, prepareEdge);\n+            addInEdge(to, prepareEdge);\n+        }\n+        if (Double.isFinite(weightBwd) && from != to) {\n+            addOutEdge(to, prepareEdge);\n+            addInEdge(from, prepareEdge);\n+        }\n+        if (edgeBased)\n+            origGraphBuilder.addEdge(from, to, edge, fwd, bwd);\n+    }\n+\n+    public int addShortcut(int from, int to, int origEdgeKeyFirst, int origEdgeKeyLast, int skipped1,\n+                           int skipped2, double weight, int origEdgeCount) {\n+        checkReady();\n+        PrepareEdge prepareEdge = edgeBased\n+                ? new EdgeBasedPrepareShortcut(nextShortcutId, from, to, origEdgeKeyFirst, origEdgeKeyLast, weight, skipped1, skipped2, origEdgeCount)\n+                : new PrepareShortcut(nextShortcutId, from, to, weight, skipped1, skipped2, origEdgeCount);\n+        addOutEdge(from, prepareEdge);\n+        addInEdge(to, prepareEdge);\n+        return nextShortcutId++;\n+    }\n+\n+    public void prepareForContraction() {\n+        checkNotReady();\n+        origGraph = edgeBased ? origGraphBuilder.build() : null;\n+        origGraphBuilder = null;\n+        // todo: performance - maybe sort the edges in some clever way?\n+        ready = true;\n+    }\n+\n+    public PrepareGraphEdgeExplorer createOutEdgeExplorer() {\n+        checkReady();\n+        return new PrepareGraphEdgeExplorerImpl(prepareEdges, false);\n+    }\n+\n+    public PrepareGraphEdgeExplorer createInEdgeExplorer() {\n+        checkReady();\n+        return new PrepareGraphEdgeExplorerImpl(prepareEdges, true);\n+    }\n+\n+    public PrepareGraphOrigEdgeExplorer createOutOrigEdgeExplorer() {\n+        checkReady();\n+        if (!edgeBased)\n+            throw new IllegalStateException(\"orig out explorer is not available for node-based graph\");\n+        return origGraph.createOutOrigEdgeExplorer();\n+    }\n+\n+    public PrepareGraphOrigEdgeExplorer createInOrigEdgeExplorer() {\n+        checkReady();\n+        if (!edgeBased)\n+            throw new IllegalStateException(\"orig in explorer is not available for node-based graph\");\n+        return origGraph.createInOrigEdgeExplorer();\n+    }\n+\n+    public double getTurnWeight(int inEdge, int viaNode, int outEdge) {\n+        return turnCostFunction.getTurnWeight(inEdge, viaNode, outEdge);\n+    }\n+\n+    public IntContainer disconnect(int node) {\n+        checkReady();\n+        // we use this neighbor set to guarantee a deterministic order of the returned\n+        // node ids\n+        neighborSet.clear();\n+        IntArrayList neighbors = new IntArrayList(getDegree(node));\n+        for (int i = 0; i < prepareEdges.size(node); i++) {\n+            PrepareEdge prepareEdge = prepareEdges.get(node, i);\n+            int adjNode = prepareEdge.getNodeB();\n+            if (adjNode == node)\n+                adjNode = prepareEdge.getNodeA();\n+            if (adjNode == node)\n+                // this is a loop\n+                continue;\n+            prepareEdges.remove(adjNode, prepareEdge);\n+            if (neighborSet.add(adjNode))\n+                neighbors.add(adjNode);\n+        }\n+        prepareEdges.clear(node);\n+        return neighbors;\n+    }\n+\n+    public void close() {\n+        checkReady();\n+        prepareEdges = null;\n+        neighborSet = null;\n+        if (edgeBased)\n+            origGraph = null;\n+    }\n+\n+    private void addOutEdge(int node, PrepareEdge prepareEdge) {\n+        prepareEdges.addPartTwo(node, prepareEdge);\n+    }\n+\n+    private void addInEdge(int node, PrepareEdge prepareEdge) {\n+        prepareEdges.addPartOne(node, prepareEdge);\n+    }\n+\n+    private void checkReady() {\n+        if (!ready)\n+            throw new IllegalStateException(\"You need to call prepareForContraction() before calling this method\");\n+    }\n+\n+    private void checkNotReady() {\n+        if (ready)\n+            throw new IllegalStateException(\"You cannot call this method after calling prepareForContraction()\");\n+    }\n+\n+    @FunctionalInterface\n+    public interface TurnCostFunction {\n+        double getTurnWeight(int inEdge, int viaNode, int outEdge);\n+    }\n+\n+    private static class PrepareGraphEdgeExplorerImpl implements PrepareGraphEdgeExplorer, PrepareGraphEdgeIterator {\n+        private final SplitArray2D<PrepareEdge> prepareEdges;\n+        private final boolean reverse;\n+        private int node = -1;\n+        private int end;\n+        private PrepareEdge currEdge;\n+        private int index;\n+\n+        PrepareGraphEdgeExplorerImpl(SplitArray2D<PrepareEdge> prepareEdges, boolean reverse) {\n+            this.prepareEdges = prepareEdges;\n+            this.reverse = reverse;\n+        }\n+\n+        @Override\n+        public PrepareGraphEdgeIterator setBaseNode(int node) {\n+            this.node = node;\n+            // we store the in edges in the first and the out edges in the second part of the prepareEdges\n+            this.index = reverse ? -1 : (prepareEdges.mid(node) - 1);\n+            this.end = reverse ? prepareEdges.mid(node) : prepareEdges.size(node);\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean next() {\n+            index++;\n+            if (index == end) {\n+                currEdge = null;\n+                return false;\n+            }\n+            currEdge = prepareEdges.get(node, index);\n+            return true;\n+        }\n+\n+        @Override\n+        public int getBaseNode() {\n+            return node;\n+        }\n+\n+        @Override\n+        public int getAdjNode() {\n+            return nodeAisBase() ? currEdge.getNodeB() : currEdge.getNodeA();\n+        }\n+\n+        @Override\n+        public int getPrepareEdge() {\n+            return currEdge.getPrepareEdge();\n+        }\n+\n+        @Override\n+        public boolean isShortcut() {\n+            return currEdge.isShortcut();\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirst() {\n+            return nodeAisBase() ? currEdge.getOrigEdgeKeyFirstAB() : currEdge.getOrigEdgeKeyFirstBA();\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLast() {\n+            return nodeAisBase() ? currEdge.getOrigEdgeKeyLastAB() : currEdge.getOrigEdgeKeyLastBA();\n+        }\n+\n+        @Override\n+        public int getSkipped1() {\n+            return currEdge.getSkipped1();\n+        }\n+\n+        @Override\n+        public int getSkipped2() {\n+            return currEdge.getSkipped2();\n+        }\n+\n+        @Override\n+        public double getWeight() {\n+            if (nodeAisBase()) {\n+                return reverse ? currEdge.getWeightBA() : currEdge.getWeightAB();\n+            } else {\n+                return reverse ? currEdge.getWeightAB() : currEdge.getWeightBA();\n+            }\n+        }\n+\n+        @Override\n+        public int getOrigEdgeCount() {\n+            return currEdge.getOrigEdgeCount();\n+        }\n+\n+        @Override\n+        public void setSkippedEdges(int skipped1, int skipped2) {\n+            currEdge.setSkipped1(skipped1);\n+            currEdge.setSkipped2(skipped2);\n+        }\n+\n+        @Override\n+        public void setWeight(double weight) {\n+            assert Double.isFinite(weight);\n+            currEdge.setWeight(weight);\n+        }\n+\n+        @Override\n+        public void setOrigEdgeCount(int origEdgeCount) {\n+            currEdge.setOrigEdgeCount(origEdgeCount);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return currEdge == null ? \"not_started\" : getBaseNode() + \"-\" + getAdjNode();\n+        }\n+\n+        private boolean nodeAisBase() {\n+            // in some cases we need to determine which direction of the (bidirectional) edge we want\n+            return currEdge.getNodeA() == node;\n+        }\n+    }\n+\n+    interface PrepareEdge {\n+        boolean isShortcut();\n+\n+        int getPrepareEdge();\n+\n+        int getNodeA();\n+\n+        int getNodeB();\n+\n+        double getWeightAB();\n+\n+        double getWeightBA();\n+\n+        int getOrigEdgeKeyFirstAB();\n+\n+        int getOrigEdgeKeyFirstBA();\n+\n+        int getOrigEdgeKeyLastAB();\n+\n+        int getOrigEdgeKeyLastBA();\n+\n+        int getSkipped1();\n+\n+        int getSkipped2();\n+\n+        int getOrigEdgeCount();\n+\n+        void setSkipped1(int skipped1);\n+\n+        void setSkipped2(int skipped2);\n+\n+        void setWeight(double weight);\n+\n+        void setOrigEdgeCount(int origEdgeCount);\n+    }\n+\n+    public static class PrepareBaseEdge implements PrepareEdge {\n+        private final int prepareEdge;\n+        private final int nodeA;\n+        private final int nodeB;\n+        private final float weightAB;\n+        private final float weightBA;\n+\n+        public PrepareBaseEdge(int prepareEdge, int nodeA, int nodeB, float weightAB, float weightBA) {\n+            this.prepareEdge = prepareEdge;\n+            this.nodeA = nodeA;\n+            this.nodeB = nodeB;\n+            this.weightAB = weightAB;\n+            this.weightBA = weightBA;\n+        }\n+\n+        @Override\n+        public boolean isShortcut() {\n+            return false;\n+        }\n+\n+        @Override\n+        public int getPrepareEdge() {\n+            return prepareEdge;\n+        }\n+\n+        @Override\n+        public int getNodeA() {\n+            return nodeA;\n+        }\n+\n+        @Override\n+        public int getNodeB() {\n+            return nodeB;\n+        }\n+\n+        @Override\n+        public double getWeightAB() {\n+            return weightAB;\n+        }\n+\n+        @Override\n+        public double getWeightBA() {\n+            return weightBA;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstAB() {\n+            int keyFwd = prepareEdge << 1;\n+            if (nodeA > nodeB)\n+                keyFwd += 1;\n+            return keyFwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstBA() {\n+            int keyBwd = prepareEdge << 1;\n+            if (nodeB > nodeA)\n+                keyBwd += 1;\n+            return keyBwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastAB() {\n+            int keyFwd = prepareEdge << 1;\n+            if (nodeA > nodeB)\n+                keyFwd += 1;\n+            return keyFwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastBA() {\n+            int keyBwd = prepareEdge << 1;\n+            if (nodeB > nodeA)\n+                keyBwd += 1;\n+            return keyBwd;\n+        }\n+\n+        @Override\n+        public int getSkipped1() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public int getSkipped2() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public int getOrigEdgeCount() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public void setSkipped1(int skipped1) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void setSkipped2(int skipped2) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void setWeight(double weight) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void setOrigEdgeCount(int origEdgeCount) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return nodeA + \"-\" + nodeB + \" (\" + prepareEdge + \") \" + weightAB + \" \" + weightBA;\n+        }\n+    }\n+\n+    private static class PrepareShortcut implements PrepareEdge {\n+        private final int prepareEdge;\n+        private final int from;\n+        private final int to;\n+        private double weight;\n+        private int skipped1;\n+        private int skipped2;\n+        private int origEdgeCount;\n+\n+        private PrepareShortcut(int prepareEdge, int from, int to, double weight, int skipped1, int skipped2, int origEdgeCount) {\n+            this.prepareEdge = prepareEdge;\n+            this.from = from;\n+            this.to = to;\n+            assert Double.isFinite(weight);\n+            this.weight = weight;\n+            this.skipped1 = skipped1;\n+            this.skipped2 = skipped2;\n+            this.origEdgeCount = origEdgeCount;\n+        }\n+\n+        @Override\n+        public boolean isShortcut() {\n+            return true;\n+        }\n+\n+        @Override\n+        public int getPrepareEdge() {\n+            return prepareEdge;\n+        }\n+\n+        @Override\n+        public int getNodeA() {\n+            return from;\n+        }\n+\n+        @Override\n+        public int getNodeB() {\n+            return to;\n+        }\n+\n+        @Override\n+        public double getWeightAB() {\n+            return weight;\n+        }\n+\n+        @Override\n+        public double getWeightBA() {\n+            return weight;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstAB() {\n+            throw new IllegalStateException(\"Not supported for node-based shortcuts\");\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstBA() {\n+            throw new IllegalStateException(\"Not supported for node-based shortcuts\");\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastAB() {\n+            throw new IllegalStateException(\"Not supported for node-based shortcuts\");\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastBA() {\n+            throw new IllegalStateException(\"Not supported for node-based shortcuts\");\n+        }\n+\n+        @Override\n+        public int getSkipped1() {\n+            return skipped1;\n+        }\n+\n+        @Override\n+        public int getSkipped2() {\n+            return skipped2;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeCount() {\n+            return origEdgeCount;\n+        }\n+\n+        @Override\n+        public void setSkipped1(int skipped1) {\n+            this.skipped1 = skipped1;\n+        }\n+\n+        @Override\n+        public void setSkipped2(int skipped2) {\n+            this.skipped2 = skipped2;\n+        }\n+\n+        @Override\n+        public void setWeight(double weight) {\n+            this.weight = weight;\n+        }\n+\n+        @Override\n+        public void setOrigEdgeCount(int origEdgeCount) {\n+            this.origEdgeCount = origEdgeCount;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return from + \"-\" + to + \" \" + weight;\n+        }\n+    }\n+\n+    private static class EdgeBasedPrepareShortcut extends PrepareShortcut {\n+        // we use this subclass to save some memory for node-based where these are not needed\n+        private final int origEdgeKeyFirst;\n+        private final int origEdgeKeyLast;\n+\n+        public EdgeBasedPrepareShortcut(int prepareEdge, int from, int to, int origEdgeKeyFirst, int origEdgeKeyLast,\n+                                        double weight, int skipped1, int skipped2, int origEdgeCount) {\n+            super(prepareEdge, from, to, weight, skipped1, skipped2, origEdgeCount);\n+            this.origEdgeKeyFirst = origEdgeKeyFirst;\n+            this.origEdgeKeyLast = origEdgeKeyLast;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstAB() {\n+            return origEdgeKeyFirst;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstBA() {\n+            return origEdgeKeyFirst;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastAB() {\n+            return origEdgeKeyLast;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastBA() {\n+            return origEdgeKeyLast;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getNodeA() + \"-\" + getNodeB() + \" (\" + origEdgeKeyFirst + \", \" + origEdgeKeyLast + \") \" + getWeightAB();\n+        }\n+    }\n+\n+    private static class OrigGraph {\n+        private final IntArrayList firstEdgesByNode;\n+        private final IntArrayList adjNodes;\n+        private final IntArrayList edgesAndFlags;\n+\n+        private OrigGraph(IntArrayList firstEdgesByNode, IntArrayList adjNodes, IntArrayList edgesAndFlags) {\n+            this.firstEdgesByNode = firstEdgesByNode;\n+            this.adjNodes = adjNodes;\n+            this.edgesAndFlags = edgesAndFlags;\n+        }\n+\n+        PrepareGraphOrigEdgeExplorer createOutOrigEdgeExplorer() {\n+            return new OrigEdgeIteratorImpl(this, false);\n+        }\n+\n+        PrepareGraphOrigEdgeExplorer createInOrigEdgeExplorer() {\n+            return new OrigEdgeIteratorImpl(this, true);\n+        }\n+\n+        static class Builder {\n+            private final IntArrayList fromNodes = new IntArrayList();\n+            private final IntArrayList toNodes = new IntArrayList();\n+            private final IntArrayList edgesAndFlags = new IntArrayList();\n+            private int maxFrom = -1;\n+            private int maxTo = -1;\n+\n+            void addEdge(int from, int to, int edge, boolean fwd, boolean bwd) {\n+                fromNodes.add(from);\n+                toNodes.add(to);\n+                edgesAndFlags.add(getEdgeWithFlags(edge, fwd, bwd));\n+                maxFrom = Math.max(maxFrom, from);\n+                maxTo = Math.max(maxTo, to);\n+\n+                fromNodes.add(to);\n+                toNodes.add(from);\n+                edgesAndFlags.add(getEdgeWithFlags(edge, bwd, fwd));\n+                maxFrom = Math.max(maxFrom, to);\n+                maxTo = Math.max(maxTo, from);\n+            }\n+\n+            OrigGraph build() {\n+                int[] sortOrder = IndirectSort.mergesort(0, fromNodes.elementsCount, new IndirectComparator.AscendingIntComparator(fromNodes.buffer));\n+                sortAndTrim(fromNodes, sortOrder);\n+                sortAndTrim(toNodes, sortOrder);\n+                sortAndTrim(edgesAndFlags, sortOrder);\n+                return new OrigGraph(buildFirstEdgesByNode(), toNodes, edgesAndFlags);\n+            }\n+\n+            private int getEdgeWithFlags(int edge, boolean fwd, boolean bwd) {\n+                // we use only 30 bits for the edge Id and store two access flags along with the same int", "originalCommit": "47e9077efff7ffe7d38e5eee6806762a934bf490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUwNDk0OA==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489504948", "bodyText": "Oh good point, I almost forgot about this. But 30bits should be enough, because this is only for base graph edges. And if they exceeded 30bits the edge-based preparation would fail anyway, because there are more than twice as many shortcuts than base edges. This is only used for edge-based. Also it would be very easy to change this limit here (use another in, or dataaccess with byte[]..)", "author": "easbar", "createdAt": "2020-09-16T14:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5NTgwNg=="}], "type": "inlineReview"}, {"oid": "5a5cdd5fa36a0318db15afe18d714db4ead5ffca", "url": "https://github.com/graphhopper/graphhopper/commit/5a5cdd5fa36a0318db15afe18d714db4ead5ffca", "message": "Minor cleanup and docs", "committedDate": "2020-09-16T16:37:24Z", "type": "commit"}, {"oid": "a49d48944ad0825397c053c3bc77993b5f30b377", "url": "https://github.com/graphhopper/graphhopper/commit/a49d48944ad0825397c053c3bc77993b5f30b377", "message": "Update comment", "committedDate": "2020-09-16T16:46:26Z", "type": "commit"}, {"oid": "0edb0d8ae5f6c23e6774239ff47a9f5000a3a78d", "url": "https://github.com/graphhopper/graphhopper/commit/0edb0d8ae5f6c23e6774239ff47a9f5000a3a78d", "message": "Comment about u-turn costs", "committedDate": "2020-09-16T17:01:06Z", "type": "commit"}, {"oid": "453d09896e7e81c64ce4078668ba4afe70611747", "url": "https://github.com/graphhopper/graphhopper/commit/453d09896e7e81c64ce4078668ba4afe70611747", "message": "Remove todos", "committedDate": "2020-09-16T17:12:35Z", "type": "commit"}, {"oid": "31bd5ca6fcabd5fff02771dd530143f5fcced4be", "url": "https://github.com/graphhopper/graphhopper/commit/31bd5ca6fcabd5fff02771dd530143f5fcced4be", "message": "Enable check for equal weight witness path again", "committedDate": "2020-09-16T17:13:24Z", "type": "commit"}, {"oid": "4990f7324a69a12d59baab41e66a40147983b0ad", "url": "https://github.com/graphhopper/graphhopper/commit/4990f7324a69a12d59baab41e66a40147983b0ad", "message": "Remove outdated comment", "committedDate": "2020-09-16T17:19:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5NzA5Mw==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489597093", "bodyText": "Thes orig edge counts are now included in the prepare graph's edges", "author": "easbar", "createdAt": "2020-09-16T17:16:30Z", "path": "core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java", "diffHunk": "@@ -1,81 +0,0 @@\n-/*\n- *  Licensed to GraphHopper GmbH under one or more contributor\n- *  license agreements. See the NOTICE file distributed with this work for\n- *  additional information regarding copyright ownership.\n- *\n- *  GraphHopper GmbH licenses this file to you under the Apache License,\n- *  Version 2.0 (the \"License\"); you may not use this file except in\n- *  compliance with the License. You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-\n-package com.graphhopper.routing.ch;\n-\n-import com.graphhopper.storage.DAType;\n-import com.graphhopper.storage.DataAccess;\n-import com.graphhopper.storage.GHDirectory;\n-\n-abstract class AbstractNodeContractor implements NodeContractor {\n-    final PrepareCHGraph prepareGraph;\n-    PrepareCHEdgeExplorer inEdgeExplorer;\n-    PrepareCHEdgeExplorer outEdgeExplorer;\n-    private final DataAccess originalEdges;\n-    int maxLevel;\n-    private int maxEdgesCount;\n-\n-    public AbstractNodeContractor(PrepareCHGraph prepareGraph) {\n-        this.prepareGraph = prepareGraph;\n-        originalEdges = new GHDirectory(\"\", DAType.RAM_INT).find(\"\");\n-        originalEdges.create(1000);\n-    }\n-\n-    @Override\n-    public void initFromGraph() {\n-        inEdgeExplorer = prepareGraph.createInEdgeExplorer();\n-        outEdgeExplorer = prepareGraph.createOutEdgeExplorer();\n-        maxLevel = prepareGraph.getNodes();\n-        maxEdgesCount = prepareGraph.getOriginalEdges();\n-    }\n-\n-    @Override\n-    public void close() {\n-        originalEdges.close();\n-    }\n-\n-    boolean isContracted(int node) {\n-        return prepareGraph.getLevel(node) != maxLevel;\n-    }\n-\n-    void setOrigEdgeCount(int edgeId, int value) {", "originalCommit": "453d09896e7e81c64ce4078668ba4afe70611747", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5NzM1OQ==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489597359", "bodyText": "I removed this heuristic for now, might be worth to re-implement it later, but not sure really", "author": "easbar", "createdAt": "2020-09-16T17:16:58Z", "path": "core/src/main/java/com/graphhopper/routing/ch/CHParameters.java", "diffHunk": "@@ -12,7 +12,6 @@\n     // node contraction, node-based\n     public static final String EDGE_DIFFERENCE_WEIGHT = Parameters.CH.PREPARE + \"node.edge_difference_weight\";\n     public static final String ORIGINAL_EDGE_COUNT_WEIGHT = Parameters.CH.PREPARE + \"node.original_edge_count_weight\";\n-    public static final String CONTRACTED_NEIGHBORS_WEIGHT = Parameters.CH.PREPARE + \"node.contracted_neighbors_weight\";", "originalCommit": "453d09896e7e81c64ce4078668ba4afe70611747", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwMTE1MA==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489601150", "bodyText": "Here we got rid of one of the int[] arrays, i.e. 4byte*N where N=2*number of base graph edges. We no longer need to store the incEdges, because we use the edge keys directly now and the index position equals the edge key for each element.", "author": "easbar", "createdAt": "2020-09-16T17:23:31Z", "path": "core/src/main/java/com/graphhopper/routing/ch/EdgeBasedWitnessPathSearcher.java", "diffHunk": "@@ -87,12 +85,11 @@\n     // data structures used to build the shortest path tree\n     // we allocate memory for all possible edge keys and keep track which ones have been discovered so far\n     private double[] weights;\n-    private int[] edges;\n-    private int[] incEdges;\n+    private int[] prepareEdges;", "originalCommit": "453d09896e7e81c64ce4078668ba4afe70611747", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwMzk0NA==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489603944", "bodyText": "No need for these two arrays as we never need to find the actual shortest path (we just need to check its existence). This saved 2*4byte*N where N=number of nodes of the graph", "author": "easbar", "createdAt": "2020-09-16T17:28:29Z", "path": "core/src/main/java/com/graphhopper/routing/ch/NodeBasedWitnessPathSearcher.java", "diffHunk": "@@ -30,41 +29,25 @@\n  * i.e. its a Dijkstra search that allows re-using the shortest path tree for different searches with the same origin\n  * node and uses large int/double arrays instead of hash maps to store the shortest path tree (higher memory consumption,\n  * but faster query times -> better for CH preparation). Main reason we use this instead of {@link DijkstraOneToMany}\n- * is that we can use this implementation with a {@link PrepareCHGraph}.\n+ * is that we can use this implementation with a {@link CHPreparationGraph} and we are only interested in checking for\n+ * witness paths (e.g. we do not need to find the actual path).\n  */\n public class NodeBasedWitnessPathSearcher {\n-    private static final int EMPTY_PARENT = -1;\n     private static final int NOT_FOUND = -1;\n-    private final PrepareCHGraph graph;\n-    private final PrepareCHEdgeExplorer outEdgeExplorer;\n+    private PrepareGraphEdgeExplorer outEdgeExplorer;\n     private final IntArrayList changedNodes;\n-    private final int maxLevel;\n     private int maxVisitedNodes = Integer.MAX_VALUE;\n     protected double[] weights;\n-    private int[] parents;\n-    private int[] edgeIds;", "originalCommit": "453d09896e7e81c64ce4078668ba4afe70611747", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwNDk3MA==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489604970", "bodyText": "Here we were allocating quite a bit of memory even when re-starting the server and just loading the preparations (no new preparation). We should really make PrepareContractionHierarchies about preparing CH and not use it as a 'handle' to the preparations available on the server...", "author": "easbar", "createdAt": "2020-09-16T17:30:16Z", "path": "core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java", "diffHunk": "@@ -77,22 +76,18 @@ public static PrepareContractionHierarchies fromGraphHopperStorage(GraphHopperSt\n     }\n \n     private PrepareContractionHierarchies(GraphHopperStorage ghStorage, CHConfig chConfig) {\n+        graph = ghStorage;\n         chGraph = ghStorage.getCHGraph(chConfig.getName());\n         if (chGraph == null)\n             throw new IllegalArgumentException(\"There is no CH graph '\" + chConfig.getName() + \"', existing: \" + ghStorage.getCHGraphNames());\n         this.chConfig = chConfig;\n         params = Params.forTraversalMode(chConfig.getTraversalMode());\n-        updatedNeighbors = new IntHashSet(50);\n+        nodes = chGraph.getNodes();\n         if (chConfig.getTraversalMode().isEdgeBased()) {\n             TurnCostStorage turnCostStorage = chGraph.getBaseGraph().getTurnCostStorage();\n             if (turnCostStorage == null) {\n                 throw new IllegalArgumentException(\"For edge-based CH you need a turn cost storage\");\n             }\n-            prepareGraph = PrepareCHGraph.edgeBased(chGraph, chConfig.getWeighting());\n-            nodeContractor = new EdgeBasedNodeContractor(prepareGraph, pMap);\n-        } else {\n-            prepareGraph = PrepareCHGraph.nodeBased(chGraph, chConfig.getWeighting());\n-            nodeContractor = new NodeBasedNodeContractor(prepareGraph, pMap);", "originalCommit": "453d09896e7e81c64ce4078668ba4afe70611747", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwNTcyNg==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489605726", "bodyText": "This is no longer needed because after we wrote a shortcut to CHGraph we never change it again", "author": "easbar", "createdAt": "2020-09-16T17:31:39Z", "path": "core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java", "diffHunk": "@@ -32,46 +32,21 @@\n     /**\n      * A bitmask for two directions\n      */\n-    public static final int getScDirMask() {\n+    public static int getScDirMask() {\n         return scDirMask;\n     }\n \n     /**\n      * The bit for forward direction\n      */\n-    public static final int getScFwdDir() {\n+    public static int getScFwdDir() {\n         return scFwdDir;\n     }\n \n     /**\n      * The bit for backward direction\n      */\n-    public static final int getScBwdDir() {\n+    public static int getScBwdDir() {\n         return scBwdDir;\n     }\n-\n-    /**\n-     * Returns 1 if existingScFlags of an existing shortcut can be overwritten with a new shortcut by\n-     * newScFlags without limiting or changing the directions of the existing shortcut.\n-     * The method returns 2 for the same condition but only if the new shortcut has to be added\n-     * even if weight is higher than existing shortcut weight.\n-     * <pre>\n-     *                 | newScFlags:\n-     * existingScFlags | -> | <- | <->\n-     * ->              |  1 | 0  | 2\n-     * <-              |  0 | 1  | 2\n-     * <->             |  0 | 0  | 1\n-     * </pre>\n-     *\n-     * @return 1 if newScFlags is identical to existingScFlags for the two direction bits and 0 otherwise.\n-     * There are two special cases when it returns 2.\n-     */\n-    public static final int getScMergeStatus(int existingScFlags, int newScFlags) {\n-        if ((existingScFlags & scDirMask) == (newScFlags & scDirMask))\n-            return 1;\n-        else if ((newScFlags & scDirMask) == scDirMask)\n-            return 2;\n-\n-        return 0;\n-    }", "originalCommit": "453d09896e7e81c64ce4078668ba4afe70611747", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwNjQ1Mw==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489606453", "bodyText": "Any idea for a better name? I am trying to say this is an array of arrays (2D) where each of the inner arrays is split into two parts (the elements of the two parts are separated from each other). But maybe not so important as this is only a package private class used by CHPreparationGraph...", "author": "easbar", "createdAt": "2020-09-16T17:32:58Z", "path": "core/src/main/java/com/graphhopper/routing/ch/SplitArray2D.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.ch;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * This is a more memory-efficient version of two equal length `ArrayList<T>[]`s, i.e. this is a fixed size array where\n+ * each element is a variable sized sub-array and each sub-array is divided into two parts.\n+ * This is more memory efficient than two arrays of `ArrayList`s, because it saves the object-overhead of using an\n+ * ArrayList object for each sub-array.\n+ * <p>\n+ * The elements in each sub-array are divided into two parts with ranges [0,mid[ and [mid,size[. We can add elements\n+ * to either of the two parts.\n+ */\n+class SplitArray2D<T> {", "originalCommit": "453d09896e7e81c64ce4078668ba4afe70611747", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8a9c5599d8fad5e67e995c5295ad0600d6a28842", "url": "https://github.com/graphhopper/graphhopper/commit/8a9c5599d8fad5e67e995c5295ad0600d6a28842", "message": "Loop shortcuts only as out edges", "committedDate": "2020-09-16T19:41:21Z", "type": "commit"}, {"oid": "dbcf9eec0b107925891e7f8e1c43cef48a33405b", "url": "https://github.com/graphhopper/graphhopper/commit/dbcf9eec0b107925891e7f8e1c43cef48a33405b", "message": "Combine adjNode and isPathToCenters arrays -> reduce memory usage for edge-based CH", "committedDate": "2020-09-17T17:26:48Z", "type": "commit"}, {"oid": "6c3f2399bbf6cba7bb540be470ababdc76c0f090", "url": "https://github.com/graphhopper/graphhopper/commit/6c3f2399bbf6cba7bb540be470ababdc76c0f090", "message": "Update comment", "committedDate": "2020-09-21T07:18:57Z", "type": "commit"}, {"oid": "4cfa7fc9d1ddf18cb6e3f0974169a3c2c8d555c2", "url": "https://github.com/graphhopper/graphhopper/commit/4cfa7fc9d1ddf18cb6e3f0974169a3c2c8d555c2", "message": "Remove unused and suspicious GTFS route type constants\n\n(cherry picked from commit d48a941d60f028f7c5f8f4bf530abab169e988f8)", "committedDate": "2020-09-21T07:19:41Z", "type": "commit"}, {"oid": "243e63765bd1c6a6f72bf0c1ad59a4c5aa349fff", "url": "https://github.com/graphhopper/graphhopper/commit/243e63765bd1c6a6f72bf0c1ad59a4c5aa349fff", "message": "Public datatype is public\n\n(cherry picked from commit c0aaffae8631efb8fa23c6ab5cf26e27027efd08)", "committedDate": "2020-09-21T07:19:44Z", "type": "commit"}, {"oid": "8cffac27daad830ca8785099c0ba8d6b34dc9799", "url": "https://github.com/graphhopper/graphhopper/commit/8cffac27daad830ca8785099c0ba8d6b34dc9799", "message": "Define how many decimal places isochrone coordinates have\n\n(cherry picked from commit 0e9461e6de94d491f2118fca20ca903f631e7288)", "committedDate": "2020-09-21T07:19:47Z", "type": "commit"}, {"oid": "1a92096a1dcabb6c0e126fb42e9b1210e6cb7bed", "url": "https://github.com/graphhopper/graphhopper/commit/1a92096a1dcabb6c0e126fb42e9b1210e6cb7bed", "message": "Merge branch 'master' into faster_ch_prep", "committedDate": "2020-09-21T07:43:02Z", "type": "commit"}, {"oid": "1c2ca0f9c421ff36b645c31fc2d66852717911cd", "url": "https://github.com/graphhopper/graphhopper/commit/1c2ca0f9c421ff36b645c31fc2d66852717911cd", "message": "Trim split 2d array", "committedDate": "2020-09-21T15:33:33Z", "type": "commit"}, {"oid": "c0198a6c09b3d447506ce49d8cce2b52b2fdc07d", "url": "https://github.com/graphhopper/graphhopper/commit/c0198a6c09b3d447506ce49d8cce2b52b2fdc07d", "message": "Extract method to grow 2d array", "committedDate": "2020-09-21T15:36:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0MDIzMA==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r492540230", "bodyText": "How large are these sub-arrays on average? Could it make sense to initialize them with the average+20% then they do not need to grow that often and the size mismatch could be lower?", "author": "karussell", "createdAt": "2020-09-22T07:56:07Z", "path": "core/src/main/java/com/graphhopper/routing/ch/SplitArray2D.java", "diffHunk": "@@ -122,4 +122,17 @@ void clear(int n) {\n         mids[n] = 0;\n     }\n \n+    private void grow(int n) {\n+        // todo: think about grow factor: trimming and then doubling the size might be not what we want, rather\n+        // increase by 50% or something?", "originalCommit": "c0198a6c09b3d447506ce49d8cce2b52b2fdc07d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0NDk0Mw==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r492544943", "bodyText": "Good question. In this commit: 1c2ca0f I trimmed the arrays after the prepare graph is built for the first time to save some memory at the beginning of the contraction. For maximum speed it would of course be better to initialize them with some expected size (but no idea so far how important this is). I am currently running the import with this trimming to compare to the version without the trimming.", "author": "easbar", "createdAt": "2020-09-22T08:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0MDIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0MDAyOQ==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r492640029", "bodyText": "I did a quick check for Bayern (~6mio shortcuts) and Germany (~28mio shortcuts) and the array sizes seem to be relatively stable against changes of the map size. Before the contraction the average 'size' (not length) of the arrays (number of in+out edges) is around 4.5 (makes sense: 2.25 in/out edges per node) and average mids[n] is almost exactly half of sizes[n] (on average the number of in edges is the same as out edges -> makes sense).\nThe maximum size during the contraction is about 100 and the maximum mid is around 50 for both maps.\nSo I think its already safe to say that we can store mid/size in a single int to save some (not a lot) memory (around 900MB for planet). For the resizing strategy I think it probably does not really matter, because the arrays never get very large and maybe its even the best approach to trim them as I do currently to make sure memory is minimized.\nIn my opinion if we change anything here we should try linking the edge objects to each other and remove the sub-arrays entirely, but I would postpone this until we feel like its definitely needed (and we are sure it improves anything).", "author": "easbar", "createdAt": "2020-09-22T10:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0MDIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY2OTY0MA==", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r492669640", "bodyText": "to trim them as I do currently to make sure memory is minimized.\n\nYes, this sounds reasonable", "author": "karussell", "createdAt": "2020-09-22T11:47:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0MDIzMA=="}], "type": "inlineReview"}, {"oid": "5a60be242885bda4064e9f5261985a9ff24057b7", "url": "https://github.com/graphhopper/graphhopper/commit/5a60be242885bda4064e9f5261985a9ff24057b7", "message": "Update changelog", "committedDate": "2020-09-22T11:53:28Z", "type": "commit"}]}