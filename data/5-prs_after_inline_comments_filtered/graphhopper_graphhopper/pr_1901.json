{"pr_number": 1901, "pr_title": "Extract GraphHopperRouter from GraphHopper", "pr_createdAt": "2020-02-12T08:57:29Z", "pr_url": "https://github.com/graphhopper/graphhopper/pull/1901", "timeline": [{"oid": "2020d3c3f21378f8593bcb83cc6de2210400fb6f", "url": "https://github.com/graphhopper/graphhopper/commit/2020d3c3f21378f8593bcb83cc6de2210400fb6f", "message": "Extract GraphHopperRouter from GraphHopper", "committedDate": "2020-02-12T08:53:12Z", "type": "commit"}, {"oid": "92b076f24fa53c1cfaf533e6ef30c4a4e7cab372", "url": "https://github.com/graphhopper/graphhopper/commit/92b076f24fa53c1cfaf533e6ef30c4a4e7cab372", "message": "Merge branch 'master' into gh_router\n\n# Conflicts:\n#\tcore/src/main/java/com/graphhopper/GraphHopper.java", "committedDate": "2020-02-19T06:41:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMDk2NA==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r383030964", "bodyText": "Maybe we get rid of the change graph endpoint and its lock mechnism for now to reduce complexity?\nMy plan was also for #1280 to reduce the number of possibilities to modify the base graph and it seems that spatial rules can replace change graph endpoint (in combination with CustomWeighting for the dynamic case).", "author": "karussell", "createdAt": "2020-02-23T19:21:23Z", "path": "core/src/main/java/com/graphhopper/routing/GraphHopperRouter.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.GHRequest;\n+import com.graphhopper.GHResponse;\n+import com.graphhopper.routing.ch.CHPreparationHandler;\n+import com.graphhopper.routing.ch.CHProfileSelectionException;\n+import com.graphhopper.routing.ch.CHProfileSelector;\n+import com.graphhopper.routing.ch.CHRoutingAlgorithmFactory;\n+import com.graphhopper.routing.lm.LMPreparationHandler;\n+import com.graphhopper.routing.querygraph.QueryGraph;\n+import com.graphhopper.routing.template.AlternativeRoutingTemplate;\n+import com.graphhopper.routing.template.RoundTripRoutingTemplate;\n+import com.graphhopper.routing.template.RoutingTemplate;\n+import com.graphhopper.routing.template.ViaRoutingTemplate;\n+import com.graphhopper.routing.util.*;\n+import com.graphhopper.routing.weighting.*;\n+import com.graphhopper.storage.CHProfile;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.storage.GraphEdgeIdFinder;\n+import com.graphhopper.storage.GraphHopperStorage;\n+import com.graphhopper.storage.index.LocationIndex;\n+import com.graphhopper.storage.index.QueryResult;\n+import com.graphhopper.util.*;\n+import com.graphhopper.util.details.PathDetailsBuilderFactory;\n+import com.graphhopper.util.exceptions.PointDistanceExceededException;\n+import com.graphhopper.util.exceptions.PointOutOfBoundsException;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.GHPoint;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.graphhopper.routing.weighting.TurnCostProvider.NO_TURN_COST_PROVIDER;\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+import static com.graphhopper.util.Helper.DIST_3D;\n+import static com.graphhopper.util.Parameters.Algorithms.*;\n+import static com.graphhopper.util.Parameters.Routing.CURBSIDE;\n+\n+public class GraphHopperRouter {\n+    private final EncodingManager encodingManager;\n+    private final GraphHopperStorage ghStorage;\n+    private final LocationIndex locationIndex;\n+    private final LMPreparationHandler lmPreparationHandler;\n+    private final List<CHProfile> chProfiles;\n+    // todonow: too costly to import all the time, do static init or pass via constructor?\n+    private TranslationMap trMap = new TranslationMap().doImport();\n+    private RoutingConfig routingConfig;\n+    private WeightingFactory weightingFactory = new DefaultWeightingFactory();\n+    private PathDetailsBuilderFactory pathBuilderFactory = new PathDetailsBuilderFactory();\n+    private boolean chDisablingAllowed;\n+    private boolean lmDisablingAllowed;\n+    private boolean chEnabled;\n+    private boolean lmEnabled;\n+\n+    public GraphHopperRouter(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n+                             // todonow: remove these dependencies\n+                             LMPreparationHandler lmPreparationHandler, CHPreparationHandler chPreparationHandler,\n+                             RoutingConfig routingConfig) {\n+        if (ghStorage.isClosed())\n+            throw new IllegalStateException(\"GH storage should not be closed\");\n+\n+        this.ghStorage = ghStorage;\n+        this.chProfiles = ghStorage.getCHProfiles();\n+        this.encodingManager = ghStorage.getEncodingManager();\n+        this.locationIndex = locationIndex;\n+        this.lmPreparationHandler = lmPreparationHandler;\n+        this.routingConfig = routingConfig;\n+        // todonow: maybe simply add setters for ch/lm enabled -> no need for lm/ch prep handlers here anymore\n+        chEnabled = chPreparationHandler.isEnabled();\n+        lmEnabled = lmPreparationHandler.isEnabled();\n+        // todonow: maybe these could go into routing config -> no need for lm/ch prep handlers here anymore\n+        chDisablingAllowed = chPreparationHandler.isDisablingAllowed();\n+        lmDisablingAllowed = lmPreparationHandler.isDisablingAllowed();\n+    }\n+\n+    // todonow: these setters are not thread-safe, do we care? maybe use builder pattern instead? or just volatile?\n+    // at least document thread safety of this class, also there is lock mechanism in GraphHopper but what if this class\n+    // is used standalone?", "originalCommit": "92b076f24fa53c1cfaf533e6ef30c4a4e7cab372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4ODgwOA==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r383788808", "bodyText": "Sure getting rid of this lock mechanism would certainly make things a bit simpler... Modifying the base graph seems very complex to me anyway, for example we do not update the landmarks or ch graphs after modifying the base graph and doing this per request would be very expensive anyway?", "author": "easbar", "createdAt": "2020-02-25T10:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMDk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMzk2Mw==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r383813963", "bodyText": "Yes, the change graph endpoint was supposed to do only smaller changes and increases the weight only so that it would work with LM at least, but yeah, it is not really battle tested and probably also not used.", "author": "karussell", "createdAt": "2020-02-25T11:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMDk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2MjE2NQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r384062165", "bodyText": "So we remove it for 1.0?", "author": "easbar", "createdAt": "2020-02-25T19:00:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMDk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5OTA5NA==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r384099094", "bodyText": "Ok, #1931", "author": "karussell", "createdAt": "2020-02-25T20:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMDk2NA=="}], "type": "inlineReview"}, {"oid": "87b02f802c87328a8cd22c834d0f1336a8830f4c", "url": "https://github.com/graphhopper/graphhopper/commit/87b02f802c87328a8cd22c834d0f1336a8830f4c", "message": "minor", "committedDate": "2020-05-13T17:48:56Z", "type": "commit"}, {"oid": "1c3d53c888f7f3fe48413f0f125179ba0c84efb1", "url": "https://github.com/graphhopper/graphhopper/commit/1c3d53c888f7f3fe48413f0f125179ba0c84efb1", "message": "Reset to current master", "committedDate": "2020-05-27T13:27:22Z", "type": "commit"}, {"oid": "b9709b766a8905ae244100cf30d44a5db46af881", "url": "https://github.com/graphhopper/graphhopper/commit/b9709b766a8905ae244100cf30d44a5db46af881", "message": "Merge branch 'master' into gh_router\n\n# Conflicts:\n#\tcore/src/main/resources/com/graphhopper/util/zh_TW.txt", "committedDate": "2020-05-27T13:27:57Z", "type": "commit"}, {"oid": "4f39a5fa8cda8519d170374a3bd40b887d19c1d2", "url": "https://github.com/graphhopper/graphhopper/commit/4f39a5fa8cda8519d170374a3bd40b887d19c1d2", "message": "Merge branch 'master' into gh_router", "committedDate": "2020-05-27T13:33:36Z", "type": "commit"}, {"oid": "5b837ae776b44d26c5d341a5ab6a64942b789e39", "url": "https://github.com/graphhopper/graphhopper/commit/5b837ae776b44d26c5d341a5ab6a64942b789e39", "message": "Extract GraphHopperRouter from GraphHopper", "committedDate": "2020-05-27T13:33:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE0MzE0OA==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431143148", "bodyText": "I basically took this code and put it into a new class...", "author": "easbar", "createdAt": "2020-05-27T13:46:10Z", "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -1036,211 +1001,20 @@ public GHResponse route(GHRequest request) {\n      * This method calculates the alternative path list using the low level Path objects.\n      */\n     public List<Path> calcPaths(GHRequest request, GHResponse ghRsp) {\n+        return createGraphHopperRouter().route(request, ghRsp);", "originalCommit": "5b837ae776b44d26c5d341a5ab6a64942b789e39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE0NDE3Nw==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431144177", "bodyText": "Similar to GraphHopper these PreparationHandlers are concerned with both the 'import' and the 'algorithm creation' (when routing), but they are mostly about preparation and I definitely want to get rid of them here. -> They are gone now :)", "author": "easbar", "createdAt": "2020-05-27T13:47:33Z", "path": "core/src/main/java/com/graphhopper/routing/GraphHopperRouter.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.GHRequest;\n+import com.graphhopper.GHResponse;\n+import com.graphhopper.config.LMProfile;\n+import com.graphhopper.config.Profile;\n+import com.graphhopper.routing.ch.CHPreparationHandler;\n+import com.graphhopper.routing.ch.CHRoutingAlgorithmFactory;\n+import com.graphhopper.routing.lm.LMPreparationHandler;\n+import com.graphhopper.routing.querygraph.QueryGraph;\n+import com.graphhopper.routing.template.AlternativeRoutingTemplate;\n+import com.graphhopper.routing.template.RoundTripRoutingTemplate;\n+import com.graphhopper.routing.template.RoutingTemplate;\n+import com.graphhopper.routing.template.ViaRoutingTemplate;\n+import com.graphhopper.routing.util.DefaultEdgeFilter;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.util.TraversalMode;\n+import com.graphhopper.routing.weighting.BlockAreaWeighting;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.CHConfig;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.storage.GraphEdgeIdFinder;\n+import com.graphhopper.storage.GraphHopperStorage;\n+import com.graphhopper.storage.index.LocationIndex;\n+import com.graphhopper.storage.index.QueryResult;\n+import com.graphhopper.util.*;\n+import com.graphhopper.util.details.PathDetailsBuilderFactory;\n+import com.graphhopper.util.exceptions.PointDistanceExceededException;\n+import com.graphhopper.util.exceptions.PointOutOfBoundsException;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.GHPoint;\n+\n+import java.util.*;\n+\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+import static com.graphhopper.util.Helper.DIST_EARTH;\n+import static com.graphhopper.util.Parameters.Algorithms.*;\n+import static com.graphhopper.util.Parameters.Routing.CURBSIDE;\n+import static com.graphhopper.util.Parameters.Routing.POINT_HINT;\n+\n+public class GraphHopperRouter {\n+    private final GraphHopperStorage ghStorage;\n+    private final EncodingManager encodingManager;\n+    private final LocationIndex locationIndex;\n+    private final Map<String, Profile> profilesByName;\n+    private final PathDetailsBuilderFactory pathDetailsBuilderFactory;\n+    private final TranslationMap translationMap;\n+    private final RoutingConfig routingConfig;\n+    private final WeightingFactory weightingFactory;\n+    private final CHPreparationHandler chPreparationHandler;\n+    private final LMPreparationHandler lmPreparationHandler;", "originalCommit": "5b837ae776b44d26c5d341a5ab6a64942b789e39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3ca49449157d88e9fb1c957cd83e1fe7b1670d05", "url": "https://github.com/graphhopper/graphhopper/commit/3ca49449157d88e9fb1c957cd83e1fe7b1670d05", "message": "revert file", "committedDate": "2020-05-27T13:55:50Z", "type": "commit"}, {"oid": "5cdc500db4eae6d1cb648b7cda6e438b789b2f72", "url": "https://github.com/graphhopper/graphhopper/commit/5cdc500db4eae6d1cb648b7cda6e438b789b2f72", "message": "Replace some method calls: ghStorage.getCHGraph(CHConfig) -> ghStorage.getCHGraph(String)", "committedDate": "2020-05-27T21:31:07Z", "type": "commit"}, {"oid": "ea1edbbf9331dbbaa224fdfb3f40a923b8da43f2", "url": "https://github.com/graphhopper/graphhopper/commit/ea1edbbf9331dbbaa224fdfb3f40a923b8da43f2", "message": "Remove exception from GraphHopperStorage#getCHGraph(String)", "committedDate": "2020-05-27T21:36:43Z", "type": "commit"}, {"oid": "fb469bfdc593f415578bf5bf4268b3747b742428", "url": "https://github.com/graphhopper/graphhopper/commit/fb469bfdc593f415578bf5bf4268b3747b742428", "message": "Remove CHPreparationHandler field from GraphHopperRouter", "committedDate": "2020-05-27T21:38:41Z", "type": "commit"}, {"oid": "7ae75366b9d533ff7fe80c609e3d1fb197a35cc3", "url": "https://github.com/graphhopper/graphhopper/commit/7ae75366b9d533ff7fe80c609e3d1fb197a35cc3", "message": "Remove LMPreparationHandler field from GraphHopperRouter", "committedDate": "2020-05-27T22:01:42Z", "type": "commit"}, {"oid": "fc160916e8eb2f880d330884ae5240b2b14785a6", "url": "https://github.com/graphhopper/graphhopper/commit/fc160916e8eb2f880d330884ae5240b2b14785a6", "message": "Move CH/LMDisablingAllowed flags into RoutingConfig, remove CH/LMPreparationHandler dependencies from GHRouter", "committedDate": "2020-05-28T07:53:11Z", "type": "commit"}, {"oid": "abf09ce91647bf4df2b5407879c57567f8893bd2", "url": "https://github.com/graphhopper/graphhopper/commit/abf09ce91647bf4df2b5407879c57567f8893bd2", "message": "Remove setters for routing config properties from GraphHopper, add getRoutingConfig instead", "committedDate": "2020-05-28T08:03:28Z", "type": "commit"}, {"oid": "ac573ae3ccb91f24b61fec8a2b2faa62621b3c56", "url": "https://github.com/graphhopper/graphhopper/commit/ac573ae3ccb91f24b61fec8a2b2faa62621b3c56", "message": "Remove GraphHopper#getAlgorithmFactory", "committedDate": "2020-05-28T08:15:43Z", "type": "commit"}, {"oid": "2f0cfb48202ab7edb136a9567a8e963eebcaba9c", "url": "https://github.com/graphhopper/graphhopper/commit/2f0cfb48202ab7edb136a9567a8e963eebcaba9c", "message": "Add javadoc", "committedDate": "2020-05-28T08:22:44Z", "type": "commit"}, {"oid": "d805e7c46af06f5edfa97dd564b42435207928d8", "url": "https://github.com/graphhopper/graphhopper/commit/d805e7c46af06f5edfa97dd564b42435207928d8", "message": "Use EncodingManager from GraphHopperStorage", "committedDate": "2020-05-28T08:30:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY3MDE3Ng==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431670176", "bodyText": "Should we rename this to RouterConfig, because it configures the behavior of GraphHopperRouter? -> Update: Renamed both here: 8ba19ce", "author": "easbar", "createdAt": "2020-05-28T08:32:34Z", "path": "core/src/main/java/com/graphhopper/routing/RoutingConfig.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+/**\n+ * This class contains various parameters that control the behavior of {@link GraphHopperRouter}.\n+ */\n+public class RoutingConfig {", "originalCommit": "d805e7c46af06f5edfa97dd564b42435207928d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY3MDcyMw==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431670723", "bodyText": "See my comment about the GraphHopperRouter constructor.", "author": "easbar", "createdAt": "2020-05-28T08:33:30Z", "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -1036,211 +974,33 @@ public GHResponse route(GHRequest request) {\n      * This method calculates the alternative path list using the low level Path objects.\n      */\n     public List<Path> calcPaths(GHRequest request, GHResponse ghRsp) {\n+        return createGraphHopperRouter().route(request, ghRsp);\n+    }\n+\n+    private GraphHopperRouter createGraphHopperRouter() {\n         if (ghStorage == null || !fullyLoaded)\n             throw new IllegalStateException(\"Do a successful call to load or importOrLoad before routing\");\n-\n         if (ghStorage.isClosed())\n             throw new IllegalStateException(\"You need to create a new GraphHopper instance as it is already closed\");\n-\n         if (locationIndex == null)\n             throw new IllegalStateException(\"Location index not initialized\");\n \n-        try {\n-            validateRequest(request);\n-            final boolean disableCH = getDisableCH(request.getHints());\n-            final boolean disableLM = getDisableLM(request.getHints());\n-            Profile profile = profilesByName.get(request.getProfile());\n-            if (profile == null)\n-                throw new IllegalArgumentException(\"The requested profile '\" + request.getProfile() + \"' does not exist.\\nAvailable profiles: \" + profilesByName.keySet());\n-            if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n-                throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n-                        \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n-            // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chPreparationHandler.isEnabled() && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = ghStorage.getCHGraph(chConfig);\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \"supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = createWeighting(profile, request.getHints());\n-                if (request.getHints().has(Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n-            }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            String algoStr = request.getAlgorithm();\n-            if (algoStr.isEmpty())\n-                algoStr = chPreparationHandler.isEnabled() && !disableCH ? DIJKSTRA_BI : ASTAR_BI;\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, algoStr, weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n-            int maxVisitedNodesForRequest = request.getHints().getInt(Routing.MAX_VISITED_NODES, routingConfig.getMaxVisitedNodes());\n-            if (maxVisitedNodesForRequest > routingConfig.getMaxVisitedNodes())\n-                throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routingConfig.getMaxVisitedNodes());\n-\n-            AlgorithmOptions algoOpts = AlgorithmOptions.start().\n-                    algorithm(algoStr).\n-                    traversalMode(tMode).\n-                    weighting(weighting).\n-                    maxVisitedNodes(maxVisitedNodesForRequest).\n-                    hints(request.getHints()).\n-                    build();\n-\n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Routing.CALC_POINTS, routingConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routingConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, trMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n-        } catch (IllegalArgumentException ex) {\n-            ghRsp.addError(ex);\n-            return Collections.emptyList();\n-        }\n-    }\n-\n-    private List<String> getTurnCostProfiles() {\n-        List<String> turnCostProfiles = new ArrayList<>();\n-        for (Profile p : profilesByName.values()) {\n-            if (p.isTurnCosts()) {\n-                turnCostProfiles.add(p.getName());\n-            }\n+        Map<String, CHGraph> chGraphs = new LinkedHashMap<>();\n+        for (CHProfile chProfile : chPreparationHandler.getCHProfiles()) {\n+            String chGraphName = chPreparationHandler.getPreparation(chProfile.getProfile()).getCHConfig().getName();\n+            chGraphs.put(chProfile.getProfile(), ghStorage.getCHGraph(chGraphName));", "originalCommit": "d805e7c46af06f5edfa97dd564b42435207928d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY3MTYzNA==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431671634", "bodyText": "GraphHopperRouter needs a way to obtain the CH/LM helper structures for a given profile. Once we have it, some kind of 'graph-database' could replace this, but for now I am simply using these maps.", "author": "easbar", "createdAt": "2020-05-28T08:35:02Z", "path": "core/src/main/java/com/graphhopper/routing/GraphHopperRouter.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.GHRequest;\n+import com.graphhopper.GHResponse;\n+import com.graphhopper.config.Profile;\n+import com.graphhopper.routing.ch.CHRoutingAlgorithmFactory;\n+import com.graphhopper.routing.lm.LMRoutingAlgorithmFactory;\n+import com.graphhopper.routing.lm.LandmarkStorage;\n+import com.graphhopper.routing.querygraph.QueryGraph;\n+import com.graphhopper.routing.template.AlternativeRoutingTemplate;\n+import com.graphhopper.routing.template.RoundTripRoutingTemplate;\n+import com.graphhopper.routing.template.RoutingTemplate;\n+import com.graphhopper.routing.template.ViaRoutingTemplate;\n+import com.graphhopper.routing.util.DefaultEdgeFilter;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.util.TraversalMode;\n+import com.graphhopper.routing.weighting.BlockAreaWeighting;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.*;\n+import com.graphhopper.storage.index.LocationIndex;\n+import com.graphhopper.storage.index.QueryResult;\n+import com.graphhopper.util.*;\n+import com.graphhopper.util.details.PathDetailsBuilderFactory;\n+import com.graphhopper.util.exceptions.PointDistanceExceededException;\n+import com.graphhopper.util.exceptions.PointOutOfBoundsException;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.GHPoint;\n+\n+import java.util.*;\n+\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+import static com.graphhopper.util.Helper.DIST_EARTH;\n+import static com.graphhopper.util.Parameters.Algorithms.*;\n+import static com.graphhopper.util.Parameters.Routing.CURBSIDE;\n+import static com.graphhopper.util.Parameters.Routing.POINT_HINT;\n+\n+public class GraphHopperRouter {\n+    private final GraphHopperStorage ghStorage;\n+    private final EncodingManager encodingManager;\n+    private final LocationIndex locationIndex;\n+    private final Map<String, Profile> profilesByName;\n+    private final PathDetailsBuilderFactory pathDetailsBuilderFactory;\n+    private final TranslationMap translationMap;\n+    private final RoutingConfig routingConfig;\n+    private final WeightingFactory weightingFactory;\n+    // todo: these should not be necessary anymore as soon as GraphHopperStorage (or something that replaces) it acts\n+    // like a 'graph database'\n+    private final Map<String, CHGraph> chGraphs;\n+    private final Map<String, LandmarkStorage> landmarks;", "originalCommit": "d805e7c46af06f5edfa97dd564b42435207928d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY3Mjg5Mw==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431672893", "bodyText": "This was a bit weird. The default for LM disabling allowed was false, but still this returned true whenever there were some LM profiles. -> I changed the default for lmDisablingAllowed to true in RouterConfig now. Is this ok?", "author": "easbar", "createdAt": "2020-05-28T08:37:05Z", "path": "core/src/main/java/com/graphhopper/routing/lm/LMPreparationHandler.java", "diffHunk": "@@ -93,15 +85,6 @@ public int getLandmarks() {\n         return landmarkCount;\n     }\n \n-    public LMPreparationHandler setDisablingAllowed(boolean disablingAllowed) {\n-        this.disablingAllowed = disablingAllowed;\n-        return this;\n-    }\n-\n-    public final boolean isDisablingAllowed() {\n-        return disablingAllowed || !isEnabled();\n-    }", "originalCommit": "d805e7c46af06f5edfa97dd564b42435207928d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTczODYxNA==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431738614", "bodyText": "Or should we set it to false now? Seems a bit more simple to me to have both set to false :) (We would probably have to adjust this in a few tests, but what about production?)", "author": "easbar", "createdAt": "2020-05-28T10:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY3Mjg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc2NjA5Ng==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431766096", "bodyText": "Hm I'll leave it as it is for now we can change the default still later if we think its better.", "author": "easbar", "createdAt": "2020-05-28T11:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY3Mjg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc2NzAyNw==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431767027", "bodyText": "Yes, this could work too. The (hopefully ;)) only requirement for production is that the behaviour of ch.disable=true does not depend on if there are LM profiles or not (as we have clusters with CH and LM but also with CH and without LM). An additional assumption there is that no one uses lm.disable=true and only ch.disable=true/false.", "author": "karussell", "createdAt": "2020-05-28T11:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY3Mjg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc2ODUzMg==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431768532", "bodyText": "Ok I think ch.disable=true does not depend on the existence of LM profiles, but anyway for now it seems easier to not change it :)", "author": "easbar", "createdAt": "2020-05-28T11:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY3Mjg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY3MzkxOA==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431673918", "bodyText": "I changed these, because getting a CH graph should be done by passing its name, not the entire CHConfig (which I want to get rid of anyway).", "author": "easbar", "createdAt": "2020-05-28T08:38:44Z", "path": "tools/src/main/java/com/graphhopper/tools/Measurement.java", "diffHunk": "@@ -242,7 +242,7 @@ protected DataReader importData() throws IOException {\n                 System.gc();\n                 if (!hopper.getCHPreparationHandler().getNodeBasedCHConfigs().isEmpty()) {\n                     CHConfig chConfig = hopper.getCHPreparationHandler().getNodeBasedCHConfigs().get(0);\n-                    CHGraph lg = g.getCHGraph(chConfig);\n+                    CHGraph lg = g.getCHGraph(chConfig.getName());", "originalCommit": "d805e7c46af06f5edfa97dd564b42435207928d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5MDkwMg==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431690902", "bodyText": "Is this file even needed still?", "author": "easbar", "createdAt": "2020-05-28T09:07:17Z", "path": "core/src/main/java/com/graphhopper/util/EngineWarmUp.java", "diffHunk": "@@ -59,8 +59,8 @@ private static void warmUpCHSubNetwork(GraphHopper graphHopper, int iterations)\n         Random rand = new Random(0);\n \n         for (int i = 0; i < iterations; i++) {\n-            int startNode = rand.nextInt(graphHopper.getMaxVisitedNodes() + 1);\n-            int endNode = rand.nextInt(graphHopper.getMaxVisitedNodes() + 1);\n+            int startNode = rand.nextInt(graphHopper.getRoutingConfig().getMaxVisitedNodes() + 1);", "originalCommit": "d805e7c46af06f5edfa97dd564b42435207928d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcxOTA0Ng==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431719046", "bodyText": "See #194\nIt is currently not used, but we or a Java user could benefit of it when using MMAP. For now I would indeed remove it and instead suggest that the user warms up JVM and caches via some random routes.", "author": "karussell", "createdAt": "2020-05-28T09:56:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5MDkwMg=="}], "type": "inlineReview"}, {"oid": "8ba19ce3752e3b4e7d4dabb24ffce48bc5dde32e", "url": "https://github.com/graphhopper/graphhopper/commit/8ba19ce3752e3b4e7d4dabb24ffce48bc5dde32e", "message": "Rename: RoutingConfig -> RouterConfig, GraphHopperRouter -> Router", "committedDate": "2020-05-28T09:09:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcyNjY1NA==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431726654", "bodyText": "Can we throw this inside ghStorage.getCHGraph?", "author": "karussell", "createdAt": "2020-05-28T10:10:08Z", "path": "core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java", "diffHunk": "@@ -79,7 +79,9 @@ public static PrepareContractionHierarchies fromGraphHopperStorage(GraphHopperSt\n     }\n \n     private PrepareContractionHierarchies(GraphHopperStorage ghStorage, CHConfig chConfig) {\n-        this.chGraph = ghStorage.getCHGraph(chConfig);\n+        chGraph = ghStorage.getCHGraph(chConfig.getName());\n+        if (chGraph == null)\n+            throw new IllegalArgumentException(\"There is no CH graph '\" + chConfig.getName() + \"', existing: \" + ghStorage.getCHGraphNames());", "originalCommit": "8ba19ce3752e3b4e7d4dabb24ffce48bc5dde32e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTczNjA5NQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431736095", "bodyText": "Good question :) Previously there was an IllegalStateException inside getCHGraph(), but what about the case where we get some profile via the web UI and use this to get the CH graph? In this case we do not want a 500 error, so we would have to catch the IllegalStateException and convert it into a (web api friendly(ier)) IllegalArgumentException, but this very ugly. So we could change this into an IllegalArgumentException instead, but this only means that the concerns of the web layer further propagate into the core (especially if the error message contains web layer stuff). I thought returning null is a cleaner (layer independent) way to communicate that the corresponding CHGraph does not exist. I would even use a (checked) CHGraphDoesNotExistException to make this very explicit, but I know you don't like it and we had this discussion before :) Or we use a dedicated but unchecked exception...\nTo summarize:\n\nThe IllegalStateException used before seems very wrong to me, because it does not even allow asking GraphHopperStorage for a wrong CHGraph name. You have to know it before calling the method, but if this shall turn into something like a 'graph-database' there should be a clean way to find out something does not exist.\nUsing IllegalArgumentException is slightly better, especially because we use this quite frequently so far. But what about the error message? Its hard to make this independent from the layer the method is used in. And catching and converting an IllegalArgumentException also seems wrong. In this case it would be better to use a dedicated exception (does not matter much if its checked or not).\nUsing null leaves it up to the calling code how to handle the exceptional case (this is what I decided to do here)", "author": "easbar", "createdAt": "2020-05-28T10:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcyNjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc1Mjk3OQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431752979", "bodyText": "Ah. Thanks for these insights. So we fetch getCHGraph to know if a ch graph exists? Couldn't we do this with the profile map or when is it required?\n\nbut I know you don't like it and we had this discussion before :)\n\nHaha. Yeah. But every rule can have its exceptions ;)", "author": "karussell", "createdAt": "2020-05-28T11:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcyNjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc1NzgxOQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431757819", "bodyText": "So we fetch getCHGraph to know if a ch graph exists?\n\nNo, we need the actual graph (here and in other places).\n\nHaha. Yeah. But every rule can have its exceptions ;)\n\nNo I think there is no need for this. Its a matter of style and since we aren't using checked exceptions there is no real need to start doing it. Sorry mentioning checked/unchecked was a bit distracting here. This is more about error handling between different parts of the code base. And I guess the question was whether we should use return values like null, or standard exceptions (like IllegalArgument) or dedicated exceptions (like CHGraphDoesNotExist) to indicate such exceptional conditions.", "author": "easbar", "createdAt": "2020-05-28T11:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcyNjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc3Mjg4OA==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431772888", "bodyText": "Using IllegalArgumentException is slightly better, especially because we use this quite frequently so far. But what about the error message? Its hard to make this independent from the layer the method is used in.\n\nAre there currently different exception handling cases for ghStorage.getCHGraph==null where we have different messages?\n(Because if there is a bug then the now unchecked cases like in createRouter will throw a NPE)", "author": "karussell", "createdAt": "2020-05-28T11:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcyNjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc3ODI0OQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431778249", "bodyText": "Are there currently different exception handling cases for ghStorage.getCHGraph==null where we have different messages?\n\nWe don't know what GraphHopperStorage might be used for so we cannot know what a good error message would be. Actually I think we do not want to know this because GraphHopperStorage is not meant to be used for one particular use-case. This is kind of my point here, it should be up to the caller of the method what to do if the CH graph does not exist. In case the CH graph does not exist and we use the result we get an NPE yes, but before we got an IllegalStateException (I do not think either one is better). Using null forces the caller to handle it unless she is sure this case cannot happen (compared to a checked exceptions where we also have to handle it (and the compiler tells us) if we are sure we do not need to). Ok, the NPE will not produce a useful error message, so this would be an advantage of using a dedicated exception.", "author": "easbar", "createdAt": "2020-05-28T11:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcyNjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc3OTI4Mg==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431779282", "bodyText": "like in createRouter\n\nIn createRouter there cannot be an NPE, because we use a profile name that we got from GraphHopperStorage (but yes this is hard to see and not so easy to reason about).", "author": "easbar", "createdAt": "2020-05-28T11:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcyNjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4MTQ5MA==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431781490", "bodyText": "Ah but maybe we are talking about two different things... Have a look at Router#getAlgorithmFactory\n   CHGraph chGraph = chGraphs.get(profile);\n            if (chGraph == null)\n                throw new IllegalArgumentException(\"Cannot find CH preparation for the requested profile: '\" + profile + \"'\" +\n                        \"\\nYou can try disabling CH using \" + Parameters.CH.DISABLE + \"=true\" +\n                        \"\\navailable CH profiles: \" + chGraphs.keySet());\nHere we get a profile name from the user and throw an error if this profile name does not work with CH. The same error message would not make sense in GraphHopperStorage#getCHGraph. But to make this even more complicated: This code no longer even takes the CH graph from GraphHopperStorage (but it did before), because now I have this Map<String, CHGraph> (see the comment in the Router constructor if you wonder why).\nSo I could also revert the change in getCHGraph and throw an exception there again, but still my point is that it should be possible to find out a CH graph does not exist in a clean way (without catching IllegalStateException).", "author": "easbar", "createdAt": "2020-05-28T11:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcyNjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4ODA5NQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431788095", "bodyText": "But I can see why you want to prevent NPE, so my next suggestion would be an (unchecked) CHGraphDoesNotExistException.", "author": "easbar", "createdAt": "2020-05-28T12:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcyNjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg0MDI1NQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1901#discussion_r431840255", "bodyText": "So I could also revert the change in getCHGraph and throw an exception there again\n\nok\n\nBut I can see why you want to prevent NPE, so my next suggestion would be an (unchecked) CHGraphDoesNotExistException\n\nLet's keep it like it is :) (returning null)", "author": "karussell", "createdAt": "2020-05-28T13:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcyNjY1NA=="}], "type": "inlineReview"}, {"oid": "8d07c315aabaf21165309b3ab1f6fb15d1d39736", "url": "https://github.com/graphhopper/graphhopper/commit/8d07c315aabaf21165309b3ab1f6fb15d1d39736", "message": "Remove EngineWarmup", "committedDate": "2020-05-28T10:29:50Z", "type": "commit"}, {"oid": "f9ee70271b81e06c5281892411a433fa34c3a2be", "url": "https://github.com/graphhopper/graphhopper/commit/f9ee70271b81e06c5281892411a433fa34c3a2be", "message": "Remove todos", "committedDate": "2020-05-28T11:28:44Z", "type": "commit"}, {"oid": "a03a7325dcf8e362ee4418f2b89a1c82698ef2a0", "url": "https://github.com/graphhopper/graphhopper/commit/a03a7325dcf8e362ee4418f2b89a1c82698ef2a0", "message": "Merge branch 'master' into gh_router", "committedDate": "2020-05-28T11:29:23Z", "type": "commit"}]}