{"pr_number": 1585, "pr_title": "JBTM-3276 SlotStore implementation.", "pr_createdAt": "2020-04-02T14:52:32Z", "pr_url": "https://github.com/jbosstm/narayana/pull/1585", "timeline": [{"oid": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "url": "https://github.com/jbosstm/narayana/commit/667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "message": "JBTM-3276 SlotStore implementation.\nThis is part one, with the in-memory backend.", "committedDate": "2020-04-02T14:48:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NjM0Mw==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403486343", "bodyText": "Can the file exist if the directory hierarchy hasn't been created?", "author": "mmusgrov", "createdAt": "2020-04-04T16:06:22Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStore.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputBuffer;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+\n+/**\n+ * A storage system presenting a key-value API, implemented (conceptually) using a fixed sized array.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStore {\n+\n+    private final SlotStoreEnvironmentBean config;\n+\n+    private final String storeDirCanonicalPath;\n+\n+    /*\n+     * The slotIdIndex tracks the key to slot mapping for all in-use slots,\n+     * whilst the free list tracks all unoccupied slots. Care must be taken with the\n+     * relative ordering of operations on these structures, to avoid losing or double allocating slots.\n+     */\n+    public final ConcurrentHashMap<SlotStoreKey, Integer> slotIdIndex = new ConcurrentHashMap<>();\n+    public final Deque<Integer> freeList = new ConcurrentLinkedDeque<>();\n+\n+    public final RAMSlots slots; // TODO add alternative implementations\n+\n+    /**\n+     * Create a new instance with the given configuration.\n+     *\n+     * @param config The configuration parameters for the instance\n+     * @throws IOException if the required backing storage can't be initialized.\n+     */\n+    public SlotStore(SlotStoreEnvironmentBean config) throws IOException {\n+\n+        this.config = config;\n+\n+        // unused for now, but eventually we'll have a disk backend...\n+        File storeDir = new File(config.getStoreDir());\n+        if (!storeDir.exists() && !storeDir.mkdirs()) {", "originalCommit": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA4NDE1OA==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404084158", "bodyText": "The dir may be created in one run and its existence validated on the next, since it doesn't get deleted when the server shuts down. Wouldn't be a lot of use for recovery if it did! That code shouldn't really be in the RAM backed version at all, but the path also serves as the store name so it didn't get cleanly factored out.\nfirst run of a server, exist check fails, so mkdirs runs and must succeed\nsubsequent runs of a server, exists check passes, so mkdirs doesn't run as it's shortcut out", "author": "jhalliday", "createdAt": "2020-04-06T13:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA5MDg5Mw==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404090893", "bodyText": "Of course, thanks for the clarification.", "author": "mmusgrov", "createdAt": "2020-04-06T13:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NjM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NjUyNA==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403486524", "bodyText": "Do you ignore the return value because you just want to validate inputBuffer. If so why not add an isValid() method? Is it because SlotStore is only ever accessed via the adaptor (SlotStoreAdaptor), in which case validation as a side effect of unpacking is fine.", "author": "mmusgrov", "createdAt": "2020-04-04T16:08:19Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStore.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputBuffer;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+\n+/**\n+ * A storage system presenting a key-value API, implemented (conceptually) using a fixed sized array.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStore {\n+\n+    private final SlotStoreEnvironmentBean config;\n+\n+    private final String storeDirCanonicalPath;\n+\n+    /*\n+     * The slotIdIndex tracks the key to slot mapping for all in-use slots,\n+     * whilst the free list tracks all unoccupied slots. Care must be taken with the\n+     * relative ordering of operations on these structures, to avoid losing or double allocating slots.\n+     */\n+    public final ConcurrentHashMap<SlotStoreKey, Integer> slotIdIndex = new ConcurrentHashMap<>();\n+    public final Deque<Integer> freeList = new ConcurrentLinkedDeque<>();\n+\n+    public final RAMSlots slots; // TODO add alternative implementations\n+\n+    /**\n+     * Create a new instance with the given configuration.\n+     *\n+     * @param config The configuration parameters for the instance\n+     * @throws IOException if the required backing storage can't be initialized.\n+     */\n+    public SlotStore(SlotStoreEnvironmentBean config) throws IOException {\n+\n+        this.config = config;\n+\n+        // unused for now, but eventually we'll have a disk backend...\n+        File storeDir = new File(config.getStoreDir());\n+        if (!storeDir.exists() && !storeDir.mkdirs()) {\n+            throw new IOException(tsLogger.i18NLogger.get_dir_create_failed(storeDir.getCanonicalPath()));\n+        }\n+        storeDirCanonicalPath = storeDir.getCanonicalPath();\n+\n+        slots = new RAMSlots(config);\n+\n+        for (int i = 0; i < config.getNumberOfSlots(); i++) {\n+            freeList.add(i); // TODO recovery, when the backend supports it.\n+        }\n+    }\n+\n+    /**\n+     * @return the \"name\" of the object store. Where in the hierarchy it appears, e.g., /ObjectStore/MyName/...\n+     */\n+    public String getStoreName() {\n+        return this.getClass().getSimpleName() + \":\" + storeDirCanonicalPath;\n+    }\n+\n+    /**\n+     * Retrieve the serialized state for an entry.\n+     *\n+     * @param key The unique identifier for the entry\n+     * @return The serialized state\n+     * @throws IOException if the entry is not found\n+     */\n+    public InputObjectState read(SlotStoreKey key) throws IOException {\n+\n+        Integer slotId = slotIdIndex.get(key);\n+        if (slotId == null) {\n+            throw new IOException(\"record not found for \" + key);\n+        }\n+        byte[] data = slots.read(slotId);\n+        // it's possible, though unlikely, for the data to be null here due to a concurrent remove\n+        if (data == null) {\n+            throw new IOException(\"record not found for \" + key);\n+        }\n+        InputBuffer inputBuffer = new InputBuffer(data);\n+        SlotStoreKey.unpackFrom(inputBuffer);\n+", "originalCommit": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA4NDM5Nw==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404084397", "bodyText": "The data contains the serialized key needed to rebuild the slotIdIndex on recovery, plus the serialized record. The read operation already has the key - that's the thing passed as an arg to the function. So there is no point deserializing the copy that's in the data. But we need to skip over it to reach the record state we do need. Perhaps I should reverse the packing order so the key trails the record, but as reads are rare anyhow it may not be worth the optimization", "author": "jhalliday", "createdAt": "2020-04-06T13:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NjUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NzE1Mw==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403487153", "bodyText": "Superfluous test for null because matchingKeys cannot be null because SlotStoreAdaptor#getMatchingKeys(key) always returns a valid array.", "author": "mmusgrov", "createdAt": "2020-04-04T16:14:24Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStoreAdaptor.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.common.Uid;\n+import com.arjuna.ats.arjuna.exceptions.ObjectStoreException;\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.ObjectStoreAPI;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+import com.arjuna.ats.internal.arjuna.common.UidHelper;\n+import com.arjuna.common.internal.util.propertyservice.BeanPopulator;\n+\n+import java.io.IOException;\n+import java.io.SyncFailedException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Adaptor class that wraps the SlotStore to make it look like an ObjectStore.\n+ * Modelled on HornetqObjectStoreAdaptor.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStoreAdaptor implements ObjectStoreAPI {\n+\n+    private final SlotStore store;\n+\n+    // used for standalone bootstrap via StoreManager\n+    public SlotStoreAdaptor() throws IOException {\n+        SlotStoreEnvironmentBean envBean = BeanPopulator.getDefaultInstance(SlotStoreEnvironmentBean.class);\n+        store = new SlotStore(envBean);\n+    }\n+\n+    // used for beans wiring type bootstrap when running embedded.\n+    public SlotStoreAdaptor(SlotStore slotStore) {\n+        this.store = slotStore;\n+    }\n+\n+    /**\n+     * Obtain all of the Uids for a specified type.\n+     *\n+     * @param typeName       The type to scan for.\n+     * @param foundInstances The object state in which to store the Uids\n+     * @param matchState     The file type to look for (e.g., committed, shadowed). [StateStatus]\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances, int matchState) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \", \" + matchState + \")\");\n+        }\n+\n+        SlotStoreKey key = new SlotStoreKey(null, typeName, matchState);\n+\n+        SlotStoreKey[] matchingKeys = store.getMatchingKeys(key);\n+\n+        OutputObjectState buffer = new OutputObjectState();\n+\n+        try {\n+            if (matchingKeys != null) {", "originalCommit": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA4NjAxNA==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404086014", "bodyText": "D'oh", "author": "jhalliday", "createdAt": "2020-04-06T13:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NzE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NzQzNg==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403487436", "bodyText": "I'd have expected this method to return all Uids regardless of their StateStatus value. But since it only returns OS_UNKNOWN ones will you include some javadoc for the method signature.", "author": "mmusgrov", "createdAt": "2020-04-04T16:17:34Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStoreAdaptor.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.common.Uid;\n+import com.arjuna.ats.arjuna.exceptions.ObjectStoreException;\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.ObjectStoreAPI;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+import com.arjuna.ats.internal.arjuna.common.UidHelper;\n+import com.arjuna.common.internal.util.propertyservice.BeanPopulator;\n+\n+import java.io.IOException;\n+import java.io.SyncFailedException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Adaptor class that wraps the SlotStore to make it look like an ObjectStore.\n+ * Modelled on HornetqObjectStoreAdaptor.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStoreAdaptor implements ObjectStoreAPI {\n+\n+    private final SlotStore store;\n+\n+    // used for standalone bootstrap via StoreManager\n+    public SlotStoreAdaptor() throws IOException {\n+        SlotStoreEnvironmentBean envBean = BeanPopulator.getDefaultInstance(SlotStoreEnvironmentBean.class);\n+        store = new SlotStore(envBean);\n+    }\n+\n+    // used for beans wiring type bootstrap when running embedded.\n+    public SlotStoreAdaptor(SlotStore slotStore) {\n+        this.store = slotStore;\n+    }\n+\n+    /**\n+     * Obtain all of the Uids for a specified type.\n+     *\n+     * @param typeName       The type to scan for.\n+     * @param foundInstances The object state in which to store the Uids\n+     * @param matchState     The file type to look for (e.g., committed, shadowed). [StateStatus]\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances, int matchState) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \", \" + matchState + \")\");\n+        }\n+\n+        SlotStoreKey key = new SlotStoreKey(null, typeName, matchState);\n+\n+        SlotStoreKey[] matchingKeys = store.getMatchingKeys(key);\n+\n+        OutputObjectState buffer = new OutputObjectState();\n+\n+        try {\n+            if (matchingKeys != null) {\n+                for (SlotStoreKey matchingKey : matchingKeys) {\n+                    if (matchingKey != null) {\n+                        UidHelper.packInto(matchingKey.getUid(), buffer);\n+                    }\n+                }\n+            }\n+            UidHelper.packInto(Uid.nullUid(), buffer);\n+        } catch (IOException e) {\n+            throw new ObjectStoreException(e);\n+        }\n+\n+        foundInstances.setBuffer(buffer.buffer());\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \")\");\n+        }\n+\n+        return allObjUids(typeName, foundInstances, StateStatus.OS_UNKNOWN);", "originalCommit": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwNDA0OA==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404104048", "bodyText": "Arg. That's actually a bug in getMatchingKeys - if should indeed return all by using\nslotStoreKey.getStateStatus() == StateStatus.OS_UNKNOWN\nrather than\nkey.getStateStatus() == StateStatus.OS_UNKNOWN\nI should probably call them lookFor and candidateMatch or something else more distinctive.", "author": "jhalliday", "createdAt": "2020-04-06T13:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NzQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc4Njk1MQ==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404786951", "bodyText": "@jhalliday I was also expecting a javadoc entry for this method since it only return only OS_UNKNOWN states, why not all states and whatever the answer is shouldn't the javadoc say why?", "author": "mmusgrov", "createdAt": "2020-04-07T12:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NzQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg2NTAwNw==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404865007", "bodyText": "It returns all states - OS_UNKNOWN functions as a wildcard in this case. I think that started out as a quirk of the FileStore and then spread, it's not documented behaviour of the RecoveryStore interface, but I'm happy to make it so. The javadoc in the adaptor is mostly copy/paste of the interface javadoc just to help me remember how things should work, which is why that method didn't get any.", "author": "jhalliday", "createdAt": "2020-04-07T14:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NzQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODEzNA==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403488134", "bodyText": "The comment is confusing because the array of knownTypes is populated in the method getKnownTypes by the call types.add(key.getTypeName()); but the added typeName can never be null (because the SlotStoreKey constructor dereferences it when checks for \"/\").", "author": "mmusgrov", "createdAt": "2020-04-04T16:24:48Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStoreAdaptor.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.common.Uid;\n+import com.arjuna.ats.arjuna.exceptions.ObjectStoreException;\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.ObjectStoreAPI;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+import com.arjuna.ats.internal.arjuna.common.UidHelper;\n+import com.arjuna.common.internal.util.propertyservice.BeanPopulator;\n+\n+import java.io.IOException;\n+import java.io.SyncFailedException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Adaptor class that wraps the SlotStore to make it look like an ObjectStore.\n+ * Modelled on HornetqObjectStoreAdaptor.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStoreAdaptor implements ObjectStoreAPI {\n+\n+    private final SlotStore store;\n+\n+    // used for standalone bootstrap via StoreManager\n+    public SlotStoreAdaptor() throws IOException {\n+        SlotStoreEnvironmentBean envBean = BeanPopulator.getDefaultInstance(SlotStoreEnvironmentBean.class);\n+        store = new SlotStore(envBean);\n+    }\n+\n+    // used for beans wiring type bootstrap when running embedded.\n+    public SlotStoreAdaptor(SlotStore slotStore) {\n+        this.store = slotStore;\n+    }\n+\n+    /**\n+     * Obtain all of the Uids for a specified type.\n+     *\n+     * @param typeName       The type to scan for.\n+     * @param foundInstances The object state in which to store the Uids\n+     * @param matchState     The file type to look for (e.g., committed, shadowed). [StateStatus]\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances, int matchState) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \", \" + matchState + \")\");\n+        }\n+\n+        SlotStoreKey key = new SlotStoreKey(null, typeName, matchState);\n+\n+        SlotStoreKey[] matchingKeys = store.getMatchingKeys(key);\n+\n+        OutputObjectState buffer = new OutputObjectState();\n+\n+        try {\n+            if (matchingKeys != null) {\n+                for (SlotStoreKey matchingKey : matchingKeys) {\n+                    if (matchingKey != null) {\n+                        UidHelper.packInto(matchingKey.getUid(), buffer);\n+                    }\n+                }\n+            }\n+            UidHelper.packInto(Uid.nullUid(), buffer);\n+        } catch (IOException e) {\n+            throw new ObjectStoreException(e);\n+        }\n+\n+        foundInstances.setBuffer(buffer.buffer());\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \")\");\n+        }\n+\n+        return allObjUids(typeName, foundInstances, StateStatus.OS_UNKNOWN);\n+    }\n+\n+    /**\n+     * Obtain all types of objects stored in the object store.\n+     *\n+     * @param foundTypes The state in which to store the types.\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allTypes(InputObjectState foundTypes) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allTypes()\");\n+        }\n+\n+        String[] knownTypes = store.getKnownTypes(); // may contain trailing null elements", "originalCommit": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwNDEyMQ==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404104121", "bodyText": "oops. That's a copy-paste from the Hornetq version, which can do odd things because it's backed by a ConcurrentMap. You're right, it doesn't apply here.", "author": "jhalliday", "createdAt": "2020-04-06T13:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODIzMA==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403488230", "bodyText": "Remark: ArjunaCore does not document that typename hierarchies are delimited by slashes\nRemark: could you not leverage java.nio.files.Path to split the type name for you instead of using the following tricky code", "author": "mmusgrov", "createdAt": "2020-04-04T16:25:59Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStoreAdaptor.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.common.Uid;\n+import com.arjuna.ats.arjuna.exceptions.ObjectStoreException;\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.ObjectStoreAPI;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+import com.arjuna.ats.internal.arjuna.common.UidHelper;\n+import com.arjuna.common.internal.util.propertyservice.BeanPopulator;\n+\n+import java.io.IOException;\n+import java.io.SyncFailedException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Adaptor class that wraps the SlotStore to make it look like an ObjectStore.\n+ * Modelled on HornetqObjectStoreAdaptor.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStoreAdaptor implements ObjectStoreAPI {\n+\n+    private final SlotStore store;\n+\n+    // used for standalone bootstrap via StoreManager\n+    public SlotStoreAdaptor() throws IOException {\n+        SlotStoreEnvironmentBean envBean = BeanPopulator.getDefaultInstance(SlotStoreEnvironmentBean.class);\n+        store = new SlotStore(envBean);\n+    }\n+\n+    // used for beans wiring type bootstrap when running embedded.\n+    public SlotStoreAdaptor(SlotStore slotStore) {\n+        this.store = slotStore;\n+    }\n+\n+    /**\n+     * Obtain all of the Uids for a specified type.\n+     *\n+     * @param typeName       The type to scan for.\n+     * @param foundInstances The object state in which to store the Uids\n+     * @param matchState     The file type to look for (e.g., committed, shadowed). [StateStatus]\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances, int matchState) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \", \" + matchState + \")\");\n+        }\n+\n+        SlotStoreKey key = new SlotStoreKey(null, typeName, matchState);\n+\n+        SlotStoreKey[] matchingKeys = store.getMatchingKeys(key);\n+\n+        OutputObjectState buffer = new OutputObjectState();\n+\n+        try {\n+            if (matchingKeys != null) {\n+                for (SlotStoreKey matchingKey : matchingKeys) {\n+                    if (matchingKey != null) {\n+                        UidHelper.packInto(matchingKey.getUid(), buffer);\n+                    }\n+                }\n+            }\n+            UidHelper.packInto(Uid.nullUid(), buffer);\n+        } catch (IOException e) {\n+            throw new ObjectStoreException(e);\n+        }\n+\n+        foundInstances.setBuffer(buffer.buffer());\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean allObjUids(String typeName, InputObjectState foundInstances) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allObjUids(\" + typeName + \")\");\n+        }\n+\n+        return allObjUids(typeName, foundInstances, StateStatus.OS_UNKNOWN);\n+    }\n+\n+    /**\n+     * Obtain all types of objects stored in the object store.\n+     *\n+     * @param foundTypes The state in which to store the types.\n+     * @return <code>true</code> if no errors occurred, <code>false</code>\n+     * otherwise.\n+     */\n+    @Override\n+    public boolean allTypes(InputObjectState foundTypes) throws ObjectStoreException {\n+        if (tsLogger.logger.isTraceEnabled()) {\n+            tsLogger.logger.trace(\"SlotStore.allTypes()\");\n+        }\n+\n+        String[] knownTypes = store.getKnownTypes(); // may contain trailing null elements\n+        Set<String> typeSet = new HashSet<>();\n+\n+        if (knownTypes == null || knownTypes.length == 0) {\n+            return true;\n+        }\n+\n+        OutputObjectState buffer = new OutputObjectState();\n+\n+        try {\n+            for (String typeName : knownTypes) {\n+                if (typeName == null) {\n+                    continue;\n+                }\n+\n+                if (typeName.startsWith(\"/\")) {", "originalCommit": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExMjE4Mw==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404112183", "bodyText": "ArjunaCore uses leading delimiters in some calls and not in others, considering the typename to be equivalent with or without, which works ok when backed by the file system as the file path code fixes them up when concatenating, but not when backed by non-fs things like the string indexing here. Basically \"/foo\".equals(\"foo\") is assumed by the core to be true even though it's not, because in practice new File(baseDIr, \"/foo\").equals( new File(baseDIr, \"foo\") ) is true.\nTook an age to track that down when building the Hornetq version. It's another thing that got copied in and could be tweaked, but probably isn't worth the effort. More complex parsing is overkill as we don't care about / within the typename, only at the start.", "author": "jhalliday", "createdAt": "2020-04-06T13:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEzNDIyNg==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404134226", "bodyText": "I was asking more about using java.nio.files.Path to split the type name instead of your hand rolled complex parsing. But if you prefer to keep the complex version then fine and we will maintain it for you ;)", "author": "mmusgrov", "createdAt": "2020-04-06T14:26:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MDY3MQ==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404140671", "bodyText": "Actually using java.nio.* is more complex and slower. Please ignore my comment.", "author": "mmusgrov", "createdAt": "2020-04-06T14:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODU0OQ==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403488549", "bodyText": "My IDE is complaining that many of your access modifiers are too permissive. I know the slot store is private to SlotStoreAdaptor but restricting the modifier will stop IDE's from complaining.", "author": "mmusgrov", "createdAt": "2020-04-04T16:29:02Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/RAMSlots.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+/**\n+ * Trivial in-memory backend for the SlotStore, useful for benchmarking but not much else.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class RAMSlots {\n+\n+    public final byte[][] slots;", "originalCommit": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExMzYwMg==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404113602", "bodyText": "The machine ain't the boss of me. Buy yeah, true.", "author": "jhalliday", "createdAt": "2020-04-06T14:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4ODU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4OTEwMw==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r403489103", "bodyText": "So now there are two entries for the same state. Can periodic recovery kick in at this point and attempt to recover both?", "author": "mmusgrov", "createdAt": "2020-04-04T16:34:37Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStore.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+import com.arjuna.ats.arjuna.objectstore.StateStatus;\n+import com.arjuna.ats.arjuna.state.InputBuffer;\n+import com.arjuna.ats.arjuna.state.InputObjectState;\n+import com.arjuna.ats.arjuna.state.OutputObjectState;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+\n+/**\n+ * A storage system presenting a key-value API, implemented (conceptually) using a fixed sized array.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-03\n+ */\n+public class SlotStore {\n+\n+    private final SlotStoreEnvironmentBean config;\n+\n+    private final String storeDirCanonicalPath;\n+\n+    /*\n+     * The slotIdIndex tracks the key to slot mapping for all in-use slots,\n+     * whilst the free list tracks all unoccupied slots. Care must be taken with the\n+     * relative ordering of operations on these structures, to avoid losing or double allocating slots.\n+     */\n+    public final ConcurrentHashMap<SlotStoreKey, Integer> slotIdIndex = new ConcurrentHashMap<>();\n+    public final Deque<Integer> freeList = new ConcurrentLinkedDeque<>();\n+\n+    public final RAMSlots slots; // TODO add alternative implementations\n+\n+    /**\n+     * Create a new instance with the given configuration.\n+     *\n+     * @param config The configuration parameters for the instance\n+     * @throws IOException if the required backing storage can't be initialized.\n+     */\n+    public SlotStore(SlotStoreEnvironmentBean config) throws IOException {\n+\n+        this.config = config;\n+\n+        // unused for now, but eventually we'll have a disk backend...\n+        File storeDir = new File(config.getStoreDir());\n+        if (!storeDir.exists() && !storeDir.mkdirs()) {\n+            throw new IOException(tsLogger.i18NLogger.get_dir_create_failed(storeDir.getCanonicalPath()));\n+        }\n+        storeDirCanonicalPath = storeDir.getCanonicalPath();\n+\n+        slots = new RAMSlots(config);\n+\n+        for (int i = 0; i < config.getNumberOfSlots(); i++) {\n+            freeList.add(i); // TODO recovery, when the backend supports it.\n+        }\n+    }\n+\n+    /**\n+     * @return the \"name\" of the object store. Where in the hierarchy it appears, e.g., /ObjectStore/MyName/...\n+     */\n+    public String getStoreName() {\n+        return this.getClass().getSimpleName() + \":\" + storeDirCanonicalPath;\n+    }\n+\n+    /**\n+     * Retrieve the serialized state for an entry.\n+     *\n+     * @param key The unique identifier for the entry\n+     * @return The serialized state\n+     * @throws IOException if the entry is not found\n+     */\n+    public InputObjectState read(SlotStoreKey key) throws IOException {\n+\n+        Integer slotId = slotIdIndex.get(key);\n+        if (slotId == null) {\n+            throw new IOException(\"record not found for \" + key);\n+        }\n+        byte[] data = slots.read(slotId);\n+        // it's possible, though unlikely, for the data to be null here due to a concurrent remove\n+        if (data == null) {\n+            throw new IOException(\"record not found for \" + key);\n+        }\n+        InputBuffer inputBuffer = new InputBuffer(data);\n+        SlotStoreKey.unpackFrom(inputBuffer);\n+\n+        InputObjectState inputObjectState = new InputObjectState();\n+        inputObjectState.unpackFrom(inputBuffer);\n+\n+        return inputObjectState;\n+    }\n+\n+    /**\n+     * Remove the state for an entry, freeing the slot.\n+     * Depending on the configuration, this change may not be immediately persistent.\n+     *\n+     * @param key The unique identifier for the entry\n+     * @return true on success, false otherwise\n+     * @throws IOException unused for now in this impl.\n+     */\n+    public boolean remove(SlotStoreKey key) throws IOException {\n+\n+        Integer slotId = slotIdIndex.remove(key);\n+        if (slotId == null) {\n+            return false;\n+        }\n+\n+        slots.clear(slotId, config.isSyncDeletes());\n+\n+        freeList.add(slotId);\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Write (or overwrite) an entry with the given key and value.\n+     *\n+     * @param key               The unique identifier for the entry\n+     * @param outputObjectState The serialized state\n+     * @return true on success, false otherwise e.g. when the store is full.\n+     * @throws IOException if serialization fails\n+     */\n+    public boolean write(SlotStoreKey key, OutputObjectState outputObjectState) throws IOException {\n+\n+        OutputObjectState record = new OutputObjectState();\n+        key.packInto(record);\n+        outputObjectState.packInto(record);\n+        byte[] data = outputObjectState.buffer();\n+\n+        if (data.length > config.getBytesPerSlot()) {\n+            throw new IOException(\"data too big for slot\");\n+        }\n+\n+        // We always write to a new slot, as overwrite in place may be non-atomic and\n+        // risks leaving us with neither the before or after version for crash recovery.\n+\n+        Integer slotId = freeList.poll();\n+        if (slotId == null) {\n+            return false;\n+        }\n+\n+        slots.write(slotId, data, config.isSyncWrites());\n+        slotIdIndex.put(key, slotId);\n+\n+        Integer previousSlot = slotIdIndex.put(key, slotId);\n+\n+        // If it's a rewrite, we need to release the older version's slot\n+        if (previousSlot != null) {", "originalCommit": "667e45455b6b25c03b0ad38ee0a3ad9d697c4898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExOTQxNw==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404119417", "bodyText": "There is a time window where internally that's true, just as in wider recovery we may still have a log for a tx that has actually completed and isn't in the resource managers any more.\nIn the case of SlotStore it is (will be, when I write it...) indeterminate which state is used, which is fine so log as exactly one is. That's taken care of by the index, which only ever holds one even if two underlying slots are used. Periodic Recovery (in the ArjunaCore sense) sees only one, as it's going via the index. Recovery internally at the SlotStore level (one-off at startup time) will see both and insert only one into the index.", "author": "jhalliday", "createdAt": "2020-04-06T14:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4OTEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEzMTU1NA==", "url": "https://github.com/jbosstm/narayana/pull/1585#discussion_r404131554", "bodyText": "Thanks for a thorough answer.", "author": "mmusgrov", "createdAt": "2020-04-06T14:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4OTEwMw=="}], "type": "inlineReview"}, {"oid": "9c4f104cd48b3e2140236f5f75c8f5e3c99838d9", "url": "https://github.com/jbosstm/narayana/commit/9c4f104cd48b3e2140236f5f75c8f5e3c99838d9", "message": "JBTM-3276 SlotStore implementation.\npart one review fixes", "committedDate": "2020-04-06T14:58:04Z", "type": "commit"}, {"oid": "80c436652c27146ba74fca14c5a81aecb201a46f", "url": "https://github.com/jbosstm/narayana/commit/80c436652c27146ba74fca14c5a81aecb201a46f", "message": "JBTM-3276 SlotStore implementation.\njavadoc improvements.", "committedDate": "2020-04-07T14:54:07Z", "type": "commit"}]}