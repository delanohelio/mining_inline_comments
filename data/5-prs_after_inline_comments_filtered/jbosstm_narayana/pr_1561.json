{"pr_number": 1561, "pr_title": "[JBTM-3257] not throwing NPE when request command on recovery trigger is", "pr_createdAt": "2020-02-20T12:09:15Z", "pr_url": "https://github.com/jbosstm/narayana/pull/1561", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzM5OQ==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r381997399", "bodyText": "Would it be possible to add a test for this please? I think the description of https://issues.redhat.com/browse/JBTM-3257 indicates that the scan would have started but if I understand where this condition can occur it is before the instruction is read. I wonder why an IOException is not coming out of in.readLine?", "author": "tomjenkinson", "createdAt": "2020-02-20T13:29:18Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/recovery/WorkerService.java", "diffHunk": "@@ -63,7 +63,7 @@ public void doWork (InputStream is, OutputStream os) throws IOException\n \t{\n \t    String request = in.readLine();\n \n-        if (request.equals(\"PING\"))\n+        if (\"PING\".equals(request))", "originalCommit": "680ffb9ce48993af22969302fd7303830d72bd8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjU2MDMyNA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r382560324", "bodyText": "ok. investigation was not easy but I assume I got the reason. see my comment below", "author": "ochaloup", "createdAt": "2020-02-21T12:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM4MjIwOA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386382208", "bodyText": "Sorry to go back in time so far by when you refer to a comment to look at below please can you indicate the one I should look at?", "author": "tomjenkinson", "createdAt": "2020-03-02T13:09:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQyNTI5OA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386425298", "bodyText": "@tomjenkinson I meant the one where I summarized my effort. It's this one: #1561 (comment)\nBut as you went through the code already I assume there is not many new information in that comment.", "author": "ochaloup", "createdAt": "2020-03-02T14:30:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0MDU1Ng==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386440556", "bodyText": "Thanks @ochaloup I am wondering which of the tests will make the variable request be equal to null? Is that scenario able to be created in the unit tests using WorkerService? Something like create the PrintWriter client side and then just close the socket and somehow verify that the WorkerService did not NPE when it got a null https://github.com/jbosstm/narayana/pull/1561/files#diff-133ca2f8c1781ec3f48d3b73b2060a23L64", "author": "tomjenkinson", "createdAt": "2020-03-02T14:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkxMTMwNg==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386911306", "bodyText": "@ochaloup Testing getting a null on the request is the key thing I am trying to get to for JBTM-3257. Which of the tests results in that?\nI was thinking that a test could open the socket and then close the socket (without sending anything) and it might result in request from String request = in.readLine(); being null?\nIf you do need to send \"SCAN\" as described in https://issues.redhat.com/browse/JBTM-3257 then perhaps rather than toServer.println you could use https://docs.oracle.com/javase/7/docs/api/java/io/PrintWriter.html#print(java.lang.String) rather than println but I don't know of a way to abruptly kill the socket in Java so perhaps that is not possible / predictable in a platform neutral manner?", "author": "tomjenkinson", "createdAt": "2020-03-03T10:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA4Njc0MQ==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r387086741", "bodyText": "@tomjenkinson\ntest which you ask for is here: ochaloup@65e56fc\n...but it's not possible to be really tested. The trouble is that NPE is thrown but NPE is left just as an error in test log. NPE is at a thread which just disappears and does not influence any functionality.\nI didn't add the test into the test suite as it's not easily possible to find the NPE happens or not. And from my perspective it's not an important test. The functionality is not harmed. On socket timeout the client does not wait for any information. So the NPE is only printed to log. While no information is delivered wrongly.", "author": "ochaloup", "createdAt": "2020-03-03T15:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEwMDYxMw==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r387100613", "bodyText": "I think this is the part I am not sure of most. What to do about that test as that is the part that really covers testing of JBTM-3257 IIUC. I will consider further.", "author": "tomjenkinson", "createdAt": "2020-03-03T15:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0NDg1Mg==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r387144852", "bodyText": "@ochaloup please can you take a look at ochaloup#8 ?", "author": "tomjenkinson", "createdAt": "2020-03-03T16:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxOTMzMw==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r387619333", "bodyText": "@tomjenkinson wow, that's nice. Thanks! I will add the test to PR and I will try to reformat the commits. I hope in a good order :-)", "author": "ochaloup", "createdAt": "2020-03-04T11:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzM5OQ=="}], "type": "inlineReview"}, {"oid": "035c6e85b54154a638231717c91a28cbb3bcbe26", "url": "https://github.com/jbosstm/narayana/commit/035c6e85b54154a638231717c91a28cbb3bcbe26", "message": "[refactoring] to get more information on error states", "committedDate": "2020-02-21T12:36:40Z", "type": "forcePushed"}, {"oid": "728025122c8149a4d3929e66badb2b0444e477bf", "url": "https://github.com/jbosstm/narayana/commit/728025122c8149a4d3929e66badb2b0444e477bf", "message": "[refactoring] to get more information on error states", "committedDate": "2020-02-24T09:53:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MTU0NQ==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385081545", "bodyText": "The method naming convention in this file is to prefix the method name with the level at which the message is logged. This also has the benefit of making it easy to search a source file for various warning, errors, etc", "author": "mmusgrov", "createdAt": "2020-02-27T11:57:23Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/arjuna/logging/arjunaI18NLogger.java", "diffHunk": "@@ -1604,6 +1605,14 @@ public void warn_objectstore_JDBCImple_over_max_image_size(int imageSize,\n \t@Message(id = 12399, value = \"Problem in doWork of CacheStore trying to perform state management\", format = MESSAGE_FORMAT)\n \t@LogMessage(level = WARN)\n \tvoid warn_could_not_handle_objectstore_generic(@Cause Exception ex);\n+\n+\t@Message(id = 12400, value = \"Cannot terminate the recovery manager as the implementation is not known. Could be the recovery manager was not started yet?\", format = MESSAGE_FORMAT)\n+\tString get_recovery_manager_implementation_is_not_set();", "originalCommit": "728025122c8149a4d3929e66badb2b0444e477bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5NTI5Nw==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385595297", "bodyText": "This is not a log message. Take a look at the annotations in the code. As a non-log message, but a message used for exception, the get_ prefix should correspond with the format of the file in such cases.", "author": "ochaloup", "createdAt": "2020-02-28T09:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MTU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MDg2OQ==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385770869", "bodyText": "Okay", "author": "mmusgrov", "createdAt": "2020-02-28T15:48:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MTU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MzE2Nw==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385083167", "bodyText": "Why no log message?", "author": "mmusgrov", "createdAt": "2020-02-27T12:00:58Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/arjuna/recovery/RecoveryManager.java", "diffHunk": "@@ -441,7 +442,8 @@ public static void main (String[] args)\n                     }\n                     catch(InterruptedException interruptedException)\n                     {\n-                        // do nothing\n+                        System.err.println(\"The retry attempt was interrupted. Exiting...\");", "originalCommit": "728025122c8149a4d3929e66badb2b0444e477bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5ODEyOQ==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385598129", "bodyText": "It's because this printing is part of the main class which is invoked from the command line. I think it's more logical to print this message to STDERR rather than to log.", "author": "ochaloup", "createdAt": "2020-02-28T09:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MzE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NDEyMQ==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385084121", "bodyText": "It is not ignored anymore so the name needs updating too.", "author": "mmusgrov", "createdAt": "2020-02-27T12:03:03Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/recovery/Listener.java", "diffHunk": "@@ -242,16 +242,17 @@ public synchronized void stopListener()\n            }\n            try {\n                wait();\n-           } catch (InterruptedException e) {\n-               // ignore\n+           } catch (InterruptedException ignoredIe) {\n+               tsLogger.logger.debug(\"Waiting for connection close was interrupted\", ignoredIe);", "originalCommit": "728025122c8149a4d3929e66badb2b0444e477bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5ODA0Nw==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385598047", "bodyText": "I think it's ignored as it's just logged and only under the debug level. But I can rename it.", "author": "ochaloup", "createdAt": "2020-02-28T09:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NDEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NDM4MA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385084380", "bodyText": "rename ignoredIe", "author": "mmusgrov", "createdAt": "2020-02-27T12:03:37Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/recovery/Listener.java", "diffHunk": "@@ -242,16 +242,17 @@ public synchronized void stopListener()\n            }\n            try {\n                wait();\n-           } catch (InterruptedException e) {\n-               // ignore\n+           } catch (InterruptedException ignoredIe) {\n+               tsLogger.logger.debug(\"Waiting for connection close was interrupted\", ignoredIe);\n            }\n        }\n       \n        // make sure this listener thread has exited before we return\n \n        try {\n            this.join();\n-       } catch (InterruptedException ie) {\n+       } catch (InterruptedException ignoredIe) {\n+           tsLogger.logger.debug(\"Waiting to ensure the listener thread has exited was interrupted\", ignoredIe);", "originalCommit": "728025122c8149a4d3929e66badb2b0444e477bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NTcxMQ==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385085711", "bodyText": "What does foobar:0 signify?", "author": "mmusgrov", "createdAt": "2020-02-27T12:06:33Z", "path": "ArjunaCore/arjuna/tests/classes/com/hp/mwtests/ts/arjuna/recovery/RecoveryDriverUnitTest.java", "diffHunk": "@@ -46,20 +46,20 @@ public void testInvalid () throws Exception\n         try\n         {\n             rd.asynchronousScan();\n-            \n-            fail();\n+\n+            fail(\"Recovery driver asynchronously calls a non-existing host and port 'foobar:0'. Failure is expected.\");", "originalCommit": "728025122c8149a4d3929e66badb2b0444e477bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5OTA3Mw==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385599073", "bodyText": "From my understanding it's a non-existent hostname:port sequence. I think it's good point to rename it to be more descriptive.", "author": "ochaloup", "createdAt": "2020-02-28T09:48:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NTcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NjQ4MA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385086480", "bodyText": "The naming is odd. How about resetInitialState instead?", "author": "mmusgrov", "createdAt": "2020-02-27T12:08:14Z", "path": "ArjunaCore/arjuna/tests/classes/com/hp/mwtests/ts/arjuna/recovery/RecoverySocketUnitTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package com.hp.mwtests.ts.arjuna.recovery;\n+\n+import com.arjuna.ats.arjuna.common.recoveryPropertyManager;\n+import com.arjuna.ats.arjuna.recovery.RecoveryDriver;\n+import com.arjuna.ats.arjuna.recovery.RecoveryManager;\n+import org.jboss.logging.Logger;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test cases which work with a direct connection to socket where RecoveryManager listens at.\n+ */\n+public class RecoverySocketUnitTest {\n+    private static final Logger log = Logger.getLogger(RecoverySocketUnitTest.class);\n+\n+    private static boolean socketRecoveryListenerInitialState;\n+    private static int periodicRecoveryPeriodInitialState, recoveryBackoffPeriodInitialState;\n+\n+    private InetAddress recoveryManagerHost = null;\n+    private int recoveryManagerPort = 0;\n+    private RecoveryManager recoveryManager;\n+\n+    @BeforeClass\n+    public static void getInitialState() {\n+        socketRecoveryListenerInitialState = recoveryPropertyManager.getRecoveryEnvironmentBean().isRecoveryListener();\n+        periodicRecoveryPeriodInitialState =  recoveryPropertyManager.getRecoveryEnvironmentBean().getPeriodicRecoveryPeriod();\n+        recoveryBackoffPeriodInitialState = recoveryPropertyManager.getRecoveryEnvironmentBean().getRecoveryBackoffPeriod();\n+    }\n+\n+    @AfterClass\n+    public static void returnBackInitialState() {", "originalCommit": "728025122c8149a4d3929e66badb2b0444e477bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwMDQxNA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385600414", "bodyText": "+1, thanks", "author": "ochaloup", "createdAt": "2020-02-28T09:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NjQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NjgwOA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385086808", "bodyText": "Will you add more comment about why the test is waiting?", "author": "mmusgrov", "createdAt": "2020-02-27T12:08:54Z", "path": "ArjunaCore/arjuna/tests/classes/com/hp/mwtests/ts/arjuna/recovery/RecoverySocketUnitTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package com.hp.mwtests.ts.arjuna.recovery;\n+\n+import com.arjuna.ats.arjuna.common.recoveryPropertyManager;\n+import com.arjuna.ats.arjuna.recovery.RecoveryDriver;\n+import com.arjuna.ats.arjuna.recovery.RecoveryManager;\n+import org.jboss.logging.Logger;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test cases which work with a direct connection to socket where RecoveryManager listens at.\n+ */\n+public class RecoverySocketUnitTest {\n+    private static final Logger log = Logger.getLogger(RecoverySocketUnitTest.class);\n+\n+    private static boolean socketRecoveryListenerInitialState;\n+    private static int periodicRecoveryPeriodInitialState, recoveryBackoffPeriodInitialState;\n+\n+    private InetAddress recoveryManagerHost = null;\n+    private int recoveryManagerPort = 0;\n+    private RecoveryManager recoveryManager;\n+\n+    @BeforeClass\n+    public static void getInitialState() {\n+        socketRecoveryListenerInitialState = recoveryPropertyManager.getRecoveryEnvironmentBean().isRecoveryListener();\n+        periodicRecoveryPeriodInitialState =  recoveryPropertyManager.getRecoveryEnvironmentBean().getPeriodicRecoveryPeriod();\n+        recoveryBackoffPeriodInitialState = recoveryPropertyManager.getRecoveryEnvironmentBean().getRecoveryBackoffPeriod();\n+    }\n+\n+    @AfterClass\n+    public static void returnBackInitialState() {\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryListener(socketRecoveryListenerInitialState);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setPeriodicRecoveryPeriod(periodicRecoveryPeriodInitialState);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryBackoffPeriod(recoveryBackoffPeriodInitialState);\n+    }\n+\n+    @Before\n+    public void enableRecoveryListener() throws InterruptedException{\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryListener(true);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setPeriodicRecoveryPeriod(1);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryBackoffPeriod(1);\n+        recoveryManager = RecoveryManager.manager();\n+        // wait for the socket would be established\n+        Thread.sleep(50);", "originalCommit": "728025122c8149a4d3929e66badb2b0444e477bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNTA2NA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385605064", "bodyText": "Thanks. Good point. This is my omission from the prior test setup.\nThe recovery manager startup is synchronous and the waiting should not be necessary here at all.", "author": "ochaloup", "createdAt": "2020-02-28T10:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NjgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NzI1Ng==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385087256", "bodyText": "What is it returning to. More standard naming conventions would be just terminateRecoveryListener or stopRecoveryListener?", "author": "mmusgrov", "createdAt": "2020-02-27T12:09:50Z", "path": "ArjunaCore/arjuna/tests/classes/com/hp/mwtests/ts/arjuna/recovery/RecoverySocketUnitTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package com.hp.mwtests.ts.arjuna.recovery;\n+\n+import com.arjuna.ats.arjuna.common.recoveryPropertyManager;\n+import com.arjuna.ats.arjuna.recovery.RecoveryDriver;\n+import com.arjuna.ats.arjuna.recovery.RecoveryManager;\n+import org.jboss.logging.Logger;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test cases which work with a direct connection to socket where RecoveryManager listens at.\n+ */\n+public class RecoverySocketUnitTest {\n+    private static final Logger log = Logger.getLogger(RecoverySocketUnitTest.class);\n+\n+    private static boolean socketRecoveryListenerInitialState;\n+    private static int periodicRecoveryPeriodInitialState, recoveryBackoffPeriodInitialState;\n+\n+    private InetAddress recoveryManagerHost = null;\n+    private int recoveryManagerPort = 0;\n+    private RecoveryManager recoveryManager;\n+\n+    @BeforeClass\n+    public static void getInitialState() {\n+        socketRecoveryListenerInitialState = recoveryPropertyManager.getRecoveryEnvironmentBean().isRecoveryListener();\n+        periodicRecoveryPeriodInitialState =  recoveryPropertyManager.getRecoveryEnvironmentBean().getPeriodicRecoveryPeriod();\n+        recoveryBackoffPeriodInitialState = recoveryPropertyManager.getRecoveryEnvironmentBean().getRecoveryBackoffPeriod();\n+    }\n+\n+    @AfterClass\n+    public static void returnBackInitialState() {\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryListener(socketRecoveryListenerInitialState);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setPeriodicRecoveryPeriod(periodicRecoveryPeriodInitialState);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryBackoffPeriod(recoveryBackoffPeriodInitialState);\n+    }\n+\n+    @Before\n+    public void enableRecoveryListener() throws InterruptedException{\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryListener(true);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setPeriodicRecoveryPeriod(1);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryBackoffPeriod(1);\n+        recoveryManager = RecoveryManager.manager();\n+        // wait for the socket would be established\n+        Thread.sleep(50);\n+    }\n+\n+    @After\n+    public void returnStateOfRecoveryListener() {", "originalCommit": "728025122c8149a4d3929e66badb2b0444e477bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwMTE5Mg==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r385601192", "bodyText": "+1, thanks", "author": "ochaloup", "createdAt": "2020-02-28T09:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4NzI1Ng=="}], "type": "inlineReview"}, {"oid": "dbdff0a923468f777d46754439b9a3c4d1316a6d", "url": "https://github.com/jbosstm/narayana/commit/dbdff0a923468f777d46754439b9a3c4d1316a6d", "message": "[refactoring] to get more information on error states", "committedDate": "2020-02-28T09:56:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM4MzA3Nw==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386383077", "bodyText": "Is there a test where we expect the socket to time out and we verify that?", "author": "tomjenkinson", "createdAt": "2020-03-02T13:11:37Z", "path": "ArjunaCore/arjuna/tests/classes/com/hp/mwtests/ts/arjuna/recovery/RecoverySocketUnitTest.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package com.hp.mwtests.ts.arjuna.recovery;\n+\n+import com.arjuna.ats.arjuna.common.recoveryPropertyManager;\n+import com.arjuna.ats.arjuna.recovery.RecoveryDriver;\n+import com.arjuna.ats.arjuna.recovery.RecoveryManager;\n+import org.jboss.logging.Logger;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test cases which work with a direct connection to socket where RecoveryManager listens at.\n+ */\n+public class RecoverySocketUnitTest {\n+    private static final Logger log = Logger.getLogger(RecoverySocketUnitTest.class);\n+\n+    private static boolean socketRecoveryListenerInitialState;\n+    private static int periodicRecoveryPeriodInitialState, recoveryBackoffPeriodInitialState;\n+\n+    private InetAddress recoveryManagerHost = null;\n+    private int recoveryManagerPort = 0;\n+    private RecoveryManager recoveryManager;\n+\n+    @BeforeClass\n+    public static void getInitialState() {\n+        socketRecoveryListenerInitialState = recoveryPropertyManager.getRecoveryEnvironmentBean().isRecoveryListener();\n+        periodicRecoveryPeriodInitialState =  recoveryPropertyManager.getRecoveryEnvironmentBean().getPeriodicRecoveryPeriod();\n+        recoveryBackoffPeriodInitialState = recoveryPropertyManager.getRecoveryEnvironmentBean().getRecoveryBackoffPeriod();\n+    }\n+\n+    @AfterClass\n+    public static void returnBackInitialState() {\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryListener(socketRecoveryListenerInitialState);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setPeriodicRecoveryPeriod(periodicRecoveryPeriodInitialState);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryBackoffPeriod(recoveryBackoffPeriodInitialState);\n+    }\n+\n+    @Before\n+    public void enableRecoveryListener() throws InterruptedException{\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryListener(true);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setPeriodicRecoveryPeriod(1);\n+        recoveryPropertyManager.getRecoveryEnvironmentBean().setRecoveryBackoffPeriod(1);\n+        recoveryManager = RecoveryManager.manager();\n+        // wait for the socket would be established\n+        Thread.sleep(50);\n+    }\n+\n+    @After\n+    public void returnStateOfRecoveryListener() {\n+        try {\n+            recoveryManager.terminate();\n+        } catch (IllegalStateException ise) {\n+            // cannot terminate cleanly which may happen because some of the tests which terminated recovery manager before\n+            log.debugf(ise,\"Cannot terminate recovery manager. This is probably not a problem as the test may stopped it already. Check the prior errors.\");\n+        }\n+    }\n+\n+    @Test\n+    public void socketPing() throws Exception {\n+        try (Socket connectorSocket = getSocket()) {\n+            // streams to and from the RecoveryManager listener\n+            BufferedReader fromServer = new BufferedReader(new InputStreamReader(connectorSocket.getInputStream(), StandardCharsets.UTF_8));\n+            PrintWriter toServer = new PrintWriter(new OutputStreamWriter(connectorSocket.getOutputStream(), StandardCharsets.UTF_8));\n+\n+            toServer.println(RecoveryDriver.PING);\n+            toServer.flush();\n+            String stringResponse = fromServer.readLine();\n+            assertEquals(\"Expecting the correct response string for command \" + RecoveryDriver.PING, RecoveryDriver.PONG, stringResponse);\n+        } catch (final SocketTimeoutException stex) {\n+            failOnSocketTimeout(stex, RecoveryDriver.PING);", "originalCommit": "12d5da00fa4eee6dd123d2c1b43dda84c4097871", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxODkxOA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386418918", "bodyText": "No, but I can add it. Just note that the socket which times out is the one on the client side as the remote socket is the server socket which waits for a new connections.", "author": "ochaloup", "createdAt": "2020-03-02T14:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM4MzA3Nw=="}], "type": "inlineReview"}, {"oid": "5b36ec67aa39e4e0d8b8a65e8cfd324733f15dcb", "url": "https://github.com/jbosstm/narayana/commit/5b36ec67aa39e4e0d8b8a65e8cfd324733f15dcb", "message": "[JBTM-3259] fixing race condition on terminating recovery manager and socket call invocation\n\n+ refactoring to get more information on error states", "committedDate": "2020-03-02T14:19:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0Nzc1MQ==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386447751", "bodyText": "I wonder if byteman could ensure that this terminated occurs at the right time to detect that the scan has started as is being interrupted?\nAlso, should we be checking the outout from the read side to make sure the scan took place?", "author": "tomjenkinson", "createdAt": "2020-03-02T15:07:04Z", "path": "ArjunaCore/arjuna/tests/classes/com/hp/mwtests/ts/arjuna/recovery/RecoverySocketUnitTest.java", "diffHunk": "@@ -143,6 +142,35 @@ public void socketScanVerbose() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void socketScanTerminateAbruptly() throws Exception {\n+        try (Socket connectorSocket = getSocket()) {\n+            PrintWriter toServer = new PrintWriter(new OutputStreamWriter(connectorSocket.getOutputStream(), StandardCharsets.UTF_8));\n+            toServer.println(RecoveryDriver.SCAN);\n+            toServer.flush();\n+            recoveryManager.terminate();", "originalCommit": "5b36ec67aa39e4e0d8b8a65e8cfd324733f15dcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MDQ1Ng==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386860456", "bodyText": "The terminate needs to occur before the SCAN command returns back any value. Otherwise the test would not verifies about the abrupt termination.\nSure Byteman could be used. If you prefer that I can try to add some byteman test for this.\nI personally prefer here the standard \"blackbox\" test which verifies if the termination works or has some issue.", "author": "ochaloup", "createdAt": "2020-03-03T08:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0Nzc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkwNzEyMQ==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386907121", "bodyText": "I will close this discussion to move it closer to where I would most like to explore", "author": "tomjenkinson", "createdAt": "2020-03-03T09:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0Nzc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0ODgxMA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386448810", "bodyText": "Was this expected in here or in JBTM-3257?", "author": "tomjenkinson", "createdAt": "2020-03-02T15:08:50Z", "path": "ArjunaCore/arjuna/tests/classes/com/hp/mwtests/ts/arjuna/recovery/RecoverySocketUnitTest.java", "diffHunk": "@@ -143,6 +142,35 @@ public void socketScanVerbose() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void socketScanTerminateAbruptly() throws Exception {\n+        try (Socket connectorSocket = getSocket()) {\n+            PrintWriter toServer = new PrintWriter(new OutputStreamWriter(connectorSocket.getOutputStream(), StandardCharsets.UTF_8));\n+            toServer.println(RecoveryDriver.SCAN);\n+            toServer.flush();\n+            recoveryManager.terminate();\n+        } catch (final SocketTimeoutException stex) {\n+            failOnSocketTimeout(stex, RecoveryDriver.SCAN);\n+        }\n+    }\n+\n+    @Test\n+    public void socketTimeout() throws Exception {", "originalCommit": "5b36ec67aa39e4e0d8b8a65e8cfd324733f15dcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MTI3NQ==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386861275", "bodyText": "It's a general test on the socket connection so it could be here but it could be there. It does not hit the specific fixed issue. The socket times out as the input is not finished. This behaviour is the same before the fixes and after the fixes as well.\nI can move it if it's preferred.", "author": "ochaloup", "createdAt": "2020-03-03T08:28:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0ODgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkwNTgyNg==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r386905826", "bodyText": "Given your answer, I think the thing to consider is if it was part of the investigation of JBTM-3259 or JBTM-3257 and may ever want backporting or whether it is more applicable to have a separate commit as it is not directly related to either? If an additional commit is necessary I think it could be prefixed it as \"ADDITIONAL TEST ONLY:\" (like we tend to do for \"BUILD SCRIPT ONLY:\" and \"RELEASE SCRIPT ONLY:\") /cc @mmusgrov", "author": "tomjenkinson", "createdAt": "2020-03-03T09:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0ODgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA4Nzg2Nw==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r387087867", "bodyText": "@tomjenkinson I have really not much an idea what should be the result. I have had the commits separated to three. There were two commits created each for one issue, and then there was one for the maintenance changes.\nThen I was asked to squash them. So I did it.\nI really don't care how this should be done, just tell me.", "author": "ochaloup", "createdAt": "2020-03-03T15:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0ODgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA5ODYwMA==", "url": "https://github.com/jbosstm/narayana/pull/1561#discussion_r387098600", "bodyText": "Hi @ochaloup sorry! I guess I didn't understand exactly what exactly the third commit covered. Let me try to understand the other part of the thread first and I will come back here.", "author": "tomjenkinson", "createdAt": "2020-03-03T15:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0ODgxMA=="}], "type": "inlineReview"}, {"oid": "52a939e63a04ae5f7ef96643ae9fcc4945b22c5d", "url": "https://github.com/jbosstm/narayana/commit/52a939e63a04ae5f7ef96643ae9fcc4945b22c5d", "message": "[JBTM-3257] not throwing NPE when request command on recovery trigger is null", "committedDate": "2020-03-04T12:21:18Z", "type": "commit"}, {"oid": "4ed75f0aae45d6d66c7e74331baff52104cd5a98", "url": "https://github.com/jbosstm/narayana/commit/4ed75f0aae45d6d66c7e74331baff52104cd5a98", "message": "[JBTM-3259] fixing race condition on terminating recovery manager and socket call invocation", "committedDate": "2020-03-04T12:21:18Z", "type": "commit"}, {"oid": "450d3ca6d01472aaad0d7375cfbf568cda7bef5e", "url": "https://github.com/jbosstm/narayana/commit/450d3ca6d01472aaad0d7375cfbf568cda7bef5e", "message": "[REFACTORING ONLY] to get more information on error states to log and to output", "committedDate": "2020-03-04T12:21:18Z", "type": "commit"}, {"oid": "2b55a408f4967d94a1447e2cd6b486109c408abd", "url": "https://github.com/jbosstm/narayana/commit/2b55a408f4967d94a1447e2cd6b486109c408abd", "message": "[ADDITIONAL TEST ONLY] adding tests for the recovery socket calls", "committedDate": "2020-03-04T12:25:32Z", "type": "commit"}, {"oid": "2b55a408f4967d94a1447e2cd6b486109c408abd", "url": "https://github.com/jbosstm/narayana/commit/2b55a408f4967d94a1447e2cd6b486109c408abd", "message": "[ADDITIONAL TEST ONLY] adding tests for the recovery socket calls", "committedDate": "2020-03-04T12:25:32Z", "type": "forcePushed"}]}