{"pr_number": 1986, "pr_title": "PLANNER-1627: Planning Server iteration #2 (target architecture)", "pr_createdAt": "2020-01-19T17:47:28Z", "pr_url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODU0OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318548", "bodyText": "I'm not sure why this class is necessary. The same effect should be achievable by adding the following to package-info.java:\n@XmlJavaTypeAdapters({\n    @XmlJavaTypeAdapter(type = LocalDateTime.class, value = LocalDateTimeXmlAdapter.class)\n})", "author": "triceo", "createdAt": "2020-01-19T20:09:58Z", "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/LocalDateTimeValue.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import java.time.LocalDateTime;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import org.kie.internal.jaxb.LocalDateTimeXmlAdapter;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"local-date-time-value\")\n+public class LocalDateTimeValue {", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODY0Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318647", "bodyText": "10 minutes seems to me to be far too long for anything.", "author": "triceo", "createdAt": "2020-01-19T20:11:54Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.marshalling.MarshallingFormat;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeClientFactory {\n+\n+    static {\n+        // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n+        // of other users\n+        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());\n+    }\n+\n+    static KieServicesClient createKieServicesClient(final String endpoint,\n+                                                     final String login,\n+                                                     final String password) {\n+\n+        final KieServicesConfiguration configuration = KieServicesFactory.newRestConfiguration(endpoint, login, password);\n+        configuration.setTimeout(600000);", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwNjg2OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368406869", "bodyText": "good catch, it's a 60.000 instead of 600.000", "author": "wmedvede", "createdAt": "2020-01-20T07:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODcxMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318710", "bodyText": "I think you can use Collections.singletonMap().", "author": "triceo", "createdAt": "2020-01-19T20:13:02Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/helper/TaskAssigningRuntimeServicesClientBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.helper;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.kie.server.client.KieServicesConfiguration;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+import org.kie.server.client.impl.TaskAssigningRuntimeClientImpl;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeServicesClientBuilder implements KieServicesClientBuilder {\n+\n+    @Override\n+    public String getImplementedCapability() {\n+        return CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+    }\n+\n+    @Override\n+    public Map<Class<?>, Object> build(KieServicesConfiguration configuration, ClassLoader classLoader) {\n+        final Map<Class<?>, Object> services = new HashMap<>();", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODc3MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318771", "bodyText": "Can we get away with this? Is it normal that some KIE server components would not implement JMS, only REST?", "author": "triceo", "createdAt": "2020-01-19T20:13:53Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/impl/TaskAssigningRuntimeClientImpl.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.impl;\n+\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.kie.server.api.exception.KieServicesException;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.api.rest.RestURI;\n+import org.kie.server.client.KieServicesConfiguration;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_LAST_MODIFICATION_DATE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_TASK_ID;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE_SIZE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.STATUS;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.TASK_INPUT_VARIABLES_MODE;\n+import static org.kie.server.api.model.taskassigning.TaskAssigningRestURI.TASK_ASSIGNING_EXECUTE_PLANNING_URI;\n+import static org.kie.server.api.model.taskassigning.TaskAssigningRestURI.TASK_ASSIGNING_QUERIES_TASK_DATA_URI;\n+import static org.kie.server.api.model.taskassigning.TaskAssigningRestURI.TASK_ASSIGNING_RUNTIME_URI;\n+\n+public class TaskAssigningRuntimeClientImpl extends AbstractKieServicesClientImpl implements TaskAssigningRuntimeClient {\n+\n+    public TaskAssigningRuntimeClientImpl(KieServicesConfiguration config) {\n+        super(config);\n+    }\n+\n+    public TaskAssigningRuntimeClientImpl(KieServicesConfiguration config, ClassLoader classLoader) {\n+        super(config, classLoader);\n+    }\n+\n+    @Override\n+    public ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId) {\n+        if (config.isRest()) {\n+            final String uri = TASK_ASSIGNING_RUNTIME_URI + \"/\" + TASK_ASSIGNING_EXECUTE_PLANNING_URI + \"?user=\" + userId;\n+            return makeHttpPostRequestAndCreateCustomResponse(RestURI.build(loadBalancer.getUrl(),\n+                                                                            uri,\n+                                                                            Collections.emptyMap()),\n+                                                              planningItemList,\n+                                                              ExecutePlanningResult.class);\n+        } else {\n+            throw new KieServicesException(\"JMS protocol is not implemented for this service.\");", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwODM1Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368408357", "bodyText": "at this point the only protocol that is being used is REST and so will probalby happen with 95% probability for the rest of the life of this API.  Note that is api is used for consuming the tasks information and executing the plan from the KieServerPlanningExtension, and here we don't want/need JMS invocation.\nIn general I'd say that this also the for 90% of the uses of the kie-server apis, and only a reduced set of use cases/customers use JMS.\nSo by now we can live with that, but yes, in future iteration JMS alternative can be added with no problem.", "author": "wmedvede", "createdAt": "2020-01-20T08:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODk0Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318947", "bodyText": "Would you please explain (possibly in comments) the logic of this loop?", "author": "triceo", "createdAt": "2020-01-19T20:16:09Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.util;\n+\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+\n+public class TaskDataReader {\n+\n+    private TaskAssigningRuntimeClient runtimeClient;\n+\n+    private TaskDataReader(TaskAssigningRuntimeClient runtimeClient) {\n+        this.runtimeClient = runtimeClient;\n+    }\n+\n+    public static class Result {\n+\n+        LocalDateTime queryTime;\n+\n+        List<TaskData> tasks;\n+\n+        private Result(LocalDateTime queryTime, List<TaskData> tasks) {\n+            this.queryTime = queryTime;\n+            this.tasks = tasks;\n+        }\n+\n+        public LocalDateTime getQueryTime() {\n+            return queryTime;\n+        }\n+\n+        public List<TaskData> getTasks() {\n+            return tasks;\n+        }\n+    }\n+\n+    public static TaskDataReader from(TaskAssigningRuntimeClient runtimeClient) {\n+        return new TaskDataReader(runtimeClient);\n+    }\n+\n+    public Result readTasks(long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,\n+                            int pageSize, TaskInputVariablesReadMode taskInputVariablesReadMode) {\n+        final List<TaskData> result = new ArrayList<>();\n+        boolean finished = false;\n+        List<TaskData> partialResult;\n+        TaskDataList taskDataList;\n+        TaskData lastItem = null;\n+        LocalDateTime queryTime = null;\n+\n+        long taskId = fromTaskId;\n+        int nextPageSize = pageSize;\n+        while (!finished) {\n+            taskDataList = runtimeClient.findTasks(taskId, status, fromLastModificationDate,\n+                                                   0, nextPageSize, taskInputVariablesReadMode);\n+            partialResult = new ArrayList<>(taskDataList.getItems());", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwOTQ4OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368409488", "bodyText": "yes, in general the kie-server queries related APIs that iterates server side datasets are based on a paging reading. By passing the pageNumber and pageSize.\nBut here I need to read all the values, but, doing a paging reading.\nSo this loop implements \"read all values\" by getting chunks in a paged reading fashion.\nNote the for feeding the solver e.g. for creating the initial solution, we need to consume all the tasks, and not only a page.", "author": "wmedvede", "createdAt": "2020-01-20T08:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTYxMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368319610", "bodyText": "This method is very long. I think it would be good to split it into a couple sub-methods.", "author": "triceo", "createdAt": "2020-01-19T20:23:48Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionChangesBuilder.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AddTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AssignTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.ReleaseTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.RemoveTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.TaskPropertyChangeProblemFactChange;\n+import org.kie.server.services.taskassigning.user.system.api.UserSystemService;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.optaplanner.core.impl.solver.ProblemFactChange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.DUMMY_TASK_PLANNER_241;\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.PLANNING_USER;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Completed;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Error;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Exited;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Failed;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Obsolete;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+import static org.kie.server.services.taskassigning.planning.SolutionBuilder.addInOrder;\n+import static org.kie.server.services.taskassigning.planning.SolutionBuilder.fromTaskData;\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.fromExternalUser;\n+\n+/**\n+ * This class performs the calculation of the impact (i.e. the set of changes to be applied) on a solution given the\n+ * updated information about the tasks in the jBPM runtime.\n+ */\n+public class SolutionChangesBuilder {\n+\n+    private static Logger LOGGER = LoggerFactory.getLogger(SolutionChangesBuilder.class);\n+\n+    private TaskAssigningSolution solution;\n+\n+    private List<TaskData> taskDataList;\n+\n+    private UserSystemService systemService;\n+\n+    private SolverHandlerContext context;\n+\n+    public SolutionChangesBuilder() {\n+    }\n+\n+    public SolutionChangesBuilder withSolution(TaskAssigningSolution solution) {\n+        this.solution = solution;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder withTasks(List<TaskData> taskDataList) {\n+        this.taskDataList = taskDataList;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder withUserSystem(UserSystemService userSystemService) {\n+        this.systemService = userSystemService;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder withContext(SolverHandlerContext context) {\n+        this.context = context;\n+        return this;\n+    }\n+\n+    public List<ProblemFactChange<TaskAssigningSolution>> build() {", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTc1Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368319756", "bodyText": "Another very long and cryptic method.", "author": "triceo", "createdAt": "2020-01-19T20:25:26Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.function.Consumer;\n+\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.user.system.api.UserSystemService;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.services.taskassigning.user.system.api.User;\n+import org.optaplanner.core.impl.solver.ProblemFactChange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manages the periodical reading (polling strategy) of current tasks from the jBPM runtime and depending\n+ * on the \"action\" INIT_SOLVER_EXECUTOR / SYNCHRONIZE_SOLUTION determines if the solver executor must be restarted with\n+ * a fully recovered solution or instead the tasks updated information is used for calculating the required changes\n+ * for the proper solution update. If any changes are calculated they are notified to the resultConsumer.\n+ * This class implements proper retries in case of connection issues with the target jBPM runtime, etc.\n+ */\n+public class SolutionSynchronizer extends RunnableBase {\n+\n+    public static final int INIT_SOLVER_EXECUTOR = 0;\n+    public static final int SYNCHRONIZE_SOLUTION = 1;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionSynchronizer.class);\n+\n+    private final SolverExecutor solverExecutor;\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final UserSystemService userSystemService;\n+    private final long syncInterval;\n+    private final SolverHandlerContext context;\n+    private final Consumer<Result> resultConsumer;\n+    private int solverExecutorStarts = 0;\n+    private TaskAssigningSolution solution;\n+    private LocalDateTime fromLastModificationDate;\n+    private int action = INIT_SOLVER_EXECUTOR;\n+\n+    private final Semaphore startPermit = new Semaphore(0);\n+\n+    public static class Result {\n+\n+        private List<ProblemFactChange<TaskAssigningSolution>> changes;\n+\n+        public Result(List<ProblemFactChange<TaskAssigningSolution>> changes) {\n+            this.changes = changes;\n+        }\n+\n+        public List<ProblemFactChange<TaskAssigningSolution>> getChanges() {\n+            return changes;\n+        }\n+    }\n+\n+    public SolutionSynchronizer(final SolverExecutor solverExecutor,\n+                                final TaskAssigningRuntimeDelegate delegate,\n+                                final UserSystemService userSystem,\n+                                final long syncInterval,\n+                                final SolverHandlerContext context,\n+                                final Consumer<Result> resultConsumer) {\n+        checkNotNull(\"solverExecutor\", solverExecutor);\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"userSystem\", userSystem);\n+        checkCondition(\"syncInterval\", syncInterval > 0);\n+        checkNotNull(\"context\", context);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+\n+        this.solverExecutor = solverExecutor;\n+        this.delegate = delegate;\n+        this.userSystemService = userSystem;\n+        this.syncInterval = syncInterval;\n+        this.context = context;\n+        this.resultConsumer = resultConsumer;\n+    }\n+\n+    public void initSolverExecutor() {\n+        this.action = INIT_SOLVER_EXECUTOR;\n+        startPermit.release();\n+    }\n+\n+    public void synchronizeSolution(TaskAssigningSolution solution, LocalDateTime fromLastModificationDate) {\n+        this.solution = solution;\n+        this.fromLastModificationDate = fromLastModificationDate;\n+        this.action = SYNCHRONIZE_SOLUTION;\n+        LOGGER.debug(\"Start synchronizeSolution fromLastModificationDate: \" + fromLastModificationDate);\n+        startPermit.release();\n+    }\n+\n+    /**\n+     * Starts the synchronizing finalization, that will be produced as soon as possible.\n+     * It's a non thread-safe method, but only first invocation has effect.\n+     */\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        startPermit.release(); //in case it's waiting for start.\n+    }\n+\n+    @Override\n+    public void run() {", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTg1Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368319852", "bodyText": "Have you considered using the new SolverManager API? It was designed for use cases such as yours, and I think it would save you a lot of code in the parts where you run/synchronize the solver.", "author": "triceo", "createdAt": "2020-01-19T20:26:42Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.time.LocalDateTime;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+\n+public interface TaskAssigningRuntimeClient {\n+\n+    ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId);", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MjYyNw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368472627", "bodyText": "SolverManager API wasn't available/delivered at the time this development started and don't know if it's production ready right now. So it wasn't included as part of this development, and I don't see this as a priority right know. When this this version is stable, etc, I'll take a look and evaluate the benefits/drawbacks of adding it.", "author": "wmedvede", "createdAt": "2020-01-20T10:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3OTI0Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369579243", "bodyText": "It has a potential to help you get rid of a lot of code, including testing.", "author": "rsynek", "createdAt": "2020-01-22T14:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxMDk0Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370510943", "bodyText": "Guys, as I mentioned before, it took too long to setup this initial \"running\" version, and priority now is to have this version closed, ideally in this sprint. After this, improvements ad-dings are welcome, but will be incorporated in separate JIRAs, I want to have more control on this.\nThe following JIRA will track this adding\nhttps://issues.redhat.com/browse/PLANNER-1805\nThanks.", "author": "wmedvede", "createdAt": "2020-01-24T08:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyMDQwNQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368320405", "bodyText": "Did we ever consider what happens on Websphere, Weblogic and Tomcat?\n(I'm not sure we're being asked to deliver those. Traditionally, we would have been. A question for PM, perhaps?)", "author": "triceo", "createdAt": "2020-01-19T20:32:39Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/main/java/org/kie/server/services/taskassigning/user/system/simple/WildflyUtil.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.user.system.simple;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.kie.server.services.taskassigning.user.system.api.Group;\n+import org.kie.server.services.taskassigning.user.system.api.User;\n+\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+public class WildflyUtil {", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwNTUwNg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368405506", "bodyText": "I'm still pending to send the document with the configuration options, etc. Will have today.\nBut the name WildlfyUtil in this context means that the \"UserSystemServiceSimple\" implementation is a \"simple\" one, that reads the users definitions from a file with the format\nuserA=group1,group2\nuserB=group1,group3\nand so on, it's a kind of \"development\" mode user system service implementation.\nBut is not tight to any particular container.\nDeployments in other containers than WF can still use this format for \"development\", \"testing\" or even production (this last option is less likely). The only thing they have to do is to copy the configuration file in a directory that can be accessed by kie-server webapp  and configure the \"UserSystemServiceSimple\" with the parameter\n\nAs long the kie-server webapp can access the directory XXXXX it'll work.", "author": "wmedvede", "createdAt": "2020-01-20T07:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyMDQwNQ=="}], "type": "inlineReview"}, {"oid": "e3481e09293a730bebdaa38e8399cf36fefe4916", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/e3481e09293a730bebdaa38e8399cf36fefe4916", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "committedDate": "2020-01-20T16:00:56Z", "type": "forcePushed"}, {"oid": "15d5275064a5fb2238fdf246bb7a52e5ff186bba", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/15d5275064a5fb2238fdf246bb7a52e5ff186bba", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "committedDate": "2020-01-21T09:15:59Z", "type": "forcePushed"}, {"oid": "3971a9e009547e449964d8c4a91f669111db24ce", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/3971a9e009547e449964d8c4a91f669111db24ce", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "committedDate": "2020-01-21T20:20:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MTA1OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369491058", "bodyText": "This is a bit confusing. Constants names are usually all upper case.", "author": "yurloc", "createdAt": "2020-01-22T10:52:09Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.time.StopWatch;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.api.model.instance.ProcessInstance;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.util.TaskDataReader;\n+\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+\n+public class IntegrationTests {\n+\n+    private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server|http://localhost:8080/kie-server/services/rest/server\";\n+    //private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server\";\n+\n+    private static String CONTAINER_ID = \"com.myspace:test-process:1.0.0-SNAPSHOT\";\n+    private static String PROCESS_ID = \"test-process.Produce_Task_For_HR\";\n+\n+    private static List<Integer> pageSizes = Arrays.asList(3000);\n+\n+    private Map<String, StopWatch> timeRegistry = new HashMap<>();\n+\n+    private TaskAssigningRuntimeClient client;\n+\n+    @Before\n+    public void setUp() {\n+        timeRegistry.clear();\n+        client = newTaskAssigningRuntimeClient();\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    private void testFindTasksWithTaskAssigningClientTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,", "originalCommit": "3971a9e009547e449964d8c4a91f669111db24ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2NzkyMQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369967921", "bodyText": "+1 and my apologizes, this test is not part or the product code, just a local test I run for playing a bit. Will be removed as part of the review.", "author": "wmedvede", "createdAt": "2020-01-23T07:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MTA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MTYxNA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369491614", "bodyText": "Could be an enum. Btw, isn't this already available somewhere in jBPM API?", "author": "yurloc", "createdAt": "2020-01-22T10:53:20Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public class UserType {", "originalCommit": "3971a9e009547e449964d8c4a91f669111db24ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAyNTM5Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382025392", "bodyText": "I've looked, but no definition exists in jBPM API. Constants where upper-cased.", "author": "wmedvede", "createdAt": "2020-02-20T14:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MTYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MjU0Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369492542", "bodyText": "Import property name from org.kie.server.api.KieServerConstants?", "author": "yurloc", "createdAt": "2020-01-22T10:55:31Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.kie.server.api.marshalling.MarshallingFormat;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeClientFactory {\n+\n+    static {\n+        // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n+        // of other users\n+        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());", "originalCommit": "3971a9e009547e449964d8c4a91f669111db24ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "committedDate": "2020-01-22T10:30:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUxMjM1OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369512358", "bodyText": "inputParams is unused. Maybe it should be passed here?\nBtw, how do I run IntegrationTests? If I run it from IDEA I get this:\n\norg.kie.server.common.rest.NoEndpointFoundException: No available endpoints found\n\nIf I do mvn clean install the test doesn't seem to be run at all.", "author": "yurloc", "createdAt": "2020-01-22T11:42:31Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.time.StopWatch;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.api.model.instance.ProcessInstance;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.util.TaskDataReader;\n+\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+\n+public class IntegrationTests {\n+\n+    private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server|http://localhost:8080/kie-server/services/rest/server\";\n+    //private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server\";\n+\n+    private static String CONTAINER_ID = \"com.myspace:test-process:1.0.0-SNAPSHOT\";\n+    private static String PROCESS_ID = \"test-process.Produce_Task_For_HR\";\n+\n+    private static List<Integer> pageSizes = Arrays.asList(3000);\n+\n+    private Map<String, StopWatch> timeRegistry = new HashMap<>();\n+\n+    private TaskAssigningRuntimeClient client;\n+\n+    @Before\n+    public void setUp() {\n+        timeRegistry.clear();\n+        client = newTaskAssigningRuntimeClient();\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    private void testFindTasksWithTaskAssigningClientTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,\n+                                            Reserved,\n+                                            InProgress,\n+                                            Suspended);\n+\n+        registerStartTime(\"findTasks\");\n+        List<TaskData> list = client.findTasks(0L, status, null, 0, pageSize, inputVariablesReadMode).getItems();\n+        StopWatch stopWatch = registerEndTime(\"findTasks\");\n+        System.out.println(\"Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime((stopWatch)));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderNoVariables() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.DONT_READ));\n+    }\n+\n+    private void findTasksWithTasksReaderTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,\n+                                            Reserved,\n+                                            InProgress,\n+                                            Suspended);\n+\n+        registerStartTime(\"findTasks\");\n+        List<TaskData> list = TaskDataReader.from(client).readTasks(0L, status, null, pageSize, inputVariablesReadMode).getTasks();\n+        StopWatch stopWatch = registerEndTime(\"findTasks\");\n+        System.out.println(\"With TaskDataReader, Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime(stopWatch));\n+    }\n+\n+    private static String printTime(StopWatch stopWatch) {\n+        return stopWatch.toString();\n+    }\n+\n+    @Test\n+    public void createProcessInstances() {\n+\n+        int processInstancesSize = 5;\n+        List<Long> processInstances = new ArrayList<>();\n+\n+        ProcessServicesClient processServices = newKieServicesClient().getServicesClient(ProcessServicesClient.class);\n+\n+        long processInstanceId;\n+        for (int i = 0; i < processInstancesSize; i++) {\n+            HashMap inputParams = new HashMap();\n+            inputParams.put(\"processVar1\", \"generatedValue.for.taskInput1_\" + i);\n+            inputParams.put(\"processVar2\", \"generatedValue.for.taskInput2_\" + i);\n+            processInstanceId = processServices.startProcess(CONTAINER_ID, PROCESS_ID);", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNDE1Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369634156", "bodyText": "The same for me.", "author": "rsynek", "createdAt": "2020-01-22T15:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUxMjM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2ODE4MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369968181", "bodyText": "same here, this class will be removed.", "author": "wmedvede", "createdAt": "2020-01-23T07:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUxMjM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NzY2OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369577668", "bodyText": "As a part of API, would be good to put there javadoc explaining what individual values mean.", "author": "rsynek", "createdAt": "2020-01-22T14:06:15Z", "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/TaskInputVariablesReadMode.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public enum TaskInputVariablesReadMode {", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5MDg5NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382090895", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T15:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NzY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MjM0Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369582347", "bodyText": "Thinking aloud: if we wrap the kie server client, does it make sense to make the timeout configurable?", "author": "rsynek", "createdAt": "2020-01-22T14:14:34Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.kie.server.api.marshalling.MarshallingFormat;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeClientFactory {\n+\n+    static {\n+        // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n+        // of other users\n+        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());\n+    }\n+\n+    static KieServicesClient createKieServicesClient(final String endpoint,\n+                                                     final String login,\n+                                                     final String password) {\n+\n+        final KieServicesConfiguration configuration = KieServicesFactory.newRestConfiguration(endpoint, login, password);\n+        configuration.setTimeout(90000);", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5MTEyMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382091120", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T15:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MjM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU5MDUzOQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369590539", "bodyText": "The method is rather complex and sonarcloud complains about cognitive complexity going over a threshold too [1].\nThere are no tests for this method and with its complicated logic it will be very difficult to write them.\n[1] https://sonarcloud.io/component_measures?id=org.drools%3Adroolsjbpm-integration&metric=new_coverage&pullRequest=1986&selected=org.drools%3Adroolsjbpm-integration%3Ajbpm-task-assigning%2Fkie-server-client-task-assigning%2Fsrc%2Fmain%2Fjava%2Forg%2Fkie%2Fserver%2Fclient%2Futil%2FTaskDataReader.java&view=treemap", "author": "rsynek", "createdAt": "2020-01-22T14:27:46Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.util;\n+\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+\n+public class TaskDataReader {\n+\n+    private TaskAssigningRuntimeClient runtimeClient;\n+\n+    private TaskDataReader(TaskAssigningRuntimeClient runtimeClient) {\n+        this.runtimeClient = runtimeClient;\n+    }\n+\n+    public static class Result {\n+\n+        LocalDateTime queryTime;\n+\n+        List<TaskData> tasks;\n+\n+        private Result(LocalDateTime queryTime, List<TaskData> tasks) {\n+            this.queryTime = queryTime;\n+            this.tasks = tasks;\n+        }\n+\n+        public LocalDateTime getQueryTime() {\n+            return queryTime;\n+        }\n+\n+        public List<TaskData> getTasks() {\n+            return tasks;\n+        }\n+    }\n+\n+    public static TaskDataReader from(TaskAssigningRuntimeClient runtimeClient) {\n+        return new TaskDataReader(runtimeClient);\n+    }\n+\n+    public Result readTasks(long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5MTQ3Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382091472", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T15:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU5MDUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMzQ4MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369613480", "bodyText": "If there is no need to re-throw the InterruptedException, let's set the interrupted flag via Thread.interrupt().\nSee e.g. https://dzone.com/articles/understanding-thread-interruption-in-java", "author": "rsynek", "createdAt": "2020-01-22T15:04:52Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manges the processing of new a solution produced by the solver.\n+ */\n+public class SolutionProcessor extends RunnableBase {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionProcessor.class);\n+\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final Consumer<Result> resultConsumer;\n+    private final String targetUserId;\n+    private final int publishWindowSize;\n+\n+    private final Semaphore solutionResource = new Semaphore(0);\n+    private final AtomicBoolean processing = new AtomicBoolean(false);\n+\n+    private TaskAssigningSolution solution;\n+\n+    public static class Result {\n+\n+        private Exception exception;\n+\n+        private ExecutePlanningResult executeResult;\n+\n+        private Result() {\n+\n+        }\n+\n+        private Result(Exception exception) {\n+            this.exception = exception;\n+        }\n+\n+        public Result(ExecutePlanningResult executeResult) {\n+            this.executeResult = executeResult;\n+        }\n+\n+        public boolean hasException() {\n+            return exception != null;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public ExecutePlanningResult getExecuteResult() {\n+            return executeResult;\n+        }\n+    }\n+\n+    /**\n+     * @param delegate a TaskAssigningRuntimeDelegate instance for executing methods into the jBPM runtime.\n+     * @param resultConsumer a consumer for processing the results.\n+     * @param targetUserId a user identifier for using as the \"on behalf of\" user when interacting with the jBPM runtime.\n+     * @param publishWindowSize Integer value > 0 that indicates the number of tasks to be published.\n+     */\n+    public SolutionProcessor(final TaskAssigningRuntimeDelegate delegate,\n+                             final Consumer<Result> resultConsumer,\n+                             final String targetUserId,\n+                             final int publishWindowSize) {\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+        checkNotNull(\"targetUserId\", targetUserId);\n+        checkCondition(\"publishWindowSize\", publishWindowSize > 0);\n+        this.delegate = delegate;\n+        this.resultConsumer = resultConsumer;\n+        this.targetUserId = targetUserId;\n+        this.publishWindowSize = publishWindowSize;\n+    }\n+\n+    /**\n+     * @return true if a solution is being processed at this time, false in any other case.\n+     */\n+    public boolean isProcessing() {\n+        return processing.get();\n+    }\n+\n+    /**\n+     * This method is invoked form a different thread for doing the processing of a solution. This method is not\n+     * thread-safe and it's expected that any synchronization required between the isProcessing() and process()\n+     * methods is performed by the caller. Since only one solution can be processed at time, the caller should typically\n+     * execute in the following sequence.\n+     * if (!solutionProcessor.isProcessing()) {\n+     * solutionProcessor.process(solution);\n+     * } else {\n+     * //invoke at a later time.\n+     * }\n+     * A null value will throw an exception.\n+     * @param solution a solution to process.\n+     */\n+    public void process(final TaskAssigningSolution solution) {\n+        checkNotNull(\"solution\", solution);\n+        processing.set(true);\n+        this.solution = solution;\n+        solutionResource.release();\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        solutionResource.release(); //un-lock in case it was waiting for a solution to process.\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (isAlive()) {\n+            try {\n+                solutionResource.acquire();\n+                if (isAlive()) {\n+                    doProcess(solution);\n+                }\n+            } catch (InterruptedException e) {", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDE4NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369980184", "bodyText": "I'll restore the interrupted status as suggested by zonar, but I believe the flag by zonar is a \"false positive\".\nThis is what the code is doing.\n    while (isAlive()) {\n           //do something\n        } catch (InterruptedException e) {\n         //so here the code sets it self in super.destory() that will cause the \n         //the thread to have a graceful and controlled die. The interruption is  thus not hiden,\n         // and imediatelly when the whild(isAlive()) condition is checked the result is \n         // false. No risks to enter in a neverending loop ingnoring the interrupted status.\n\n            super.destroy();\n            \n            LOGGER.error(\"Solution Processor was interrupted\", e);\n        }\n    }", "author": "wmedvede", "createdAt": "2020-01-23T08:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMzQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNDgxMw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369614813", "bodyText": "Every call to LOGGER.trace will print a new trace message - with a new timestamp. I suspect we should rather format the entire solution string first and then just print it once.", "author": "rsynek", "createdAt": "2020-01-22T15:07:03Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manges the processing of new a solution produced by the solver.\n+ */\n+public class SolutionProcessor extends RunnableBase {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionProcessor.class);\n+\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final Consumer<Result> resultConsumer;\n+    private final String targetUserId;\n+    private final int publishWindowSize;\n+\n+    private final Semaphore solutionResource = new Semaphore(0);\n+    private final AtomicBoolean processing = new AtomicBoolean(false);\n+\n+    private TaskAssigningSolution solution;\n+\n+    public static class Result {\n+\n+        private Exception exception;\n+\n+        private ExecutePlanningResult executeResult;\n+\n+        private Result() {\n+\n+        }\n+\n+        private Result(Exception exception) {\n+            this.exception = exception;\n+        }\n+\n+        public Result(ExecutePlanningResult executeResult) {\n+            this.executeResult = executeResult;\n+        }\n+\n+        public boolean hasException() {\n+            return exception != null;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public ExecutePlanningResult getExecuteResult() {\n+            return executeResult;\n+        }\n+    }\n+\n+    /**\n+     * @param delegate a TaskAssigningRuntimeDelegate instance for executing methods into the jBPM runtime.\n+     * @param resultConsumer a consumer for processing the results.\n+     * @param targetUserId a user identifier for using as the \"on behalf of\" user when interacting with the jBPM runtime.\n+     * @param publishWindowSize Integer value > 0 that indicates the number of tasks to be published.\n+     */\n+    public SolutionProcessor(final TaskAssigningRuntimeDelegate delegate,\n+                             final Consumer<Result> resultConsumer,\n+                             final String targetUserId,\n+                             final int publishWindowSize) {\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+        checkNotNull(\"targetUserId\", targetUserId);\n+        checkCondition(\"publishWindowSize\", publishWindowSize > 0);\n+        this.delegate = delegate;\n+        this.resultConsumer = resultConsumer;\n+        this.targetUserId = targetUserId;\n+        this.publishWindowSize = publishWindowSize;\n+    }\n+\n+    /**\n+     * @return true if a solution is being processed at this time, false in any other case.\n+     */\n+    public boolean isProcessing() {\n+        return processing.get();\n+    }\n+\n+    /**\n+     * This method is invoked form a different thread for doing the processing of a solution. This method is not\n+     * thread-safe and it's expected that any synchronization required between the isProcessing() and process()\n+     * methods is performed by the caller. Since only one solution can be processed at time, the caller should typically\n+     * execute in the following sequence.\n+     * if (!solutionProcessor.isProcessing()) {\n+     * solutionProcessor.process(solution);\n+     * } else {\n+     * //invoke at a later time.\n+     * }\n+     * A null value will throw an exception.\n+     * @param solution a solution to process.\n+     */\n+    public void process(final TaskAssigningSolution solution) {\n+        checkNotNull(\"solution\", solution);\n+        processing.set(true);\n+        this.solution = solution;\n+        solutionResource.release();\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        solutionResource.release(); //un-lock in case it was waiting for a solution to process.\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (isAlive()) {\n+            try {\n+                solutionResource.acquire();\n+                if (isAlive()) {\n+                    doProcess(solution);\n+                }\n+            } catch (InterruptedException e) {\n+                super.destroy();\n+                LOGGER.error(\"Solution Processor was interrupted\", e);\n+            }\n+        }\n+        LOGGER.debug(\"Solution Processor finished\");\n+    }\n+\n+    private void doProcess(final TaskAssigningSolution solution) {\n+        LOGGER.debug(\"Starting processing of solution: \" + solution);\n+        final List<PlanningItem> planningItems = new ArrayList<>(solution.getTaskList().size());\n+        List<PlanningItem> userPlanningItems;\n+        Iterator<PlanningItem> userPlanningItemsIt;\n+        PlanningItem planningItem;\n+        int index;\n+        int publishedCount;\n+        for (User user : solution.getUserList()) {\n+            userPlanningItems = new ArrayList<>();\n+            index = 0;\n+            publishedCount = 0;\n+            Task nextTask = user.getNextTask();\n+\n+            while (nextTask != null) {\n+                if (IS_NOT_DUMMY.test(nextTask)) {\n+                    //dummy tasks has nothing to with the jBPM runtime, don't process them\n+                    planningItem = PlanningItem.builder()\n+                            .containerId(nextTask.getContainerId())\n+                            .taskId(nextTask.getId())\n+                            .processInstanceId(nextTask.getProcessInstanceId())\n+                            .planningTask(PlanningTask.builder()\n+                                                  .taskId(nextTask.getId())\n+                                                  .published(nextTask.isPinned())\n+                                                  .assignedUser(user.getUser().getEntityId())\n+                                                  .index(index++)\n+                                                  .build())\n+                            .build();\n+\n+                    userPlanningItems.add(planningItem);\n+                    publishedCount += planningItem.getPlanningTask().isPublished() ? 1 : 0;\n+                }\n+                nextTask = nextTask.getNextTask();\n+            }\n+            if (!IS_PLANNING_USER.test(user.getEntityId())) {\n+                userPlanningItemsIt = userPlanningItems.iterator();\n+                while (userPlanningItemsIt.hasNext() && publishedCount < publishWindowSize) {\n+                    planningItem = userPlanningItemsIt.next();\n+                    if (!planningItem.getPlanningTask().isPublished()) {\n+                        planningItem.getPlanningTask().setPublished(true);\n+                        publishedCount++;\n+                    }\n+                }\n+            }\n+            planningItems.addAll(userPlanningItems);\n+        }\n+\n+        final List<PlanningItem> publishedTasks = planningItems.stream().filter(item -> item.getPlanningTask().isPublished()).collect(Collectors.toList());\n+\n+        if (LOGGER.isTraceEnabled()) {\n+            traceSolution(solution);\n+            tracePublishedTasks(publishedTasks);\n+        }\n+\n+        Result result;\n+        try {\n+            ExecutePlanningResult executeResult = delegate.executePlanning(publishedTasks, targetUserId);\n+            result = new Result(executeResult);\n+        } catch (Exception e) {\n+            LOGGER.error(\"An error was produced during solution processing, planning execution failed.\", e);\n+            result = new Result(e);\n+        }\n+\n+        LOGGER.debug(\"Solution processing finished: \" + solution);\n+        processing.set(false);\n+        resultConsumer.accept(result);\n+    }\n+\n+    private void traceSolution(TaskAssigningSolution solution) {\n+        LOGGER.trace(\"\\n\");", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNDk1NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369614954", "bodyText": "ditto", "author": "rsynek", "createdAt": "2020-01-22T15:07:16Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manges the processing of new a solution produced by the solver.\n+ */\n+public class SolutionProcessor extends RunnableBase {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionProcessor.class);\n+\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final Consumer<Result> resultConsumer;\n+    private final String targetUserId;\n+    private final int publishWindowSize;\n+\n+    private final Semaphore solutionResource = new Semaphore(0);\n+    private final AtomicBoolean processing = new AtomicBoolean(false);\n+\n+    private TaskAssigningSolution solution;\n+\n+    public static class Result {\n+\n+        private Exception exception;\n+\n+        private ExecutePlanningResult executeResult;\n+\n+        private Result() {\n+\n+        }\n+\n+        private Result(Exception exception) {\n+            this.exception = exception;\n+        }\n+\n+        public Result(ExecutePlanningResult executeResult) {\n+            this.executeResult = executeResult;\n+        }\n+\n+        public boolean hasException() {\n+            return exception != null;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public ExecutePlanningResult getExecuteResult() {\n+            return executeResult;\n+        }\n+    }\n+\n+    /**\n+     * @param delegate a TaskAssigningRuntimeDelegate instance for executing methods into the jBPM runtime.\n+     * @param resultConsumer a consumer for processing the results.\n+     * @param targetUserId a user identifier for using as the \"on behalf of\" user when interacting with the jBPM runtime.\n+     * @param publishWindowSize Integer value > 0 that indicates the number of tasks to be published.\n+     */\n+    public SolutionProcessor(final TaskAssigningRuntimeDelegate delegate,\n+                             final Consumer<Result> resultConsumer,\n+                             final String targetUserId,\n+                             final int publishWindowSize) {\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+        checkNotNull(\"targetUserId\", targetUserId);\n+        checkCondition(\"publishWindowSize\", publishWindowSize > 0);\n+        this.delegate = delegate;\n+        this.resultConsumer = resultConsumer;\n+        this.targetUserId = targetUserId;\n+        this.publishWindowSize = publishWindowSize;\n+    }\n+\n+    /**\n+     * @return true if a solution is being processed at this time, false in any other case.\n+     */\n+    public boolean isProcessing() {\n+        return processing.get();\n+    }\n+\n+    /**\n+     * This method is invoked form a different thread for doing the processing of a solution. This method is not\n+     * thread-safe and it's expected that any synchronization required between the isProcessing() and process()\n+     * methods is performed by the caller. Since only one solution can be processed at time, the caller should typically\n+     * execute in the following sequence.\n+     * if (!solutionProcessor.isProcessing()) {\n+     * solutionProcessor.process(solution);\n+     * } else {\n+     * //invoke at a later time.\n+     * }\n+     * A null value will throw an exception.\n+     * @param solution a solution to process.\n+     */\n+    public void process(final TaskAssigningSolution solution) {\n+        checkNotNull(\"solution\", solution);\n+        processing.set(true);\n+        this.solution = solution;\n+        solutionResource.release();\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        solutionResource.release(); //un-lock in case it was waiting for a solution to process.\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (isAlive()) {\n+            try {\n+                solutionResource.acquire();\n+                if (isAlive()) {\n+                    doProcess(solution);\n+                }\n+            } catch (InterruptedException e) {\n+                super.destroy();\n+                LOGGER.error(\"Solution Processor was interrupted\", e);\n+            }\n+        }\n+        LOGGER.debug(\"Solution Processor finished\");\n+    }\n+\n+    private void doProcess(final TaskAssigningSolution solution) {\n+        LOGGER.debug(\"Starting processing of solution: \" + solution);\n+        final List<PlanningItem> planningItems = new ArrayList<>(solution.getTaskList().size());\n+        List<PlanningItem> userPlanningItems;\n+        Iterator<PlanningItem> userPlanningItemsIt;\n+        PlanningItem planningItem;\n+        int index;\n+        int publishedCount;\n+        for (User user : solution.getUserList()) {\n+            userPlanningItems = new ArrayList<>();\n+            index = 0;\n+            publishedCount = 0;\n+            Task nextTask = user.getNextTask();\n+\n+            while (nextTask != null) {\n+                if (IS_NOT_DUMMY.test(nextTask)) {\n+                    //dummy tasks has nothing to with the jBPM runtime, don't process them\n+                    planningItem = PlanningItem.builder()\n+                            .containerId(nextTask.getContainerId())\n+                            .taskId(nextTask.getId())\n+                            .processInstanceId(nextTask.getProcessInstanceId())\n+                            .planningTask(PlanningTask.builder()\n+                                                  .taskId(nextTask.getId())\n+                                                  .published(nextTask.isPinned())\n+                                                  .assignedUser(user.getUser().getEntityId())\n+                                                  .index(index++)\n+                                                  .build())\n+                            .build();\n+\n+                    userPlanningItems.add(planningItem);\n+                    publishedCount += planningItem.getPlanningTask().isPublished() ? 1 : 0;\n+                }\n+                nextTask = nextTask.getNextTask();\n+            }\n+            if (!IS_PLANNING_USER.test(user.getEntityId())) {\n+                userPlanningItemsIt = userPlanningItems.iterator();\n+                while (userPlanningItemsIt.hasNext() && publishedCount < publishWindowSize) {\n+                    planningItem = userPlanningItemsIt.next();\n+                    if (!planningItem.getPlanningTask().isPublished()) {\n+                        planningItem.getPlanningTask().setPublished(true);\n+                        publishedCount++;\n+                    }\n+                }\n+            }\n+            planningItems.addAll(userPlanningItems);\n+        }\n+\n+        final List<PlanningItem> publishedTasks = planningItems.stream().filter(item -> item.getPlanningTask().isPublished()).collect(Collectors.toList());\n+\n+        if (LOGGER.isTraceEnabled()) {\n+            traceSolution(solution);\n+            tracePublishedTasks(publishedTasks);\n+        }\n+\n+        Result result;\n+        try {\n+            ExecutePlanningResult executeResult = delegate.executePlanning(publishedTasks, targetUserId);\n+            result = new Result(executeResult);\n+        } catch (Exception e) {\n+            LOGGER.error(\"An error was produced during solution processing, planning execution failed.\", e);\n+            result = new Result(e);\n+        }\n+\n+        LOGGER.debug(\"Solution processing finished: \" + solution);\n+        processing.set(false);\n+        resultConsumer.accept(result);\n+    }\n+\n+    private void traceSolution(TaskAssigningSolution solution) {\n+        LOGGER.trace(\"\\n\");\n+        LOGGER.trace(\"*** Start of solution trace, with users = {} and tasks = {} ***\", solution.getUserList().size(), solution.getTaskList().size());\n+        for (User user : solution.getUserList()) {\n+            Task nextTask = user.getNextTask();\n+            while (nextTask != null) {\n+                LOGGER.trace(user.getEntityId() + \" -> \" + nextTask.getId() + \", pinned: \" + nextTask.isPinned() + \" priority: \" + nextTask.getPriority() + \", status: \" + nextTask.getStatus());\n+                nextTask = nextTask.getNextTask();\n+            }\n+        }\n+        LOGGER.trace(\"*** End of solution trace ***\");\n+        LOGGER.trace(\"\\n\");\n+    }\n+\n+    private void tracePublishedTasks(List<PlanningItem> publishedTasks) {", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjc0NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369622744", "bodyText": "It's more readable to invert the logic, so that you just:\nif (true.equals(...)) { return; } and the rest of the method keeps the original level of indentation.", "author": "rsynek", "createdAt": "2020-01-22T15:19:54Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java", "diffHunk": "@@ -787,6 +790,37 @@ protected EntityManagerFactory build(Map<String, String> properties) {\n         }\n     }\n \n+    private void checkAndAddTaskAssigningEntities(PersistenceUnitInfo info) {\n+        if (\"false\".equals(System.getProperty(KIE_TASK_ASSIGNING_RUNTIME_EXT_DISABLED))) {", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDEwMTg2OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370101868", "bodyText": "Inverting the condition would make it more complex because you'd have to return if the property was \"true\" or unset.\nThe way it's written now means the task assigning extension is disabled by default and must be enabled explicitly (that's probably wanted). Wouldn't be more natural to enable it like this:\n-Dorg.kie.server.taskAssigning.runtime.ext.enabled=true\n\nrather than\n-Dorg.kie.server.taskAssigning.runtime.ext.disabled=false\n\nThe double negative is a bit difficult to understand. It makes better sense to me to use a *.disabled property to disable an extension that is enabled by default and, conversely, use a *.enabled property to enable an extension that is disabled by default.\nAlso I'd suggest to use Boolean.parseBoolean() consistently because it's used on other places to parse properties. Boolean.parseBoolean() is case insensitive and so while *.disabled=FALSE might work for other properties elsewhere, it wouldn't work here, which would be surprising.", "author": "yurloc", "createdAt": "2020-01-23T12:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNDkzNw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r379534937", "bodyText": "The standard mechanism for enabling disabling extensions is\norg.kie.server.XXX.XXX.ext.disabled so I'd prefer to keep it to this extension too. Otherwise it's not straight ahead to understand how to enable/disable a particular extension.\nSo I basically vote for keeping the standard nomeclature\norg.kie.server.taskAssigning.runtime.ext.disabled\nAnd finally with the code\n\"false\".equals(System.getProperty(KIE_TASK_ASSIGNING_RUNTIME_EXT_DISABLED)\nSince this is not let's say a standard extension, I want be sure to enable it exactly when the user typed the word \"false\".\nOtherwise if we do Boolean.parse(\"truee\") we could enable the extension just because of type mistake.", "author": "wmedvede", "createdAt": "2020-02-14T16:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEwMzI0Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380103242", "bodyText": "OK, I understand your reasons for using the disabled=false form to activate the extension and agree with your approach.", "author": "yurloc", "createdAt": "2020-02-17T10:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369631960", "bodyText": "What is the purpose of this method? Is it required to register task planning JPA entities into the PersistenceContext to make them writeable into database together with jBPM classes?\nIn other words, does it serve the purpose of saving the task assignment at a safe point in a jBPM process?", "author": "rsynek", "createdAt": "2020-01-22T15:34:26Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java", "diffHunk": "@@ -787,6 +790,37 @@ protected EntityManagerFactory build(Map<String, String> properties) {\n         }\n     }\n \n+    private void checkAndAddTaskAssigningEntities(PersistenceUnitInfo info) {", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2OTY0MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369969641", "bodyText": "yes, tasks assigning incorporates one entity that we need to have in the same persistence unit as the jBPM ones. But I don't want to add it to the core jBPM entities to not add this such specific stuff there. So basically this entity is incorporated only on servers that has the tasks assigning enabled.", "author": "wmedvede", "createdAt": "2020-01-23T07:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MzA5MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370053090", "bodyText": "Would you please point me to a piece of code which effectively saves the planning model in DB?\nI doubt we should leak the task assignment implementation classes into jBPM KIE extension like here.", "author": "rsynek", "createdAt": "2020-01-23T10:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUwNzc5Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370507796", "bodyText": "sure, see here\n\n  \n    \n      droolsjbpm-integration/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/main/java/org/kie/server/services/taskassigning/runtime/TaskAssigningRuntimeServiceBase.java\n    \n    \n         Line 389\n      in\n      842cdd7\n    \n    \n    \n    \n\n        \n          \n           persistenceContext.merge(new PlanningTaskImpl(planningItem.getTaskId(),", "author": "wmedvede", "createdAt": "2020-01-24T07:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM5MTE5OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r373391198", "bodyText": "Thanks, let's talk about it in today's meeting - I don't think we should couple the persistence of jBPM and task assignment so closely.", "author": "rsynek", "createdAt": "2020-01-31T09:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAzNjE3Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370036173", "bodyText": "Should be upper case and maybe an enum.", "author": "yurloc", "createdAt": "2020-01-23T10:22:30Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/TaskStatus.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public class TaskStatus {\n+\n+    public static final String Created = \"Created\";", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0NjAxMg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370746012", "bodyText": "This is where we typically throw an exception - that's defensive programming. If, in the future, you add another value and forget to change it here, that's how you'll find out.", "author": "triceo", "createdAt": "2020-01-24T17:14:36Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionBuilder.java", "diffHunk": "@@ -127,6 +131,10 @@ public TaskAssigningSolution build() {\n                             addTaskToUser(assignedTasksByUserId, task, taskData.getActualOwner(), -1, pinned);\n                         }\n                     }\n+                    break;\n+                default:\n+                    //no other cases exists, sonar required.\n+                    break;", "originalCommit": "a31167c12ed4a67d20c60824cb8bef850b79d499", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests II", "committedDate": "2020-02-14T17:57:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA0ODk2OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380048968", "bodyText": "typo", "author": "rsynek", "createdAt": "2020-02-17T08:51:06Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/util/TaskUtil.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning.util;\n+\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.services.taskassigning.core.model.Group;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TypedLabel;\n+import org.kie.server.services.taskassigning.core.model.User;\n+\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.isUser;\n+\n+public class TaskUtil {\n+\n+    private TaskUtil() {\n+    }\n+\n+    public static Task fromTaskData(TaskData taskData) {\n+        final Task task = new Task(taskData.getTaskId(),\n+                                   taskData.getProcessInstanceId(),\n+                                   taskData.getProcessId(),\n+                                   taskData.getContainerId(),\n+                                   taskData.getName(),\n+                                   taskData.getPriority(),\n+                                   taskData.getStatus(),\n+                                   taskData.getInputData());\n+        if (taskData.getPotentialOwners() != null) {\n+            taskData.getPotentialOwners().forEach(potentialOwner -> {\n+                if (isUser(potentialOwner.getType())) {\n+                    task.getPotentialOwners().add(new User(potentialOwner.getName().hashCode(), potentialOwner.getName()));\n+                } else {\n+                    task.getPotentialOwners().add(new Group(potentialOwner.getName().hashCode(), potentialOwner.getName()));\n+                }\n+            });\n+        }\n+        //TODO expermiental for the demo", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA0OTg1NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380049855", "bodyText": "This is a candidate for a parametrized test:\nhttps://github.com/junit-team/junit4/wiki/Parameterized-tests", "author": "rsynek", "createdAt": "2020-02-17T08:53:02Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/PlanningBuilderTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Test;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.kie.server.services.taskassigning.core.model.ModelConstants.PLANNING_USER_ID;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.initializeUser;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.mockUser;\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.extractTasks;\n+\n+public class PlanningBuilderTest {", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2MTc2MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382261761", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA0OTg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NTgyMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380055820", "bodyText": "Is this delay really needed? Could the mock just do nothing?", "author": "rsynek", "createdAt": "2020-02-17T09:04:54Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionProcessorTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Test;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class SolutionProcessorTest extends RunnableBaseTest<SolutionProcessor> {\n+\n+    private static final String TARGET_USER_ID = \"TARGET_USER_ID\";\n+    private static final int PUBLISH_WINDOW_SIZE = 2;\n+\n+    private TaskAssigningRuntimeDelegate delegate;\n+\n+    @Mock\n+    private TaskAssigningRuntimeClient runtimeClient;\n+\n+    @Mock\n+    private Consumer<SolutionProcessor.Result> resultConsumer;\n+\n+    @Mock\n+    private ExecutePlanningResult result;\n+\n+    @Captor\n+    private ArgumentCaptor<SolutionProcessor.Result> resultCaptor;\n+\n+    @Mock\n+    private List<PlanningItem> generatedPlan;\n+\n+    @Override\n+    protected SolutionProcessor createRunnableBase() {\n+        delegate = spy(new TaskAssigningRuntimeDelegateMock(runtimeClient));\n+        SolutionProcessor processor = spy(new SolutionProcessor(delegate, resultConsumer, TARGET_USER_ID, PUBLISH_WINDOW_SIZE));\n+        doReturn(generatedPlan).when(processor).buildPlanning(any(), anyInt());\n+        return processor;\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    public void process() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n+        runnableBase.process(solution);\n+        assertTrue(runnableBase.isProcessing());\n+\n+        // wait while the processing is occurring.\n+        while (runnableBase.isProcessing()) {\n+            Thread.sleep(100);\n+        }\n+\n+        verify(delegate).executePlanning(generatedPlan, TARGET_USER_ID);\n+        verify(resultConsumer).accept(resultCaptor.capture());\n+        assertEquals(result, resultCaptor.getValue().getExecuteResult());\n+\n+        runnableBase.destroy();\n+        assertTrue(runnableBase.isDestroyed());\n+        future.get();\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    public void processWithFailure() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n+        runnableBase.process(solution);\n+        Assertions.assertThatThrownBy(() -> runnableBase.process(solution))\n+                .hasMessage(\"SolutionProcessor process method can only be invoked when the status is STOPPED\");\n+\n+        runnableBase.destroy();\n+        assertTrue(runnableBase.isDestroyed());\n+        future.get();\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    public void processWithDelegateError() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n+\n+        RuntimeException generatedError = new RuntimeException(\"Emulate a service invocation error.\");\n+        when(delegate.executePlanning(generatedPlan, TARGET_USER_ID)).thenThrow(generatedError);\n+\n+        runnableBase.process(solution);\n+\n+        // wait while the processing is occurring.\n+        while (runnableBase.isProcessing()) {\n+            Thread.sleep(100);\n+        }\n+\n+        verify(resultConsumer).accept(resultCaptor.capture());\n+        assertTrue(resultCaptor.getValue().hasException());\n+        assertEquals(generatedError, resultCaptor.getValue().getException());\n+\n+        runnableBase.destroy();\n+        assertTrue(runnableBase.isDestroyed());\n+        future.get();\n+    }\n+\n+    private class TaskAssigningRuntimeDelegateMock extends TaskAssigningRuntimeDelegate {\n+\n+        public TaskAssigningRuntimeDelegateMock(TaskAssigningRuntimeClient runtimeClient) {\n+            super(runtimeClient);\n+        }\n+\n+        @Override\n+        public ExecutePlanningResult executePlanning(List<PlanningItem> planningItems, String userId) {\n+            try {\n+                // emulate some time to finish\n+                Thread.sleep(500);", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2MjI5OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382262298", "bodyText": "done, moved to CountDownLatch", "author": "wmedvede", "createdAt": "2020-02-20T21:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NTgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NzcwNg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380057706", "bodyText": "Once the test is active, this Thread.sleep possibly becomes a cause of instability.", "author": "rsynek", "createdAt": "2020-02-17T09:08:59Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolverExecutorTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Semaphore;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.optaplanner.core.api.score.Score;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.event.BestSolutionChangedEvent;\n+import org.optaplanner.core.api.solver.event.SolverEventListener;\n+import org.optaplanner.core.impl.score.director.ScoreDirectorFactory;\n+import org.optaplanner.core.impl.solver.ProblemFactChange;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+public class SolverExecutorTest extends RunnableBaseTest<SolverExecutor> {\n+\n+    @Mock\n+    private SolverDef solverDef;\n+\n+    @Mock\n+    private KieServerRegistry registry;\n+\n+    private Solver<TaskAssigningSolution> solver;\n+\n+    @Mock\n+    private TaskAssigningSolution solution;\n+\n+    @Mock\n+    private SolverEventListener<TaskAssigningSolution> eventListener;\n+\n+    @Captor\n+    private ArgumentCaptor<SolverEventListener<TaskAssigningSolution>> eventListenerCaptor;\n+\n+    @Mock\n+    private BestSolutionChangedEvent<TaskAssigningSolution> event;\n+\n+    @Override\n+    protected SolverExecutor createRunnableBase() {\n+        solver = spy(new SolverMock());\n+        return new SolverExecutorMock(solverDef, registry, eventListener);\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    //TODO, In fix process. Temporary commented due to an issue probably related with JUnit.\n+    @Ignore\n+    public void start() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        runnableBase.start(solution);\n+        // give some time for the start method to execute.\n+        Thread.sleep(1000);", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2MzI5Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382263296", "bodyText": "in product, e.g. kie-server there are currently an important quantity of tests doing Thread.sleep. In general I believe this shouldn't a problem if the code is done well.\nBut anyway, this was moved to CountDownLatch", "author": "wmedvede", "createdAt": "2020-02-20T21:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NzcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2NjI4NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380066284", "bodyText": "I wonder if we could rather create some Task instances with these properties instead of creating tenths of the fields directly in the test and having methods with 8+ parameters.", "author": "rsynek", "createdAt": "2020-02-17T09:26:03Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/query/AbstractTaskAssigningDataQueryMapperTest.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.runtime.query;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.dashbuilder.dataset.DataColumn;\n+import org.dashbuilder.dataset.DataSet;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public abstract class AbstractTaskAssigningDataQueryMapperTest<T extends AbstractTaskAssigningQueryMapper<?>> {\n+\n+    /**\n+     * Task1 has planning task and potential owners.\n+     */\n+    static final Long TASK1_ID = 1L;", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA4NTc4Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380085783", "bodyText": "Does the test call this mock 3 times that it returns 3 different answers?", "author": "rsynek", "createdAt": "2020-02-17T10:01:26Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/TaskAssigningRuntimeServiceQueryHelperTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.runtime;\n+\n+import java.sql.Date;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.UserTaskService;\n+import org.jbpm.services.api.query.QueryService;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.Status;\n+import org.kie.server.api.model.KieContainerStatus;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.impl.KieContainerInstanceImpl;\n+import org.kie.server.services.taskassigning.runtime.query.AbstractTaskAssigningQueryMapper;\n+import org.kie.server.services.taskassigning.runtime.query.TaskAssigningTaskDataQueryMapper;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.stubbing.Answer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_LAST_MODIFICATION_DATE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_TASK_ID;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE_SIZE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.STATUS;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.TASK_INPUT_VARIABLES_MODE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.TO_TASK_ID;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class TaskAssigningRuntimeServiceQueryHelperTest {\n+\n+    private static final String GREATER_OR_EQUALS_TO = \"GREATER_OR_EQUALS_TO\";\n+    private static final String LOWER_OR_EQUALS_TO = \"LOWER_OR_EQUALS_TO\";\n+    private static final String EQUALS_TO = \"EQUALS_TO\";\n+\n+    private static final String FROM_LAST_MODIFICATION_STR_VALUE = \"2020-02-11T16:07:34.332\";\n+    private static final LocalDateTime FROM_LAST_MODIFICATION_VALUE = LocalDateTime.parse(FROM_LAST_MODIFICATION_STR_VALUE);\n+    private static final List<String> STATUS_VALUE = Arrays.asList(\"Ready\", \"Reserved\");\n+\n+    private static final Long FROM_TASK_ID_VALUE = 1L;\n+    private static final Long TO_TASK_ID_VALUE = 2L;\n+    private static final Integer PAGE_VALUE = 3;\n+    private static final Integer PAGE_SIZE_VALUE = 4;\n+\n+    //  Task1 is Ready and has PlanningTask\n+    private static final Long TASK1_ID = 1L;\n+    // Task2 is Reserved and doesn't have PlanningTask\n+    private static final Long TASK2_ID = 2L;\n+    // Task3 is Completed\n+    private static final Long TASK3_ID = 3L;\n+\n+    private static final Map<String, Object> TASK1_INPUTS = new HashMap<>();\n+    private static final Map<String, Object> TASK2_INPUTS = new HashMap<>();\n+    private static final Map<String, Object> TASK3_INPUTS = new HashMap<>();\n+\n+    private static final String CONTAINER_ID = \"CONTAINER_ID\";\n+\n+    @Mock\n+    private KieServerRegistry registry;\n+\n+    @Mock\n+    private QueryService queryService;\n+\n+    @Mock\n+    private UserTaskService userTaskService;\n+\n+    private TaskAssigningRuntimeServiceQueryHelper helper;\n+\n+    @Captor\n+    private ArgumentCaptor<QueryParam[]> paramsCaptor;\n+\n+    @Captor\n+    private ArgumentCaptor<QueryContext> contextCaptor;\n+\n+    @Before\n+    public void setUp() {\n+        this.helper = spy(new TaskAssigningRuntimeServiceQueryHelper(registry, userTaskService, queryService));\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadNoInputs() {\n+        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.DONT_READ);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // no inputs were loaded\n+        assertNull(result.get(0).getInputData());\n+        assertNull(result.get(1).getInputData());\n+        assertNull(result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadNoInputsByDefault() {\n+        Map<String, Object> params = prepareQuery(null);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // no inputs were loaded\n+        assertNull(result.get(0).getInputData());\n+        assertNull(result.get(1).getInputData());\n+        assertNull(result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadInputsForAll() {\n+        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.READ_FOR_ALL);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // all the inputs were loaded\n+        assertEquals(TASK1_INPUTS, result.get(0).getInputData());\n+        assertEquals(TASK2_INPUTS, result.get(1).getInputData());\n+        assertEquals(TASK3_INPUTS, result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadInputsForActiveTasks() {\n+        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.READ_FOR_ACTIVE_TASKS_WITH_NO_PLANNING_ENTITY);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // task1 is Ready and has PlanningTask\n+        assertEquals(TASK1_INPUTS, result.get(0).getInputData());\n+        // task2 is Reserved but hasn't PlanningTask\n+        assertNull(result.get(1).getInputData());\n+        // task3 is not active.\n+        assertNull(result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void readTaskDataSummary() {\n+        List<TaskData> invocation0 = mockTasks();\n+        List<TaskData> invocation1 = Arrays.asList(mockTaskData(4L), mockTaskData(5L));\n+        List<TaskData> invocation2 = Collections.singletonList(mockTaskData(6L));\n+        doAnswer(new Answer() {\n+            private int invocations = 0;\n+\n+            public Object answer(InvocationOnMock invocation) {", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwNTk5MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382105990", "bodyText": "yes, it basically emulates the consumption of all the tasks but in a paged basis", "author": "wmedvede", "createdAt": "2020-02-20T16:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA4NTc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzNzc4MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380137781", "bodyText": "This should be rather a single trace message. In such a case, StringBuilder could be more suitable for preparing the message than the BREAK function.", "author": "rsynek", "createdAt": "2020-02-17T11:51:01Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/TraceHelper.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AddTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AssignTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.ReleaseTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.RemoveTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.TaskPropertyChangeProblemFactChange;\n+import org.kie.server.services.taskassigning.planning.util.IndexedElement;\n+import org.slf4j.Logger;\n+\n+public class TraceHelper {\n+\n+    private static final Function<String, String> BREAK = (s) -> System.lineSeparator() + s;\n+    private static final String TASK_WITH_NAME_FORMAT = \" -> ({}, {})\";\n+\n+    private TraceHelper() {\n+    }\n+\n+    static void traceProgrammedChanges(Logger logger, List<RemoveTaskProblemFactChange> removedTasksChanges,\n+                                       List<ReleaseTaskProblemFactChange> releasedTasksChanges,\n+                                       Map<String, List<IndexedElement<AssignTaskProblemFactChange>>> changesByUserId,\n+                                       List<TaskPropertyChangeProblemFactChange> propertyChanges,\n+                                       List<AddTaskProblemFactChange> newTaskChanges) {\n+\n+        logger.trace(BREAK.apply(\"*** Removed tasks ***\"));\n+        logger.trace(\"Total tasks removed from solution is {}\", removedTasksChanges.size());\n+        removedTasksChanges.forEach(change -> logger.trace(TASK_WITH_NAME_FORMAT, change.getTask().getId(), change.getTask().getName()));\n+        logger.trace(\"*** End of Removed tasks ***\");", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MTgwMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380141800", "bodyText": "There are no assertions; is the test supposed to only check that no exception is thrown?", "author": "rsynek", "createdAt": "2020-02-17T12:00:29Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/test/java/org/kie/server/services/taskassigning/user/system/simple/SimpleUserSystemServiceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.user.system.simple;\n+\n+import java.net.URL;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.services.taskassigning.user.system.api.Group;\n+import org.kie.server.services.taskassigning.user.system.api.User;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.server.services.taskassigning.user.system.simple.SimpleUserSystemService.USERS_FILE_LOADING_ERROR;\n+import static org.kie.server.services.taskassigning.user.system.simple.SimpleUserSystemService.USERS_FILE_NOT_CONFIGURED_ERROR;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP1;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP2;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP3;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER1;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER2;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER3;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER4;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER5;\n+\n+public class SimpleUserSystemServiceTest {\n+\n+    private SimpleUserSystemService userSystem;\n+    private static final List<String> USERS = Arrays.asList(USER1, USER2, USER3, USER4, USER5);\n+    private static final List<String> GROUPS = Arrays.asList(GROUP1, GROUP2, GROUP3);\n+\n+    @Before\n+    public void setUp() {\n+        URL url = SimpleUserSystemServiceTest.class.getResource(WildflyUtilTest.USERS_FILE);\n+        String path = Paths.get(url.getPath()).toUri().toString();\n+        System.setProperty(SimpleUserSystemService.USERS_FILE, path);\n+        userSystem = new SimpleUserSystemService();\n+    }\n+\n+    @After\n+    public void cleanUp() {\n+        System.clearProperty(SimpleUserSystemService.USERS_FILE);\n+    }\n+\n+    @Test\n+    public void start() {\n+        userSystem.start();", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwOTI3NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382109275", "bodyText": "yes, start() checks the non failing case anyway, renamed to startSuccess\nthen we have other startXXX for testing potential failing use cases.", "author": "wmedvede", "createdAt": "2020-02-20T16:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MTgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2MzY2MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382263661", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzkxMQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380143911", "bodyText": "The constants should be in upper case; but an enum, as @yurloc suggested, is definitely preferable.", "author": "rsynek", "createdAt": "2020-02-17T12:05:18Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public class UserType {\n+\n+    private UserType() {\n+    }\n+\n+    public static final String User = \"User\";", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2Mzc0OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382263748", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEyMDQ1Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380120453", "bodyText": "Unused imports.", "author": "yurloc", "createdAt": "2020-02-17T11:09:48Z", "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/test/java/org/kie/server/api/model/taskassigning/util/StatusConverterTest.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning.util;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.Test;\n+import org.kie.api.task.model.Status;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.kie.api.task.model.Status.Completed;\n+import static org.kie.api.task.model.Status.Ready;", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2Mzg2NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382263864", "bodyText": "good catch.\ndone", "author": "wmedvede", "createdAt": "2020-02-20T21:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEyMDQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzMDYyMg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380130622", "bodyText": "Javadoc please \ud83d\ude42. Please explain what fromTaskId and fromLastModificationDate do.\nQuestions:\n\nWhy toTaskId is not here (but QueryParamName.TO_TASK_ID exists)?\nCan we use List<Status> status? Otherwise how does the user know what are the possible string values?", "author": "yurloc", "createdAt": "2020-02-17T11:33:27Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.time.LocalDateTime;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+\n+public interface TaskAssigningRuntimeClient {\n+\n+    ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId);\n+\n+    TaskDataList findTasks(Long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NDA4Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382264087", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzMDYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYwOTk0Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r384609946", "bodyText": "Exellent! Thanks.", "author": "yurloc", "createdAt": "2020-02-26T16:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzMDYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MDk3Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380140972", "bodyText": "Classes in the same package are already in kie-server-parent/kie-server-api. Why is the package split between two modules? Maybe the package in this module (jbpm-task-assigning/kie-server-api-task-assigning) is some kind of internal API or data model for the remote API whereas kie-serve-api is the Java client API? Not sure but I would recommend not to use same package name in different modules unless necessary.", "author": "yurloc", "createdAt": "2020-02-17T11:58:22Z", "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/QueryParamName.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjExMjY1MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382112650", "bodyText": "This splitting is because right now I have this development in a completely separate structure and with the aim of adding into the kie-server-parent structure the \"less as possible\". This was good for keeping this development isolated as much as possible. And there are a few classes there.\nBUT, the final destination of all this development is kie-server-parent module, so when this PR is approved next step is to move all this classes to the correspnding kie-server-api.\nSo consider this module as \"temporal\".", "author": "wmedvede", "createdAt": "2020-02-20T16:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MDk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzU2Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380143566", "bodyText": "Typo: expeted.", "author": "yurloc", "createdAt": "2020-02-17T12:04:33Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionBuilderTest.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.kie.api.task.model.Status;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+import static org.kie.api.task.model.Status.InProgress;\n+import static org.kie.api.task.model.Status.Ready;\n+import static org.kie.api.task.model.Status.Reserved;\n+import static org.kie.api.task.model.Status.Suspended;\n+import static org.kie.server.api.model.taskassigning.util.StatusConverter.convertToString;\n+import static org.kie.server.services.taskassigning.core.model.ModelConstants.DUMMY_TASK;\n+import static org.kie.server.services.taskassigning.core.model.ModelConstants.PLANNING_USER_ID;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.assertContains;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.assertNotContains;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.mockExternalUser;\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.extractTasks;\n+\n+public class SolutionBuilderTest {\n+\n+    // enabled user\n+    private static final String USER1 = \"USER1\";\n+    // disabled user\n+    private static final String USER2 = \"USER2\";\n+    // enabled user\n+    private static final String USER3 = \"USER3\";\n+    // user not present in the external users\n+    private static final String USER_NOT_PRESENT = \"USER_NOT_PRESENT\";\n+\n+    @Test\n+    public void buildAndCheckUsersWhereAdded() {\n+        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Collections.emptyList())\n+                .withUsers(externalUsers)\n+                .build();\n+\n+        assertContains(USER1, solution.getUserList());\n+        assertNotContains(USER2, solution.getUserList()); //externalUser2 is disabled.\n+        assertContains(USER3, solution.getUserList());\n+        assertContains(PLANNING_USER_ID, solution.getUserList()); //is always added.\n+        assertEquals(3, solution.getUserList().size(), 0);\n+    }\n+\n+    @Test\n+    public void buildAndCheckDummyTaskWasAdded() {\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Collections.emptyList())\n+                .withUsers(Collections.emptyList())\n+                .build();\n+        assertEquals(1, solution.getTaskList().size());\n+        assertEquals(DUMMY_TASK, solution.getTaskList().get(0));\n+    }\n+\n+    @Test\n+    public void buildAndCheckReadyTaskWasProcessedCorrect() {\n+        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n+        TaskData taskData = mockTaskData(1L, Ready);\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Collections.singletonList(taskData))\n+                .withUsers(externalUsers)\n+                .build();\n+        assertEquals(2, solution.getTaskList().size());\n+        assertContainsNotAssignedTask(taskData, solution);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Reserved, USER1), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, InProgress, USER1), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Suspended, USER1), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckTaskForNotPresentUserWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Reserved, USER_NOT_PRESENT), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), false);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedForPlanningUserTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, PLANNING_USER_ID);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), false);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedForPlanningUserTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, PLANNING_USER_ID);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), false);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAnExample() {\n+        PlanningTask planningTask1 = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData1 = mockTaskData(1L, Reserved, USER1);\n+        taskData1.setPlanningTask(planningTask1);\n+\n+        PlanningTask planningTask2 = PlanningTask.builder()\n+                .taskId(2L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(2)\n+                .build();\n+        TaskData taskData2 = mockTaskData(2L, Suspended, USER1);\n+        taskData2.setPlanningTask(planningTask2);\n+\n+        PlanningTask planningTask3 = PlanningTask.builder()\n+                .taskId(3L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(3)\n+                .build();\n+        TaskData taskData3 = mockTaskData(3L, InProgress, USER1);\n+        taskData3.setPlanningTask(planningTask3);\n+\n+        PlanningTask planningTask4 = PlanningTask.builder()\n+                .taskId(4L)\n+                .assignedUser(USER2)\n+                .published(false)\n+                .index(4)\n+                .build();\n+        TaskData taskData4 = mockTaskData(4L, InProgress, USER1);\n+        taskData4.setPlanningTask(planningTask4);\n+\n+        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Arrays.asList(taskData4, taskData1, taskData3, taskData2))\n+                .withUsers(externalUsers)\n+                .build();\n+\n+        assertEquals(5, solution.getTaskList().size());\n+        User user1 = solution.getUserList().stream()\n+                .filter(user -> user.getEntityId().equals(USER1))\n+                .findFirst().orElse(null);\n+        assertNotNull(user1);\n+        List<Task> user1Tasks = extractTasks(user1, (task) -> true);\n+        assertEquals(4L, user1Tasks.size(), 0);\n+\n+        assertExpetedTaskAtPosition(taskData2.getTaskId(), 0, true, user1Tasks);\n+        assertExpetedTaskAtPosition(taskData3.getTaskId(), 1, true, user1Tasks);\n+        assertExpetedTaskAtPosition(taskData4.getTaskId(), 2, true, user1Tasks);\n+        assertExpetedTaskAtPosition(taskData1.getTaskId(), 3, false, user1Tasks);\n+    }\n+\n+    void assertExpetedTaskAtPosition(long taskId, int position, boolean pinned, List<Task> tasks) {", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NDMyOA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382264328", "bodyText": "good catch\ndone", "author": "wmedvede", "createdAt": "2020-02-20T21:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE4NjgzMg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380186832", "bodyText": "Is there any reason for abbreviating the element names? I'd personally avoid abbreviations since the XML should be human readable (think of the documentation with REST call examples).", "author": "yurloc", "createdAt": "2020-02-17T13:39:44Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/OrganizationalEntity.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import java.util.Objects;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"tsk-assig-oe\")", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NDQ1NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382264455", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE4NjgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE4Nzg4OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380187888", "bodyText": "Redundant \"-task\".", "author": "yurloc", "createdAt": "2020-02-17T13:41:51Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/PlanningItemList.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+import org.kie.server.api.model.ItemList;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"tsk-assig-task-planning-item-list\")", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NDY2Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382264667", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE4Nzg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MjY3OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380192678", "bodyText": "Probably s/Execute/Execution/. Is this a result of a planning execution? Then it should be PlanningExecutionResult.", "author": "yurloc", "createdAt": "2020-02-17T13:50:55Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/ExecutePlanningResult.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"tsk-assig-exec-planning-result\")\n+public class ExecutePlanningResult {", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5NTIyMw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380195223", "bodyText": "Also, by looking at the class fields, it seem this only serves to report an execution error. Should the class name reflect this?", "author": "yurloc", "createdAt": "2020-02-17T13:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MjY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzMDY1NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382130654", "bodyText": "I agree with the renaming PlanningExecutionResult is better suited and I think I makes sense keep this name.", "author": "wmedvede", "createdAt": "2020-02-20T16:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MjY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NDgwNQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382264805", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MjY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5NjI1OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380196258", "bodyText": "Will this work without ExecutePlanningResult and OrganizationalEntity?", "author": "yurloc", "createdAt": "2020-02-17T13:57:35Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/marshalling/jaxb/JaxbMarshaller.java", "diffHunk": "@@ -381,13 +386,20 @@\n                 DMNDecisionInfo.class,\n                 DMNInputDataInfo.class,\n                 DMNItemDefinitionInfo.class,\n-                \n+\n                 // Kie PMML\n                 PMML4Result.class,\n                 IntegerFieldOutput.class,\n                 DoubleFieldOutput.class,\n                 StringFieldOutput.class,\n-                ScoreCard.class\n+                ScoreCard.class,\n+\n+                //TaskAssigning\n+                PlanningItem.class,\n+                PlanningItemList.class,\n+                PlanningTask.class,\n+                TaskDataList.class,\n+                TaskData.class", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NTM3OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382265379", "bodyText": "works since the missing classes are right now being sent as fields of declared ones, but good catch. done", "author": "wmedvede", "createdAt": "2020-02-20T21:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5NjI1OA=="}], "type": "inlineReview"}, {"oid": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "committedDate": "2020-02-20T20:44:47Z", "type": "commit"}, {"oid": "f797da226fee8a2b8df32bc606b869bb66f33492", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/f797da226fee8a2b8df32bc606b869bb66f33492", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests I", "committedDate": "2020-02-20T20:44:47Z", "type": "commit"}, {"oid": "6b6465776075428ebfdc3f9018be38703a7571ce", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/6b6465776075428ebfdc3f9018be38703a7571ce", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests II", "committedDate": "2020-02-20T20:44:47Z", "type": "commit"}, {"oid": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/db9e03bb968b28a37642f4b825cfe35aec2e8132", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests III", "committedDate": "2020-02-20T20:44:47Z", "type": "commit"}, {"oid": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/db9e03bb968b28a37642f4b825cfe35aec2e8132", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests III", "committedDate": "2020-02-20T20:44:47Z", "type": "forcePushed"}, {"oid": "00c0a6fb5eec3c39538f1e28c7cf478ebc674c0d", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/00c0a6fb5eec3c39538f1e28c7cf478ebc674c0d", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests IV", "committedDate": "2020-02-25T17:21:55Z", "type": "commit"}, {"oid": "aae3659cabb4a0f35d4ef6e9e7e76ec7b9e02b0f", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/aae3659cabb4a0f35d4ef6e9e7e76ec7b9e02b0f", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests V", "committedDate": "2020-02-26T09:17:25Z", "type": "commit"}]}