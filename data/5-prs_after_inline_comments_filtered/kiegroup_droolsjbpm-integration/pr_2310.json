{"pr_number": 2310, "pr_title": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "pr_createdAt": "2020-11-05T11:55:17Z", "pr_url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310", "timeline": [{"oid": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/4872bb018b6c6d3493e38edaa46a1b66777a73fd", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-11-12T11:50:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMjkxMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r522902910", "bodyText": "RH copyright is missing", "author": "afalhambra", "createdAt": "2020-11-13T11:51:49Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/ClusteredJobFailOverListener.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.kie.server.services.jbpm.cluster;", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2NjQ0Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529266443", "bodyText": "added", "author": "elguardian", "createdAt": "2020-11-24T07:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMjkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMzAxMw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r522903013", "bodyText": "RH copyright header is missing", "author": "afalhambra", "createdAt": "2020-11-13T11:52:05Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/EJBCacheInitializer.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package org.kie.server.services.jbpm.cluster;", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2NjUwNA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529266504", "bodyText": "added", "author": "elguardian", "createdAt": "2020-11-24T07:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMzAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkxMjY5Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r522912692", "bodyText": "no need to use the full qualified name of the class. Use imports section instead\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ClusterAwareService clusterService = org.kie.api.internal.utils.ServiceRegistry.getService(ClusterAwareService.class);\n          \n          \n            \n                    ClusterAwareService clusterService = ServiceRegistry.getService(ClusterAwareService.class);", "author": "afalhambra", "createdAt": "2020-11-13T12:13:20Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/EJBCacheInitializer.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.List;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Resource;\n+import javax.ejb.Singleton;\n+import javax.ejb.Startup;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.jgroups.Address;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterNode;\n+\n+@Singleton\n+@Startup\n+public class EJBCacheInitializer {\n+\n+    public static final String CACHE_NAME_LOOKUP = \"java:jboss/infinispan/container/jbpm\";\n+    \n+    public static final String CACHE_NODES_NAME_LOOKUP = \"java:jboss/infinispan/cache/jbpm/nodes\";\n+    \n+    public static final String CACHE_JOBS_NAME_LOOKUP = \"java:jboss/infinispan/cache/jbpm/jobs\";\n+    \n+    // this enforce the cache initializer\n+\n+    @Resource(lookup = CACHE_NAME_LOOKUP)\n+    private EmbeddedCacheManager cacheManager;\n+\n+    @Resource(lookup = CACHE_NODES_NAME_LOOKUP)\n+    private Cache<Address, ClusterNode> nodesCache;\n+\n+    @Resource(lookup = CACHE_JOBS_NAME_LOOKUP)\n+    private Cache<String, List<Long>> jobsCache;\n+\n+    @PostConstruct\n+    public void init() {\n+        ClusterAwareService clusterService = org.kie.api.internal.utils.ServiceRegistry.getService(ClusterAwareService.class);", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2NjY4Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529266686", "bodyText": "done", "author": "elguardian", "createdAt": "2020-11-24T07:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkxMjY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyNDgyMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r522924820", "bodyText": "This check is not needed. We're inside the loop where changeManager.isCoordinator() is true\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (cacheManager.isCoordinator()) {\n          \n          \n            \n                            // address change we remove the nodes from the cache\n          \n          \n            \n                            membersLeft.forEach(node -> nodes.remove(node));\n          \n          \n            \n                        }\n          \n          \n            \n                        // address change we remove the nodes from the cache\n          \n          \n            \n                        membersLeft.forEach(node -> nodes.remove(node));", "author": "afalhambra", "createdAt": "2020-11-13T12:39:33Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/InfinispanClusterAwareService.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.CacheCollection;\n+import org.infinispan.CacheSet;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.notifications.cachemanagerlistener.annotation.ViewChanged;\n+import org.infinispan.notifications.cachemanagerlistener.event.Event;\n+import org.infinispan.notifications.cachemanagerlistener.event.ViewChangedEvent;\n+import org.infinispan.remoting.transport.Address;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.kie.server.api.KieServerConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Listener\n+public class InfinispanClusterAwareService implements ClusterAwareService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InfinispanClusterAwareService.class);\n+\n+    private List<ClusterListener> listeners;\n+    private EmbeddedCacheManager cacheManager;\n+\n+    private String kieServerId = System.getProperty(KieServerConstants.KIE_SERVER_ID);\n+    private String kieServerLocation = System.getProperty(KieServerConstants.KIE_SERVER_LOCATION);\n+\n+    public InfinispanClusterAwareService() {\n+        listeners = new ArrayList<>();\n+    }\n+\n+    \n+    @Override\n+    public ClusterNode getThisNode() {\n+        return new ClusterNode(kieServerId, kieServerLocation);\n+    }\n+\n+    public void init(EmbeddedCacheManager cacheManager) {\n+        this.cacheManager = cacheManager;\n+        cacheManager.addListener(this);\n+        Cache<Address, ClusterNode> nodes = cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY);\n+        nodes.addListener(this);\n+        logger.info(\"This node is about to join the jBPM cluster {}-{}\", kieServerId, kieServerLocation);\n+        nodes.put(cacheManager.getAddress(), getThisNode());\n+\n+    }\n+\n+    @CacheEntryCreated\n+    public void nodeJoin(CacheEntryCreatedEvent<Address, ClusterNode> event) {\n+        if(event.isPre()) {\n+            return;\n+        }\n+        logger.info(\"jBPM cluster member joined {}\", event.getValue());\n+        synchronized (listeners) {\n+            listeners.forEach(listener -> listener.nodeJoined(event.getValue()));\n+        }\n+    }\n+\n+    @CacheEntryRemoved\n+    public void nodeLeft(CacheEntryRemovedEvent<Address, ClusterNode> event) {\n+        if(event.isPre()) {\n+            return;\n+        }\n+        logger.info(\"jBPM cluster member left {}\", event.getOldValue());\n+        synchronized (listeners) {\n+            listeners.forEach(listener -> listener.nodeLeft(event.getOldValue()));\n+        }\n+    }\n+\n+    @ViewChanged\n+    public void viewChanged(ViewChangedEvent event) {\n+        logger.info(\"jBPM cluster view changed. Current active nodes: {}\", event.getNewMembers());\n+        if (Event.Type.VIEW_CHANGED.equals(event.getType()) && cacheManager.isCoordinator()) {\n+            List<Address> changedAddress = event.getNewMembers();\n+            Cache<Address, ClusterNode> nodes = cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY);\n+            CacheSet<Address> currentView = cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY).keySet();\n+\n+            List<Address> membersLeft = currentView.stream().filter(e -> !changedAddress.contains(e)).collect(toList());\n+\n+            // forcefully removed\n+            if (cacheManager.isCoordinator()) {\n+                // address change we remove the nodes from the cache\n+                membersLeft.forEach(node -> nodes.remove(node));\n+            }", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2OTgzMg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529269832", "bodyText": "right", "author": "elguardian", "createdAt": "2020-11-24T07:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyNDgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyNzI5Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r522927297", "bodyText": "might be final\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<ClusterListener> listeners;\n          \n          \n            \n                private final List<ClusterListener> listeners;", "author": "afalhambra", "createdAt": "2020-11-13T12:44:35Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/InfinispanClusterAwareService.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.CacheCollection;\n+import org.infinispan.CacheSet;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.notifications.cachemanagerlistener.annotation.ViewChanged;\n+import org.infinispan.notifications.cachemanagerlistener.event.Event;\n+import org.infinispan.notifications.cachemanagerlistener.event.ViewChangedEvent;\n+import org.infinispan.remoting.transport.Address;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.kie.server.api.KieServerConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Listener\n+public class InfinispanClusterAwareService implements ClusterAwareService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InfinispanClusterAwareService.class);\n+\n+    private List<ClusterListener> listeners;", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2OTIwNg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529269206", "bodyText": "not needed.", "author": "elguardian", "createdAt": "2020-11-24T07:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyNzI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyNzM3NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r522927374", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-11-13T12:44:44Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/InfinispanClusterAwareService.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.CacheCollection;\n+import org.infinispan.CacheSet;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.notifications.cachemanagerlistener.annotation.ViewChanged;\n+import org.infinispan.notifications.cachemanagerlistener.event.Event;\n+import org.infinispan.notifications.cachemanagerlistener.event.ViewChangedEvent;\n+import org.infinispan.remoting.transport.Address;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.kie.server.api.KieServerConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Listener\n+public class InfinispanClusterAwareService implements ClusterAwareService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InfinispanClusterAwareService.class);\n+\n+    private List<ClusterListener> listeners;\n+    private EmbeddedCacheManager cacheManager;\n+\n+    private String kieServerId = System.getProperty(KieServerConstants.KIE_SERVER_ID);\n+    private String kieServerLocation = System.getProperty(KieServerConstants.KIE_SERVER_LOCATION);", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2OTQ1NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529269454", "bodyText": "done", "author": "elguardian", "createdAt": "2020-11-24T07:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyNzM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkzMDc3MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r522930771", "bodyText": "Do we really need these two resources here in this EJB?", "author": "afalhambra", "createdAt": "2020-11-13T12:51:54Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/EJBCacheInitializer.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.List;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Resource;\n+import javax.ejb.Singleton;\n+import javax.ejb.Startup;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.jgroups.Address;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterNode;\n+\n+@Singleton\n+@Startup\n+public class EJBCacheInitializer {\n+\n+    public static final String CACHE_NAME_LOOKUP = \"java:jboss/infinispan/container/jbpm\";\n+    \n+    public static final String CACHE_NODES_NAME_LOOKUP = \"java:jboss/infinispan/cache/jbpm/nodes\";\n+    \n+    public static final String CACHE_JOBS_NAME_LOOKUP = \"java:jboss/infinispan/cache/jbpm/jobs\";\n+    \n+    // this enforce the cache initializer\n+\n+    @Resource(lookup = CACHE_NAME_LOOKUP)\n+    private EmbeddedCacheManager cacheManager;\n+\n+    @Resource(lookup = CACHE_NODES_NAME_LOOKUP)\n+    private Cache<Address, ClusterNode> nodesCache;\n+\n+    @Resource(lookup = CACHE_JOBS_NAME_LOOKUP)\n+    private Cache<String, List<Long>> jobsCache;", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2ODg2OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529268868", "bodyText": "this is a long story. infinispan cache are started on demand in wildfly so the only way to start them (because EAGER initilization in EAP is deprecated is referencing them in the ejb.", "author": "elguardian", "createdAt": "2020-11-24T07:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkzMDc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwMDM0MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523000341", "bodyText": "node.toString() returns Cluster Node [\" +serverId \"-\" + location + \"] - so maybe it's clearer something like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Node left in cluster {} node {}, failing over and requeuing {}\", node.getServerId(), node, Arrays.toString(jobs.toArray()));\n          \n          \n            \n                    logger.info(\"Node left cluster {}, failing over and requeuing {}\", node, Arrays.toString(jobs.toArray()));", "author": "afalhambra", "createdAt": "2020-11-13T14:53:33Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/ClusteredJobFailOverListener.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.jbpm.executor.AsynchronousJobEvent;\n+import org.jbpm.executor.AsynchronousJobListener;\n+import org.jbpm.executor.RequeueAware;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusteredJobFailOverListener implements ClusterListener, AsynchronousJobListener{\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ClusteredJobFailOverListener.class);\n+\n+    private ClusterAwareService clusterService;\n+    private RequeueAware executorService;\n+    \n+    public ClusteredJobFailOverListener(ClusterAwareService clusterService, RequeueAware executorService) {\n+        this.clusterService = clusterService;\n+        this.executorService = executorService;\n+    }\n+\n+    @Override\n+    public void nodeJoined(ClusterNode node) {\n+        logger.info(\"Node joined in cluster {} node {}\", node.getServerId(), node);\n+    }\n+\n+    @Override\n+    public void nodeLeft(ClusterNode node) {\n+        // all the jobs belonging to the partition need to be requeued\n+        List<Long> jobs = clusterService.getDataFromPartition(ClusterAwareService.CLUSTER_JOBS_KEY, node.toKey());\n+        if(jobs == null || jobs.isEmpty()) {\n+            return;\n+        }\n+        if(!clusterService.isCoordinator()) {\n+            return;\n+        }\n+        logger.info(\"Node left in cluster {} node {}, failing over and requeuing {}\", node.getServerId(), node, Arrays.toString(jobs.toArray()));", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2NzU4MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529267581", "bodyText": "done", "author": "elguardian", "createdAt": "2020-11-24T07:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwMDM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwNTc0OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523005748", "bodyText": "Shouldn't this logic be placed inside afterJobCancelled method instead? What if the job is properly cancel for any reason?", "author": "afalhambra", "createdAt": "2020-11-13T15:01:32Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/ClusteredJobFailOverListener.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.jbpm.executor.AsynchronousJobEvent;\n+import org.jbpm.executor.AsynchronousJobListener;\n+import org.jbpm.executor.RequeueAware;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusteredJobFailOverListener implements ClusterListener, AsynchronousJobListener{\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ClusteredJobFailOverListener.class);\n+\n+    private ClusterAwareService clusterService;\n+    private RequeueAware executorService;\n+    \n+    public ClusteredJobFailOverListener(ClusterAwareService clusterService, RequeueAware executorService) {\n+        this.clusterService = clusterService;\n+        this.executorService = executorService;\n+    }\n+\n+    @Override\n+    public void nodeJoined(ClusterNode node) {\n+        logger.info(\"Node joined in cluster {} node {}\", node.getServerId(), node);\n+    }\n+\n+    @Override\n+    public void nodeLeft(ClusterNode node) {\n+        // all the jobs belonging to the partition need to be requeued\n+        List<Long> jobs = clusterService.getDataFromPartition(ClusterAwareService.CLUSTER_JOBS_KEY, node.toKey());\n+        if(jobs == null || jobs.isEmpty()) {\n+            return;\n+        }\n+        if(!clusterService.isCoordinator()) {\n+            return;\n+        }\n+        logger.info(\"Node left in cluster {} node {}, failing over and requeuing {}\", node.getServerId(), node, Arrays.toString(jobs.toArray()));\n+        jobs.forEach(jobId -> executorService.requeueById(jobId));\n+    }\n+\n+    @Override\n+    public void beforeJobScheduled(AsynchronousJobEvent event) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void beforeJobExecuted(AsynchronousJobEvent event) {\n+        logger.debug(\"Adding job executed {} for failover\", event);\n+        Long data = event.getJob().getId();\n+        clusterService.addData(ClusterAwareService.CLUSTER_JOBS_KEY, clusterService.getThisNode().toKey(), data);\n+    }\n+\n+    @Override\n+    public void afterJobExecuted(AsynchronousJobEvent event) {\n+        logger.info(\"Removing executed job {} from failover\", event);\n+        Long data = event.getJob().getId();\n+        clusterService.removeData(ClusterAwareService.CLUSTER_JOBS_KEY, clusterService.getThisNode().toKey(), data);\n+    }\n+\n+    @Override\n+    public void beforeJobCancelled(AsynchronousJobEvent event) {\n+        logger.debug(\"Removing cancelled job {} from failover\", event);\n+        Long data = event.getJob().getId();\n+        clusterService.removeData(ClusterAwareService.CLUSTER_JOBS_KEY, clusterService.getThisNode().toKey(), data);\n+    }", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2ODM1Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529268357", "bodyText": "right", "author": "elguardian", "createdAt": "2020-11-24T07:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwNTc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwNzAyMQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523007021", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Adding job executed {} for failover\", event);\n          \n          \n            \n                    logger.debug(\"Adding job executed {} for failover\", event.getJob());", "author": "afalhambra", "createdAt": "2020-11-13T15:03:27Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/ClusteredJobFailOverListener.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.jbpm.executor.AsynchronousJobEvent;\n+import org.jbpm.executor.AsynchronousJobListener;\n+import org.jbpm.executor.RequeueAware;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusteredJobFailOverListener implements ClusterListener, AsynchronousJobListener{\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ClusteredJobFailOverListener.class);\n+\n+    private ClusterAwareService clusterService;\n+    private RequeueAware executorService;\n+    \n+    public ClusteredJobFailOverListener(ClusterAwareService clusterService, RequeueAware executorService) {\n+        this.clusterService = clusterService;\n+        this.executorService = executorService;\n+    }\n+\n+    @Override\n+    public void nodeJoined(ClusterNode node) {\n+        logger.info(\"Node joined in cluster {} node {}\", node.getServerId(), node);\n+    }\n+\n+    @Override\n+    public void nodeLeft(ClusterNode node) {\n+        // all the jobs belonging to the partition need to be requeued\n+        List<Long> jobs = clusterService.getDataFromPartition(ClusterAwareService.CLUSTER_JOBS_KEY, node.toKey());\n+        if(jobs == null || jobs.isEmpty()) {\n+            return;\n+        }\n+        if(!clusterService.isCoordinator()) {\n+            return;\n+        }\n+        logger.info(\"Node left in cluster {} node {}, failing over and requeuing {}\", node.getServerId(), node, Arrays.toString(jobs.toArray()));\n+        jobs.forEach(jobId -> executorService.requeueById(jobId));\n+    }\n+\n+    @Override\n+    public void beforeJobScheduled(AsynchronousJobEvent event) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void beforeJobExecuted(AsynchronousJobEvent event) {\n+        logger.debug(\"Adding job executed {} for failover\", event);", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwNzQzMQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523007431", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Removing executed job {} from failover\", event);\n          \n          \n            \n                    logger.debug(\"Removing executed job {} from failover\", event.getJob());", "author": "afalhambra", "createdAt": "2020-11-13T15:04:10Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/ClusteredJobFailOverListener.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.jbpm.executor.AsynchronousJobEvent;\n+import org.jbpm.executor.AsynchronousJobListener;\n+import org.jbpm.executor.RequeueAware;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusteredJobFailOverListener implements ClusterListener, AsynchronousJobListener{\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ClusteredJobFailOverListener.class);\n+\n+    private ClusterAwareService clusterService;\n+    private RequeueAware executorService;\n+    \n+    public ClusteredJobFailOverListener(ClusterAwareService clusterService, RequeueAware executorService) {\n+        this.clusterService = clusterService;\n+        this.executorService = executorService;\n+    }\n+\n+    @Override\n+    public void nodeJoined(ClusterNode node) {\n+        logger.info(\"Node joined in cluster {} node {}\", node.getServerId(), node);\n+    }\n+\n+    @Override\n+    public void nodeLeft(ClusterNode node) {\n+        // all the jobs belonging to the partition need to be requeued\n+        List<Long> jobs = clusterService.getDataFromPartition(ClusterAwareService.CLUSTER_JOBS_KEY, node.toKey());\n+        if(jobs == null || jobs.isEmpty()) {\n+            return;\n+        }\n+        if(!clusterService.isCoordinator()) {\n+            return;\n+        }\n+        logger.info(\"Node left in cluster {} node {}, failing over and requeuing {}\", node.getServerId(), node, Arrays.toString(jobs.toArray()));\n+        jobs.forEach(jobId -> executorService.requeueById(jobId));\n+    }\n+\n+    @Override\n+    public void beforeJobScheduled(AsynchronousJobEvent event) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void beforeJobExecuted(AsynchronousJobEvent event) {\n+        logger.debug(\"Adding job executed {} for failover\", event);\n+        Long data = event.getJob().getId();\n+        clusterService.addData(ClusterAwareService.CLUSTER_JOBS_KEY, clusterService.getThisNode().toKey(), data);\n+    }\n+\n+    @Override\n+    public void afterJobExecuted(AsynchronousJobEvent event) {\n+        logger.info(\"Removing executed job {} from failover\", event);", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2Nzc4Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529267782", "bodyText": "done", "author": "elguardian", "createdAt": "2020-11-24T07:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwNzQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwNzU1Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523007553", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Removing cancelled job {} from failover\", event);\n          \n          \n            \n                    logger.debug(\"Removing cancelled job {} from failover\", event.getJob());", "author": "afalhambra", "createdAt": "2020-11-13T15:04:22Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/ClusteredJobFailOverListener.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.jbpm.executor.AsynchronousJobEvent;\n+import org.jbpm.executor.AsynchronousJobListener;\n+import org.jbpm.executor.RequeueAware;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusteredJobFailOverListener implements ClusterListener, AsynchronousJobListener{\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ClusteredJobFailOverListener.class);\n+\n+    private ClusterAwareService clusterService;\n+    private RequeueAware executorService;\n+    \n+    public ClusteredJobFailOverListener(ClusterAwareService clusterService, RequeueAware executorService) {\n+        this.clusterService = clusterService;\n+        this.executorService = executorService;\n+    }\n+\n+    @Override\n+    public void nodeJoined(ClusterNode node) {\n+        logger.info(\"Node joined in cluster {} node {}\", node.getServerId(), node);\n+    }\n+\n+    @Override\n+    public void nodeLeft(ClusterNode node) {\n+        // all the jobs belonging to the partition need to be requeued\n+        List<Long> jobs = clusterService.getDataFromPartition(ClusterAwareService.CLUSTER_JOBS_KEY, node.toKey());\n+        if(jobs == null || jobs.isEmpty()) {\n+            return;\n+        }\n+        if(!clusterService.isCoordinator()) {\n+            return;\n+        }\n+        logger.info(\"Node left in cluster {} node {}, failing over and requeuing {}\", node.getServerId(), node, Arrays.toString(jobs.toArray()));\n+        jobs.forEach(jobId -> executorService.requeueById(jobId));\n+    }\n+\n+    @Override\n+    public void beforeJobScheduled(AsynchronousJobEvent event) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void beforeJobExecuted(AsynchronousJobEvent event) {\n+        logger.debug(\"Adding job executed {} for failover\", event);\n+        Long data = event.getJob().getId();\n+        clusterService.addData(ClusterAwareService.CLUSTER_JOBS_KEY, clusterService.getThisNode().toKey(), data);\n+    }\n+\n+    @Override\n+    public void afterJobExecuted(AsynchronousJobEvent event) {\n+        logger.info(\"Removing executed job {} from failover\", event);\n+        Long data = event.getJob().getId();\n+        clusterService.removeData(ClusterAwareService.CLUSTER_JOBS_KEY, clusterService.getThisNode().toKey(), data);\n+    }\n+\n+    @Override\n+    public void beforeJobCancelled(AsynchronousJobEvent event) {\n+        logger.debug(\"Removing cancelled job {} from failover\", event);", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2Nzk1OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529267959", "bodyText": "done", "author": "elguardian", "createdAt": "2020-11-24T07:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwNzU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwOTUzNQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523009535", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ExecutionResults execute(CommandContext ctx) throws InterruptedException {\n          \n          \n            \n                @Override\n          \n          \n            \n                public ExecutionResults execute(CommandContext ctx) throws InterruptedException {", "author": "afalhambra", "createdAt": "2020-11-13T15:07:27Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/ReoccurringLongPrintOutCommand.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.Date;\n+\n+import org.kie.api.executor.Command;\n+import org.kie.api.executor.CommandContext;\n+import org.kie.api.executor.ExecutionResults;\n+import org.kie.api.executor.Reoccurring;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Simple command to log the contextual data and return empty results as reoccurring job. \n+ * Just for demo purpose.\n+ * \n+ */\n+public class ReoccurringLongPrintOutCommand implements Command, Reoccurring {\n+    \n+    private static final Logger logger = LoggerFactory.getLogger(ReoccurringLongPrintOutCommand.class);\n+\n+    public ExecutionResults execute(CommandContext ctx) throws InterruptedException {", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3MzQyMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529273420", "bodyText": "added", "author": "elguardian", "createdAt": "2020-11-24T08:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwOTUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAxOTQ5Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523019496", "bodyText": "unused import\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import org.jbpm.services.api.RuntimeDataService;", "author": "afalhambra", "createdAt": "2020-11-13T15:22:24Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/JBPMClusterKieServerExtension.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.executor.impl.ExecutorServiceImpl;\n+import org.jbpm.services.api.RuntimeDataService;", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3MDI2MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529270261", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-24T07:59:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAxOTQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNDQwMw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523024403", "bodyText": "do we want this extension to be enabled by default?", "author": "afalhambra", "createdAt": "2020-11-13T15:29:47Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/JBPMClusterKieServerExtension.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.executor.impl.ExecutorServiceImpl;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.executor.ExecutorService;\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.model.Message;\n+import org.kie.server.api.model.Severity;\n+import org.kie.server.services.api.KieContainerInstance;\n+import org.kie.server.services.api.KieServerApplicationComponentsService;\n+import org.kie.server.services.api.KieServerExtension;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.api.SupportedTransports;\n+import org.kie.server.services.impl.KieServerImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JBPMClusterKieServerExtension implements KieServerExtension {\n+\n+    public static final String EXTENSION_NAME = \"jBPM-Cluster\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(JBPMClusterKieServerExtension.class);\n+\n+    private static final Boolean disabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_CLUSTER_SERVER_EXT_DISABLED, \"false\"));", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3MDczMw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529270733", "bodyText": "it is required to install it manually because it is only avaiable for wildfly/EAP. So I would suggest to keep it that way.", "author": "elguardian", "createdAt": "2020-11-24T08:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNDQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNjgyNA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523026824", "bodyText": "not needed\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            continue;", "author": "afalhambra", "createdAt": "2020-11-13T15:33:34Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/JBPMClusterKieServerExtension.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.executor.impl.ExecutorServiceImpl;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.executor.ExecutorService;\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.model.Message;\n+import org.kie.server.api.model.Severity;\n+import org.kie.server.services.api.KieContainerInstance;\n+import org.kie.server.services.api.KieServerApplicationComponentsService;\n+import org.kie.server.services.api.KieServerExtension;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.api.SupportedTransports;\n+import org.kie.server.services.impl.KieServerImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JBPMClusterKieServerExtension implements KieServerExtension {\n+\n+    public static final String EXTENSION_NAME = \"jBPM-Cluster\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(JBPMClusterKieServerExtension.class);\n+\n+    private static final Boolean disabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_CLUSTER_SERVER_EXT_DISABLED, \"false\"));\n+    private static final Boolean jbpmDisabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_SERVER_EXT_DISABLED, \"false\"));\n+\n+    private List<Object> services = new ArrayList<Object>();\n+    private boolean initialized = false;\n+\n+    private KieServerRegistry registry;\n+\n+    private ExecutorService jbpmExecutorService;\n+    private ClusterAwareService clusterService;\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return !disabled && !jbpmDisabled;\n+    }\n+\n+    @Override\n+    public void init(KieServerImpl kieServer, KieServerRegistry registry) {\n+\n+        this.registry = registry;\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        if (jbpmExtension == null) {\n+            initialized = false;\n+            logger.warn(\"jBPM extension not found, jBPM Cluster cannot work without jBPM extension, disabling itself\");\n+            return;\n+        }\n+\n+        configureServices();\n+\n+        // this implements fail over for jobs\n+        ExecutorServiceImpl service = (ExecutorServiceImpl) jbpmExecutorService;\n+        ClusteredJobFailOverListener clusteredJobFailOverListener = new ClusteredJobFailOverListener(clusterService, service);\n+        service.addAsyncJobListener(clusteredJobFailOverListener);\n+        clusterService.addClusterListener(clusteredJobFailOverListener);\n+\n+        initialized = true;\n+    }\n+\n+    private void configureServices () {\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        List<Object> jbpmServices = jbpmExtension.getServices();\n+        \n+\n+        for (Object object : jbpmServices) {\n+            // in case given service is null (meaning was not configured) continue with next one\n+            if (object == null) {\n+                continue;\n+            }\n+            if (ExecutorService.class.isAssignableFrom(object.getClass())) {\n+                this.jbpmExecutorService = (ExecutorService) object;\n+                continue;", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3MTA4NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529271084", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-24T08:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNjgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNzQ2OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523027468", "bodyText": "we can make use of import\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    clusterService = org.kie.api.internal.utils.ServiceRegistry.getService(ClusterAwareService.class);\n          \n          \n            \n                    clusterService = ServiceRegistry.getService(ClusterAwareService.class);", "author": "afalhambra", "createdAt": "2020-11-13T15:34:28Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/JBPMClusterKieServerExtension.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.executor.impl.ExecutorServiceImpl;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.executor.ExecutorService;\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.model.Message;\n+import org.kie.server.api.model.Severity;\n+import org.kie.server.services.api.KieContainerInstance;\n+import org.kie.server.services.api.KieServerApplicationComponentsService;\n+import org.kie.server.services.api.KieServerExtension;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.api.SupportedTransports;\n+import org.kie.server.services.impl.KieServerImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JBPMClusterKieServerExtension implements KieServerExtension {\n+\n+    public static final String EXTENSION_NAME = \"jBPM-Cluster\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(JBPMClusterKieServerExtension.class);\n+\n+    private static final Boolean disabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_CLUSTER_SERVER_EXT_DISABLED, \"false\"));\n+    private static final Boolean jbpmDisabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_SERVER_EXT_DISABLED, \"false\"));\n+\n+    private List<Object> services = new ArrayList<Object>();\n+    private boolean initialized = false;\n+\n+    private KieServerRegistry registry;\n+\n+    private ExecutorService jbpmExecutorService;\n+    private ClusterAwareService clusterService;\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return !disabled && !jbpmDisabled;\n+    }\n+\n+    @Override\n+    public void init(KieServerImpl kieServer, KieServerRegistry registry) {\n+\n+        this.registry = registry;\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        if (jbpmExtension == null) {\n+            initialized = false;\n+            logger.warn(\"jBPM extension not found, jBPM Cluster cannot work without jBPM extension, disabling itself\");\n+            return;\n+        }\n+\n+        configureServices();\n+\n+        // this implements fail over for jobs\n+        ExecutorServiceImpl service = (ExecutorServiceImpl) jbpmExecutorService;\n+        ClusteredJobFailOverListener clusteredJobFailOverListener = new ClusteredJobFailOverListener(clusterService, service);\n+        service.addAsyncJobListener(clusteredJobFailOverListener);\n+        clusterService.addClusterListener(clusteredJobFailOverListener);\n+\n+        initialized = true;\n+    }\n+\n+    private void configureServices () {\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        List<Object> jbpmServices = jbpmExtension.getServices();\n+        \n+\n+        for (Object object : jbpmServices) {\n+            // in case given service is null (meaning was not configured) continue with next one\n+            if (object == null) {\n+                continue;\n+            }\n+            if (ExecutorService.class.isAssignableFrom(object.getClass())) {\n+                this.jbpmExecutorService = (ExecutorService) object;\n+                continue;\n+            } \n+        }\n+\n+        clusterService = org.kie.api.internal.utils.ServiceRegistry.getService(ClusterAwareService.class);", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3MTYwOA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529271608", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-24T08:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNzQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMDQwNA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523030404", "bodyText": "this code is not needed", "author": "afalhambra", "createdAt": "2020-11-13T15:39:11Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/JBPMClusterKieServerExtension.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.executor.impl.ExecutorServiceImpl;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.executor.ExecutorService;\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.model.Message;\n+import org.kie.server.api.model.Severity;\n+import org.kie.server.services.api.KieContainerInstance;\n+import org.kie.server.services.api.KieServerApplicationComponentsService;\n+import org.kie.server.services.api.KieServerExtension;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.api.SupportedTransports;\n+import org.kie.server.services.impl.KieServerImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JBPMClusterKieServerExtension implements KieServerExtension {\n+\n+    public static final String EXTENSION_NAME = \"jBPM-Cluster\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(JBPMClusterKieServerExtension.class);\n+\n+    private static final Boolean disabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_CLUSTER_SERVER_EXT_DISABLED, \"false\"));\n+    private static final Boolean jbpmDisabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_SERVER_EXT_DISABLED, \"false\"));\n+\n+    private List<Object> services = new ArrayList<Object>();\n+    private boolean initialized = false;\n+\n+    private KieServerRegistry registry;\n+\n+    private ExecutorService jbpmExecutorService;\n+    private ClusterAwareService clusterService;\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return !disabled && !jbpmDisabled;\n+    }\n+\n+    @Override\n+    public void init(KieServerImpl kieServer, KieServerRegistry registry) {\n+\n+        this.registry = registry;\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        if (jbpmExtension == null) {\n+            initialized = false;\n+            logger.warn(\"jBPM extension not found, jBPM Cluster cannot work without jBPM extension, disabling itself\");\n+            return;\n+        }\n+\n+        configureServices();\n+\n+        // this implements fail over for jobs\n+        ExecutorServiceImpl service = (ExecutorServiceImpl) jbpmExecutorService;\n+        ClusteredJobFailOverListener clusteredJobFailOverListener = new ClusteredJobFailOverListener(clusterService, service);\n+        service.addAsyncJobListener(clusteredJobFailOverListener);\n+        clusterService.addClusterListener(clusteredJobFailOverListener);\n+\n+        initialized = true;\n+    }\n+\n+    private void configureServices () {\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        List<Object> jbpmServices = jbpmExtension.getServices();\n+        \n+\n+        for (Object object : jbpmServices) {\n+            // in case given service is null (meaning was not configured) continue with next one\n+            if (object == null) {\n+                continue;\n+            }\n+            if (ExecutorService.class.isAssignableFrom(object.getClass())) {\n+                this.jbpmExecutorService = (ExecutorService) object;\n+                continue;\n+            } \n+        }\n+\n+        clusterService = org.kie.api.internal.utils.ServiceRegistry.getService(ClusterAwareService.class);\n+    }\n+    \n+    @Override\n+    public void destroy(KieServerImpl kieServer, KieServerRegistry registry) {\n+        if (!initialized) {\n+            return;\n+        }", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3MTg5NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529271895", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-24T08:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMDQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMDQ3Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523030476", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-11-13T15:39:19Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/JBPMClusterKieServerExtension.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.executor.impl.ExecutorServiceImpl;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.executor.ExecutorService;\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.model.Message;\n+import org.kie.server.api.model.Severity;\n+import org.kie.server.services.api.KieContainerInstance;\n+import org.kie.server.services.api.KieServerApplicationComponentsService;\n+import org.kie.server.services.api.KieServerExtension;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.api.SupportedTransports;\n+import org.kie.server.services.impl.KieServerImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JBPMClusterKieServerExtension implements KieServerExtension {\n+\n+    public static final String EXTENSION_NAME = \"jBPM-Cluster\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(JBPMClusterKieServerExtension.class);\n+\n+    private static final Boolean disabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_CLUSTER_SERVER_EXT_DISABLED, \"false\"));\n+    private static final Boolean jbpmDisabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_SERVER_EXT_DISABLED, \"false\"));\n+\n+    private List<Object> services = new ArrayList<Object>();\n+    private boolean initialized = false;\n+\n+    private KieServerRegistry registry;\n+\n+    private ExecutorService jbpmExecutorService;\n+    private ClusterAwareService clusterService;\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return !disabled && !jbpmDisabled;\n+    }\n+\n+    @Override\n+    public void init(KieServerImpl kieServer, KieServerRegistry registry) {\n+\n+        this.registry = registry;\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        if (jbpmExtension == null) {\n+            initialized = false;\n+            logger.warn(\"jBPM extension not found, jBPM Cluster cannot work without jBPM extension, disabling itself\");\n+            return;\n+        }\n+\n+        configureServices();\n+\n+        // this implements fail over for jobs\n+        ExecutorServiceImpl service = (ExecutorServiceImpl) jbpmExecutorService;\n+        ClusteredJobFailOverListener clusteredJobFailOverListener = new ClusteredJobFailOverListener(clusterService, service);\n+        service.addAsyncJobListener(clusteredJobFailOverListener);\n+        clusterService.addClusterListener(clusteredJobFailOverListener);\n+\n+        initialized = true;\n+    }\n+\n+    private void configureServices () {\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        List<Object> jbpmServices = jbpmExtension.getServices();\n+        \n+\n+        for (Object object : jbpmServices) {\n+            // in case given service is null (meaning was not configured) continue with next one\n+            if (object == null) {\n+                continue;\n+            }\n+            if (ExecutorService.class.isAssignableFrom(object.getClass())) {\n+                this.jbpmExecutorService = (ExecutorService) object;\n+                continue;\n+            } \n+        }\n+\n+        clusterService = org.kie.api.internal.utils.ServiceRegistry.getService(ClusterAwareService.class);\n+    }\n+    \n+    @Override\n+    public void destroy(KieServerImpl kieServer, KieServerRegistry registry) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void createContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        if (!initialized) {\n+            return;\n+        }", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3MTk0OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529271949", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-24T08:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMDQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMTIzNw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523031237", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-11-13T15:40:24Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/JBPMClusterKieServerExtension.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.executor.impl.ExecutorServiceImpl;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.executor.ExecutorService;\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.model.Message;\n+import org.kie.server.api.model.Severity;\n+import org.kie.server.services.api.KieContainerInstance;\n+import org.kie.server.services.api.KieServerApplicationComponentsService;\n+import org.kie.server.services.api.KieServerExtension;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.api.SupportedTransports;\n+import org.kie.server.services.impl.KieServerImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JBPMClusterKieServerExtension implements KieServerExtension {\n+\n+    public static final String EXTENSION_NAME = \"jBPM-Cluster\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(JBPMClusterKieServerExtension.class);\n+\n+    private static final Boolean disabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_CLUSTER_SERVER_EXT_DISABLED, \"false\"));\n+    private static final Boolean jbpmDisabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_SERVER_EXT_DISABLED, \"false\"));\n+\n+    private List<Object> services = new ArrayList<Object>();\n+    private boolean initialized = false;\n+\n+    private KieServerRegistry registry;\n+\n+    private ExecutorService jbpmExecutorService;\n+    private ClusterAwareService clusterService;\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return !disabled && !jbpmDisabled;\n+    }\n+\n+    @Override\n+    public void init(KieServerImpl kieServer, KieServerRegistry registry) {\n+\n+        this.registry = registry;\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        if (jbpmExtension == null) {\n+            initialized = false;\n+            logger.warn(\"jBPM extension not found, jBPM Cluster cannot work without jBPM extension, disabling itself\");\n+            return;\n+        }\n+\n+        configureServices();\n+\n+        // this implements fail over for jobs\n+        ExecutorServiceImpl service = (ExecutorServiceImpl) jbpmExecutorService;\n+        ClusteredJobFailOverListener clusteredJobFailOverListener = new ClusteredJobFailOverListener(clusterService, service);\n+        service.addAsyncJobListener(clusteredJobFailOverListener);\n+        clusterService.addClusterListener(clusteredJobFailOverListener);\n+\n+        initialized = true;\n+    }\n+\n+    private void configureServices () {\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        List<Object> jbpmServices = jbpmExtension.getServices();\n+        \n+\n+        for (Object object : jbpmServices) {\n+            // in case given service is null (meaning was not configured) continue with next one\n+            if (object == null) {\n+                continue;\n+            }\n+            if (ExecutorService.class.isAssignableFrom(object.getClass())) {\n+                this.jbpmExecutorService = (ExecutorService) object;\n+                continue;\n+            } \n+        }\n+\n+        clusterService = org.kie.api.internal.utils.ServiceRegistry.getService(ClusterAwareService.class);\n+    }\n+    \n+    @Override\n+    public void destroy(KieServerImpl kieServer, KieServerRegistry registry) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void createContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void updateContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        // recreate configuration for updated container\n+        disposeContainer(id, kieContainerInstance, parameters);\n+        createContainer(id, kieContainerInstance, parameters);", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3MjE2Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529272166", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-24T08:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMTIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMTMyMw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523031323", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-11-13T15:40:32Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/JBPMClusterKieServerExtension.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.executor.impl.ExecutorServiceImpl;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.executor.ExecutorService;\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.model.Message;\n+import org.kie.server.api.model.Severity;\n+import org.kie.server.services.api.KieContainerInstance;\n+import org.kie.server.services.api.KieServerApplicationComponentsService;\n+import org.kie.server.services.api.KieServerExtension;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.api.SupportedTransports;\n+import org.kie.server.services.impl.KieServerImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JBPMClusterKieServerExtension implements KieServerExtension {\n+\n+    public static final String EXTENSION_NAME = \"jBPM-Cluster\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(JBPMClusterKieServerExtension.class);\n+\n+    private static final Boolean disabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_CLUSTER_SERVER_EXT_DISABLED, \"false\"));\n+    private static final Boolean jbpmDisabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_SERVER_EXT_DISABLED, \"false\"));\n+\n+    private List<Object> services = new ArrayList<Object>();\n+    private boolean initialized = false;\n+\n+    private KieServerRegistry registry;\n+\n+    private ExecutorService jbpmExecutorService;\n+    private ClusterAwareService clusterService;\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return !disabled && !jbpmDisabled;\n+    }\n+\n+    @Override\n+    public void init(KieServerImpl kieServer, KieServerRegistry registry) {\n+\n+        this.registry = registry;\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        if (jbpmExtension == null) {\n+            initialized = false;\n+            logger.warn(\"jBPM extension not found, jBPM Cluster cannot work without jBPM extension, disabling itself\");\n+            return;\n+        }\n+\n+        configureServices();\n+\n+        // this implements fail over for jobs\n+        ExecutorServiceImpl service = (ExecutorServiceImpl) jbpmExecutorService;\n+        ClusteredJobFailOverListener clusteredJobFailOverListener = new ClusteredJobFailOverListener(clusterService, service);\n+        service.addAsyncJobListener(clusteredJobFailOverListener);\n+        clusterService.addClusterListener(clusteredJobFailOverListener);\n+\n+        initialized = true;\n+    }\n+\n+    private void configureServices () {\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        List<Object> jbpmServices = jbpmExtension.getServices();\n+        \n+\n+        for (Object object : jbpmServices) {\n+            // in case given service is null (meaning was not configured) continue with next one\n+            if (object == null) {\n+                continue;\n+            }\n+            if (ExecutorService.class.isAssignableFrom(object.getClass())) {\n+                this.jbpmExecutorService = (ExecutorService) object;\n+                continue;\n+            } \n+        }\n+\n+        clusterService = org.kie.api.internal.utils.ServiceRegistry.getService(ClusterAwareService.class);\n+    }\n+    \n+    @Override\n+    public void destroy(KieServerImpl kieServer, KieServerRegistry registry) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void createContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void updateContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        // recreate configuration for updated container\n+        disposeContainer(id, kieContainerInstance, parameters);\n+        createContainer(id, kieContainerInstance, parameters);\n+    }\n+\n+    @Override\n+    public boolean isUpdateContainerAllowed(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void disposeContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        if (!initialized) {\n+            return;\n+        }", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3MjIzMg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529272232", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-24T08:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMTMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMjU4OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523032589", "bodyText": "not needed\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!initialized) {\n          \n          \n            \n                        return null;\n          \n          \n            \n                    }", "author": "afalhambra", "createdAt": "2020-11-13T15:42:34Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/JBPMClusterKieServerExtension.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.executor.impl.ExecutorServiceImpl;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.executor.ExecutorService;\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.model.Message;\n+import org.kie.server.api.model.Severity;\n+import org.kie.server.services.api.KieContainerInstance;\n+import org.kie.server.services.api.KieServerApplicationComponentsService;\n+import org.kie.server.services.api.KieServerExtension;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.api.SupportedTransports;\n+import org.kie.server.services.impl.KieServerImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JBPMClusterKieServerExtension implements KieServerExtension {\n+\n+    public static final String EXTENSION_NAME = \"jBPM-Cluster\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(JBPMClusterKieServerExtension.class);\n+\n+    private static final Boolean disabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_CLUSTER_SERVER_EXT_DISABLED, \"false\"));\n+    private static final Boolean jbpmDisabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_SERVER_EXT_DISABLED, \"false\"));\n+\n+    private List<Object> services = new ArrayList<Object>();\n+    private boolean initialized = false;\n+\n+    private KieServerRegistry registry;\n+\n+    private ExecutorService jbpmExecutorService;\n+    private ClusterAwareService clusterService;\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return !disabled && !jbpmDisabled;\n+    }\n+\n+    @Override\n+    public void init(KieServerImpl kieServer, KieServerRegistry registry) {\n+\n+        this.registry = registry;\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        if (jbpmExtension == null) {\n+            initialized = false;\n+            logger.warn(\"jBPM extension not found, jBPM Cluster cannot work without jBPM extension, disabling itself\");\n+            return;\n+        }\n+\n+        configureServices();\n+\n+        // this implements fail over for jobs\n+        ExecutorServiceImpl service = (ExecutorServiceImpl) jbpmExecutorService;\n+        ClusteredJobFailOverListener clusteredJobFailOverListener = new ClusteredJobFailOverListener(clusterService, service);\n+        service.addAsyncJobListener(clusteredJobFailOverListener);\n+        clusterService.addClusterListener(clusteredJobFailOverListener);\n+\n+        initialized = true;\n+    }\n+\n+    private void configureServices () {\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        List<Object> jbpmServices = jbpmExtension.getServices();\n+        \n+\n+        for (Object object : jbpmServices) {\n+            // in case given service is null (meaning was not configured) continue with next one\n+            if (object == null) {\n+                continue;\n+            }\n+            if (ExecutorService.class.isAssignableFrom(object.getClass())) {\n+                this.jbpmExecutorService = (ExecutorService) object;\n+                continue;\n+            } \n+        }\n+\n+        clusterService = org.kie.api.internal.utils.ServiceRegistry.getService(ClusterAwareService.class);\n+    }\n+    \n+    @Override\n+    public void destroy(KieServerImpl kieServer, KieServerRegistry registry) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void createContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void updateContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        // recreate configuration for updated container\n+        disposeContainer(id, kieContainerInstance, parameters);\n+        createContainer(id, kieContainerInstance, parameters);\n+    }\n+\n+    @Override\n+    public boolean isUpdateContainerAllowed(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void disposeContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public List<Object> getAppComponents(SupportedTransports type) {\n+        List<Object> appComponentsList = new ArrayList<Object>();\n+        if (!initialized) {\n+            return appComponentsList;\n+        }\n+\n+        services.add(clusterService);\n+        ServiceLoader<KieServerApplicationComponentsService> appComponentsServices = ServiceLoader.load(KieServerApplicationComponentsService.class);\n+\n+        for( KieServerApplicationComponentsService appComponentsService : appComponentsServices ) {\n+            appComponentsList.addAll(appComponentsService.getAppComponents(EXTENSION_NAME, type, services));\n+        }\n+        return appComponentsList;\n+\n+\n+    }\n+\n+    @Override\n+    public <T> T getAppComponents(Class<T> serviceType) {\n+        if (!initialized) {\n+            return null;\n+        }\n+", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3MzE0NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r529273145", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-24T08:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMjU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNTcxNw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r523035717", "bodyText": "we may end up having added the same object clusterService several times in the same list, when method getAppComponents is called several times", "author": "afalhambra", "createdAt": "2020-11-13T15:47:23Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/JBPMClusterKieServerExtension.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.executor.impl.ExecutorServiceImpl;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.executor.ExecutorService;\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.model.Message;\n+import org.kie.server.api.model.Severity;\n+import org.kie.server.services.api.KieContainerInstance;\n+import org.kie.server.services.api.KieServerApplicationComponentsService;\n+import org.kie.server.services.api.KieServerExtension;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.api.SupportedTransports;\n+import org.kie.server.services.impl.KieServerImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JBPMClusterKieServerExtension implements KieServerExtension {\n+\n+    public static final String EXTENSION_NAME = \"jBPM-Cluster\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(JBPMClusterKieServerExtension.class);\n+\n+    private static final Boolean disabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_CLUSTER_SERVER_EXT_DISABLED, \"false\"));\n+    private static final Boolean jbpmDisabled = Boolean.parseBoolean(System.getProperty(KieServerConstants.KIE_JBPM_SERVER_EXT_DISABLED, \"false\"));\n+\n+    private List<Object> services = new ArrayList<Object>();\n+    private boolean initialized = false;\n+\n+    private KieServerRegistry registry;\n+\n+    private ExecutorService jbpmExecutorService;\n+    private ClusterAwareService clusterService;\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return !disabled && !jbpmDisabled;\n+    }\n+\n+    @Override\n+    public void init(KieServerImpl kieServer, KieServerRegistry registry) {\n+\n+        this.registry = registry;\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        if (jbpmExtension == null) {\n+            initialized = false;\n+            logger.warn(\"jBPM extension not found, jBPM Cluster cannot work without jBPM extension, disabling itself\");\n+            return;\n+        }\n+\n+        configureServices();\n+\n+        // this implements fail over for jobs\n+        ExecutorServiceImpl service = (ExecutorServiceImpl) jbpmExecutorService;\n+        ClusteredJobFailOverListener clusteredJobFailOverListener = new ClusteredJobFailOverListener(clusterService, service);\n+        service.addAsyncJobListener(clusteredJobFailOverListener);\n+        clusterService.addClusterListener(clusteredJobFailOverListener);\n+\n+        initialized = true;\n+    }\n+\n+    private void configureServices () {\n+        KieServerExtension jbpmExtension = registry.getServerExtension(\"jBPM\");\n+        List<Object> jbpmServices = jbpmExtension.getServices();\n+        \n+\n+        for (Object object : jbpmServices) {\n+            // in case given service is null (meaning was not configured) continue with next one\n+            if (object == null) {\n+                continue;\n+            }\n+            if (ExecutorService.class.isAssignableFrom(object.getClass())) {\n+                this.jbpmExecutorService = (ExecutorService) object;\n+                continue;\n+            } \n+        }\n+\n+        clusterService = org.kie.api.internal.utils.ServiceRegistry.getService(ClusterAwareService.class);\n+    }\n+    \n+    @Override\n+    public void destroy(KieServerImpl kieServer, KieServerRegistry registry) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void createContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void updateContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        // recreate configuration for updated container\n+        disposeContainer(id, kieContainerInstance, parameters);\n+        createContainer(id, kieContainerInstance, parameters);\n+    }\n+\n+    @Override\n+    public boolean isUpdateContainerAllowed(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void disposeContainer(String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) {\n+        if (!initialized) {\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public List<Object> getAppComponents(SupportedTransports type) {\n+        List<Object> appComponentsList = new ArrayList<Object>();\n+        if (!initialized) {\n+            return appComponentsList;\n+        }\n+\n+        services.add(clusterService);", "originalCommit": "4872bb018b6c6d3493e38edaa46a1b66777a73fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ4NjQxMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r532486410", "bodyText": "resolved", "author": "elguardian", "createdAt": "2020-11-30T10:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNTcxNw=="}], "type": "inlineReview"}, {"oid": "504732f3d74a794ec2d7ff10579f3241825f39a8", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/504732f3d74a794ec2d7ff10579f3241825f39a8", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-11-24T08:12:51Z", "type": "forcePushed"}, {"oid": "ea239e61cd51a32f881c2490622b3773c373d06f", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/ea239e61cd51a32f881c2490622b3773c373d06f", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-11-24T08:52:51Z", "type": "forcePushed"}, {"oid": "1edd83c4e2e2ed313ed9dc2bfccb63952c95a64f", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/1edd83c4e2e2ed313ed9dc2bfccb63952c95a64f", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-11-24T08:54:36Z", "type": "forcePushed"}, {"oid": "7de3160f1bfbbe763afe9ae5043b72f1bf303e3a", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/7de3160f1bfbbe763afe9ae5043b72f1bf303e3a", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-11-24T12:35:48Z", "type": "forcePushed"}, {"oid": "6a6a66e8a6d234b5fe10f81ac48708c8dd5f84b5", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/6a6a66e8a6d234b5fe10f81ac48708c8dd5f84b5", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-11-30T10:15:42Z", "type": "forcePushed"}, {"oid": "b82b2f8e104aaa212cdcc8c51a45cb063e8f61ee", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/b82b2f8e104aaa212cdcc8c51a45cb063e8f61ee", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-11-30T10:18:25Z", "type": "forcePushed"}, {"oid": "cc753277f380fcbe9a1202a80f7e025da1e096ea", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/cc753277f380fcbe9a1202a80f7e025da1e096ea", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-11-30T10:41:02Z", "type": "forcePushed"}, {"oid": "488bd38d83708957c0e7939bdc03039b3f8e6786", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/488bd38d83708957c0e7939bdc03039b3f8e6786", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-11-30T10:51:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyNTg5MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r533325891", "bodyText": "typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void nodeJoin(CacheEntryCreatedEvent<Address, ClusterNode> event) {\n          \n          \n            \n                public void nodeJoined(CacheEntryCreatedEvent<Address, ClusterNode> event) {", "author": "afalhambra", "createdAt": "2020-12-01T11:07:52Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/InfinispanClusterAwareService.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.CacheCollection;\n+import org.infinispan.CacheSet;\n+import org.infinispan.commons.util.CloseableIterator;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.Listener.Observation;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.notifications.cachemanagerlistener.annotation.ViewChanged;\n+import org.infinispan.notifications.cachemanagerlistener.event.Event;\n+import org.infinispan.notifications.cachemanagerlistener.event.ViewChangedEvent;\n+import org.infinispan.remoting.transport.Address;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.kie.server.api.KieServerConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+@Listener(observation = Observation.POST)\n+public class InfinispanClusterAwareService implements ClusterAwareService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InfinispanClusterAwareService.class);\n+\n+    private List<ClusterListener> listeners;\n+    private EmbeddedCacheManager cacheManager;\n+\n+    private String kieServerId;\n+    private String kieServerLocation;\n+\n+    public InfinispanClusterAwareService(String kieServerId, String kieServerLocation) {\n+        this.kieServerId = kieServerId;\n+        this.kieServerLocation = kieServerLocation;\n+        listeners = new ArrayList<>();\n+    }\n+\n+    public InfinispanClusterAwareService() {\n+        this(System.getProperty(KieServerConstants.KIE_SERVER_ID), System.getProperty(KieServerConstants.KIE_SERVER_LOCATION));\n+    }\n+\n+    \n+    @Override\n+    public ClusterNode getThisNode() {\n+        return new ClusterNode(kieServerId, kieServerLocation);\n+    }\n+\n+    public void init(EmbeddedCacheManager cacheManager) {\n+        this.cacheManager = cacheManager;\n+        cacheManager.addListener(this);\n+        Cache<Address, ClusterNode> nodes = cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY);\n+        nodes.addListener(this);\n+        logger.info(\"This node is about to join the jBPM cluster {}-{}\", kieServerId, kieServerLocation);\n+        nodes.put(cacheManager.getAddress(), getThisNode());\n+\n+    }\n+\n+    @CacheEntryCreated\n+    public void nodeJoin(CacheEntryCreatedEvent<Address, ClusterNode> event) {", "originalCommit": "488bd38d83708957c0e7939bdc03039b3f8e6786", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MzIzNA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r533993234", "bodyText": "done", "author": "elguardian", "createdAt": "2020-12-02T08:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyNTg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyNzQwNA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r533327404", "bodyText": "currently we're only updating those members who left the cluster - but if I'm not wrong, this method may be called when new members joined the cluster also. Shouldn't we also add those in the cache?", "author": "afalhambra", "createdAt": "2020-12-01T11:10:33Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/InfinispanClusterAwareService.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.CacheCollection;\n+import org.infinispan.CacheSet;\n+import org.infinispan.commons.util.CloseableIterator;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.Listener.Observation;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.notifications.cachemanagerlistener.annotation.ViewChanged;\n+import org.infinispan.notifications.cachemanagerlistener.event.Event;\n+import org.infinispan.notifications.cachemanagerlistener.event.ViewChangedEvent;\n+import org.infinispan.remoting.transport.Address;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.kie.server.api.KieServerConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+@Listener(observation = Observation.POST)\n+public class InfinispanClusterAwareService implements ClusterAwareService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InfinispanClusterAwareService.class);\n+\n+    private List<ClusterListener> listeners;\n+    private EmbeddedCacheManager cacheManager;\n+\n+    private String kieServerId;\n+    private String kieServerLocation;\n+\n+    public InfinispanClusterAwareService(String kieServerId, String kieServerLocation) {\n+        this.kieServerId = kieServerId;\n+        this.kieServerLocation = kieServerLocation;\n+        listeners = new ArrayList<>();\n+    }\n+\n+    public InfinispanClusterAwareService() {\n+        this(System.getProperty(KieServerConstants.KIE_SERVER_ID), System.getProperty(KieServerConstants.KIE_SERVER_LOCATION));\n+    }\n+\n+    \n+    @Override\n+    public ClusterNode getThisNode() {\n+        return new ClusterNode(kieServerId, kieServerLocation);\n+    }\n+\n+    public void init(EmbeddedCacheManager cacheManager) {\n+        this.cacheManager = cacheManager;\n+        cacheManager.addListener(this);\n+        Cache<Address, ClusterNode> nodes = cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY);\n+        nodes.addListener(this);\n+        logger.info(\"This node is about to join the jBPM cluster {}-{}\", kieServerId, kieServerLocation);\n+        nodes.put(cacheManager.getAddress(), getThisNode());\n+\n+    }\n+\n+    @CacheEntryCreated\n+    public void nodeJoin(CacheEntryCreatedEvent<Address, ClusterNode> event) {\n+        if(event.isPre()) {\n+            return;\n+        }\n+        logger.info(\"jBPM cluster member joined {}\", event.getValue());\n+        synchronized (listeners) {\n+            listeners.forEach(listener -> listener.nodeJoined(event.getValue()));\n+        }\n+    }\n+\n+    @CacheEntryRemoved\n+    public void nodeLeft(CacheEntryRemovedEvent<Address, ClusterNode> event) {\n+        if(event.isPre()) {\n+            return;\n+        }\n+        logger.info(\"jBPM cluster member left {}\", event.getOldValue());\n+        synchronized (listeners) {\n+            listeners.forEach(listener -> listener.nodeLeft(event.getOldValue()));\n+        }\n+    }\n+\n+    @ViewChanged\n+    public void viewChanged(ViewChangedEvent event) {\n+        logger.info(\"jBPM cluster view changed. Current active nodes: {}\", event.getNewMembers());\n+        if (Event.Type.VIEW_CHANGED.equals(event.getType())) {\n+            List<Address> changedAddress = event.getNewMembers();\n+            Cache<Address, ClusterNode> nodes = cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY);\n+            CacheSet<Address> currentView = cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY).keySet();\n+\n+            List<Address> membersLeft = new ArrayList<>();\n+            Iterator<Address> addresses = currentView.iterator();\n+            while(addresses.hasNext()) {\n+                Address address = addresses.next();\n+                if(!changedAddress.contains(address)) {\n+                    membersLeft.add(address);\n+                }\n+            }\n+\n+\n+            // forcefully removed\n+            // address change we remove the nodes from the cache\n+            membersLeft.forEach(node -> nodes.remove(node));", "originalCommit": "488bd38d83708957c0e7939bdc03039b3f8e6786", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MjU1Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r533992553", "bodyText": "this is only for nodes crashing.", "author": "elguardian", "createdAt": "2020-12-02T08:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyNzQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMDU5Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r533330592", "bodyText": "can be replaced with method reference\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return values.stream().flatMap(e -> e.stream()).collect(toList());\n          \n          \n            \n                    return values.stream().flatMap(Collection::stream).collect(toList());", "author": "afalhambra", "createdAt": "2020-12-01T11:16:03Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/main/java/org/kie/server/services/jbpm/cluster/InfinispanClusterAwareService.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.CacheCollection;\n+import org.infinispan.CacheSet;\n+import org.infinispan.commons.util.CloseableIterator;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.Listener.Observation;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.notifications.cachemanagerlistener.annotation.ViewChanged;\n+import org.infinispan.notifications.cachemanagerlistener.event.Event;\n+import org.infinispan.notifications.cachemanagerlistener.event.ViewChangedEvent;\n+import org.infinispan.remoting.transport.Address;\n+import org.kie.api.cluster.ClusterAwareService;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+import org.kie.server.api.KieServerConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+@Listener(observation = Observation.POST)\n+public class InfinispanClusterAwareService implements ClusterAwareService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InfinispanClusterAwareService.class);\n+\n+    private List<ClusterListener> listeners;\n+    private EmbeddedCacheManager cacheManager;\n+\n+    private String kieServerId;\n+    private String kieServerLocation;\n+\n+    public InfinispanClusterAwareService(String kieServerId, String kieServerLocation) {\n+        this.kieServerId = kieServerId;\n+        this.kieServerLocation = kieServerLocation;\n+        listeners = new ArrayList<>();\n+    }\n+\n+    public InfinispanClusterAwareService() {\n+        this(System.getProperty(KieServerConstants.KIE_SERVER_ID), System.getProperty(KieServerConstants.KIE_SERVER_LOCATION));\n+    }\n+\n+    \n+    @Override\n+    public ClusterNode getThisNode() {\n+        return new ClusterNode(kieServerId, kieServerLocation);\n+    }\n+\n+    public void init(EmbeddedCacheManager cacheManager) {\n+        this.cacheManager = cacheManager;\n+        cacheManager.addListener(this);\n+        Cache<Address, ClusterNode> nodes = cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY);\n+        nodes.addListener(this);\n+        logger.info(\"This node is about to join the jBPM cluster {}-{}\", kieServerId, kieServerLocation);\n+        nodes.put(cacheManager.getAddress(), getThisNode());\n+\n+    }\n+\n+    @CacheEntryCreated\n+    public void nodeJoin(CacheEntryCreatedEvent<Address, ClusterNode> event) {\n+        if(event.isPre()) {\n+            return;\n+        }\n+        logger.info(\"jBPM cluster member joined {}\", event.getValue());\n+        synchronized (listeners) {\n+            listeners.forEach(listener -> listener.nodeJoined(event.getValue()));\n+        }\n+    }\n+\n+    @CacheEntryRemoved\n+    public void nodeLeft(CacheEntryRemovedEvent<Address, ClusterNode> event) {\n+        if(event.isPre()) {\n+            return;\n+        }\n+        logger.info(\"jBPM cluster member left {}\", event.getOldValue());\n+        synchronized (listeners) {\n+            listeners.forEach(listener -> listener.nodeLeft(event.getOldValue()));\n+        }\n+    }\n+\n+    @ViewChanged\n+    public void viewChanged(ViewChangedEvent event) {\n+        logger.info(\"jBPM cluster view changed. Current active nodes: {}\", event.getNewMembers());\n+        if (Event.Type.VIEW_CHANGED.equals(event.getType())) {\n+            List<Address> changedAddress = event.getNewMembers();\n+            Cache<Address, ClusterNode> nodes = cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY);\n+            CacheSet<Address> currentView = cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY).keySet();\n+\n+            List<Address> membersLeft = new ArrayList<>();\n+            Iterator<Address> addresses = currentView.iterator();\n+            while(addresses.hasNext()) {\n+                Address address = addresses.next();\n+                if(!changedAddress.contains(address)) {\n+                    membersLeft.add(address);\n+                }\n+            }\n+\n+\n+            // forcefully removed\n+            // address change we remove the nodes from the cache\n+            membersLeft.forEach(node -> nodes.remove(node));\n+        }\n+    }\n+\n+    @Override\n+    public boolean isCoordinator() {\n+        return cacheManager.isCoordinator();\n+    }\n+\n+    @Override\n+    public Collection<ClusterNode> getActiveClusterNodes() {\n+        return cacheManager.<Address, ClusterNode> getCache(CLUSTER_NODES_KEY).values();\n+    }\n+\n+    @Override\n+    public <T> void removeData(String key, String partition, T value) {\n+        if (!cacheManager.cacheExists(key)) {\n+            return;\n+        }\n+        Cache<String, List<T>> cache = cacheManager.<String, List<T>> getCache(key);\n+        List<T> values = cache.get(partition);\n+        if(values == null) {\n+            return;\n+        }\n+        values.remove(value);\n+        cache.put(partition, values);\n+    }\n+\n+    @Override\n+    public <T> void addData(String key, String partition, T value) {\n+        if (!cacheManager.cacheExists(key)) {\n+            return;\n+        }\n+        Cache<String, List<T>> cache = cacheManager.<String, List<T>> getCache(key);\n+        List<T> values = cache.get(partition);\n+        if(values == null) {\n+            values = new ArrayList<>();\n+        }\n+        values.add(value);\n+        cache.put(partition, values);\n+    }\n+\n+    @Override\n+    public <T> List<T> getData(String key) {\n+        if (!cacheManager.cacheExists(key)) {\n+            return emptyList();\n+        }\n+        CacheCollection<List<T>> values = cacheManager.<String, List<T>> getCache(key).values();\n+        return values.stream().flatMap(e -> e.stream()).collect(toList());", "originalCommit": "488bd38d83708957c0e7939bdc03039b3f8e6786", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MjkzMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r533992930", "bodyText": "done", "author": "elguardian", "createdAt": "2020-12-02T08:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMDU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM0MDc5MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r533340791", "bodyText": "RH header is missing", "author": "afalhambra", "createdAt": "2020-12-01T11:34:15Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/test/java/org/kie/server/services/jbpm/cluster/InfinispanClusterAwareServiceTest.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.kie.server.services.jbpm.cluster;", "originalCommit": "488bd38d83708957c0e7939bdc03039b3f8e6786", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MzE2MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r533993161", "bodyText": "added", "author": "elguardian", "createdAt": "2020-12-02T08:52:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM0MDc5MQ=="}], "type": "inlineReview"}, {"oid": "92fe066c118a793e897694b377fc3a856bcd2c3c", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/92fe066c118a793e897694b377fc3a856bcd2c3c", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-12-02T11:04:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA3NDg5NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r536074895", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-12-04T12:46:59Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/test/java/org/kie/server/services/jbpm/cluster/InfinispanClusterAwareServiceTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+\n+\n+public class InfinispanClusterAwareServiceTest {\n+\n+    \n+    public static class ClusterTrackerListener implements ClusterListener {\n+\n+        private AtomicInteger joined = new AtomicInteger();\n+        private AtomicInteger left = new AtomicInteger();\n+\n+        @Override\n+        public void nodeJoined(ClusterNode node) {\n+            joined.incrementAndGet();\n+            System.out.println(\"JOINED \" + node);\n+        }\n+\n+        @Override\n+        public void nodeLeft(ClusterNode node) {\n+            left.incrementAndGet();\n+            System.out.println(\"LEFT \" + node);", "originalCommit": "92fe066c118a793e897694b377fc3a856bcd2c3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA3NDk1OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2310#discussion_r536074958", "bodyText": "please, remove and try to use a logger instead", "author": "afalhambra", "createdAt": "2020-12-04T12:47:05Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm-cluster/src/test/java/org/kie/server/services/jbpm/cluster/InfinispanClusterAwareServiceTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.jbpm.cluster;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.kie.api.cluster.ClusterListener;\n+import org.kie.api.cluster.ClusterNode;\n+\n+\n+public class InfinispanClusterAwareServiceTest {\n+\n+    \n+    public static class ClusterTrackerListener implements ClusterListener {\n+\n+        private AtomicInteger joined = new AtomicInteger();\n+        private AtomicInteger left = new AtomicInteger();\n+\n+        @Override\n+        public void nodeJoined(ClusterNode node) {\n+            joined.incrementAndGet();\n+            System.out.println(\"JOINED \" + node);", "originalCommit": "92fe066c118a793e897694b377fc3a856bcd2c3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e5e2ea76ab124a8c34f6fccd1d093c28edd13af0", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/e5e2ea76ab124a8c34f6fccd1d093c28edd13af0", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-12-07T13:31:40Z", "type": "commit"}, {"oid": "e5e2ea76ab124a8c34f6fccd1d093c28edd13af0", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/e5e2ea76ab124a8c34f6fccd1d093c28edd13af0", "message": "[JBPM-9399] Add support to jBPM and runtime/cluster environments detection", "committedDate": "2020-12-07T13:31:40Z", "type": "forcePushed"}]}