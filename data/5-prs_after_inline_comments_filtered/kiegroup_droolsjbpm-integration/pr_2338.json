{"pr_number": 2338, "pr_title": "[JBPM-9436] Kafka Consumer/Producer springboot integration tests", "pr_createdAt": "2020-12-09T16:11:05Z", "pr_url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338", "timeline": [{"oid": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/ba25d64955bd2770e678ab47107d35d4ca6686c8", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-10T01:28:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA2MDQ2Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540060462", "bodyText": "Maybe it's worth moving this to the import section rather than using the full qualified package name\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        fos.write(com.google.common.io.Files.toByteArray(new File(resource + \"/pom.xml\")));\n          \n          \n            \n                        fos.write(toByteArray(new File(resource + \"/pom.xml\")));", "author": "afalhambra", "createdAt": "2020-12-10T10:39:04Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/utils/KieJarBuildHelper.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples.utils;\n+\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+import org.appformer.maven.integration.MavenRepository;\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.KieBuilder;\n+import org.kie.api.builder.Message;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class KieJarBuildHelper {\n+    \n+    private static final Logger logger = LoggerFactory.getLogger(KieJarBuildHelper.class);\n+    \n+    public static void createKieJar(String resource) {\n+        KieServices ks = KieServices.get();\n+        KieBuilder kieBuilder = ks.newKieBuilder(new File(resource));\n+        KieBuilder build = kieBuilder.buildAll();\n+        InternalKieModule kjar = (InternalKieModule) build.getKieModule();\n+\n+        List<Message> messages = kieBuilder.buildAll().getResults().getMessages();\n+        if (!messages.isEmpty()) {\n+            for (Message message : messages) {\n+                logger.error(\"Error Message: ({}) {}\", message.getPath(), message.getText());\n+            }\n+            throw new RuntimeException(\"There are errors building the package, please check your knowledge assets!\");\n+        }\n+        \n+        String pomFileName = MavenRepository.toFileName(kjar.getReleaseId(), null) + \".pom\";\n+        File pomFile = new File(System.getProperty(\"java.io.tmpdir\"), pomFileName);\n+        try (FileOutputStream fos = new FileOutputStream(pomFile)) {\n+            fos.write(com.google.common.io.Files.toByteArray(new File(resource + \"/pom.xml\")));", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3MTAyOA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540071028", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        fail(\"Exception when createTopics: \" + e.getMessage());\n          \n          \n            \n                        fail(\"Exception when creating topics: \" + e.getMessage());", "author": "afalhambra", "createdAt": "2020-12-10T10:54:35Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaFixture.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.apache.kafka.clients.consumer.ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.TRANSACTIONAL_ID_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.runtime.manager.impl.jpa.EntityManagerFactoryManager;\n+import org.jbpm.services.api.DeploymentService;\n+import org.kie.server.services.jbpm.kafka.KafkaServerExtension;\n+import org.kie.server.springboot.samples.utils.KieJarBuildHelper;\n+import org.slf4j.LoggerFactory;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.Logger;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+\n+public class KafkaFixture {\n+\n+    protected static final String GROUP_ID = \"org.kie.server.testing\";\n+    protected static final String VERSION = \"1.0.0.Final\";\n+    \n+    protected static final String SIGNALLING_PROJECT = \"signalling-project\";\n+    protected static final String START_SIGNAL_PROCESS_ID = \"StartSignalProcess\";\n+    protected static final String START_MESSAGE_PROCESS_ID = \"StartMessageProcess\";\n+    protected static final String START_MESSAGE_POJO_PROCESS_ID = \"StartMessagePojoProcess\";\n+    protected static final String START_MESSAGE_COMPLEX_POJO_PROCESS_ID = \"StartMessageComplexPojoProcess\";\n+    protected static final String START_MESSAGE_POJO_CLASS_NOT_FOUND_PROCESS_ID = \"StartMessagePojoClassNotFoundProcess\";\n+    protected static final String BOUNDARY_SIGNAL_PROCESS_ID = \"BoundarySignalProcess\";\n+    protected static final String BOUNDARY_MESSAGE_PROCESS_ID = \"BoundaryMessageProcess\";\n+    protected static final String INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID = \"IntermediateCatchEventSignal\";\n+    protected static final String INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID = \"IntermediateCatchEventMessage\";\n+    protected static final String SUBPROCESS_SIGNAL_PROCESS_ID = \"SubprocessSignalProcess\";\n+    protected static final String SUBPROCESS_MESSAGE_PROCESS_ID = \"SubprocessMessageProcess\";\n+\n+    protected static final String BOUNDARY_SIGNAL = \"boundarySignal\";\n+    protected static final String BOUNDARY_MESSAGE = \"boundaryMessage\";\n+    protected static final String START_SIGNAL = \"startSignal\";\n+    protected static final String START_MESSAGE = \"startMessage\";\n+    protected static final String START_MESSAGE_POJO = \"startMessagePojo\";\n+    protected static final String START_MESSAGE_COMPLEX_POJO = \"startMessageComplexPojo\";\n+    protected static final String START_MESSAGE_POJO_CLASS_NOT_FOUND = \"startMessagePojoClassNotFound\";\n+    \n+    protected static final String INTERMEDIATE_SIGNAL = \"intermediateSignal\";\n+    protected static final String INTERMEDIATE_MESSAGE = \"intermediateMessage\";\n+    protected static final String SUBPROCESS_SIGNAL = \"subprocessSignal\";\n+    protected static final String SUBPROCESS_MESSAGE = \"subprocessMessage\";\n+\n+    protected static final String SUBPROCESS_SCRIPT_NODE = \"sub-script\";\n+\n+    protected static final String PATH = \"src/test/resources/kjars/\";\n+    \n+    protected static String bootstrapServers;\n+    protected static Properties props = new Properties();\n+    \n+    protected KModuleDeploymentUnit unit = null;\n+    \n+    public static void generalSetup() {\n+        EntityManagerFactoryManager.get().clear();\n+        props.put(BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        createTopics();\n+    }\n+\n+    public static void createTopics() {\n+        try (AdminClient adminClient = AdminClient.create(props)) {\n+            adminClient.createTopics(Arrays.asList(new NewTopic(BOUNDARY_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(BOUNDARY_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(START_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_POJO, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_COMPLEX_POJO, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_POJO_CLASS_NOT_FOUND, 1, (short) 1),\n+                                                   new NewTopic(INTERMEDIATE_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(INTERMEDIATE_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(SUBPROCESS_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(SUBPROCESS_MESSAGE, 1, (short) 1)))\n+                       .all().get(1, TimeUnit.MINUTES);\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            fail(\"Exception when createTopics: \" + e.getMessage());", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc2NDQ2Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543764467", "bodyText": "done", "author": "gmunozfe", "createdAt": "2020-12-15T23:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3MTAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3MzAzMw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540073033", "bodyText": "Maybe it's worth making this class abstract as it seems we need an actual implementation of this class as some of the config members are relaying on the extended classes. - wdyt?", "author": "afalhambra", "createdAt": "2020-12-10T10:57:30Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaFixture.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.apache.kafka.clients.consumer.ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.TRANSACTIONAL_ID_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.runtime.manager.impl.jpa.EntityManagerFactoryManager;\n+import org.jbpm.services.api.DeploymentService;\n+import org.kie.server.services.jbpm.kafka.KafkaServerExtension;\n+import org.kie.server.springboot.samples.utils.KieJarBuildHelper;\n+import org.slf4j.LoggerFactory;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.Logger;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+\n+public class KafkaFixture {", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc2NTQ3OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543765479", "bodyText": "done", "author": "gmunozfe", "createdAt": "2020-12-15T23:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3MzAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3NjQ3OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540076478", "bodyText": "You can use method reference\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                stream().map(s -> s.groupId()).collect(Collectors.toList());\n          \n          \n            \n                                stream().map(ConsumerGroupListing::groupId).collect(toList());", "author": "afalhambra", "createdAt": "2020-12-10T11:02:44Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaFixture.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.apache.kafka.clients.consumer.ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.TRANSACTIONAL_ID_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.runtime.manager.impl.jpa.EntityManagerFactoryManager;\n+import org.jbpm.services.api.DeploymentService;\n+import org.kie.server.services.jbpm.kafka.KafkaServerExtension;\n+import org.kie.server.springboot.samples.utils.KieJarBuildHelper;\n+import org.slf4j.LoggerFactory;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.Logger;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+\n+public class KafkaFixture {\n+\n+    protected static final String GROUP_ID = \"org.kie.server.testing\";\n+    protected static final String VERSION = \"1.0.0.Final\";\n+    \n+    protected static final String SIGNALLING_PROJECT = \"signalling-project\";\n+    protected static final String START_SIGNAL_PROCESS_ID = \"StartSignalProcess\";\n+    protected static final String START_MESSAGE_PROCESS_ID = \"StartMessageProcess\";\n+    protected static final String START_MESSAGE_POJO_PROCESS_ID = \"StartMessagePojoProcess\";\n+    protected static final String START_MESSAGE_COMPLEX_POJO_PROCESS_ID = \"StartMessageComplexPojoProcess\";\n+    protected static final String START_MESSAGE_POJO_CLASS_NOT_FOUND_PROCESS_ID = \"StartMessagePojoClassNotFoundProcess\";\n+    protected static final String BOUNDARY_SIGNAL_PROCESS_ID = \"BoundarySignalProcess\";\n+    protected static final String BOUNDARY_MESSAGE_PROCESS_ID = \"BoundaryMessageProcess\";\n+    protected static final String INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID = \"IntermediateCatchEventSignal\";\n+    protected static final String INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID = \"IntermediateCatchEventMessage\";\n+    protected static final String SUBPROCESS_SIGNAL_PROCESS_ID = \"SubprocessSignalProcess\";\n+    protected static final String SUBPROCESS_MESSAGE_PROCESS_ID = \"SubprocessMessageProcess\";\n+\n+    protected static final String BOUNDARY_SIGNAL = \"boundarySignal\";\n+    protected static final String BOUNDARY_MESSAGE = \"boundaryMessage\";\n+    protected static final String START_SIGNAL = \"startSignal\";\n+    protected static final String START_MESSAGE = \"startMessage\";\n+    protected static final String START_MESSAGE_POJO = \"startMessagePojo\";\n+    protected static final String START_MESSAGE_COMPLEX_POJO = \"startMessageComplexPojo\";\n+    protected static final String START_MESSAGE_POJO_CLASS_NOT_FOUND = \"startMessagePojoClassNotFound\";\n+    \n+    protected static final String INTERMEDIATE_SIGNAL = \"intermediateSignal\";\n+    protected static final String INTERMEDIATE_MESSAGE = \"intermediateMessage\";\n+    protected static final String SUBPROCESS_SIGNAL = \"subprocessSignal\";\n+    protected static final String SUBPROCESS_MESSAGE = \"subprocessMessage\";\n+\n+    protected static final String SUBPROCESS_SCRIPT_NODE = \"sub-script\";\n+\n+    protected static final String PATH = \"src/test/resources/kjars/\";\n+    \n+    protected static String bootstrapServers;\n+    protected static Properties props = new Properties();\n+    \n+    protected KModuleDeploymentUnit unit = null;\n+    \n+    public static void generalSetup() {\n+        EntityManagerFactoryManager.get().clear();\n+        props.put(BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        createTopics();\n+    }\n+\n+    public static void createTopics() {\n+        try (AdminClient adminClient = AdminClient.create(props)) {\n+            adminClient.createTopics(Arrays.asList(new NewTopic(BOUNDARY_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(BOUNDARY_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(START_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_POJO, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_COMPLEX_POJO, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_POJO_CLASS_NOT_FOUND, 1, (short) 1),\n+                                                   new NewTopic(INTERMEDIATE_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(INTERMEDIATE_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(SUBPROCESS_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(SUBPROCESS_MESSAGE, 1, (short) 1)))\n+                       .all().get(1, TimeUnit.MINUTES);\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            fail(\"Exception when createTopics: \" + e.getMessage());\n+        }\n+    }\n+    \n+    public String setup(DeploymentService ds, String artifactId) {\n+        KieJarBuildHelper.createKieJar(PATH + artifactId);\n+        unit = new KModuleDeploymentUnit(GROUP_ID, artifactId, VERSION);\n+        ds.deploy(unit);\n+        waitForConsumerGroupToBeReady();\n+        return unit.getIdentifier();\n+    }\n+\n+    protected void cleanup(DeploymentService ds) {\n+        if (ds!=null) {\n+            ds.undeploy(unit);\n+        }\n+    }\n+\n+    protected void waitForConsumerGroupToBeReady() {\n+        await().atMost(3, SECONDS).pollDelay(1, SECONDS).until(() -> !listConsumerGroups().isEmpty());\n+    }\n+    \n+    protected List<String> listConsumerGroups() {\n+        List<String> consumerGroups = new ArrayList<>();\n+        try (AdminClient adminClient = AdminClient.create(props)) {\n+            consumerGroups = adminClient.listConsumerGroups().all().get().\n+                    stream().map(s -> s.groupId()).collect(Collectors.toList());", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc2NTk0MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543765940", "bodyText": "done", "author": "gmunozfe", "createdAt": "2020-12-15T23:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3NjQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4MDM5Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540080397", "bodyText": "it might be worth clearing out the props\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    }\n          \n          \n            \n                    props.clear();\n          \n      \n    \n    \n  \n\nNot sure about the topics in case they're already created. Should we try to remove them at this point?", "author": "afalhambra", "createdAt": "2020-12-10T11:09:03Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaFixture.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.apache.kafka.clients.consumer.ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.TRANSACTIONAL_ID_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.runtime.manager.impl.jpa.EntityManagerFactoryManager;\n+import org.jbpm.services.api.DeploymentService;\n+import org.kie.server.services.jbpm.kafka.KafkaServerExtension;\n+import org.kie.server.springboot.samples.utils.KieJarBuildHelper;\n+import org.slf4j.LoggerFactory;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.Logger;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+\n+public class KafkaFixture {\n+\n+    protected static final String GROUP_ID = \"org.kie.server.testing\";\n+    protected static final String VERSION = \"1.0.0.Final\";\n+    \n+    protected static final String SIGNALLING_PROJECT = \"signalling-project\";\n+    protected static final String START_SIGNAL_PROCESS_ID = \"StartSignalProcess\";\n+    protected static final String START_MESSAGE_PROCESS_ID = \"StartMessageProcess\";\n+    protected static final String START_MESSAGE_POJO_PROCESS_ID = \"StartMessagePojoProcess\";\n+    protected static final String START_MESSAGE_COMPLEX_POJO_PROCESS_ID = \"StartMessageComplexPojoProcess\";\n+    protected static final String START_MESSAGE_POJO_CLASS_NOT_FOUND_PROCESS_ID = \"StartMessagePojoClassNotFoundProcess\";\n+    protected static final String BOUNDARY_SIGNAL_PROCESS_ID = \"BoundarySignalProcess\";\n+    protected static final String BOUNDARY_MESSAGE_PROCESS_ID = \"BoundaryMessageProcess\";\n+    protected static final String INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID = \"IntermediateCatchEventSignal\";\n+    protected static final String INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID = \"IntermediateCatchEventMessage\";\n+    protected static final String SUBPROCESS_SIGNAL_PROCESS_ID = \"SubprocessSignalProcess\";\n+    protected static final String SUBPROCESS_MESSAGE_PROCESS_ID = \"SubprocessMessageProcess\";\n+\n+    protected static final String BOUNDARY_SIGNAL = \"boundarySignal\";\n+    protected static final String BOUNDARY_MESSAGE = \"boundaryMessage\";\n+    protected static final String START_SIGNAL = \"startSignal\";\n+    protected static final String START_MESSAGE = \"startMessage\";\n+    protected static final String START_MESSAGE_POJO = \"startMessagePojo\";\n+    protected static final String START_MESSAGE_COMPLEX_POJO = \"startMessageComplexPojo\";\n+    protected static final String START_MESSAGE_POJO_CLASS_NOT_FOUND = \"startMessagePojoClassNotFound\";\n+    \n+    protected static final String INTERMEDIATE_SIGNAL = \"intermediateSignal\";\n+    protected static final String INTERMEDIATE_MESSAGE = \"intermediateMessage\";\n+    protected static final String SUBPROCESS_SIGNAL = \"subprocessSignal\";\n+    protected static final String SUBPROCESS_MESSAGE = \"subprocessMessage\";\n+\n+    protected static final String SUBPROCESS_SCRIPT_NODE = \"sub-script\";\n+\n+    protected static final String PATH = \"src/test/resources/kjars/\";\n+    \n+    protected static String bootstrapServers;\n+    protected static Properties props = new Properties();\n+    \n+    protected KModuleDeploymentUnit unit = null;\n+    \n+    public static void generalSetup() {\n+        EntityManagerFactoryManager.get().clear();\n+        props.put(BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        createTopics();\n+    }\n+\n+    public static void createTopics() {\n+        try (AdminClient adminClient = AdminClient.create(props)) {\n+            adminClient.createTopics(Arrays.asList(new NewTopic(BOUNDARY_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(BOUNDARY_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(START_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_POJO, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_COMPLEX_POJO, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_POJO_CLASS_NOT_FOUND, 1, (short) 1),\n+                                                   new NewTopic(INTERMEDIATE_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(INTERMEDIATE_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(SUBPROCESS_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(SUBPROCESS_MESSAGE, 1, (short) 1)))\n+                       .all().get(1, TimeUnit.MINUTES);\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            fail(\"Exception when createTopics: \" + e.getMessage());\n+        }\n+    }\n+    \n+    public String setup(DeploymentService ds, String artifactId) {\n+        KieJarBuildHelper.createKieJar(PATH + artifactId);\n+        unit = new KModuleDeploymentUnit(GROUP_ID, artifactId, VERSION);\n+        ds.deploy(unit);\n+        waitForConsumerGroupToBeReady();\n+        return unit.getIdentifier();\n+    }\n+\n+    protected void cleanup(DeploymentService ds) {\n+        if (ds!=null) {\n+            ds.undeploy(unit);\n+        }", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc2NzAzNg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543767036", "bodyText": "topics and props are used just once (before class), and kafka testcontainer is disposed after class", "author": "gmunozfe", "createdAt": "2020-12-15T23:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4MDM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4MzE2MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540083160", "bodyText": "maybe we can take advantage of the props member of the class to add the different properties? wdyt?", "author": "afalhambra", "createdAt": "2020-12-10T11:13:20Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaFixture.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.apache.kafka.clients.consumer.ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.TRANSACTIONAL_ID_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.runtime.manager.impl.jpa.EntityManagerFactoryManager;\n+import org.jbpm.services.api.DeploymentService;\n+import org.kie.server.services.jbpm.kafka.KafkaServerExtension;\n+import org.kie.server.springboot.samples.utils.KieJarBuildHelper;\n+import org.slf4j.LoggerFactory;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.Logger;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+\n+public class KafkaFixture {\n+\n+    protected static final String GROUP_ID = \"org.kie.server.testing\";\n+    protected static final String VERSION = \"1.0.0.Final\";\n+    \n+    protected static final String SIGNALLING_PROJECT = \"signalling-project\";\n+    protected static final String START_SIGNAL_PROCESS_ID = \"StartSignalProcess\";\n+    protected static final String START_MESSAGE_PROCESS_ID = \"StartMessageProcess\";\n+    protected static final String START_MESSAGE_POJO_PROCESS_ID = \"StartMessagePojoProcess\";\n+    protected static final String START_MESSAGE_COMPLEX_POJO_PROCESS_ID = \"StartMessageComplexPojoProcess\";\n+    protected static final String START_MESSAGE_POJO_CLASS_NOT_FOUND_PROCESS_ID = \"StartMessagePojoClassNotFoundProcess\";\n+    protected static final String BOUNDARY_SIGNAL_PROCESS_ID = \"BoundarySignalProcess\";\n+    protected static final String BOUNDARY_MESSAGE_PROCESS_ID = \"BoundaryMessageProcess\";\n+    protected static final String INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID = \"IntermediateCatchEventSignal\";\n+    protected static final String INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID = \"IntermediateCatchEventMessage\";\n+    protected static final String SUBPROCESS_SIGNAL_PROCESS_ID = \"SubprocessSignalProcess\";\n+    protected static final String SUBPROCESS_MESSAGE_PROCESS_ID = \"SubprocessMessageProcess\";\n+\n+    protected static final String BOUNDARY_SIGNAL = \"boundarySignal\";\n+    protected static final String BOUNDARY_MESSAGE = \"boundaryMessage\";\n+    protected static final String START_SIGNAL = \"startSignal\";\n+    protected static final String START_MESSAGE = \"startMessage\";\n+    protected static final String START_MESSAGE_POJO = \"startMessagePojo\";\n+    protected static final String START_MESSAGE_COMPLEX_POJO = \"startMessageComplexPojo\";\n+    protected static final String START_MESSAGE_POJO_CLASS_NOT_FOUND = \"startMessagePojoClassNotFound\";\n+    \n+    protected static final String INTERMEDIATE_SIGNAL = \"intermediateSignal\";\n+    protected static final String INTERMEDIATE_MESSAGE = \"intermediateMessage\";\n+    protected static final String SUBPROCESS_SIGNAL = \"subprocessSignal\";\n+    protected static final String SUBPROCESS_MESSAGE = \"subprocessMessage\";\n+\n+    protected static final String SUBPROCESS_SCRIPT_NODE = \"sub-script\";\n+\n+    protected static final String PATH = \"src/test/resources/kjars/\";\n+    \n+    protected static String bootstrapServers;\n+    protected static Properties props = new Properties();\n+    \n+    protected KModuleDeploymentUnit unit = null;\n+    \n+    public static void generalSetup() {\n+        EntityManagerFactoryManager.get().clear();\n+        props.put(BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        createTopics();\n+    }\n+\n+    public static void createTopics() {\n+        try (AdminClient adminClient = AdminClient.create(props)) {\n+            adminClient.createTopics(Arrays.asList(new NewTopic(BOUNDARY_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(BOUNDARY_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(START_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_POJO, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_COMPLEX_POJO, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_POJO_CLASS_NOT_FOUND, 1, (short) 1),\n+                                                   new NewTopic(INTERMEDIATE_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(INTERMEDIATE_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(SUBPROCESS_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(SUBPROCESS_MESSAGE, 1, (short) 1)))\n+                       .all().get(1, TimeUnit.MINUTES);\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            fail(\"Exception when createTopics: \" + e.getMessage());\n+        }\n+    }\n+    \n+    public String setup(DeploymentService ds, String artifactId) {\n+        KieJarBuildHelper.createKieJar(PATH + artifactId);\n+        unit = new KModuleDeploymentUnit(GROUP_ID, artifactId, VERSION);\n+        ds.deploy(unit);\n+        waitForConsumerGroupToBeReady();\n+        return unit.getIdentifier();\n+    }\n+\n+    protected void cleanup(DeploymentService ds) {\n+        if (ds!=null) {\n+            ds.undeploy(unit);\n+        }\n+    }\n+\n+    protected void waitForConsumerGroupToBeReady() {\n+        await().atMost(3, SECONDS).pollDelay(1, SECONDS).until(() -> !listConsumerGroups().isEmpty());\n+    }\n+    \n+    protected List<String> listConsumerGroups() {\n+        List<String> consumerGroups = new ArrayList<>();\n+        try (AdminClient adminClient = AdminClient.create(props)) {\n+            consumerGroups = adminClient.listConsumerGroups().all().get().\n+                    stream().map(s -> s.groupId()).collect(Collectors.toList());\n+        } catch (InterruptedException | ExecutionException e) {\n+            fail(\"Exception when listConsumerGroups: \" + e.getMessage());\n+        }\n+        return consumerGroups;\n+    }\n+    \n+    protected Properties producerProps(String bootstrapServer, boolean transactional) {\n+        Properties producerProperties = new Properties();\n+        producerProperties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServer);", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc2ODg0OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543768848", "bodyText": "not sure, attribute props is for admin tasks (like create topics) and here they're specific for the producer. I'd prefer to keep them isolated", "author": "gmunozfe", "createdAt": "2020-12-15T23:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4MzE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4NjE3OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540086179", "bodyText": "Maybe some more meaningful name?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Optional<ILoggingEvent> getLog(ListAppender<ILoggingEvent> listAppender) {\n          \n          \n            \n                protected Optional<ILoggingEvent> getErrorLog(ListAppender<ILoggingEvent> listAppender) {", "author": "afalhambra", "createdAt": "2020-12-10T11:18:05Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaFixture.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.apache.kafka.clients.consumer.ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.TRANSACTIONAL_ID_CONFIG;\n+import static org.apache.kafka.clients.producer.ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.runtime.manager.impl.jpa.EntityManagerFactoryManager;\n+import org.jbpm.services.api.DeploymentService;\n+import org.kie.server.services.jbpm.kafka.KafkaServerExtension;\n+import org.kie.server.springboot.samples.utils.KieJarBuildHelper;\n+import org.slf4j.LoggerFactory;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.Logger;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+\n+public class KafkaFixture {\n+\n+    protected static final String GROUP_ID = \"org.kie.server.testing\";\n+    protected static final String VERSION = \"1.0.0.Final\";\n+    \n+    protected static final String SIGNALLING_PROJECT = \"signalling-project\";\n+    protected static final String START_SIGNAL_PROCESS_ID = \"StartSignalProcess\";\n+    protected static final String START_MESSAGE_PROCESS_ID = \"StartMessageProcess\";\n+    protected static final String START_MESSAGE_POJO_PROCESS_ID = \"StartMessagePojoProcess\";\n+    protected static final String START_MESSAGE_COMPLEX_POJO_PROCESS_ID = \"StartMessageComplexPojoProcess\";\n+    protected static final String START_MESSAGE_POJO_CLASS_NOT_FOUND_PROCESS_ID = \"StartMessagePojoClassNotFoundProcess\";\n+    protected static final String BOUNDARY_SIGNAL_PROCESS_ID = \"BoundarySignalProcess\";\n+    protected static final String BOUNDARY_MESSAGE_PROCESS_ID = \"BoundaryMessageProcess\";\n+    protected static final String INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID = \"IntermediateCatchEventSignal\";\n+    protected static final String INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID = \"IntermediateCatchEventMessage\";\n+    protected static final String SUBPROCESS_SIGNAL_PROCESS_ID = \"SubprocessSignalProcess\";\n+    protected static final String SUBPROCESS_MESSAGE_PROCESS_ID = \"SubprocessMessageProcess\";\n+\n+    protected static final String BOUNDARY_SIGNAL = \"boundarySignal\";\n+    protected static final String BOUNDARY_MESSAGE = \"boundaryMessage\";\n+    protected static final String START_SIGNAL = \"startSignal\";\n+    protected static final String START_MESSAGE = \"startMessage\";\n+    protected static final String START_MESSAGE_POJO = \"startMessagePojo\";\n+    protected static final String START_MESSAGE_COMPLEX_POJO = \"startMessageComplexPojo\";\n+    protected static final String START_MESSAGE_POJO_CLASS_NOT_FOUND = \"startMessagePojoClassNotFound\";\n+    \n+    protected static final String INTERMEDIATE_SIGNAL = \"intermediateSignal\";\n+    protected static final String INTERMEDIATE_MESSAGE = \"intermediateMessage\";\n+    protected static final String SUBPROCESS_SIGNAL = \"subprocessSignal\";\n+    protected static final String SUBPROCESS_MESSAGE = \"subprocessMessage\";\n+\n+    protected static final String SUBPROCESS_SCRIPT_NODE = \"sub-script\";\n+\n+    protected static final String PATH = \"src/test/resources/kjars/\";\n+    \n+    protected static String bootstrapServers;\n+    protected static Properties props = new Properties();\n+    \n+    protected KModuleDeploymentUnit unit = null;\n+    \n+    public static void generalSetup() {\n+        EntityManagerFactoryManager.get().clear();\n+        props.put(BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        createTopics();\n+    }\n+\n+    public static void createTopics() {\n+        try (AdminClient adminClient = AdminClient.create(props)) {\n+            adminClient.createTopics(Arrays.asList(new NewTopic(BOUNDARY_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(BOUNDARY_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(START_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_POJO, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_COMPLEX_POJO, 1, (short) 1),\n+                                                   new NewTopic(START_MESSAGE_POJO_CLASS_NOT_FOUND, 1, (short) 1),\n+                                                   new NewTopic(INTERMEDIATE_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(INTERMEDIATE_MESSAGE, 1, (short) 1),\n+                                                   new NewTopic(SUBPROCESS_SIGNAL, 1, (short) 1),\n+                                                   new NewTopic(SUBPROCESS_MESSAGE, 1, (short) 1)))\n+                       .all().get(1, TimeUnit.MINUTES);\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            fail(\"Exception when createTopics: \" + e.getMessage());\n+        }\n+    }\n+    \n+    public String setup(DeploymentService ds, String artifactId) {\n+        KieJarBuildHelper.createKieJar(PATH + artifactId);\n+        unit = new KModuleDeploymentUnit(GROUP_ID, artifactId, VERSION);\n+        ds.deploy(unit);\n+        waitForConsumerGroupToBeReady();\n+        return unit.getIdentifier();\n+    }\n+\n+    protected void cleanup(DeploymentService ds) {\n+        if (ds!=null) {\n+            ds.undeploy(unit);\n+        }\n+    }\n+\n+    protected void waitForConsumerGroupToBeReady() {\n+        await().atMost(3, SECONDS).pollDelay(1, SECONDS).until(() -> !listConsumerGroups().isEmpty());\n+    }\n+    \n+    protected List<String> listConsumerGroups() {\n+        List<String> consumerGroups = new ArrayList<>();\n+        try (AdminClient adminClient = AdminClient.create(props)) {\n+            consumerGroups = adminClient.listConsumerGroups().all().get().\n+                    stream().map(s -> s.groupId()).collect(Collectors.toList());\n+        } catch (InterruptedException | ExecutionException e) {\n+            fail(\"Exception when listConsumerGroups: \" + e.getMessage());\n+        }\n+        return consumerGroups;\n+    }\n+    \n+    protected Properties producerProps(String bootstrapServer, boolean transactional) {\n+        Properties producerProperties = new Properties();\n+        producerProperties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServer);\n+        producerProperties.put(KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n+        producerProperties.put(VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n+        if (transactional) {\n+            producerProperties.put(TRANSACTIONAL_ID_CONFIG, \"my-transactional-id\");\n+        }\n+            \n+        return producerProperties;\n+    }\n+    \n+    protected ListAppender<ILoggingEvent> addLogAppender() {\n+        Logger logger = (Logger) LoggerFactory.getLogger(KafkaServerExtension.class);\n+        ListAppender<ILoggingEvent> listAppender = new ListAppender<>();\n+        listAppender.start();\n+        logger.addAppender(listAppender);\n+        return listAppender;\n+    }\n+    \n+    protected Optional<ILoggingEvent> getLog(ListAppender<ILoggingEvent> listAppender) {", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc2NzQ1Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543767457", "bodyText": "done", "author": "gmunozfe", "createdAt": "2020-12-15T23:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4NjE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA5MjA3NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540092075", "bodyText": "Missing RH header/copyright", "author": "afalhambra", "createdAt": "2020-12-10T11:27:25Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaExtensionTest.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package org.kie.server.springboot.samples;", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA5OTQ0MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540099441", "bodyText": "not used - please remove", "author": "afalhambra", "createdAt": "2020-12-10T11:39:40Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc2OTA2Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543769066", "bodyText": "done", "author": "gmunozfe", "createdAt": "2020-12-15T23:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA5OTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEwMTk5MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540101990", "bodyText": "No checked exception is thrown\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setup() throws Exception {\n          \n          \n            \n                public void setup() {", "author": "afalhambra", "createdAt": "2020-12-10T11:44:02Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;\n+    \n+    @Autowired\n+    protected UserTaskService userTaskService;\n+    \n+    @Autowired\n+    protected RuntimeDataService runtimeDataService;\n+    \n+    @Autowired\n+    protected CountDownLatchEventListener countDownListener;\n+    \n+    protected String deploymentId;\n+    \n+    protected ListAppender<ILoggingEvent> listAppender;\n+    \n+    @BeforeClass\n+    public static void beforeClass() {\n+        //for the transactional tests\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\", \"1\");\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\", \"1\");\n+        kafka.start();\n+        bootstrapServers = kafka.getBootstrapServers();\n+        \n+        System.setProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        System.setProperty(KAFKA_EXTENSION_PREFIX+\"signals.mapping\", \"AUTO\");\n+        generalSetup();\n+    }\n+    \n+    \n+    @Before\n+    public void setup() throws Exception {", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc2OTI4NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543769285", "bodyText": "done", "author": "gmunozfe", "createdAt": "2020-12-15T23:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEwMTk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExNDc0NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540114744", "bodyText": "maybe it's worth checking the number of ids is 1?", "author": "afalhambra", "createdAt": "2020-12-10T12:05:00Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;\n+    \n+    @Autowired\n+    protected UserTaskService userTaskService;\n+    \n+    @Autowired\n+    protected RuntimeDataService runtimeDataService;\n+    \n+    @Autowired\n+    protected CountDownLatchEventListener countDownListener;\n+    \n+    protected String deploymentId;\n+    \n+    protected ListAppender<ILoggingEvent> listAppender;\n+    \n+    @BeforeClass\n+    public static void beforeClass() {\n+        //for the transactional tests\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\", \"1\");\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\", \"1\");\n+        kafka.start();\n+        bootstrapServers = kafka.getBootstrapServers();\n+        \n+        System.setProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        System.setProperty(KAFKA_EXTENSION_PREFIX+\"signals.mapping\", \"AUTO\");\n+        generalSetup();\n+    }\n+    \n+    \n+    @Before\n+    public void setup() throws Exception {\n+        deploymentId = setup(deploymentService, SIGNALLING_PROJECT);\n+        listAppender = addLogAppender();\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        cleanup(deploymentService);\n+    }\n+    \n+    @AfterClass\n+    public static void teardown() {\n+        kafka.stop();\n+        System.clearProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignal() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(START_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTMwNg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543771306", "bodyText": "done, changed in other places too", "author": "gmunozfe", "createdAt": "2020-12-15T23:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExNDc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExNTQ4MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540115481", "bodyText": "should we not check that the process is actually aborted? - maybe it's not worth for the test case, just in case the instances are not getting aborted properly to avoid any potential issues afterwards", "author": "afalhambra", "createdAt": "2020-12-10T12:06:15Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;\n+    \n+    @Autowired\n+    protected UserTaskService userTaskService;\n+    \n+    @Autowired\n+    protected RuntimeDataService runtimeDataService;\n+    \n+    @Autowired\n+    protected CountDownLatchEventListener countDownListener;\n+    \n+    protected String deploymentId;\n+    \n+    protected ListAppender<ILoggingEvent> listAppender;\n+    \n+    @BeforeClass\n+    public static void beforeClass() {\n+        //for the transactional tests\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\", \"1\");\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\", \"1\");\n+        kafka.start();\n+        bootstrapServers = kafka.getBootstrapServers();\n+        \n+        System.setProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        System.setProperty(KAFKA_EXTENSION_PREFIX+\"signals.mapping\", \"AUTO\");\n+        generalSetup();\n+    }\n+    \n+    \n+    @Before\n+    public void setup() throws Exception {\n+        deploymentId = setup(deploymentService, SIGNALLING_PROJECT);\n+        listAppender = addLogAppender();\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        cleanup(deploymentService);\n+    }\n+    \n+    @AfterClass\n+    public static void teardown() {\n+        kafka.stop();\n+        System.clearProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignal() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(START_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU5NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543771594", "bodyText": "it's checked that the state is active", "author": "gmunozfe", "createdAt": "2020-12-15T23:50:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExNTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExNzYzNg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540117636", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-12-10T12:09:47Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;\n+    \n+    @Autowired\n+    protected UserTaskService userTaskService;\n+    \n+    @Autowired\n+    protected RuntimeDataService runtimeDataService;\n+    \n+    @Autowired\n+    protected CountDownLatchEventListener countDownListener;\n+    \n+    protected String deploymentId;\n+    \n+    protected ListAppender<ILoggingEvent> listAppender;\n+    \n+    @BeforeClass\n+    public static void beforeClass() {\n+        //for the transactional tests\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\", \"1\");\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\", \"1\");\n+        kafka.start();\n+        bootstrapServers = kafka.getBootstrapServers();\n+        \n+        System.setProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        System.setProperty(KAFKA_EXTENSION_PREFIX+\"signals.mapping\", \"AUTO\");\n+        generalSetup();\n+    }\n+    \n+    \n+    @Before\n+    public void setup() throws Exception {\n+        deploymentId = setup(deploymentService, SIGNALLING_PROJECT);\n+        listAppender = addLogAppender();\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        cleanup(deploymentService);\n+    }\n+    \n+    @AfterClass\n+    public static void teardown() {\n+        kafka.stop();\n+        System.clearProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignal() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(START_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessage() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTcxNw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543771717", "bodyText": "same", "author": "gmunozfe", "createdAt": "2020-12-15T23:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExNzYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2Njg2Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540266863", "bodyText": "just curious - why 4 signals?", "author": "afalhambra", "createdAt": "2020-12-10T15:34:52Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;\n+    \n+    @Autowired\n+    protected UserTaskService userTaskService;\n+    \n+    @Autowired\n+    protected RuntimeDataService runtimeDataService;\n+    \n+    @Autowired\n+    protected CountDownLatchEventListener countDownListener;\n+    \n+    protected String deploymentId;\n+    \n+    protected ListAppender<ILoggingEvent> listAppender;\n+    \n+    @BeforeClass\n+    public static void beforeClass() {\n+        //for the transactional tests\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\", \"1\");\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\", \"1\");\n+        kafka.start();\n+        bootstrapServers = kafka.getBootstrapServers();\n+        \n+        System.setProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        System.setProperty(KAFKA_EXTENSION_PREFIX+\"signals.mapping\", \"AUTO\");\n+        generalSetup();\n+    }\n+    \n+    \n+    @Before\n+    public void setup() throws Exception {\n+        deploymentId = setup(deploymentService, SIGNALLING_PROJECT);\n+        listAppender = addLogAppender();\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        cleanup(deploymentService);\n+    }\n+    \n+    @AfterClass\n+    public static void teardown() {\n+        kafka.stop();\n+        System.clearProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignal() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(START_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessage() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundarySignal() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundaryMessage() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventSignal() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_SIGNAL, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventMessage() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_MESSAGE, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessSignal() throws Exception {\n+        int numOfSignals = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_SIGNAL_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfSignals);\n+        \n+        for(int i = 0; i < numOfSignals; i++)\n+            sendEvent(SUBPROCESS_SIGNAL, USELESS_DATA_EVENT);", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MjU3Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543772572", "bodyText": "no special reason, just testing the subprocess can be launched N times", "author": "gmunozfe", "createdAt": "2020-12-15T23:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2Njg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3MDQ3NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540270474", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-12-10T15:39:10Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;\n+    \n+    @Autowired\n+    protected UserTaskService userTaskService;\n+    \n+    @Autowired\n+    protected RuntimeDataService runtimeDataService;\n+    \n+    @Autowired\n+    protected CountDownLatchEventListener countDownListener;\n+    \n+    protected String deploymentId;\n+    \n+    protected ListAppender<ILoggingEvent> listAppender;\n+    \n+    @BeforeClass\n+    public static void beforeClass() {\n+        //for the transactional tests\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\", \"1\");\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\", \"1\");\n+        kafka.start();\n+        bootstrapServers = kafka.getBootstrapServers();\n+        \n+        System.setProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        System.setProperty(KAFKA_EXTENSION_PREFIX+\"signals.mapping\", \"AUTO\");\n+        generalSetup();\n+    }\n+    \n+    \n+    @Before\n+    public void setup() throws Exception {\n+        deploymentId = setup(deploymentService, SIGNALLING_PROJECT);\n+        listAppender = addLogAppender();\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        cleanup(deploymentService);\n+    }\n+    \n+    @AfterClass\n+    public static void teardown() {\n+        kafka.stop();\n+        System.clearProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignal() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(START_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessage() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundarySignal() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundaryMessage() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventSignal() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_SIGNAL, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventMessage() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_MESSAGE, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessSignal() throws Exception {\n+        int numOfSignals = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_SIGNAL_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfSignals);\n+        \n+        for(int i = 0; i < numOfSignals; i++)\n+            sendEvent(SUBPROCESS_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        autocompleteSingleTask();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessMessage() throws Exception {\n+        int numOfMessages = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_MESSAGE_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfMessages);\n+        \n+        for(int i = 0; i < numOfMessages; i++)\n+            sendEvent(SUBPROCESS_MESSAGE, USELESS_DATA_EVENT);", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3MTY5Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540271692", "bodyText": "maybe we can startup just a few less processes instead of 20? Just wondering in case 10secs is not enough for starting up 20 processes sequentially, just in case - wdyt?", "author": "afalhambra", "createdAt": "2020-12-10T15:40:36Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;\n+    \n+    @Autowired\n+    protected UserTaskService userTaskService;\n+    \n+    @Autowired\n+    protected RuntimeDataService runtimeDataService;\n+    \n+    @Autowired\n+    protected CountDownLatchEventListener countDownListener;\n+    \n+    protected String deploymentId;\n+    \n+    protected ListAppender<ILoggingEvent> listAppender;\n+    \n+    @BeforeClass\n+    public static void beforeClass() {\n+        //for the transactional tests\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\", \"1\");\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\", \"1\");\n+        kafka.start();\n+        bootstrapServers = kafka.getBootstrapServers();\n+        \n+        System.setProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        System.setProperty(KAFKA_EXTENSION_PREFIX+\"signals.mapping\", \"AUTO\");\n+        generalSetup();\n+    }\n+    \n+    \n+    @Before\n+    public void setup() throws Exception {\n+        deploymentId = setup(deploymentService, SIGNALLING_PROJECT);\n+        listAppender = addLogAppender();\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        cleanup(deploymentService);\n+    }\n+    \n+    @AfterClass\n+    public static void teardown() {\n+        kafka.stop();\n+        System.clearProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignal() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(START_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessage() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundarySignal() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundaryMessage() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventSignal() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_SIGNAL, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventMessage() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_MESSAGE, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessSignal() throws Exception {\n+        int numOfSignals = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_SIGNAL_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfSignals);\n+        \n+        for(int i = 0; i < numOfSignals; i++)\n+            sendEvent(SUBPROCESS_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        autocompleteSingleTask();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessMessage() throws Exception {\n+        int numOfMessages = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_MESSAGE_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfMessages);\n+        \n+        for(int i = 0; i < numOfMessages; i++)\n+            sendEvent(SUBPROCESS_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        autocompleteSingleTask();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundarySignalMultipleProcesses() throws InterruptedException {\n+        int numOfProcesses = 20;", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MjkxNQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543772915", "bodyText": "decreased to 5", "author": "gmunozfe", "createdAt": "2020-12-15T23:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3MTY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3MjAxMQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540272011", "bodyText": "same as before", "author": "afalhambra", "createdAt": "2020-12-10T15:40:59Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;\n+    \n+    @Autowired\n+    protected UserTaskService userTaskService;\n+    \n+    @Autowired\n+    protected RuntimeDataService runtimeDataService;\n+    \n+    @Autowired\n+    protected CountDownLatchEventListener countDownListener;\n+    \n+    protected String deploymentId;\n+    \n+    protected ListAppender<ILoggingEvent> listAppender;\n+    \n+    @BeforeClass\n+    public static void beforeClass() {\n+        //for the transactional tests\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\", \"1\");\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\", \"1\");\n+        kafka.start();\n+        bootstrapServers = kafka.getBootstrapServers();\n+        \n+        System.setProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        System.setProperty(KAFKA_EXTENSION_PREFIX+\"signals.mapping\", \"AUTO\");\n+        generalSetup();\n+    }\n+    \n+    \n+    @Before\n+    public void setup() throws Exception {\n+        deploymentId = setup(deploymentService, SIGNALLING_PROJECT);\n+        listAppender = addLogAppender();\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        cleanup(deploymentService);\n+    }\n+    \n+    @AfterClass\n+    public static void teardown() {\n+        kafka.stop();\n+        System.clearProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignal() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(START_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessage() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundarySignal() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundaryMessage() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventSignal() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_SIGNAL, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventMessage() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_MESSAGE, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessSignal() throws Exception {\n+        int numOfSignals = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_SIGNAL_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfSignals);\n+        \n+        for(int i = 0; i < numOfSignals; i++)\n+            sendEvent(SUBPROCESS_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        autocompleteSingleTask();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessMessage() throws Exception {\n+        int numOfMessages = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_MESSAGE_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfMessages);\n+        \n+        for(int i = 0; i < numOfMessages; i++)\n+            sendEvent(SUBPROCESS_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        autocompleteSingleTask();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundarySignalMultipleProcesses() throws InterruptedException {\n+        int numOfProcesses = 20;\n+        \n+        Long[] pids = startAndAssertProcesses(BOUNDARY_SIGNAL_PROCESS_ID, numOfProcesses);\n+        \n+        countDownListener.configure(BOUNDARY_SIGNAL_PROCESS_ID, numOfProcesses);\n+        \n+        //Just a single signal for the all processes\n+        sendEvent(BOUNDARY_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        assertNullProcesses(numOfProcesses, pids);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundaryMessageMultipleProcesses() throws InterruptedException {\n+        int numOfProcesses = 20;", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczODQxNg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540738416", "bodyText": "you could use method reference\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    map.put(topic, filenames.stream().map(x -> readData(x)).collect(Collectors.toList()));\n          \n          \n            \n                    map.put(topic, filenames.stream().map(this::readData).collect(Collectors.toList()));", "author": "afalhambra", "createdAt": "2020-12-11T07:17:36Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;\n+    \n+    @Autowired\n+    protected UserTaskService userTaskService;\n+    \n+    @Autowired\n+    protected RuntimeDataService runtimeDataService;\n+    \n+    @Autowired\n+    protected CountDownLatchEventListener countDownListener;\n+    \n+    protected String deploymentId;\n+    \n+    protected ListAppender<ILoggingEvent> listAppender;\n+    \n+    @BeforeClass\n+    public static void beforeClass() {\n+        //for the transactional tests\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\", \"1\");\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\", \"1\");\n+        kafka.start();\n+        bootstrapServers = kafka.getBootstrapServers();\n+        \n+        System.setProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        System.setProperty(KAFKA_EXTENSION_PREFIX+\"signals.mapping\", \"AUTO\");\n+        generalSetup();\n+    }\n+    \n+    \n+    @Before\n+    public void setup() throws Exception {\n+        deploymentId = setup(deploymentService, SIGNALLING_PROJECT);\n+        listAppender = addLogAppender();\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        cleanup(deploymentService);\n+    }\n+    \n+    @AfterClass\n+    public static void teardown() {\n+        kafka.stop();\n+        System.clearProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignal() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(START_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessage() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundarySignal() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundaryMessage() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventSignal() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_SIGNAL, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventMessage() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_MESSAGE, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessSignal() throws Exception {\n+        int numOfSignals = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_SIGNAL_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfSignals);\n+        \n+        for(int i = 0; i < numOfSignals; i++)\n+            sendEvent(SUBPROCESS_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        autocompleteSingleTask();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessMessage() throws Exception {\n+        int numOfMessages = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_MESSAGE_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfMessages);\n+        \n+        for(int i = 0; i < numOfMessages; i++)\n+            sendEvent(SUBPROCESS_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        autocompleteSingleTask();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundarySignalMultipleProcesses() throws InterruptedException {\n+        int numOfProcesses = 20;\n+        \n+        Long[] pids = startAndAssertProcesses(BOUNDARY_SIGNAL_PROCESS_ID, numOfProcesses);\n+        \n+        countDownListener.configure(BOUNDARY_SIGNAL_PROCESS_ID, numOfProcesses);\n+        \n+        //Just a single signal for the all processes\n+        sendEvent(BOUNDARY_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        assertNullProcesses(numOfProcesses, pids);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundaryMessageMultipleProcesses() throws InterruptedException {\n+        int numOfProcesses = 20;\n+        \n+        Long[] pids = startAndAssertProcesses(BOUNDARY_MESSAGE_PROCESS_ID, numOfProcesses);\n+        \n+        countDownListener.configure(BOUNDARY_MESSAGE_PROCESS_ID, numOfProcesses);\n+        \n+        //Just a single message for the all processes\n+        //Notice that message is for peer-to-peer communication, but here it works like a signal (broadcast)\n+        sendEvent(BOUNDARY_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        assertNullProcesses(numOfProcesses, pids);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessagePojo() throws InterruptedException {\n+        startMessagePojoParam(MONEY_DATA_EVENT, AMOUNT_294, CURRENCY_EUR);\n+        startMessagePojoParam(MONEY_DATA_NULL_AMOUNT_EVENT, null, CURRENCY_EUR);\n+        startMessagePojoParam(MONEY_DATA_NULL_CURRENCY_EVENT, AMOUNT_294, null);\n+        startMessagePojoParam(MONEY_DATA_NULL_BOTH_EVENT, null, null);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessageComplexPojo() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_COMPLEX_POJO_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE_COMPLEX_POJO, REIMBURSEMENT_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        Map<String, Object> map = getVariableMap(pid, \"assignedReimbursement\");\n+        \n+        assertEquals(2, ((List<?>)map.get(\"expenses\")).size());\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignalsTransactional() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 4);\n+        \n+        Map<String, List<String>> map =createTopicEventsMap(START_SIGNAL, \n+                Arrays.asList(USELESS_DATA_EVENT, USELESS_DATA_EVENT, USELESS_DATA_EVENT, USELESS_DATA_EVENT));\n+        \n+        sendTransactionalRecords(map);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        List<Long> pids = countDownListener.getIds();\n+        assertEquals(4, pids.size());\n+        \n+        assertActiveProcessesAndAbort(pids);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessagesTransactionalMalformedEvents() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_PROCESS_ID, 2);\n+        \n+        Map<String, List<String>> map =createTopicEventsMap(START_MESSAGE, \n+                Arrays.asList(MALFORMED_EVENT, USELESS_DATA_EVENT, MALFORMED_EVENT,\n+                USELESS_DATA_EVENT, MALFORMED_EVENT));\n+        \n+        sendTransactionalRecords(map);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        List<Long> pids = countDownListener.getIds();\n+        assertEquals(2, pids.size());\n+        \n+        assertActiveProcessesAndAbort(pids);\n+    }\n+    \n+    @Test(timeout = 30000)\n+    public void testStartSignalsAndMessagesTransactional() throws InterruptedException {\n+        int numOfEvents = 12;\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, numOfEvents*2);\n+        \n+        List<String> events = new ArrayList<>();\n+        \n+        for (int i=0; i<numOfEvents; i++) {\n+            events.add(USELESS_DATA_EVENT);\n+        }\n+        \n+        Map<String, List<String>> map = createTopicEventsMap(START_SIGNAL, events);\n+        \n+        map.putAll(createTopicEventsMap(START_MESSAGE, events));\n+        \n+        sendTransactionalRecords(map);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        List<Long> pids = countDownListener.getIds();\n+        assertEquals(numOfEvents*2, pids.size());\n+        \n+        assertActiveProcessesAndAbort(pids);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessagePojoMismatchedInput() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_POJO_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE_POJO, USELESS_DATA_EVENT);\n+        \n+        assertExceptionInLogs(listAppender, MismatchedInputException.class);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessagePojoMalformedData() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_POJO_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE_POJO, MALFORMED_EVENT);\n+        \n+        assertExceptionInLogs(listAppender, JsonEOFException.class);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessagePojoWrongType() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_POJO_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE_POJO, MONEY_DATA_WRONG_TYPE_EVENT);\n+        \n+        assertExceptionInLogs(listAppender, InvalidFormatException.class);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessagePojoClassNotFound() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_POJO_CLASS_NOT_FOUND_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE_POJO_CLASS_NOT_FOUND, MONEY_DATA_EVENT);\n+        \n+        assertExceptionInLogs(listAppender, ClassNotFoundException.class);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessageParseException() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_POJO_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE_POJO, MONEY_DATA_WRONG_DATE_EVENT);\n+        \n+        assertExceptionInLogs(listAppender, ParseException.class);\n+    }\n+\n+    public void startMessagePojoParam(String dataFile, String amount, String currency) throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_POJO_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE_POJO, dataFile);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertAssignedMoney(pid, amount, currency);\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    protected void assertExceptionInLogs(ListAppender<ILoggingEvent> listAppender, Class<?> clazz) throws InterruptedException {\n+        countDownListener.getCountDown().await(2, TimeUnit.SECONDS);\n+        \n+        Optional<ILoggingEvent> logEvent = getLog(listAppender);\n+        assertEquals(clazz.getCanonicalName(), logEvent.get().getThrowableProxy().getClassName());\n+        \n+        assertEquals(0, countDownListener.getIds().size());\n+    }\n+\n+    protected Long startAndAssertProcess(String processId) {\n+        Long pid1 = processService.startProcess(deploymentId, processId);\n+        assertNotNull(pid1);\n+        assertTrue(pid1 > 0);\n+        return pid1;\n+    }\n+    \n+    protected void autocompleteSingleTask() {\n+        List<TaskSummary> tasks =  runtimeDataService.getTasksAssignedAsPotentialOwner(\"john\", new QueryFilter());\n+        assertEquals(1, tasks.size());\n+        userTaskService.completeAutoProgress(tasks.get(0).getId(), \"john\", emptyMap());\n+    }\n+\n+    protected Long[] startAndAssertProcesses(String processId, int numOfProcesses) {\n+        Long[] pids = new Long[numOfProcesses];\n+        \n+        for (int i = 0; i < numOfProcesses; i++)\n+            pids[i] = startAndAssertProcess(processId);\n+        return pids;\n+    }\n+    \n+    protected void sendEvent(String topic, String filename) {\n+        sendRecord(topic, readData(filename));\n+    }\n+    \n+    protected Map<String, List<String>> createTopicEventsMap(String topic, List<String> filenames) {\n+        Map<String, List<String>> map = new HashMap<>();\n+        map.put(topic, filenames.stream().map(x -> readData(x)).collect(Collectors.toList()));", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzI5OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543773298", "bodyText": "done", "author": "gmunozfe", "createdAt": "2020-12-15T23:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczODQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5MDAzNw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r540790037", "bodyText": "As mentioned before, maybe we can decrease the number of events to send, and thus reduce the timeout as well - don't know, wdyt?", "author": "afalhambra", "createdAt": "2020-12-11T08:59:16Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/KafkaConsumerHappyPathTest.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.springboot.samples;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.clients.CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.IOUtils;\n+import org.jbpm.casemgmt.api.CaseService;\n+import org.jbpm.services.api.DeploymentService;\n+import org.jbpm.services.api.ProcessService;\n+import org.jbpm.services.api.RuntimeDataService;\n+import org.jbpm.services.api.UserTaskService;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestRule;\n+import org.junit.rules.TestWatcher;\n+import org.junit.runner.Description;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.task.model.TaskSummary;\n+import org.kie.internal.query.QueryFilter;\n+import org.kie.server.springboot.samples.listeners.CountDownLatchEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestPropertySource;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.testcontainers.containers.KafkaContainer;\n+\n+import com.fasterxml.jackson.core.io.JsonEOFException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.read.ListAppender;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(classes = {KieServerApplication.class, TestAutoConfiguration.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+@TestPropertySource(locations=\"classpath:application-kafka.properties\")\n+@DirtiesContext(classMode= DirtiesContext.ClassMode.AFTER_CLASS)\n+public class KafkaConsumerHappyPathTest extends KafkaFixture {\n+    \n+    private static final String KAFKA_EXTENSION_PREFIX = \"org.kie.server.jbpm-kafka.ext.\";\n+    private static final String USELESS_DATA_EVENT = \"useless-data-event.json\";\n+    private static final String MALFORMED_EVENT = \"malformed-event.json\";\n+    private static final String MONEY_DATA_EVENT = \"money-data-event.json\";\n+    private static final String MONEY_DATA_NULL_AMOUNT_EVENT = \"money-data-null-amount-event.json\";\n+    private static final String MONEY_DATA_NULL_CURRENCY_EVENT = \"money-data-null-currency-event.json\";\n+    private static final String MONEY_DATA_NULL_BOTH_EVENT = \"money-data-null-both-event.json\";\n+    private static final String MONEY_DATA_WRONG_TYPE_EVENT = \"money-data-wrong-type-event.json\";\n+    private static final String MONEY_DATA_WRONG_DATE_EVENT = \"money-data-wrong-date-event.json\";\n+    private static final String REIMBURSEMENT_DATA_EVENT = \"reimbursement-data-event.json\";\n+\n+    private static final String CURRENCY_EUR = \"EUR\";\n+\n+    private static final String AMOUNT_294 = \"294\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KafkaConsumerHappyPathTest.class);\n+\n+    protected static KafkaContainer kafka = new KafkaContainer();\n+    \n+    @Rule\n+    public TestRule watcher = new TestWatcher() {\n+       protected void starting(Description description) {\n+          logger.info(\">>> Starting test: \" + description.getMethodName());\n+       }\n+    };\n+    \n+    @Autowired\n+    protected DeploymentService deploymentService;\n+\n+    @Autowired\n+    protected ProcessService processService;\n+    \n+    @Autowired\n+    protected CaseService caseService;\n+    \n+    @Autowired\n+    protected UserTaskService userTaskService;\n+    \n+    @Autowired\n+    protected RuntimeDataService runtimeDataService;\n+    \n+    @Autowired\n+    protected CountDownLatchEventListener countDownListener;\n+    \n+    protected String deploymentId;\n+    \n+    protected ListAppender<ILoggingEvent> listAppender;\n+    \n+    @BeforeClass\n+    public static void beforeClass() {\n+        //for the transactional tests\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\", \"1\");\n+        kafka.addEnv(\"KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\", \"1\");\n+        kafka.start();\n+        bootstrapServers = kafka.getBootstrapServers();\n+        \n+        System.setProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n+        System.setProperty(KAFKA_EXTENSION_PREFIX+\"signals.mapping\", \"AUTO\");\n+        generalSetup();\n+    }\n+    \n+    \n+    @Before\n+    public void setup() throws Exception {\n+        deploymentId = setup(deploymentService, SIGNALLING_PROJECT);\n+        listAppender = addLogAppender();\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        cleanup(deploymentService);\n+    }\n+    \n+    @AfterClass\n+    public static void teardown() {\n+        kafka.stop();\n+        System.clearProperty(KAFKA_EXTENSION_PREFIX+BOOTSTRAP_SERVERS_CONFIG);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignal() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(START_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessage() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        assertThat(processService.getProcessInstance(deploymentId, pid).getState(), is(STATE_ACTIVE));\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundarySignal() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_SIGNAL_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundaryMessage() throws InterruptedException {\n+        Long processInstanceId = startAndAssertProcess(BOUNDARY_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(BOUNDARY_MESSAGE_PROCESS_ID, 1);\n+        \n+        sendEvent(BOUNDARY_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventSignal() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_SIGNAL_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_SIGNAL, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testIntermediateCatchEventMessage() throws Exception {\n+        Long processInstanceId = startAndAssertProcess(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configure(INTERMEDIATE_CATCH_EVENT_MESSAGE_PROCESS_ID, 1);\n+        \n+        autocompleteSingleTask();\n+        \n+        sendEvent(INTERMEDIATE_MESSAGE, USELESS_DATA_EVENT);\n+        countDownListener.getCountDown().await();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessSignal() throws Exception {\n+        int numOfSignals = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_SIGNAL_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_SIGNAL_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfSignals);\n+        \n+        for(int i = 0; i < numOfSignals; i++)\n+            sendEvent(SUBPROCESS_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        autocompleteSingleTask();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSubprocessMessage() throws Exception {\n+        int numOfMessages = 4;\n+        Long processInstanceId = startAndAssertProcess(SUBPROCESS_MESSAGE_PROCESS_ID);\n+        \n+        countDownListener.configureNode(SUBPROCESS_MESSAGE_PROCESS_ID, SUBPROCESS_SCRIPT_NODE, numOfMessages);\n+        \n+        for(int i = 0; i < numOfMessages; i++)\n+            sendEvent(SUBPROCESS_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        autocompleteSingleTask();\n+        \n+        ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+        assertNull(pi);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundarySignalMultipleProcesses() throws InterruptedException {\n+        int numOfProcesses = 20;\n+        \n+        Long[] pids = startAndAssertProcesses(BOUNDARY_SIGNAL_PROCESS_ID, numOfProcesses);\n+        \n+        countDownListener.configure(BOUNDARY_SIGNAL_PROCESS_ID, numOfProcesses);\n+        \n+        //Just a single signal for the all processes\n+        sendEvent(BOUNDARY_SIGNAL, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        assertNullProcesses(numOfProcesses, pids);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testBoundaryMessageMultipleProcesses() throws InterruptedException {\n+        int numOfProcesses = 20;\n+        \n+        Long[] pids = startAndAssertProcesses(BOUNDARY_MESSAGE_PROCESS_ID, numOfProcesses);\n+        \n+        countDownListener.configure(BOUNDARY_MESSAGE_PROCESS_ID, numOfProcesses);\n+        \n+        //Just a single message for the all processes\n+        //Notice that message is for peer-to-peer communication, but here it works like a signal (broadcast)\n+        sendEvent(BOUNDARY_MESSAGE, USELESS_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        assertNullProcesses(numOfProcesses, pids);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessagePojo() throws InterruptedException {\n+        startMessagePojoParam(MONEY_DATA_EVENT, AMOUNT_294, CURRENCY_EUR);\n+        startMessagePojoParam(MONEY_DATA_NULL_AMOUNT_EVENT, null, CURRENCY_EUR);\n+        startMessagePojoParam(MONEY_DATA_NULL_CURRENCY_EVENT, AMOUNT_294, null);\n+        startMessagePojoParam(MONEY_DATA_NULL_BOTH_EVENT, null, null);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessageComplexPojo() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_COMPLEX_POJO_PROCESS_ID, 1);\n+        \n+        sendEvent(START_MESSAGE_COMPLEX_POJO, REIMBURSEMENT_DATA_EVENT);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        Long pid = countDownListener.getIds().get(0);\n+        Map<String, Object> map = getVariableMap(pid, \"assignedReimbursement\");\n+        \n+        assertEquals(2, ((List<?>)map.get(\"expenses\")).size());\n+        \n+        processService.abortProcessInstance(pid);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartSignalsTransactional() throws InterruptedException {\n+        countDownListener.configure(START_SIGNAL_PROCESS_ID, 4);\n+        \n+        Map<String, List<String>> map =createTopicEventsMap(START_SIGNAL, \n+                Arrays.asList(USELESS_DATA_EVENT, USELESS_DATA_EVENT, USELESS_DATA_EVENT, USELESS_DATA_EVENT));\n+        \n+        sendTransactionalRecords(map);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        List<Long> pids = countDownListener.getIds();\n+        assertEquals(4, pids.size());\n+        \n+        assertActiveProcessesAndAbort(pids);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testStartMessagesTransactionalMalformedEvents() throws InterruptedException {\n+        countDownListener.configure(START_MESSAGE_PROCESS_ID, 2);\n+        \n+        Map<String, List<String>> map =createTopicEventsMap(START_MESSAGE, \n+                Arrays.asList(MALFORMED_EVENT, USELESS_DATA_EVENT, MALFORMED_EVENT,\n+                USELESS_DATA_EVENT, MALFORMED_EVENT));\n+        \n+        sendTransactionalRecords(map);\n+        \n+        countDownListener.getCountDown().await();\n+        \n+        List<Long> pids = countDownListener.getIds();\n+        assertEquals(2, pids.size());\n+        \n+        assertActiveProcessesAndAbort(pids);\n+    }\n+    \n+    @Test(timeout = 30000)\n+    public void testStartSignalsAndMessagesTransactional() throws InterruptedException {\n+        int numOfEvents = 12;", "originalCommit": "ba25d64955bd2770e678ab47107d35d4ca6686c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NDI2OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r543774268", "bodyText": "the idea is to check that engine can process several messages received in a single transaction", "author": "gmunozfe", "createdAt": "2020-12-15T23:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5MDAzNw=="}], "type": "inlineReview"}, {"oid": "fc430776ebd4362abf98254007de2622d7cb15fb", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/fc430776ebd4362abf98254007de2622d7cb15fb", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-15T23:09:34Z", "type": "forcePushed"}, {"oid": "ec6928606bea05aa7d011d66481f96888f2d25c9", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/ec6928606bea05aa7d011d66481f96888f2d25c9", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-15T23:26:55Z", "type": "forcePushed"}, {"oid": "7ccccbafa361eabd5dec9631c254852722cd21e9", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/7ccccbafa361eabd5dec9631c254852722cd21e9", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-16T00:00:43Z", "type": "forcePushed"}, {"oid": "7135642bbdbd6ed9bd695fc460248f706686fd14", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/7135642bbdbd6ed9bd695fc460248f706686fd14", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-17T00:55:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2NDEzMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r544964130", "bodyText": "I think you can remove this System.out", "author": "fjtirado", "createdAt": "2020-12-17T10:06:31Z", "path": "kie-spring-boot/kie-spring-boot-samples/kie-server-spring-boot-sample/src/test/java/org/kie/server/springboot/samples/workitems/SendTaskWIH.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package org.kie.server.springboot.samples.workitems;\n+\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemHandler;\n+import org.kie.api.runtime.process.WorkItemManager;\n+import org.springframework.stereotype.Component;\n+\n+@Component(\"Send Task\")\n+public class SendTaskWIH implements WorkItemHandler {\n+\n+    @Override\n+    public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {\n+        System.out.println(\"@@ params wih:\"+workItem.getParameters());", "originalCommit": "7135642bbdbd6ed9bd695fc460248f706686fd14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyMTExMQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2338#discussion_r545221111", "bodyText": "done", "author": "gmunozfe", "createdAt": "2020-12-17T16:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2NDEzMA=="}], "type": "inlineReview"}, {"oid": "29554dd89632f3ff9a75240e73df8432e8a072ee", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/29554dd89632f3ff9a75240e73df8432e8a072ee", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-17T16:20:15Z", "type": "forcePushed"}, {"oid": "de254477f58c124f2cf28ada56bae591e5fd25e0", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/de254477f58c124f2cf28ada56bae591e5fd25e0", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-17T16:24:54Z", "type": "forcePushed"}, {"oid": "bfab997ecb1fd4de0d4a4057b9ee70b5d36ddadd", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/bfab997ecb1fd4de0d4a4057b9ee70b5d36ddadd", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-18T07:31:48Z", "type": "forcePushed"}, {"oid": "885295fe8f79a40e676ad1da010390bd32f0f408", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/885295fe8f79a40e676ad1da010390bd32f0f408", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-18T18:16:49Z", "type": "forcePushed"}, {"oid": "1323430506165393d37c63065a43f9367a7bffdf", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/1323430506165393d37c63065a43f9367a7bffdf", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-22T23:29:21Z", "type": "forcePushed"}, {"oid": "9b546463ad8a72237a2106b63f143467bae64937", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/9b546463ad8a72237a2106b63f143467bae64937", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-23T16:51:34Z", "type": "forcePushed"}, {"oid": "261266664c6c4b24cd987de7e6fefe5fed759f84", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/261266664c6c4b24cd987de7e6fefe5fed759f84", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-23T20:14:33Z", "type": "forcePushed"}, {"oid": "dd4f75c733619378ac6fe858090646157a4ae180", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/dd4f75c733619378ac6fe858090646157a4ae180", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-24T09:26:10Z", "type": "commit"}, {"oid": "dd4f75c733619378ac6fe858090646157a4ae180", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/dd4f75c733619378ac6fe858090646157a4ae180", "message": "Kafka Consumer springboot integration tests", "committedDate": "2020-12-24T09:26:10Z", "type": "forcePushed"}]}