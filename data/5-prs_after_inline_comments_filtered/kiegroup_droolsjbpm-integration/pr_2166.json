{"pr_number": 2166, "pr_title": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)", "pr_createdAt": "2020-07-23T11:57:27Z", "pr_url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166", "timeline": [{"oid": "d64b49dd44d24632a030917fae8eefff1d7f138b", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d64b49dd44d24632a030917fae8eefff1d7f138b", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)", "committedDate": "2020-07-23T16:06:45Z", "type": "forcePushed"}, {"oid": "d0913622968397b74fb0f01c191769a02d5ceb9e", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d0913622968397b74fb0f01c191769a02d5ceb9e", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)", "committedDate": "2020-07-27T14:39:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0NzU5NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166#discussion_r461447595", "bodyText": "There is more precise matcher for this situation:\nhttp://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractAssert.html#isInstanceOf-java.lang.Class-", "author": "rsynek", "createdAt": "2020-07-28T09:30:20Z", "path": "kie-server-parent/kie-server-api/src/test/java/org/kie/server/api/model/KieServerConfigProviderLoaderTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model;\n+\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class KieServerConfigProviderLoaderTest {\n+\n+    @Test\n+    public void getConfigProviders() {\n+        List<KieServerConfigProvider> providers = KieServerConfigProviderLoader.getConfigProviders();\n+        assertThat(providers.size()).isEqualTo(2);\n+        assertThat(providers.stream().anyMatch(provider -> provider instanceof KieServerConfigProvider1)).isTrue();", "originalCommit": "d0913622968397b74fb0f01c191769a02d5ceb9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU4NDU1NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166#discussion_r461584555", "bodyText": "I you see, we have two different provider implementations we want to ensure that were loaded, but we don't have any warrant about the position etc where each instance is located, so it's not straight ahead to ask for the instanceOf the element if we don't know the position here the element is.\nI believe this is more than ok, and fulfill the assertion we want to do", "author": "wmedvede", "createdAt": "2020-07-28T13:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0NzU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3NTg3Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166#discussion_r461475877", "bodyText": "Soft suggestion: assigning solverFactory.getValue().getSolverConfig().getScanAnnotatedClassesConfig() to a local variable will make the following lines more readable", "author": "rsynek", "createdAt": "2020-07-28T10:20:09Z", "path": "kie-server-parent/kie-server-services/kie-server-services-optaplanner/src/test/java/org/kie/server/services/optaplanner/SolverServiceBaseTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.optaplanner;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+\n+import org.drools.core.impl.InternalKieContainer;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.kie.server.api.model.ServiceResponse;\n+import org.kie.server.api.model.instance.SolverInstance;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.impl.KieContainerInstanceImpl;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.SolverFactory;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SolverServiceBaseTest {\n+\n+    private static final String CONTAINER_ID = \"CONTAINER_ID\";\n+    private static final String SOLVER_ID = \"SOLVER_ID\";\n+    private static final String SOLVER_CONFIG = \"org/kie/server/services/optaplanner/SolverConfig.xml\";\n+    private static final String SOLVER_CONFIG_WRONG = \"org/kie/server/services/optaplanner/SolverConfigWrong.xml\";\n+    private static final String SOLVER_CONFIG_GLOBAL_SCAN_SET = \"org/kie/server/services/optaplanner/SolverConfigGlobalScanSet.xml\";\n+    private static final String SOLVER_CONFIG_FILTERED_SCAN_SET = \"org/kie/server/services/optaplanner/SolverConfigFilteredScanSet.xml\";\n+\n+    private static final String PRE_CONFIGURED_PACKAGE_INCLUDE = \"pre.configured.package.include\";\n+    private static final String PRE_CONFIGURED_PACKAGE_EXCLUDE = \"pre.configured.package.exclude\";\n+\n+    private static final String CREATE_SOLVER_FOR_CONTAINER_ERROR = \"Failed to create solver for container %s\";\n+    private static final String CREATE_SOLVER_CONTAINER_NOT_EXISTS_ERROR = \"Failed to create solver. Container does not exist: %s\";\n+    private static final String CREATING_SOLVER_FACTORY_ERROR = \"Error creating solver factory for solver: %s\";\n+    private static final String SOLVER_ALREADY_EXISTS_ERROR = \"Failed to create solver. Solver '%s' already exists for container '%s'.\";\n+    private static final String SOLVER_CREATED_SUCCESSFULLY_MESSAGE = \"Solver '%s' successfully created in container '%s'\";\n+\n+    @Mock\n+    private KieServerRegistry context;\n+\n+    @Mock\n+    private ExecutorService executorService;\n+\n+    @Mock\n+    private SolverInstance solverInstance;\n+\n+    @Mock\n+    private KieContainerInstanceImpl containerInstance;\n+\n+    @Mock\n+    private InternalKieContainer internalKieContainer;\n+\n+    @Captor\n+    private ArgumentCaptor<SolverFactory<Object>> solverFactory;\n+\n+    @Mock\n+    private Solver<Object> solver;\n+\n+    private SolverServiceBase serviceBase;\n+\n+    @Before\n+    public void setUp() {\n+        solverInstance = new SolverInstance();\n+        solverInstance.setContainerId(CONTAINER_ID);\n+        solverInstance.setSolverId(SOLVER_ID);\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG);\n+\n+        doReturn(CONTAINER_ID).when(containerInstance).getContainerId();\n+        doReturn(internalKieContainer).when(containerInstance).getKieContainer();\n+        doReturn(getClass().getClassLoader()).when(internalKieContainer).getClassLoader();\n+        doReturn(containerInstance).when(context).getContainer(CONTAINER_ID);\n+\n+        serviceBase = spy(new SolverServiceBase(context, executorService));\n+    }\n+\n+    @Test\n+    public void createSolverWithInstanceNullFailure() {\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, null);\n+        assertFailure(response, String.format(CREATE_SOLVER_FOR_CONTAINER_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithConfigFileNullFailure() {\n+        solverInstance.setSolverConfigFile(null);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATE_SOLVER_FOR_CONTAINER_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithContainerNotExistsFailure() {\n+        when(context.getContainer(CONTAINER_ID)).thenReturn(null);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATE_SOLVER_CONTAINER_NOT_EXISTS_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithSolverConfigurationFileWrongFailure() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_WRONG);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATING_SOLVER_FACTORY_ERROR, \"\"));\n+    }\n+\n+    @Test\n+    public void createSolverWithErrorCreatingSolverFailure() {\n+        String internalError = \"An error was produced\";\n+        doThrow(new RuntimeException(internalError))\n+                .when(serviceBase)\n+                .newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+        assertFailure(response, String.format(CREATING_SOLVER_FACTORY_ERROR, internalError));\n+    }\n+\n+    @Test\n+    public void createSolverWithSolverAlreadyExistsFailure() {\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(SOLVER_ALREADY_EXISTS_ERROR, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithNoScanSetSuccessful() {\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithGlobalScanSetSuccessful() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_GLOBAL_SCAN_SET);\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(Arrays.asList(TestConfigProvider1.PACKAGE1,\n+                                                   TestConfigProvider1.PACKAGE2,\n+                                                   TestConfigProvider1.PACKAGE3,\n+                                                   TestConfigProvider2.PACKAGE1));\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithFilteredScanSetSuccessful() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_FILTERED_SCAN_SET);\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(Collections.singletonList(PRE_CONFIGURED_PACKAGE_INCLUDE),\n+                                     Arrays.asList(TestConfigProvider1.PACKAGE1,\n+                                                   TestConfigProvider1.PACKAGE2,\n+                                                   TestConfigProvider1.PACKAGE3,\n+                                                   TestConfigProvider2.PACKAGE1,\n+                                                   PRE_CONFIGURED_PACKAGE_EXCLUDE));\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    private void assertFailure(ServiceResponse<SolverInstance> response, String messagePrefix) {\n+        assertThat(response.getType()).isEqualTo(ServiceResponse.ResponseType.FAILURE);\n+        assertThat(response.getMsg()).startsWith(messagePrefix);\n+    }\n+\n+    private void assertSuccess(ServiceResponse<SolverInstance> response, String messagePrefix) {\n+        assertThat(response.getType()).isEqualTo(ServiceResponse.ResponseType.SUCCESS);\n+        assertThat(response.getMsg()).startsWith(messagePrefix);\n+    }\n+\n+    private void assertBuildFactoryWasInvoked(List<String> expectedExcludedPackages) {\n+        assertBuildFactoryWasInvoked(null, expectedExcludedPackages);\n+    }\n+\n+    private void assertBuildFactoryWasInvoked(List<String> expectedIncludedPackages, List<String> expectedExcludedPackages) {\n+        verify(serviceBase).newSolver(solverFactory.capture());\n+        if (expectedExcludedPackages != null) {\n+            assertThat(solverFactory.getValue().getSolverConfig().getScanAnnotatedClassesConfig()).isNotNull();", "originalCommit": "d0913622968397b74fb0f01c191769a02d5ceb9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3OTgyMQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166#discussion_r461479821", "bodyText": "Soft suggestion: if the goal is to verify the list contains all items of the expected list and nothing else, there is either containsExactlyElementsOf or containsExactlyInAnyOrderElementsOf - depends whether you care about element order in the collections.", "author": "rsynek", "createdAt": "2020-07-28T10:27:59Z", "path": "kie-server-parent/kie-server-services/kie-server-services-optaplanner/src/test/java/org/kie/server/services/optaplanner/SolverServiceBaseTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.optaplanner;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+\n+import org.drools.core.impl.InternalKieContainer;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.kie.server.api.model.ServiceResponse;\n+import org.kie.server.api.model.instance.SolverInstance;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.impl.KieContainerInstanceImpl;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.SolverFactory;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SolverServiceBaseTest {\n+\n+    private static final String CONTAINER_ID = \"CONTAINER_ID\";\n+    private static final String SOLVER_ID = \"SOLVER_ID\";\n+    private static final String SOLVER_CONFIG = \"org/kie/server/services/optaplanner/SolverConfig.xml\";\n+    private static final String SOLVER_CONFIG_WRONG = \"org/kie/server/services/optaplanner/SolverConfigWrong.xml\";\n+    private static final String SOLVER_CONFIG_GLOBAL_SCAN_SET = \"org/kie/server/services/optaplanner/SolverConfigGlobalScanSet.xml\";\n+    private static final String SOLVER_CONFIG_FILTERED_SCAN_SET = \"org/kie/server/services/optaplanner/SolverConfigFilteredScanSet.xml\";\n+\n+    private static final String PRE_CONFIGURED_PACKAGE_INCLUDE = \"pre.configured.package.include\";\n+    private static final String PRE_CONFIGURED_PACKAGE_EXCLUDE = \"pre.configured.package.exclude\";\n+\n+    private static final String CREATE_SOLVER_FOR_CONTAINER_ERROR = \"Failed to create solver for container %s\";\n+    private static final String CREATE_SOLVER_CONTAINER_NOT_EXISTS_ERROR = \"Failed to create solver. Container does not exist: %s\";\n+    private static final String CREATING_SOLVER_FACTORY_ERROR = \"Error creating solver factory for solver: %s\";\n+    private static final String SOLVER_ALREADY_EXISTS_ERROR = \"Failed to create solver. Solver '%s' already exists for container '%s'.\";\n+    private static final String SOLVER_CREATED_SUCCESSFULLY_MESSAGE = \"Solver '%s' successfully created in container '%s'\";\n+\n+    @Mock\n+    private KieServerRegistry context;\n+\n+    @Mock\n+    private ExecutorService executorService;\n+\n+    @Mock\n+    private SolverInstance solverInstance;\n+\n+    @Mock\n+    private KieContainerInstanceImpl containerInstance;\n+\n+    @Mock\n+    private InternalKieContainer internalKieContainer;\n+\n+    @Captor\n+    private ArgumentCaptor<SolverFactory<Object>> solverFactory;\n+\n+    @Mock\n+    private Solver<Object> solver;\n+\n+    private SolverServiceBase serviceBase;\n+\n+    @Before\n+    public void setUp() {\n+        solverInstance = new SolverInstance();\n+        solverInstance.setContainerId(CONTAINER_ID);\n+        solverInstance.setSolverId(SOLVER_ID);\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG);\n+\n+        doReturn(CONTAINER_ID).when(containerInstance).getContainerId();\n+        doReturn(internalKieContainer).when(containerInstance).getKieContainer();\n+        doReturn(getClass().getClassLoader()).when(internalKieContainer).getClassLoader();\n+        doReturn(containerInstance).when(context).getContainer(CONTAINER_ID);\n+\n+        serviceBase = spy(new SolverServiceBase(context, executorService));\n+    }\n+\n+    @Test\n+    public void createSolverWithInstanceNullFailure() {\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, null);\n+        assertFailure(response, String.format(CREATE_SOLVER_FOR_CONTAINER_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithConfigFileNullFailure() {\n+        solverInstance.setSolverConfigFile(null);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATE_SOLVER_FOR_CONTAINER_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithContainerNotExistsFailure() {\n+        when(context.getContainer(CONTAINER_ID)).thenReturn(null);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATE_SOLVER_CONTAINER_NOT_EXISTS_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithSolverConfigurationFileWrongFailure() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_WRONG);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATING_SOLVER_FACTORY_ERROR, \"\"));\n+    }\n+\n+    @Test\n+    public void createSolverWithErrorCreatingSolverFailure() {\n+        String internalError = \"An error was produced\";\n+        doThrow(new RuntimeException(internalError))\n+                .when(serviceBase)\n+                .newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+        assertFailure(response, String.format(CREATING_SOLVER_FACTORY_ERROR, internalError));\n+    }\n+\n+    @Test\n+    public void createSolverWithSolverAlreadyExistsFailure() {\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(SOLVER_ALREADY_EXISTS_ERROR, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithNoScanSetSuccessful() {\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithGlobalScanSetSuccessful() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_GLOBAL_SCAN_SET);\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(Arrays.asList(TestConfigProvider1.PACKAGE1,\n+                                                   TestConfigProvider1.PACKAGE2,\n+                                                   TestConfigProvider1.PACKAGE3,\n+                                                   TestConfigProvider2.PACKAGE1));\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithFilteredScanSetSuccessful() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_FILTERED_SCAN_SET);\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(Collections.singletonList(PRE_CONFIGURED_PACKAGE_INCLUDE),\n+                                     Arrays.asList(TestConfigProvider1.PACKAGE1,\n+                                                   TestConfigProvider1.PACKAGE2,\n+                                                   TestConfigProvider1.PACKAGE3,\n+                                                   TestConfigProvider2.PACKAGE1,\n+                                                   PRE_CONFIGURED_PACKAGE_EXCLUDE));\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    private void assertFailure(ServiceResponse<SolverInstance> response, String messagePrefix) {\n+        assertThat(response.getType()).isEqualTo(ServiceResponse.ResponseType.FAILURE);\n+        assertThat(response.getMsg()).startsWith(messagePrefix);\n+    }\n+\n+    private void assertSuccess(ServiceResponse<SolverInstance> response, String messagePrefix) {\n+        assertThat(response.getType()).isEqualTo(ServiceResponse.ResponseType.SUCCESS);\n+        assertThat(response.getMsg()).startsWith(messagePrefix);\n+    }\n+\n+    private void assertBuildFactoryWasInvoked(List<String> expectedExcludedPackages) {\n+        assertBuildFactoryWasInvoked(null, expectedExcludedPackages);\n+    }\n+\n+    private void assertBuildFactoryWasInvoked(List<String> expectedIncludedPackages, List<String> expectedExcludedPackages) {\n+        verify(serviceBase).newSolver(solverFactory.capture());\n+        if (expectedExcludedPackages != null) {\n+            assertThat(solverFactory.getValue().getSolverConfig().getScanAnnotatedClassesConfig()).isNotNull();\n+            assertThat(solverFactory.getValue().getSolverConfig().getScanAnnotatedClassesConfig().getPackageExcludeList()).hasSize(expectedExcludedPackages.size());\n+            assertThat(solverFactory.getValue().getSolverConfig().getScanAnnotatedClassesConfig().getPackageExcludeList()).containsAll(expectedExcludedPackages);", "originalCommit": "d0913622968397b74fb0f01c191769a02d5ceb9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "91df80ea50ec2db8dbbfe515dc9d47551494a3e5", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/91df80ea50ec2db8dbbfe515dc9d47551494a3e5", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)", "committedDate": "2020-07-28T13:59:16Z", "type": "forcePushed"}, {"oid": "5a3d9621adb1e36d68d1d7c918d4212cc4c6e5f4", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/5a3d9621adb1e36d68d1d7c918d4212cc4c6e5f4", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)", "committedDate": "2020-07-28T14:13:16Z", "type": "commit"}, {"oid": "5a3d9621adb1e36d68d1d7c918d4212cc4c6e5f4", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/5a3d9621adb1e36d68d1d7c918d4212cc4c6e5f4", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)", "committedDate": "2020-07-28T14:13:16Z", "type": "forcePushed"}]}