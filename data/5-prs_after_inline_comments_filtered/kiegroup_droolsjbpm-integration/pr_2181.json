{"pr_number": 2181, "pr_title": "PLANNER-2087: Assign a time budget for the LS to execute", "pr_createdAt": "2020-08-05T16:55:49Z", "pr_url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181", "timeline": [{"oid": "d788d67cb631acbc8c8841da04fbb1920320d1ec", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d788d67cb631acbc8c8841da04fbb1920320d1ec", "message": "PLANNER-2087: Assign a time budget for the LS to execute", "committedDate": "2020-08-06T09:47:10Z", "type": "forcePushed"}, {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/8744ee8013894c78258d26726e3da7de98aaeb95", "message": "PLANNER-2087: Assign a time budget for the LS to execute", "committedDate": "2020-08-06T12:57:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg4ODE3Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466888172", "bodyText": "Could you please explain why the pool has exactly 4 threads?", "author": "rsynek", "createdAt": "2020-08-07T08:06:30Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/TaskAssigningPlanningKieServerExtension.java", "diffHunk": "@@ -154,7 +154,7 @@ public void init(KieServerImpl kieServer, KieServerRegistry registry) {\n             throw new KieServicesException(String.format(USER_SYSTEM_CONFIGURATION_ERROR, e.getMessage()), e);\n         }\n \n-        this.executorService = Executors.newFixedThreadPool(3);\n+        this.executorService = Executors.newScheduledThreadPool(4);", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwNDI0MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r467004241", "bodyText": "The solverExecutor, solutionProcessor and solutionSynchronizer are threads running at the same time. This last added thread is for being able to have a fourth slot to be scheduled for the firstLevelLocalSearch time.", "author": "wmedvede", "createdAt": "2020-08-07T12:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg4ODE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNTMyMw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466905323", "bodyText": "Why not failing fast in the constructor if the usersSyncInterval is < 0 ?", "author": "rsynek", "createdAt": "2020-08-07T08:41:36Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -263,11 +324,29 @@ Action doSynchronizeSolution() {\n     }\n \n     protected boolean isUsersSyncTime() {\n-        return System.currentTimeMillis() > nextUsersSyncTime;\n+        return nextUsersSyncTime > 0 && getSystemTime() > nextUsersSyncTime;\n     }\n \n     protected long calculateNextUsersSyncTime() {\n-        return System.currentTimeMillis() + usersSyncInterval.toMillis();\n+        if (usersSyncInterval.toMillis() > 0) {", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwNTA4NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r467005084", "bodyText": "could be an option, I personally prefer this.", "author": "wmedvede", "createdAt": "2020-08-07T12:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNTMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNjU3NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466906575", "bodyText": "Is it really necessary to accept negative or zero periods if we ignore them later? Why not failing fast?", "author": "rsynek", "createdAt": "2020-08-07T08:44:09Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -119,12 +148,32 @@ public void initSolverExecutor() {\n         startPermit.release();\n     }\n \n+    /**\n+     * Starts the synchronization of the solution from the indicated last modification date.\n+     * @param solution a non null solution instance to synchronize.\n+     * @param fromLastModificationDate filtering parameter for reading the modifications.\n+     */\n     public void synchronizeSolution(TaskAssigningSolution solution, LocalDateTime fromLastModificationDate) {\n+        synchronizeSolution(solution, fromLastModificationDate, Duration.ofMillis(0));\n+    }\n+\n+    /**\n+     * Starts the synchronization of the solution from the indicated last modification date.\n+     * @param solution a non null solution instance to synchronize.\n+     * @param fromLastModificationDate filtering parameter for reading the modifications.\n+     * @param unchangedPeriodTimeout a non null period of time for returning from the synchronization if no changes were\n+     * produced during that period. A negative or zero period is ignored.", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwNjM0NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r467006345", "bodyText": "same as above, nobody will configure things like \"wait -10 seconds\". I think it's ok.", "author": "wmedvede", "createdAt": "2020-08-07T12:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNjU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzMDk3MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r467030970", "bodyText": "Most often no, but when somebody does, it's better to give him a nudge instead of silently ignoring wrong input.\nAccepting unsanitized inputs leads to unnecessary complexity of the code doing calculations based on it, like here:\nhttps://github.com/kiegroup/droolsjbpm-integration/pull/2181/files/8744ee8013894c78258d26726e3da7de98aaeb95#diff-286401b0213653b16fad9e16daab206cR341-R345", "author": "rsynek", "createdAt": "2020-08-07T13:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNjU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3MTU2Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r468871563", "bodyText": "was applied", "author": "wmedvede", "createdAt": "2020-08-11T21:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNjU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkxNjI5NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466916295", "bodyText": "Suggestion: if the Result had nextAction field, we wouldn't need to use the generic Pair.", "author": "rsynek", "createdAt": "2020-08-07T09:02:56Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -143,23 +192,18 @@ public void destroy() {\n     @Override\n     public void run() {\n         LOGGER.debug(\"Solution Synchronizer Started\");\n-        Action nextAction;\n+        Pair<Action, Result> nextActionOrResult;", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwODMwNg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r467008306", "bodyText": "yes, but the Result is what is exposed to the configured \"consumer\", e.g. for passing the produced changes, and the nextAction is internal to the SolutionSynchronizer and there's no need to expose it to the outside.", "author": "wmedvede", "createdAt": "2020-08-07T12:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkxNjI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkyODAwNw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466928007", "bodyText": "Thinking aloud:\nDoes the firstLevelLocalSearchTime and secondLevelLocalSearchTime set expectations regarding which one blocks?\nHow about:\nwaitForImprovedSolutionDuration vs. improveSolutionOnBackgroundDuration", "author": "rsynek", "createdAt": "2020-08-07T09:26:12Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/TaskAssigningConstants.java", "diffHunk": "@@ -91,6 +91,32 @@ private TaskAssigningConstants() {\n      */\n     public static final String TASK_ASSIGNING_USERS_SYNC_INTERVAL = \"org.kie.server.taskAssigning.usersSyncInterval\";\n \n+    /**\n+     * Property for configuring the amount of time to execute LS phase before sending any plan to the kie-server with\n+     * the jBPM runtime. Allows an early improvement of the solution. This value should typically be low, e.g. 500\n+     * milliseconds, etc.\n+     *\n+     * The formats accepted are based on the ISO-8601 duration format {@code PnDTnHnMn.nS} with days considered to\n+     * be exactly 24 hours.\n+     * <p>\n+     * e.g.\n+     * \"PT0.500S\"  configures 500 milliseconds.\n+     */\n+    public static final String TASK_ASSIGNING_FIRST_LEVEL_LOCAL_SEARCH_TIME = \"org.kie.server.taskAssigning.firstLevelLocalSearchTime\";", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzMjYzNQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r467032635", "bodyText": "yes..., was not direct to find a good name for this configuration parameters (an explanation will go in the documentation in all cases) , good thing about this current names is that the term \"LocalSearch\", that in the end is what the configuration is about, somehow links to the OptaPlanner LS. Will think a bit", "author": "wmedvede", "createdAt": "2020-08-07T13:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkyODAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzNTg1MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r467035850", "bodyText": "That's a question: does the user, in this case probably a system administrator, who is configuring the task assigning, need to understand it runs some local search under the hood?\nShould the name of the parameter reflect its observable effect or internal implementation? I would argue rather the former, wdyt?", "author": "rsynek", "createdAt": "2020-08-07T13:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkyODAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4MTE2Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r467081163", "bodyText": "well, in some way, yes, but unfortunately the configuration of all the task assigning integration has many aspects that are very closely to OptaPlanner, and it's not neccesary a bad thing. e.g.\nwe could eventually configure things like\norg.kie.server.taskAssigning.solver.configResource\norg.kie.server.taskAssigning.solver.moveThreadCount\norg.kie.server.taskAssigning.solver.moveThreadBufferSize\norg.kie.server.taskAssigning.solver.threadFactoryClass\nand I think it's a good thing, since it's links you to OptaPlanner that is the in the end what we'll always have behind the scene. Additionally it helps to have a quick link with OptaPlanner documentation, etc.\nThis two new parametes are a kind of \"in the middle\"", "author": "wmedvede", "createdAt": "2020-08-07T14:36:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkyODAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMTc2Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466931766", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {\n          \n          \n            \n                private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {\n          \n      \n    \n    \n  \n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {\n          \n          \n            \n                private void scheduleOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {", "author": "rsynek", "createdAt": "2020-08-07T09:33:39Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandler.java", "diffHunk": "@@ -164,24 +177,84 @@ private void addProblemFactChanges(List<ProblemFactChange<TaskAssigningSolution>\n      * @param event event produced by the solver.\n      */\n     private void onBestSolutionChange(BestSolutionChangedEvent<TaskAssigningSolution> event) {\n-        LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {}, isCurrentChangeSetProcessed: {}\",\n-                     event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(), context.isProcessedChangeSet(context.getCurrentChangeSetId()));\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {},\" +\n+                                 \" isCurrentChangeSetProcessed: {}, newBestSolution: {}\",\n+                         event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(),\n+                         context.isProcessedChangeSet(context.getCurrentChangeSetId()), event.getNewBestSolution());\n+        }\n+\n+        TaskAssigningSolution newBestSolution = event.getNewBestSolution();\n+        if (event.isEveryProblemFactChangeProcessed() && newBestSolution.getScore().isSolutionInitialized()) {\n+            lastBestSolution.set(newBestSolution);\n+            if (hasFirstLevelLocalSearchTime()) {\n+                scheduledOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());\n+            } else {\n+                onBestSolutionChange(newBestSolution);\n+            }\n+        }\n+    }\n \n-        if (event.isEveryProblemFactChangeProcessed() &&\n-                event.getNewBestSolution().getScore().isSolutionInitialized() &&\n-                !context.isProcessedChangeSet(context.getCurrentChangeSetId())) {\n+    private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMjE1NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466932154", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            scheduledOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());\n          \n          \n            \n                            scheduleOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());", "author": "rsynek", "createdAt": "2020-08-07T09:34:29Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandler.java", "diffHunk": "@@ -164,24 +177,84 @@ private void addProblemFactChanges(List<ProblemFactChange<TaskAssigningSolution>\n      * @param event event produced by the solver.\n      */\n     private void onBestSolutionChange(BestSolutionChangedEvent<TaskAssigningSolution> event) {\n-        LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {}, isCurrentChangeSetProcessed: {}\",\n-                     event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(), context.isProcessedChangeSet(context.getCurrentChangeSetId()));\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {},\" +\n+                                 \" isCurrentChangeSetProcessed: {}, newBestSolution: {}\",\n+                         event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(),\n+                         context.isProcessedChangeSet(context.getCurrentChangeSetId()), event.getNewBestSolution());\n+        }\n+\n+        TaskAssigningSolution newBestSolution = event.getNewBestSolution();\n+        if (event.isEveryProblemFactChangeProcessed() && newBestSolution.getScore().isSolutionInitialized()) {\n+            lastBestSolution.set(newBestSolution);\n+            if (hasFirstLevelLocalSearchTime()) {\n+                scheduledOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMzk2Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466933966", "bodyText": "The SolverHandlerContext already knows everything to be able to provide \"isProcessedCurrentChangeSet\". No need to ask it for the current changeset ID only to pass it back.", "author": "rsynek", "createdAt": "2020-08-07T09:38:19Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandler.java", "diffHunk": "@@ -164,24 +177,84 @@ private void addProblemFactChanges(List<ProblemFactChange<TaskAssigningSolution>\n      * @param event event produced by the solver.\n      */\n     private void onBestSolutionChange(BestSolutionChangedEvent<TaskAssigningSolution> event) {\n-        LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {}, isCurrentChangeSetProcessed: {}\",\n-                     event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(), context.isProcessedChangeSet(context.getCurrentChangeSetId()));\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {},\" +\n+                                 \" isCurrentChangeSetProcessed: {}, newBestSolution: {}\",\n+                         event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(),\n+                         context.isProcessedChangeSet(context.getCurrentChangeSetId()), event.getNewBestSolution());\n+        }\n+\n+        TaskAssigningSolution newBestSolution = event.getNewBestSolution();\n+        if (event.isEveryProblemFactChangeProcessed() && newBestSolution.getScore().isSolutionInitialized()) {\n+            lastBestSolution.set(newBestSolution);\n+            if (hasFirstLevelLocalSearchTime()) {\n+                scheduledOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());\n+            } else {\n+                onBestSolutionChange(newBestSolution);\n+            }\n+        }\n+    }\n \n-        if (event.isEveryProblemFactChangeProcessed() &&\n-                event.getNewBestSolution().getScore().isSolutionInitialized() &&\n-                !context.isProcessedChangeSet(context.getCurrentChangeSetId())) {\n+    private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {\n+        if (scheduledFuture.get() == null && !context.isProcessedChangeSet(context.getCurrentChangeSetId())) {", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNTk5NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466935994", "bodyText": "Is the check for the same instance of a solution intended?", "author": "rsynek", "createdAt": "2020-08-07T09:42:23Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandler.java", "diffHunk": "@@ -164,24 +177,84 @@ private void addProblemFactChanges(List<ProblemFactChange<TaskAssigningSolution>\n      * @param event event produced by the solver.\n      */\n     private void onBestSolutionChange(BestSolutionChangedEvent<TaskAssigningSolution> event) {\n-        LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {}, isCurrentChangeSetProcessed: {}\",\n-                     event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(), context.isProcessedChangeSet(context.getCurrentChangeSetId()));\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {},\" +\n+                                 \" isCurrentChangeSetProcessed: {}, newBestSolution: {}\",\n+                         event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(),\n+                         context.isProcessedChangeSet(context.getCurrentChangeSetId()), event.getNewBestSolution());\n+        }\n+\n+        TaskAssigningSolution newBestSolution = event.getNewBestSolution();\n+        if (event.isEveryProblemFactChangeProcessed() && newBestSolution.getScore().isSolutionInitialized()) {\n+            lastBestSolution.set(newBestSolution);\n+            if (hasFirstLevelLocalSearchTime()) {\n+                scheduledOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());\n+            } else {\n+                onBestSolutionChange(newBestSolution);\n+            }\n+        }\n+    }\n \n-        if (event.isEveryProblemFactChangeProcessed() &&\n-                event.getNewBestSolution().getScore().isSolutionInitialized() &&\n-                !context.isProcessedChangeSet(context.getCurrentChangeSetId())) {\n+    private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {\n+        if (scheduledFuture.get() == null && !context.isProcessedChangeSet(context.getCurrentChangeSetId())) {\n             lock.lock();\n+            LOGGER.debug(\"Schedule execute solution change with previous chBestSolution: {}\", chBestSolution);\n             try {\n-                LOGGER.debug(\"A new solution has been produced for changeSetId: {}\", context.getCurrentChangeSetId());\n-                currentSolution = event.getNewBestSolution();\n-                context.setProcessedChangeSet(context.getCurrentChangeSetId());\n-                solutionProcessor.process(currentSolution);\n+                Supplier<TaskAssigningSolution> solutionSupplier = () -> lastBestSolution.get();\n+                ScheduledFuture<?> future = executorService.schedule(() -> executeSolutionChange(chBestSolution, solutionSupplier),\n+                                                                     delay,\n+                                                                     TimeUnit.MILLISECONDS);\n+                scheduledFuture.set(future);\n             } finally {\n                 lock.unlock();\n             }\n         }\n     }\n \n+    private void onBestSolutionChange(TaskAssigningSolution newBestSolution) {\n+        if (!context.isProcessedChangeSet(context.getCurrentChangeSetId())) {\n+            executeSolutionChange(newBestSolution);\n+        }\n+    }\n+\n+    private void executeSolutionChange(TaskAssigningSolution chBestSolution, Supplier<TaskAssigningSolution> solutionSupplier) {\n+        lock.lock();\n+        try {\n+            TaskAssigningSolution currentLastBestSolution = solutionSupplier.get();\n+            LOGGER.debug(\"Executing delayed solution change for currentChangeSetId: {}, lastBestSolution: {}, lastBestSolution: {}\",\n+                         context.getCurrentChangeSetId(), currentLastBestSolution.getScore(), currentLastBestSolution);\n+\n+            if (chBestSolution == currentLastBestSolution) {", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAxNDY2NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r467014665", "bodyText": "yes.", "author": "wmedvede", "createdAt": "2020-08-07T12:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk1NzM0MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466957340", "bodyText": "Do we need the compound condition? Maybe we should send the new best solution if its score is better than the score of the current solution.", "author": "rsynek", "createdAt": "2020-08-07T10:28:58Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandler.java", "diffHunk": "@@ -215,13 +295,32 @@ private void onSolutionProcessed(SolutionProcessor.Result result) {\n \n     /**\n      * Invoked every time the SolutionSynchronizer gets updated information from the jBPM runtime and there are changes\n-     * to apply.\n+     * to apply, or when the configurable amount of time with no changes has elapsed.\n      * @param result Contains the list of changes to apply.\n      */\n-    private void onUpdateSolution(SolutionSynchronizer.Result result) {\n+    private void onSolutionSynchronized(SolutionSynchronizer.Result result) {\n         lock.lock();\n         try {\n-            addProblemFactChanges(result.getChanges());\n+            if (result.hasChanges()) {\n+                addProblemFactChanges(result.getChanges());\n+            } else {\n+                LOGGER.debug(\"Processing synchronization unchanged period timeout. Checking if there is a\" +\n+                                     \" lastBestSolution with an improved score to send\");\n+                TaskAssigningSolution bestSolution = lastBestSolution.get();\n+                secondLevelSolutionSent.set(true);\n+                if (currentSolution.get() != bestSolution && !currentSolution.get().getScore().equals(bestSolution.getScore())) {", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk1ODg0OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466958849", "bodyText": "Why not start at 0?", "author": "rsynek", "createdAt": "2020-08-07T10:32:30Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizerTest.java", "diffHunk": "@@ -57,6 +62,7 @@\n     private static final Duration SYNCH_INTERVAL = Duration.ofMillis(2);\n     private static final Duration USERS_SYNCH_INTERVAL = Duration.ofMillis(4000);\n     private static final Duration QUERY_SHIFT = Duration.parse(\"PT2S\");\n+    private static final long SYSTEM_TIME = 123;", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk2MjA4Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466962086", "bodyText": "If the goal is to test the propagation of the parameters to the SolverHandler, the assertion should be the other way around:\nassertThat(handler.getTargetUserId()).isEqualTo(TARGET_USER);\nPlease see the other tests too.", "author": "rsynek", "createdAt": "2020-08-07T10:40:11Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolverHandlerTest.java", "diffHunk": "@@ -125,6 +149,62 @@ public void setUp() {\n         doReturn(solutionProcessor).when(handler).createSolutionProcessor(eq(delegate), any(), eq(TARGET_USER), anyInt());\n     }\n \n+    @After\n+    public void cleanUp() {\n+        System.clearProperty(TASK_ASSIGNING_PROCESS_RUNTIME_TARGET_USER);\n+        System.clearProperty(TASK_ASSIGNING_PUBLISH_WINDOW_SIZE);\n+        System.clearProperty(TASK_ASSIGNING_SYNC_INTERVAL);\n+        System.clearProperty(TASK_ASSIGNING_SYNC_QUERIES_SHIFT);\n+        System.clearProperty(TASK_ASSIGNING_USERS_SYNC_INTERVAL);\n+        System.clearProperty(TASK_ASSIGNING_FIRST_LEVEL_LOCAL_SEARCH_TIME);\n+        System.clearProperty(TASK_ASSIGNING_SECOND_LEVEL_LOCAL_SEARCH_TIME);\n+    }\n+\n+    @Test\n+    public void getTargetUserId() {\n+        assertThat(TARGET_USER).isEqualTo(handler.getTargetUserId());", "originalCommit": "8744ee8013894c78258d26726e3da7de98aaeb95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAyNTE0MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r467025141", "bodyText": "damn, good catch.", "author": "wmedvede", "createdAt": "2020-08-07T13:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk2MjA4Ng=="}], "type": "inlineReview"}, {"oid": "d200a976c0cc13f6db9f73e57a53bf55ee239366", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d200a976c0cc13f6db9f73e57a53bf55ee239366", "message": "PLANNER-2087: Assign a time budget for the LS to execute", "committedDate": "2020-08-11T14:55:17Z", "type": "forcePushed"}, {"oid": "8405abf152c66b506ac8625f71137c796076c693", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/8405abf152c66b506ac8625f71137c796076c693", "message": "PLANNER-2087: Assign a time budget for the LS to execute", "committedDate": "2020-08-12T04:44:11Z", "type": "commit"}, {"oid": "8405abf152c66b506ac8625f71137c796076c693", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/8405abf152c66b506ac8625f71137c796076c693", "message": "PLANNER-2087: Assign a time budget for the LS to execute", "committedDate": "2020-08-12T04:44:11Z", "type": "forcePushed"}]}