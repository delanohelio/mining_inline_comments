{"pr_number": 2059, "pr_title": "PLANNER-1943: [Task assignment] Ensure previous query time is used when synchronization is re-runned", "pr_createdAt": "2020-04-07T21:21:53Z", "pr_url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059", "timeline": [{"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "message": "PLANNER-1943: [Task assignment] Ensure previous query time is used when synchronization is re-runned", "committedDate": "2020-04-08T06:56:56Z", "type": "commit"}, {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "message": "PLANNER-1943: [Task assignment] Ensure previous query time is used when synchronization is re-runned", "committedDate": "2020-04-08T06:56:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyMzY4Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405323683", "bodyText": "Nitpicking: multiline comment is more suitable here for easier readability.", "author": "rsynek", "createdAt": "2020-04-08T07:47:45Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizerTest.java", "diffHunk": "@@ -142,17 +156,41 @@ public void synchronizeSolution() throws Exception {\n         // wait for the query executions to happen\n         queryExecutionsCountDown.await();\n \n-        //execution0: initial query execution was ok, but result0 has no results.\n-        verify(delegate).findTasks(anyList(), eq(startTime.withNano(0)), anyObject());\n-        //execution1: next retry is with result0.queryTime, but result1 hs no results.\n-        verify(delegate).findTasks(anyList(), eq(results.get(0).getQueryTime().withNano(0)), anyObject());\n-        //execution2: next retry is with result1.queryTime, but result2 has no results.\n-        verify(delegate).findTasks(anyList(), eq(results.get(1).getQueryTime().withNano(0)), anyObject());\n-        //execution3: next retry is with result2.queryTime. but execution3 and execution4 failed.\n-        verify(delegate, times(3)).findTasks(anyList(), eq(results.get(2).getQueryTime().withNano(0)), anyObject());\n-        //execution5: executed ok., but result5 has no results. next retry is with result5.queryTime\n-        verify(delegate).findTasks(anyList(), eq(results.get(5).getQueryTime().withNano(0)), anyObject());\n-        //result6, executed ok and produced changes.\n+        // initial setup queryTimes -> [startTime]\n+        // execution0:\n+        //    execute query with lastModification = startTime\n+        //    execution was ok, but result0 has no results.\n+        //    nextQueryTime = startTime since minimum distance with result0.getQueryTime() is not met -> queryTimes -> [startTime, startTime]\n+        // execution1:\n+        //     execute query with lastModification = startTime\n+        //     execution is ok, but result1 has no values.\n+        //     nextQueryTime = result1.getQueryTime() since minimum distance with startTime is met -> [startTime, result1.getQueryTime()]\n+        // execution2:\n+        //     execute query with lastModification = startTime\n+        //     execution is ok, but result2 has no values.\n+        //     nextQueryTime = result1.getQueryTime() since minimum distance with result2.getQueryTime() is not met -> [result1.getQueryTime(), result1.getQueryTime()]\n+        // execution3:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution fails.\n+        //     a retry is produced. -> [result1.getQueryTime(), result1.getQueryTime()]\n+        // execution4:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution fails.\n+        //     a retry is produced. -> [result1.getQueryTime(), result1.getQueryTime()]\n+        // execution5:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution is ok, but result5 has no values\n+        //     nextQueryTime = result5.getQueryTime() since minimum distance with result1.getQueryTime() is met -> [result1.getQueryTime(), result5.getQueryTime()]\n+        // execution6:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution is ok, and result6 has values!\n+        //     nextQueryTime = result6.getQueryTime() since minimum distance is met -> [result5.getQueryTime(), result6.getQueryTime()]\n+        //     End of loop since results are produced.", "originalCommit": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyNjQ1MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405326450", "bodyText": "I think the forEach can be called directly from the stream, right after the map call.", "author": "rsynek", "createdAt": "2020-04-08T07:52:31Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandlerContext.java", "diffHunk": "@@ -49,11 +67,113 @@ public void clearProcessedChangeSet() {\n         lastProcessedChangeSetId = -1;\n     }\n \n-    public LocalDateTime getLastModificationDate() {\n-        return lastModificationDate;\n+    /**\n+     * Registers the time of the last change processed for a task.\n+     * @param taskId identifier of the task to register.\n+     * @param changeTime the task change time to register.\n+     */\n+    public void setTaskChangeTime(long taskId, LocalDateTime changeTime) {\n+        taskChangeTimes.put(taskId, changeTime);\n+    }\n+\n+    /**\n+     * Indicates if a change has already been processed for a given task.\n+     * @param taskId identifier of the task to query.\n+     * @param changeTime the task change time to query.\n+     * @return true if the change has already been processed, false in any other case.\n+     */\n+    public boolean isProcessedTaskChange(long taskId, LocalDateTime changeTime) {\n+        return changeTime.equals(taskChangeTimes.get(taskId));\n+    }\n+\n+    /**\n+     * Removes all the registered task change times that occurred strictly before a given time.\n+     * @param untilLocalDateTime the time for filtering the changes to remove.\n+     */\n+    public void clearTaskChangeTimes(LocalDateTime untilLocalDateTime) {\n+        if (untilLocalDateTime != null) {\n+            final List<Long> removableChanges = taskChangeTimes.entrySet().stream()\n+                    .filter(entry -> untilLocalDateTime.compareTo(entry.getValue()) > 0)\n+                    .map(Map.Entry::getKey)\n+                    .collect(Collectors.toList());\n+            removableChanges.forEach(removableChange -> taskChangeTimes.remove(removableChange));", "originalCommit": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM2MjAyNQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405362025", "bodyText": "the forEach can be chained after the .collect(Collectos.toList()) but not not after the map, otherwise a java.util.ConcurrentModificationException will be produced", "author": "wmedvede", "createdAt": "2020-04-08T08:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyNjQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyODQ1OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405328459", "bodyText": "SonarCloud complains about potential NPE due to nextQueryTime might be null.", "author": "rsynek", "createdAt": "2020-04-08T07:55:52Z", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -240,7 +249,14 @@ private TaskAssigningSolution recoverSolution() {\n                                                                                                      Suspended),\n                                                                                        null,\n                                                                                        TaskInputVariablesReadMode.READ_FOR_ALL);\n-        context.setLastModificationDate(result.getQueryTime());\n+\n+        final LocalDateTime nextQueryTime = trimMillis(result.getQueryTime());\n+        final LocalDateTime adjustedFirstQueryTime = nextQueryTime != null ? nextQueryTime.minusHours(1) : null;", "originalCommit": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzMDQyMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405330420", "bodyText": "already fixed", "author": "wmedvede", "createdAt": "2020-04-08T07:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyODQ1OQ=="}], "type": "inlineReview"}, {"oid": "232ce7f9a096f252b1e59df3cbffa66d0d6910cd", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/232ce7f9a096f252b1e59df3cbffa66d0d6910cd", "message": "PLANNER-1943: [Task assignment] Ensure previous query time is used when synchronization is re-runned\n    - Revision suggestions I", "committedDate": "2020-04-08T09:00:02Z", "type": "commit"}]}