{"pr_number": 1521, "pr_title": "Add Snapshot trigger on aggregate load time", "pr_createdAt": "2020-10-06T13:36:06Z", "pr_url": "https://github.com/AxonFramework/AxonFramework/pull/1521", "timeline": [{"oid": "77b43a819296f28f02b8c7145acd153f849ea145", "url": "https://github.com/AxonFramework/AxonFramework/commit/77b43a819296f28f02b8c7145acd153f849ea145", "message": "Add Snapshotting on aggregate load time", "committedDate": "2020-10-06T12:58:25Z", "type": "commit"}, {"oid": "c1fb258ea924a8675ad20cacf1b36aec7c525b87", "url": "https://github.com/AxonFramework/AxonFramework/commit/c1fb258ea924a8675ad20cacf1b36aec7c525b87", "message": "Sonar improvements", "committedDate": "2020-10-06T14:42:30Z", "type": "commit"}, {"oid": "52b34a9ee3f577d0807951f52e4b0436f1bf4730", "url": "https://github.com/AxonFramework/AxonFramework/commit/52b34a9ee3f577d0807951f52e4b0436f1bf4730", "message": "Abstract methods need to be protected in order to be overwritten", "committedDate": "2020-10-07T07:03:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc4NTc1Mw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500785753", "bodyText": "I'd call this method just reset.", "author": "m1l4n54v1c", "createdAt": "2020-10-07T07:12:21Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    static final long serialVersionUID = 4129616856823136473L;\n+    transient Snapshotter snapshotter;\n+    Class<?> aggregateType;\n+    boolean initialized;\n+\n+    @Override\n+    public void eventHandled(EventMessage<?> msg) {\n+        if (msg instanceof DomainEventMessage && exceedsThreshold()) {\n+            prepareSnapshotScheduling((DomainEventMessage<?>) msg);\n+            resetVariables();\n+        }\n+    }\n+\n+    @Override\n+    public void initializationFinished() {\n+        initialized = true;\n+    }\n+\n+    public void prepareSnapshotScheduling(DomainEventMessage<?> eventMessage) {\n+        if (CurrentUnitOfWork.isStarted()) {\n+            if (initialized) {\n+                CurrentUnitOfWork.get().onPrepareCommit(\n+                        u -> scheduleSnapshot(eventMessage));\n+            } else {\n+                CurrentUnitOfWork.get().onCleanup(\n+                        u -> scheduleSnapshot(eventMessage));\n+            }\n+        } else {\n+            scheduleSnapshot(eventMessage);\n+        }\n+    }\n+\n+    void scheduleSnapshot(DomainEventMessage<?> eventMessage) {\n+        snapshotter.scheduleSnapshot(aggregateType, eventMessage.getAggregateIdentifier());\n+    }\n+\n+\n+    public void setSnapshotter(Snapshotter snapshotter) {\n+        this.snapshotter = snapshotter;\n+    }\n+\n+    /**\n+     * This method is used to determine if a new snapshot should be created\n+     */\n+    protected abstract boolean exceedsThreshold();\n+\n+\n+    /**\n+     * This method is used to reset all the variables that are used to check if a threshold has been exceeded\n+     */\n+    protected abstract void resetVariables();", "originalCommit": "52b34a9ee3f577d0807951f52e4b0436f1bf4730", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b165ab70556a54a8eaccf126c11ebd629ddf399", "url": "https://github.com/AxonFramework/AxonFramework/commit/1b165ab70556a54a8eaccf126c11ebd629ddf399", "message": "Added constructor to abstract class", "committedDate": "2020-10-07T07:29:53Z", "type": "commit"}, {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215", "url": "https://github.com/AxonFramework/AxonFramework/commit/2a4a3fd3401564d9d009e4591d9051136a674215", "message": "Review comment renamed method", "committedDate": "2020-10-07T07:53:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5NjM4Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500996382", "bodyText": "Missing javadoc on this method, if it will remain public. Could imagine this guy can be private too.", "author": "smcvb", "createdAt": "2020-10-07T13:07:14Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    private static final long serialVersionUID = 4129616856823136473L;\n+    private transient Snapshotter snapshotter;\n+    private Class<?> aggregateType;\n+    private boolean initialized;\n+\n+    protected AbstractSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType) {\n+        this.snapshotter = snapshotter;\n+        this.aggregateType = aggregateType;\n+        this.initialized = false;\n+    }\n+\n+    @Override\n+    public void eventHandled(EventMessage<?> msg) {\n+        if (msg instanceof DomainEventMessage && exceedsThreshold()) {\n+            prepareSnapshotScheduling((DomainEventMessage<?>) msg);\n+            reset();\n+        }\n+    }\n+\n+    @Override\n+    public void initializationFinished() {\n+        initialized = true;\n+    }\n+\n+    public void prepareSnapshotScheduling(DomainEventMessage<?> eventMessage) {", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5NjQ0Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500996442", "bodyText": "Missing javadoc on this constructor.", "author": "smcvb", "createdAt": "2020-10-07T13:07:20Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    private static final long serialVersionUID = 4129616856823136473L;\n+    private transient Snapshotter snapshotter;\n+    private Class<?> aggregateType;\n+    private boolean initialized;\n+\n+    protected AbstractSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType) {", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5NzA3NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500997075", "bodyText": "Is this intended to be package-private? Could we make it private perhaps?", "author": "smcvb", "createdAt": "2020-10-07T13:08:18Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    private static final long serialVersionUID = 4129616856823136473L;\n+    private transient Snapshotter snapshotter;\n+    private Class<?> aggregateType;\n+    private boolean initialized;\n+\n+    protected AbstractSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType) {\n+        this.snapshotter = snapshotter;\n+        this.aggregateType = aggregateType;\n+        this.initialized = false;\n+    }\n+\n+    @Override\n+    public void eventHandled(EventMessage<?> msg) {\n+        if (msg instanceof DomainEventMessage && exceedsThreshold()) {\n+            prepareSnapshotScheduling((DomainEventMessage<?>) msg);\n+            reset();\n+        }\n+    }\n+\n+    @Override\n+    public void initializationFinished() {\n+        initialized = true;\n+    }\n+\n+    public void prepareSnapshotScheduling(DomainEventMessage<?> eventMessage) {\n+        if (CurrentUnitOfWork.isStarted()) {\n+            if (initialized) {\n+                CurrentUnitOfWork.get().onPrepareCommit(\n+                        u -> scheduleSnapshot(eventMessage));\n+            } else {\n+                CurrentUnitOfWork.get().onCleanup(\n+                        u -> scheduleSnapshot(eventMessage));\n+            }\n+        } else {\n+            scheduleSnapshot(eventMessage);\n+        }\n+    }\n+\n+    void scheduleSnapshot(DomainEventMessage<?> eventMessage) {", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5Nzg1NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500997854", "bodyText": "I think this method should have some javadoc, however boring setters are :-)", "author": "smcvb", "createdAt": "2020-10-07T13:09:26Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    private static final long serialVersionUID = 4129616856823136473L;\n+    private transient Snapshotter snapshotter;\n+    private Class<?> aggregateType;\n+    private boolean initialized;\n+\n+    protected AbstractSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType) {\n+        this.snapshotter = snapshotter;\n+        this.aggregateType = aggregateType;\n+        this.initialized = false;\n+    }\n+\n+    @Override\n+    public void eventHandled(EventMessage<?> msg) {\n+        if (msg instanceof DomainEventMessage && exceedsThreshold()) {\n+            prepareSnapshotScheduling((DomainEventMessage<?>) msg);\n+            reset();\n+        }\n+    }\n+\n+    @Override\n+    public void initializationFinished() {\n+        initialized = true;\n+    }\n+\n+    public void prepareSnapshotScheduling(DomainEventMessage<?> eventMessage) {\n+        if (CurrentUnitOfWork.isStarted()) {\n+            if (initialized) {\n+                CurrentUnitOfWork.get().onPrepareCommit(\n+                        u -> scheduleSnapshot(eventMessage));\n+            } else {\n+                CurrentUnitOfWork.get().onCleanup(\n+                        u -> scheduleSnapshot(eventMessage));\n+            }\n+        } else {\n+            scheduleSnapshot(eventMessage);\n+        }\n+    }\n+\n+    void scheduleSnapshot(DomainEventMessage<?> eventMessage) {\n+        snapshotter.scheduleSnapshot(aggregateType, eventMessage.getAggregateIdentifier());\n+    }\n+\n+\n+    public void setSnapshotter(Snapshotter snapshotter) {", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5ODA5MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500998090", "bodyText": "The @return value should be specified for this piece of javadoc.", "author": "smcvb", "createdAt": "2020-10-07T13:09:46Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    private static final long serialVersionUID = 4129616856823136473L;\n+    private transient Snapshotter snapshotter;\n+    private Class<?> aggregateType;\n+    private boolean initialized;\n+\n+    protected AbstractSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType) {\n+        this.snapshotter = snapshotter;\n+        this.aggregateType = aggregateType;\n+        this.initialized = false;\n+    }\n+\n+    @Override\n+    public void eventHandled(EventMessage<?> msg) {\n+        if (msg instanceof DomainEventMessage && exceedsThreshold()) {\n+            prepareSnapshotScheduling((DomainEventMessage<?>) msg);\n+            reset();\n+        }\n+    }\n+\n+    @Override\n+    public void initializationFinished() {\n+        initialized = true;\n+    }\n+\n+    public void prepareSnapshotScheduling(DomainEventMessage<?> eventMessage) {\n+        if (CurrentUnitOfWork.isStarted()) {\n+            if (initialized) {\n+                CurrentUnitOfWork.get().onPrepareCommit(\n+                        u -> scheduleSnapshot(eventMessage));\n+            } else {\n+                CurrentUnitOfWork.get().onCleanup(\n+                        u -> scheduleSnapshot(eventMessage));\n+            }\n+        } else {\n+            scheduleSnapshot(eventMessage);\n+        }\n+    }\n+\n+    void scheduleSnapshot(DomainEventMessage<?> eventMessage) {\n+        snapshotter.scheduleSnapshot(aggregateType, eventMessage.getAggregateIdentifier());\n+    }\n+\n+\n+    public void setSnapshotter(Snapshotter snapshotter) {\n+        this.snapshotter = snapshotter;\n+    }\n+\n+    /**\n+     * This method is used to determine if a new snapshot should be created", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMTk2MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501001960", "bodyText": "Nit: Believe adding @Override to this method would make things slightly clearer.", "author": "smcvb", "createdAt": "2020-10-07T13:15:14Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/EventCountSnapshotTriggerDefinition.java", "diffHunk": "@@ -71,52 +65,23 @@ public SnapshotTrigger reconfigure(Class<?> aggregateType, SnapshotTrigger trigg\n         return new EventCountSnapshotTrigger(snapshotter, aggregateType, threshold);\n     }\n \n-    private static class EventCountSnapshotTrigger implements SnapshotTrigger, Serializable {\n+    private static class EventCountSnapshotTrigger extends AbstractSnapshotTrigger {\n \n-        private static final long serialVersionUID = 4129616856823136473L;\n-        private final Class<?> aggregateType;\n         private final int threshold;\n-\n-        private transient Snapshotter snapshotter;\n         private int counter = 0;\n-        private boolean initialized = false;\n \n         public EventCountSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType, int threshold) {\n-            this.snapshotter = snapshotter;\n-            this.aggregateType = aggregateType;\n+            super(snapshotter, aggregateType);\n             this.threshold = threshold;\n         }\n \n-        @Override\n-        public void eventHandled(EventMessage<?> msg) {\n-            if (msg instanceof DomainEventMessage && ++counter >= threshold) {\n-                if (CurrentUnitOfWork.isStarted()) {\n-                    if (initialized) {\n-                        CurrentUnitOfWork.get().onPrepareCommit(\n-                                u -> scheduleSnapshot((DomainEventMessage<?>) msg));\n-                    } else {\n-                        CurrentUnitOfWork.get().onCleanup(\n-                                u -> scheduleSnapshot((DomainEventMessage<?>) msg));\n-                    }\n-                } else {\n-                    scheduleSnapshot((DomainEventMessage<?>) msg);\n-                }\n-                counter = 0;\n-            }\n+        public boolean exceedsThreshold() {", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMjAxNg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501002016", "bodyText": "Nit: Believe adding @Override to this method would make things slightly clearer.", "author": "smcvb", "createdAt": "2020-10-07T13:15:18Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/EventCountSnapshotTriggerDefinition.java", "diffHunk": "@@ -71,52 +65,23 @@ public SnapshotTrigger reconfigure(Class<?> aggregateType, SnapshotTrigger trigg\n         return new EventCountSnapshotTrigger(snapshotter, aggregateType, threshold);\n     }\n \n-    private static class EventCountSnapshotTrigger implements SnapshotTrigger, Serializable {\n+    private static class EventCountSnapshotTrigger extends AbstractSnapshotTrigger {\n \n-        private static final long serialVersionUID = 4129616856823136473L;\n-        private final Class<?> aggregateType;\n         private final int threshold;\n-\n-        private transient Snapshotter snapshotter;\n         private int counter = 0;\n-        private boolean initialized = false;\n \n         public EventCountSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType, int threshold) {\n-            this.snapshotter = snapshotter;\n-            this.aggregateType = aggregateType;\n+            super(snapshotter, aggregateType);\n             this.threshold = threshold;\n         }\n \n-        @Override\n-        public void eventHandled(EventMessage<?> msg) {\n-            if (msg instanceof DomainEventMessage && ++counter >= threshold) {\n-                if (CurrentUnitOfWork.isStarted()) {\n-                    if (initialized) {\n-                        CurrentUnitOfWork.get().onPrepareCommit(\n-                                u -> scheduleSnapshot((DomainEventMessage<?>) msg));\n-                    } else {\n-                        CurrentUnitOfWork.get().onCleanup(\n-                                u -> scheduleSnapshot((DomainEventMessage<?>) msg));\n-                    }\n-                } else {\n-                    scheduleSnapshot((DomainEventMessage<?>) msg);\n-                }\n-                counter = 0;\n-            }\n+        public boolean exceedsThreshold() {\n+            return ++counter >= threshold;\n         }\n \n-        protected void scheduleSnapshot(DomainEventMessage<?> msg) {\n-            snapshotter.scheduleSnapshot(aggregateType, msg.getAggregateIdentifier());\n+        public void reset() {", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMzA5Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501003092", "bodyText": "To be exact, this is being introduced in 4.4.4, as the branch points to axon-4.4.x :-)", "author": "smcvb", "createdAt": "2020-10-07T13:16:51Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMzM1NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501003354", "bodyText": "To be exact, this is being introduced in 4.4.4, as the branch points to axon-4.4.x :-)", "author": "smcvb", "createdAt": "2020-10-07T13:17:11Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n+ * once the aggregate has been fully initialized, than the snapshot will only be triggered if handling resolves\n+ * successfully.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxMzg4NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501013884", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n          \n          \n            \n             * A {@link SnapshotterTriggerDefinition} implementation which based on the loading time of an Aggregate decides when to trigger the creation of a snapshot. A snapshot", "author": "smcvb", "createdAt": "2020-10-07T13:31:07Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxNDY5Ng==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501014696", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n          \n          \n            \n             * If the definable {@code loadTimeMillisThreshold} is met in situation one, the snapshot will be triggered regardless of the outcome", "author": "smcvb", "createdAt": "2020-10-07T13:32:19Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxNDg1NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501014855", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n          \n          \n            \n             * of command handling. Thus also if command handling returns exceptionally. If the {@code loadTimeMillisThreshold} is only reached", "author": "smcvb", "createdAt": "2020-10-07T13:32:33Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxNTI5OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501015299", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This number can exceed in two distinct scenarios:\n          \n          \n            \n             * This threshold can be exceeded in two distinct scenarios:", "author": "smcvb", "createdAt": "2020-10-07T13:33:11Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxNjQ1Ng==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501016456", "bodyText": "I think this guy should be made public, so that users can, if they need to, change the Clock (quite similar as currently is possible on the GenericEventMessage.", "author": "smcvb", "createdAt": "2020-10-07T13:34:40Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n+ * once the aggregate has been fully initialized, than the snapshot will only be triggered if handling resolves\n+ * successfully.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public class AggregateLoadTimeSnapshotTriggerDefinition implements SnapshotTriggerDefinition {\n+\n+    private final Snapshotter snapshotter;\n+    private final long loadTimeMillisThreshold;\n+    static Clock clock = Clock.systemUTC();", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxOTg0Ng==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501019846", "bodyText": "Nit: Believe adding @Override to this method would make things slightly clearer.", "author": "smcvb", "createdAt": "2020-10-07T13:39:17Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n+ * once the aggregate has been fully initialized, than the snapshot will only be triggered if handling resolves\n+ * successfully.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public class AggregateLoadTimeSnapshotTriggerDefinition implements SnapshotTriggerDefinition {\n+\n+    private final Snapshotter snapshotter;\n+    private final long loadTimeMillisThreshold;\n+    static Clock clock = Clock.systemUTC();\n+\n+\n+    /**\n+     * Initialized the SnapshotTriggerDefinition to threshold snapshots using the given {@code snapshotter} when loading\n+     * the aggregate instance takes longer than {@code loadTimeMillisThreshold}\n+     *\n+     * @param snapshotter the snapshotter to notify when a snapshot needs to be taken\n+     * @param loadTimeMillisThreshold  the maximum time that loading an aggregate may take\n+     */\n+    public AggregateLoadTimeSnapshotTriggerDefinition(Snapshotter snapshotter, long loadTimeMillisThreshold) {\n+        this.snapshotter = snapshotter;\n+        this.loadTimeMillisThreshold = loadTimeMillisThreshold;\n+    }\n+\n+    @Override\n+    public SnapshotTrigger prepareTrigger(Class<?> aggregateType) {\n+        return new AggregateLoadTimeSnapshotTrigger(snapshotter, aggregateType, loadTimeMillisThreshold);\n+    }\n+\n+    @Override\n+    public SnapshotTrigger reconfigure(Class<?> aggregateType, SnapshotTrigger trigger) {\n+        if (trigger instanceof AggregateLoadTimeSnapshotTrigger) {\n+            ((AggregateLoadTimeSnapshotTrigger) trigger).setSnapshotter(snapshotter);\n+            return trigger;\n+        }\n+        return new AggregateLoadTimeSnapshotTrigger(snapshotter, aggregateType, loadTimeMillisThreshold);\n+    }\n+\n+    private static class AggregateLoadTimeSnapshotTrigger extends AbstractSnapshotTrigger {\n+\n+        private final long loadTimeMillisThreshold;\n+        private long startTime = clock.instant().toEpochMilli();\n+\n+        public AggregateLoadTimeSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType, long loadTimeMillisThreshold) {\n+            super(snapshotter, aggregateType);\n+            this.loadTimeMillisThreshold = loadTimeMillisThreshold;\n+        }\n+\n+        public boolean exceedsThreshold(){", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxOTg4MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501019880", "bodyText": "Nit: Believe adding @Override to this method would make things slightly clearer.", "author": "smcvb", "createdAt": "2020-10-07T13:39:21Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n+ * once the aggregate has been fully initialized, than the snapshot will only be triggered if handling resolves\n+ * successfully.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public class AggregateLoadTimeSnapshotTriggerDefinition implements SnapshotTriggerDefinition {\n+\n+    private final Snapshotter snapshotter;\n+    private final long loadTimeMillisThreshold;\n+    static Clock clock = Clock.systemUTC();\n+\n+\n+    /**\n+     * Initialized the SnapshotTriggerDefinition to threshold snapshots using the given {@code snapshotter} when loading\n+     * the aggregate instance takes longer than {@code loadTimeMillisThreshold}\n+     *\n+     * @param snapshotter the snapshotter to notify when a snapshot needs to be taken\n+     * @param loadTimeMillisThreshold  the maximum time that loading an aggregate may take\n+     */\n+    public AggregateLoadTimeSnapshotTriggerDefinition(Snapshotter snapshotter, long loadTimeMillisThreshold) {\n+        this.snapshotter = snapshotter;\n+        this.loadTimeMillisThreshold = loadTimeMillisThreshold;\n+    }\n+\n+    @Override\n+    public SnapshotTrigger prepareTrigger(Class<?> aggregateType) {\n+        return new AggregateLoadTimeSnapshotTrigger(snapshotter, aggregateType, loadTimeMillisThreshold);\n+    }\n+\n+    @Override\n+    public SnapshotTrigger reconfigure(Class<?> aggregateType, SnapshotTrigger trigger) {\n+        if (trigger instanceof AggregateLoadTimeSnapshotTrigger) {\n+            ((AggregateLoadTimeSnapshotTrigger) trigger).setSnapshotter(snapshotter);\n+            return trigger;\n+        }\n+        return new AggregateLoadTimeSnapshotTrigger(snapshotter, aggregateType, loadTimeMillisThreshold);\n+    }\n+\n+    private static class AggregateLoadTimeSnapshotTrigger extends AbstractSnapshotTrigger {\n+\n+        private final long loadTimeMillisThreshold;\n+        private long startTime = clock.instant().toEpochMilli();\n+\n+        public AggregateLoadTimeSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType, long loadTimeMillisThreshold) {\n+            super(snapshotter, aggregateType);\n+            this.loadTimeMillisThreshold = loadTimeMillisThreshold;\n+        }\n+\n+        public boolean exceedsThreshold(){\n+            return (clock.instant().toEpochMilli() - startTime) > loadTimeMillisThreshold;\n+        }\n+\n+        public void reset() {", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyNDUzNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501024535", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Initialized the SnapshotTriggerDefinition to threshold snapshots using the given {@code snapshotter} when loading\n          \n          \n            \n                 * the aggregate instance takes longer than {@code loadTimeMillisThreshold}\n          \n          \n            \n                 * Initialize a {@link SnapshotTriggerDefinition} to trigger snapshot creation using the given {@code snapshotter} when loading\n          \n          \n            \n                 * the aggregate instance takes longer than the given {@code loadTimeMillisThreshold}.", "author": "smcvb", "createdAt": "2020-10-07T13:45:25Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n+ * once the aggregate has been fully initialized, than the snapshot will only be triggered if handling resolves\n+ * successfully.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public class AggregateLoadTimeSnapshotTriggerDefinition implements SnapshotTriggerDefinition {\n+\n+    private final Snapshotter snapshotter;\n+    private final long loadTimeMillisThreshold;\n+    static Clock clock = Clock.systemUTC();\n+\n+\n+    /**\n+     * Initialized the SnapshotTriggerDefinition to threshold snapshots using the given {@code snapshotter} when loading\n+     * the aggregate instance takes longer than {@code loadTimeMillisThreshold}", "originalCommit": "2a4a3fd3401564d9d009e4591d9051136a674215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "365ba7693575fcf84b91e8eb0aeed40624a0a2af", "url": "https://github.com/AxonFramework/AxonFramework/commit/365ba7693575fcf84b91e8eb0aeed40624a0a2af", "message": "Update eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-10-08T07:45:14Z", "type": "commit"}, {"oid": "85594f681a184514c81645813121d5e16a0856e3", "url": "https://github.com/AxonFramework/AxonFramework/commit/85594f681a184514c81645813121d5e16a0856e3", "message": "Update eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-10-08T07:45:33Z", "type": "commit"}, {"oid": "f7efdb76f69ec44608a362fdf82ccbc9f038167a", "url": "https://github.com/AxonFramework/AxonFramework/commit/f7efdb76f69ec44608a362fdf82ccbc9f038167a", "message": "Addressed review comments", "committedDate": "2020-10-08T07:55:43Z", "type": "commit"}, {"oid": "4753bc181fe4e06d16cfc29ef3a61488102e8aaa", "url": "https://github.com/AxonFramework/AxonFramework/commit/4753bc181fe4e06d16cfc29ef3a61488102e8aaa", "message": "Merge branch 'snapshot-on-load-time' of https://github.com/AxonFramework/AxonFramework into snapshot-on-load-time", "committedDate": "2020-10-08T07:56:00Z", "type": "commit"}, {"oid": "4d26a9e76a3468a9d0e8383b870299bf1180644e", "url": "https://github.com/AxonFramework/AxonFramework/commit/4d26a9e76a3468a9d0e8383b870299bf1180644e", "message": "Update eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-10-08T08:00:27Z", "type": "commit"}, {"oid": "c083309db86fcc0fd1481f86d3979cf5ee1e99de", "url": "https://github.com/AxonFramework/AxonFramework/commit/c083309db86fcc0fd1481f86d3979cf5ee1e99de", "message": "Update eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-10-08T08:02:56Z", "type": "commit"}, {"oid": "3a288865360b1cb9db85eb3f0187c04227bf2dab", "url": "https://github.com/AxonFramework/AxonFramework/commit/3a288865360b1cb9db85eb3f0187c04227bf2dab", "message": "Update eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-10-08T08:03:56Z", "type": "commit"}, {"oid": "da23a15255b44243e219c1222a900fe6df818464", "url": "https://github.com/AxonFramework/AxonFramework/commit/da23a15255b44243e219c1222a900fe6df818464", "message": "Javadoc improvemements", "committedDate": "2020-10-08T08:19:19Z", "type": "commit"}]}