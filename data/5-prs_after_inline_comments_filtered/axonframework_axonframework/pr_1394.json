{"pr_number": 1394, "pr_title": "[#901] Added support for annotated handler interceptors", "pr_createdAt": "2020-04-02T12:27:29Z", "pr_url": "https://github.com/AxonFramework/AxonFramework/pull/1394", "timeline": [{"oid": "281d808b80777b7bfd0e02a6fe54b860d51e755d", "url": "https://github.com/AxonFramework/AxonFramework/commit/281d808b80777b7bfd0e02a6fe54b860d51e755d", "message": "Added support for annotated handler interceptors\n\nThis commit adds support for interceptors declared on the handler\ninstance itself, using the same rules for parameter injection as other\nannotated handlers. Depending on the annotation used, handlers are also\ngiven the opportunity to only act on the result of handler execution,\nsuch as a specific type of exception.\n\nResolves #901", "committedDate": "2020-04-02T12:25:14Z", "type": "commit"}, {"oid": "359188e01ec72425744359b645619204ffa4ecac", "url": "https://github.com/AxonFramework/AxonFramework/commit/359188e01ec72425744359b645619204ffa4ecac", "message": "Fixed ConcurrentModificationException in java 11+", "committedDate": "2020-04-02T13:00:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NDQ2OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404654468", "bodyText": "Is this annotation only intended for eventhandling?", "author": "smcvb", "createdAt": "2020-04-07T09:07:05Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/interceptors/ExceptionHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.interceptors;", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NTQ1Ng==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404655456", "bodyText": "Shouldn't ElementType.TYPE be added? The javadoc states it can be put on class' as well, which it cant right now.", "author": "smcvb", "createdAt": "2020-04-07T09:08:47Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/interceptors/ExceptionHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.interceptors;\n+\n+import org.axonframework.messaging.Message;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Annotation marking a Handler (or class) as an interceptor for other handlers that is only interested in handling\n+ * exception results. This handler method will be invoked after a regular handler has been executed and may receive the\n+ * result of that handler as a parameter.\n+ * <p>\n+ * A handler will only be invoked when the parameters of this method match the combination of the handled Message and\n+ * the result of the handler method invocation.\n+ *\n+ * @author Allard Buijze\n+ * @since 4.4\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4MDYyMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406680622", "bodyText": "Noticed it's no longer intended for class level, so we can mark this comment as resolved.", "author": "smcvb", "createdAt": "2020-04-10T09:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NTQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NjM3NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404656375", "bodyText": "Same argument as with the previous file. Does this file belong to org.axonframework.eventhandling.interceptors, or to org.axonframework.messaging.interceptors?", "author": "smcvb", "createdAt": "2020-04-07T09:10:16Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/interceptors/MessageHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.interceptors;", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NzM1MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404657350", "bodyText": "Same packaging request as with the previous two annotations.", "author": "smcvb", "createdAt": "2020-04-07T09:11:49Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/interceptors/ResultHandler.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.interceptors;", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NzgwMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404657801", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * @author Allard Buijze\n          \n          \n            \n             * @since 4.4", "author": "smcvb", "createdAt": "2020-04-07T09:12:36Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/interceptors/ResultHandler.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.interceptors;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Meta-Annotation used to demarcate {@link MessageHandlerInterceptor} annotated methods as interceptors that should\n+ * only act on the result of a handler invocation. This gives these handlers the opportunity to act on the result only,\n+ * without intercepting the call on the way <em>to</em> the handler.\n+ * <p>\n+ * The {@link #resultType()} can be used to limit the types of responses the handler should be invoked for.\n+ * <p>\n+ * This annotation is exclusively meant as a Meta-Annotation and cannot not be placed directly on a method.\n+ *", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1OTQ5NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404659494", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * MethodEnhancerDefinition that marks methods (meta-)annotated with {@link MessageHandlerInterceptor}\n          \n          \n            \n             * as interceptors. These methods need to be given special treatment when invoking handlers. Matching\n          \n          \n            \n             * interceptors need to be invoked first, allowing them to proceed the invocation chain.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * This definition also recognizes interceptors only acting on the response. These must be meta-annotated with\n          \n          \n            \n             * {@link ResultHandler}.\n          \n          \n            \n             * {@link HandlerEnhancerDefinition} that marks methods (meta-)annotated with {@link MessageHandlerInterceptor}\n          \n          \n            \n             * as interceptors. These methods need to be given special treatment when invoking handlers. Matching\n          \n          \n            \n             * interceptors need to be invoked first, allowing them to proceed the invocation chain.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * This definition also recognizes interceptors only acting on the response. These must be meta-annotated with\n          \n          \n            \n             * {@link ResultHandler}.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Allard Buijze\n          \n          \n            \n             * @since 4.4", "author": "smcvb", "createdAt": "2020-04-07T09:15:06Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorDefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.eventhandling.interceptors.MessageHandlerInterceptor;\n+import org.axonframework.eventhandling.interceptors.ResultHandler;\n+import org.axonframework.messaging.InterceptorChain;\n+import org.axonframework.messaging.Message;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * MethodEnhancerDefinition that marks methods (meta-)annotated with {@link MessageHandlerInterceptor}\n+ * as interceptors. These methods need to be given special treatment when invoking handlers. Matching\n+ * interceptors need to be invoked first, allowing them to proceed the invocation chain.\n+ * <p>\n+ * This definition also recognizes interceptors only acting on the response. These must be meta-annotated with\n+ * {@link ResultHandler}.", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2MjE3OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404662179", "bodyText": "I think this exception should be about a @ResultHandler annotation, is that's what's being verified in the MessageHandlerInterceptorDefinition#wrapHandler method.", "author": "smcvb", "createdAt": "2020-04-07T09:19:20Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorDefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.eventhandling.interceptors.MessageHandlerInterceptor;\n+import org.axonframework.eventhandling.interceptors.ResultHandler;\n+import org.axonframework.messaging.InterceptorChain;\n+import org.axonframework.messaging.Message;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * MethodEnhancerDefinition that marks methods (meta-)annotated with {@link MessageHandlerInterceptor}\n+ * as interceptors. These methods need to be given special treatment when invoking handlers. Matching\n+ * interceptors need to be invoked first, allowing them to proceed the invocation chain.\n+ * <p>\n+ * This definition also recognizes interceptors only acting on the response. These must be meta-annotated with\n+ * {@link ResultHandler}.\n+ */\n+public class MessageHandlerInterceptorDefinition implements HandlerEnhancerDefinition {\n+    @Override\n+    public <T> MessageHandlingMember<T> wrapHandler(MessageHandlingMember<T> original) {\n+\n+        if (original.annotationAttributes(MessageHandlerInterceptor.class).isPresent()) {\n+            Optional<Map<String, Object>> attributes = original.annotationAttributes(ResultHandler.class);\n+            if (attributes.isPresent()) {\n+                return new ResultHandlingInterceptorMember<>(original, (Class<?>) attributes.get().get(\"resultType\"));\n+            }\n+            return new InterceptedMessageHandlingMember<>(original);\n+        }\n+        return original;\n+    }\n+\n+    private static class ResultHandlingInterceptorMember<T> extends WrappedMessageHandlingMember<T> implements MessageHandlerInterceptorMember<T> {\n+\n+        private final Class<?> expectedResultType;\n+\n+        public ResultHandlingInterceptorMember(MessageHandlingMember<T> original, Class<?> expectedResultType) {\n+            super(original);\n+            this.expectedResultType = expectedResultType;\n+            Method method = original.unwrap(Method.class).orElseThrow(() -> new AxonConfigurationException(\n+                    \"The @ExceptionHandler must be on method.\"));", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2MjY4Ng==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404662686", "bodyText": "Same holds for this exception. Think it should call out on the @ResultHandler annotation insteed of the @ExceptionHandler annotation.", "author": "smcvb", "createdAt": "2020-04-07T09:20:11Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorDefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.eventhandling.interceptors.MessageHandlerInterceptor;\n+import org.axonframework.eventhandling.interceptors.ResultHandler;\n+import org.axonframework.messaging.InterceptorChain;\n+import org.axonframework.messaging.Message;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * MethodEnhancerDefinition that marks methods (meta-)annotated with {@link MessageHandlerInterceptor}\n+ * as interceptors. These methods need to be given special treatment when invoking handlers. Matching\n+ * interceptors need to be invoked first, allowing them to proceed the invocation chain.\n+ * <p>\n+ * This definition also recognizes interceptors only acting on the response. These must be meta-annotated with\n+ * {@link ResultHandler}.\n+ */\n+public class MessageHandlerInterceptorDefinition implements HandlerEnhancerDefinition {\n+    @Override\n+    public <T> MessageHandlingMember<T> wrapHandler(MessageHandlingMember<T> original) {\n+\n+        if (original.annotationAttributes(MessageHandlerInterceptor.class).isPresent()) {\n+            Optional<Map<String, Object>> attributes = original.annotationAttributes(ResultHandler.class);\n+            if (attributes.isPresent()) {\n+                return new ResultHandlingInterceptorMember<>(original, (Class<?>) attributes.get().get(\"resultType\"));\n+            }\n+            return new InterceptedMessageHandlingMember<>(original);\n+        }\n+        return original;\n+    }\n+\n+    private static class ResultHandlingInterceptorMember<T> extends WrappedMessageHandlingMember<T> implements MessageHandlerInterceptorMember<T> {\n+\n+        private final Class<?> expectedResultType;\n+\n+        public ResultHandlingInterceptorMember(MessageHandlingMember<T> original, Class<?> expectedResultType) {\n+            super(original);\n+            this.expectedResultType = expectedResultType;\n+            Method method = original.unwrap(Method.class).orElseThrow(() -> new AxonConfigurationException(\n+                    \"The @ExceptionHandler must be on method.\"));\n+            boolean declaredInterceptorChain = Arrays.stream(method.getParameters())\n+                                                     .anyMatch(p -> p.getType().equals(InterceptorChain.class));\n+            if (declaredInterceptorChain) {\n+                throw new AxonConfigurationException(\"@ExceptionHandler annotated methods should not delare an InterceptorChain parameter\");", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2NDI3OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404664279", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"The @MessageHandlerInterceptor must be on method.\"));\n          \n          \n            \n                                \"The @MessageHandlerInterceptor must be on a method.\"));", "author": "smcvb", "createdAt": "2020-04-07T09:22:53Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorDefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.eventhandling.interceptors.MessageHandlerInterceptor;\n+import org.axonframework.eventhandling.interceptors.ResultHandler;\n+import org.axonframework.messaging.InterceptorChain;\n+import org.axonframework.messaging.Message;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * MethodEnhancerDefinition that marks methods (meta-)annotated with {@link MessageHandlerInterceptor}\n+ * as interceptors. These methods need to be given special treatment when invoking handlers. Matching\n+ * interceptors need to be invoked first, allowing them to proceed the invocation chain.\n+ * <p>\n+ * This definition also recognizes interceptors only acting on the response. These must be meta-annotated with\n+ * {@link ResultHandler}.\n+ */\n+public class MessageHandlerInterceptorDefinition implements HandlerEnhancerDefinition {\n+    @Override\n+    public <T> MessageHandlingMember<T> wrapHandler(MessageHandlingMember<T> original) {\n+\n+        if (original.annotationAttributes(MessageHandlerInterceptor.class).isPresent()) {\n+            Optional<Map<String, Object>> attributes = original.annotationAttributes(ResultHandler.class);\n+            if (attributes.isPresent()) {\n+                return new ResultHandlingInterceptorMember<>(original, (Class<?>) attributes.get().get(\"resultType\"));\n+            }\n+            return new InterceptedMessageHandlingMember<>(original);\n+        }\n+        return original;\n+    }\n+\n+    private static class ResultHandlingInterceptorMember<T> extends WrappedMessageHandlingMember<T> implements MessageHandlerInterceptorMember<T> {\n+\n+        private final Class<?> expectedResultType;\n+\n+        public ResultHandlingInterceptorMember(MessageHandlingMember<T> original, Class<?> expectedResultType) {\n+            super(original);\n+            this.expectedResultType = expectedResultType;\n+            Method method = original.unwrap(Method.class).orElseThrow(() -> new AxonConfigurationException(\n+                    \"The @ExceptionHandler must be on method.\"));\n+            boolean declaredInterceptorChain = Arrays.stream(method.getParameters())\n+                                                     .anyMatch(p -> p.getType().equals(InterceptorChain.class));\n+            if (declaredInterceptorChain) {\n+                throw new AxonConfigurationException(\"@ExceptionHandler annotated methods should not delare an InterceptorChain parameter\");\n+            }\n+        }\n+\n+        @Override\n+        public boolean canHandle(Message<?> message) {\n+            return ResultParameterResolverFactory.ignoringResultParameters(() -> super.canHandle(message));\n+        }\n+\n+        @Override\n+        public Object handle(Message<?> message, T target) throws Exception {\n+            InterceptorChain chain = InterceptorChainParameterResolverFactory.currentInterceptorChain();\n+            try {\n+                return chain.proceed();\n+            } catch (Exception e) {\n+                if (!expectedResultType.isInstance(e)) {\n+                    throw e;\n+                }\n+                return ResultParameterResolverFactory.callWithResult(e, () -> {\n+                    if (super.canHandle(message)) {\n+                        return super.handle(message, target);\n+                    }\n+                    throw e;\n+                });\n+            }\n+        }\n+    }\n+\n+    private static class InterceptedMessageHandlingMember<T> extends WrappedMessageHandlingMember<T> implements MessageHandlerInterceptorMember<T> {\n+\n+        private final boolean shouldInvokeInterceptorChain;\n+\n+        public InterceptedMessageHandlingMember(MessageHandlingMember<T> original) {\n+            super(original);\n+            Method method = original.unwrap(Method.class).orElseThrow(() -> new AxonConfigurationException(\n+                    \"The @MessageHandlerInterceptor must be on method.\"));", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2NjYyMA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404666620", "bodyText": "This name feels like a slight tongue breaker. Would renaming it to MessageInterceptingMember make sense?", "author": "smcvb", "createdAt": "2020-04-07T09:26:37Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorMember.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+/**\n+ * Marker interface for {@link MessageHandlingMember} instances that need to be treated as interceptors, rather\n+ * than regular members.\n+ *\n+ * @param <T> The type that the handler was declared on.\n+ */\n+public interface MessageHandlerInterceptorMember<T> extends MessageHandlingMember<T> {", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2NzI0Ng==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404667246", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param <T> The type that the handler was declared on.\n          \n          \n            \n             */\n          \n          \n            \n             * @param <T> The type that the handler was declared on.\n          \n          \n            \n             * @author Allard Buijze\n          \n          \n            \n             * @since 4.4\n          \n          \n            \n             */", "author": "smcvb", "createdAt": "2020-04-07T09:27:33Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorMember.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+/**\n+ * Marker interface for {@link MessageHandlingMember} instances that need to be treated as interceptors, rather\n+ * than regular members.\n+ *\n+ * @param <T> The type that the handler was declared on.\n+ */", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2NzUwOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404667509", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param <T> The type that declares the handlers in this chain\n          \n          \n            \n             */\n          \n          \n            \n             * @param <T> The type that declares the handlers in this chain\n          \n          \n            \n             * @author Allard Buijze\n          \n          \n            \n             * @since 4.4\n          \n          \n            \n             */", "author": "smcvb", "createdAt": "2020-04-07T09:27:57Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorMemberChain.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.messaging.Message;\n+\n+/**\n+ * Interface to interact with a MessageHandlingMember instance through a chain of interceptor, which were\n+ * used to build up this chain. Unlike regular handlers, interceptors have the ability to act on messages on their\n+ * way to the regular handler, and have the ability to block these messages.\n+ *\n+ * @param <T> The type that declares the handlers in this chain\n+ */", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Nzk2MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404667961", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface to interact with a MessageHandlingMember instance through a chain of interceptor, which were\n          \n          \n            \n             * Interface to interact with a MessageHandlingMember instance through a chain of interceptors, which were", "author": "smcvb", "createdAt": "2020-04-07T09:28:41Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorMemberChain.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.messaging.Message;\n+\n+/**\n+ * Interface to interact with a MessageHandlingMember instance through a chain of interceptor, which were", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY3MjEwNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404672107", "bodyText": "Given this comment, I'd say a warn/error level log line would be in place.", "author": "smcvb", "createdAt": "2020-04-07T09:35:10Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/ResultParameterResolverFactory.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.annotation.AnnotationUtils;\n+import org.axonframework.eventhandling.interceptors.ResultHandler;\n+import org.axonframework.messaging.Message;\n+\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.Parameter;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+\n+/**\n+ * ParameterResolverFactory that provides support for Parameters where the result of Handler execution is expected to\n+ * be injected. This is only possible in interceptor handlers that need to act on the result of downstream interceptors\n+ * or the regular handler.\n+ * <p>\n+ * The {@link ResultHandler @ResultHandler} Meta-Annotation needs to be placed on handlers that support interacting with\n+ * the result type in its parameters.\n+ *\n+ * @author Allard Buijze\n+ * @since 4.4\n+ */\n+public class ResultParameterResolverFactory implements ParameterResolverFactory {\n+\n+\n+    private static final ThreadLocal<Object> REGISTERED_RESULT = new ThreadLocal<>();\n+    private static final Object IGNORE_RESULT_PARAMETER_MARKER = new Object();\n+\n+    /**\n+     * Calls the given {@code action} (typically a handler invocation) such that the given {@code result} is available\n+     * for injection as parameter\n+     *\n+     * @param result The result to make available for parameter injection\n+     * @param action The action to take\n+     *\n+     * @return the result of the action\n+     * @throws Exception any exception thrown while executing the {@code action}\n+     */\n+    public static Object callWithResult(Object result, Callable<?> action) throws Exception {\n+        Object previous = REGISTERED_RESULT.get();\n+        REGISTERED_RESULT.set(result);\n+        try {\n+            return action.call();\n+        } finally {\n+            if (previous == null) {\n+                REGISTERED_RESULT.remove();\n+            } else {\n+                REGISTERED_RESULT.set(previous);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Performs the given {@code action} ignoring any parameters expecting a result type. This is typically used to\n+     * detect whether a handler is suitable for invocation prior to the result value being available.\n+     *\n+     * @param action The action to perform\n+     * @param <T>    The type of result expected from the action\n+     *\n+     * @return the result returned by the given action\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T ignoringResultParameters(Supplier<T> action) {\n+        try {\n+            return (T) callWithResult(IGNORE_RESULT_PARAMETER_MARKER, action::get);\n+        } catch (Exception e) {\n+            // oh dear... this is bad", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY3OTIwNg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404679206", "bodyText": "What does \"tl\" stand for? Thread Local per chance?", "author": "smcvb", "createdAt": "2020-04-07T09:46:46Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/InterceptorChainParameterResolverFactory.java", "diffHunk": "@@ -42,31 +41,74 @@\n \n     private static final String INTERCEPTOR_CHAIN_EMITTER_KEY = InterceptorChain.class.getName();\n \n+    private static final ThreadLocal<InterceptorChain> CURRENT = new ThreadLocal<>();\n     /**\n      * Initializes current unit of work with interceptor chain.\n      *\n      * @param interceptorChain the interceptor chain\n      */\n+    @Deprecated\n     public static void initialize(InterceptorChain interceptorChain) {\n         Assert.state(CurrentUnitOfWork.isStarted(),\n                      () -> \"An active Unit of Work is required for injecting interceptor chain\");\n         CurrentUnitOfWork.get().resources().put(INTERCEPTOR_CHAIN_EMITTER_KEY, interceptorChain);\n     }\n \n+    /**\n+     * Invoke the given {@code action} with the given {@code interceptorChain} being available\n+     * for parameter injection. Because this parameter is not bound to a message, it is important\n+     * to invoke handlers using this method.\n+     *\n+     * @param interceptorChain The InterceptorChain to consider for injection as parameter\n+     * @param action           The action to invoke\n+     * @param <R>              The type of response expected from the invocation\n+     *\n+     * @return The response from the invocation of given {@code action}\n+     * @throws Exception any exception that occurs while invoking given {@code action}\n+     */\n+    public static <R> R callWithInterceptorChain(InterceptorChain interceptorChain, Callable<R> action) throws Exception {\n+        InterceptorChain previous = CURRENT.get();\n+        CURRENT.set(interceptorChain);\n+        try {\n+            return action.call();\n+        } finally {\n+            if (previous == null) {\n+                CURRENT.remove();\n+            } else {\n+                CURRENT.set(previous);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the current interceptor chain registered for injection as a parameter. Will return\n+     * the instance passed in {@link #callWithInterceptorChain(InterceptorChain, Callable)}. When invoked outside the\n+     * scope of that method, this will return {@code null}.\n+     *\n+     * @return the InterceptorChain instance passed in {@link #callWithInterceptorChain(InterceptorChain, Callable)}\n+     */\n+    public static InterceptorChain currentInterceptorChain() {\n+        return CURRENT.get();\n+    }\n+\n     @Override\n     public InterceptorChain resolveParameterValue(Message<?> message) {\n+        InterceptorChain tl = CURRENT.get();", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4MTQ0Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404681447", "bodyText": "I think it's important to state it's deprecated in favor of InterceptorChainParameterResolverFactory#callWithInterceptorChain", "author": "smcvb", "createdAt": "2020-04-07T09:50:20Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/InterceptorChainParameterResolverFactory.java", "diffHunk": "@@ -42,31 +41,74 @@\n \n     private static final String INTERCEPTOR_CHAIN_EMITTER_KEY = InterceptorChain.class.getName();\n \n+    private static final ThreadLocal<InterceptorChain> CURRENT = new ThreadLocal<>();\n     /**\n      * Initializes current unit of work with interceptor chain.\n      *\n      * @param interceptorChain the interceptor chain\n      */\n+    @Deprecated", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NTE2Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404685167", "bodyText": "You could replace this for:\n!delegate.canHandle(unitOfWork.getMessage())\n        ? interceptorChain.proceed()\n        : delegate.handle(unitOfWork.getMessage(), target)", "author": "smcvb", "createdAt": "2020-04-07T09:56:36Z", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedCommandHandlerInterceptor.java", "diffHunk": "@@ -50,15 +50,13 @@ public AnnotatedCommandHandlerInterceptor(MessageHandlingMember<T> delegate, T t\n     @Override\n     public Object handle(UnitOfWork<? extends CommandMessage<?>> unitOfWork, InterceptorChain interceptorChain)\n             throws Exception {\n-        InterceptorChainParameterResolverFactory.initialize(interceptorChain);\n+        return InterceptorChainParameterResolverFactory.callWithInterceptorChain(interceptorChain, () -> {\n+            if (!delegate.canHandle(unitOfWork.getMessage())) {\n+                return interceptorChain.proceed();\n+            }\n \n-        Object result = delegate.handle(unitOfWork.getMessage(), target);\n+            return delegate.handle(unitOfWork.getMessage(), target);\n ", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4OTQ4OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404689488", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns a Map of all registered interceptor method per inspected type. Each entry\n          \n          \n            \n                 * Returns a Map of all registered interceptor methods per inspected type. Each entry", "author": "smcvb", "createdAt": "2020-04-07T10:03:40Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/AnnotatedHandlerInspector.java", "diffHunk": "@@ -258,4 +304,54 @@ private void registerHandler(Class<?> type, MessageHandlingMember<? super T> han\n     public Map<Class<?>, SortedSet<MessageHandlingMember<? super T>>> getAllHandlers() {\n         return Collections.unmodifiableMap(handlers);\n     }\n+\n+    /**\n+     * Returns a Map of all registered interceptor method per inspected type. Each entry", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5MjI2MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404692260", "bodyText": "Nit: Now that I see this, doesn't it make sense to make the InterceptorChain a @FunctionalInterface?", "author": "smcvb", "createdAt": "2020-04-07T10:08:18Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/AnnotatedHandlerInspector.java", "diffHunk": "@@ -258,4 +304,54 @@ private void registerHandler(Class<?> type, MessageHandlingMember<? super T> han\n     public Map<Class<?>, SortedSet<MessageHandlingMember<? super T>>> getAllHandlers() {\n         return Collections.unmodifiableMap(handlers);\n     }\n+\n+    /**\n+     * Returns a Map of all registered interceptor method per inspected type. Each entry\n+     * contains the inspected type as key, and a SortedSet of interceptor methods defined\n+     * on that type, in the order they are considered for invocation.\n+     *\n+     * @return a map of interceptors per type\n+     */\n+    public Map<Class<?>, SortedSet<MessageHandlingMember<? super T>>> getAllInterceptors() {\n+        return Collections.unmodifiableMap(interceptors);\n+    }\n+\n+    private static class ChainedMessageHandlerInterceptorMember<T> implements MessageHandlerInterceptorMemberChain<T> {\n+        private final MessageHandlingMember<? super T> delegate;\n+        private final MessageHandlerInterceptorMemberChain<T> next;\n+\n+        private ChainedMessageHandlerInterceptorMember(Class<?> targetType, Iterator<MessageHandlingMember<? super T>> iterator) {\n+            this.delegate = iterator.next();\n+            if (iterator.hasNext()) {\n+                this.next = new ChainedMessageHandlerInterceptorMember<>(targetType, iterator);\n+            } else {\n+                this.next = NoMoreInterceptors.instance();\n+            }\n+        }\n+\n+        @Override\n+        public Object handle(Message<?> message, T target, MessageHandlingMember<? super T> handler) throws Exception {\n+            return InterceptorChainParameterResolverFactory.callWithInterceptorChain(() -> next.handle(message, target, handler),", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NTIwNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404695204", "bodyText": "Just to clarify my mind, but this check is here to:\n\nValidate whether the current interceptor, the delegate, can handle the message and if true do so.\nIf false, we proceed over the chain by calling next.handle\n\nIs that a correct assumption from my part?", "author": "smcvb", "createdAt": "2020-04-07T10:13:13Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/AnnotatedHandlerInspector.java", "diffHunk": "@@ -258,4 +304,54 @@ private void registerHandler(Class<?> type, MessageHandlingMember<? super T> han\n     public Map<Class<?>, SortedSet<MessageHandlingMember<? super T>>> getAllHandlers() {\n         return Collections.unmodifiableMap(handlers);\n     }\n+\n+    /**\n+     * Returns a Map of all registered interceptor method per inspected type. Each entry\n+     * contains the inspected type as key, and a SortedSet of interceptor methods defined\n+     * on that type, in the order they are considered for invocation.\n+     *\n+     * @return a map of interceptors per type\n+     */\n+    public Map<Class<?>, SortedSet<MessageHandlingMember<? super T>>> getAllInterceptors() {\n+        return Collections.unmodifiableMap(interceptors);\n+    }\n+\n+    private static class ChainedMessageHandlerInterceptorMember<T> implements MessageHandlerInterceptorMemberChain<T> {\n+        private final MessageHandlingMember<? super T> delegate;\n+        private final MessageHandlerInterceptorMemberChain<T> next;\n+\n+        private ChainedMessageHandlerInterceptorMember(Class<?> targetType, Iterator<MessageHandlingMember<? super T>> iterator) {\n+            this.delegate = iterator.next();\n+            if (iterator.hasNext()) {\n+                this.next = new ChainedMessageHandlerInterceptorMember<>(targetType, iterator);\n+            } else {\n+                this.next = NoMoreInterceptors.instance();\n+            }\n+        }\n+\n+        @Override\n+        public Object handle(Message<?> message, T target, MessageHandlingMember<? super T> handler) throws Exception {\n+            return InterceptorChainParameterResolverFactory.callWithInterceptorChain(() -> next.handle(message, target, handler),\n+                                                                                     () -> doHandle(message, target, handler));\n+        }\n+\n+        private Object doHandle(Message<?> message, T target, MessageHandlingMember<? super T> handler) throws Exception {\n+            if (delegate.canHandle(message)) {", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczODM4Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404738387", "bodyText": "And if so, isn't this assurance already taken care of by the MessageHandlerInterceptorDefinition.InterceptedMessageHandlingMember itself, were we validate if the InterceptorChain has been given as a parameter (hence called) and if not we call proceed ourselves?", "author": "smcvb", "createdAt": "2020-04-07T11:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NTIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyODgwNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406628804", "bodyText": "The idea of the chain is that the chain represents the invocation of the handler (the one at the end) and takes care of the invocations of the interceptors on the way to that handler. That means the chain should accept each message, and delegate to an interceptor if that interceptor can handle it, otherwise pass it on to the next element in the chain.\nIt is the responsibility of the caller of a handle method to do a canHandle check first. So in this case, the \"chain\" is responsible for checking whether the individual interceptor in the chain is capable of handling a message (based on its declared parameters). If not, proceed in the chain. If so, the interceptor is invoked and expected to continue the chain by calling InterceptorChain#proceed", "author": "abuijze", "createdAt": "2020-04-10T06:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NTIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMTQ5Mw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406701493", "bodyText": "\ud83d\udc4d", "author": "smcvb", "createdAt": "2020-04-10T10:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NTIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwMjAyNg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404702026", "bodyText": "I think this piece of code is slightly clearer if you rename handlersPerType to interceptorsPerType.", "author": "smcvb", "createdAt": "2020-04-07T10:24:53Z", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "diffHunk": "@@ -236,13 +236,17 @@ private void prepareHandlers() {\n                                     type));\n                         }\n                         addHandler(allCommandHandlers, type, handler);\n-                    } else if (handler.unwrap(CommandHandlerInterceptorHandlingMember.class).isPresent()) {\n-                        addHandler(allCommandHandlerInterceptors, type, handler);\n                     } else {\n                         addHandler(allEventHandlers, type, handler);\n                     }\n                 }\n             }\n+            for (Map.Entry<Class<?>, SortedSet<MessageHandlingMember<? super T>>> handlersPerType : handlerInspector.getAllInterceptors().entrySet()) {", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyNjkzNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404726937", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @deprecated in favor of the more generic {@link MessageHandlerInterceptorMember\u00b6}\n          \n          \n            \n             * @deprecated in favor of the more generic {@link MessageHandlerInterceptorMember}", "author": "smcvb", "createdAt": "2020-04-07T11:11:00Z", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/CommandHandlerInterceptorHandlingMember.java", "diffHunk": "@@ -16,16 +16,19 @@\n \n package org.axonframework.modelling.command.inspection;\n \n-import org.axonframework.messaging.annotation.MessageHandlingMember;\n+import org.axonframework.messaging.annotation.MessageHandlerInterceptorMember;\n \n /**\n  * Interface specifying a message handler capable of intercepting a command.\n  *\n  * @param <T> the type of entity to which the message handler will delegate tha actual interception\n+ *\n  * @author Milan Savic\n  * @since 3.3\n+ * @deprecated in favor of the more generic {@link MessageHandlerInterceptorMember\u00b6}", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyODgyMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404728821", "bodyText": "I am not completely sure why this if block can be removed with these changes. Would you mind explaining this part?", "author": "smcvb", "createdAt": "2020-04-07T11:14:23Z", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregate.java", "diffHunk": "@@ -429,11 +427,6 @@ private Object handle(CommandMessage<?> commandMessage) throws Exception {\n                     m -> handler.handle(commandMessage, aggregateRoot)\n             ).proceed();\n         }\n-\n-        if (aggregateRoot == null) {", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NTA4NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406645084", "bodyText": "It's not really related to this PR, actually. I just found out this branch isn't necessary, as the responsibility of returning an identifier in case a creation handler returns an Aggregate instance lies with the AggregateAnnotationCommandHandler.", "author": "abuijze", "createdAt": "2020-04-10T07:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyODgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1MDUzNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406650537", "bodyText": "Actually, the code was unreachable. aggregateRoot couldn't ever be null, as it would have raised an NPE a few lines above. Also, the handle method here handles a command on an existing instance. The registerRoot method is used to initialize a new aggregate root in this instance.", "author": "abuijze", "createdAt": "2020-04-10T08:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyODgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTMxOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406699318", "bodyText": "Thanks for clarifying \ud83d\udc4d", "author": "smcvb", "createdAt": "2020-04-10T10:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyODgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczMTUzOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404731539", "bodyText": "I believe the sorted call has been removed since the interceptors have already been sorted by the HandlerComparator.\nI am just not 100% of the filter removal. Was this filter call a duplicate to begin with?", "author": "smcvb", "createdAt": "2020-04-07T11:19:31Z", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregate.java", "diffHunk": "@@ -410,8 +410,6 @@ public Object handle(Message<?> message) throws Exception {\n     private Object handle(CommandMessage<?> commandMessage) throws Exception {\n         List<AnnotatedCommandHandlerInterceptor<? super T>> interceptors =\n                 inspector.commandHandlerInterceptors((Class<? extends T>) aggregateRoot.getClass())\n-                         .filter(chi -> chi.canHandle(commandMessage))", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0MDEzNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406640135", "bodyText": "Yes, sorting is not this class' responsibility anymore.\nThe implementation has been changed to chain the invocations itself. That means the \"chain\" will check if the interceptor at a specific can perform the invocation. If not, it will proceed without invoking the interceptor.", "author": "abuijze", "createdAt": "2020-04-10T07:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczMTUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTUwMw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406699503", "bodyText": "Aaah of course, makes total sense.", "author": "smcvb", "createdAt": "2020-04-10T10:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczMTUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczNjQ0Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r404736442", "bodyText": "The part after the || is only intended to keep supporting the deprecated InterceptorChainParameterResolverFactory#initialize method, right?", "author": "smcvb", "createdAt": "2020-04-07T11:28:32Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/InterceptorChainParameterResolverFactory.java", "diffHunk": "@@ -42,31 +41,74 @@\n \n     private static final String INTERCEPTOR_CHAIN_EMITTER_KEY = InterceptorChain.class.getName();\n \n+    private static final ThreadLocal<InterceptorChain> CURRENT = new ThreadLocal<>();\n     /**\n      * Initializes current unit of work with interceptor chain.\n      *\n      * @param interceptorChain the interceptor chain\n      */\n+    @Deprecated\n     public static void initialize(InterceptorChain interceptorChain) {\n         Assert.state(CurrentUnitOfWork.isStarted(),\n                      () -> \"An active Unit of Work is required for injecting interceptor chain\");\n         CurrentUnitOfWork.get().resources().put(INTERCEPTOR_CHAIN_EMITTER_KEY, interceptorChain);\n     }\n \n+    /**\n+     * Invoke the given {@code action} with the given {@code interceptorChain} being available\n+     * for parameter injection. Because this parameter is not bound to a message, it is important\n+     * to invoke handlers using this method.\n+     *\n+     * @param interceptorChain The InterceptorChain to consider for injection as parameter\n+     * @param action           The action to invoke\n+     * @param <R>              The type of response expected from the invocation\n+     *\n+     * @return The response from the invocation of given {@code action}\n+     * @throws Exception any exception that occurs while invoking given {@code action}\n+     */\n+    public static <R> R callWithInterceptorChain(InterceptorChain interceptorChain, Callable<R> action) throws Exception {\n+        InterceptorChain previous = CURRENT.get();\n+        CURRENT.set(interceptorChain);\n+        try {\n+            return action.call();\n+        } finally {\n+            if (previous == null) {\n+                CURRENT.remove();\n+            } else {\n+                CURRENT.set(previous);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the current interceptor chain registered for injection as a parameter. Will return\n+     * the instance passed in {@link #callWithInterceptorChain(InterceptorChain, Callable)}. When invoked outside the\n+     * scope of that method, this will return {@code null}.\n+     *\n+     * @return the InterceptorChain instance passed in {@link #callWithInterceptorChain(InterceptorChain, Callable)}\n+     */\n+    public static InterceptorChain currentInterceptorChain() {\n+        return CURRENT.get();\n+    }\n+\n     @Override\n     public InterceptorChain resolveParameterValue(Message<?> message) {\n+        InterceptorChain tl = CURRENT.get();\n+        if (tl != null) {\n+            return tl;\n+        }\n         return CurrentUnitOfWork.map(uow -> (InterceptorChain) uow.getResource(INTERCEPTOR_CHAIN_EMITTER_KEY))\n                                 .orElseThrow(() -> new IllegalStateException(\n                                         \"InterceptorChain should have been injected\"));\n     }\n \n     @Override\n     public boolean matches(Message<?> message) {\n-        return message instanceof CommandMessage;\n+        return CURRENT.get() != null || CurrentUnitOfWork.isStarted() && CurrentUnitOfWork.get().resources().containsKey(INTERCEPTOR_CHAIN_EMITTER_KEY);", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTU5Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406629592", "bodyText": "Yes, that's correct. Just in case someone attached an Interceptor to the Unit of Work. The key is private, but the value is easy to \"guess\". I thought it wouldn't harm to leave it here...", "author": "abuijze", "createdAt": "2020-04-10T06:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczNjQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTYxNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406699614", "bodyText": "Think that's a fair assumption :-)", "author": "smcvb", "createdAt": "2020-04-10T10:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczNjQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwMjk2MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405502960", "bodyText": "Why not test the @ExceptionHandler scenario here too?", "author": "smcvb", "createdAt": "2020-04-08T12:57:04Z", "path": "messaging/src/test/java/org/axonframework/queryhandling/annotation/AnnotationQueryHandlerAdapterTest.java", "diffHunk": "@@ -114,6 +124,22 @@ void testRunQueryForCollection() throws Exception {\n         assertEquals(testResponse, result.size());\n     }\n \n+    @Test\n+    void testInterceptMessages() throws Exception {\n+        List<QueryMessage<?, ?>> withInterceptor = new ArrayList<>();\n+        List<QueryMessage<?, ?>> withoutInterceptor = new ArrayList<>();\n+        testSubject = new AnnotationQueryHandlerAdapter<>(new MyInterceptingQueryHandler(withoutInterceptor, withInterceptor));\n+\n+        QueryMessage<String, String> testQueryMessage =\n+                new GenericQueryMessage<>(\"Hi\", \"Hello\", ResponseTypes.instanceOf(String.class));\n+\n+        String result = (String) testSubject.handle(testQueryMessage);\n+\n+        assertEquals(\"Hi\", result);\n+        assertEquals(Collections.singletonList(testQueryMessage), withInterceptor);\n+        assertEquals(Collections.singletonList(testQueryMessage), withoutInterceptor);\n+    }\n+", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNTcwNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405505707", "bodyText": "Just to clarify, the unwrapping is now necessary because you've introduced the ClasspathHandlerDefinition on the test subject, correct?", "author": "smcvb", "createdAt": "2020-04-08T13:01:14Z", "path": "messaging/src/test/java/org/axonframework/messaging/annotation/AnnotatedHandlerInspectorTest.java", "diffHunk": "@@ -66,28 +84,55 @@ public void testComplexHandlerHierarchy() throws NoSuchMethodException {\n         Map<Class<?>, SortedSet<MessageHandlingMember<? super A>>> allHandlers = inspector.getAllHandlers();\n         assertEquals(5, allHandlers.size());\n \n-        assertEquals(paHandle, allHandlers.get(pA.class).first());\n-        assertEquals(paHandle, inspector.getHandlers(pA.class).findFirst().get());\n+        assertEquals(paHandle, allHandlers.get(pA.class).first().unwrap(AnnotatedMessageHandlingMember.class).get());", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzODQ4MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406638480", "bodyText": "Yes, correct. There is now a chain of enhancements on the handler.", "author": "abuijze", "createdAt": "2020-04-10T07:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNTcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMDA3Ng==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405510076", "bodyText": "I don't \"feel\" what this call is verifying, as I don't notice any assertions.\nIs it just the fact it traverses through the class hierarchy, ending up in the interceptor?", "author": "smcvb", "createdAt": "2020-04-08T13:07:48Z", "path": "messaging/src/test/java/org/axonframework/messaging/annotation/AnnotatedHandlerInspectorTest.java", "diffHunk": "@@ -66,28 +84,55 @@ public void testComplexHandlerHierarchy() throws NoSuchMethodException {\n         Map<Class<?>, SortedSet<MessageHandlingMember<? super A>>> allHandlers = inspector.getAllHandlers();\n         assertEquals(5, allHandlers.size());\n \n-        assertEquals(paHandle, allHandlers.get(pA.class).first());\n-        assertEquals(paHandle, inspector.getHandlers(pA.class).findFirst().get());\n+        assertEquals(paHandle, allHandlers.get(pA.class).first().unwrap(AnnotatedMessageHandlingMember.class).get());\n+        assertEquals(paHandle, inspector.getHandlers(pA.class).findFirst().flatMap(h -> h.unwrap(AnnotatedMessageHandlingMember.class)).get());\n+\n+        assertEquals(asList(aOn, aHandle, paHandle), unwrapToList(allHandlers.get(A.class).stream()));\n+        assertEquals(asList(aOn, aHandle, paHandle), unwrapToList(inspector.getHandlers(A.class)));\n+\n+        assertEquals(asList(aOn, bOn, aHandle, bHandle, paHandle), unwrapToList(allHandlers.get(B.class).stream()));\n+        assertEquals(asList(aOn, bOn, aHandle, bHandle, paHandle), unwrapToList(inspector.getHandlers(B.class)));\n+\n+        assertEquals(asList(aOn, cOn, aHandle, cHandle, paHandle), unwrapToList(allHandlers.get(C.class).stream()));\n+        assertEquals(asList(aOn, cOn, aHandle, cHandle, paHandle), unwrapToList(inspector.getHandlers(C.class)));\n \n-        assertEquals(asList(aOn, aHandle, paHandle), new ArrayList<>(allHandlers.get(A.class)));\n-        assertEquals(asList(aOn, aHandle, paHandle), inspector.getHandlers(A.class).collect(toList()));\n+        assertEquals(asList(aOn, bOn, aHandle, bHandle, dHandle, paHandle), unwrapToList(allHandlers.get(D.class).stream()));\n+        assertEquals(asList(aOn, bOn, aHandle, bHandle, dHandle, paHandle), unwrapToList(inspector.getHandlers(D.class)));\n+    }\n \n-        assertEquals(asList(aOn, bOn, aHandle, bHandle, paHandle), new ArrayList<>(allHandlers.get(B.class)));\n-        assertEquals(asList(aOn, bOn, aHandle, bHandle, paHandle), inspector.getHandlers(B.class).collect(toList()));\n+    private <T extends MessageHandlingMember<?>> List<AnnotatedMessageHandlingMember> unwrapToList(Stream<T> stream) {\n+        return stream.map(e -> e.unwrap(AnnotatedMessageHandlingMember.class).get()).collect(Collectors.toList());\n+    }\n \n-        assertEquals(asList(aOn, cOn, aHandle, cHandle, paHandle), new ArrayList<>(allHandlers.get(C.class)));\n-        assertEquals(asList(aOn, cOn, aHandle, cHandle, paHandle), inspector.getHandlers(C.class).collect(toList()));\n+    @Test\n+    public void testInterceptors() throws Exception {\n+        Map<Class<?>, SortedSet<MessageHandlingMember<? super A>>> interceptors = inspector.getAllInterceptors();\n+        assertEquals(5, interceptors.size());\n+        assertEquals(1, interceptors.get(pA.class).size());\n+        assertEquals(1, interceptors.get(A.class).size());\n+        assertEquals(2, interceptors.get(B.class).size());\n+        assertEquals(1, interceptors.get(C.class).size());\n+        assertEquals(2, interceptors.get(D.class).size());\n+\n+        MessageHandlerInterceptorMemberChain<A> chain = inspector.chainedInterceptor(B.class);\n+\n+        chain.handle(asEventMessage(\"Hello\"), new D(), inspector.getHandlers(pA.class).findFirst().get());", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzODcwNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406638705", "bodyText": "This one is making sure no exceptions are thrown from this invocation, as opposed to the next call, which does throw an exception.", "author": "abuijze", "createdAt": "2020-04-10T07:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMDA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTc2MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406699760", "bodyText": "Alright, sounds reasonable to me.", "author": "smcvb", "createdAt": "2020-04-10T10:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMDA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMzYyOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405513628", "bodyText": "Why not also assert whether the value from the MetaData is populated in e.getMessage()?\nPretty sure it works though, just wondering.", "author": "smcvb", "createdAt": "2020-04-08T13:13:02Z", "path": "messaging/src/test/java/org/axonframework/eventhandling/AnnotationEventMessageHandlerAdapterTest.java", "diffHunk": "@@ -34,14 +42,117 @@ void testInvokeResetHandler() {\n         SomeHandler annotatedEventListener = new SomeHandler();\n         new AnnotationEventHandlerAdapter(annotatedEventListener,\n                                           MultiParameterResolverFactory.ordered(ClasspathParameterResolverFactory.forClass(getClass()),\n-                                                                                 new SimpleResourceParameterResolverFactory(singletonList(new SomeResource())))).prepareReset();\n+                                                                                new SimpleResourceParameterResolverFactory(singletonList(new SomeResource())))).prepareReset();\n \n         assertEquals(singletonList(\"reset\"), annotatedEventListener.invocations);\n     }\n \n+    @Test\n+    void testHandlerInterceptors() throws Exception {\n+        SomeHandler annotatedEventListener = new SomeInterceptingHandler();\n+        AnnotationEventHandlerAdapter testSubject = new AnnotationEventHandlerAdapter(annotatedEventListener,\n+                                                                                      MultiParameterResolverFactory.ordered(ClasspathParameterResolverFactory.forClass(getClass()),\n+                                                                                                                            new SimpleResourceParameterResolverFactory(singletonList(new SomeResource()))));\n+\n+        testSubject.handle(asEventMessage(\"count\"));\n+        assertEquals(3, annotatedEventListener.invocations.stream().filter(\"count\"::equals).count());\n+    }\n+\n+    @Test\n+    void testWrapExceptionInResultInterceptor() {\n+        Listener annotatedEventListener = new Listener();\n+        AnnotationEventHandlerAdapter testSubject = new AnnotationEventHandlerAdapter(annotatedEventListener,\n+                                                                                      MultiParameterResolverFactory.ordered(ClasspathParameterResolverFactory.forClass(getClass()),\n+                                                                                                                            new SimpleResourceParameterResolverFactory(singletonList(new SomeResource()))));\n+\n+        try {\n+            testSubject.handle(GenericEventMessage.asEventMessage(\"testing\").andMetaData(MetaData.with(\"key\", \"value\")));\n+            fail(\"Expected exception\");\n+        } catch (Exception e) {\n+            assertEquals(RuntimeException.class, e.getClass());\n+            assertEquals(IllegalArgumentException.class, e.getCause().getClass());\n+            assertEquals(\"testing\", e.getCause().getMessage());", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNDQyNg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405514426", "bodyText": "This tests look identical with testWrapExceptionInResultInterceptor.", "author": "smcvb", "createdAt": "2020-04-08T13:14:11Z", "path": "messaging/src/test/java/org/axonframework/eventhandling/AnnotationEventMessageHandlerAdapterTest.java", "diffHunk": "@@ -34,14 +42,117 @@ void testInvokeResetHandler() {\n         SomeHandler annotatedEventListener = new SomeHandler();\n         new AnnotationEventHandlerAdapter(annotatedEventListener,\n                                           MultiParameterResolverFactory.ordered(ClasspathParameterResolverFactory.forClass(getClass()),\n-                                                                                 new SimpleResourceParameterResolverFactory(singletonList(new SomeResource())))).prepareReset();\n+                                                                                new SimpleResourceParameterResolverFactory(singletonList(new SomeResource())))).prepareReset();\n \n         assertEquals(singletonList(\"reset\"), annotatedEventListener.invocations);\n     }\n \n+    @Test\n+    void testHandlerInterceptors() throws Exception {\n+        SomeHandler annotatedEventListener = new SomeInterceptingHandler();\n+        AnnotationEventHandlerAdapter testSubject = new AnnotationEventHandlerAdapter(annotatedEventListener,\n+                                                                                      MultiParameterResolverFactory.ordered(ClasspathParameterResolverFactory.forClass(getClass()),\n+                                                                                                                            new SimpleResourceParameterResolverFactory(singletonList(new SomeResource()))));\n+\n+        testSubject.handle(asEventMessage(\"count\"));\n+        assertEquals(3, annotatedEventListener.invocations.stream().filter(\"count\"::equals).count());\n+    }\n+\n+    @Test\n+    void testWrapExceptionInResultInterceptor() {\n+        Listener annotatedEventListener = new Listener();\n+        AnnotationEventHandlerAdapter testSubject = new AnnotationEventHandlerAdapter(annotatedEventListener,\n+                                                                                      MultiParameterResolverFactory.ordered(ClasspathParameterResolverFactory.forClass(getClass()),\n+                                                                                                                            new SimpleResourceParameterResolverFactory(singletonList(new SomeResource()))));\n+\n+        try {\n+            testSubject.handle(GenericEventMessage.asEventMessage(\"testing\").andMetaData(MetaData.with(\"key\", \"value\")));\n+            fail(\"Expected exception\");\n+        } catch (Exception e) {\n+            assertEquals(RuntimeException.class, e.getClass());\n+            assertEquals(IllegalArgumentException.class, e.getCause().getClass());\n+            assertEquals(\"testing\", e.getCause().getMessage());\n+        }\n+    }\n+\n+    @Test\n+    void testExceptionFromHandlerPickedUp() {", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNTQ0NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405515445", "bodyText": "Why not test the @ExceptionHandler cases here too?", "author": "smcvb", "createdAt": "2020-04-08T13:15:41Z", "path": "messaging/src/test/java/org/axonframework/queryhandling/annotation/AnnotationQueryHandlerAdapterTest.java", "diffHunk": "@@ -114,6 +124,22 @@ void testRunQueryForCollection() throws Exception {\n         assertEquals(testResponse, result.size());\n     }\n \n+    @Test\n+    void testInterceptMessages() throws Exception {\n+        List<QueryMessage<?, ?>> withInterceptor = new ArrayList<>();\n+        List<QueryMessage<?, ?>> withoutInterceptor = new ArrayList<>();\n+        testSubject = new AnnotationQueryHandlerAdapter<>(new MyInterceptingQueryHandler(withoutInterceptor, withInterceptor));\n+\n+        QueryMessage<String, String> testQueryMessage =\n+                new GenericQueryMessage<>(\"Hi\", \"Hello\", ResponseTypes.instanceOf(String.class));\n+\n+        String result = (String) testSubject.handle(testQueryMessage);\n+\n+        assertEquals(\"Hi\", result);\n+        assertEquals(Collections.singletonList(testQueryMessage), withInterceptor);\n+        assertEquals(Collections.singletonList(testQueryMessage), withoutInterceptor);\n+    }", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzOTIwOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406639209", "bodyText": "I figured the implementation is generic enough not to have to deal with different types of interceptors. I just want to ensure that interceptors are being taken into account in the invocation of a handler.", "author": "abuijze", "createdAt": "2020-04-10T07:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNTQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTg4OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406699889", "bodyText": "Sound judgment call", "author": "smcvb", "createdAt": "2020-04-10T10:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNTQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNTk0MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405515941", "bodyText": "Just to make sure I am on the right path. The unwrapping is necessary because you switched from the AnnotatedMessageHandlingMemberDefinition to the ClasspathHandlerDefinition, right?", "author": "smcvb", "createdAt": "2020-04-08T13:16:27Z", "path": "messaging/src/test/java/org/axonframework/messaging/annotation/AnnotatedHandlerInspectorTest.java", "diffHunk": "@@ -66,28 +84,55 @@ public void testComplexHandlerHierarchy() throws NoSuchMethodException {\n         Map<Class<?>, SortedSet<MessageHandlingMember<? super A>>> allHandlers = inspector.getAllHandlers();\n         assertEquals(5, allHandlers.size());\n \n-        assertEquals(paHandle, allHandlers.get(pA.class).first());\n-        assertEquals(paHandle, inspector.getHandlers(pA.class).findFirst().get());\n+        assertEquals(paHandle, allHandlers.get(pA.class).first().unwrap(AnnotatedMessageHandlingMember.class).get());", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzODQ3MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406638470", "bodyText": "Yes, correct. There is now a chain of enhancements on the handler.", "author": "abuijze", "createdAt": "2020-04-10T07:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNjE5MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405516190", "bodyText": "I am uncertain what this chain call actually tests at the moment.", "author": "smcvb", "createdAt": "2020-04-08T13:16:49Z", "path": "messaging/src/test/java/org/axonframework/messaging/annotation/AnnotatedHandlerInspectorTest.java", "diffHunk": "@@ -66,28 +84,55 @@ public void testComplexHandlerHierarchy() throws NoSuchMethodException {\n         Map<Class<?>, SortedSet<MessageHandlingMember<? super A>>> allHandlers = inspector.getAllHandlers();\n         assertEquals(5, allHandlers.size());\n \n-        assertEquals(paHandle, allHandlers.get(pA.class).first());\n-        assertEquals(paHandle, inspector.getHandlers(pA.class).findFirst().get());\n+        assertEquals(paHandle, allHandlers.get(pA.class).first().unwrap(AnnotatedMessageHandlingMember.class).get());\n+        assertEquals(paHandle, inspector.getHandlers(pA.class).findFirst().flatMap(h -> h.unwrap(AnnotatedMessageHandlingMember.class)).get());\n+\n+        assertEquals(asList(aOn, aHandle, paHandle), unwrapToList(allHandlers.get(A.class).stream()));\n+        assertEquals(asList(aOn, aHandle, paHandle), unwrapToList(inspector.getHandlers(A.class)));\n+\n+        assertEquals(asList(aOn, bOn, aHandle, bHandle, paHandle), unwrapToList(allHandlers.get(B.class).stream()));\n+        assertEquals(asList(aOn, bOn, aHandle, bHandle, paHandle), unwrapToList(inspector.getHandlers(B.class)));\n+\n+        assertEquals(asList(aOn, cOn, aHandle, cHandle, paHandle), unwrapToList(allHandlers.get(C.class).stream()));\n+        assertEquals(asList(aOn, cOn, aHandle, cHandle, paHandle), unwrapToList(inspector.getHandlers(C.class)));\n \n-        assertEquals(asList(aOn, aHandle, paHandle), new ArrayList<>(allHandlers.get(A.class)));\n-        assertEquals(asList(aOn, aHandle, paHandle), inspector.getHandlers(A.class).collect(toList()));\n+        assertEquals(asList(aOn, bOn, aHandle, bHandle, dHandle, paHandle), unwrapToList(allHandlers.get(D.class).stream()));\n+        assertEquals(asList(aOn, bOn, aHandle, bHandle, dHandle, paHandle), unwrapToList(inspector.getHandlers(D.class)));\n+    }\n \n-        assertEquals(asList(aOn, bOn, aHandle, bHandle, paHandle), new ArrayList<>(allHandlers.get(B.class)));\n-        assertEquals(asList(aOn, bOn, aHandle, bHandle, paHandle), inspector.getHandlers(B.class).collect(toList()));\n+    private <T extends MessageHandlingMember<?>> List<AnnotatedMessageHandlingMember> unwrapToList(Stream<T> stream) {\n+        return stream.map(e -> e.unwrap(AnnotatedMessageHandlingMember.class).get()).collect(Collectors.toList());\n+    }\n \n-        assertEquals(asList(aOn, cOn, aHandle, cHandle, paHandle), new ArrayList<>(allHandlers.get(C.class)));\n-        assertEquals(asList(aOn, cOn, aHandle, cHandle, paHandle), inspector.getHandlers(C.class).collect(toList()));\n+    @Test\n+    public void testInterceptors() throws Exception {\n+        Map<Class<?>, SortedSet<MessageHandlingMember<? super A>>> interceptors = inspector.getAllInterceptors();\n+        assertEquals(5, interceptors.size());\n+        assertEquals(1, interceptors.get(pA.class).size());\n+        assertEquals(1, interceptors.get(A.class).size());\n+        assertEquals(2, interceptors.get(B.class).size());\n+        assertEquals(1, interceptors.get(C.class).size());\n+        assertEquals(2, interceptors.get(D.class).size());\n+\n+        MessageHandlerInterceptorMemberChain<A> chain = inspector.chainedInterceptor(B.class);\n+\n+        chain.handle(asEventMessage(\"Hello\"), new D(), inspector.getHandlers(pA.class).findFirst().get());", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMTEyOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405521128", "bodyText": "I cant seem to be able to wrap my head around this one line here.\nIs this done so that we do not enforce users to inject the InterceptorChain in an @ExceptionHandler annotated method (which feels fair tbh)?\nAnd subsequently, that it doesn't matter in which part of the InterceptorChain the ResultHandlingInterceptorMember resides?", "author": "smcvb", "createdAt": "2020-04-08T13:23:44Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorDefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.eventhandling.interceptors.MessageHandlerInterceptor;\n+import org.axonframework.eventhandling.interceptors.ResultHandler;\n+import org.axonframework.messaging.InterceptorChain;\n+import org.axonframework.messaging.Message;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * MethodEnhancerDefinition that marks methods (meta-)annotated with {@link MessageHandlerInterceptor}\n+ * as interceptors. These methods need to be given special treatment when invoking handlers. Matching\n+ * interceptors need to be invoked first, allowing them to proceed the invocation chain.\n+ * <p>\n+ * This definition also recognizes interceptors only acting on the response. These must be meta-annotated with\n+ * {@link ResultHandler}.\n+ */\n+public class MessageHandlerInterceptorDefinition implements HandlerEnhancerDefinition {\n+    @Override\n+    public <T> MessageHandlingMember<T> wrapHandler(MessageHandlingMember<T> original) {\n+\n+        if (original.annotationAttributes(MessageHandlerInterceptor.class).isPresent()) {\n+            Optional<Map<String, Object>> attributes = original.annotationAttributes(ResultHandler.class);\n+            if (attributes.isPresent()) {\n+                return new ResultHandlingInterceptorMember<>(original, (Class<?>) attributes.get().get(\"resultType\"));\n+            }\n+            return new InterceptedMessageHandlingMember<>(original);\n+        }\n+        return original;\n+    }\n+\n+    private static class ResultHandlingInterceptorMember<T> extends WrappedMessageHandlingMember<T> implements MessageHandlerInterceptorMember<T> {\n+\n+        private final Class<?> expectedResultType;\n+\n+        public ResultHandlingInterceptorMember(MessageHandlingMember<T> original, Class<?> expectedResultType) {\n+            super(original);\n+            this.expectedResultType = expectedResultType;\n+            Method method = original.unwrap(Method.class).orElseThrow(() -> new AxonConfigurationException(\n+                    \"The @ExceptionHandler must be on method.\"));\n+            boolean declaredInterceptorChain = Arrays.stream(method.getParameters())\n+                                                     .anyMatch(p -> p.getType().equals(InterceptorChain.class));\n+            if (declaredInterceptorChain) {\n+                throw new AxonConfigurationException(\"@ExceptionHandler annotated methods should not delare an InterceptorChain parameter\");\n+            }\n+        }\n+\n+        @Override\n+        public boolean canHandle(Message<?> message) {\n+            return ResultParameterResolverFactory.ignoringResultParameters(() -> super.canHandle(message));\n+        }\n+\n+        @Override\n+        public Object handle(Message<?> message, T target) throws Exception {\n+            InterceptorChain chain = InterceptorChainParameterResolverFactory.currentInterceptorChain();\n+            try {\n+                return chain.proceed();", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzNjMzNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406636335", "bodyText": "This is an interceptor that acts on the result of a handler invocation. The proceed call is used to continue in the chain, so that we can invoke the handler \"interceptor\" with the result of that invocation. In this particular instance, it's a handler that only needs to act on Exceptions, so we catch exceptions and check if the actual exception thrown matches the interceptor's signature. If so, we invoke it, otherwise, we rethrow the exception.", "author": "abuijze", "createdAt": "2020-04-10T07:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMTEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMDMwOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406700308", "bodyText": "Alright, then my gut was right here I feel. Thanks for clarifying further.", "author": "smcvb", "createdAt": "2020-04-10T10:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2OTc4Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405569787", "bodyText": "Isn't this super.canHandle check already performed in the local canHandle call? What's the scenario when this is false so that the exception needs to be thrown again?", "author": "smcvb", "createdAt": "2020-04-08T14:30:50Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorDefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.eventhandling.interceptors.MessageHandlerInterceptor;\n+import org.axonframework.eventhandling.interceptors.ResultHandler;\n+import org.axonframework.messaging.InterceptorChain;\n+import org.axonframework.messaging.Message;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * MethodEnhancerDefinition that marks methods (meta-)annotated with {@link MessageHandlerInterceptor}\n+ * as interceptors. These methods need to be given special treatment when invoking handlers. Matching\n+ * interceptors need to be invoked first, allowing them to proceed the invocation chain.\n+ * <p>\n+ * This definition also recognizes interceptors only acting on the response. These must be meta-annotated with\n+ * {@link ResultHandler}.\n+ */\n+public class MessageHandlerInterceptorDefinition implements HandlerEnhancerDefinition {\n+    @Override\n+    public <T> MessageHandlingMember<T> wrapHandler(MessageHandlingMember<T> original) {\n+\n+        if (original.annotationAttributes(MessageHandlerInterceptor.class).isPresent()) {\n+            Optional<Map<String, Object>> attributes = original.annotationAttributes(ResultHandler.class);\n+            if (attributes.isPresent()) {\n+                return new ResultHandlingInterceptorMember<>(original, (Class<?>) attributes.get().get(\"resultType\"));\n+            }\n+            return new InterceptedMessageHandlingMember<>(original);\n+        }\n+        return original;\n+    }\n+\n+    private static class ResultHandlingInterceptorMember<T> extends WrappedMessageHandlingMember<T> implements MessageHandlerInterceptorMember<T> {\n+\n+        private final Class<?> expectedResultType;\n+\n+        public ResultHandlingInterceptorMember(MessageHandlingMember<T> original, Class<?> expectedResultType) {\n+            super(original);\n+            this.expectedResultType = expectedResultType;\n+            Method method = original.unwrap(Method.class).orElseThrow(() -> new AxonConfigurationException(\n+                    \"The @ExceptionHandler must be on method.\"));\n+            boolean declaredInterceptorChain = Arrays.stream(method.getParameters())\n+                                                     .anyMatch(p -> p.getType().equals(InterceptorChain.class));\n+            if (declaredInterceptorChain) {\n+                throw new AxonConfigurationException(\"@ExceptionHandler annotated methods should not delare an InterceptorChain parameter\");\n+            }\n+        }\n+\n+        @Override\n+        public boolean canHandle(Message<?> message) {\n+            return ResultParameterResolverFactory.ignoringResultParameters(() -> super.canHandle(message));\n+        }\n+\n+        @Override\n+        public Object handle(Message<?> message, T target) throws Exception {\n+            InterceptorChain chain = InterceptorChainParameterResolverFactory.currentInterceptorChain();\n+            try {\n+                return chain.proceed();\n+            } catch (Exception e) {\n+                if (!expectedResultType.isInstance(e)) {\n+                    throw e;\n+                }\n+                return ResultParameterResolverFactory.callWithResult(e, () -> {\n+                    if (super.canHandle(message)) {", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzNjkyNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406636927", "bodyText": "No, canHandle has to be permissive (it ignores any parameters that expect an invocation result), since we only know if the can really handle this message when we also know the result. In this case, we also explicitly check if the result is of the type the handler expects.", "author": "abuijze", "createdAt": "2020-04-10T07:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2OTc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMDU3Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406700572", "bodyText": "Aaah gotcha, of course!", "author": "smcvb", "createdAt": "2020-04-10T10:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2OTc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MDg1OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405570859", "bodyText": "What if the user didn't call InterceptorChain#proceed, even though a parameter was added to the @MessageHandlerInterceptor annotated method?", "author": "smcvb", "createdAt": "2020-04-08T14:32:16Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlerInterceptorDefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.eventhandling.interceptors.MessageHandlerInterceptor;\n+import org.axonframework.eventhandling.interceptors.ResultHandler;\n+import org.axonframework.messaging.InterceptorChain;\n+import org.axonframework.messaging.Message;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * MethodEnhancerDefinition that marks methods (meta-)annotated with {@link MessageHandlerInterceptor}\n+ * as interceptors. These methods need to be given special treatment when invoking handlers. Matching\n+ * interceptors need to be invoked first, allowing them to proceed the invocation chain.\n+ * <p>\n+ * This definition also recognizes interceptors only acting on the response. These must be meta-annotated with\n+ * {@link ResultHandler}.\n+ */\n+public class MessageHandlerInterceptorDefinition implements HandlerEnhancerDefinition {\n+    @Override\n+    public <T> MessageHandlingMember<T> wrapHandler(MessageHandlingMember<T> original) {\n+\n+        if (original.annotationAttributes(MessageHandlerInterceptor.class).isPresent()) {\n+            Optional<Map<String, Object>> attributes = original.annotationAttributes(ResultHandler.class);\n+            if (attributes.isPresent()) {\n+                return new ResultHandlingInterceptorMember<>(original, (Class<?>) attributes.get().get(\"resultType\"));\n+            }\n+            return new InterceptedMessageHandlingMember<>(original);\n+        }\n+        return original;\n+    }\n+\n+    private static class ResultHandlingInterceptorMember<T> extends WrappedMessageHandlingMember<T> implements MessageHandlerInterceptorMember<T> {\n+\n+        private final Class<?> expectedResultType;\n+\n+        public ResultHandlingInterceptorMember(MessageHandlingMember<T> original, Class<?> expectedResultType) {\n+            super(original);\n+            this.expectedResultType = expectedResultType;\n+            Method method = original.unwrap(Method.class).orElseThrow(() -> new AxonConfigurationException(\n+                    \"The @ExceptionHandler must be on method.\"));\n+            boolean declaredInterceptorChain = Arrays.stream(method.getParameters())\n+                                                     .anyMatch(p -> p.getType().equals(InterceptorChain.class));\n+            if (declaredInterceptorChain) {\n+                throw new AxonConfigurationException(\"@ExceptionHandler annotated methods should not delare an InterceptorChain parameter\");\n+            }\n+        }\n+\n+        @Override\n+        public boolean canHandle(Message<?> message) {\n+            return ResultParameterResolverFactory.ignoringResultParameters(() -> super.canHandle(message));\n+        }\n+\n+        @Override\n+        public Object handle(Message<?> message, T target) throws Exception {\n+            InterceptorChain chain = InterceptorChainParameterResolverFactory.currentInterceptorChain();\n+            try {\n+                return chain.proceed();\n+            } catch (Exception e) {\n+                if (!expectedResultType.isInstance(e)) {\n+                    throw e;\n+                }\n+                return ResultParameterResolverFactory.callWithResult(e, () -> {\n+                    if (super.canHandle(message)) {\n+                        return super.handle(message, target);\n+                    }\n+                    throw e;\n+                });\n+            }\n+        }\n+    }\n+\n+    private static class InterceptedMessageHandlingMember<T> extends WrappedMessageHandlingMember<T> implements MessageHandlerInterceptorMember<T> {\n+\n+        private final boolean shouldInvokeInterceptorChain;\n+\n+        public InterceptedMessageHandlingMember(MessageHandlingMember<T> original) {\n+            super(original);\n+            Method method = original.unwrap(Method.class).orElseThrow(() -> new AxonConfigurationException(\n+                    \"The @MessageHandlerInterceptor must be on method.\"));\n+            shouldInvokeInterceptorChain = Arrays.stream(method.getParameters())\n+                                                 .noneMatch(p -> p.getType().equals(InterceptorChain.class));\n+            if (shouldInvokeInterceptorChain && !Void.TYPE.equals(method.getReturnType())) {\n+                throw new AxonConfigurationException(\"@MessageHandlerInterceptor must return void or declare \" +\n+                                                             \"InterceptorChain parameter.\");\n+            }\n+        }\n+\n+        @Override\n+        public Object handle(Message<?> message, T target) throws Exception {\n+            Object result = super.handle(message, target);\n+            if (shouldInvokeInterceptorChain) {", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzNzQ4Mw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406637483", "bodyText": "Then apparently the interceptor thought it was necessary to prevent the invocation of the handler.", "author": "abuijze", "createdAt": "2020-04-10T07:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MDg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMTczMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406701732", "bodyText": "{facepalm} But of course..thanks for that.", "author": "smcvb", "createdAt": "2020-04-10T10:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MDg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MTg4OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r405571888", "bodyText": "So, the canHandle method will/can actually call handle too? Or, will the parameter already be resolved if we perform canHandle?", "author": "smcvb", "createdAt": "2020-04-08T14:33:44Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/ResultParameterResolverFactory.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.annotation.AnnotationUtils;\n+import org.axonframework.eventhandling.interceptors.ResultHandler;\n+import org.axonframework.messaging.Message;\n+\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.Parameter;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+\n+/**\n+ * ParameterResolverFactory that provides support for Parameters where the result of Handler execution is expected to\n+ * be injected. This is only possible in interceptor handlers that need to act on the result of downstream interceptors\n+ * or the regular handler.\n+ * <p>\n+ * The {@link ResultHandler @ResultHandler} Meta-Annotation needs to be placed on handlers that support interacting with\n+ * the result type in its parameters.\n+ *\n+ * @author Allard Buijze\n+ * @since 4.4\n+ */\n+public class ResultParameterResolverFactory implements ParameterResolverFactory {\n+\n+\n+    private static final ThreadLocal<Object> REGISTERED_RESULT = new ThreadLocal<>();\n+    private static final Object IGNORE_RESULT_PARAMETER_MARKER = new Object();\n+\n+    /**\n+     * Calls the given {@code action} (typically a handler invocation) such that the given {@code result} is available\n+     * for injection as parameter\n+     *\n+     * @param result The result to make available for parameter injection\n+     * @param action The action to take\n+     *\n+     * @return the result of the action\n+     * @throws Exception any exception thrown while executing the {@code action}\n+     */\n+    public static Object callWithResult(Object result, Callable<?> action) throws Exception {\n+        Object previous = REGISTERED_RESULT.get();\n+        REGISTERED_RESULT.set(result);\n+        try {\n+            return action.call();\n+        } finally {\n+            if (previous == null) {\n+                REGISTERED_RESULT.remove();\n+            } else {\n+                REGISTERED_RESULT.set(previous);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Performs the given {@code action} ignoring any parameters expecting a result type. This is typically used to\n+     * detect whether a handler is suitable for invocation prior to the result value being available.", "originalCommit": "359188e01ec72425744359b645619204ffa4ecac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzODA5MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406638090", "bodyText": "This will not call handle. The idea is that we can use this method to find out if an interceptor acting on the result is potentially able to handle it. But since we don't know the actual result of the invocation yet, we can't be sure. The actual handle method is responsible for that additional check once the result is known.", "author": "abuijze", "createdAt": "2020-04-10T07:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MTg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNDYwOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406704609", "bodyText": "Had to debug this myself to truelly understand the process why this makes sense. Any how, it makes sense now, hence I'll resolve this comment too.", "author": "smcvb", "createdAt": "2020-04-10T10:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MTg4OA=="}], "type": "inlineReview"}, {"oid": "f9088f93d2249c9026bdb0430abb3ce5720b87d5", "url": "https://github.com/AxonFramework/AxonFramework/commit/f9088f93d2249c9026bdb0430abb3ce5720b87d5", "message": "Apply suggestions from code review\r\n\r\nSuggestions from code review\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-04-09T20:37:23Z", "type": "commit"}, {"oid": "18c31a0a905c42de0f15c5c21294013ae726e12b", "url": "https://github.com/AxonFramework/AxonFramework/commit/18c31a0a905c42de0f15c5c21294013ae726e12b", "message": "Changes after review comments", "committedDate": "2020-04-09T20:47:45Z", "type": "commit"}, {"oid": "d2170f45e30baa5ebf13d86da7264cb10fcadab9", "url": "https://github.com/AxonFramework/AxonFramework/commit/d2170f45e30baa5ebf13d86da7264cb10fcadab9", "message": "Improvement of exception descriptions", "committedDate": "2020-04-10T08:06:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3OTc1Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1394#discussion_r406679752", "bodyText": "Daaawh, sad, but I figured this wasn't a class level annotation.", "author": "smcvb", "createdAt": "2020-04-10T09:23:50Z", "path": "messaging/src/main/java/org/axonframework/messaging/interceptors/ExceptionHandler.java", "diffHunk": "@@ -24,7 +24,7 @@\n import java.lang.annotation.Target;\n \n /**\n- * Annotation marking a Handler (or class) as an interceptor for other handlers that is only interested in handling", "originalCommit": "18c31a0a905c42de0f15c5c21294013ae726e12b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "67ee34aefdd8dbcda9b0ea4fc14f67c31fa0f55c", "url": "https://github.com/AxonFramework/AxonFramework/commit/67ee34aefdd8dbcda9b0ea4fc14f67c31fa0f55c", "message": "Merge remote-tracking branch 'origin/master' into feature-annotated-interceptors\n\n# Conflicts:\n#\tmessaging/src/main/java/org/axonframework/eventhandling/AnnotationEventHandlerAdapter.java\n#\tmessaging/src/main/resources/META-INF/services/org.axonframework.messaging.annotation.HandlerEnhancerDefinition\n#\tmessaging/src/test/java/org/axonframework/eventhandling/AnnotationEventMessageHandlerAdapterTest.java\n#\tspring/src/test/java/org/axonframework/spring/config/SpringAxonAutoConfigurerTest.java", "committedDate": "2020-07-02T10:16:35Z", "type": "commit"}, {"oid": "83abf6e44d4b7ad1c64a8432128963c18c68dac0", "url": "https://github.com/AxonFramework/AxonFramework/commit/83abf6e44d4b7ad1c64a8432128963c18c68dac0", "message": "Fix merge issues\n\nFix merge issues due to reset context addition in the\nAnnotationEventHandlerAdapter and their respective tests\n\n#901", "committedDate": "2020-07-02T11:06:35Z", "type": "commit"}, {"oid": "b9a569e6b2546d4e7c63aed6f896d61089daf3f6", "url": "https://github.com/AxonFramework/AxonFramework/commit/b9a569e6b2546d4e7c63aed6f896d61089daf3f6", "message": "Fix code smells\n\n- Use diamond casing\n- Drop test complexity\n\n#901", "committedDate": "2020-07-02T11:46:31Z", "type": "commit"}, {"oid": "51833d175aa581c76cb848a75cee9e7284ad94b9", "url": "https://github.com/AxonFramework/AxonFramework/commit/51833d175aa581c76cb848a75cee9e7284ad94b9", "message": "Merge remote-tracking branch 'origin/master' into feature-annotated-interceptors", "committedDate": "2020-07-07T08:08:33Z", "type": "commit"}]}