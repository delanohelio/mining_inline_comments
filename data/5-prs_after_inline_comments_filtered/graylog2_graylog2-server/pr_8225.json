{"pr_number": 8225, "pr_title": "Extract interface from `Indices` class, isolate ES-specific details.", "pr_createdAt": "2020-05-28T11:21:08Z", "pr_url": "https://github.com/Graylog2/graylog2-server/pull/8225", "timeline": [{"oid": "65fa0d4d74a7d4cb006fe7a0281a8e695e014fc7", "url": "https://github.com/Graylog2/graylog2-server/commit/65fa0d4d74a7d4cb006fe7a0281a8e695e014fc7", "message": "Removing unused dependencies.", "committedDate": "2020-05-28T12:45:43Z", "type": "forcePushed"}, {"oid": "93b748867560f1a8f16746e1ca759d9750e02f32", "url": "https://github.com/Graylog2/graylog2-server/commit/93b748867560f1a8f16746e1ca759d9750e02f32", "message": "Adding license header.", "committedDate": "2020-06-03T15:15:48Z", "type": "forcePushed"}, {"oid": "3edbed16f7332913495c1e13dd951551bda4587b", "url": "https://github.com/Graylog2/graylog2-server/commit/3edbed16f7332913495c1e13dd951551bda4587b", "message": "Making integration test abstract and implementing adapter creation.", "committedDate": "2020-06-04T08:25:32Z", "type": "forcePushed"}, {"oid": "c11f4ca25de7c15dcae7e24a502abb23f28b7d0f", "url": "https://github.com/Graylog2/graylog2-server/commit/c11f4ca25de7c15dcae7e24a502abb23f28b7d0f", "message": "Making integration test abstract and implementing adapter creation.", "committedDate": "2020-06-04T12:50:17Z", "type": "forcePushed"}, {"oid": "241e298d4c300052e1db82b3922e71d0b8739e76", "url": "https://github.com/Graylog2/graylog2-server/commit/241e298d4c300052e1db82b3922e71d0b8739e76", "message": "Extracting interface from `Indices` class.", "committedDate": "2020-06-05T07:49:39Z", "type": "commit"}, {"oid": "f41dd61a6417fdd40dd333d8a0d8cdad856b5d4b", "url": "https://github.com/Graylog2/graylog2-server/commit/f41dd61a6417fdd40dd333d8a0d8cdad856b5d4b", "message": "Binding implementation for `IndicesAdapter`.", "committedDate": "2020-06-05T07:49:42Z", "type": "commit"}, {"oid": "026c22788cf0971b5d9b20cba92d98919a7d75ca", "url": "https://github.com/Graylog2/graylog2-server/commit/026c22788cf0971b5d9b20cba92d98919a7d75ca", "message": "Using own health status class.", "committedDate": "2020-06-05T07:49:42Z", "type": "commit"}, {"oid": "42eb4ed71c66e6260c95b15160ee6d3dbc2a70be", "url": "https://github.com/Graylog2/graylog2-server/commit/42eb4ed71c66e6260c95b15160ee6d3dbc2a70be", "message": "Removing unused dependencies.", "committedDate": "2020-06-05T07:49:42Z", "type": "commit"}, {"oid": "f74ed9d47f61a54c6ae111b5a71974240c5d7029", "url": "https://github.com/Graylog2/graylog2-server/commit/f74ed9d47f61a54c6ae111b5a71974240c5d7029", "message": "Adapting to changes.", "committedDate": "2020-06-05T07:49:42Z", "type": "commit"}, {"oid": "5e3fe2b65158387d9b3022df8202c454799e67ba", "url": "https://github.com/Graylog2/graylog2-server/commit/5e3fe2b65158387d9b3022df8202c454799e67ba", "message": "Adding license header.", "committedDate": "2020-06-05T07:49:42Z", "type": "commit"}, {"oid": "496987503285cdb9abffdc175e426422bd03d5d9", "url": "https://github.com/Graylog2/graylog2-server/commit/496987503285cdb9abffdc175e426422bd03d5d9", "message": "Making integration test abstract and implementing adapter creation.", "committedDate": "2020-06-05T07:50:06Z", "type": "commit"}, {"oid": "496987503285cdb9abffdc175e426422bd03d5d9", "url": "https://github.com/Graylog2/graylog2-server/commit/496987503285cdb9abffdc175e426422bd03d5d9", "message": "Making integration test abstract and implementing adapter creation.", "committedDate": "2020-06-05T07:50:06Z", "type": "forcePushed"}, {"oid": "866459bc60ecbbaa91e4bb251d5cbbf44bc077f1", "url": "https://github.com/Graylog2/graylog2-server/commit/866459bc60ecbbaa91e4bb251d5cbbf44bc077f1", "message": "Removing jest references from test, adjusting `IndicesAdapter` construction.", "committedDate": "2020-06-05T07:58:01Z", "type": "commit"}, {"oid": "3bf528a308c731b6df4eb709b34ac7ae4d7cd8a0", "url": "https://github.com/Graylog2/graylog2-server/commit/3bf528a308c731b6df4eb709b34ac7ae4d7cd8a0", "message": "Moving `prepareIndexRequest` to separate, implementation class.", "committedDate": "2020-06-05T10:32:11Z", "type": "commit"}, {"oid": "25ec13dc6b0ac53cf1d22506e8182cd15151da82", "url": "https://github.com/Graylog2/graylog2-server/commit/25ec13dc6b0ac53cf1d22506e8182cd15151da82", "message": "Removing unneeded imports.", "committedDate": "2020-06-05T10:32:35Z", "type": "commit"}, {"oid": "5bcdb7e9c5161d634460372c5fa94ff2e2657e67", "url": "https://github.com/Graylog2/graylog2-server/commit/5bcdb7e9c5161d634460372c5fa94ff2e2657e67", "message": "Moving ES-specifics from `MessagesIT` to `MessagesES6IT`.", "committedDate": "2020-06-05T10:41:45Z", "type": "commit"}, {"oid": "a8fd9f42f925ae63c3f18798f418cf83c329bed6", "url": "https://github.com/Graylog2/graylog2-server/commit/a8fd9f42f925ae63c3f18798f418cf83c329bed6", "message": "Preventing exception or indexing without document id when moving.\n\nBefore this change, when moving documents from one index to another, it\ncould theoretically happen that a document either has no source field or\nno id. In the first case an exception would be thrown and further moving\naborted, in the other case a document without an id would be attempted\nto index.\n\nThis small change is handling the optionality of the source field\nproperly and only adds a bulk indexing action to the request if both\nsource and id fields exist.", "committedDate": "2020-06-05T12:31:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyNzEwNA==", "url": "https://github.com/Graylog2/graylog2-server/pull/8225#discussion_r435827104", "bodyText": "These two should be final.", "author": "alex-konn", "createdAt": "2020-06-05T10:15:21Z", "path": "graylog-storage-elasticsearch6/src/main/java/org/graylog/storage/elasticsearch6/IndicesAdapterES6.java", "diffHunk": "@@ -0,0 +1,642 @@\n+package org.graylog.storage.elasticsearch6;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterators;\n+import com.google.common.primitives.Ints;\n+import io.searchbox.client.JestClient;\n+import io.searchbox.client.JestResult;\n+import io.searchbox.cluster.Health;\n+import io.searchbox.cluster.State;\n+import io.searchbox.core.Bulk;\n+import io.searchbox.core.BulkResult;\n+import io.searchbox.core.Cat;\n+import io.searchbox.core.CatResult;\n+import io.searchbox.core.Search;\n+import io.searchbox.core.SearchResult;\n+import io.searchbox.core.SearchScroll;\n+import io.searchbox.core.search.aggregation.FilterAggregation;\n+import io.searchbox.core.search.aggregation.MaxAggregation;\n+import io.searchbox.core.search.aggregation.MinAggregation;\n+import io.searchbox.core.search.aggregation.TermsAggregation;\n+import io.searchbox.indices.CloseIndex;\n+import io.searchbox.indices.CreateIndex;\n+import io.searchbox.indices.DeleteIndex;\n+import io.searchbox.indices.Flush;\n+import io.searchbox.indices.ForceMerge;\n+import io.searchbox.indices.OpenIndex;\n+import io.searchbox.indices.Stats;\n+import io.searchbox.indices.aliases.AddAliasMapping;\n+import io.searchbox.indices.aliases.AliasMapping;\n+import io.searchbox.indices.aliases.GetAliases;\n+import io.searchbox.indices.aliases.ModifyAliases;\n+import io.searchbox.indices.aliases.RemoveAliasMapping;\n+import io.searchbox.indices.settings.GetSettings;\n+import io.searchbox.indices.settings.UpdateSettings;\n+import io.searchbox.indices.template.DeleteTemplate;\n+import io.searchbox.indices.template.PutTemplate;\n+import io.searchbox.params.Parameters;\n+import io.searchbox.params.SearchType;\n+import org.apache.http.client.config.RequestConfig;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortBuilders;\n+import org.graylog2.indexer.ElasticsearchException;\n+import org.graylog2.indexer.IndexMapping;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.cluster.jest.JestUtils;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.messages.Messages;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.jackson.TypeReferences;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.elasticsearch.search.builder.SearchSourceBuilder.searchSource;\n+\n+public class IndicesAdapterES6 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES6.class);\n+    private final JestClient jestClient;\n+    private ObjectMapper objectMapper;\n+    private Messages messages;", "originalCommit": "866459bc60ecbbaa91e4bb251d5cbbf44bc077f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMTM3OA==", "url": "https://github.com/Graylog2/graylog2-server/pull/8225#discussion_r435901378", "bodyText": "...as they already have been made in the meantime.", "author": "alex-konn", "createdAt": "2020-06-05T12:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyNzEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NTAxNg==", "url": "https://github.com/Graylog2/graylog2-server/pull/8225#discussion_r435845016", "bodyText": "This method can be private. I would also suppress the warning caused by id always being \"1\". Bonus points for moving the method below its usage in the test. :)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected boolean indexMessage(String index, Map<String, Object> source, String id) {\n          \n          \n            \n            private boolean indexMessage(String index, Map<String, Object> source, @SuppressWarnings(\"SameParameterValue\") String id) {", "author": "alex-konn", "createdAt": "2020-06-05T10:54:33Z", "path": "graylog-storage-elasticsearch6/src/test/java/org/graylog/storage/elasticsearch6/MessagesES6IT.java", "diffHunk": "@@ -1,12 +1,61 @@\n package org.graylog.storage.elasticsearch6;\n \n import com.codahale.metrics.MetricRegistry;\n+import io.searchbox.client.JestResult;\n+import io.searchbox.core.Count;\n+import io.searchbox.core.CountResult;\n+import io.searchbox.core.DocumentResult;\n+import io.searchbox.core.Index;\n+import org.graylog2.indexer.cluster.jest.JestUtils;\n import org.graylog2.indexer.messages.MessagesAdapter;\n import org.graylog2.indexer.messages.MessagesIT;\n+import org.graylog2.indexer.results.ResultMessage;\n+import org.graylog2.plugin.Message;\n+import org.junit.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n \n public class MessagesES6IT extends MessagesIT {\n+    private final IndexingHelper indexingHelper = new IndexingHelper();\n+\n     @Override\n     protected MessagesAdapter createMessagesAdapter(MetricRegistry metricRegistry) {\n         return new MessagesAdapterES6(jestClient(), true, metricRegistry);\n     }\n+\n+    @Override\n+    protected Double messageCount(String indexName) {\n+        final Count count = new Count.Builder().addIndex(indexName).build();\n+\n+        final CountResult result = JestUtils.execute(jestClient(), count, () -> \"Unable to count documents\");\n+        return result.getCount();\n+    }\n+\n+    protected boolean indexMessage(String index, Map<String, Object> source, String id) {", "originalCommit": "5bcdb7e9c5161d634460372c5fa94ff2e2657e67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0OTU2Nw==", "url": "https://github.com/Graylog2/graylog2-server/pull/8225#discussion_r435849567", "bodyText": "We should use a mocked EventBus here and also suppress the related Unstable warning. I know it was like this before, but still... :)", "author": "alex-konn", "createdAt": "2020-06-05T11:04:17Z", "path": "graylog2-server/src/test/java/org/graylog2/indexer/fieldtypes/IndexFieldTypePollerIT.java", "diffHunk": "@@ -71,19 +67,21 @@\n             .build();\n     private TestIndexSet indexSet;\n \n+    protected abstract IndicesAdapter createIndicesAdapter();\n+\n     @Before\n     public void setUp() throws Exception {\n-        final Indices indices = new Indices(jestClient(),\n-                new ObjectMapperProvider().get(),\n+        final Indices indices = new Indices(\n                 new IndexMappingFactory(new Node(jestClient())),\n-                new Messages(mock(TrafficAccounting.class), mock(MessagesAdapter.class), mock(ProcessingStatusRecorder.class)),\n                 mock(NodeId.class),\n                 new NullAuditEventSender(),\n-                new EventBus(\"index-field-type-poller-it\"));\n+                new EventBus(\"index-field-type-poller-it\"),\n+                createIndicesAdapter()\n+        );", "originalCommit": "5bcdb7e9c5161d634460372c5fa94ff2e2657e67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MjE3Ng==", "url": "https://github.com/Graylog2/graylog2-server/pull/8225#discussion_r435852176", "bodyText": "We should update the link here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-update-settings.html\n          \n          \n            \n                    // https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-update-settings.html", "author": "alex-konn", "createdAt": "2020-06-05T11:10:27Z", "path": "graylog-storage-elasticsearch6/src/main/java/org/graylog/storage/elasticsearch6/IndicesAdapterES6.java", "diffHunk": "@@ -0,0 +1,641 @@\n+package org.graylog.storage.elasticsearch6;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterators;\n+import com.google.common.primitives.Ints;\n+import io.searchbox.client.JestClient;\n+import io.searchbox.client.JestResult;\n+import io.searchbox.cluster.Health;\n+import io.searchbox.cluster.State;\n+import io.searchbox.core.Bulk;\n+import io.searchbox.core.BulkResult;\n+import io.searchbox.core.Cat;\n+import io.searchbox.core.CatResult;\n+import io.searchbox.core.Search;\n+import io.searchbox.core.SearchResult;\n+import io.searchbox.core.SearchScroll;\n+import io.searchbox.core.search.aggregation.FilterAggregation;\n+import io.searchbox.core.search.aggregation.MaxAggregation;\n+import io.searchbox.core.search.aggregation.MinAggregation;\n+import io.searchbox.core.search.aggregation.TermsAggregation;\n+import io.searchbox.indices.CloseIndex;\n+import io.searchbox.indices.CreateIndex;\n+import io.searchbox.indices.DeleteIndex;\n+import io.searchbox.indices.Flush;\n+import io.searchbox.indices.ForceMerge;\n+import io.searchbox.indices.OpenIndex;\n+import io.searchbox.indices.Stats;\n+import io.searchbox.indices.aliases.AddAliasMapping;\n+import io.searchbox.indices.aliases.AliasMapping;\n+import io.searchbox.indices.aliases.GetAliases;\n+import io.searchbox.indices.aliases.ModifyAliases;\n+import io.searchbox.indices.aliases.RemoveAliasMapping;\n+import io.searchbox.indices.settings.GetSettings;\n+import io.searchbox.indices.settings.UpdateSettings;\n+import io.searchbox.indices.template.DeleteTemplate;\n+import io.searchbox.indices.template.PutTemplate;\n+import io.searchbox.params.Parameters;\n+import io.searchbox.params.SearchType;\n+import org.apache.http.client.config.RequestConfig;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortBuilders;\n+import org.graylog2.indexer.ElasticsearchException;\n+import org.graylog2.indexer.IndexMapping;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.cluster.jest.JestUtils;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.jackson.TypeReferences;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.elasticsearch.search.builder.SearchSourceBuilder.searchSource;\n+\n+public class IndicesAdapterES6 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES6.class);\n+    private final JestClient jestClient;\n+    private final ObjectMapper objectMapper;\n+    private final IndexingHelper indexingHelper;\n+\n+    @Inject\n+    public IndicesAdapterES6(JestClient jestClient, ObjectMapper objectMapper, IndexingHelper indexingHelper) {\n+        this.jestClient = jestClient;\n+        this.objectMapper = objectMapper;\n+        this.indexingHelper = indexingHelper;\n+    }\n+\n+    @Override\n+    public void move(String source, String target, Consumer<IndexMoveResult> resultCallback) {\n+        // TODO: This method should use the Re-index API: https://www.elastic.co/guide/en/elasticsearch/reference/5.3/docs-reindex.html\n+        final String query = SearchSourceBuilder.searchSource()\n+                .query(QueryBuilders.matchAllQuery())\n+                .size(350)\n+                .sort(SortBuilders.fieldSort(FieldSortBuilder.DOC_FIELD_NAME))\n+                .toString();\n+\n+        final Search request = new Search.Builder(query)\n+                .setParameter(Parameters.SCROLL, \"10s\")\n+                .addIndex(source)\n+                .build();\n+\n+        final SearchResult searchResult = JestUtils.execute(jestClient, request, () -> \"Couldn't process search query response\");\n+\n+        final String scrollId = searchResult.getJsonObject().path(\"_scroll_id\").asText(null);\n+        if (scrollId == null) {\n+            throw new ElasticsearchException(\"Couldn't find scroll ID in search query response\");\n+        }\n+\n+        while (true) {\n+            final SearchScroll scrollRequest = new SearchScroll.Builder(scrollId, \"1m\").build();\n+            final JestResult scrollResult = JestUtils.execute(jestClient, scrollRequest, () -> \"Couldn't process result of scroll query\");\n+            final JsonNode scrollHits = scrollResult.getJsonObject().path(\"hits\").path(\"hits\");\n+\n+            // No more hits.\n+            if (scrollHits.size() == 0) {\n+                break;\n+            }\n+\n+            final Bulk.Builder bulkRequestBuilder = new Bulk.Builder();\n+            for (JsonNode jsonElement : scrollHits) {\n+                final Map<String, Object> doc = Optional.ofNullable(jsonElement.path(\"_source\"))\n+                        .map(sourceJson -> objectMapper.<Map<String, Object>>convertValue(sourceJson, TypeReferences.MAP_STRING_OBJECT))\n+                        .orElse(Collections.emptyMap());\n+                final String id = (String) doc.remove(\"_id\");\n+\n+                bulkRequestBuilder.addAction(indexingHelper.prepareIndexRequest(target, doc, id));\n+            }\n+\n+            final BulkResult bulkResult = JestUtils.execute(jestClient, bulkRequestBuilder.build(), () -> \"Couldn't bulk index messages into index \" + target);\n+\n+            final boolean hasFailedItems = !bulkResult.getFailedItems().isEmpty();\n+            final IndexMoveResult result = IndexMoveResult.create(bulkResult.getItems().size(), bulkResult.getJsonObject().path(\"took\").asLong(), hasFailedItems);\n+            resultCallback.accept(result);\n+        }\n+    }\n+\n+    @Override\n+    public void delete(String indexName) {\n+        JestUtils.execute(jestClient, new DeleteIndex.Builder(indexName).build(), () -> \"Couldn't delete index \" + indexName);\n+    }\n+\n+    @Override\n+    public Set<String> resolveAlias(String alias) {\n+        // TODO: This is basically getting all indices and later we filter out the alias we want to check for.\n+        //       This can be done in a more efficient way by either using the /_cat/aliases/<alias-name> API or\n+        //       the regular /_alias/<alias-name> API.\n+        final GetAliases request = new GetAliases.Builder().build();\n+        final JestResult jestResult = JestUtils.execute(jestClient, request, () -> \"Couldn't collect indices for alias \" + alias);\n+\n+        // The ES return value of this has an awkward format: The first key of the hash is the target index. Thanks.\n+        final ImmutableSet.Builder<String> indicesBuilder = ImmutableSet.builder();\n+        final Iterator<Map.Entry<String, JsonNode>> it = jestResult.getJsonObject().fields();\n+        while (it.hasNext()) {\n+            Map.Entry<String, JsonNode> entry = it.next();\n+            final String indexName = entry.getKey();\n+            Optional.of(entry.getValue())\n+                    .map(json -> json.path(\"aliases\"))\n+                    .map(JsonNode::fields)\n+                    .map(ImmutableList::copyOf)\n+                    .filter(aliases -> !aliases.isEmpty())\n+                    .filter(aliases -> aliases.stream().anyMatch(aliasEntry -> aliasEntry.getKey().equals(alias)))\n+                    .ifPresent(x -> indicesBuilder.add(indexName));\n+        }\n+\n+        return indicesBuilder.build();\n+    }\n+\n+    @Override\n+    public void create(String indexName, IndexSettings indexSettings, String templateName, Map<String, Object> template) {\n+        final Map<String, Object> settings = new HashMap<>();\n+        settings.put(\"number_of_shards\", indexSettings.shards());\n+        settings.put(\"number_of_replicas\", indexSettings.replicas());\n+\n+        final CreateIndex request = new CreateIndex.Builder(indexName)\n+                .settings(settings)\n+                .build();\n+\n+        // Make sure our index template exists before creating an index!\n+        ensureIndexTemplate(templateName, template);\n+\n+        final JestResult jestResult;\n+        try {\n+            jestResult = jestClient.execute(request);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"Couldn't create index \" + indexName, e);\n+        }\n+\n+        if (!jestResult.isSucceeded()){\n+            throw new ElasticsearchException(jestResult.getErrorMessage());\n+        }\n+    }\n+\n+    @Override\n+    public boolean ensureIndexTemplate(String templateName, Map<String, Object> template) {\n+        final PutTemplate request = new PutTemplate.Builder(templateName, template).build();\n+\n+        final JestResult jestResult = JestUtils.execute(jestClient, request, () -> \"Unable to create index template \" + templateName);\n+        return jestResult.isSucceeded();\n+    }\n+\n+    @Override\n+    public Optional<DateTime> indexCreationDate(String index) {\n+        final GetSettings request = new GetSettings.Builder()\n+                .addIndex(index)\n+                .ignoreUnavailable(true)\n+                .build();\n+        final JestResult jestResult = JestUtils.execute(jestClient, request, () -> \"Couldn't read settings of index \" + index);\n+\n+        return Optional.of(jestResult.getJsonObject().path(index).path(\"settings\").path(\"index\").path(\"creation_date\"))\n+                .filter(JsonNode::isValueNode)\n+                .map(JsonNode::asLong)\n+                .map(creationDate -> new DateTime(creationDate, DateTimeZone.UTC));\n+    }\n+\n+    @Override\n+    public void openIndex(String index) {\n+        JestUtils.execute(jestClient, new OpenIndex.Builder(index).build(), () -> \"Couldn't open index \" + index);\n+    }\n+\n+    @Override\n+    public void setReadOnly(String index) {\n+        // https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-update-settings.html", "originalCommit": "5bcdb7e9c5161d634460372c5fa94ff2e2657e67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1Njg2OQ==", "url": "https://github.com/Graylog2/graylog2-server/pull/8225#discussion_r435856869", "bodyText": "While we're at it, we should suppress the warning about the parameter value always being YELLOW\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Health.Status waitForStatus(String index, Health.Status clusterHealthStatus) {\n          \n          \n            \n                private Health.Status waitForStatus(String index, @SuppressWarnings(\"SameParameterValue\") Health.Status clusterHealthStatus) {", "author": "alex-konn", "createdAt": "2020-06-05T11:21:30Z", "path": "graylog-storage-elasticsearch6/src/main/java/org/graylog/storage/elasticsearch6/IndicesAdapterES6.java", "diffHunk": "@@ -0,0 +1,641 @@\n+package org.graylog.storage.elasticsearch6;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterators;\n+import com.google.common.primitives.Ints;\n+import io.searchbox.client.JestClient;\n+import io.searchbox.client.JestResult;\n+import io.searchbox.cluster.Health;\n+import io.searchbox.cluster.State;\n+import io.searchbox.core.Bulk;\n+import io.searchbox.core.BulkResult;\n+import io.searchbox.core.Cat;\n+import io.searchbox.core.CatResult;\n+import io.searchbox.core.Search;\n+import io.searchbox.core.SearchResult;\n+import io.searchbox.core.SearchScroll;\n+import io.searchbox.core.search.aggregation.FilterAggregation;\n+import io.searchbox.core.search.aggregation.MaxAggregation;\n+import io.searchbox.core.search.aggregation.MinAggregation;\n+import io.searchbox.core.search.aggregation.TermsAggregation;\n+import io.searchbox.indices.CloseIndex;\n+import io.searchbox.indices.CreateIndex;\n+import io.searchbox.indices.DeleteIndex;\n+import io.searchbox.indices.Flush;\n+import io.searchbox.indices.ForceMerge;\n+import io.searchbox.indices.OpenIndex;\n+import io.searchbox.indices.Stats;\n+import io.searchbox.indices.aliases.AddAliasMapping;\n+import io.searchbox.indices.aliases.AliasMapping;\n+import io.searchbox.indices.aliases.GetAliases;\n+import io.searchbox.indices.aliases.ModifyAliases;\n+import io.searchbox.indices.aliases.RemoveAliasMapping;\n+import io.searchbox.indices.settings.GetSettings;\n+import io.searchbox.indices.settings.UpdateSettings;\n+import io.searchbox.indices.template.DeleteTemplate;\n+import io.searchbox.indices.template.PutTemplate;\n+import io.searchbox.params.Parameters;\n+import io.searchbox.params.SearchType;\n+import org.apache.http.client.config.RequestConfig;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortBuilders;\n+import org.graylog2.indexer.ElasticsearchException;\n+import org.graylog2.indexer.IndexMapping;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.cluster.jest.JestUtils;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.jackson.TypeReferences;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.elasticsearch.search.builder.SearchSourceBuilder.searchSource;\n+\n+public class IndicesAdapterES6 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES6.class);\n+    private final JestClient jestClient;\n+    private final ObjectMapper objectMapper;\n+    private final IndexingHelper indexingHelper;\n+\n+    @Inject\n+    public IndicesAdapterES6(JestClient jestClient, ObjectMapper objectMapper, IndexingHelper indexingHelper) {\n+        this.jestClient = jestClient;\n+        this.objectMapper = objectMapper;\n+        this.indexingHelper = indexingHelper;\n+    }\n+\n+    @Override\n+    public void move(String source, String target, Consumer<IndexMoveResult> resultCallback) {\n+        // TODO: This method should use the Re-index API: https://www.elastic.co/guide/en/elasticsearch/reference/5.3/docs-reindex.html\n+        final String query = SearchSourceBuilder.searchSource()\n+                .query(QueryBuilders.matchAllQuery())\n+                .size(350)\n+                .sort(SortBuilders.fieldSort(FieldSortBuilder.DOC_FIELD_NAME))\n+                .toString();\n+\n+        final Search request = new Search.Builder(query)\n+                .setParameter(Parameters.SCROLL, \"10s\")\n+                .addIndex(source)\n+                .build();\n+\n+        final SearchResult searchResult = JestUtils.execute(jestClient, request, () -> \"Couldn't process search query response\");\n+\n+        final String scrollId = searchResult.getJsonObject().path(\"_scroll_id\").asText(null);\n+        if (scrollId == null) {\n+            throw new ElasticsearchException(\"Couldn't find scroll ID in search query response\");\n+        }\n+\n+        while (true) {\n+            final SearchScroll scrollRequest = new SearchScroll.Builder(scrollId, \"1m\").build();\n+            final JestResult scrollResult = JestUtils.execute(jestClient, scrollRequest, () -> \"Couldn't process result of scroll query\");\n+            final JsonNode scrollHits = scrollResult.getJsonObject().path(\"hits\").path(\"hits\");\n+\n+            // No more hits.\n+            if (scrollHits.size() == 0) {\n+                break;\n+            }\n+\n+            final Bulk.Builder bulkRequestBuilder = new Bulk.Builder();\n+            for (JsonNode jsonElement : scrollHits) {\n+                final Map<String, Object> doc = Optional.ofNullable(jsonElement.path(\"_source\"))\n+                        .map(sourceJson -> objectMapper.<Map<String, Object>>convertValue(sourceJson, TypeReferences.MAP_STRING_OBJECT))\n+                        .orElse(Collections.emptyMap());\n+                final String id = (String) doc.remove(\"_id\");\n+\n+                bulkRequestBuilder.addAction(indexingHelper.prepareIndexRequest(target, doc, id));\n+            }\n+\n+            final BulkResult bulkResult = JestUtils.execute(jestClient, bulkRequestBuilder.build(), () -> \"Couldn't bulk index messages into index \" + target);\n+\n+            final boolean hasFailedItems = !bulkResult.getFailedItems().isEmpty();\n+            final IndexMoveResult result = IndexMoveResult.create(bulkResult.getItems().size(), bulkResult.getJsonObject().path(\"took\").asLong(), hasFailedItems);\n+            resultCallback.accept(result);\n+        }\n+    }\n+\n+    @Override\n+    public void delete(String indexName) {\n+        JestUtils.execute(jestClient, new DeleteIndex.Builder(indexName).build(), () -> \"Couldn't delete index \" + indexName);\n+    }\n+\n+    @Override\n+    public Set<String> resolveAlias(String alias) {\n+        // TODO: This is basically getting all indices and later we filter out the alias we want to check for.\n+        //       This can be done in a more efficient way by either using the /_cat/aliases/<alias-name> API or\n+        //       the regular /_alias/<alias-name> API.\n+        final GetAliases request = new GetAliases.Builder().build();\n+        final JestResult jestResult = JestUtils.execute(jestClient, request, () -> \"Couldn't collect indices for alias \" + alias);\n+\n+        // The ES return value of this has an awkward format: The first key of the hash is the target index. Thanks.\n+        final ImmutableSet.Builder<String> indicesBuilder = ImmutableSet.builder();\n+        final Iterator<Map.Entry<String, JsonNode>> it = jestResult.getJsonObject().fields();\n+        while (it.hasNext()) {\n+            Map.Entry<String, JsonNode> entry = it.next();\n+            final String indexName = entry.getKey();\n+            Optional.of(entry.getValue())\n+                    .map(json -> json.path(\"aliases\"))\n+                    .map(JsonNode::fields)\n+                    .map(ImmutableList::copyOf)\n+                    .filter(aliases -> !aliases.isEmpty())\n+                    .filter(aliases -> aliases.stream().anyMatch(aliasEntry -> aliasEntry.getKey().equals(alias)))\n+                    .ifPresent(x -> indicesBuilder.add(indexName));\n+        }\n+\n+        return indicesBuilder.build();\n+    }\n+\n+    @Override\n+    public void create(String indexName, IndexSettings indexSettings, String templateName, Map<String, Object> template) {\n+        final Map<String, Object> settings = new HashMap<>();\n+        settings.put(\"number_of_shards\", indexSettings.shards());\n+        settings.put(\"number_of_replicas\", indexSettings.replicas());\n+\n+        final CreateIndex request = new CreateIndex.Builder(indexName)\n+                .settings(settings)\n+                .build();\n+\n+        // Make sure our index template exists before creating an index!\n+        ensureIndexTemplate(templateName, template);\n+\n+        final JestResult jestResult;\n+        try {\n+            jestResult = jestClient.execute(request);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"Couldn't create index \" + indexName, e);\n+        }\n+\n+        if (!jestResult.isSucceeded()){\n+            throw new ElasticsearchException(jestResult.getErrorMessage());\n+        }\n+    }\n+\n+    @Override\n+    public boolean ensureIndexTemplate(String templateName, Map<String, Object> template) {\n+        final PutTemplate request = new PutTemplate.Builder(templateName, template).build();\n+\n+        final JestResult jestResult = JestUtils.execute(jestClient, request, () -> \"Unable to create index template \" + templateName);\n+        return jestResult.isSucceeded();\n+    }\n+\n+    @Override\n+    public Optional<DateTime> indexCreationDate(String index) {\n+        final GetSettings request = new GetSettings.Builder()\n+                .addIndex(index)\n+                .ignoreUnavailable(true)\n+                .build();\n+        final JestResult jestResult = JestUtils.execute(jestClient, request, () -> \"Couldn't read settings of index \" + index);\n+\n+        return Optional.of(jestResult.getJsonObject().path(index).path(\"settings\").path(\"index\").path(\"creation_date\"))\n+                .filter(JsonNode::isValueNode)\n+                .map(JsonNode::asLong)\n+                .map(creationDate -> new DateTime(creationDate, DateTimeZone.UTC));\n+    }\n+\n+    @Override\n+    public void openIndex(String index) {\n+        JestUtils.execute(jestClient, new OpenIndex.Builder(index).build(), () -> \"Couldn't open index \" + index);\n+    }\n+\n+    @Override\n+    public void setReadOnly(String index) {\n+        // https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-update-settings.html\n+        final Map<String, Object> settings = ImmutableMap.of(\n+                \"index\", ImmutableMap.of(\"blocks\",\n+                        ImmutableMap.of(\n+                                \"write\", true, // Block writing.\n+                                \"read\", false, // Allow reading.\n+                                \"metadata\", false) // Allow getting metadata.\n+                )\n+        );\n+\n+        final UpdateSettings request = new UpdateSettings.Builder(settings).addIndex(index).build();\n+        JestUtils.execute(jestClient, request, () -> \"Couldn't set index \" + index + \" to read-only\");\n+    }\n+\n+    @Override\n+    public void flush(String index) {\n+        JestUtils.execute(jestClient, new Flush.Builder().addIndex(index).force().build(), () -> \"Couldn't flush index \" + index);\n+    }\n+\n+    @Override\n+    public String markIndexReopened(String index) {\n+        final String aliasName = index + Indices.REOPENED_ALIAS_SUFFIX;\n+        final ModifyAliases request = new ModifyAliases.Builder(new AddAliasMapping.Builder(index, aliasName).build()).build();\n+\n+        JestUtils.execute(jestClient, request, () -> \"Couldn't create reopened alias for index \" + index);\n+\n+        return aliasName;\n+    }\n+\n+    @Override\n+    public void removeAlias(String indexName, String alias) {\n+        JestUtils.execute(jestClient,\n+                new ModifyAliases.Builder(new RemoveAliasMapping.Builder(indexName, alias).build()).build(),\n+                () -> \"Couldn't remove reopened alias for index \" + indexName + \" before closing.\");\n+    }\n+\n+    @Override\n+    public void removeAliases(Set<String> indices, String alias) {\n+        final AliasMapping removeAliasMapping = new RemoveAliasMapping.Builder(ImmutableList.copyOf(indices), alias).build();\n+        final ModifyAliases request = new ModifyAliases.Builder(removeAliasMapping).build();\n+        JestUtils.execute(jestClient, request, () -> \"Couldn't remove alias \" + alias + \" from indices \" + indices);\n+    }\n+\n+    @Override\n+    public void optimizeIndex(String index, int maxNumSegments, Duration timeout) {\n+        final RequestConfig requestConfig = RequestConfig.custom()\n+                .setSocketTimeout(Ints.saturatedCast(timeout.toMilliseconds()))\n+                .build();\n+\n+        final ForceMerge request = new ForceMerge.Builder()\n+                .addIndex(index)\n+                .maxNumSegments(maxNumSegments)\n+                .flush(true)\n+                .onlyExpungeDeletes(false)\n+                .build();\n+\n+        JestUtils.execute(jestClient, requestConfig, request, () -> \"Couldn't force merge index \" + index);\n+    }\n+\n+    @Override\n+    public IndexRangeStats indexRangeStatsOfIndex(String index) {\n+        final FilterAggregationBuilder builder = AggregationBuilders.filter(\"agg\", QueryBuilders.existsQuery(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.min(\"ts_min\").field(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.max(\"ts_max\").field(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.terms(\"streams\").size(Integer.MAX_VALUE).field(Message.FIELD_STREAMS));\n+        final String query = searchSource()\n+                .aggregation(builder)\n+                .size(0)\n+                .toString();\n+\n+        final Search request = new Search.Builder(query)\n+                .addIndex(index)\n+                .setSearchType(SearchType.DFS_QUERY_THEN_FETCH)\n+                .ignoreUnavailable(true)\n+                .build();\n+\n+        if (LOG.isDebugEnabled()) {\n+            String data = \"{}\";\n+            try {\n+                data = request.getData(objectMapper.copy().enable(SerializationFeature.INDENT_OUTPUT));\n+            } catch (IOException e) {\n+                LOG.debug(\"Couldn't pretty print request payload\", e);\n+            }\n+            LOG.debug(\"Index range query: _search/{}: {}\", index, data);\n+        }\n+\n+        final SearchResult result = JestUtils.execute(jestClient, request, () -> \"Couldn't build index range of index \" + index);\n+\n+        final FilterAggregation f = result.getAggregations().getFilterAggregation(\"agg\");\n+        if (f == null) {\n+            throw new IndexNotFoundException(\"Couldn't build index range of index \" + index + \" because it doesn't exist.\");\n+        } else if (f.getCount() == 0L) {\n+            LOG.debug(\"No documents with attribute \\\"timestamp\\\" found in index <{}>\", index);\n+            return IndexRangeStats.EMPTY;\n+        }\n+\n+        final MinAggregation minAgg = f.getMinAggregation(\"ts_min\");\n+        final DateTime min = new DateTime(minAgg.getMin().longValue(), DateTimeZone.UTC);\n+        final MaxAggregation maxAgg = f.getMaxAggregation(\"ts_max\");\n+        final DateTime max = new DateTime(maxAgg.getMax().longValue(), DateTimeZone.UTC);\n+        // make sure we return an empty list, so we can differentiate between old indices that don't have this information\n+        // and newer ones that simply have no streams.\n+        final TermsAggregation streams = f.getTermsAggregation(\"streams\");\n+        final List<String> streamIds = streams.getBuckets().stream()\n+                .map(TermsAggregation.Entry::getKeyAsString)\n+                .collect(toList());\n+\n+\n+        return IndexRangeStats.create(min, max, streamIds);\n+    }\n+\n+    @Override\n+    public HealthStatus waitForRecovery(String index) {\n+        final Health.Status status = waitForStatus(index, Health.Status.YELLOW);\n+        return mapHealthStatus(status);\n+    }\n+\n+    private HealthStatus mapHealthStatus(Health.Status status) {\n+        switch (status) {\n+            case RED: return HealthStatus.Red;\n+            case YELLOW: return HealthStatus.Yellow;\n+            case GREEN: return HealthStatus.Green;\n+            default: throw new IllegalStateException(\"Unexpected cluster status: \" + status);\n+        }\n+    }\n+\n+    private Health.Status waitForStatus(String index, Health.Status clusterHealthStatus) {", "originalCommit": "5bcdb7e9c5161d634460372c5fa94ff2e2657e67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c74b93fa2f77c282b80e1e3d9ff629f49d557c4", "url": "https://github.com/Graylog2/graylog2-server/commit/7c74b93fa2f77c282b80e1e3d9ff629f49d557c4", "message": "Addressing very fine remarks from @alex-konn.", "committedDate": "2020-06-05T12:40:45Z", "type": "commit"}, {"oid": "872a0b818b06d928ce56627ef0b57b265ddcd0ba", "url": "https://github.com/Graylog2/graylog2-server/commit/872a0b818b06d928ce56627ef0b57b265ddcd0ba", "message": "Making method private.", "committedDate": "2020-06-05T12:42:27Z", "type": "commit"}]}