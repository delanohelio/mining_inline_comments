{"pr_number": 227, "pr_title": "Basic implementation of the StdIO extension for catching stdin/out", "pr_createdAt": "2020-04-12T21:53:18Z", "pr_url": "https://github.com/junit-pioneer/junit-pioneer/pull/227", "timeline": [{"oid": "0f60bf71ae275cc3d6c150220e3631e36a088512", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0f60bf71ae275cc3d6c150220e3631e36a088512", "message": "Basic implementation of the StdIO extension for catching stdin/out", "committedDate": "2020-04-12T21:51:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwMTEwMA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r410401100", "bodyText": "Javadoc already helps while developing and requesting other peoples feedback ;)", "author": "Bukama", "createdAt": "2020-04-17T18:34:04Z", "path": "src/main/java/org/junitpioneer/jupiter/Std.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+", "originalCommit": "0f60bf71ae275cc3d6c150220e3631e36a088512", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MDEzMA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411260130", "bodyText": "You are right, sorry. \ud83d\ude10\nI added javadoc.", "author": "Michael1993", "createdAt": "2020-04-20T10:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwMTEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMTAwMA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r410411000", "bodyText": "Can this be written as a loop? Without the test case I would have not known why those lines are doubled", "author": "Bukama", "createdAt": "2020-04-17T18:54:05Z", "path": "src/test/java/org/junitpioneer/jupiter/StdIoExtensionTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junitpioneer.jupiter.StdIOExtension.StdIn;\n+import org.junitpioneer.jupiter.StdIOExtension.StdOut;\n+\n+@ExtendWith(StdIOExtension.class)\n+public class StdIoExtensionTest {\n+\n+\tBasicCommandLineApp app = new BasicCommandLineApp();\n+\n+\t@Test\n+\t@DisplayName(\"catches the output on the standard out\")\n+\tvoid catchesOut(@Std StdOut out) {\n+\t\tapp.multiline();\n+\t\tassertThat(out.linesArray()).containsExactly(\"Hello\", \"World!\");\n+\t}\n+\n+\t@Test\n+\t@DisplayName(\"catches the input from the standard in\")\n+\tvoid catchesIn(@Std({ \"Hello\", \"World!\" }) StdIn in, @Std StdOut out) throws IOException {\n+\t\tapp.readAndWrite();\n+\t\tassertThat(in.linesArray()).containsExactly(\"Hello\", \"World!\");\n+\t\tassertThat(out.linesArray()).containsExactly(\"Hello\", \"World!\");\n+\t}\n+\n+\t/**\n+\t * A sample class that I would write tests for.\n+\t */\n+\tprivate static class BasicCommandLineApp {\n+\n+\t\tpublic void multiline() {\n+\t\t\tSystem.out.println(\"Hello\");\n+\t\t\tSystem.out.println(\"World!\");\n+\t\t}\n+\n+\t\tpublic void readAndWrite() throws IOException {\n+\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n+\t\t\tString read = reader.readLine();\n+\t\t\tSystem.out.println(read);\n+\t\t\tread = reader.readLine();\n+\t\t\tSystem.out.println(read);", "originalCommit": "0f60bf71ae275cc3d6c150220e3631e36a088512", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MTIxMw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411261213", "bodyText": "I would not write this as a loop because that would add unneeded complexity. Since this is only for testing purposes (never executed directly), I think it should be fine.", "author": "Michael1993", "createdAt": "2020-04-20T10:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMTAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxNzUyMg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r410417522", "bodyText": "Would name this capturedLines", "author": "Bukama", "createdAt": "2020-04-17T19:07:58Z", "path": "src/main/java/org/junitpioneer/jupiter/StdIOExtension.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.ParameterContext;\n+import org.junit.jupiter.api.extension.ParameterResolutionException;\n+import org.junit.jupiter.api.extension.ParameterResolver;\n+\n+public class StdIOExtension implements ParameterResolver {\n+\n+\tprivate static final String SEPARATOR = System.getProperty(\"line.separator\");\n+\n+\t@Override\n+\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)\n+\t\t\tthrows ParameterResolutionException {\n+\t\treturn parameterContext.isAnnotated(Std.class);\n+\t}\n+\n+\t@Override\n+\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)\n+\t\t\tthrows ParameterResolutionException {\n+\t\tClass<?> parameterType = parameterContext.getParameter().getType();\n+\t\tif (parameterType == StdOut.class) {\n+\t\t\treturn new StdOut();\n+\t\t}\n+\t\tif (parameterType == StdIn.class) {\n+\t\t\tStd std = parameterContext\n+\t\t\t\t\t.findAnnotation(Std.class)\n+\t\t\t\t\t.orElseThrow(() -> new ParameterResolutionException(\"Needs to be annotated with Std\"));\n+\t\t\treturn new StdIn(std.value());\n+\t\t}\n+\t\tthrow new ParameterResolutionException(\"Can only resolve parameter of type \" + StdOut.class.getName() + \" or \"\n+\t\t\t\t+ StdIn.class.getName() + \" but was: \" + parameterType.getName());\n+\n+\t}\n+\n+\tpublic static class StdOut extends OutputStream {\n+\n+\t\tStringWriter writer = new StringWriter();\n+\n+\t\tpublic StdOut() {\n+\t\t\tSystem.setOut(new PrintStream(this));\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void write(int i) {\n+\t\t\twriter.write(i);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn writer.toString();\n+\t\t}\n+\n+\t\tpublic String[] linesArray() {\n+\t\t\treturn this.toString().split(SEPARATOR);\n+\t\t}\n+\n+\t}\n+\n+\tpublic static class StdIn extends InputStream {\n+\n+\t\tStringReader reader;\n+\t\tStringWriter writer = new StringWriter();\n+\n+\t\tpublic StdIn(String... values) {\n+\t\t\treader = new StringReader(String.join(SEPARATOR, values));\n+\t\t\tSystem.setIn(this);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int read() throws IOException {\n+\t\t\tint reading = reader.read();\n+\t\t\tif (reading != -1) {\n+\t\t\t\twriter.write(reading);\n+\t\t\t}\n+\t\t\treturn reading;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn writer.toString();\n+\t\t}\n+\n+\t\tpublic String[] linesArray() {", "originalCommit": "0f60bf71ae275cc3d6c150220e3631e36a088512", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI1OTU4NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411259584", "bodyText": "Thank you, sounds good.", "author": "Michael1993", "createdAt": "2020-04-20T10:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxNzUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxNzYzNA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r410417634", "bodyText": "Would name this capturedLines", "author": "Bukama", "createdAt": "2020-04-17T19:08:12Z", "path": "src/main/java/org/junitpioneer/jupiter/StdIOExtension.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.ParameterContext;\n+import org.junit.jupiter.api.extension.ParameterResolutionException;\n+import org.junit.jupiter.api.extension.ParameterResolver;\n+\n+public class StdIOExtension implements ParameterResolver {\n+\n+\tprivate static final String SEPARATOR = System.getProperty(\"line.separator\");\n+\n+\t@Override\n+\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)\n+\t\t\tthrows ParameterResolutionException {\n+\t\treturn parameterContext.isAnnotated(Std.class);\n+\t}\n+\n+\t@Override\n+\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)\n+\t\t\tthrows ParameterResolutionException {\n+\t\tClass<?> parameterType = parameterContext.getParameter().getType();\n+\t\tif (parameterType == StdOut.class) {\n+\t\t\treturn new StdOut();\n+\t\t}\n+\t\tif (parameterType == StdIn.class) {\n+\t\t\tStd std = parameterContext\n+\t\t\t\t\t.findAnnotation(Std.class)\n+\t\t\t\t\t.orElseThrow(() -> new ParameterResolutionException(\"Needs to be annotated with Std\"));\n+\t\t\treturn new StdIn(std.value());\n+\t\t}\n+\t\tthrow new ParameterResolutionException(\"Can only resolve parameter of type \" + StdOut.class.getName() + \" or \"\n+\t\t\t\t+ StdIn.class.getName() + \" but was: \" + parameterType.getName());\n+\n+\t}\n+\n+\tpublic static class StdOut extends OutputStream {\n+\n+\t\tStringWriter writer = new StringWriter();\n+\n+\t\tpublic StdOut() {\n+\t\t\tSystem.setOut(new PrintStream(this));\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void write(int i) {\n+\t\t\twriter.write(i);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn writer.toString();\n+\t\t}\n+\n+\t\tpublic String[] linesArray() {", "originalCommit": "0f60bf71ae275cc3d6c150220e3631e36a088512", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIzNDUxNw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411234517", "bodyText": "Good idea. Thank you.", "author": "Michael1993", "createdAt": "2020-04-20T09:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxNzYzNA=="}], "type": "inlineReview"}, {"oid": "c41e7ee879582124536ac4fc9de254496db240d1", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c41e7ee879582124536ac4fc9de254496db240d1", "message": "Working commit, should be squashed", "committedDate": "2020-04-20T08:55:05Z", "type": "commit"}, {"oid": "432d5ada913d1a870197dc95f8519dc439234b2c", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/432d5ada913d1a870197dc95f8519dc439234b2c", "message": "Merge branch 'master' of https://github.com/junit-pioneer/junit-pioneer into std-io", "committedDate": "2020-04-20T08:55:18Z", "type": "commit"}, {"oid": "b039c437e793c9e1a60c96f0f130e8d7e310a015", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b039c437e793c9e1a60c96f0f130e8d7e310a015", "message": "Added configuration tests, implemented suggestions", "committedDate": "2020-04-20T14:14:29Z", "type": "commit"}, {"oid": "6165f7cdeb02e73f3296e71207854d9da8266f12", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6165f7cdeb02e73f3296e71207854d9da8266f12", "message": "Revert ReportEntry typo because it's not in scope", "committedDate": "2020-04-20T14:39:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2NjY5Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411466697", "bodyText": "I see you've took my idea of calling it Interceptor - but why cutting the last two character then?", "author": "Bukama", "createdAt": "2020-04-20T15:21:48Z", "path": "src/main/java/org/junitpioneer/jupiter/StdIntercept.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+/**\n+ * Intercept communication on the standard input/output,\n+ * to verify behaviour. This should be used with\n+ * {@link org.junitpioneer.jupiter.StdIOExtension.StdOut}\n+ * to intercept the standard output ({@code System.in}) and\n+ * {@link org.junitpioneer.jupiter.StdIOExtension.StdIn}\n+ * to intercept the standard input ({@code System.out}).\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface StdIntercept {", "originalCommit": "6165f7cdeb02e73f3296e71207854d9da8266f12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5MDgxNQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411590815", "bodyText": "I try to name everything in my code so it looks like written language when in context. For example here, StdInterceptor looks better, but if you read the test it becomes:\n@StdIntercept StdIn in - which is saying (to me) intercept StdIn with the variable in.\nTo be honest, I originally wanted to rename this annotation just @Intercept but that looks too general (if that makes sense).", "author": "Michael1993", "createdAt": "2020-04-20T18:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2NjY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk5ODgwNg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411998806", "bodyText": "The annotation is unnecessary for resolving StdOut and StdIn could use a method level annotation instead for getting its parameters, for example: @StdInSource. Would that be simpler?", "author": "Michael1993", "createdAt": "2020-04-21T08:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2NjY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5OTg4NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r412299884", "bodyText": "The annotation is unnecessary for resolving StdOut and StdIn could use a method level annotation instead for getting its parameters, for example: @StdInSource. Would that be simpler?\n\nThe missing need for StdOut should be documented in the final adoc !", "author": "Bukama", "createdAt": "2020-04-21T16:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2NjY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk3NDE4Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r414974183", "bodyText": "This was changed and documented.", "author": "Michael1993", "createdAt": "2020-04-25T04:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2NjY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2NzIzMQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411467231", "bodyText": "Since JUnit5 assertThrows should be used, when exceptions are expected. While this method itself can hold the expected exception I personal like to use an super class here and to check for the exception type later using AssertJ. Taking this test as an example it would look like this:\nThrowable thrown = assertThrows(Throwable.class, () -> \n  // Call your system under test here\n  executeTestsForMethod(StdIOExtensionConfigurationTests.class, \"noAnnotation\");\n);\n\nString expectedMessage = \"No ParameterResolver registered\";\n\nassertThat(thrown).isExactlyInstanceOf(ParameterResolutionException.class);\nassertThat(thrown.getMessage()).startsWith(expectedMessage);", "author": "Bukama", "createdAt": "2020-04-20T15:22:31Z", "path": "src/test/java/org/junitpioneer/jupiter/StdIoExtensionTests.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ParameterResolutionException;\n+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;\n+import org.junitpioneer.jupiter.StdIOExtension.StdIn;\n+import org.junitpioneer.jupiter.StdIOExtension.StdOut;\n+\n+@ExtendWith(StdIOExtension.class)\n+@DisplayName(\"StdIOExtension \")\n+public class StdIoExtensionTests extends AbstractJupiterTestEngineTests {\n+\n+\tfinal BasicCommandLineApp app = new BasicCommandLineApp();\n+\n+\t@Nested\n+\t@DisplayName(\"with specific configuration \")\n+\tclass ConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"fails if parameter is not annotated with @StdIntercept\")\n+\t\tvoid needsAnnotation() {\n+\t\t\ttry {\n+\t\t\t\texecuteTestsForMethod(StdIOExtensionConfigurationTests.class, \"noAnnotation\");\n+\t\t\t}\n+\t\t\tcatch (ParameterResolutionException ex) {\n+\t\t\t\tassertThat(ex.getMessage()).startsWith(\"No ParameterResolver registered\");\n+\t\t\t}", "originalCommit": "6165f7cdeb02e73f3296e71207854d9da8266f12", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2ODg4NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411468884", "bodyText": "Minding liveticker ...the format looks very strange - do we have a general formatting problem here?...", "author": "Bukama", "createdAt": "2020-04-20T15:24:31Z", "path": "src/test/java/org/junitpioneer/jupiter/StdIoExtensionTests.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ParameterResolutionException;\n+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;\n+import org.junitpioneer.jupiter.StdIOExtension.StdIn;\n+import org.junitpioneer.jupiter.StdIOExtension.StdOut;\n+\n+@ExtendWith(StdIOExtension.class)\n+@DisplayName(\"StdIOExtension \")\n+public class StdIoExtensionTests extends AbstractJupiterTestEngineTests {\n+\n+\tfinal BasicCommandLineApp app = new BasicCommandLineApp();\n+\n+\t@Nested\n+\t@DisplayName(\"with specific configuration \")\n+\tclass ConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"fails if parameter is not annotated with @StdIntercept\")\n+\t\tvoid needsAnnotation() {\n+\t\t\ttry {\n+\t\t\t\texecuteTestsForMethod(StdIOExtensionConfigurationTests.class, \"noAnnotation\");\n+\t\t\t}\n+\t\t\tcatch (ParameterResolutionException ex) {\n+\t\t\t\tassertThat(ex.getMessage()).startsWith(\"No ParameterResolver registered\");\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"fails if the parameter type is not StdIn or StdOut\")\n+\t\tvoid needsType() {\n+\t\t\ttry {\n+\t\t\t\texecuteTestsForMethod(StdIOExtensionConfigurationTests.class, \"badType\");\n+\t\t\t}\n+\t\t\tcatch (ParameterResolutionException ex) {\n+\t\t\t\tassertThat(ex.getMessage()).contains(\"Can only resolve parameter\", \"but was\");\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"resolves parameter for correct type and annotation\")\n+\t\tvoid goodConfig() {\n+\t\t\tAssertions\n+\t\t\t\t\t.assertDoesNotThrow(\n+\t\t\t\t\t\t() -> executeTestsForMethod(StdIOExtensionConfigurationTests.class, \"goodConfig\"));\n+\t\t}", "originalCommit": "6165f7cdeb02e73f3296e71207854d9da8266f12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4MzcxNg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411483716", "bodyText": "This three tests explicitly check the annotation configuration. The first two are for no annotation and bad type - that's OK. But the last checks only for good configuration of StdIn. So there there is no explicit good configuration check for StdOut and therefore the related code is not covered by one of this configuration tests!\nAs of now StdOut is only indirectly covered by the later two for checking the captured lines. If you only want to check indirectly that you can remove the test of StdIn as it's checked by the later tests.\nI prefer to split the tests for checking the configuration and the output, so I suggest to add one for StdOut too.", "author": "Bukama", "createdAt": "2020-04-20T15:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2ODg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4NjA1Ng==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411486056", "bodyText": "Shall we move this to the PioneerAnnotationUtils in a generic way? Is it even possible?", "author": "Bukama", "createdAt": "2020-04-20T15:46:08Z", "path": "src/main/java/org/junitpioneer/jupiter/StdIOExtension.java", "diffHunk": "@@ -27,39 +29,42 @@\n \tprivate static final String SEPARATOR = System.getProperty(\"line.separator\");\n \n \t@Override\n-\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)\n-\t\t\tthrows ParameterResolutionException {\n-\t\treturn parameterContext.isAnnotated(Std.class);\n+\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n+\t\treturn parameterContext.isAnnotated(StdIntercept.class);\n \t}\n \n \t@Override\n-\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)\n-\t\t\tthrows ParameterResolutionException {\n+\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n \t\tClass<?> parameterType = parameterContext.getParameter().getType();\n+\t\tStdIntercept stdIntercept = getInterceptAnnotation(parameterContext);\n \t\tif (parameterType == StdOut.class) {\n \t\t\treturn new StdOut();\n \t\t}\n \t\tif (parameterType == StdIn.class) {\n-\t\t\tStd std = parameterContext\n-\t\t\t\t\t.findAnnotation(Std.class)\n-\t\t\t\t\t.orElseThrow(() -> new ParameterResolutionException(\"Needs to be annotated with Std\"));\n-\t\t\treturn new StdIn(std.value());\n+\t\t\treturn new StdIn(stdIntercept.value());\n \t\t}\n \t\tthrow new ParameterResolutionException(\"Can only resolve parameter of type \" + StdOut.class.getName() + \" or \"\n \t\t\t\t+ StdIn.class.getName() + \" but was: \" + parameterType.getName());\n \n \t}\n \n+\tprivate StdIntercept getInterceptAnnotation(ParameterContext context) {\n+\t\treturn context\n+\t\t\t\t.findAnnotation(StdIntercept.class)\n+\t\t\t\t.orElseThrow(() -> new ParameterResolutionException(\n+\t\t\t\t\t\"This can never happen because this extension only supplies parameters if the parameter is annotated with @StdIntercept\"));\n+\t}\n+", "originalCommit": "6165f7cdeb02e73f3296e71207854d9da8266f12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4ODA1NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r411588054", "bodyText": "You could but it does not really make sense, because this ParameterResolutionException is specific to this extension. If you want to move just the first part, how would that even look?\nPioneerAnnotationUtils.findAnnotation(context, StdIntercept.class)?\nI think this is simple enough to leave as-is but if you have any ideas, I'm open.", "author": "Michael1993", "createdAt": "2020-04-20T18:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4NjA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMjQwMA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r412312400", "bodyText": "You could but it does not really make sense, because this ParameterResolutionException is specific to this extension. If you want to move just the first part, how would that even look?\nPioneerAnnotationUtils.findAnnotation(context, StdIntercept.class)?\nI think this is simple enough to leave as-is but if you have any ideas, I'm open.\n\nMy thouhgt was to include the exception throwing when moving. Does not have to be ParameterResolutionException, but maybe something \"general\" like InvalidParameterException or MissingResourceException - or we define a  PioneerException :D", "author": "Bukama", "createdAt": "2020-04-21T16:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4NjA1Ng=="}], "type": "inlineReview"}, {"oid": "041f8dba293593775957eba0e9977e6026a7348b", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/041f8dba293593775957eba0e9977e6026a7348b", "message": "Fixed configuration tests to actually run as expected. Added new method for test running.", "committedDate": "2020-04-20T21:38:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMzM1Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r412313357", "bodyText": "This class is copied form JUnit Jupiter and must not be modified.\nPlease add changes to our own extending class AbstractPioneerTestEngineTests", "author": "Bukama", "createdAt": "2020-04-21T16:38:12Z", "path": "src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java", "diffHunk": "@@ -38,6 +40,16 @@ protected ExecutionEventRecorder executeTestsForMethod(Class<?> testClass, Strin\n \t\treturn executeTests(request().selectors(selectMethod(testClass.getName(), methodName)).build());\n \t}\n \n+\tprotected ExecutionEventRecorder executeTestsForMethodWithParameters(Class<?> testClass, String methodName,\n+\t\t\tClass<?>... params) {\n+\t\tString paramNames = Arrays\n+\t\t\t\t.stream(params)\n+\t\t\t\t.map(Class::getName)\n+\t\t\t\t.reduce((name1, name2) -> String.join(\",\", name1, name2))\n+\t\t\t\t.orElse(\"\");\n+\t\treturn executeTests(request().selectors(selectMethod(testClass.getName(), methodName, paramNames)).build());\n+\t}\n+", "originalCommit": "041f8dba293593775957eba0e9977e6026a7348b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk3Mzg3NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r414973874", "bodyText": "Yay, we are using the new testkit now! \ud83e\udd73", "author": "Michael1993", "createdAt": "2020-04-25T04:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMzM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNDU2Ng==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r412314566", "bodyText": "Why this try/catch ? The test should only pass if the assert for started count is valid.", "author": "Bukama", "createdAt": "2020-04-21T16:40:14Z", "path": "src/test/java/org/junitpioneer/jupiter/StdIoExtensionTests.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ParameterResolutionException;\n+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;\n+import org.junit.platform.engine.test.event.ExecutionEventRecorder;\n+import org.junitpioneer.jupiter.StdIOExtension.StdIn;\n+import org.junitpioneer.jupiter.StdIOExtension.StdOut;\n+\n+@ExtendWith(StdIOExtension.class)\n+@DisplayName(\"StdIOExtension \")\n+public class StdIoExtensionTests extends AbstractJupiterTestEngineTests {\n+\n+\tfinal BasicCommandLineApp app = new BasicCommandLineApp();\n+\n+\t@Nested\n+\t@DisplayName(\"with specific configuration \")\n+\tclass ConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"fails if parameter is not annotated with @StdIntercept\")\n+\t\tvoid needsAnnotation() {\n+\t\t\tExecutionEventRecorder recorder = executeTestsForMethodWithParameters(StdIOExtensionConfigurations.class,\n+\t\t\t\t\"noAnnotation\", StdIn.class);\n+\n+\t\t\tassertThat(getFirstFailuresThrowable(recorder))\n+\t\t\t\t\t.isInstanceOf(ParameterResolutionException.class)\n+\t\t\t\t\t.hasMessageContaining(\"No ParameterResolver registered for\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"fails if the parameter type is not StdIn or StdOut\")\n+\t\tvoid needsType() {\n+\t\t\tExecutionEventRecorder recorder = executeTestsForMethodWithParameters(StdIOExtensionConfigurations.class,\n+\t\t\t\t\"badType\", Boolean.class);\n+\n+\t\t\tassertThat(getFirstFailuresThrowable(recorder))\n+\t\t\t\t\t.isInstanceOf(ParameterResolutionException.class)\n+\t\t\t\t\t.hasMessageContaining(\"Can only resolve parameter of type %s or %s but was:\",\n+\t\t\t\t\t\tStdOut.class.getName(), StdIn.class.getName());\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"resolves parameter for type StdIn and annotation\")\n+\t\tvoid goodConfig_stdIn() {\n+\t\t\ttry {\n+\t\t\t\tExecutionEventRecorder recorder = executeTestsForMethodWithParameters(\n+\t\t\t\t\tStdIOExtensionConfigurations.class, \"resolveStdIn\", StdIn.class);\n+\t\t\t\tassertThat(recorder.getTestStartedCount()).isGreaterThan(0);\n+\t\t\t}\n+\t\t\tcatch (Throwable ignored) {\n+\t\t\t\tfail();\n+\t\t\t}", "originalCommit": "041f8dba293593775957eba0e9977e6026a7348b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU5NTA2NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r414595065", "bodyText": "Yeah, you are right. I removed the try-catch.", "author": "Michael1993", "createdAt": "2020-04-24T13:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNDU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNDY4MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r412314680", "bodyText": "see above", "author": "Bukama", "createdAt": "2020-04-21T16:40:25Z", "path": "src/test/java/org/junitpioneer/jupiter/StdIoExtensionTests.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ParameterResolutionException;\n+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;\n+import org.junit.platform.engine.test.event.ExecutionEventRecorder;\n+import org.junitpioneer.jupiter.StdIOExtension.StdIn;\n+import org.junitpioneer.jupiter.StdIOExtension.StdOut;\n+\n+@ExtendWith(StdIOExtension.class)\n+@DisplayName(\"StdIOExtension \")\n+public class StdIoExtensionTests extends AbstractJupiterTestEngineTests {\n+\n+\tfinal BasicCommandLineApp app = new BasicCommandLineApp();\n+\n+\t@Nested\n+\t@DisplayName(\"with specific configuration \")\n+\tclass ConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"fails if parameter is not annotated with @StdIntercept\")\n+\t\tvoid needsAnnotation() {\n+\t\t\tExecutionEventRecorder recorder = executeTestsForMethodWithParameters(StdIOExtensionConfigurations.class,\n+\t\t\t\t\"noAnnotation\", StdIn.class);\n+\n+\t\t\tassertThat(getFirstFailuresThrowable(recorder))\n+\t\t\t\t\t.isInstanceOf(ParameterResolutionException.class)\n+\t\t\t\t\t.hasMessageContaining(\"No ParameterResolver registered for\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"fails if the parameter type is not StdIn or StdOut\")\n+\t\tvoid needsType() {\n+\t\t\tExecutionEventRecorder recorder = executeTestsForMethodWithParameters(StdIOExtensionConfigurations.class,\n+\t\t\t\t\"badType\", Boolean.class);\n+\n+\t\t\tassertThat(getFirstFailuresThrowable(recorder))\n+\t\t\t\t\t.isInstanceOf(ParameterResolutionException.class)\n+\t\t\t\t\t.hasMessageContaining(\"Can only resolve parameter of type %s or %s but was:\",\n+\t\t\t\t\t\tStdOut.class.getName(), StdIn.class.getName());\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"resolves parameter for type StdIn and annotation\")\n+\t\tvoid goodConfig_stdIn() {\n+\t\t\ttry {\n+\t\t\t\tExecutionEventRecorder recorder = executeTestsForMethodWithParameters(\n+\t\t\t\t\tStdIOExtensionConfigurations.class, \"resolveStdIn\", StdIn.class);\n+\t\t\t\tassertThat(recorder.getTestStartedCount()).isGreaterThan(0);\n+\t\t\t}\n+\t\t\tcatch (Throwable ignored) {\n+\t\t\t\tfail();\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"resolves parameter for type StdOut and annotation\")\n+\t\tvoid goodConfig_stdOut() {\n+\t\t\ttry {\n+\t\t\t\tExecutionEventRecorder recorder = executeTestsForMethodWithParameters(\n+\t\t\t\t\tStdIOExtensionConfigurations.class, \"resolveStdOut\", StdOut.class);\n+\t\t\t\tassertThat(recorder.getTestStartedCount()).isGreaterThan(0);\n+\t\t\t}\n+\t\t\tcatch (Throwable ignored) {\n+\t\t\t\tfail();\n+\t\t\t}\n+\t\t}", "originalCommit": "041f8dba293593775957eba0e9977e6026a7348b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU5NTI2MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r414595260", "bodyText": "Removed the try-catch.", "author": "Michael1993", "createdAt": "2020-04-24T13:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNDY4MA=="}], "type": "inlineReview"}, {"oid": "7cb40b6a823c628082f9ed806873965f5798b9ab", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/7cb40b6a823c628082f9ed806873965f5798b9ab", "message": "Added adoc documentation for standard input/output extension.", "committedDate": "2020-04-23T20:21:18Z", "type": "commit"}, {"oid": "27d65060dfdcbc3c4e07b945c81ede4648967ea4", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/27d65060dfdcbc3c4e07b945c81ede4648967ea4", "message": "Renamed annotation, changed how it interacts with StdIn/StdOut parameters.", "committedDate": "2020-04-23T22:18:03Z", "type": "commit"}, {"oid": "6a8ffb0f163bc860f191d03c3a8dffb4e5ea0989", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6a8ffb0f163bc860f191d03c3a8dffb4e5ea0989", "message": "Small changes to behaviour (StdIn or StdOut should not be setting standard in/out by themselves). Refreshed documentation.", "committedDate": "2020-04-23T22:55:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMDk5MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r414700991", "bodyText": "I personally like parenthesis here (even when they are not necessary).", "author": "Bukama", "createdAt": "2020-04-24T16:21:17Z", "path": "src/main/java/org/junitpioneer/jupiter/StdIOExtension.java", "diffHunk": "@@ -30,39 +32,46 @@\n \n \t@Override\n \tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n-\t\treturn parameterContext.isAnnotated(StdIntercept.class);\n+\t\tClass<?> type = parameterContext.getParameter().getType();\n+\t\treturn type == StdIn.class || type == StdOut.class;", "originalCommit": "6a8ffb0f163bc860f191d03c3a8dffb4e5ea0989", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMjY1OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r414702658", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tformat(\"Can not resolve parameter %s because test method is missing annotation %s\",\n          \n          \n            \n            \t\t\t\t\tformat(\"Can not resolve test methods parameter %s because the '%s' annotation is missing.\",", "author": "Bukama", "createdAt": "2020-04-24T16:23:52Z", "path": "src/main/java/org/junitpioneer/jupiter/StdIOExtension.java", "diffHunk": "@@ -30,39 +32,46 @@\n \n \t@Override\n \tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n-\t\treturn parameterContext.isAnnotated(StdIntercept.class);\n+\t\tClass<?> type = parameterContext.getParameter().getType();\n+\t\treturn type == StdIn.class || type == StdOut.class;\n \t}\n \n \t@Override\n \tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n \t\tClass<?> parameterType = parameterContext.getParameter().getType();\n-\t\tStdIntercept stdIntercept = getInterceptAnnotation(parameterContext);\n \t\tif (parameterType == StdOut.class) {\n-\t\t\treturn new StdOut();\n-\t\t}\n-\t\tif (parameterType == StdIn.class) {\n-\t\t\treturn new StdIn(stdIntercept.value());\n+\t\t\treturn getOut();\n \t\t}\n-\t\tthrow new ParameterResolutionException(\"Can only resolve parameter of type \" + StdOut.class.getName() + \" or \"\n-\t\t\t\t+ StdIn.class.getName() + \" but was: \" + parameterType.getName());\n+\t\tString[] source = getSourceValuesFromAnnotation(extensionContext);\n+\t\treturn getIn(source);\n+\t}\n \n+\tprivate Object getIn(String[] source) {\n+\t\tStdIn in = new StdIn(source);\n+\t\tSystem.setIn(in);\n+\t\treturn in;\n \t}\n \n-\tprivate StdIntercept getInterceptAnnotation(ParameterContext context) {\n+\tprivate Object getOut() {\n+\t\tStdOut out = new StdOut();\n+\t\tSystem.setOut(new PrintStream(out));\n+\t\treturn out;\n+\t}\n+\n+\tprivate String[] getSourceValuesFromAnnotation(ExtensionContext context) {\n \t\treturn context\n-\t\t\t\t.findAnnotation(StdIntercept.class)\n+\t\t\t\t.getTestMethod()\n+\t\t\t\t.map(method -> method.getAnnotation(StdInSource.class))\n+\t\t\t\t.map(StdInSource::value)\n \t\t\t\t.orElseThrow(() -> new ParameterResolutionException(\n-\t\t\t\t\t\"This can never happen because this extension only supplies parameters if the parameter is annotated with @StdIntercept\"));\n+\t\t\t\t\tformat(\"Can not resolve parameter %s because test method is missing annotation %s\",", "originalCommit": "6a8ffb0f163bc860f191d03c3a8dffb4e5ea0989", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNDQwNA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/227#discussion_r414704404", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Provide values that the extension will read instead of reading the\n          \n          \n            \n             * standard input ({@code System.out}).\n          \n          \n            \n             * This should be used with {@link org.junitpioneer.jupiter.StdIOExtension.StdIn}.\n          \n          \n            \n             * Provide values that the {@code StdIOExtension} extension will read instead of reading the\n          \n          \n            \n             * standard input ({@code System.in}).\n          \n          \n            \n             * This should be used with {@link org.junitpioneer.jupiter.StdIOExtension.StdIn}.", "author": "Bukama", "createdAt": "2020-04-24T16:26:41Z", "path": "src/main/java/org/junitpioneer/jupiter/StdInSource.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Provide values that the extension will read instead of reading the\n+ * standard input ({@code System.out}).\n+ * This should be used with {@link org.junitpioneer.jupiter.StdIOExtension.StdIn}.", "originalCommit": "6a8ffb0f163bc860f191d03c3a8dffb4e5ea0989", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "72cb7a914d781abfa69b2f7ed50492ca9b101e1d", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/72cb7a914d781abfa69b2f7ed50492ca9b101e1d", "message": "Merge branch 'master' of https://github.com/junit-pioneer/junit-pioneer into std-io\n\n\u0001 Conflicts:\n\u0001\tsrc/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java", "committedDate": "2020-04-25T03:19:06Z", "type": "commit"}, {"oid": "5c5ec09070ca73c1d6ae6abe30b9dc1d16013fa4", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/5c5ec09070ca73c1d6ae6abe30b9dc1d16013fa4", "message": "Refactor based on suggestions and to use the new testkit.", "committedDate": "2020-04-25T04:01:14Z", "type": "commit"}, {"oid": "f38a3a3352ece9c47440106fb77cd31584afb340", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/f38a3a3352ece9c47440106fb77cd31584afb340", "message": "Sonar quality updates", "committedDate": "2020-04-26T12:23:40Z", "type": "commit"}, {"oid": "edd5906f8362d192963f2b9211c3f4312c64a621", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/edd5906f8362d192963f2b9211c3f4312c64a621", "message": "Documentation update, revert unused method implementation.", "committedDate": "2020-04-26T15:24:18Z", "type": "commit"}, {"oid": "ad6b32002e144c8b204208aa99df3e66feb49524", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/ad6b32002e144c8b204208aa99df3e66feb49524", "message": "Made documentation less informal and properly formatted", "committedDate": "2020-05-26T16:46:13Z", "type": "commit"}, {"oid": "81f87ec681c3580ba7f7b503a30964b1d3e09b2c", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/81f87ec681c3580ba7f7b503a30964b1d3e09b2c", "message": "Fix docs-nav.yml", "committedDate": "2020-05-27T10:33:27Z", "type": "commit"}]}