{"pr_number": 4125, "pr_title": "WFCORE-4895, Bootable jar runtime", "pr_createdAt": "2020-04-01T16:28:12Z", "pr_url": "https://github.com/wildfly/wildfly-core/pull/4125", "timeline": [{"oid": "e81116b1a1db9e63c2df18f54c82d833ea6a3825", "url": "https://github.com/wildfly/wildfly-core/commit/e81116b1a1db9e63c2df18f54c82d833ea6a3825", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-01T18:09:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MjU3Mg==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404852572", "bodyText": "This is just a minor note. It might be useful to add a comment here that logging needs to be configured before other components have a chance to initialize a logger.", "author": "jamezp", "createdAt": "2020-04-07T14:27:23Z", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();", "originalCommit": "e81116b1a1db9e63c2df18f54c82d833ea6a3825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxNjkwNg==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404916906", "bodyText": "Ok, added a comment.", "author": "jfdenise", "createdAt": "2020-04-07T15:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MjU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NTg4NA==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404855884", "bodyText": "If we do this we mandate that users must use the JBoss Log Manager. Maybe this is okay, but maybe it's something we should look at.", "author": "jamezp", "createdAt": "2020-04-07T14:31:37Z", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);", "originalCommit": "e81116b1a1db9e63c2df18f54c82d833ea6a3825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMDA1NA==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404920054", "bodyText": "@jamezp , I was under the assumption that the jboss logmanager was the only usable implementation with the Logging subsystem. You are suggesting that user could set the system property and not rely on the logging subsystem? I could check if the system property exists and do nothing if that is the case.", "author": "jfdenise", "createdAt": "2020-04-07T15:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MTE5OQ==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404941199", "bodyText": "I'm redacting this concern. The logging subsystem does require the JBoss Log Manager, my thought was if the subsystem was removed maybe the user would want to use a different log manager. However the servers main entry point does do some log manager initialization as well so removing a requirement like that is out of scope for this. Sorry about the confusion there.", "author": "jamezp", "createdAt": "2020-04-07T16:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NTg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTMzNQ==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404859335", "bodyText": "Is there a reason we're swallowing the errors here?", "author": "jamezp", "createdAt": "2020-04-07T14:36:22Z", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }", "originalCommit": "e81116b1a1db9e63c2df18f54c82d833ea6a3825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMTEzMA==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404921130", "bodyText": "We want to clean as much as we can even if a failure occurs (eg: Windows and opened jar deletion). I should add a log.", "author": "jfdenise", "createdAt": "2020-04-07T15:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTQyNA==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404859424", "bodyText": "Is there a reason we're swallowing the errors here?", "author": "jamezp", "createdAt": "2020-04-07T14:36:29Z", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;\n+                    }\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {", "originalCommit": "e81116b1a1db9e63c2df18f54c82d833ea6a3825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMjg3NA==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404922874", "bodyText": "Same, continue to delete although we have errors. I will add a log.", "author": "jfdenise", "createdAt": "2020-04-07T15:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTkyMA==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404859920", "bodyText": "This seems odd as we swallow the error below at line 291.", "author": "jamezp", "createdAt": "2020-04-07T14:37:08Z", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;", "originalCommit": "e81116b1a1db9e63c2df18f54c82d833ea6a3825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMzAzMQ==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404923031", "bodyText": "Yep, need to remove it.", "author": "jfdenise", "createdAt": "2020-04-07T15:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg2MjU4OA==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404862588", "bodyText": "Is there a reason we're doing this privileged? I ask because if we're running this under a security manager the other places where we set system properties are gonna be an issue as well.", "author": "jamezp", "createdAt": "2020-04-07T14:40:30Z", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private static void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    if (e != null) {\n+                        // directory iteration failed\n+                        throw e;\n+                    }\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private void waitAndClean() {\n+        try {\n+            // Give max 10 seconds for the server to stop before to delete jbossHome.\n+            ModelNode mn = new ModelNode();\n+            mn.get(ADDRESS);\n+            mn.get(OP).set(READ_ATTRIBUTE_OPERATION);\n+            mn.get(NAME).set(SERVER_STATE);\n+            for (int i = 0; i < 10; i++) {\n+                try {\n+                    ModelControllerClient client = server.getModelControllerClient();\n+                    if (client != null) {\n+                        ModelNode ret = client.execute(mn);\n+                        if (ret.hasDefined(RESULT)) {\n+                            String val = ret.get(RESULT).asString();\n+                            if (STOPPED.equals(val)) {\n+                                log.serverStopped();\n+                                break;\n+                            } else {\n+                                log.serverNotStopped();\n+                            }\n+                        }\n+                        Thread.sleep(1000);\n+                    } else {\n+                        log.nullController();\n+                        break;\n+                    }\n+                } catch (Exception ex) {\n+                    log.unexpectedExceptionWhileShuttingDown(ex);\n+                }\n+            }\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    /**\n+     * Modular entry point.\n+     *\n+     * @param jbossHome Server home directory.\n+     * @param args User provided arguments.\n+     * @param moduleLoader JBoss modules loader.\n+     * @param moduleClassLoader Bootable jar module classloader\n+     * @param unzipTime Time spent to unzip the server.\n+     * @throws Exception\n+     */\n+    public static void run(Path jbossHome, List<String> args, ModuleLoader moduleLoader, ModuleClassLoader moduleClassLoader, Long unzipTime) throws Exception {\n+        setTccl(moduleClassLoader);\n+        Arguments arguments;\n+        try {\n+            arguments = Arguments.parseArguments(args);\n+        } catch (Throwable ex) {\n+            System.err.println(ex);\n+            CmdUsage.printUsage(System.out);\n+            return;\n+        }\n+        if (arguments.isHelp()) {\n+            CmdUsage.printUsage(System.out);\n+            return;\n+        }\n+        BootableJar bootableJar = new BootableJar(jbossHome, arguments, moduleLoader, unzipTime);\n+        bootableJar.run();\n+    }\n+\n+    static void setTccl(final ClassLoader cl) {\n+        if (System.getSecurityManager() == null) {\n+            Thread.currentThread().setContextClassLoader(cl);\n+        } else {\n+            AccessController.doPrivileged(new PrivilegedAction<Object>() {", "originalCommit": "e81116b1a1db9e63c2df18f54c82d833ea6a3825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxODE3Nw==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r404918177", "bodyText": "That is un-needed, I removed the block.", "author": "jfdenise", "createdAt": "2020-04-07T15:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg2MjU4OA=="}], "type": "inlineReview"}, {"oid": "1c2b4302ed06fa4f5f93833c9dc3088dbd1777e2", "url": "https://github.com/wildfly/wildfly-core/commit/1c2b4302ed06fa4f5f93833c9dc3088dbd1777e2", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-07T15:47:55Z", "type": "forcePushed"}, {"oid": "1bf07c30be271f067238c64e6ed62745bbf47f94", "url": "https://github.com/wildfly/wildfly-core/commit/1bf07c30be271f067238c64e6ed62745bbf47f94", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-07T16:09:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxODQyNg==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r405518426", "bodyText": "You could expose the currentProcessState from the Server and avoid polling with a management Operation.\nThe benefits are you will get all the possible process states, in case of needing a different one instead of STOPPED, and it avoid any overhead executing the management operation. I used this on this issue: https://github.com/wildfly/wildfly-core/pull/4119/files#diff-ba94eab7c9f427c4ba24827d0908d9edR374", "author": "yersan", "createdAt": "2020-04-08T13:19:53Z", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/BootableJar.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ADDRESS;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.ARCHIVE;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.CONTENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.DEPLOYMENT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.NAME;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.OP;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.READ_ATTRIBUTE_OPERATION;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RESULT;\n+import static org.jboss.as.controller.client.helpers.ClientConstants.RUNTIME_NAME;\n+import org.jboss.as.process.CommandLineConstants;\n+import org.jboss.as.process.ExitCodes;\n+import org.jboss.dmr.ModelNode;\n+import org.jboss.logmanager.LogContext;\n+import org.jboss.logmanager.PropertyConfigurator;\n+import org.jboss.modules.ModuleClassLoader;\n+import org.jboss.modules.ModuleLoader;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_CONFIG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.JBOSS_SERVER_LOG_DIR;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_BOOT_FILE_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_CLASS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG_MANAGER_PROP;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE;\n+import static org.wildfly.core.jar.runtime.Constants.STANDALONE_CONFIG;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import static org.wildfly.core.jar.runtime.Constants.CONFIGURATION;\n+import static org.wildfly.core.jar.runtime.Constants.DATA;\n+import static org.wildfly.core.jar.runtime.Constants.DEPLOYMENTS;\n+import static org.wildfly.core.jar.runtime.Constants.LOG;\n+import static org.wildfly.core.jar.runtime.Constants.LOGGING_PROPERTIES;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_LOG;\n+import static org.wildfly.core.jar.runtime.Constants.SERVER_STATE;\n+import static org.wildfly.core.jar.runtime.Constants.SHA1;\n+import static org.wildfly.core.jar.runtime.Constants.STOPPED;\n+import org.wildfly.core.jar.runtime.Server.ShutdownHandler;\n+\n+/**\n+ *\n+ * @author jdenise\n+ */\n+public final class BootableJar implements ShutdownHandler {\n+\n+    private static final String DEP_1 = \"ff\";\n+    private static final String DEP_2 = \"00\";\n+\n+    private class ShutdownHook extends Thread {\n+\n+        @Override\n+        public void run() {\n+            log.shuttingDown();\n+            waitAndClean();\n+        }\n+    }\n+\n+    private BootableJarLogger log;\n+\n+    private final Path jbossHome;\n+    private final List<String> startServerArgs = new ArrayList<>();\n+    private Server server;\n+    private final Arguments arguments;\n+    private final ModuleLoader loader;\n+\n+    private BootableJar(Path jbossHome, Arguments arguments, ModuleLoader loader, long unzipTime) throws Exception {\n+        this.jbossHome = jbossHome;\n+        this.arguments = arguments;\n+        this.loader = loader;\n+        startServerArgs.addAll(arguments.getServerArguments());\n+        startServerArgs.add(CommandLineConstants.READ_ONLY_SERVER_CONFIG + \"=\" + STANDALONE_CONFIG);\n+\n+        // logging needs to be configured before other components have a chance to initialize a logger\n+        configureLogger();\n+        long t = System.currentTimeMillis();\n+        if (arguments.getDeployment() != null) {\n+            setupDeployment(arguments.getDeployment());\n+        }\n+\n+        log.advertiseInstall(jbossHome, unzipTime + (System.currentTimeMillis() - t));\n+    }\n+\n+    @Override\n+    public void shutdown(int status) {\n+        if (status == ExitCodes.RESTART_PROCESS_FROM_STARTUP_SCRIPT) {\n+            log.cantRestartServer();\n+        }\n+        System.exit(status);\n+    }\n+\n+    private void setupDeployment(Path deployment) throws Exception {\n+        Path deploymentDir = jbossHome.resolve(STANDALONE).resolve(DATA).resolve(CONTENT).resolve(DEP_1).resolve(DEP_2);\n+\n+        Path target = deploymentDir.resolve(CONTENT);\n+        Files.createDirectories(deploymentDir);\n+        // Exploded deployment\n+        boolean isExploded = Files.isDirectory(deployment);\n+        updateConfig(jbossHome.resolve(STANDALONE).resolve(CONFIGURATION).resolve(STANDALONE_CONFIG),\n+                deployment.getFileName().toString(), isExploded);\n+        if (isExploded) {\n+            copyDirectory(deployment, target);\n+        } else {\n+            Files.copy(deployment, target);\n+        }\n+        log.installDeployment(deployment);\n+    }\n+\n+    private static void updateConfig(Path configFile, String name, boolean isExploded) throws Exception {\n+        FileInputStream fileInputStream = new FileInputStream(configFile.toFile());\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+\n+        Document document = documentBuilder.parse(fileInputStream);\n+        Element root = document.getDocumentElement();\n+\n+        NodeList lst = root.getChildNodes();\n+        for (int i = 0; i < lst.getLength(); i++) {\n+            Node n = lst.item(i);\n+            if (n instanceof Element) {\n+                if (DEPLOYMENTS.equals(n.getNodeName())) {\n+                    throw BootableJarLogger.ROOT_LOGGER.deploymentAlreadyExist();\n+                }\n+            }\n+        }\n+        Element deployments = document.createElement(DEPLOYMENTS);\n+        Element deployment = document.createElement(DEPLOYMENT);\n+        Element content = document.createElement(CONTENT);\n+        content.setAttribute(SHA1, DEP_1 + DEP_2);\n+        if (isExploded) {\n+            content.setAttribute(ARCHIVE, \"false\");\n+        }\n+        deployment.appendChild(content);\n+        deployment.setAttribute(NAME, name);\n+        deployment.setAttribute(RUNTIME_NAME, name);\n+        deployments.appendChild(deployment);\n+\n+        root.appendChild(deployments);\n+        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n+        StreamResult output = new StreamResult(configFile.toFile());\n+        DOMSource input = new DOMSource(document);\n+\n+        transformer.transform(input, output);\n+\n+    }\n+\n+    private void copyDirectory(Path src, Path target) throws IOException {\n+        Files.walk(src).forEach(file -> {\n+            try {\n+                Path targetFile = target.resolve(src.relativize(file));\n+                if (Files.isDirectory(file)) {\n+                    if (!Files.exists(targetFile)) {\n+                        Files.createDirectory(targetFile);\n+                    }\n+                } else {\n+                    Files.copy(file, targetFile);\n+                }\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+    }\n+\n+    private void configureLogger() throws IOException {\n+        System.setProperty(LOG_MANAGER_PROP, LOG_MANAGER_CLASS);\n+        configureLogging();\n+        log = BootableJarLogger.ROOT_LOGGER;\n+    }\n+\n+    private void configureLogging() throws IOException {\n+        if (!arguments.isVersion()) {\n+            LogContext ctx = configureLogContext();\n+            LogContext.setLogContextSelector(() -> {\n+                return ctx;\n+            });\n+        }\n+    }\n+\n+    private LogContext configureLogContext() throws IOException {\n+        final Path baseDir = jbossHome.resolve(STANDALONE);\n+        String serverLogDir = System.getProperty(JBOSS_SERVER_LOG_DIR, null);\n+        if (serverLogDir == null) {\n+            serverLogDir = baseDir.resolve(LOG).toString();\n+            System.setProperty(JBOSS_SERVER_LOG_DIR, serverLogDir);\n+        }\n+        final String serverCfgDir = System.getProperty(JBOSS_SERVER_CONFIG_DIR, baseDir.resolve(CONFIGURATION).toString());\n+        final LogContext embeddedLogContext = LogContext.create();\n+        final Path bootLog = Paths.get(serverLogDir).resolve(SERVER_LOG);\n+        final Path loggingProperties = Paths.get(serverCfgDir).resolve(Paths.get(LOGGING_PROPERTIES));\n+        if (Files.exists(loggingProperties)) {\n+            try (final InputStream in = Files.newInputStream(loggingProperties)) {\n+                System.setProperty(LOG_BOOT_FILE_PROP, bootLog.toAbsolutePath().toString());\n+                PropertyConfigurator configurator = new PropertyConfigurator(embeddedLogContext);\n+                configurator.configure(in);\n+            }\n+        }\n+        return embeddedLogContext;\n+    }\n+\n+    public void run() throws Exception {\n+        try {\n+            server = buildServer(startServerArgs);\n+        } catch (RuntimeException ex) {\n+            cleanup();\n+            throw ex;\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n+        server.start();\n+    }\n+\n+    private void cleanup() {\n+        log.deletingHome(jbossHome);\n+        deleteDir(jbossHome);\n+\n+    }\n+\n+    private Server buildServer(List<String> args) throws IOException {\n+        String[] array = new String[args.size()];\n+        log.advertiseOptions(args);\n+        return Server.newSever(jbossHome, args.toArray(array), loader, this);\n+    }\n+\n+    private void deleteDir(Path root) {\n+        if (root == null || !Files.exists(root)) {\n+            return;\n+        }\n+        try {\n+            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(file);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(file.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                        throws IOException {\n+                    try {\n+                        Files.delete(dir);\n+                    } catch (IOException ex) {\n+                        log.cantDelete(dir.toString(), ex);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private void waitAndClean() {\n+        try {\n+            // Give max 10 seconds for the server to stop before to delete jbossHome.\n+            ModelNode mn = new ModelNode();\n+            mn.get(ADDRESS);\n+            mn.get(OP).set(READ_ATTRIBUTE_OPERATION);\n+            mn.get(NAME).set(SERVER_STATE);\n+            for (int i = 0; i < 10; i++) {\n+                try {\n+                    ModelControllerClient client = server.getModelControllerClient();\n+                    if (client != null) {\n+                        ModelNode ret = client.execute(mn);", "originalCommit": "1bf07c30be271f067238c64e6ed62745bbf47f94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzODkxMw==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r406038913", "bodyText": "Good point, I removed DMR request and exposed the process state.", "author": "jfdenise", "createdAt": "2020-04-09T08:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxODQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3MDE2OQ==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r413870169", "bodyText": "Just for the record, the requested changes were rejected due to https://issues.redhat.com/browse/WFCORE-4922", "author": "yersan", "createdAt": "2020-04-23T14:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxODQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjI4MQ==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r405586281", "bodyText": "The boolean argument should be yes instead of false. Doing so the internal variable that stores the currentProcessState gets updated upon an nitification.", "author": "yersan", "createdAt": "2020-04-08T14:53:20Z", "path": "bootable-jar/runtime/src/main/java/org/wildfly/core/jar/runtime/Server.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.wildfly.core.jar.runtime;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import static java.lang.System.getProperties;\n+import static java.lang.System.getSecurityManager;\n+import static java.lang.System.getenv;\n+import static java.lang.System.setProperty;\n+import java.nio.file.Path;\n+import static java.security.AccessController.doPrivileged;\n+import java.security.PrivilegedAction;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import org.jboss.as.controller.ControlledProcessState;\n+import org.jboss.as.controller.ControlledProcessStateService;\n+import org.jboss.as.controller.ModelControllerClientFactory;\n+import org.jboss.as.controller.ProcessStateNotifier;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.client.helpers.DelegatingModelControllerClient;\n+import org.jboss.as.server.Bootstrap;\n+import org.jboss.as.server.Main;\n+import org.jboss.as.server.ServerEnvironment;\n+import org.jboss.as.server.ServerService;\n+import org.jboss.as.server.SystemExiter;\n+import org.jboss.modules.Module;\n+import org.jboss.modules.ModuleLoadException;\n+import org.jboss.modules.ModuleLoader;\n+import org.jboss.msc.service.ServiceActivator;\n+import org.jboss.msc.service.ServiceContainer;\n+import org.jboss.msc.service.ServiceController;\n+import org.jboss.msc.value.Value;\n+import org.wildfly.core.jar.runtime._private.BootableJarLogger;\n+\n+/**\n+ * Bootable jar server. Inspired from Embedded Server API standalone server.\n+ *\n+ * @author jdenise\n+ */\n+final class Server {\n+\n+    interface ShutdownHandler {\n+\n+        void shutdown(int status);\n+    }\n+\n+    private static final String MODULE_ID_VFS = \"org.jboss.vfs\";\n+    private final PropertyChangeListener processStateListener;\n+    private final String[] cmdargs;\n+    private final Properties systemProps;\n+    private final Map<String, String> systemEnv;\n+    private final ModuleLoader moduleLoader;\n+    private ServiceContainer serviceContainer;\n+    private ControlledProcessState.State currentProcessState;\n+    private ModelControllerClient modelControllerClient;\n+    private ExecutorService executorService;\n+    private ProcessStateNotifier processStateNotifier;\n+    private final ShutdownHandler shutdownHandler;\n+\n+    private Server(String[] cmdargs, Properties systemProps,\n+            Map<String, String> systemEnv, ModuleLoader moduleLoader,\n+            ShutdownHandler shutdownHandler) {\n+        this.cmdargs = cmdargs;\n+        this.systemProps = systemProps;\n+        this.systemEnv = systemEnv;\n+        this.moduleLoader = moduleLoader;\n+        this.shutdownHandler = shutdownHandler;\n+\n+        processStateListener = new PropertyChangeListener() {\n+            @Override\n+            public void propertyChange(PropertyChangeEvent evt) {\n+                if (\"currentState\".equals(evt.getPropertyName())) {\n+                    ControlledProcessState.State newState = (ControlledProcessState.State) evt.getNewValue();\n+                    establishModelControllerClient(newState, false);", "originalCommit": "1bf07c30be271f067238c64e6ed62745bbf47f94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzOTAzNA==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r406039034", "bodyText": "Ok.", "author": "jfdenise", "createdAt": "2020-04-09T08:25:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg2ODYxMA==", "url": "https://github.com/wildfly/wildfly-core/pull/4125#discussion_r413868610", "bodyText": "Just for the record, the requested changes were rejected due to https://issues.redhat.com/browse/WFCORE-4922", "author": "yersan", "createdAt": "2020-04-23T14:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjI4MQ=="}], "type": "inlineReview"}, {"oid": "d65daa4e24f2ebc2f0a65c4f2fdb50eed207a652", "url": "https://github.com/wildfly/wildfly-core/commit/d65daa4e24f2ebc2f0a65c4f2fdb50eed207a652", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-09T07:25:58Z", "type": "forcePushed"}, {"oid": "2191a9d7ea118efa9236ee25ad64d5f282818611", "url": "https://github.com/wildfly/wildfly-core/commit/2191a9d7ea118efa9236ee25ad64d5f282818611", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-09T08:22:35Z", "type": "forcePushed"}, {"oid": "a7cc61775b4387c6b485ba70eb3dbf746041e346", "url": "https://github.com/wildfly/wildfly-core/commit/a7cc61775b4387c6b485ba70eb3dbf746041e346", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-09T08:41:38Z", "type": "forcePushed"}, {"oid": "057a82543e5a013d41129eb506dcf09cfe5da318", "url": "https://github.com/wildfly/wildfly-core/commit/057a82543e5a013d41129eb506dcf09cfe5da318", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-10T13:52:53Z", "type": "forcePushed"}, {"oid": "e7cb0ce5dc8bb516499d8ff04489fea6232ddbbb", "url": "https://github.com/wildfly/wildfly-core/commit/e7cb0ce5dc8bb516499d8ff04489fea6232ddbbb", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-14T14:35:39Z", "type": "forcePushed"}, {"oid": "1f4bb783e6d2069deb71346e215bec880ae0fa83", "url": "https://github.com/wildfly/wildfly-core/commit/1f4bb783e6d2069deb71346e215bec880ae0fa83", "message": "Fix for WFCORE-4895, Bootable runtime module", "committedDate": "2020-04-28T12:48:41Z", "type": "commit"}, {"oid": "42f72678a67def585b4f0678e98e68bb9a2c7b85", "url": "https://github.com/wildfly/wildfly-core/commit/42f72678a67def585b4f0678e98e68bb9a2c7b85", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-28T13:58:33Z", "type": "forcePushed"}, {"oid": "c03341fe70c06a59f724e204d5e5adf3fc14a631", "url": "https://github.com/wildfly/wildfly-core/commit/c03341fe70c06a59f724e204d5e5adf3fc14a631", "message": "Fix for WFCORE-4895, Bootable runtime module, ts.bootable profile, launcher and test-runner support for bootable jar", "committedDate": "2020-04-28T14:59:25Z", "type": "commit"}, {"oid": "0224084bfbb06ee8a59e217ccab8b3b4d07ad129", "url": "https://github.com/wildfly/wildfly-core/commit/0224084bfbb06ee8a59e217ccab8b3b4d07ad129", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-28T14:59:35Z", "type": "commit"}, {"oid": "0224084bfbb06ee8a59e217ccab8b3b4d07ad129", "url": "https://github.com/wildfly/wildfly-core/commit/0224084bfbb06ee8a59e217ccab8b3b4d07ad129", "message": "Fix for WFCORE-4895, update vault test fp to depend on GAV", "committedDate": "2020-04-28T14:59:35Z", "type": "forcePushed"}]}