{"pr_number": 4267, "pr_title": "[WFCORE-5032] Elytron subsystem should not depend upon PicketBox", "pr_createdAt": "2020-07-15T09:54:19Z", "pr_url": "https://github.com/wildfly/wildfly-core/pull/4267", "timeline": [{"oid": "d4d611a3f28680a0a3059c46af8deb8edc6f787e", "url": "https://github.com/wildfly/wildfly-core/commit/d4d611a3f28680a0a3059c46af8deb8edc6f787e", "message": "[WFCORE-4873]: Upgrade JGit to 5.8.0.202006091008-r\n\n * Adding a new layer to be able to 'remove' git support.\n * Adding bouncycastle dependencies and splitting the modules.\n * Removing jcraft jsch and jzlib dependencies.\n * Upgrading jgit and its dependency JavaEWAH to 1.1.7.\n * Disabling commit signing.\n\nJira: https://issues.redhat.com/browse/WFCORE-4873", "committedDate": "2020-07-08T13:44:04Z", "type": "commit"}, {"oid": "54a0235aeb9898aeb2a370ce8a14540ef5f6dbc1", "url": "https://github.com/wildfly/wildfly-core/commit/54a0235aeb9898aeb2a370ce8a14540ef5f6dbc1", "message": "[WFCORE-5042] Upgrade WildFly Elytron to 1.13.0.CR2", "committedDate": "2020-07-10T19:25:02Z", "type": "commit"}, {"oid": "d23772731876ce9f95f800296d7d0665a81c774d", "url": "https://github.com/wildfly/wildfly-core/commit/d23772731876ce9f95f800296d7d0665a81c774d", "message": "[WFCORE-5044] Add org.apache.sshd:sshd-common dependency", "committedDate": "2020-07-10T19:26:03Z", "type": "commit"}, {"oid": "5585e2c0c5da48ad9d9ad733ef87f9355e56000f", "url": "https://github.com/wildfly/wildfly-core/commit/5585e2c0c5da48ad9d9ad733ef87f9355e56000f", "message": "[WFCORE-5042] Upgrade WildFly Elytron to 1.13.0.CR2\n\nAddress merge conflict with [WFCORE-4873]", "committedDate": "2020-07-15T08:56:43Z", "type": "commit"}, {"oid": "bbcaff70c6ed34b52c728365e774078cfe30dd70", "url": "https://github.com/wildfly/wildfly-core/commit/bbcaff70c6ed34b52c728365e774078cfe30dd70", "message": "[WFCORE-5032] Remove direct dependency on PicketBox and instead dynamically discover PolicyContextHandlers from the security subsystem if available.", "committedDate": "2020-07-15T09:12:19Z", "type": "commit"}, {"oid": "53af992d24ceea74b3693b8121bdc5d1451c699b", "url": "https://github.com/wildfly/wildfly-core/commit/53af992d24ceea74b3693b8121bdc5d1451c699b", "message": "[WFCORE-5020] Ensure and defined PolicyConfigurationFactory is instantiated at the time the service starts.\n\nAlso use the defined module and verify the correct instance was loaded.", "committedDate": "2020-07-15T09:12:19Z", "type": "commit"}, {"oid": "8180e29c479bf8f65b9ddf7814aebd6dd4ff5f4c", "url": "https://github.com/wildfly/wildfly-core/commit/8180e29c479bf8f65b9ddf7814aebd6dd4ff5f4c", "message": "[WFCORE-5049] Ensure the Policy is registered before the PolicyConfigurationFactory is instantiated.", "committedDate": "2020-07-15T09:12:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0MTAyOQ==", "url": "https://github.com/wildfly/wildfly-core/pull/4267#discussion_r464241029", "bodyText": "should this sys prop remain? or should it be discarded at some point?", "author": "jmesnil", "createdAt": "2020-08-03T07:32:47Z", "path": "elytron/src/main/java/org/wildfly/extension/elytron/PolicyDefinitions.java", "diffHunk": "@@ -287,292 +276,131 @@ protected void recordCapabilitiesAndRequirements(OperationContext context, Attri\n \n     }\n \n-    private static Supplier<Policy> getPolicyProvider(OperationContext context, ModelNode model, ServiceBuilder<Policy> serviceBuilder) throws OperationFailedException {\n-        Supplier<Policy> result = configureJaccPolicy(context, model, serviceBuilder);\n+    private static Consumer<Consumer<Policy>> getPolicyProvider(OperationContext context, ModelNode model) throws OperationFailedException {\n+        Consumer<Consumer<Policy>> result = configureJaccPolicy(context, model);\n         if (result == null) {\n             result = configureCustomPolicy(context, model);\n         }\n         return result;\n     }\n \n-    private static Supplier<Policy> configureCustomPolicy(OperationContext context, ModelNode model) throws OperationFailedException {\n+    private static Consumer<Consumer<Policy>> configureCustomPolicy(OperationContext context, ModelNode model) throws OperationFailedException {\n         ModelNode policyModel = model.get(CUSTOM_POLICY);\n \n         if (policyModel.isDefined()) {\n             String className = CustomPolicyDefinition.CLASS_NAME.resolveModelAttribute(context, policyModel).asString();\n             String module = CustomPolicyDefinition.MODULE.resolveModelAttribute(context, policyModel).asStringOrNull();\n \n-            return () -> newPolicy(className, module);\n+            return (t) -> {\n+                try {\n+                    t.accept(newPolicy(className, ClassLoadingAttributeDefinitions.resolveClassLoader(module)));\n+                } catch (ModuleLoadException e) {\n+                    throw ElytronSubsystemMessages.ROOT_LOGGER.unableToLoadModuleRuntime(module, e);\n+                }\n+            };\n         }\n \n         return null;\n     }\n \n-    private static Supplier<Policy> configureJaccPolicy(OperationContext context, ModelNode model, ServiceBuilder<Policy> serviceBuilder) throws OperationFailedException {\n+    private static Consumer<Consumer<Policy>> configureJaccPolicy(OperationContext context, ModelNode model) throws OperationFailedException {\n         ModelNode policyModel = model.get(JACC_POLICY);\n \n         if (policyModel.isDefined()) {\n-            String policyProvider = JaccPolicyDefinition.POLICY_PROVIDER.resolveModelAttribute(context, policyModel).asString();\n-            String configurationFactory = JaccPolicyDefinition.CONFIGURATION_FACTORY.resolveModelAttribute(context, policyModel).asString();\n+            final String policyProvider = JaccPolicyDefinition.POLICY_PROVIDER.resolveModelAttribute(context, policyModel).asString();\n+            final String configurationFactory = JaccPolicyDefinition.CONFIGURATION_FACTORY.resolveModelAttribute(context, policyModel).asString();\n+            final boolean defaultConfigurationFactory = configurationFactory.equals(JaccPolicyDefinition.CONFIGURATION_FACTORY.getDefaultValue().asString());\n             String module = JaccPolicyDefinition.MODULE.resolveModelAttribute(context, policyModel).asStringOrNull();\n \n-            serviceBuilder.addAliases(JACC_POLICY_RUNTIME_CAPABILITY.getCapabilityServiceName());\n+            return new Consumer<Consumer<Policy>>() {\n \n-            return new Supplier<Policy>() {\n                 @Override\n-                public Policy get() {\n-                    if (configurationFactory != null) {\n-                        if (WildFlySecurityManager.isChecking()) {\n-                            AccessController.doPrivileged(setConfigurationProviderSystemProperty());\n-                        } else {\n-                            setConfigurationProviderSystemProperty().run();\n-                        }\n-                    }\n-\n-                    Policy policy = newPolicy(policyProvider, module);\n+                public void accept(Consumer<Policy> policyConsumer) {\n \n                     try {\n-                        PolicyContext.registerHandler(SecurityConstants.SUBJECT_CONTEXT_KEY, createSubjectPolicyContextHandler(), true);\n-                        PolicyContext.registerHandler(SecurityConstants.CALLBACK_HANDLER_KEY, createCallbackHandlerContextHandler(), true);\n-                        PolicyContext.registerHandler(SecurityIdentity.class.getName(), createSecurityIdentityContextHandler(), true);\n-                    } catch (PolicyContextException cause) {\n-                        throw ElytronSubsystemMessages.ROOT_LOGGER.failedToRegisterPolicyHandlers(cause);\n-                    }\n-\n-                    return policy;\n-                }\n-\n-                private PrivilegedAction<Void> setConfigurationProviderSystemProperty() {\n-                    return () -> {\n-                        if (WildFlySecurityManager.isChecking()) {\n-                            WildFlySecurityManager.setPropertyPrivileged(\"javax.security.jacc.PolicyConfigurationFactory.provider\", configurationFactory);\n-                        } else {\n-                            System.setProperty(\"javax.security.jacc.PolicyConfigurationFactory.provider\", configurationFactory);\n-                        }\n-                        return null;\n-                    };\n-                }\n+                        ClassLoader configuredClassLoader = ClassLoadingAttributeDefinitions.resolveClassLoader(module);\n \n-                private PolicyContextHandler createSecurityIdentityContextHandler() {\n-                    return new PolicyContextHandler() {\n-                        final String KEY = SecurityIdentity.class.getName();\n+                        Policy policy = newPolicy(policyProvider, configuredClassLoader);\n+                        policyConsumer.accept(policy);\n \n-                        @Override\n-                        public Object getContext(String key, Object data) throws PolicyContextException {\n-                            if (supports(key)) {\n-                                SecurityDomain securityDomain = doPrivileged((PrivilegedAction<SecurityDomain>) SecurityDomain::getCurrent);\n+                        doPrivileged((PrivilegedExceptionAction<PolicyConfigurationFactory>) () -> newPolicyConfigurationFactory(\n+                                configurationFactory,\n+                                defaultConfigurationFactory ? PolicyDefinitions.class.getClassLoader() : configuredClassLoader));\n \n-                                if (securityDomain == null) {\n-                                    return null;\n-                                }\n+                        Map<String, PolicyContextHandler> discoveredHandlers = discoverPolicyContextHandlers();\n \n-                                SecurityIdentity securityIdentity = securityDomain.getCurrentSecurityIdentity();\n-\n-                                if (securityIdentity != null) {\n-                                    return securityIdentity;\n-                                }\n-                            }\n-\n-                            return null;\n-                        }\n-\n-                        @Override\n-                        public String[] getKeys() throws PolicyContextException {\n-                            return new String[]{KEY};\n+                        registerHandler(discoveredHandlers, new SubjectPolicyContextHandler());\n+                        registerHandler(discoveredHandlers, new SecurityIdentityHandler());\n+                        for (Entry<String, PolicyContextHandler> entry : discoveredHandlers.entrySet()) {\n+                            PolicyContext.registerHandler(entry.getKey(), entry.getValue(), true);\n                         }\n \n-                        @Override\n-                        public boolean supports(String key) throws PolicyContextException {\n-                            return getKeys()[0].equalsIgnoreCase(key);\n-                        }\n-                    };\n+                    } catch (Exception cause) {\n+                        throw ElytronSubsystemMessages.ROOT_LOGGER.failedToRegisterPolicyHandlers(cause);\n+                    }\n                 }\n \n-                private PolicyContextHandler createCallbackHandlerContextHandler() {\n-                    return new PolicyContextHandler() {\n-                        // in case applications are using legacy (PicketBox) security infrastructure\n-                        CallbackHandlerPolicyContextHandler legacy = new CallbackHandlerPolicyContextHandler();\n-\n-                        @Override\n-                        public Object getContext(String key, Object data) throws PolicyContextException {\n-                            return legacy.getContext(key, data);\n-                        }\n-\n-                        @Override\n-                        public String[] getKeys() throws PolicyContextException {\n-                            return legacy.getKeys();\n-                        }\n-\n-                        @Override\n-                        public boolean supports(String key) throws PolicyContextException {\n-                            return legacy.supports(key);\n+                private void registerHandler(Map<String, PolicyContextHandler> discoveredHandlers, PolicyContextHandler handler) throws PolicyContextException {\n+                    for (String key : handler.getKeys()) {\n+                        PolicyContextHandler discovered = discoveredHandlers.remove(key);\n+                        if (discovered != null) {\n+                            ElytronSubsystemMessages.ROOT_LOGGER.tracef(\"Registering DelegatingPolicyContextHandler for key '%s'.\", key);\n+                            PolicyContext.registerHandler(key, discovered != null ? new DelegatingPolicyContextHandler(key, handler, discovered) : handler, true);\n+                        } else {\n+                            PolicyContext.registerHandler(key, handler, true);\n                         }\n-                    };\n+                    }\n                 }\n \n-                private PolicyContextHandler createSubjectPolicyContextHandler() {\n-                    return new PolicyContextHandler() {\n-                        // in case applications are using legacy (PicketBox) security infrastructure\n-                        SubjectPolicyContextHandler legacy = new SubjectPolicyContextHandler();\n-\n-                        @Override\n-                        public Object getContext(String key, Object data) throws PolicyContextException {\n-                            if (supports(key)) {\n-                                SecurityIdentity securityIdentity = (SecurityIdentity) PolicyContext.getContext(SecurityIdentity.class.getName());\n-\n-                                if (securityIdentity == null) {\n-                                    return legacy.getContext(key, data);\n-                                }\n-\n-                                return SubjectUtil.fromSecurityIdentity(securityIdentity);\n+                private Map<String, PolicyContextHandler> discoverPolicyContextHandlers() throws PolicyContextException {\n+                    Map<String, PolicyContextHandler> handlerMap = new HashMap<>();\n+                    ServiceLoader<PolicyContextHandler> serviceLoader = ServiceLoader.load(PolicyContextHandler.class, PolicyDefinitions.class.getClassLoader());\n+                    for (PolicyContextHandler handler : serviceLoader) {\n+                        for (String key : handler.getKeys()) {\n+                            if (handlerMap.put(key, handler) != null) {\n+                                throw ElytronSubsystemMessages.ROOT_LOGGER.duplicatePolicyContextHandler(key);\n+                            }\n+                            if (ElytronSubsystemMessages.ROOT_LOGGER.isTraceEnabled()) {\n+                                ElytronSubsystemMessages.ROOT_LOGGER.tracef(\"Discovered PolicyContextHandler '%s' for key '%s'.\", handler.getClass().getName(), key);\n                             }\n-\n-                            return null;\n-                        }\n-\n-                        @Override\n-                        public String[] getKeys() throws PolicyContextException {\n-                            return legacy.getKeys();\n                         }\n+                    }\n \n-                        @Override\n-                        public boolean supports(String key) throws PolicyContextException {\n-                            return legacy.supports(key);\n-                        }\n-                    };\n+                    return handlerMap;\n                 }\n+\n             };\n         }\n \n         return null;\n     }\n \n-    private static Policy newPolicy(String className, String module) {\n+    private static Policy newPolicy(String className, ClassLoader classLoader) {\n         try {\n-            ClassLoader classLoader = ClassLoadingAttributeDefinitions.resolveClassLoader(module);\n             Object policy = classLoader.loadClass(className).newInstance();\n             return Policy.class.cast(policy);\n         } catch (Exception e) {\n             throw ElytronSubsystemMessages.ROOT_LOGGER.failedToCreatePolicy(className, e);\n         }\n     }\n \n-    /**\n-     * Utilities for dealing with {@link Subject}.\n-     *\n-     * @author <a href=\"mailto:sguilhen@redhat.com\">Stefan Guilhen</a>\n-     */\n-    static final class SubjectUtil {\n-\n-        /**\n-         * Converts the supplied {@link SecurityIdentity} into a {@link Subject}.\n-         *\n-         * @param securityIdentity the {@link SecurityIdentity} to be converted.\n-         * @return the constructed {@link Subject} instance.\n-         */\n-        static Subject fromSecurityIdentity(final SecurityIdentity securityIdentity) {\n-            Assert.checkNotNullParam(\"securityIdentity\", securityIdentity);\n-            Subject subject = new Subject();\n-            subject.getPrincipals().add(securityIdentity.getPrincipal());\n-\n-            // add the 'Roles' group to the subject containing the identity's mapped roles.\n-            Group rolesGroup = new SimpleGroup(\"Roles\");\n-            for (String role : securityIdentity.getRoles()) {\n-                rolesGroup.addMember(new NamePrincipal(role));\n-            }\n-            subject.getPrincipals().add(rolesGroup);\n-\n-            // add a 'CallerPrincipal' group containing the identity's principal.\n-            Group callerPrincipalGroup = new SimpleGroup(\"CallerPrincipal\");\n-            callerPrincipalGroup.addMember(securityIdentity.getPrincipal());\n-            subject.getPrincipals().add(callerPrincipalGroup);\n-\n-            // process the identity's public and private credentials.\n-            for (Credential credential : securityIdentity.getPublicCredentials()) {\n-                if (credential instanceof PublicKeyCredential) {\n-                    subject.getPublicCredentials().add(credential.castAs(PublicKeyCredential.class).getPublicKey());\n-                }\n-                else if (credential instanceof X509CertificateChainPublicCredential) {\n-                    subject.getPublicCredentials().add(credential.castAs(X509CertificateChainPublicCredential.class).getCertificateChain());\n-                }\n-                else {\n-                    subject.getPublicCredentials().add(credential);\n-                }\n-            }\n+    private static PolicyConfigurationFactory newPolicyConfigurationFactory(String className, ClassLoader classLoader) throws PolicyContextException, ClassNotFoundException {\n+        final ClassLoader original = Thread.currentThread().getContextClassLoader();\n \n-            for (Credential credential : doPrivileged((PrivilegedAction<IdentityCredentials>) securityIdentity::getPrivateCredentials)) {\n-                if (credential instanceof PasswordCredential) {\n-                    addPrivateCredential(subject, credential.castAs(PasswordCredential.class).getPassword());\n-                }\n-                else if (credential instanceof SecretKeyCredential) {\n-                    addPrivateCredential(subject, credential.castAs(SecretKeyCredential.class).getSecretKey());\n-                }\n-                else if (credential instanceof KeyPairCredential) {\n-                    addPrivateCredential(subject, credential.castAs(KeyPairCredential.class).getKeyPair());\n-                }\n-                else if (credential instanceof X509CertificateChainPrivateCredential) {\n-                    addPrivateCredential(subject, credential.castAs(X509CertificateChainPrivateCredential.class).getCertificateChain());\n-                }\n-                else {\n-                    addPrivateCredential(subject, credential);\n-                }\n+        try {\n+            Thread.currentThread().setContextClassLoader(classLoader);\n+            System.setProperty(PolicyConfigurationFactory.class.getName() + \".provider\", className);", "originalCommit": "8180e29c479bf8f65b9ddf7814aebd6dd4ff5f4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3MTcyOA==", "url": "https://github.com/wildfly/wildfly-core/pull/4267#discussion_r464371728", "bodyText": "TBH after setting it and triggering the initialisation clearing it has no effect, without restarting the process it is not possible to clear the previous result.\nTBH compared to some of the other specs this seems to be a gap in JACC that was can't manually swap in a different implementation / instance.", "author": "darranl", "createdAt": "2020-08-03T12:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0MTAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg2MTU0OA==", "url": "https://github.com/wildfly/wildfly-core/pull/4267#discussion_r464861548", "bodyText": "ok, thanks for the explanation", "author": "jmesnil", "createdAt": "2020-08-04T07:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0MTAyOQ=="}], "type": "inlineReview"}, {"oid": "a45d099fdc37c63cc9e40a5101a3845ed3b94ad8", "url": "https://github.com/wildfly/wildfly-core/commit/a45d099fdc37c63cc9e40a5101a3845ed3b94ad8", "message": "[WFCORE-5020] Ensure the Elytron AuthConfigFactory is used so we don't fall back to the PicketBox implementation.", "committedDate": "2020-08-04T09:53:21Z", "type": "commit"}]}