{"pr_number": 4072, "pr_title": "DHFPROD-4786: Facet by time window based on when an entity instance was created", "pr_createdAt": "2020-06-09T00:57:19Z", "pr_url": "https://github.com/marklogic/marklogic-data-hub/pull/4072", "timeline": [{"oid": "bbd02235b61fda39a993839001c4679624bd679a", "url": "https://github.com/marklogic/marklogic-data-hub/commit/bbd02235b61fda39a993839001c4679624bd679a", "message": "DHFPROD-4786: Facet by time window based on when an entity instance was created\n\nDHFPROD-4786: sidebar test", "committedDate": "2020-06-09T05:41:15Z", "type": "forcePushed"}, {"oid": "e9c2930e0a4ae2d2af0cf526bfbf189021d7385d", "url": "https://github.com/marklogic/marklogic-data-hub/commit/e9c2930e0a4ae2d2af0cf526bfbf189021d7385d", "message": "DHFPROD-4786: Facet by time window based on when an entity instance was created\n\nDHFPROD-4786: Tests", "committedDate": "2020-06-09T12:47:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3NDc2NA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437474764", "bodyText": "To make this code easier to understand, move the guts of each case into a private method. That'll slim down this method - which I also think should be protected (if you want to access it via a unit test) or private, definitely not public.", "author": "rjrudin", "createdAt": "2020-06-09T14:38:34Z", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/entities/search/impl/CreatedOnFacetHandler.java", "diffHunk": "@@ -21,33 +21,91 @@\n import com.marklogic.hub.central.entities.search.Constants;\n import com.marklogic.hub.central.entities.search.FacetHandler;\n import com.marklogic.hub.central.entities.search.models.DocSearchQueryInfo;\n+import com.marklogic.hub.central.exceptions.DataHubException;\n \n import java.time.LocalDate;\n import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.TemporalAdjusters;\n+import java.util.HashMap;\n+import java.util.Map;\n \n public class CreatedOnFacetHandler implements FacetHandler {\n \n-    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n-    private static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter\n-            .ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n+    public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ssZ\");\n \n     @Override\n     public StructuredQueryDefinition buildQuery(DocSearchQueryInfo.FacetData data, StructuredQueryBuilder queryBuilder) {\n-        // Converting the date in string format from yyyy-MM-dd format to yyyy-MM-dd HH:mm:ss format\n-        LocalDate startDate = LocalDate.parse(data.getRangeValues().getLowerBound(), DATE_FORMAT);\n-        String startDateTime = startDate.atStartOfDay(ZoneId.systemDefault())\n-                .format(DATE_TIME_FORMAT);\n+        Map<String, String> dateRange = computeDateRange(data);\n+        return queryBuilder.and(\n+            queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.GE, dateRange.get(\"startDateTime\")),\n+            queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.LT, dateRange.get(\"endDateTime\"))\n+        );\n+    }\n+\n+    public Map<String, String> computeDateRange(DocSearchQueryInfo.FacetData data) {\n+        Map<String, String> dateRange = new HashMap<>();\n+        String timeRange = \"Custom\";\n+        int zoneOffset = 0;\n+\n+        if(data.getStringValues().size() > 0) {\n+            timeRange = data.getStringValues().get(0);\n+        }\n+\n+        if(data.getStringValues().size() > 1) {\n+            zoneOffset = Integer.parseInt(data.getStringValues().get(1));\n+        }\n+\n+        ZoneId zoneId = ZoneId.ofOffset(\"UTC\", ZoneOffset.ofTotalSeconds(zoneOffset*60));\n+        ZonedDateTime startDate = LocalDate.now().atStartOfDay(zoneId);\n+        ZonedDateTime endDate = LocalDate.now().atStartOfDay(zoneId);\n+        String startDateTime;\n+        String endDateTime;\n+\n+        switch (timeRange) {\n+            case \"Today\":", "originalCommit": "e9c2930e0a4ae2d2af0cf526bfbf189021d7385d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3NjMxNw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437476317", "bodyText": "Because you have 4 cases in your switch in the implementation, I'd expect at least 4 separate test methods. And because of the presence of \"if\" and \"try\" blocks for \"Custom\", I'd expect multiple test methods for that case, one for each scenario. This will be much more readable than one long test that covers different scenarios, and it'll be easier to debug if/when one of the scenarios breaks.", "author": "rjrudin", "createdAt": "2020-06-09T14:40:35Z", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/entities/search/impl/CreatedOnFacetHandlerTest.java", "diffHunk": "@@ -32,10 +41,73 @@ public void testCreatedOnDateRangeFacet() {\n         Fragment fragment = toFragment(queryDefinition);\n \n         assertEquals(Arrays.asList(constraintName, constraintName), fragment.getElementValues(\"//search:constraint-name\"));\n-        assertTrue(fragment.getElementValue(\"//search:value[../search:range-operator='GE']\").contains(lowerBound),\n-                \"Expected lower bound to include: \" + lowerBound);\n+        assertTrue(fragment.getElementValue(\"//search:value[../search:range-operator='GE']\").contains(expectedLowerBound),\n+                \"Expected lower bound to include: \" + expectedLowerBound);\n         assertTrue(fragment.getElementValue(\"//search:value[../search:range-operator='LT']\").contains(expectedUpperBound),\n                 \"Upper bound is one day more than what was passed in order to include the passed in date as well\" +\n                         \" for comparison. Expected upper bound to include: \" + expectedUpperBound);\n     }\n+\n+    @Test\n+    public void testComputeDateRangeTimeWindows() {\n+        String zoneOffset = \"-420\";\n+        ZoneId zoneId = ZoneId.ofOffset(\"UTC\", ZoneOffset.ofTotalSeconds(Integer.parseInt(zoneOffset)*60));\n+        DocSearchQueryInfo.FacetData facetData = new DocSearchQueryInfo.FacetData();\n+        DocSearchQueryInfo.RangeValues rangeValues = new DocSearchQueryInfo.RangeValues();\n+\n+        // For time window Today.", "originalCommit": "e9c2930e0a4ae2d2af0cf526bfbf189021d7385d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "98a962250cc0279bce03c6964798548980619a26", "url": "https://github.com/marklogic/marklogic-data-hub/commit/98a962250cc0279bce03c6964798548980619a26", "message": "DHFPROD-4786: Facet by time window based on when an entity instance was created\n\nDHFPROD-4786: Tests", "committedDate": "2020-06-09T16:09:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU2MjE1MA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437562150", "bodyText": "These can't be class fields, because EntitySearchManager is storing one instance of it in a static map that is used for all threads. So we'll get thread-safety issues on this and possibly incorrect results.\nA good rule of thumb is that if you have a set of fields that are associated with one another, toss them into a class. So instead of making these class fields of CreatedOnFacetHandler, make an e.g. CreatedOnFacetInputs class and create a new instance of that when buildQuery is called, and then pass it to each case method. This avoids thread-safety issues and reduces the amount of state (which is generally good - the more state, the more problems there are).", "author": "rjrudin", "createdAt": "2020-06-09T16:27:04Z", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/entities/search/impl/CreatedOnFacetHandler.java", "diffHunk": "@@ -21,33 +21,115 @@\n import com.marklogic.hub.central.entities.search.Constants;\n import com.marklogic.hub.central.entities.search.FacetHandler;\n import com.marklogic.hub.central.entities.search.models.DocSearchQueryInfo;\n+import com.marklogic.hub.central.exceptions.DataHubException;\n \n import java.time.LocalDate;\n import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.TemporalAdjusters;\n+import java.util.HashMap;\n+import java.util.Map;\n \n public class CreatedOnFacetHandler implements FacetHandler {\n \n-    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n-    private static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter\n-            .ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n+    public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ssZ\");\n+\n+    int zoneOffset = 0;", "originalCommit": "98a962250cc0279bce03c6964798548980619a26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU2MjYwNg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437562606", "bodyText": "Storing these as class fields is fine because we don't have to worry about multiple threads running this same test instance.", "author": "rjrudin", "createdAt": "2020-06-09T16:27:46Z", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/entities/search/impl/CreatedOnFacetHandlerTest.java", "diffHunk": "@@ -4,38 +4,171 @@\n import com.marklogic.client.query.StructuredQueryDefinition;\n import com.marklogic.hub.central.entities.search.Constants;\n import com.marklogic.hub.central.entities.search.models.DocSearchQueryInfo;\n+import com.marklogic.hub.central.exceptions.DataHubException;\n import com.marklogic.rest.util.Fragment;\n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n+import java.time.Duration;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public class CreatedOnFacetHandlerTest extends AbstractFacetHandlerTest {\n \n+    List<String> stringValues;\n+    Map<String, String> dateRange;\n+\n+    CreatedOnFacetHandler createdOnFacetHandler;", "originalCommit": "98a962250cc0279bce03c6964798548980619a26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "defc8dfb28db7d03a504f371e09205be156e3bf0", "url": "https://github.com/marklogic/marklogic-data-hub/commit/defc8dfb28db7d03a504f371e09205be156e3bf0", "message": "DHFPROD-4786: Facet by time window based on when an entity instance was created\n\nDHFPROD-4786: Tests", "committedDate": "2020-06-09T17:20:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYyNjc5NA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437626794", "bodyText": "It's fine to pass CreatedOnFacetInputs in here, but you don't really need to because the caller doesn't care about it. You can just instantiate it within this method. No need to change though.", "author": "rjrudin", "createdAt": "2020-06-09T18:16:10Z", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/entities/search/impl/CreatedOnFacetHandler.java", "diffHunk": "@@ -21,33 +21,113 @@\n import com.marklogic.hub.central.entities.search.Constants;\n import com.marklogic.hub.central.entities.search.FacetHandler;\n import com.marklogic.hub.central.entities.search.models.DocSearchQueryInfo;\n+import com.marklogic.hub.central.exceptions.DataHubException;\n \n import java.time.LocalDate;\n import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.TemporalAdjusters;\n+import java.util.HashMap;\n+import java.util.Map;\n \n public class CreatedOnFacetHandler implements FacetHandler {\n \n-    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n-    private static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter\n-            .ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n+    public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ssZ\");\n \n     @Override\n     public StructuredQueryDefinition buildQuery(DocSearchQueryInfo.FacetData data, StructuredQueryBuilder queryBuilder) {\n-        // Converting the date in string format from yyyy-MM-dd format to yyyy-MM-dd HH:mm:ss format\n-        LocalDate startDate = LocalDate.parse(data.getRangeValues().getLowerBound(), DATE_FORMAT);\n-        String startDateTime = startDate.atStartOfDay(ZoneId.systemDefault())\n-                .format(DATE_TIME_FORMAT);\n+        Map<String, String> dateRange = computeDateRange(data, new CreatedOnFacetInputs());\n+        return queryBuilder.and(\n+            queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.GE, dateRange.get(\"startDateTime\")),\n+            queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.LT, dateRange.get(\"endDateTime\"))\n+        );\n+    }\n+\n+    protected Map<String, String> computeDateRange(DocSearchQueryInfo.FacetData data, CreatedOnFacetInputs facetInputs) {", "originalCommit": "defc8dfb28db7d03a504f371e09205be156e3bf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDQzMg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437650432", "bodyText": "Method getTodayTimeWindow also uses the same code, maybe we can extract common code into a method.", "author": "akshaysonvane", "createdAt": "2020-06-09T18:57:31Z", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/entities/search/impl/CreatedOnFacetHandler.java", "diffHunk": "@@ -21,33 +21,113 @@\n import com.marklogic.hub.central.entities.search.Constants;\n import com.marklogic.hub.central.entities.search.FacetHandler;\n import com.marklogic.hub.central.entities.search.models.DocSearchQueryInfo;\n+import com.marklogic.hub.central.exceptions.DataHubException;\n \n import java.time.LocalDate;\n import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.TemporalAdjusters;\n+import java.util.HashMap;\n+import java.util.Map;\n \n public class CreatedOnFacetHandler implements FacetHandler {\n \n-    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n-    private static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter\n-            .ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n+    public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ssZ\");\n \n     @Override\n     public StructuredQueryDefinition buildQuery(DocSearchQueryInfo.FacetData data, StructuredQueryBuilder queryBuilder) {\n-        // Converting the date in string format from yyyy-MM-dd format to yyyy-MM-dd HH:mm:ss format\n-        LocalDate startDate = LocalDate.parse(data.getRangeValues().getLowerBound(), DATE_FORMAT);\n-        String startDateTime = startDate.atStartOfDay(ZoneId.systemDefault())\n-                .format(DATE_TIME_FORMAT);\n+        Map<String, String> dateRange = computeDateRange(data, new CreatedOnFacetInputs());\n+        return queryBuilder.and(\n+            queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.GE, dateRange.get(\"startDateTime\")),\n+            queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.LT, dateRange.get(\"endDateTime\"))\n+        );\n+    }\n+\n+    protected Map<String, String> computeDateRange(DocSearchQueryInfo.FacetData data, CreatedOnFacetInputs facetInputs) {\n+\n+        if(data.getStringValues().size() > 0) {\n+            facetInputs.timeRange = data.getStringValues().get(0);\n+        }\n+\n+        if(data.getStringValues().size() > 1) {\n+            facetInputs.zoneOffset = Integer.parseInt(data.getStringValues().get(1));\n+        }\n+\n+        facetInputs.zoneId = ZoneId.ofOffset(\"UTC\", ZoneOffset.ofTotalSeconds(facetInputs.zoneOffset*60));\n+        facetInputs.startDate = LocalDate.now().atStartOfDay(facetInputs.zoneId);\n+        facetInputs.endDate = LocalDate.now().atStartOfDay(facetInputs.zoneId);\n+\n+        switch (facetInputs.timeRange) {\n+            case \"Today\":\n+                getTodayTimeWindow(facetInputs);\n+                break;\n+\n+            case \"This Week\":\n+                getThisWeekTimeWindow(facetInputs);\n+                break;\n+\n+            case \"This Month\":\n+                getThisMonthTimeWindow(facetInputs);\n+                break;\n \n-        // Converting the date in string format from yyyy-MM-dd format to yyyy-MM-dd HH:mm:ss format\n-        // Adding 1 day to end date to get docs harmonized on the end date as well.\n-        LocalDate endDate = LocalDate.parse(data.getRangeValues().getUpperBound(), DATE_FORMAT)\n-                .plusDays(1);\n-        String endDateTime = endDate.atStartOfDay(ZoneId.systemDefault()).format(DATE_TIME_FORMAT);\n+            case \"Custom\":\n+                getCustomTimeWindow(data, facetInputs);\n+                break;\n+        }\n+        return facetInputs.dateRange;\n+    }\n+\n+    private void getTodayTimeWindow(CreatedOnFacetInputs facetInputs) {\n+        facetInputs.startDateTime = facetInputs.startDate.toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"startDateTime\", facetInputs.startDateTime);\n+        facetInputs.endDateTime = facetInputs.endDate.plusDays(1).toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"endDateTime\", facetInputs.endDateTime);\n+    }\n+\n+    private void getThisWeekTimeWindow(CreatedOnFacetInputs facetInputs) {\n+        facetInputs.startDateTime = facetInputs.startDate.plusDays((-1) * (facetInputs.startDate.getDayOfWeek().getValue() % 7)).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"startDateTime\", facetInputs.startDateTime);\n+        facetInputs.endDateTime = facetInputs.endDate.plusDays(1).toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"endDateTime\", facetInputs.endDateTime);\n+    }\n+\n+    private void getThisMonthTimeWindow(CreatedOnFacetInputs facetInputs) {\n+        facetInputs.startDate = facetInputs.startDate.with(TemporalAdjusters.firstDayOfMonth());\n+        facetInputs.startDateTime = facetInputs.startDate.toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"startDateTime\", facetInputs.startDateTime);\n+        facetInputs.endDateTime = facetInputs.endDate.plusDays(1).toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"endDateTime\", facetInputs.endDateTime);", "originalCommit": "defc8dfb28db7d03a504f371e09205be156e3bf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1OTQ3MQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437659471", "bodyText": "No it doesn't. facetInputs.startDate = facetInputs.startDate.with(TemporalAdjusters.firstDayOfMonth());\nis used here.\nfacetInputs.startDateTime = facetInputs.startDate.toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\nThis is the only common line.", "author": "rahulvudutala", "createdAt": "2020-06-09T19:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDQzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2ODM0OQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437668349", "bodyText": "I meant lines 99 to 102.", "author": "akshaysonvane", "createdAt": "2020-06-09T19:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDcxNA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437650714", "bodyText": "It seems that FE now sends both date and time. Do we still need to add a day any more if that's the case?\nCan we use startTime >= && <=endTime for comparison making this more accurate?\nSince the FE still uses a DatePicker and not DateTimePicker maybe we can add the day over there. This would make the BE not deal with the wonky logic of adding days. Also, this would mean when we introduce a DateTimePicker in the FE we don't have to change the BE to support it.", "author": "akshaysonvane", "createdAt": "2020-06-09T18:58:01Z", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/entities/search/impl/CreatedOnFacetHandler.java", "diffHunk": "@@ -21,33 +21,113 @@\n import com.marklogic.hub.central.entities.search.Constants;\n import com.marklogic.hub.central.entities.search.FacetHandler;\n import com.marklogic.hub.central.entities.search.models.DocSearchQueryInfo;\n+import com.marklogic.hub.central.exceptions.DataHubException;\n \n import java.time.LocalDate;\n import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.TemporalAdjusters;\n+import java.util.HashMap;\n+import java.util.Map;\n \n public class CreatedOnFacetHandler implements FacetHandler {\n \n-    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n-    private static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter\n-            .ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n+    public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ssZ\");\n \n     @Override\n     public StructuredQueryDefinition buildQuery(DocSearchQueryInfo.FacetData data, StructuredQueryBuilder queryBuilder) {\n-        // Converting the date in string format from yyyy-MM-dd format to yyyy-MM-dd HH:mm:ss format\n-        LocalDate startDate = LocalDate.parse(data.getRangeValues().getLowerBound(), DATE_FORMAT);\n-        String startDateTime = startDate.atStartOfDay(ZoneId.systemDefault())\n-                .format(DATE_TIME_FORMAT);\n+        Map<String, String> dateRange = computeDateRange(data, new CreatedOnFacetInputs());\n+        return queryBuilder.and(\n+            queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.GE, dateRange.get(\"startDateTime\")),\n+            queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.LT, dateRange.get(\"endDateTime\"))\n+        );\n+    }\n+\n+    protected Map<String, String> computeDateRange(DocSearchQueryInfo.FacetData data, CreatedOnFacetInputs facetInputs) {\n+\n+        if(data.getStringValues().size() > 0) {\n+            facetInputs.timeRange = data.getStringValues().get(0);\n+        }\n+\n+        if(data.getStringValues().size() > 1) {\n+            facetInputs.zoneOffset = Integer.parseInt(data.getStringValues().get(1));\n+        }\n+\n+        facetInputs.zoneId = ZoneId.ofOffset(\"UTC\", ZoneOffset.ofTotalSeconds(facetInputs.zoneOffset*60));\n+        facetInputs.startDate = LocalDate.now().atStartOfDay(facetInputs.zoneId);\n+        facetInputs.endDate = LocalDate.now().atStartOfDay(facetInputs.zoneId);\n+\n+        switch (facetInputs.timeRange) {\n+            case \"Today\":\n+                getTodayTimeWindow(facetInputs);\n+                break;\n+\n+            case \"This Week\":\n+                getThisWeekTimeWindow(facetInputs);\n+                break;\n+\n+            case \"This Month\":\n+                getThisMonthTimeWindow(facetInputs);\n+                break;\n \n-        // Converting the date in string format from yyyy-MM-dd format to yyyy-MM-dd HH:mm:ss format\n-        // Adding 1 day to end date to get docs harmonized on the end date as well.\n-        LocalDate endDate = LocalDate.parse(data.getRangeValues().getUpperBound(), DATE_FORMAT)\n-                .plusDays(1);\n-        String endDateTime = endDate.atStartOfDay(ZoneId.systemDefault()).format(DATE_TIME_FORMAT);\n+            case \"Custom\":\n+                getCustomTimeWindow(data, facetInputs);\n+                break;\n+        }\n+        return facetInputs.dateRange;\n+    }\n+\n+    private void getTodayTimeWindow(CreatedOnFacetInputs facetInputs) {\n+        facetInputs.startDateTime = facetInputs.startDate.toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"startDateTime\", facetInputs.startDateTime);\n+        facetInputs.endDateTime = facetInputs.endDate.plusDays(1).toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"endDateTime\", facetInputs.endDateTime);\n+    }\n+\n+    private void getThisWeekTimeWindow(CreatedOnFacetInputs facetInputs) {\n+        facetInputs.startDateTime = facetInputs.startDate.plusDays((-1) * (facetInputs.startDate.getDayOfWeek().getValue() % 7)).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"startDateTime\", facetInputs.startDateTime);\n+        facetInputs.endDateTime = facetInputs.endDate.plusDays(1).toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"endDateTime\", facetInputs.endDateTime);\n+    }\n+\n+    private void getThisMonthTimeWindow(CreatedOnFacetInputs facetInputs) {\n+        facetInputs.startDate = facetInputs.startDate.with(TemporalAdjusters.firstDayOfMonth());\n+        facetInputs.startDateTime = facetInputs.startDate.toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"startDateTime\", facetInputs.startDateTime);\n+        facetInputs.endDateTime = facetInputs.endDate.plusDays(1).toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"endDateTime\", facetInputs.endDateTime);\n+    }\n \n-        return queryBuilder\n-                .and(queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.GE, startDateTime),\n-                        queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.LT, endDateTime));\n+    private void getCustomTimeWindow(DocSearchQueryInfo.FacetData data, CreatedOnFacetInputs facetInputs) {\n+        if(!data.getRangeValues().getLowerBound().isEmpty() && !data.getRangeValues().getUpperBound().isEmpty()) {\n+            try {\n+                facetInputs.startDateTime = ZonedDateTime.parse(data.getRangeValues().getLowerBound()).format(DATE_TIME_FORMAT);\n+                facetInputs.endDateTime = ZonedDateTime.parse(data.getRangeValues().getUpperBound()).plusDays(1).format(DATE_TIME_FORMAT);", "originalCommit": "defc8dfb28db7d03a504f371e09205be156e3bf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MzU2MA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437653560", "bodyText": "Date and time for entity properties. We still have a date picker for hub properties\nIt is more accurate doing < than <= as we don't know appropriate end time for a date.\nThe feature supports client zone offset. To work with zone it has to be date-time, So converted to date-time even if date picker is used", "author": "rahulvudutala", "createdAt": "2020-06-09T19:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MzYwOQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437673609", "bodyText": "I meant can we add the day in the FE since the only reason we need to add a day here is that we use a date picker and not a date-time picker. Since this seems to be a FE dependency maybe the hack should also be in the FE.\nMoving the logic to the FE would make BE work correctly for all date-time ranges and if/when we add the date-time picker in the FE we dont have to make any changes since we already support the right thing.", "author": "akshaysonvane", "createdAt": "2020-06-09T19:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3NTQ0MQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437675441", "bodyText": "The date picker value will change, as we display the same object. Its not just FE, even if the endpoint is hit, it should return the same results no different from UI", "author": "rahulvudutala", "createdAt": "2020-06-09T19:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDg0OQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4072#discussion_r437650849", "bodyText": "We can have protected access for the class.", "author": "akshaysonvane", "createdAt": "2020-06-09T18:58:15Z", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/entities/search/impl/CreatedOnFacetHandler.java", "diffHunk": "@@ -21,33 +21,113 @@\n import com.marklogic.hub.central.entities.search.Constants;\n import com.marklogic.hub.central.entities.search.FacetHandler;\n import com.marklogic.hub.central.entities.search.models.DocSearchQueryInfo;\n+import com.marklogic.hub.central.exceptions.DataHubException;\n \n import java.time.LocalDate;\n import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.TemporalAdjusters;\n+import java.util.HashMap;\n+import java.util.Map;\n \n public class CreatedOnFacetHandler implements FacetHandler {\n \n-    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n-    private static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter\n-            .ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n+    public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ssZ\");\n \n     @Override\n     public StructuredQueryDefinition buildQuery(DocSearchQueryInfo.FacetData data, StructuredQueryBuilder queryBuilder) {\n-        // Converting the date in string format from yyyy-MM-dd format to yyyy-MM-dd HH:mm:ss format\n-        LocalDate startDate = LocalDate.parse(data.getRangeValues().getLowerBound(), DATE_FORMAT);\n-        String startDateTime = startDate.atStartOfDay(ZoneId.systemDefault())\n-                .format(DATE_TIME_FORMAT);\n+        Map<String, String> dateRange = computeDateRange(data, new CreatedOnFacetInputs());\n+        return queryBuilder.and(\n+            queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.GE, dateRange.get(\"startDateTime\")),\n+            queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.LT, dateRange.get(\"endDateTime\"))\n+        );\n+    }\n+\n+    protected Map<String, String> computeDateRange(DocSearchQueryInfo.FacetData data, CreatedOnFacetInputs facetInputs) {\n+\n+        if(data.getStringValues().size() > 0) {\n+            facetInputs.timeRange = data.getStringValues().get(0);\n+        }\n+\n+        if(data.getStringValues().size() > 1) {\n+            facetInputs.zoneOffset = Integer.parseInt(data.getStringValues().get(1));\n+        }\n+\n+        facetInputs.zoneId = ZoneId.ofOffset(\"UTC\", ZoneOffset.ofTotalSeconds(facetInputs.zoneOffset*60));\n+        facetInputs.startDate = LocalDate.now().atStartOfDay(facetInputs.zoneId);\n+        facetInputs.endDate = LocalDate.now().atStartOfDay(facetInputs.zoneId);\n+\n+        switch (facetInputs.timeRange) {\n+            case \"Today\":\n+                getTodayTimeWindow(facetInputs);\n+                break;\n+\n+            case \"This Week\":\n+                getThisWeekTimeWindow(facetInputs);\n+                break;\n+\n+            case \"This Month\":\n+                getThisMonthTimeWindow(facetInputs);\n+                break;\n \n-        // Converting the date in string format from yyyy-MM-dd format to yyyy-MM-dd HH:mm:ss format\n-        // Adding 1 day to end date to get docs harmonized on the end date as well.\n-        LocalDate endDate = LocalDate.parse(data.getRangeValues().getUpperBound(), DATE_FORMAT)\n-                .plusDays(1);\n-        String endDateTime = endDate.atStartOfDay(ZoneId.systemDefault()).format(DATE_TIME_FORMAT);\n+            case \"Custom\":\n+                getCustomTimeWindow(data, facetInputs);\n+                break;\n+        }\n+        return facetInputs.dateRange;\n+    }\n+\n+    private void getTodayTimeWindow(CreatedOnFacetInputs facetInputs) {\n+        facetInputs.startDateTime = facetInputs.startDate.toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"startDateTime\", facetInputs.startDateTime);\n+        facetInputs.endDateTime = facetInputs.endDate.plusDays(1).toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"endDateTime\", facetInputs.endDateTime);\n+    }\n+\n+    private void getThisWeekTimeWindow(CreatedOnFacetInputs facetInputs) {\n+        facetInputs.startDateTime = facetInputs.startDate.plusDays((-1) * (facetInputs.startDate.getDayOfWeek().getValue() % 7)).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"startDateTime\", facetInputs.startDateTime);\n+        facetInputs.endDateTime = facetInputs.endDate.plusDays(1).toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"endDateTime\", facetInputs.endDateTime);\n+    }\n+\n+    private void getThisMonthTimeWindow(CreatedOnFacetInputs facetInputs) {\n+        facetInputs.startDate = facetInputs.startDate.with(TemporalAdjusters.firstDayOfMonth());\n+        facetInputs.startDateTime = facetInputs.startDate.toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"startDateTime\", facetInputs.startDateTime);\n+        facetInputs.endDateTime = facetInputs.endDate.plusDays(1).toLocalDate().atStartOfDay(facetInputs.zoneId).format(DATE_TIME_FORMAT);\n+        facetInputs.dateRange.put(\"endDateTime\", facetInputs.endDateTime);\n+    }\n \n-        return queryBuilder\n-                .and(queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.GE, startDateTime),\n-                        queryBuilder.rangeConstraint(Constants.CREATED_ON_CONSTRAINT_NAME, StructuredQueryBuilder.Operator.LT, endDateTime));\n+    private void getCustomTimeWindow(DocSearchQueryInfo.FacetData data, CreatedOnFacetInputs facetInputs) {\n+        if(!data.getRangeValues().getLowerBound().isEmpty() && !data.getRangeValues().getUpperBound().isEmpty()) {\n+            try {\n+                facetInputs.startDateTime = ZonedDateTime.parse(data.getRangeValues().getLowerBound()).format(DATE_TIME_FORMAT);\n+                facetInputs.endDateTime = ZonedDateTime.parse(data.getRangeValues().getUpperBound()).plusDays(1).format(DATE_TIME_FORMAT);\n+            } catch (DateTimeParseException dtpe) {\n+                facetInputs.startDate = LocalDate.parse(data.getRangeValues().getLowerBound()).atStartOfDay().atZone(ZoneOffset.UTC);\n+                facetInputs.endDate = LocalDate.parse(data.getRangeValues().getUpperBound()).atStartOfDay().atZone(ZoneOffset.UTC);\n+                facetInputs.startDateTime = facetInputs.startDate.format(DATE_TIME_FORMAT);\n+                facetInputs.endDateTime = facetInputs.endDate.plusDays(1).format(DATE_TIME_FORMAT);\n+            }\n+            facetInputs.dateRange.put(\"startDateTime\", facetInputs.startDateTime);\n+            facetInputs.dateRange.put(\"endDateTime\", facetInputs.endDateTime);\n+        } else {\n+            throw new DataHubException(\"The date range is missing for createdOn in your request\");\n+        }\n+    }\n \n+    public static final class CreatedOnFacetInputs {", "originalCommit": "defc8dfb28db7d03a504f371e09205be156e3bf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c83a5d59fb07dd5e0a774171a495468838ef55f", "url": "https://github.com/marklogic/marklogic-data-hub/commit/5c83a5d59fb07dd5e0a774171a495468838ef55f", "message": "DHFPROD-4786: Facet by time window based on when an entity instance was created\n\nDHFPROD-4786: Tests and integration test fixes", "committedDate": "2020-06-09T19:09:28Z", "type": "commit"}, {"oid": "5c83a5d59fb07dd5e0a774171a495468838ef55f", "url": "https://github.com/marklogic/marklogic-data-hub/commit/5c83a5d59fb07dd5e0a774171a495468838ef55f", "message": "DHFPROD-4786: Facet by time window based on when an entity instance was created\n\nDHFPROD-4786: Tests and integration test fixes", "committedDate": "2020-06-09T19:09:28Z", "type": "forcePushed"}]}