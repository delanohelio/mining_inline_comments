{"pr_number": 3862, "pr_title": "DHFPROD-4226: Export rows as csv", "pr_createdAt": "2020-04-22T22:38:55Z", "pr_url": "https://github.com/marklogic/marklogic-data-hub/pull/3862", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODMxNg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413458316", "bodyText": "I've worked on projects before where we create a lot of test files that are stored in version control, and it can quickly become difficult to manage. I think it's far better in the long term to write a simple program to generate documents in memory and write them to ML. It's fewer files in version control, and it's easier to change.\nRight now, it doesn't look like the test cares what's in the documents, though I think it should - shouldn't it be verifying that the correct value is present in each column in each row?\nFor that reason, I would only insert 2 test documents (generally, there's zero, there's 1, and then there's 2 or more). And I'd only request maybe 3 columns. Now you only need to verify 6 values. And since you have 2 test documents, you can have a separate test that passes in a limit of 1, and you can verify you only get 1 row back.\nWith that in mind, I'd design a bare minimum test document - no headers, no triples, no attachments. And if you're only requesting 3 properties, I'd populate 4 total properties - that allows you to verify that when you ask for 3 of them, you don't get the 4th. Then, make a simple method in here that allows you to insert a document with 3 known values.\nAlso, let's use the entity-reference-model project. The Customer entity has three atomic properties so far - customerId, name, and customerSince. Feel free to add a fourth atomic property for your test. That avoids having to create a new example project, and the more tests we have using the same sample project, the easier it is to understand the tests.", "author": "rjrudin", "createdAt": "2020-04-23T02:15:15Z", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +77,122 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installExportProject();\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Order\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Order\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"sku\\\",\\n\" +\n+            \"            \\\"title\\\",\\n\" +\n+            \"            \\\"price\\\",\\n\" +\n+            \"            \\\"discounted-price\\\",\\n\" +\n+            \"            \\\"order-date\\\",\\n\" +\n+            \"            \\\"ship-date\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 5;\n+        int headerRow = 1;\n+        int totalColumns = 6;\n+        int totalRows = limit + headerRow;\n+\n+        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"fileType\", \"csv\");\n+        params.add(\"limit\", String.valueOf(limit));\n+        params.add(\"queryDocument\", json);\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, params)\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+                assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), params)\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+                assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+            });\n+    }\n+\n+    private void installExportProject() throws IOException {\n+        String projectFolder = \"test-projects/export-project\";\n+        installProjectInFolder(projectFolder);\n+        entityManager.deployQueryOptions();\n+\n+        DocumentMetadataHandle metadata = new DocumentMetadataHandle()\n+            .withCollections(\"Order\")\n+            .withPermission(\"data-hub-operator\", DocumentMetadataHandle.Capability.READ, DocumentMetadataHandle.Capability.UPDATE);\n+        GenericDocumentManager finalDocMgr = getHubConfig().newFinalClient().newDocumentManager();\n+        DocumentWriteSet writeSet = finalDocMgr.newWriteSet();\n+        File inputDir = new ClassPathResource(projectFolder + \"/input\").getFile();", "originalCommit": "5509ea3767fcc4714b3c1b65fd58f7be467f851f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MTc3Ng==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413971776", "bodyText": "Makes sense. I'll update the tests.", "author": "akshaysonvane", "createdAt": "2020-04-23T17:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODc3NA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413458774", "bodyText": "Is there something under src/main/java that needs this? The only reference I saw to \"async\" is in EntitySearchControllerTest.", "author": "rjrudin", "createdAt": "2020-04-23T02:16:29Z", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/WebMvcConfig.java", "diffHunk": "@@ -44,4 +46,14 @@ protected Resource getResource(String resourcePath, Resource location)\n                 }\n             });\n     }\n+\n+    @Override\n+    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {", "originalCommit": "5509ea3767fcc4714b3c1b65fd58f7be467f851f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MjAwNA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413972004", "bodyText": "We need this since we are using a StreamingResponseBody for asynchronous request processing.\nStreamingResponseBody by default uses a SimpleAsyncTaskExecutor which does not reuse threads, as a result, its advisable to provide our own TaskExecutor.\nAlso, this allows us to configure the Default Timeout which at this point is 10 minutes.", "author": "akshaysonvane", "createdAt": "2020-04-23T17:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NjMwOQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415086309", "bodyText": "I think this method needs to make that clear. Spring is great at making it easy to setup useful, reusable stuff, but the few lines of code required to do so often beg the question of - \"Why is this being configured?\"\nThe method name is usually a good way to answer that question - e.g. \"configureAsyncProcessingForStreamingResponses\". Each setting needs a comment as well - why 10 threads? Why 10 minutes? Why did we choose those numbers? 3 months from now, someone will look at this code and wonder why these settings were chosen.\nI also think it's worth explicitly identifying the feature this is for - i.e. exporting entities. That may expand in the future - i.e. when we support exporting other results.", "author": "rjrudin", "createdAt": "2020-04-25T15:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDM2MA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190360", "bodyText": "Makes sense. I'll add the code comments.", "author": "akshaysonvane", "createdAt": "2020-04-26T02:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODc3NA=="}], "type": "inlineReview"}, {"oid": "4497b74605bd30a13205acb1a9e68baa06e32b17", "url": "https://github.com/marklogic/marklogic-data-hub/commit/4497b74605bd30a13205acb1a9e68baa06e32b17", "message": "DHFPROD-4226: Export rows as csv", "committedDate": "2020-04-24T20:09:26Z", "type": "forcePushed"}, {"oid": "801d3387dbb69fff9e41367a525b975e7ab076a9", "url": "https://github.com/marklogic/marklogic-data-hub/commit/801d3387dbb69fff9e41367a525b975e7ab076a9", "message": "DHFPROD-4226: Export rows as csv", "committedDate": "2020-04-24T21:29:39Z", "type": "forcePushed"}, {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e", "url": "https://github.com/marklogic/marklogic-data-hub/commit/e393bb174cc60ae6fca374d2012615a13c59098e", "message": "DHFPROD-4226: Export rows as csv", "committedDate": "2020-04-24T21:37:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NjYzMQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415086631", "bodyText": "Looking at this, it does seem like there's a chance for a null pointer. How about \"searchQuery.hasEntityTypeIds()\"? That results in less work for the controller, and that method can be coded to ensure an NPE can't occur.", "author": "rjrudin", "createdAt": "2020-04-25T15:38:53Z", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/managers/EntitySearchManager.java", "diffHunk": "@@ -100,7 +112,7 @@ public StringHandle search(SearchQuery searchQuery) {\n         }\n         catch (MarkLogicServerException e) {\n             // If there are no entityModels to search, then we expect an error because no search options will exist\n-            if(searchQuery.getQuery().getEntityTypeIds().isEmpty() || modelManager.getModels().size() == 0) {\n+            if (searchQuery.getQuery().getEntityTypeIds().isEmpty() || modelManager.getModels().size() == 0) {", "originalCommit": "e393bb174cc60ae6fca374d2012615a13c59098e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDQzNw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190437", "bodyText": "Since the models have been designed to initialize these objects in the constructor it won't throw an NPE.", "author": "akshaysonvane", "createdAt": "2020-04-26T02:06:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NjYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzA1Mg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087052", "bodyText": "Why is this here? I don't think any post-commit triggers fire when entity instances are saved?", "author": "rjrudin", "createdAt": "2020-04-25T15:41:26Z", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();", "originalCommit": "e393bb174cc60ae6fca374d2012615a13c59098e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDQ3Mw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190473", "bodyText": "Right, this needs to go. I missed that while refactoring the code.", "author": "akshaysonvane", "createdAt": "2020-04-26T02:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzE3Ng==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087176", "bodyText": "Nice - is this verifying that the async support is configured correctly then?", "author": "rjrudin", "createdAt": "2020-04-25T15:41:57Z", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)", "originalCommit": "e393bb174cc60ae6fca374d2012615a13c59098e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDU0NQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190545", "bodyText": "Yes, request().asyncStarted() checks for the async support.\ngetAsyncResult() is needed to wait for the async result to return.", "author": "akshaysonvane", "createdAt": "2020-04-26T02:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzUwOA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087508", "bodyText": "This is reusable stuff that is worth adding to the ReferenceModelProject class.\nThe current \"createCustomer\" method in there is for \"raw\" customers. I think it's worth renaming that to \"createRawCustomer\", and then this can become \"createCustomerInstance\", which makes it clear we're creating entity instances here.", "author": "rjrudin", "createdAt": "2020-04-25T15:44:01Z", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), getRequestParams(limit, null))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+\n+        // test limit\n+        int newLimit = 1;\n+        postWithParams(EXPORT_PATH, getRequestParams(newLimit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(newLimit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()) || actualRowSet.contains(customer2.getHashCode()));\n+            });\n+    }\n+\n+    private void assertRowsAndColumns(int limit, int totalColumns, String response) {\n+        int headerRow = 1;\n+        int totalRows = limit + headerRow;\n+\n+        assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+        assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+    }\n+\n+    private void createCustomer(Customer customer) {", "originalCommit": "e393bb174cc60ae6fca374d2012615a13c59098e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDU4MA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190580", "bodyText": "To the ReferenceModelProject this goes then.", "author": "akshaysonvane", "createdAt": "2020-04-26T02:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzcxMg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087712", "bodyText": "This can move to the testFixture source set in core DH too. Make it a regular public class though, with private fields and getters/setters, as we can use Jackson to generate JSON for it automatically, which will save some effort. We'll likely add more to this class so to make writing tests easier as we go.", "author": "rjrudin", "createdAt": "2020-04-25T15:45:28Z", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), getRequestParams(limit, null))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+\n+        // test limit\n+        int newLimit = 1;\n+        postWithParams(EXPORT_PATH, getRequestParams(newLimit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(newLimit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()) || actualRowSet.contains(customer2.getHashCode()));\n+            });\n+    }\n+\n+    private void assertRowsAndColumns(int limit, int totalColumns, String response) {\n+        int headerRow = 1;\n+        int totalRows = limit + headerRow;\n+\n+        assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+        assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+    }\n+\n+    private void createCustomer(Customer customer) {\n+        String customerEntityType = \"Customer\";\n+\n+        JSONDocumentManager mgr = getHubConfig().newFinalClient().newJSONDocumentManager();\n+        ObjectNode customerProps = objectMapper.createObjectNode();\n+        customerProps.put(\"customerId\", customer.customerId);\n+        customerProps.put(\"name\", customer.name);\n+        customerProps.put(\"customerNumber\", customer.customerNumber);\n+        customerProps.put(\"customerSince\", customer.customerSince);\n+\n+        ObjectNode infoProp = objectMapper.createObjectNode();\n+        infoProp.put(\"title\", customerEntityType);\n+        infoProp.put(\"version\", \"0.0.1\");\n+        infoProp.put(\"baseUri\", \"http://example.org/\");\n+\n+        ObjectNode instanceProps = objectMapper.createObjectNode();\n+        instanceProps.set(\"info\", infoProp);\n+        instanceProps.set(customerEntityType, customerProps);\n+\n+        ObjectNode instance = objectMapper.createObjectNode().set(\"instance\", instanceProps);\n+        ObjectNode envelope = objectMapper.createObjectNode().set(\"envelope\", instance);\n+\n+        DocumentMetadataHandle metadata = new DocumentMetadataHandle()\n+            .withCollections(customerEntityType)\n+            .withPermission(\"data-hub-operator\", DocumentMetadataHandle.Capability.READ, DocumentMetadataHandle.Capability.UPDATE);\n+        mgr.write(\"/\" + customerEntityType + customer.customerId + \".json\", metadata, new JacksonHandle(envelope));\n+    }\n+\n+    private Set<Integer> calculateHash(String csvData) throws IOException {\n+        Set<Integer> rowSet = new HashSet<>();\n+\n+        try (BufferedReader reader = new BufferedReader(new StringReader(csvData))) {\n+            String line = reader.readLine();\n+            while (line != null) {\n+                line = line.replaceAll(\",\", \"\");\n+                rowSet.add(line.hashCode());\n+                line = reader.readLine();\n+            }\n+        }\n+\n+        return rowSet;\n+    }\n+\n+    private MultiValueMap<String, String> getRequestParams(int limit, String json) {\n+        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"fileType\", \"csv\");\n+        params.add(\"limit\", String.valueOf(limit));\n+        params.add(\"queryDocument\", json);\n+\n+        return params;\n+    }\n+\n+    static class Customer {", "originalCommit": "e393bb174cc60ae6fca374d2012615a13c59098e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDYyNg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190626", "bodyText": "Will do.", "author": "akshaysonvane", "createdAt": "2020-04-26T02:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4ODMyMg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415088322", "bodyText": "I think we need to catch an exception here in case the options exist. They should exist - but if they don't, the user is going to get an error they likely won't understand and I'll probably get pinged with a message saying that Gradle is broken.\nSo use a try/catch here to catch an exception if the options don't exist, and rethrow the error with a message of e.g. \"Could not find search options: (name); system is not configured correctly, please contact a system administrator\".", "author": "rjrudin", "createdAt": "2020-04-25T15:48:44Z", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/managers/EntitySearchManager.java", "diffHunk": "@@ -278,6 +290,126 @@ protected String buildSearchOptions(String query, SearchQuery searchQuery) {\n         return sb.toString();\n     }\n \n+    public void exportById(String queryId, String fileType, Long limit, OutputStream out, HttpServletResponse response) {\n+        JsonNode queryDocument = EntitySearchService.on(finalDataServiceClient).getSavedQuery(queryId);\n+        exportByQuery(queryDocument, fileType, limit, out, response);\n+    }\n+\n+    public void exportByQuery(JsonNode queryDocument, String fileType, Long limit, OutputStream out, HttpServletResponse response) {\n+        if (\"CSV\".equals(fileType.toUpperCase())) {\n+            prepareResponseHeader(response, CSV_CONTENT_TYPE, getFileNameForDownload(queryDocument, CSV_FILE_EXTENSION));\n+            exportRows(queryDocument, limit, out);\n+        }\n+        else {\n+            throw new DataHubException(\"Invalid file type: \" + fileType);\n+        }\n+    }\n+\n+    public void exportRows(JsonNode queryDocument, Long limit, OutputStream out) {\n+        QueryManager queryMgr = finalDatabaseClient.newQueryManager();\n+        SearchQuery searchQuery = transformToSearchQuery(queryDocument);\n+        StructuredQueryDefinition structuredQueryDefinition = buildQuery(queryMgr, searchQuery);\n+\n+        String structQuery = structuredQueryDefinition.serialize();\n+        String searchQText = searchQuery.getQuery().getSearchText();\n+        String queryOptions = finalDatabaseClient.newServerConfigManager().newQueryOptionsManager().readOptionsAs(QUERY_OPTIONS, Format.XML, String.class);", "originalCommit": "e393bb174cc60ae6fca374d2012615a13c59098e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDY2OA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190668", "bodyText": "Good catch. I'll catch the exception.", "author": "akshaysonvane", "createdAt": "2020-04-26T02:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4ODMyMg=="}], "type": "inlineReview"}, {"oid": "45a63b2769e96098de1f5366610dfef9ad7d703f", "url": "https://github.com/marklogic/marklogic-data-hub/commit/45a63b2769e96098de1f5366610dfef9ad7d703f", "message": "DHFPROD-4226: Export rows as csv", "committedDate": "2020-04-26T01:43:46Z", "type": "forcePushed"}, {"oid": "6228cd71470419c915fa9b0fbf5dba53357f8164", "url": "https://github.com/marklogic/marklogic-data-hub/commit/6228cd71470419c915fa9b0fbf5dba53357f8164", "message": "DHFPROD-4226: Export rows as csv", "committedDate": "2020-04-26T03:05:54Z", "type": "forcePushed"}, {"oid": "45d98a812646b139f060d9a108c2947c96ceaceb", "url": "https://github.com/marklogic/marklogic-data-hub/commit/45d98a812646b139f060d9a108c2947c96ceaceb", "message": "DHFPROD-4226: Export rows as csv", "committedDate": "2020-04-27T15:47:55Z", "type": "forcePushed"}, {"oid": "bf8c512f7e182b1702120ab3d26916964df32e2a", "url": "https://github.com/marklogic/marklogic-data-hub/commit/bf8c512f7e182b1702120ab3d26916964df32e2a", "message": "DHFPROD-4226: Export rows as csv", "committedDate": "2020-04-27T19:26:06Z", "type": "commit"}, {"oid": "bf8c512f7e182b1702120ab3d26916964df32e2a", "url": "https://github.com/marklogic/marklogic-data-hub/commit/bf8c512f7e182b1702120ab3d26916964df32e2a", "message": "DHFPROD-4226: Export rows as csv", "committedDate": "2020-04-27T19:26:06Z", "type": "forcePushed"}]}