{"pr_number": 502, "pr_title": "feat(rc): Add Remote Config Management API ", "pr_createdAt": "2020-12-11T18:43:51Z", "pr_url": "https://github.com/firebase/firebase-admin-java/pull/502", "timeline": [{"oid": "88482db9588919e523bab94496ed19a08fa34140", "url": "https://github.com/firebase/firebase-admin-java/commit/88482db9588919e523bab94496ed19a08fa34140", "message": "Add initial classes for Remote Config API (#477)\n\n- Add initial classes for Remote Config API\r\n- Add unit tests", "committedDate": "2020-09-15T20:51:17Z", "type": "commit"}, {"oid": "936043bf8e61f8792dc668b1801de9939f6e61d8", "url": "https://github.com/firebase/firebase-admin-java/commit/936043bf8e61f8792dc668b1801de9939f6e61d8", "message": "Add the entry point for Remote Config (#478)\n\n* Add the entry point for Remote Config\r\n\r\n* Remove the builder in RemoteConfig.java\r\n\r\n* Remove fromApp and use the constructor directly\r\n\r\n* Fix doc strings", "committedDate": "2020-09-24T18:49:35Z", "type": "commit"}, {"oid": "150b121b2ca8187b119bb2e3c3807d8f50385f5e", "url": "https://github.com/firebase/firebase-admin-java/commit/150b121b2ca8187b119bb2e3c3807d8f50385f5e", "message": "Add parameters to Remote Config template (#479)\n\n- Introduce Response Types and Public Types\r\n- Implement toResponseType() and toPublicType()\r\n- Add parameters to RemoteConfigTemplate\r\n- Add unit tests", "committedDate": "2020-10-02T18:35:40Z", "type": "commit"}, {"oid": "01d0c98ef2ba9bccc1d2331fbed8b39e2c5410f7", "url": "https://github.com/firebase/firebase-admin-java/commit/01d0c98ef2ba9bccc1d2331fbed8b39e2c5410f7", "message": "Remote Config Refactor Public and Response types (#481)\n\n* Refactor Public and Response types\r\n\r\n* reformat code\r\n\r\n* Clean up code style\r\n\r\n* Remove getUseInAppDefault and use the value type in setter", "committedDate": "2020-10-06T16:10:24Z", "type": "commit"}, {"oid": "f2c5e815725201757af764e4025f0a2c3565f019", "url": "https://github.com/firebase/firebase-admin-java/commit/f2c5e815725201757af764e4025f0a2c3565f019", "message": "Remove RemoteConfig prefix from classes (#483)", "committedDate": "2020-10-13T17:06:31Z", "type": "commit"}, {"oid": "e4bde999d4e072b5bf9d2f558d0124668b455070", "url": "https://github.com/firebase/firebase-admin-java/commit/e4bde999d4e072b5bf9d2f558d0124668b455070", "message": "Add Remote Config conditions to template (#489)\n\n* Add Remote Config conditions to template", "committedDate": "2020-10-27T21:30:03Z", "type": "commit"}, {"oid": "cd5dfdaf13cd9ccc620a414402dac5699831ae90", "url": "https://github.com/firebase/firebase-admin-java/commit/cd5dfdaf13cd9ccc620a414402dac5699831ae90", "message": "Add Remote Config Parameter Group type (#490)\n\n* Introduce Parameter Groups\r\n\r\n* Refactor unit tests\r\n\r\n* PR fixes\r\n\r\n* Fix variable names in unit tests", "committedDate": "2020-11-02T18:05:59Z", "type": "commit"}, {"oid": "daf8b2c4253f5d4bee2f9528a2a526e3b8733589", "url": "https://github.com/firebase/firebase-admin-java/commit/daf8b2c4253f5d4bee2f9528a2a526e3b8733589", "message": "Add Version information to RC template (#491)\n\n* Add Version information to RC template\r\n\r\n* PR fixes\r\n\r\n* PR fixes\r\n\r\n* Clean up template unit tests", "committedDate": "2020-11-10T20:22:23Z", "type": "commit"}, {"oid": "1a3f03665c35454e5e4e969c853ec3dbd43786d3", "url": "https://github.com/firebase/firebase-admin-java/commit/1a3f03665c35454e5e4e969c853ec3dbd43786d3", "message": "Add Remote Config Pubish, Validate, and GetTemplateAtVersion operations (#496)\n\n* Add Pubish, Validate, and GetTemplateAtVersion operations\r\n\r\n* Clean up tests\r\n\r\n* Move PublishOptions to parent package", "committedDate": "2020-11-24T16:16:17Z", "type": "commit"}, {"oid": "33b9e3b91943fd39945b7612909eb92121936817", "url": "https://github.com/firebase/firebase-admin-java/commit/33b9e3b91943fd39945b7612909eb92121936817", "message": "Add Remote Config rollback operation (#497)\n\n* Add Remote Config rollback operation\r\n\r\n* PR fixes", "committedDate": "2020-12-01T23:10:30Z", "type": "commit"}, {"oid": "8085ceeb68db4b067cef1c2ad45a9437aa192b9b", "url": "https://github.com/firebase/firebase-admin-java/commit/8085ceeb68db4b067cef1c2ad45a9437aa192b9b", "message": "Add List Versions operation in Remote Config (#498)\n\n* Add List Versions operation in Remote Config\r\n\r\n* PR fixes\r\n\r\n* Move convertToUtcZuluFormat to utils class", "committedDate": "2020-12-02T22:43:27Z", "type": "commit"}, {"oid": "09043e6bf13cd9113e7f3cf00899738db4a8c9be", "url": "https://github.com/firebase/firebase-admin-java/commit/09043e6bf13cd9113e7f3cf00899738db4a8c9be", "message": "Add toJSON and fromJSON to Remote Config Template (#500)\n\n* Add toJSON and fromJSON to Remote Config Template", "committedDate": "2020-12-10T23:28:01Z", "type": "commit"}, {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "url": "https://github.com/firebase/firebase-admin-java/commit/03b9f3d63c90222932ebff6df70d30ca9f802c59", "message": "Add Remote Config Integration tests (#501)\n\n* Add Remote Config Integration tests\r\n\r\n* Updated listversions tests to use the sync apis", "committedDate": "2020-12-11T18:35:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMTAyMA==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541201020", "bodyText": "This is correct; would \"template to get\" or \"template to retrieve\" be more accurate?", "author": "egilmorez", "createdAt": "2020-12-11T19:33:52Z", "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.", "originalCommit": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAyMTYwMg==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r542021602", "bodyText": "Good point! Changed to template to get. Thanks!", "author": "lahirumaramba", "createdAt": "2020-12-13T22:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMTAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwNjAzNw==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541206037", "bodyText": "This somehow overloads the similar previous method, right?  Should we say something here about how/why, much as you have done for the async methods?", "author": "egilmorez", "createdAt": "2020-12-11T19:38:54Z", "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(\n+          @NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return getTemplateAtVersionOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.", "originalCommit": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAyODY0Mg==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r542028642", "bodyText": "We have an async function for each type of version number, long and String.\nAs discussed offline, the function signature helps developers to differentiate between getTemplateAtVersion(long versionNumber) and getTemplateAtVersion(String versionNumber).", "author": "lahirumaramba", "createdAt": "2020-12-13T23:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwNjAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMDkyOQ==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541210929", "bodyText": "I guess the difference here is the length of the version number . . . but I'm a bit confused looking at these.  Can you check and make sure each similar/overloaded method has a descr. mentioning the distinction?\nWould be easier for me to eyeball if we had a staged version.  Is that even feasible before a PR like this is merged?", "author": "egilmorez", "createdAt": "2020-12-11T19:44:06Z", "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(\n+          @NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return getTemplateAtVersionOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(long versionNumber) throws FirebaseRemoteConfigException {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(String versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(@NonNull String versionNumber) {\n+    return getTemplateAtVersionOp(versionNumber).callAsync(app);\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(long versionNumber)} but performs the operation", "originalCommit": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAyODUwMQ==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r542028501", "bodyText": "As discussed offline, the function signature helps developers to differentiate between getTemplateAtVersion(long versionNumber) and getTemplateAtVersion(String versionNumber).", "author": "lahirumaramba", "createdAt": "2020-12-13T23:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMDkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxNDEwMw==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541214103", "bodyText": "Would it be accurate to say something like \"ignoring\" or \"disregarding any existing ETag conflicts.\"  ?\nOr maybe \"without evaluating the ETag values.\"  ?\nFeels a little odd just attached with \"and\" this way.", "author": "egilmorez", "createdAt": "2020-12-11T19:47:16Z", "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(\n+          @NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return getTemplateAtVersionOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(long versionNumber) throws FirebaseRemoteConfigException {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(String versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(@NonNull String versionNumber) {\n+    return getTemplateAtVersionOp(versionNumber).callAsync(app);\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(long versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(long versionNumber) {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateAtVersionOp(\n+          final String versionNumber) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplateAtVersion(versionNumber);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Publishes a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return The published {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while publishing the template.\n+   */\n+  public Template publishTemplate(@NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #publishTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is published.\n+   */\n+  public ApiFuture<Template> publishTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template).callAsync(app);\n+  }\n+\n+  /**\n+   * Validates a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return The validated {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while validating the template.\n+   */\n+  public Template validateTemplate(\n+          @NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #validateTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is validated.\n+   */\n+  public ApiFuture<Template> validateTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).callAsync(app);\n+  }\n+\n+  /**\n+   * Force publishes a Remote Config template.\n+   *\n+   * <p>This method forces the Remote Config template to be updated and circumvent the ETag.", "originalCommit": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAyMjYyNQ==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r542022625", "bodyText": "Thanks! Updated to without evaluating the ETag values.", "author": "lahirumaramba", "createdAt": "2020-12-13T22:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxNDEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxNjY0OA==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541216648", "bodyText": "Is this the long version number variant?", "author": "egilmorez", "createdAt": "2020-12-11T19:49:53Z", "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(\n+          @NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return getTemplateAtVersionOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(long versionNumber) throws FirebaseRemoteConfigException {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(String versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(@NonNull String versionNumber) {\n+    return getTemplateAtVersionOp(versionNumber).callAsync(app);\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(long versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(long versionNumber) {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateAtVersionOp(\n+          final String versionNumber) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplateAtVersion(versionNumber);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Publishes a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return The published {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while publishing the template.\n+   */\n+  public Template publishTemplate(@NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #publishTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is published.\n+   */\n+  public ApiFuture<Template> publishTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template).callAsync(app);\n+  }\n+\n+  /**\n+   * Validates a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return The validated {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while validating the template.\n+   */\n+  public Template validateTemplate(\n+          @NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #validateTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is validated.\n+   */\n+  public ApiFuture<Template> validateTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).callAsync(app);\n+  }\n+\n+  /**\n+   * Force publishes a Remote Config template.\n+   *\n+   * <p>This method forces the Remote Config template to be updated and circumvent the ETag.\n+   * This approach is not recommended because it risks causing the loss of updates to your\n+   * Remote Config template if multiple clients are updating the Remote Config template.\n+   * See <a href=\"https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates\">\n+   * ETag usage and forced updates</a>.\n+   *\n+   * @param template The Remote Config template to be forcefully published.\n+   * @return The published {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while publishing the template.\n+   */\n+  public Template forcePublishTemplate(\n+          @NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template, new PublishOptions().setForcePublish(true)).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #forcePublishTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be forcefully published.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is published.\n+   */\n+  public ApiFuture<Template> forcePublishTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template, new PublishOptions().setForcePublish(true)).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> publishTemplateOp(\n+          final Template template) {\n+    return publishTemplateOp(template, new PublishOptions());\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> publishTemplateOp(\n+          final Template template, final PublishOptions options) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient\n+                .publishTemplate(template, options.isValidateOnly(), options.isForcePublish());\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Rolls back a project's published Remote Config template to the specified version.", "originalCommit": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAyMjkzMg==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r542022932", "bodyText": "long version number represents the Number format of the versionNumber as opposed to the String format.\nEx: long format -> 9 vs String format -> \"9\"", "author": "lahirumaramba", "createdAt": "2020-12-13T22:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxNjY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxODE3Mg==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541218172", "bodyText": "Do you mean that this method fires off the deletion?  Otherwise, this might seem like extra/unnecessary information.\nHere and below (whose desc may also need clarification on the nature of the override).", "author": "egilmorez", "createdAt": "2020-12-11T19:51:29Z", "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(\n+          @NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return getTemplateAtVersionOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(long versionNumber) throws FirebaseRemoteConfigException {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(String versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(@NonNull String versionNumber) {\n+    return getTemplateAtVersionOp(versionNumber).callAsync(app);\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(long versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(long versionNumber) {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateAtVersionOp(\n+          final String versionNumber) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplateAtVersion(versionNumber);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Publishes a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return The published {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while publishing the template.\n+   */\n+  public Template publishTemplate(@NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #publishTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is published.\n+   */\n+  public ApiFuture<Template> publishTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template).callAsync(app);\n+  }\n+\n+  /**\n+   * Validates a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return The validated {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while validating the template.\n+   */\n+  public Template validateTemplate(\n+          @NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #validateTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is validated.\n+   */\n+  public ApiFuture<Template> validateTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).callAsync(app);\n+  }\n+\n+  /**\n+   * Force publishes a Remote Config template.\n+   *\n+   * <p>This method forces the Remote Config template to be updated and circumvent the ETag.\n+   * This approach is not recommended because it risks causing the loss of updates to your\n+   * Remote Config template if multiple clients are updating the Remote Config template.\n+   * See <a href=\"https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates\">\n+   * ETag usage and forced updates</a>.\n+   *\n+   * @param template The Remote Config template to be forcefully published.\n+   * @return The published {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while publishing the template.\n+   */\n+  public Template forcePublishTemplate(\n+          @NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template, new PublishOptions().setForcePublish(true)).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #forcePublishTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be forcefully published.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is published.\n+   */\n+  public ApiFuture<Template> forcePublishTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template, new PublishOptions().setForcePublish(true)).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> publishTemplateOp(\n+          final Template template) {\n+    return publishTemplateOp(template, new PublishOptions());\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> publishTemplateOp(\n+          final Template template, final PublishOptions options) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient\n+                .publishTemplate(template, options.isValidateOnly(), options.isForcePublish());\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Rolls back a project's published Remote Config template to the specified version.\n+   *\n+   * <p>A rollback is equivalent to getting a previously published Remote Config\n+   * template and re-publishing it using a force update.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to roll back to.\n+   *                      The specified version number must be lower than the current version\n+   *                      number, and not have been deleted due to staleness. Only the last 300\n+   *                      versions are stored. All versions that correspond to non-active Remote\n+   *                      Config templates (that is, all except the template that is being fetched\n+   *                      by clients) are also deleted if they are more than 90 days old.\n+   * @return The rolled back {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while rolling back the template.\n+   */\n+  public Template rollback(long versionNumber) throws FirebaseRemoteConfigException {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return rollbackOp(versionNumberString).call();\n+  }\n+\n+  /**\n+   * Rolls back a project's published Remote Config template to the specified version.\n+   *\n+   * <p>A rollback is equivalent to getting a previously published Remote Config\n+   * template and re-publishing it using a force update.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to roll back to.\n+   *                      The specified version number must be lower than the current version\n+   *                      number, and not have been deleted due to staleness. Only the last 300\n+   *                      versions are stored. All versions that correspond to non-active Remote\n+   *                      Config templates (that is, all except the template that is being fetched\n+   *                      by clients) are also deleted if they are more than 90 days old.\n+   * @return The rolled back {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while rolling back the template.\n+   */\n+  public Template rollback(@NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return rollbackOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #rollback(long versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to roll back to.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} once\n+   *     the rollback operation is successful.\n+   */\n+  public ApiFuture<Template> rollbackAsync(long versionNumber) {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return rollbackOp(versionNumberString).callAsync(app);\n+  }\n+\n+  /**\n+   * Similar to {@link #rollback(String versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to roll back to.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} once\n+   *     the rollback operation is successful.\n+   */\n+  public ApiFuture<Template> rollbackAsync(@NonNull String versionNumber) {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return rollbackOp(versionNumberString).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> rollbackOp(\n+          final String versionNumber) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.rollback(versionNumber);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets a list of Remote Config template versions that have been published, sorted in reverse\n+   * chronological order. Only the last 300 versions are stored.\n+   *\n+   * <p>All versions that correspond to non-active Remote Config templates (that is, all except the\n+   * template that is being fetched by clients) are also deleted if they are more than 90 days old.", "originalCommit": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAyMzM1OA==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r542023358", "bodyText": "This method lists the available versions. You are right! This paragraph is confusing. Removed it.", "author": "lahirumaramba", "createdAt": "2020-12-13T22:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxODE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyMzQ2MQ==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541223461", "bodyText": "Nit, but I'd say \"an empty string\"", "author": "egilmorez", "createdAt": "2020-12-11T19:57:26Z", "path": "src/main/java/com/google/firebase/remoteconfig/ListVersionsPage.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.gax.paging.Page;\n+import com.google.common.collect.ImmutableList;\n+import com.google.firebase.internal.NonNull;\n+import com.google.firebase.remoteconfig.internal.TemplateResponse;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Represents a page of {@link Version} instances. Provides methods for iterating\n+ * over the versions in the current page, and calling up subsequent pages of versions. Instances of\n+ * this class are thread-safe and immutable.\n+ */\n+public final class ListVersionsPage implements Page<Version> {\n+\n+  static final String END_OF_LIST = \"\";\n+\n+  private final VersionsResultBatch currentBatch;\n+  private final VersionSource source;\n+  private final ListVersionsOptions listVersionsOptions;\n+\n+  private ListVersionsPage(\n+          @NonNull VersionsResultBatch currentBatch, @NonNull VersionSource source,\n+          @NonNull ListVersionsOptions listVersionsOptions) {\n+    this.currentBatch = checkNotNull(currentBatch);\n+    this.source = checkNotNull(source);\n+    this.listVersionsOptions = listVersionsOptions;\n+  }\n+\n+  /**\n+   * Checks if there is another page of versions available to retrieve.\n+   *\n+   * @return true if another page is available, or false otherwise.\n+   */\n+  @Override\n+  public boolean hasNextPage() {\n+    return !END_OF_LIST.equals(currentBatch.getNextPageToken());\n+  }\n+\n+  /**\n+   * Returns the next page of versions.\n+   *\n+   * @return A new {@link ListVersionsPage} instance, or null if there are no more pages.\n+   */\n+  @NonNull\n+  @Override\n+  public ListVersionsPage getNextPage() {\n+    if (hasNextPage()) {\n+      ListVersionsOptions options;\n+      if (listVersionsOptions != null) {\n+        options = listVersionsOptions.toBuilder().setPageToken(currentBatch.getNextPageToken())\n+                .build();\n+      } else {\n+        options = ListVersionsOptions.builder().setPageToken(currentBatch.getNextPageToken())\n+                .build();\n+      }\n+      Factory factory = new Factory(source, options);\n+      try {\n+        return factory.create();\n+      } catch (FirebaseRemoteConfigException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns the string token that identifies the next page. Never returns null. Returns empty", "originalCommit": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAyMzg0OQ==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r542023849", "bodyText": "Thanks! Fixed.", "author": "lahirumaramba", "createdAt": "2020-12-13T22:49:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyMzQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2NDIxNg==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541264216", "bodyText": "This means console or backend, correct?  Might be worth noting.", "author": "egilmorez", "createdAt": "2020-12-11T20:38:23Z", "path": "src/main/java/com/google/firebase/remoteconfig/Version.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.Strings;\n+import com.google.firebase.internal.NonNull;\n+import com.google.firebase.internal.Nullable;\n+import com.google.firebase.remoteconfig.internal.TemplateResponse;\n+import com.google.firebase.remoteconfig.internal.TemplateResponse.VersionResponse;\n+\n+import java.text.ParseException;\n+import java.util.Objects;\n+\n+/**\n+ * Represents a Remote Config template version.\n+ * Output only, except for the version description. Contains metadata about a particular\n+ * version of the Remote Config template. All fields are set at the time the specified Remote\n+ * Config template is published. A version's description field may be specified when\n+ * publishing a template.\n+ */\n+public final class Version {\n+\n+  private final String versionNumber;\n+  private final long updateTime;\n+  private final String updateOrigin;\n+  private final String updateType;\n+  private final User updateUser;\n+  private final String rollbackSource;\n+  private final boolean legacy;\n+  private String description;\n+\n+  private Version() {\n+    this.versionNumber = null;\n+    this.updateTime = 0L;\n+    this.updateOrigin = null;\n+    this.updateType = null;\n+    this.updateUser = null;\n+    this.rollbackSource = null;\n+    this.legacy = false;\n+  }\n+\n+  Version(@NonNull VersionResponse versionResponse) {\n+    checkNotNull(versionResponse);\n+    this.versionNumber = versionResponse.getVersionNumber();\n+\n+    if (!Strings.isNullOrEmpty(versionResponse.getUpdateTime())) {\n+      try {\n+        this.updateTime = RemoteConfigUtil.convertToMilliseconds(versionResponse.getUpdateTime());\n+      } catch (ParseException e) {\n+        throw new IllegalStateException(\"Unable to parse update time.\", e);\n+      }\n+    } else {\n+      this.updateTime = 0L;\n+    }\n+\n+    this.updateOrigin = versionResponse.getUpdateOrigin();\n+    this.updateType = versionResponse.getUpdateType();\n+    TemplateResponse.UserResponse userResponse = versionResponse.getUpdateUser();\n+    this.updateUser = (userResponse != null) ? new User(userResponse) : null;\n+    this.description = versionResponse.getDescription();\n+    this.rollbackSource = versionResponse.getRollbackSource();\n+    this.legacy = versionResponse.isLegacy();\n+  }\n+\n+  /**\n+   * Creates a new {@link Version} with a description.\n+   */\n+  public static Version withDescription(String description) {\n+    return new Version().setDescription(description);\n+  }\n+\n+  /**\n+   * Gets the version number of the template.\n+   *\n+   * @return The version number or null.\n+   */\n+  @Nullable\n+  public String getVersionNumber() {\n+    return versionNumber;\n+  }\n+\n+  /**\n+   * Gets the update time of the version. The timestamp of when this version of the Remote Config\n+   * template was written to the Remote Config backend.\n+   *\n+   * @return The update time of the version or null.\n+   */\n+  @Nullable\n+  public long getUpdateTime() {\n+    return updateTime;\n+  }\n+\n+  /**\n+   * Gets the origin of the template update action.", "originalCommit": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAyNDM1Ng==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r542024356", "bodyText": "I think it could be the Console, Admin Node, Admin Java, and the CLI. This could change in the future as we add more SDKs. Should we mention all that here?", "author": "lahirumaramba", "createdAt": "2020-12-13T22:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2NDIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY2MDE4NQ==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r542660185", "bodyText": "I think you're right -- let's not go down that path.", "author": "egilmorez", "createdAt": "2020-12-14T19:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2NDIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2Njc0Ng==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541266746", "bodyText": "I'm not 100% clear here.  Are the number and the source the same thing?  Or does this actually get the version from which this version was rolled back?", "author": "egilmorez", "createdAt": "2020-12-11T20:41:10Z", "path": "src/main/java/com/google/firebase/remoteconfig/Version.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.Strings;\n+import com.google.firebase.internal.NonNull;\n+import com.google.firebase.internal.Nullable;\n+import com.google.firebase.remoteconfig.internal.TemplateResponse;\n+import com.google.firebase.remoteconfig.internal.TemplateResponse.VersionResponse;\n+\n+import java.text.ParseException;\n+import java.util.Objects;\n+\n+/**\n+ * Represents a Remote Config template version.\n+ * Output only, except for the version description. Contains metadata about a particular\n+ * version of the Remote Config template. All fields are set at the time the specified Remote\n+ * Config template is published. A version's description field may be specified when\n+ * publishing a template.\n+ */\n+public final class Version {\n+\n+  private final String versionNumber;\n+  private final long updateTime;\n+  private final String updateOrigin;\n+  private final String updateType;\n+  private final User updateUser;\n+  private final String rollbackSource;\n+  private final boolean legacy;\n+  private String description;\n+\n+  private Version() {\n+    this.versionNumber = null;\n+    this.updateTime = 0L;\n+    this.updateOrigin = null;\n+    this.updateType = null;\n+    this.updateUser = null;\n+    this.rollbackSource = null;\n+    this.legacy = false;\n+  }\n+\n+  Version(@NonNull VersionResponse versionResponse) {\n+    checkNotNull(versionResponse);\n+    this.versionNumber = versionResponse.getVersionNumber();\n+\n+    if (!Strings.isNullOrEmpty(versionResponse.getUpdateTime())) {\n+      try {\n+        this.updateTime = RemoteConfigUtil.convertToMilliseconds(versionResponse.getUpdateTime());\n+      } catch (ParseException e) {\n+        throw new IllegalStateException(\"Unable to parse update time.\", e);\n+      }\n+    } else {\n+      this.updateTime = 0L;\n+    }\n+\n+    this.updateOrigin = versionResponse.getUpdateOrigin();\n+    this.updateType = versionResponse.getUpdateType();\n+    TemplateResponse.UserResponse userResponse = versionResponse.getUpdateUser();\n+    this.updateUser = (userResponse != null) ? new User(userResponse) : null;\n+    this.description = versionResponse.getDescription();\n+    this.rollbackSource = versionResponse.getRollbackSource();\n+    this.legacy = versionResponse.isLegacy();\n+  }\n+\n+  /**\n+   * Creates a new {@link Version} with a description.\n+   */\n+  public static Version withDescription(String description) {\n+    return new Version().setDescription(description);\n+  }\n+\n+  /**\n+   * Gets the version number of the template.\n+   *\n+   * @return The version number or null.\n+   */\n+  @Nullable\n+  public String getVersionNumber() {\n+    return versionNumber;\n+  }\n+\n+  /**\n+   * Gets the update time of the version. The timestamp of when this version of the Remote Config\n+   * template was written to the Remote Config backend.\n+   *\n+   * @return The update time of the version or null.\n+   */\n+  @Nullable\n+  public long getUpdateTime() {\n+    return updateTime;\n+  }\n+\n+  /**\n+   * Gets the origin of the template update action.\n+   *\n+   * @return The origin of the template update action or null.\n+   */\n+  @Nullable\n+  public String getUpdateOrigin() {\n+    return updateOrigin;\n+  }\n+\n+  /**\n+   * Gets the type of the template update action.\n+   *\n+   * @return The type of the template update action or null.\n+   */\n+  @Nullable\n+  public String getUpdateType() {\n+    return updateType;\n+  }\n+\n+  /**\n+   * Gets the update user of the template.\n+   * An aggregation of all metadata fields about the account that performed the update.\n+   *\n+   * @return The update user of the template or null.\n+   */\n+  @Nullable\n+  public User getUpdateUser() {\n+    return updateUser;\n+  }\n+\n+  /**\n+   * Gets the user-provided description of the corresponding Remote Config template.\n+   *\n+   * @return The description of the template or null.\n+   */\n+  @Nullable\n+  public String getDescription() {\n+    return description;\n+  }\n+\n+  /**\n+   * Gets the rollback source of the template.\n+   *\n+   * <p>The version number of the Remote Config template that has become the current version", "originalCommit": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAyNDk4Mg==", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r542024982", "bodyText": "The rollback source is a property of the version (metadata) of a rolled back template. It only presents in the Version if the template was a result of a rolled back operation. rollback source is actually the version number of the original template that was used for the rollback.", "author": "lahirumaramba", "createdAt": "2020-12-13T22:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2Njc0Ng=="}], "type": "inlineReview"}, {"oid": "2557d615e2e60c5d507384a7bc3cfbc8f53e0256", "url": "https://github.com/firebase/firebase-admin-java/commit/2557d615e2e60c5d507384a7bc3cfbc8f53e0256", "message": "Fix documentation", "committedDate": "2020-12-13T23:10:46Z", "type": "commit"}]}