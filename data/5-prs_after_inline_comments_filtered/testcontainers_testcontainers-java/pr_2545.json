{"pr_number": 2545, "pr_title": "Add R2DBC support", "pr_createdAt": "2020-04-09T12:27:08Z", "pr_url": "https://github.com/testcontainers/testcontainers-java/pull/2545", "timeline": [{"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e", "url": "https://github.com/testcontainers/testcontainers-java/commit/98515fc93fbfc6292bf224d0640fe7fe61e6041e", "message": "Add R2DBC URL support", "committedDate": "2020-04-09T12:16:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NDQ4NA==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406174484", "bodyText": "might be a case when\nfuture just completed ->\nvoid enter() { publisher.subscribe(this); } executed but subscription may be delivered later (See https://github.com/reactive-streams/reactive-streams-jvm/issues/486 for the clarification)\nso the next cancel which is waiting on the synchronized block will end-up with NPE.\n\nThe simples solution for that is to add flag and synchronization between request cancel and onsubscriber to ensure we are not ending up with NPE if the subscription has not arrived yet", "author": "OlegDokuka", "createdAt": "2020-04-09T12:39:44Z", "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();", "originalCommit": "98515fc93fbfc6292bf224d0640fe7fe61e6041e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4NjM4Mw==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406186383", "bodyText": "good catch", "author": "simonbasle", "createdAt": "2020-04-09T13:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NDQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTI2NQ==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406175265", "bodyText": "here we have to have a flag, e.g (canceled) and if so, immediately call s.cancel on the given one", "author": "OlegDokuka", "createdAt": "2020-04-09T12:41:13Z", "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();\n+            }\n+\n+            @Override\n+            public void onSubscribe(Subscription s) {\n+                this.s = s;", "originalCommit": "98515fc93fbfc6292bf224d0640fe7fe61e6041e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTExMQ==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406175111", "bodyText": "@mp911de does the connection factory absolutely guarantees a Publisher with at most one onNext(Connection)? if not, @bsideup it might be worth it to consider guarding against flux-like publishers by adding a boolean guard in onNext (doesn't even have to be a volatile, since only onNext would read/write it)", "author": "simonbasle", "createdAt": "2020-04-09T12:40:54Z", "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();\n+            }\n+\n+            @Override\n+            public void onSubscribe(Subscription s) {\n+                this.s = s;\n+                s.request(1);", "originalCommit": "98515fc93fbfc6292bf224d0640fe7fe61e6041e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4NTUyMw==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406185523", "bodyText": "it does (checked with Mark), yes. See the design notes in the Javadoc", "author": "bsideup", "createdAt": "2020-04-09T12:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4NzM3Mg==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406187372", "bodyText": "it was unclear to me that comment was about the factory, since it mentions ConnectionPublisher (the current class). I would instead phrase it as Publisher<Connection> provided by R2DBC / the connectionFactory is guaranteed to emit at most one item", "author": "simonbasle", "createdAt": "2020-04-09T13:02:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIyMTMwNA==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406221304", "bodyText": "connectionFactory implements single element or failure semantics. Completion without an element or emitting multiple items violates the spec. It's a cold publisher that should allow multiple subscriptions.", "author": "mp911de", "createdAt": "2020-04-09T13:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4MTMzNg==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406181336", "bodyText": "that pattern was a bit harder for me to follow because of the habit of seeing Subscription as self-sufficient and thus aggressively guarded, but after review it looks correct. I feel it wouldn't be too hard to collapse the various SubscriptionState into the StateMachineSubscription itself and deal with int/enum based states for transitions, but eh as long as it is correct...", "author": "simonbasle", "createdAt": "2020-04-09T12:52:19Z", "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {", "originalCommit": "98515fc93fbfc6292bf224d0640fe7fe61e6041e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4NjUwOA==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406186508", "bodyText": "Thanks for looking at it! FYI I just fixed a race reported by @OlegDokuka:\nd3409df", "author": "bsideup", "createdAt": "2020-04-09T13:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4MTMzNg=="}], "type": "inlineReview"}, {"oid": "d3409df8e09c28f0f3531d9f2918e55ebd37eebb", "url": "https://github.com/testcontainers/testcontainers-java/commit/d3409df8e09c28f0f3531d9f2918e55ebd37eebb", "message": "fix a race", "committedDate": "2020-04-09T13:00:24Z", "type": "commit"}, {"oid": "3e2b34b15aa06c385a793f1b50e076a32c4fb8d6", "url": "https://github.com/testcontainers/testcontainers-java/commit/3e2b34b15aa06c385a793f1b50e076a32c4fb8d6", "message": "move javadoc to the top class", "committedDate": "2020-04-09T13:14:01Z", "type": "commit"}, {"oid": "84ce94d515d83704969dae75e502f27228c6ac04", "url": "https://github.com/testcontainers/testcontainers-java/commit/84ce94d515d83704969dae75e502f27228c6ac04", "message": "use `auto-service`, add `testUrlSupport` test", "committedDate": "2020-04-09T14:30:34Z", "type": "commit"}, {"oid": "7b4a8c668aa6e6ef881fe64a8c4cd1d9b2380366", "url": "https://github.com/testcontainers/testcontainers-java/commit/7b4a8c668aa6e6ef881fe64a8c4cd1d9b2380366", "message": "Add MSSQL R2DBC support", "committedDate": "2020-04-09T14:31:30Z", "type": "commit"}, {"oid": "8903ed8523dc21c5ce2decb53917baba6273508f", "url": "https://github.com/testcontainers/testcontainers-java/commit/8903ed8523dc21c5ce2decb53917baba6273508f", "message": "Add MySQL", "committedDate": "2020-04-09T14:51:29Z", "type": "commit"}, {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5", "url": "https://github.com/testcontainers/testcontainers-java/commit/a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5", "message": "Add MariaDB", "committedDate": "2020-04-09T15:08:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0Mjc1OA==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407042758", "bodyText": "Woah, TIL about @AutoService. I like it.\nFor the sake of consistency, we should probably propagate this out to everywhere else where we've currently hand-written a service descriptor file. This could be a subsequent PR, though.", "author": "rnorth", "createdAt": "2020-04-11T09:45:56Z", "path": "modules/mariadb/src/main/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerProvider.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.testcontainers.containers;\n+\n+import com.google.auto.service.AutoService;\n+import io.r2dbc.spi.ConnectionFactoryOptions;\n+import org.mariadb.r2dbc.MariadbConnectionFactoryProvider;\n+import org.testcontainers.r2dbc.R2DBCDatabaseContainer;\n+import org.testcontainers.r2dbc.R2DBCDatabaseContainerProvider;\n+\n+@AutoService(R2DBCDatabaseContainerProvider.class)", "originalCommit": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NTQxMg==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407045412", "bodyText": "Just wondering if we should prefer an approach similar to our jdbc-test module, that runs the same test in a parameterized way?", "author": "kiview", "createdAt": "2020-04-11T10:14:32Z", "path": "modules/mariadb/src/test/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.testcontainers.containers;\n+\n+import io.r2dbc.spi.Closeable;\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactories;\n+import io.r2dbc.spi.ConnectionFactory;\n+import io.r2dbc.spi.Result;\n+import org.junit.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import static org.junit.Assert.*;\n+\n+public class MariaDBR2DBCDatabaseContainerTest {", "originalCommit": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NzQzMg==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407047432", "bodyText": "@rnorth wanted to change it to \"per module\" for better parallelization, see #2520", "author": "bsideup", "createdAt": "2020-04-11T10:35:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NTQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0ODQyMg==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407048422", "bodyText": "Ah yes, I was assuming something like this actually \ud83d\ude2c\nStill, we could maybe extract an abstract base test class or something similar in a later change, to reduced code duplication.", "author": "kiview", "createdAt": "2020-04-11T10:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NTQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NTE2OQ==", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407065169", "bodyText": "Yep, we can split it per-module and have some common base test classes to keep things neat. That's how I'd started with my draft splitting of jdbc-test, and works nicely.", "author": "rnorth", "createdAt": "2020-04-11T13:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NTQxMg=="}], "type": "inlineReview"}, {"oid": "886c9e725befd219c1906fc2ddda2338061c945a", "url": "https://github.com/testcontainers/testcontainers-java/commit/886c9e725befd219c1906fc2ddda2338061c945a", "message": "Use `@AutoService` on `TestcontainersR2DBCConnectionFactoryProvider`", "committedDate": "2020-04-11T10:39:48Z", "type": "commit"}, {"oid": "184da8843372599724bcce6fda7ac2d558ad8ae9", "url": "https://github.com/testcontainers/testcontainers-java/commit/184da8843372599724bcce6fda7ac2d558ad8ae9", "message": "Merge branch 'master' into r2dbc_support\n\n# Conflicts:\n#\tmodules/mariadb/build.gradle", "committedDate": "2020-04-11T18:08:42Z", "type": "commit"}, {"oid": "834dae85d7df4032b4a378afc8ba3b90221d2833", "url": "https://github.com/testcontainers/testcontainers-java/commit/834dae85d7df4032b4a378afc8ba3b90221d2833", "message": "add `AbstractR2DBCDatabaseContainerTest`", "committedDate": "2020-04-12T10:26:05Z", "type": "commit"}, {"oid": "937fe9603dd55912051f44910b5ecd75be6a2a59", "url": "https://github.com/testcontainers/testcontainers-java/commit/937fe9603dd55912051f44910b5ecd75be6a2a59", "message": "`TC_IMAGE` -> `TC_IMAGE_TAG`", "committedDate": "2020-04-12T10:43:15Z", "type": "commit"}, {"oid": "574df74f73adc52999558c70a0186c2f3f12955e", "url": "https://github.com/testcontainers/testcontainers-java/commit/574df74f73adc52999558c70a0186c2f3f12955e", "message": "fix `reusesUntilConnectionFactoryIsClosed`", "committedDate": "2020-04-12T10:57:26Z", "type": "commit"}, {"oid": "fa6a715732188a8ef146abb449a2368e2e11898c", "url": "https://github.com/testcontainers/testcontainers-java/commit/fa6a715732188a8ef146abb449a2368e2e11898c", "message": "Merge branch 'master' into r2dbc_support", "committedDate": "2020-04-12T11:26:22Z", "type": "commit"}, {"oid": "e145cc1b4bd088b9bc87ba562206938587133715", "url": "https://github.com/testcontainers/testcontainers-java/commit/e145cc1b4bd088b9bc87ba562206938587133715", "message": "add docs", "committedDate": "2020-04-12T11:33:51Z", "type": "commit"}, {"oid": "830f483fc8f7aff05bb3b7e6a5831a89e25fdbc6", "url": "https://github.com/testcontainers/testcontainers-java/commit/830f483fc8f7aff05bb3b7e6a5831a89e25fdbc6", "message": "Update docs/modules/databases/r2dbc.md\n\nCo-Authored-By: Richard North <rich.north@gmail.com>", "committedDate": "2020-04-12T13:38:05Z", "type": "commit"}, {"oid": "3db13dc3c22f1a0a009a1552704abda074ec498f", "url": "https://github.com/testcontainers/testcontainers-java/commit/3db13dc3c22f1a0a009a1552704abda074ec498f", "message": "Update docs/modules/databases/r2dbc.md\n\nCo-Authored-By: Richard North <rich.north@gmail.com>", "committedDate": "2020-04-12T13:39:09Z", "type": "commit"}, {"oid": "38e81dc1c6a23a90432cb9b2da50c07e2f609e80", "url": "https://github.com/testcontainers/testcontainers-java/commit/38e81dc1c6a23a90432cb9b2da50c07e2f609e80", "message": "Update docs/modules/databases/r2dbc.md\n\nCo-Authored-By: Richard North <rich.north@gmail.com>", "committedDate": "2020-04-12T14:20:48Z", "type": "commit"}, {"oid": "b28fb65ad718fc47309a789ba726b8297327fb67", "url": "https://github.com/testcontainers/testcontainers-java/commit/b28fb65ad718fc47309a789ba726b8297327fb67", "message": "Merge branch 'master' into r2dbc_support", "committedDate": "2020-04-12T16:03:28Z", "type": "commit"}]}