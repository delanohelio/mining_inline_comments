{"pr_number": 864, "pr_title": "PHOENIX-5261: Implement ALTER TABLE ADD COLUMN CASCADE", "pr_createdAt": "2020-08-26T19:11:35Z", "pr_url": "https://github.com/apache/phoenix/pull/864", "timeline": [{"oid": "ca33eed96c0a1173cf760b5d74ea9b71a3711daa", "url": "https://github.com/apache/phoenix/commit/ca33eed96c0a1173cf760b5d74ea9b71a3711daa", "message": "PHOENIX-5261: Implement ALTER TABLE ADD COLUMN CASCADE", "committedDate": "2020-09-15T03:35:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2MTQzMA==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489161430", "bodyText": "Nit: The comment here and line 134 are misleading. The tests are handling both tables and views.", "author": "priyankporwal", "createdAt": "2020-09-16T04:56:53Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterAddCascadeIndexIT.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.schema.types.PChar;\n+import org.apache.phoenix.schema.types.PDouble;\n+import org.apache.phoenix.schema.types.PFloat;\n+import org.apache.phoenix.schema.types.PVarchar;\n+import org.apache.phoenix.util.ColumnInfo;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.schema.MetaDataClient.INCORRECT_INDEX_NAME_S;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class AlterAddCascadeIndexIT extends ParallelStatsDisabledIT {\n+\n+    public static final String SYNTAX_ERROR = \"Syntax error\";\n+    @Rule\n+    public ExpectedException exception = ExpectedException.none();\n+    private static Connection conn;\n+    private Properties prop;\n+    private boolean isViewIndex;\n+    private String phoenixObjectName;\n+    private String indexesName;\n+    private final String tableDDLOptions;\n+\n+\n+    public AlterAddCascadeIndexIT(boolean isViewIndex, boolean mutable) {\n+        this.isViewIndex = isViewIndex;\n+        StringBuilder optionBuilder = new StringBuilder();\n+        if (!mutable) {\n+            optionBuilder.append(\" IMMUTABLE_ROWS=true\");\n+        }\n+        this.tableDDLOptions = optionBuilder.toString();\n+    }\n+\n+    @Parameters(name=\"AlterAddCascadeIndexIT_isViewIndex={0},mutable={1}\")\n+    public static Collection<Object[]> data() {\n+        return Arrays.asList(new Object[][] {\n+                { true, true},\n+                { true, false},\n+                { false, true},\n+                { false, false},\n+        });\n+    }\n+\n+    @Before\n+    public void setup() throws SQLException {\n+        prop = new Properties();\n+        conn = DriverManager.getConnection(getUrl(), prop);\n+        conn.setAutoCommit(true);\n+        conn.createStatement().execute(\"CREATE TABLE IF NOT EXISTS test.us_population (\\n\" +\n+                \"      state CHAR(2) NOT NULL,\\n\" +\n+                \"      city VARCHAR NOT NULL,\\n\" +\n+                \"      population BIGINT,\\n\" +\n+                \"      CONSTRAINT my_pk PRIMARY KEY (state, city)) \" + tableDDLOptions);\n+\n+        if(isViewIndex) {\n+            conn.createStatement().execute(\"CREATE VIEW IF NOT EXISTS test.us_population_gv\" +\n+                    \"(city_area INTEGER, avg_fam_size INTEGER) AS \" +\n+                    \"SELECT * FROM test.us_population WHERE state = 'CA'\");\n+\n+            conn.createStatement().execute(\"CREATE INDEX IF NOT EXISTS us_population_gv_gi ON \" +\n+                    \"test.us_population_gv (city_area) INCLUDE (population)\");\n+            conn.createStatement().execute(\"CREATE INDEX IF NOT EXISTS us_population_gv_gi_2 ON \" +\n+                    \"test.us_population_gv (avg_fam_size) INCLUDE (population)\");\n+            phoenixObjectName = \"test.us_population_gv\";\n+            indexesName = \"us_population_gv_gi, us_population_gv_gi_2\";\n+        } else {\n+            conn.createStatement().execute(\"CREATE INDEX IF NOT EXISTS us_population_gi ON \" +\n+                    \"test.us_population (population)\");\n+            conn.createStatement().execute(\"CREATE INDEX IF NOT EXISTS us_population_gi_2 ON \" +\n+                    \"test.us_population (state, population)\");\n+            phoenixObjectName = \"test.us_population\";\n+            indexesName = \"us_population_gi, us_population_gi_2\";\n+        }\n+    }\n+\n+    // Test with ALTER TABLE CASCADE INDEX ALL", "originalCommit": "ca33eed96c0a1173cf760b5d74ea9b71a3711daa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMTA0Mw==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489611043", "bodyText": "nit: Rename as indexName", "author": "gokceni", "createdAt": "2020-09-16T17:41:10Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterAddCascadeIndexIT.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.schema.types.PChar;\n+import org.apache.phoenix.schema.types.PDouble;\n+import org.apache.phoenix.schema.types.PFloat;\n+import org.apache.phoenix.schema.types.PVarchar;\n+import org.apache.phoenix.util.ColumnInfo;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.schema.MetaDataClient.INCORRECT_INDEX_NAME_S;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class AlterAddCascadeIndexIT extends ParallelStatsDisabledIT {\n+\n+    public static final String SYNTAX_ERROR = \"Syntax error\";\n+    @Rule\n+    public ExpectedException exception = ExpectedException.none();\n+    private static Connection conn;\n+    private Properties prop;\n+    private boolean isViewIndex;\n+    private String phoenixObjectName;\n+    private String indexesName;", "originalCommit": "ca33eed96c0a1173cf760b5d74ea9b71a3711daa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMjYzOA==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489612638", "bodyText": "nit: Refactor into its own function", "author": "gokceni", "createdAt": "2020-09-16T17:44:07Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -3800,6 +3814,27 @@ public MutationState addColumn(PTable table, List<ColumnDef> origColumnDefs,\n                                 .setTableName(tableName).build().buildException();\n                             }\n                             PColumn column = newColumn(position++, colDef, PrimaryKeyConstraint.EMPTY, table.getDefaultFamilyName() == null ? null : table.getDefaultFamilyName().getString(), true, columnQualifierBytes, willBeImmutableRows);\n+                            HashMap<PTable, PColumn> indexColumn = null;\n+                            if (cascade) {", "originalCommit": "ca33eed96c0a1173cf760b5d74ea9b71a3711daa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMzA3Mw==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489613073", "bodyText": "Is there a function for this?", "author": "gokceni", "createdAt": "2020-09-16T17:44:52Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/PTableImpl.java", "diffHunk": "@@ -1524,6 +1525,40 @@ public Integer getBucketNum() {\n         return indexes;\n     }\n \n+    @Override\n+    public List<PTable> getIndexes(boolean viewOnly) {\n+        List<PTable> indexes = new ArrayList<>();\n+        indexes.addAll(this.indexes);\n+        if (viewOnly) {\n+            for (PTable index: this.indexes) {\n+                if(index.getTableName().toString().contains(\"#\")) {", "originalCommit": "ca33eed96c0a1173cf760b5d74ea9b71a3711daa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc0ODQ3NA==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489748474", "bodyText": "What are these specially names tables? Related to Gokcen's question - perhaps a well-names function would help readability.", "author": "priyankporwal", "createdAt": "2020-09-16T20:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMzA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MDcyNA==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r490480724", "bodyText": "Added a comment.", "author": "swaroopak", "createdAt": "2020-09-17T18:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMzA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMzYwMA==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489613600", "bodyText": "Can you add a comment what this loop is doing?", "author": "gokceni", "createdAt": "2020-09-16T17:45:46Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/PTableImpl.java", "diffHunk": "@@ -1524,6 +1525,40 @@ public Integer getBucketNum() {\n         return indexes;\n     }\n \n+    @Override\n+    public List<PTable> getIndexes(boolean viewOnly) {\n+        List<PTable> indexes = new ArrayList<>();\n+        indexes.addAll(this.indexes);\n+        if (viewOnly) {\n+            for (PTable index: this.indexes) {\n+                if(index.getTableName().toString().contains(\"#\")) {\n+                    indexes.remove(index);\n+                }\n+            }\n+        }\n+        return indexes;\n+    }\n+\n+    @Override\n+    public List<PTable> getIndexes(List<NamedNode> indexes) {\n+        List<PTable> indexesPTable = Lists.newArrayListWithExpectedSize(indexes.size());\n+        List<String> indexesParam = Lists.newArrayListWithExpectedSize(indexes.size());\n+        for (NamedNode index : indexes) {\n+            indexesParam.add(index.getName());\n+        }\n+        for (PTable index : this.indexes) {", "originalCommit": "ca33eed96c0a1173cf760b5d74ea9b71a3711daa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc0MzYyOA==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489743628", "bodyText": "Why does this have to be special error? I assume add PK column to phoenix table/view is not supported anyways. Also, if it has to be a new error then replace \"CASCADE\" with \"CASCADE INDEX\".", "author": "priyankporwal", "createdAt": "2020-09-16T20:45:20Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java", "diffHunk": "@@ -528,8 +528,9 @@ public SQLException newException(SQLExceptionInfo info) {\n             \"Cannot use a connection with SCN set to upsert data for a table with indexes.\"),\n \n     CANNOT_PERFORM_DDL_WITH_PENDING_MUTATIONS(904, \"43M15\",\n-            \"Cannot perform DDL with pending mutations. Commit or rollback mutations before performing DDL\");\n+            \"Cannot perform DDL with pending mutations. Commit or rollback mutations before performing DDL\"),\n \n+    NOT_SUPPORTED_CASCADE_FEATURE_PK(905, \"43M16\", \"CASCADE feature is not supported to add PK column\");", "originalCommit": "2936d2f53275fe88db068f1232e359b54ebe931c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1MjQ1OQ==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489752459", "bodyText": "Shouldn't this be a SQLException with its own SQLExceptionCode?", "author": "gjacoby126", "createdAt": "2020-09-16T21:02:58Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -3629,14 +3632,25 @@ private void mutateStringProperty(String tenantId, String schemaName, String tab\n \n     public MutationState addColumn(AddColumnStatement statement) throws SQLException {\n         PTable table = FromCompiler.getResolver(statement, connection).getTables().get(0).getTable();\n-        return addColumn(table, statement.getColumnDefs(), statement.getProps(), statement.ifNotExists(), false, statement.getTable(), statement.getTableType());\n+        return addColumn(table, statement.getColumnDefs(), statement.getProps(), statement.ifNotExists(), false, statement.getTable(), statement.getTableType(), statement.isCascade(), statement.getIndexes());\n     }\n \n     public MutationState addColumn(PTable table, List<ColumnDef> origColumnDefs,\n             ListMultimap<String, Pair<String, Object>> stmtProperties, boolean ifNotExists,\n-            boolean removeTableProps, NamedTableNode namedTableNode, PTableType tableType)\n+            boolean removeTableProps, NamedTableNode namedTableNode, PTableType tableType, boolean cascade, List<NamedNode> indexes)\n                     throws SQLException {\n         connection.rollback();\n+        List<PTable> indexesPTable = Lists.newArrayListWithExpectedSize(indexes != null ?\n+                indexes.size() : table.getIndexes().size());\n+        // if cascade keyword is passed and indexes are provided either implicitly or explicitly\n+        if (cascade && (indexes == null || !indexes.isEmpty())) {\n+            boolean isView = table.getType().equals(PTableType.VIEW);\n+            indexesPTable = indexes == null ?\n+                    table.getIndexes(isView) : table.getIndexes(indexes);\n+            if (indexesPTable == null) {\n+                throw new RuntimeException(INCORRECT_INDEX_NAME_S);", "originalCommit": "2936d2f53275fe88db068f1232e359b54ebe931c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NjUyMQ==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489756521", "bodyText": "nit: List.remove() returns the item if the item was present, so a contains() followed by a remove() is redundant because remove() itself can be used as a contains().", "author": "gjacoby126", "createdAt": "2020-09-16T21:11:07Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/PTableImpl.java", "diffHunk": "@@ -1524,6 +1525,40 @@ public Integer getBucketNum() {\n         return indexes;\n     }\n \n+    @Override\n+    public List<PTable> getIndexes(boolean viewOnly) {\n+        List<PTable> indexes = new ArrayList<>();\n+        indexes.addAll(this.indexes);\n+        if (viewOnly) {\n+            for (PTable index: this.indexes) {\n+                if(index.getTableName().toString().contains(\"#\")) {\n+                    indexes.remove(index);\n+                }\n+            }\n+        }\n+        return indexes;\n+    }\n+\n+    @Override\n+    public List<PTable> getIndexes(List<NamedNode> indexes) {\n+        List<PTable> indexesPTable = Lists.newArrayListWithExpectedSize(indexes.size());\n+        List<String> indexesParam = Lists.newArrayListWithExpectedSize(indexes.size());\n+        for (NamedNode index : indexes) {\n+            indexesParam.add(index.getName());\n+        }\n+        for (PTable index : this.indexes) {\n+            if(indexesParam.contains(index.getTableName().getString())) {", "originalCommit": "2936d2f53275fe88db068f1232e359b54ebe931c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1OTU0OQ==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489759549", "bodyText": "Please create new tables for each test rather than dropping identical tables after each test. Dropping tables is really slow. See PHOENIX-5942.", "author": "gjacoby126", "createdAt": "2020-09-16T21:17:17Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterAddCascadeIndexIT.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.schema.types.PDecimal;\n+import org.apache.phoenix.schema.types.PDouble;\n+import org.apache.phoenix.schema.types.PFloat;\n+import org.apache.phoenix.schema.types.PVarchar;\n+import org.apache.phoenix.util.ColumnInfo;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.schema.MetaDataClient.INCORRECT_INDEX_NAME_S;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class AlterAddCascadeIndexIT extends ParallelStatsDisabledIT {\n+\n+    public static final String SYNTAX_ERROR = \"Syntax error\";\n+    @Rule\n+    public ExpectedException exception = ExpectedException.none();\n+    private static Connection conn;\n+    private Properties prop;\n+    private boolean isViewIndex;\n+    private String phoenixObjectName;\n+    private String indexesName;\n+    private final String tableDDLOptions;\n+\n+\n+    public AlterAddCascadeIndexIT(boolean isViewIndex, boolean mutable) {\n+        this.isViewIndex = isViewIndex;\n+        StringBuilder optionBuilder = new StringBuilder();\n+        if (!mutable) {\n+            optionBuilder.append(\" IMMUTABLE_ROWS=true\");\n+        }\n+        this.tableDDLOptions = optionBuilder.toString();\n+    }\n+\n+    @Parameters(name=\"AlterAddCascadeIndexIT_isViewIndex={0},mutable={1}\")\n+    public static Collection<Object[]> data() {\n+        return Arrays.asList(new Object[][] {\n+                { true, true},\n+                { true, false},\n+                { false, true},\n+                { false, false},\n+        });\n+    }\n+\n+    @Before\n+    public void setup() throws SQLException {\n+        prop = new Properties();", "originalCommit": "2936d2f53275fe88db068f1232e359b54ebe931c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc2MDgyOQ==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r489760829", "bodyText": "Do we need a local index too?", "author": "gjacoby126", "createdAt": "2020-09-16T21:20:04Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterAddCascadeIndexIT.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.schema.types.PDecimal;\n+import org.apache.phoenix.schema.types.PDouble;\n+import org.apache.phoenix.schema.types.PFloat;\n+import org.apache.phoenix.schema.types.PVarchar;\n+import org.apache.phoenix.util.ColumnInfo;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.schema.MetaDataClient.INCORRECT_INDEX_NAME_S;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class AlterAddCascadeIndexIT extends ParallelStatsDisabledIT {\n+\n+    public static final String SYNTAX_ERROR = \"Syntax error\";\n+    @Rule\n+    public ExpectedException exception = ExpectedException.none();\n+    private static Connection conn;\n+    private Properties prop;\n+    private boolean isViewIndex;\n+    private String phoenixObjectName;\n+    private String indexesName;\n+    private final String tableDDLOptions;\n+\n+\n+    public AlterAddCascadeIndexIT(boolean isViewIndex, boolean mutable) {\n+        this.isViewIndex = isViewIndex;\n+        StringBuilder optionBuilder = new StringBuilder();\n+        if (!mutable) {\n+            optionBuilder.append(\" IMMUTABLE_ROWS=true\");\n+        }\n+        this.tableDDLOptions = optionBuilder.toString();\n+    }\n+\n+    @Parameters(name=\"AlterAddCascadeIndexIT_isViewIndex={0},mutable={1}\")\n+    public static Collection<Object[]> data() {\n+        return Arrays.asList(new Object[][] {\n+                { true, true},\n+                { true, false},\n+                { false, true},\n+                { false, false},\n+        });\n+    }\n+\n+    @Before\n+    public void setup() throws SQLException {\n+        prop = new Properties();\n+        conn = DriverManager.getConnection(getUrl(), prop);\n+        conn.setAutoCommit(true);\n+        conn.createStatement().execute(\"CREATE TABLE IF NOT EXISTS test.us_population (\\n\" +\n+                \"      state CHAR(2) NOT NULL,\\n\" +\n+                \"      city VARCHAR NOT NULL,\\n\" +\n+                \"      population BIGINT,\\n\" +\n+                \"      CONSTRAINT my_pk PRIMARY KEY (state, city)) \" + tableDDLOptions);\n+\n+        if(isViewIndex) {\n+            conn.createStatement().execute(\"CREATE VIEW IF NOT EXISTS test.us_population_gv\" +\n+                    \"(city_area INTEGER, avg_fam_size INTEGER) AS \" +\n+                    \"SELECT * FROM test.us_population WHERE state = 'CA'\");\n+\n+            conn.createStatement().execute(\"CREATE INDEX IF NOT EXISTS us_population_gv_gi ON \" +\n+                    \"test.us_population_gv (city_area) INCLUDE (population)\");\n+            conn.createStatement().execute(\"CREATE INDEX IF NOT EXISTS us_population_gv_gi_2 ON \" +", "originalCommit": "2936d2f53275fe88db068f1232e359b54ebe931c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MTYzNQ==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r490481635", "bodyText": "At this point, we are focusing on global index only. I ll add a test for local index and exception around it.", "author": "swaroopak", "createdAt": "2020-09-17T18:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc2MDgyOQ=="}], "type": "inlineReview"}, {"oid": "80656f1c47e704193ab7be7c3e8da097b72e6049", "url": "https://github.com/apache/phoenix/commit/80656f1c47e704193ab7be7c3e8da097b72e6049", "message": "Refactoring and more test scenario on local index", "committedDate": "2020-09-17T21:07:48Z", "type": "forcePushed"}, {"oid": "07e22304b3fb1b3d9766fb7ea2da5171ad8b5d77", "url": "https://github.com/apache/phoenix/commit/07e22304b3fb1b3d9766fb7ea2da5171ad8b5d77", "message": "Refactoring and more test scenario on local index", "committedDate": "2020-09-17T21:09:16Z", "type": "forcePushed"}, {"oid": "54e356f667689120361fdff8e9c6e644ce1244a5", "url": "https://github.com/apache/phoenix/commit/54e356f667689120361fdff8e9c6e644ce1244a5", "message": "Fixing ordinal position issue", "committedDate": "2020-09-18T19:37:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4MTYyNQ==", "url": "https://github.com/apache/phoenix/pull/864#discussion_r492281625", "bodyText": "Let's also have one with a mix of a global and local index in the cascade clause to make sure that we still throw an exception.", "author": "gjacoby126", "createdAt": "2020-09-21T19:02:41Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterAddCascadeIndexIT.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.schema.types.PDecimal;\n+import org.apache.phoenix.schema.types.PDouble;\n+import org.apache.phoenix.schema.types.PFloat;\n+import org.apache.phoenix.schema.types.PVarchar;\n+import org.apache.phoenix.util.ColumnInfo;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Properties;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class AlterAddCascadeIndexIT extends ParallelStatsDisabledIT {\n+\n+    public static final String SYNTAX_ERROR = \"Syntax error\";\n+    @Rule\n+    public ExpectedException exception = ExpectedException.none();\n+    private static Connection conn;\n+    private Properties prop;\n+    private boolean isViewIndex;\n+    private String phoenixObjectName;\n+    private String indexNames;\n+    private final String tableDDLOptions;\n+    String fullIndexNameOne, fullIndexNameTwo;\n+\n+\n+    public AlterAddCascadeIndexIT(boolean isViewIndex, boolean mutable) {\n+        this.isViewIndex = isViewIndex;\n+        StringBuilder optionBuilder = new StringBuilder();\n+        if (!mutable) {\n+            optionBuilder.append(\" IMMUTABLE_ROWS=true\");\n+        }\n+        this.tableDDLOptions = optionBuilder.toString();\n+    }\n+\n+    @Parameters(name=\"AlterAddCascadeIndexIT_isViewIndex={0},mutable={1}\")\n+    public static Collection<Object[]> data() {\n+        return Arrays.asList(new Object[][] {\n+                { true, true},\n+                { true, false},\n+                { false, true},\n+                { false, false},\n+        });\n+    }\n+\n+    @Before\n+    public void setup() throws SQLException {\n+        prop = new Properties();\n+        conn = DriverManager.getConnection(getUrl(), prop);\n+        conn.setAutoCommit(true);\n+        String schemaName = \"S_\"+generateUniqueName();\n+        String indexNameOne = \"I_\"+generateUniqueName();\n+        String indexNameTwo = \"I_\"+generateUniqueName();\n+        String tableName = \"T_\"+generateUniqueName();\n+        String viewName = \"V_\"+generateUniqueName();\n+        String fullViewName = SchemaUtil.getQualifiedTableName(schemaName, viewName);\n+        String fullTableName = SchemaUtil.getQualifiedTableName(schemaName, tableName);\n+        conn.createStatement().execute(\"CREATE TABLE IF NOT EXISTS \" + fullTableName + \" (\\n\" +\n+                \"      state CHAR(2) NOT NULL,\\n\" +\n+                \"      city VARCHAR NOT NULL,\\n\" +\n+                \"      population BIGINT,\\n\" +\n+                \"      CONSTRAINT my_pk PRIMARY KEY (state, city)) \" + tableDDLOptions);\n+\n+        if(isViewIndex) {\n+            conn.createStatement().execute(\"CREATE VIEW IF NOT EXISTS \" + fullViewName +\n+                    \" (city_area INTEGER, avg_fam_size INTEGER) AS \" +\n+                    \"SELECT * FROM \"+fullTableName+\" WHERE state = 'CA'\");\n+\n+            conn.createStatement().execute(\"CREATE INDEX IF NOT EXISTS \" + indexNameOne + \" ON \" +\n+                    fullViewName+\" (city_area) INCLUDE (population)\");\n+            conn.createStatement().execute(\"CREATE INDEX IF NOT EXISTS \" + indexNameTwo + \" ON \" +\n+                    fullViewName+\" (avg_fam_size) INCLUDE (population)\");\n+            phoenixObjectName = fullViewName;\n+        } else {\n+            conn.createStatement().execute(\"CREATE INDEX IF NOT EXISTS \" + indexNameOne + \" ON \" +\n+                    fullTableName+\" (population)\");\n+            conn.createStatement().execute(\"CREATE INDEX IF NOT EXISTS \" + indexNameTwo + \" ON \" +\n+                    fullTableName+\" (state, population)\");\n+            phoenixObjectName = fullTableName;\n+        }\n+        fullIndexNameOne = SchemaUtil.getQualifiedTableName(schemaName, indexNameOne);\n+        fullIndexNameTwo = SchemaUtil.getQualifiedTableName(schemaName, indexNameTwo);\n+        indexNames = indexNameOne +\", \"+indexNameTwo;\n+    }\n+\n+\n+    // Test with ALTER TABLE/VIEW CASCADE INDEX ALL with upserting into new column\n+    @Test\n+    public void testAlterDBOAddCascadeIndexAllUpsert() throws Exception {\n+        String query = \"ALTER \" +(isViewIndex? \"VIEW \" : \"TABLE \") + phoenixObjectName + \" ADD new_column_3 VARCHAR(64) CASCADE INDEX ALL\";\n+        conn.createStatement().execute(query);\n+        PreparedStatement ps;\n+        if(isViewIndex) {\n+            ps = conn.prepareStatement(\"UPSERT INTO \" + phoenixObjectName +\n+                    \"(state,city,population,city_area,avg_fam_size,new_column_3) \" +\n+                    \"VALUES('CA','Santa Barbara',912332,1300,4,'test_column')\");\n+        } else {\n+            ps = conn.prepareStatement(\"UPSERT INTO \" + phoenixObjectName +\n+                    \"(state,city,population,new_column_3) \" +\n+                    \"VALUES('CA','Santa Barbara',912332,'test_column')\");\n+        }\n+        ps.executeUpdate();\n+        ColumnInfo [] columnArray =  {new ColumnInfo(\"new_column_3\", PVarchar.INSTANCE.getSqlType(), 64)};\n+        ColumnInfo [] columnIndexArray =  {new ColumnInfo(\"0:new_column_3\", PVarchar.INSTANCE.getSqlType(), 64)};\n+        if(isViewIndex) {\n+            assertDBODefinition(conn, phoenixObjectName, PTableType.VIEW, 6, columnArray, false);\n+            assertDBODefinition(conn, fullIndexNameOne, PTableType.INDEX, 5, columnIndexArray, false);\n+            assertDBODefinition(conn, fullIndexNameTwo, PTableType.INDEX, 5, columnIndexArray, false);\n+        } else {\n+            assertDBODefinition(conn, phoenixObjectName, PTableType.TABLE, 4, columnArray, false);\n+            assertDBODefinition(conn, fullIndexNameOne, PTableType.INDEX, 4, columnIndexArray, false);\n+            assertDBODefinition(conn, fullIndexNameTwo, PTableType.INDEX, 4, columnIndexArray, false);\n+        }\n+\n+    }\n+\n+    // Test with CASCADE INDEX <index_name>\n+    @Test\n+    public void testAlterDBOAddCascadeIndex() throws Exception {\n+        ColumnInfo [] columnArray =  {new ColumnInfo(\"new_column_1\", PFloat.INSTANCE.getSqlType())};\n+        ColumnInfo [] columnIndexArray =  {new ColumnInfo(\"0:new_column_1\", PDecimal.INSTANCE.getSqlType())};\n+\n+        String query = \"ALTER \" + (isViewIndex? \"VIEW \" : \"TABLE \")\n+                + phoenixObjectName + \" ADD new_column_1 FLOAT CASCADE INDEX \" + indexNames.split(\",\")[0];\n+        conn.createStatement().execute(query);\n+        if(isViewIndex) {\n+            assertDBODefinition(conn, phoenixObjectName, PTableType.VIEW, 6, columnArray, false);\n+            assertDBODefinition(conn, fullIndexNameOne, PTableType.INDEX, 5, columnIndexArray, false);\n+            assertDBODefinition(conn, fullIndexNameTwo, PTableType.INDEX, 4, columnIndexArray, true);\n+        } else {\n+            assertDBODefinition(conn, phoenixObjectName, PTableType.TABLE, 4, columnArray, false);\n+            assertDBODefinition(conn, fullIndexNameOne, PTableType.INDEX, 4, columnIndexArray, false);\n+            assertDBODefinition(conn, fullIndexNameTwo, PTableType.INDEX, 3, columnIndexArray, true);\n+        }\n+    }\n+\n+    // Test with CASCADE INDEX <index_name>\n+    @Test\n+    public void testAlterDBOAddCascadeTwoColsOneIndex() throws Exception {\n+        ColumnInfo [] columnArray =  {new ColumnInfo(\"new_column_1\", PFloat.INSTANCE.getSqlType()),\n+                new ColumnInfo(\"new_column_2\", PDouble.INSTANCE.getSqlType())};\n+        ColumnInfo [] columnIndexArray =  {new ColumnInfo(\"0:new_column_1\", PDecimal.INSTANCE.getSqlType()),\n+                new ColumnInfo(\"0:new_column_2\", PDecimal.INSTANCE.getSqlType())};\n+        String query = \"ALTER \" + (isViewIndex ? \"VIEW \" : \"TABLE \") + phoenixObjectName\n+                + \" ADD new_column_1 FLOAT, new_column_2 DOUBLE CASCADE INDEX \" + indexNames.split(\",\")[0];\n+        conn.createStatement().execute(query);\n+        if(isViewIndex) {\n+            assertDBODefinition(conn, phoenixObjectName, PTableType.VIEW, 7, columnArray, false);\n+            assertDBODefinition(conn, fullIndexNameOne, PTableType.INDEX, 6, columnIndexArray, false);\n+            assertDBODefinition(conn, fullIndexNameTwo, PTableType.INDEX, 4, columnIndexArray, true);\n+        } else {\n+            assertDBODefinition(conn, phoenixObjectName, PTableType.TABLE, 5, columnArray, false);\n+            assertDBODefinition(conn, fullIndexNameOne, PTableType.INDEX, 5, columnIndexArray, false);\n+            assertDBODefinition(conn, fullIndexNameTwo, PTableType.INDEX, 3, columnIndexArray, true);\n+        }\n+\n+    }\n+\n+    // Test with CASCADE INDEX <index_name>, <index_name>\n+    @Test\n+    public void testAlterDBOAddCascadeIndexes() throws Exception {\n+        ColumnInfo [] columnArray = {new ColumnInfo(\"new_column_1\", PDouble.INSTANCE.getSqlType())};\n+        ColumnInfo [] columnIndexArray = {new ColumnInfo(\"0:new_column_1\", PDecimal.INSTANCE.getSqlType())};\n+        String query = \"ALTER \" + (isViewIndex ? \"VIEW \" : \"TABLE \")\n+                + phoenixObjectName + \" ADD new_column_1 DOUBLE CASCADE INDEX \" + indexNames;\n+        conn.createStatement().execute(query);\n+        if(isViewIndex) {\n+            assertDBODefinition(conn, phoenixObjectName, PTableType.VIEW, 6, columnArray, false);\n+            assertDBODefinition(conn, fullIndexNameOne, PTableType.INDEX, 5, columnIndexArray, false);\n+            assertDBODefinition(conn, fullIndexNameTwo, PTableType.INDEX, 5, columnIndexArray, false);\n+        } else {\n+            assertDBODefinition(conn, phoenixObjectName, PTableType.TABLE, 4, columnArray, false);\n+            assertDBODefinition(conn, fullIndexNameOne, PTableType.INDEX, 4, columnIndexArray, false);\n+            assertDBODefinition(conn, fullIndexNameTwo, PTableType.INDEX, 4, columnIndexArray, false);\n+        }\n+    }\n+\n+    // Test with CASCADE INDEX <index_name>, <index_name>\n+    @Test\n+    public void testAlterDBOAddCascadeTwoColsTwoIndexes() throws Exception {\n+        ColumnInfo [] columnArray =  {new ColumnInfo(\"new_column_1\", PFloat.INSTANCE.getSqlType()),\n+                new ColumnInfo(\"new_column_2\", PDouble.INSTANCE.getSqlType())};\n+        ColumnInfo [] columIndexArray =  {new ColumnInfo(\"0:new_column_1\", PDecimal.INSTANCE.getSqlType()),\n+                new ColumnInfo(\"0:new_column_2\", PDecimal.INSTANCE.getSqlType())};\n+\n+        String query = \"ALTER \" + (isViewIndex ? \"VIEW \" : \"TABLE \")\n+                + phoenixObjectName + \" ADD new_column_1 FLOAT, new_column_2 DOUBLE CASCADE INDEX \" + indexNames;\n+        conn.createStatement().execute(query);\n+        if(isViewIndex) {\n+            assertDBODefinition(conn, phoenixObjectName, PTableType.VIEW, 7, columnArray, false);\n+            assertDBODefinition(conn, fullIndexNameOne, PTableType.INDEX, 6, columIndexArray, false);\n+            assertDBODefinition(conn, fullIndexNameTwo, PTableType.INDEX, 6, columIndexArray, false);\n+        } else {\n+            assertDBODefinition(conn, phoenixObjectName, PTableType.TABLE, 5, columnArray, false);\n+            assertDBODefinition(conn, fullIndexNameOne, PTableType.INDEX, 5, columIndexArray, false);\n+            assertDBODefinition(conn, fullIndexNameTwo, PTableType.INDEX, 5, columIndexArray, false);\n+        }\n+\n+    }\n+\n+    // Exception for invalid grammar\n+    @Test\n+    public void testAlterDBOException() throws SQLException {\n+\n+        String query = \"ALTER \" + (isViewIndex ? \"VIEW \" : \"TABLE \") + phoenixObjectName + \" ADD new_column VARCHAR ALL\";\n+        try {\n+            conn.createStatement().execute(query);\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().contains(SYNTAX_ERROR));\n+        }\n+\n+        query = \"ALTER \" + (isViewIndex ? \"VIEW \" : \"TABLE \") + phoenixObjectName\n+                + \" ADD new_column VARCHAR CASCADE \" + indexNames.split(\",\")[0];\n+        try {\n+            conn.createStatement().execute(query);\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().contains(SYNTAX_ERROR));\n+        }\n+\n+        query = \"ALTER \" + (isViewIndex ? \"VIEW \" : \"TABLE \") + phoenixObjectName\n+                + \" ADD new_column VARCHAR INDEX \" + indexNames.split(\",\")[0];\n+        try {\n+            conn.createStatement().execute(query);\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().contains(SYNTAX_ERROR));\n+        }\n+\n+        query = \"ALTER \" + (isViewIndex ? \"VIEW \" : \"TABLE \")\n+                + phoenixObjectName + \" ADD new_column_1 DOUBLE CASCADE INDEX INCORRECT_NAME\";\n+        try {\n+            conn.createStatement().execute(query);\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().contains(SQLExceptionCode.INCORRECT_INDEX_NAME.getMessage()));\n+        }\n+\n+        String localIndex = generateUniqueName();", "originalCommit": "54e356f667689120361fdff8e9c6e644ce1244a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6a73728f8c9443311c80de7a11f3507767b9d183", "url": "https://github.com/apache/phoenix/commit/6a73728f8c9443311c80de7a11f3507767b9d183", "message": "PHOENIX-5261: Implement ALTER TABLE ADD COLUMN CASCADE", "committedDate": "2020-09-21T21:47:58Z", "type": "commit"}, {"oid": "6a73728f8c9443311c80de7a11f3507767b9d183", "url": "https://github.com/apache/phoenix/commit/6a73728f8c9443311c80de7a11f3507767b9d183", "message": "PHOENIX-5261: Implement ALTER TABLE ADD COLUMN CASCADE", "committedDate": "2020-09-21T21:47:58Z", "type": "forcePushed"}]}