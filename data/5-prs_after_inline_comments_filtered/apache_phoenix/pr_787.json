{"pr_number": 787, "pr_title": "PHOENIX-5890: Port Phoenix-5799 to master", "pr_createdAt": "2020-05-22T23:22:36Z", "pr_url": "https://github.com/apache/phoenix/pull/787", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5MTI3Ng==", "url": "https://github.com/apache/phoenix/pull/787#discussion_r430691276", "bodyText": "@swaroopak - need to close indexHTable if not null as well. (The original 5799 did so too)", "author": "gjacoby126", "createdAt": "2020-05-26T20:33:09Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationResultRepository.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.HColumnDescriptor;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HTableDescriptor;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.coprocessor.MetaDataProtocol;\n+import org.apache.phoenix.hbase.index.table.HTableFactory;\n+import org.apache.phoenix.hbase.index.util.ImmutableBytesPtr;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.mapreduce.index.IndexTool;\n+import org.apache.phoenix.query.ConnectionQueryServices;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.util.ByteUtil;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+public class IndexVerificationResultRepository {\n+    private Table resultHTable;\n+    private Table indexHTable;\n+    public static final byte[] ROW_KEY_SEPARATOR_BYTE = Bytes.toBytes(\"|\");\n+    public final static String RESULT_TABLE_NAME = \"PHOENIX_INDEX_TOOL_RESULT\";\n+    public final static byte[] RESULT_TABLE_NAME_BYTES = Bytes.toBytes(RESULT_TABLE_NAME);\n+    public final static byte[] RESULT_TABLE_COLUMN_FAMILY = QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES;\n+    public static String SCANNED_DATA_ROW_COUNT = \"ScannedDataRowCount\";\n+    public final static byte[] SCANNED_DATA_ROW_COUNT_BYTES = Bytes.toBytes(SCANNED_DATA_ROW_COUNT);\n+    public static String REBUILT_INDEX_ROW_COUNT = \"RebuiltIndexRowCount\";\n+    public final static byte[] REBUILT_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(REBUILT_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_VALID_INDEX_ROW_COUNT = \"BeforeRebuildValidIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_VALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_VALID_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT = \"BeforeRebuildExpiredIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT = \"BeforeRebuildMissingIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT = \"BeforeRebuildInvalidIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_VALID_INDEX_ROW_COUNT = \"AfterValidExpiredIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_VALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_VALID_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT = \"AfterRebuildExpiredIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_MISSING_INDEX_ROW_COUNT = \"AfterRebuildMissingIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_MISSING_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_INVALID_INDEX_ROW_COUNT = \"AfterRebuildInvalidIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_INVALID_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS = \"AfterRebuildInvalidIndexRowCountCozExtraCells\";\n+    public final static byte[] AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS_BYTES = Bytes.toBytes(AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS);\n+    public static String AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS = \"AfterRebuildInvalidIndexRowCountCozMissingCells\";\n+    public final static byte[] AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS_BYTES = Bytes.toBytes(AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS);\n+    public static String BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS = \"BeforeRebuildInvalidIndexRowCountCozExtraCells\";\n+    public final static byte[] BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS_BYTES = Bytes.toBytes(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS);\n+    public static String BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS = \"BeforeRebuildInvalidIndexRowCountCozMissingCells\";\n+    public final static byte[] BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS_BYTES = Bytes.toBytes(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS);\n+\n+    /***\n+     * Only usable for read methods\n+     */\n+    public IndexVerificationResultRepository(){\n+\n+    }\n+\n+    public IndexVerificationResultRepository(Connection conn, byte[] indexNameBytes) throws SQLException {\n+        resultHTable = getTable(conn, RESULT_TABLE_NAME_BYTES);\n+        indexHTable = getTable(conn, indexNameBytes);\n+    }\n+\n+    public IndexVerificationResultRepository(byte[] indexName,\n+                                             HTableFactory hTableFactory) throws IOException {\n+        resultHTable = hTableFactory.getTable(new ImmutableBytesPtr(RESULT_TABLE_NAME_BYTES));\n+        indexHTable = hTableFactory.getTable(new ImmutableBytesPtr(indexName));\n+    }\n+\n+    public void createResultTable(Connection connection) throws IOException, SQLException {\n+        ConnectionQueryServices queryServices = connection.unwrap(PhoenixConnection.class).getQueryServices();\n+        Admin admin = queryServices.getAdmin();\n+\n+        if (!admin.tableExists(TableName.valueOf(RESULT_TABLE_NAME))) {\n+            HTableDescriptor tableDescriptor = new\n+                HTableDescriptor(TableName.valueOf(RESULT_TABLE_NAME));\n+            tableDescriptor.setValue(HColumnDescriptor.TTL, String.valueOf(MetaDataProtocol.DEFAULT_LOG_TTL));\n+            HColumnDescriptor columnDescriptor = new HColumnDescriptor(RESULT_TABLE_COLUMN_FAMILY);\n+            tableDescriptor.addFamily(columnDescriptor);\n+            admin.createTable(tableDescriptor);\n+        }\n+    }\n+    public static byte[] generateResultTableRowKey(long ts, byte[] indexTableName,  byte [] regionName,\n+                                                    byte[] startRow, byte[] stopRow) {\n+        byte[] keyPrefix = Bytes.toBytes(Long.toString(ts));\n+        int targetOffset = 0;\n+        // The row key for the result table : timestamp | index table name | datable table region name |\n+        //                                    scan start row | scan stop row\n+        byte[] rowKey = new byte[keyPrefix.length + ROW_KEY_SEPARATOR_BYTE.length + indexTableName.length +\n+            ROW_KEY_SEPARATOR_BYTE.length + regionName.length + ROW_KEY_SEPARATOR_BYTE.length +\n+            startRow.length + ROW_KEY_SEPARATOR_BYTE.length + stopRow.length];\n+        Bytes.putBytes(rowKey, targetOffset, keyPrefix, 0, keyPrefix.length);\n+        targetOffset += keyPrefix.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, indexTableName, 0, indexTableName.length);\n+        targetOffset += indexTableName.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, regionName, 0, regionName.length);\n+        targetOffset += regionName.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, startRow, 0, startRow.length);\n+        targetOffset += startRow.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, stopRow, 0, stopRow.length);\n+        return rowKey;\n+    }\n+\n+    public void logToIndexToolResultTable(IndexToolVerificationResult verificationResult,\n+                                          IndexTool.IndexVerifyType verifyType, byte[] region) throws IOException {\n+        long scanMaxTs = verificationResult.getScanMaxTs();\n+        byte[] rowKey = generateResultTableRowKey(scanMaxTs, indexHTable.getName().toBytes(),\n+            region, verificationResult.getStartRow(),\n+            verificationResult.getStopRow());\n+        Put put = new Put(rowKey);\n+        put.addColumn(RESULT_TABLE_COLUMN_FAMILY, SCANNED_DATA_ROW_COUNT_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getScannedDataRowCount())));\n+        put.addColumn(RESULT_TABLE_COLUMN_FAMILY, REBUILT_INDEX_ROW_COUNT_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getRebuiltIndexRowCount())));\n+        if (verifyType == IndexTool.IndexVerifyType.BEFORE || verifyType == IndexTool.IndexVerifyType.BOTH ||\n+            verifyType == IndexTool.IndexVerifyType.ONLY) {\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_VALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildValidIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildExpiredIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildMissingIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildInvalidIndexRowCount())));\n+        }\n+        if (verifyType == IndexTool.IndexVerifyType.AFTER || verifyType == IndexTool.IndexVerifyType.BOTH) {\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_VALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildValidIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildExpiredIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildMissingIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildInvalidIndexRowCount())));\n+        }\n+        resultHTable.put(put);\n+    }\n+\n+    public IndexToolVerificationResult getVerificationResult(Connection conn, long ts) throws IOException, SQLException {\n+        Table hTable = getTable(conn, RESULT_TABLE_NAME_BYTES);\n+        return getVerificationResult(hTable, ts);\n+    }\n+\n+    public Table getTable(Connection conn, byte[] tableName) throws SQLException {\n+        return conn.unwrap(PhoenixConnection.class).getQueryServices()\n+                .getTable(tableName);\n+    }\n+\n+    public IndexToolVerificationResult getVerificationResult(Table htable, long ts)\n+        throws IOException {\n+        byte[] startRowKey = Bytes.toBytes(Long.toString(ts));\n+        byte[] stopRowKey = ByteUtil.calculateTheClosestNextRowKeyForPrefix(startRowKey);\n+        IndexToolVerificationResult verificationResult = new IndexToolVerificationResult(ts);\n+        Scan scan = new Scan();\n+        scan.withStartRow(startRowKey);\n+        scan.withStopRow(stopRowKey);\n+        ResultScanner scanner = htable.getScanner(scan);\n+        for (Result result = scanner.next(); result != null; result = scanner.next()) {\n+            boolean isFirst = true;\n+            for (Cell cell : result.rawCells()) {\n+                if (isFirst){\n+                    byte[][] rowKeyParts = ByteUtil.splitArrayBySeparator(result.getRow(),\n+                        ROW_KEY_SEPARATOR_BYTE[0]);\n+                    verificationResult.setStartRow(rowKeyParts[3]);\n+                    verificationResult.setStopRow(rowKeyParts[4]);\n+                    isFirst = false;\n+                }\n+                verificationResult.update(cell);\n+            }\n+        }\n+        return verificationResult;\n+    }\n+\n+    public void close() throws IOException {\n+        if (resultHTable != null) {\n+            resultHTable.close();\n+        }", "originalCommit": "e6b80c49fea2ee5c47253802ace5f446f745443c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcwNTEyMw==", "url": "https://github.com/apache/phoenix/pull/787#discussion_r430705123", "bodyText": "The patch attached in 5799 didn't have the close on the index table. Anyway, I added them to both (Result/Output)  the repositories. Please take a look.", "author": "swaroopak", "createdAt": "2020-05-26T21:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5MTI3Ng=="}], "type": "inlineReview"}, {"oid": "d2094d21aef12a3922bb59637695f2aca959e585", "url": "https://github.com/apache/phoenix/commit/d2094d21aef12a3922bb59637695f2aca959e585", "message": "PHOENIX-5890: Port Phoenix-5799 to master", "committedDate": "2020-05-26T20:57:19Z", "type": "commit"}, {"oid": "d2094d21aef12a3922bb59637695f2aca959e585", "url": "https://github.com/apache/phoenix/commit/d2094d21aef12a3922bb59637695f2aca959e585", "message": "PHOENIX-5890: Port Phoenix-5799 to master", "committedDate": "2020-05-26T20:57:19Z", "type": "forcePushed"}]}