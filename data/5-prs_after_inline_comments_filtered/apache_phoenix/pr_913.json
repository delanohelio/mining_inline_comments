{"pr_number": 913, "pr_title": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "pr_createdAt": "2020-10-06T23:55:13Z", "pr_url": "https://github.com/apache/phoenix/pull/913", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NDEyMQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r520944121", "bodyText": "We already have immutable table creation in other tests in this class. Do we need this test?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-10T23:40:51Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java", "diffHunk": "@@ -98,4 +99,13 @@ public void testQueryWithMultipleColumnFamiliesAndMultipleConditionsForImmutable\n             }\n         }\n     }\n+\n+    @Test\n+    public void testImmutableTableCreation() throws Exception {", "originalCommit": "976ae42c53350982b71a91b06b54c820d01e76db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MDYwOQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r533790609", "bodyText": "Correct, @ChinmaySKulkarni , doesn't look like we need this. Removed it.", "author": "gjacoby126", "createdAt": "2020-12-01T23:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NDEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NDc2Mw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r520944763", "bodyText": "I might be wrong here, but don't we already have a class like this introduced by @jpisaac for creating test tables, indices, etc. and test data too?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-10T23:42:31Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/util/TestDDLUtil.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.util;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+public class TestDDLUtil {", "originalCommit": "976ae42c53350982b71a91b06b54c820d01e76db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4OTY3Mg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r533789672", "bodyText": "Switched WALAnnotationIT to use @jpisaac 's SchemaBuilder class (and enhanced it a bit to fill in a couple feature gaps)", "author": "gjacoby126", "createdAt": "2020-12-01T23:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NDc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjE5Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r520946196", "bodyText": "nit: add a newline", "author": "ChinmaySKulkarni", "createdAt": "2020-11-10T23:46:29Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestDDLUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private TestDDLUtil ddlUtil;\n+    private boolean isImmutable;\n+    private boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+        ddlUtil = new TestDDLUtil(false);\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<String, String>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        TestTableInfo tableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        boolean createGlobalIndex = false;\n+        upsertAndDeleteHelper(tableInfo, createGlobalIndex);\n+        assertAnnotation(2, tableInfo.getPhysicalTableName(), null, tableInfo.getSchemaName(),\n+            tableInfo.getTableName(), PTableType.TABLE, minTimestamp, true);\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        TestTableInfo tableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        boolean createGlobalIndex = true;\n+        upsertAndDeleteHelper(tableInfo, createGlobalIndex);\n+        assertAnnotation(2, tableInfo.getPhysicalTableName(), null, tableInfo.getSchemaName(),\n+            tableInfo.getTableName(), PTableType.TABLE, minTimestamp, true);\n+        assertAnnotation(2, tableInfo.getPhysicalGlobalIndexName(), null, tableInfo.getSchemaName(),\n+            tableInfo.getIndexName(), PTableType.INDEX, minTimestamp, true);\n+    }\n+\n+    //Note that local secondary indexes aren't supported because they go in the same WALEdit as the\n+    // \"base\" table data they index.\n+\n+    private void upsertAndDeleteHelper(TestTableInfo tableInfo, boolean createGlobalIndex) throws SQLException {\n+        try (Connection conn = getConnection()) {\n+            ddlUtil.createBaseTable(conn, tableInfo.getSchemaName(), tableInfo.getTableName(),\n+                isMultiTenant, null, null, isImmutable);\n+            if (createGlobalIndex) {\n+                ddlUtil.createIndex(conn, tableInfo.getSchemaName(), tableInfo.getIndexName(),\n+                    tableInfo.getTableName(), \"v1\", false, false);\n+            }\n+            String upsertSql = \"UPSERT INTO \" + tableInfo.getFullTableName() + \" VALUES\" +\n+                \" ('a', 'b', 2, 'bc', 3)\";\n+            conn.createStatement().execute(upsertSql);\n+            conn.commit();\n+            //Deleting by entire PK gets executed as more like an UPSERT VALUES than an UPSERT SELECT\n+            //(i.e, it generates the Mutations and then pushes them to server, rather than\n+            // running a select query and deleting the mutations returned)\n+            String deleteSql = \"DELETE FROM \" + tableInfo.getFullTableName() + \" \" +\n+                \"WHERE t_id = 'a' AND k1 = 'b'\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertSelectClientSide() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        TestTableInfo baseTableInfo = new TestTableInfo();\n+        TestTableInfo targetTableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = getConnection()) {\n+            //upsert selecting from a different table will force processing to be client-side\n+            ddlUtil.createBaseTable(conn, baseTableInfo.getSchemaName(), baseTableInfo.getTableName(),\n+                isMultiTenant, null, null, isImmutable);\n+            conn.createStatement().execute(\"UPSERT INTO \" + baseTableInfo.getFullTableName() + \" VALUES\" +\n+                \" ('a', 'b', 2, 'bc', 3)\");\n+            conn.commit();\n+            ddlUtil.createBaseTable(conn, targetTableInfo.getSchemaName(),\n+                targetTableInfo.getTableName(), isMultiTenant, null, null, isImmutable);\n+            String sql = \"UPSERT INTO \" + targetTableInfo.getFullTableName() +\n+                \" (t_id, k1, k2, v1, v2) SELECT * FROM \" + baseTableInfo.getFullTableName();\n+            conn.createStatement().execute(sql);\n+            conn.commit();\n+        }\n+        assertAnnotation(1, baseTableInfo.getPhysicalTableName(), null,\n+            baseTableInfo.getSchemaName(), baseTableInfo.getTableName(), PTableType.TABLE,\n+            minTimestamp, true);\n+        assertAnnotation(1, targetTableInfo.getPhysicalTableName(), null,\n+            targetTableInfo.getSchemaName(), targetTableInfo.getTableName(),\n+            PTableType.TABLE, minTimestamp, true);\n+    }\n+\n+    @Test\n+    public void testUpsertSelectServerSide() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        Assume.assumeFalse(isImmutable); //only mutable tables can be processed server-side\n+        TestTableInfo targetTableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = getConnection()) {\n+            ddlUtil.createBaseTable(conn, targetTableInfo.getSchemaName(),\n+                targetTableInfo.getTableName(), isMultiTenant, null, null, isImmutable);\n+            conn.createStatement().execute(\"UPSERT INTO \" + targetTableInfo.getFullTableName() + \" VALUES\" +\n+                \" ('a', 'b', 2, 'bc', 3)\");\n+            conn.commit();\n+            conn.setAutoCommit(true); //required for server side execution\n+            clearAnnotations(TableName.valueOf(SchemaUtil.getPhysicalHBaseTableName(\n+                targetTableInfo.getSchemaName(), targetTableInfo.getTableName(),\n+                false).getString()));\n+            String sql = \"UPSERT INTO \" + targetTableInfo.getFullTableName() +\n+                \" (t_id, k1, k2, v1, v2) SELECT * FROM \" + targetTableInfo.getFullTableName();\n+            conn.createStatement().execute(sql);\n+        }\n+        assertAnnotation(1, targetTableInfo.getPhysicalTableName(), null,\n+            targetTableInfo.getSchemaName(), targetTableInfo.getTableName(),\n+            PTableType.TABLE, minTimestamp, true);\n+    }\n+\n+    @Test\n+    public void testGroupedUpsertSelect() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        //because we're inserting to a different table than we're selecting from, this should be\n+        // processed client-side\n+        TestTableInfo baseTableInfo = new TestTableInfo();\n+        TestTableInfo targetTableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = getConnection()) {\n+            ddlUtil.createBaseTable(conn, baseTableInfo.getSchemaName(),\n+                baseTableInfo.getTableName(), isMultiTenant, null, null, isImmutable);\n+            ddlUtil.createBaseTable(conn, targetTableInfo.getSchemaName(),\n+                targetTableInfo.getTableName(), isMultiTenant, null, null, isImmutable);\n+            conn.createStatement().execute(\"UPSERT INTO \" + baseTableInfo.getFullTableName() + \" VALUES\" +\n+                \" ('a', 'b', 2, 'bc', 3)\");\n+            conn.commit();\n+            String aggSql = \"UPSERT INTO \" + targetTableInfo.getFullTableName() +\n+                \" SELECT t_id, k1, k2, MIN(v1), AVG(v2) FROM \" + baseTableInfo.getFullTableName() +\n+                \" GROUP BY t_id, k1, k2\";\n+            conn.createStatement().execute(aggSql);\n+            conn.commit();\n+        }\n+        assertAnnotation(1, baseTableInfo.getPhysicalTableName(), null,\n+            baseTableInfo.getSchemaName(), baseTableInfo.getTableName(),\n+            PTableType.TABLE, minTimestamp, true);\n+        assertAnnotation(1, targetTableInfo.getPhysicalTableName(), null,\n+            targetTableInfo.getSchemaName(), targetTableInfo.getTableName(),\n+            PTableType.TABLE, minTimestamp, true);\n+    }\n+\n+    @Test\n+    public void testRangeDeleteServerSide() throws Exception {\n+        boolean isClientSide = false;\n+        testRangeDeleteHelper(isClientSide);\n+    }\n+\n+    private void testRangeDeleteHelper(boolean isClientSide) throws SQLException, IOException {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        TestTableInfo tableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = getConnection()) {\n+            ddlUtil.createBaseTable(conn, tableInfo.getSchemaName(), tableInfo.getTableName(),\n+                isMultiTenant, null, null, isImmutable);\n+            conn.createStatement().execute(\"UPSERT INTO \" + tableInfo.getFullTableName() + \" VALUES\" +\n+                \" ('a', 'b', 2, 'bc', 3)\");\n+            conn.commit();\n+            //Deleting by a partial PK to so that it executes a SELECT and then deletes the\n+            // returned mutations\n+            String sql = \"DELETE FROM \" + tableInfo.getFullTableName() + \" \" +\n+                \"WHERE t_id = 'a' AND k1 = 'b'\";\n+\n+            if (isClientSide) {\n+                sql += \" LIMIT 1\";\n+            }\n+            conn.setAutoCommit(!isClientSide);\n+            conn.createStatement().execute(sql);\n+            conn.commit();\n+        }\n+        assertAnnotation(2, tableInfo.getPhysicalTableName(), null, tableInfo.getSchemaName(),\n+            tableInfo.getTableName(), PTableType.TABLE, minTimestamp, true);\n+    }\n+\n+    @Test\n+    public void testRangeDeleteClientSide() throws Exception {\n+        boolean isClientSide = true;\n+        testRangeDeleteHelper(isClientSide);\n+    }\n+\n+    @Test\n+    public void testGlobalViewUpsert() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        TestTableInfo tableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = getConnection()) {\n+            createGlobalViewHelper(tableInfo, conn);\n+            conn.createStatement().execute(\"UPSERT INTO \" + tableInfo.getFullViewName()\n+                + \" VALUES\" + \" ('a', 'b', 2, 'bc', 3)\");\n+            conn.commit();\n+            String deleteSql = \"DELETE FROM \" + tableInfo.getFullViewName() + \" \" +\n+                \"WHERE t_id = 'a' AND k1 = 'b' and k2 = 2\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();        }\n+        assertAnnotation(2, tableInfo.getPhysicalTableName(), null, tableInfo.getSchemaName(),\n+            tableInfo.getViewName(), PTableType.VIEW, minTimestamp, true);\n+    }\n+    private void createGlobalViewHelper(TestTableInfo tableInfo, Connection conn) throws SQLException {", "originalCommit": "976ae42c53350982b71a91b06b54c820d01e76db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MDQzOQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r533790439", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-12-01T23:25:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjE5Ng=="}], "type": "inlineReview"}, {"oid": "9c1f0d169152e5eeb945dee60685209667811bd0", "url": "https://github.com/apache/phoenix/commit/9c1f0d169152e5eeb945dee60685209667811bd0", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-11-20T22:10:38Z", "type": "forcePushed"}, {"oid": "bc9b26ce09b0d39623b427227cc72e8bfe9f31d3", "url": "https://github.com/apache/phoenix/commit/bc9b26ce09b0d39623b427227cc72e8bfe9f31d3", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-08T17:16:19Z", "type": "forcePushed"}, {"oid": "233766547c1db7700356eb74f1a018b4c12c6275", "url": "https://github.com/apache/phoenix/commit/233766547c1db7700356eb74f1a018b4c12c6275", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-08T21:58:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIzNTAxMg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539235012", "bodyText": "nit: we are assigning these variables representing MutationMetadataType twice (null and scan.getAttribute()), should we assign all of them just once by removing null assignments?", "author": "virajjasani", "createdAt": "2020-12-09T11:39:39Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -644,4 +651,33 @@ public boolean next(List<Cell> resultsToReturn) throws IOException {\n     public long getMaxResultSize() {\n         return scan.getMaxResultSize();\n     }\n+\n+    private void annotateDataMutations(UngroupedAggregateRegionObserver.MutationList mutationsList,\n+                                       Scan scan) {\n+        byte[] tenantId = null;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM1MDc0OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541350748", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-12-11T22:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIzNTAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIzNjk0OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539236948", "bodyText": "nit: redundant?", "author": "virajjasani", "createdAt": "2020-12-09T11:42:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -64,6 +64,7 @@\n import org.apache.phoenix.cache.GlobalCache;\n import org.apache.phoenix.cache.TenantCache;\n import org.apache.phoenix.exception.DataExceedsCapacityException;\n+import org.apache.phoenix.execute.MutationState;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM0NzMzNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541347335", "bodyText": "removed", "author": "gjacoby126", "createdAt": "2020-12-11T22:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIzNjk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MDI0Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539380246", "bodyText": "In case of old client - new server case, changeDetectionEnabledKv will be null right?", "author": "virajjasani", "createdAt": "2020-12-09T15:02:20Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -1160,6 +1169,12 @@ private PTable getTable(RegionScanner scanner, long clientTimeStamp, long tableT\n            null : PLong.INSTANCE.getCodec().decodeLong(lastDDLTimestampKv.getValueArray(),\n                 lastDDLTimestampKv.getValueOffset(), SortOrder.getDefault());\n \n+        Cell changeDetectionEnabledKv = tableKeyValues[CHANGE_DETECTION_ENABLED_INDEX];\n+        boolean isChangeDetectionEnabled = changeDetectionEnabledKv != null", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNzQwNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539637405", "bodyText": "So long as some other client hasn't set CHANGE_DETECTION_ENABLED=true on the table via an ALTER statement.", "author": "gjacoby126", "createdAt": "2020-12-09T20:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MDI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMzQ3NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539703474", "bodyText": "If a new client modifies some table's CDE field, there won't be a problem for old clients interacting with the table right?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MDI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM0Njc5NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541346794", "bodyText": "Since it's an optional field in the protobuf and the old client won't even know to deserialize it I don't think it would cause a problem.", "author": "gjacoby126", "createdAt": "2020-12-11T22:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MDI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4NzI5OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539387298", "bodyText": "nit: we can keep both util methods private?", "author": "virajjasani", "createdAt": "2020-12-09T15:10:37Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java", "diffHunk": "@@ -682,6 +687,49 @@ private void generateMutations(final TableRef tableRef, final long mutationTimes\n         values.putAll(modifiedValues);\n     }\n \n+    public static void annotateMutationsWithMetadata(PTable table, List<Mutation> rowMutations) {\n+        //only annotate if the change detection flag is on the table and HBase supports\n+        // preWALAppend coprocs server-side\n+        if (table == null || !table.isChangeDetectionEnabled()\n+            || !HbaseCompatCapabilities.hasPreWALAppend()) {\n+            return;\n+        }\n+        //annotate each mutation with enough metadata so that anyone interested can\n+        // deterministically figure out exactly what Phoenix schema object created the mutation\n+        // Server-side we can annotate the HBase WAL with these.\n+        for (Mutation mutation : rowMutations) {\n+            annotateMutationWithMetadata(table, mutation);\n+        }\n+\n+    }\n+\n+    public static void annotateMutationWithMetadata(PTable table, Mutation mutation) {", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2MjM3Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541362377", "bodyText": "Switched to private", "author": "gjacoby126", "createdAt": "2020-12-11T22:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4NzI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwMjg5NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539402895", "bodyText": "nit: should we avoid defining constants in Compat classes?", "author": "virajjasani", "createdAt": "2020-12-09T15:28:19Z", "path": "phoenix-hbase-compat-1.3.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatIndexRegionObserver.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.compat.hbase.coprocessor;\n+\n+import org.apache.hadoop.hbase.coprocessor.BaseRegionObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class CompatIndexRegionObserver extends BaseRegionObserver {\n+    public static String PHOENIX_APPEND_METADATA_TO_WAL = \"phoenix.append.metadata.to.wal\";\n+    public static boolean DEFAULT_PHOENIX_APPEND_METADATA_TO_WAL = false;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzOTczOA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539639738", "bodyText": "These aren't used, will remove.", "author": "gjacoby126", "createdAt": "2020-12-09T20:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwMjg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwNjY3NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539406674", "bodyText": "appendToWALKey() is public only in 1.5 compact class but not in 1.3/1.4 compact classes, without which this could cause compilation issue while running against 1.3/1.4.", "author": "virajjasani", "createdAt": "2020-12-09T15:32:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.util;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+\n+import java.util.Map;\n+\n+/**\n+ * Utility functions shared between IndexRegionObserver and GlobalIndexChecker for annotating the\n+ * HBase WAL with Phoenix-level metadata about mutations.\n+ */\n+public class WALAnnotationUtil {\n+\n+    public static void appendMutationAttributesToWALKey(WALKey key,\n+                                        IndexRegionObserver.BatchMutateContext context) {\n+        if (context != null && context.getOriginalMutations().size() > 0) {\n+            Mutation firstMutation = context.getOriginalMutations().get(0);\n+            Map<String, byte[]> attrMap = firstMutation.getAttributesMap();\n+            for (MutationState.MutationMetadataType metadataType :\n+                MutationState.MutationMetadataType.values()) {\n+                String metadataTypeKey = metadataType.toString();\n+                if (attrMap.containsKey(metadataTypeKey)) {\n+                    CompatIndexRegionObserver.appendToWALKey(key, metadataTypeKey,", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2NjYzNw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539466637", "bodyText": "Moreover, 1.3/1.4 compact classes don't have it as static", "author": "virajjasani", "createdAt": "2020-12-09T16:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwNjY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0MjcyMQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539642721", "bodyText": "Oops, thanks for the catch.", "author": "gjacoby126", "createdAt": "2020-12-09T20:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwNjY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1NDA2NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539454064", "bodyText": "If possible, we can refactor this validation in a small util method and it can be used by both workflows: createTable/createIndex and addColumn/alterIndex?", "author": "virajjasani", "createdAt": "2020-12-09T16:28:00Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -2102,6 +2106,17 @@ private PTable createTableInternal(CreateTableStatement statement, byte[][] spli\n                 }\n             }\n \n+            Boolean isChangeDetectionEnabledProp =\n+                (Boolean) TableProperty.CHANGE_DETECTION_ENABLED.getValue(tableProps);\n+            if (isChangeDetectionEnabledProp != null) {\n+                if (tableType != TABLE && tableType != VIEW) {\n+                    throw new SQLExceptionInfo.Builder(\n+                        SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY)", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3NDQ5Mw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542574493", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-12-14T17:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1NDA2NA=="}], "type": "inlineReview"}, {"oid": "3d85019370ddbc6564aff6b958189ae8617a5a63", "url": "https://github.com/apache/phoenix/commit/3d85019370ddbc6564aff6b958189ae8617a5a63", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-09T21:10:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDYxNA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539560614", "bodyText": "nit: is the import necessary? Seems like the only change on this file is this import", "author": "gokceni", "createdAt": "2020-12-09T18:50:37Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java", "diffHunk": "@@ -17,6 +17,7 @@\n  */\n package org.apache.phoenix.end2end;\n \n+import org.apache.phoenix.util.TestDDLUtil;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3MzMxNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542573315", "bodyText": "Removed", "author": "gjacoby126", "createdAt": "2020-12-14T17:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NDYyMA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539564620", "bodyText": "ditto", "author": "gokceni", "createdAt": "2020-12-09T18:56:43Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java", "diffHunk": "@@ -72,6 +72,7 @@\n import org.apache.phoenix.util.PropertiesUtil;\n import org.apache.phoenix.util.QueryUtil;\n import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestDDLUtil;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3MzQyNA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542573424", "bodyText": "Removed", "author": "gjacoby126", "createdAt": "2020-12-14T17:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NDYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MTg2MA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539571860", "bodyText": "TODO seems to be dropped but not implemented?", "author": "gokceni", "createdAt": "2020-12-09T19:07:48Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/GroupedAggregateRegionObserver.java", "diffHunk": "@@ -400,7 +400,6 @@ protected boolean isRegionObserverFor(Scan scan) {\n      * Used for an aggregate query in which the key order does not necessarily match the group by\n      * key order. In this case, we must collect all distinct groups within a region into a map,\n      * aggregating as we go.\n-     * @param limit TODO", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM0NTU5Mg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541345592", "bodyText": "Removed the params from the Javadoc as they were Javadoc errors.", "author": "gjacoby126", "createdAt": "2020-12-11T22:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MzAzMA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539573030", "bodyText": "nit: lonely import", "author": "gokceni", "createdAt": "2020-12-09T19:09:43Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionObserver.java", "diffHunk": "@@ -73,6 +73,7 @@\n import org.apache.hadoop.io.WritableUtils;\n import org.apache.phoenix.coprocessor.generated.PTableProtos;\n import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MjU5MQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539672591", "bodyText": "It would be nice to refactor this perhaps to a new method? Lines 596 to 602 is same as 616 to 622", "author": "gokceni", "createdAt": "2020-12-09T21:47:25Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -609,6 +613,9 @@ public boolean next(List<Cell> resultsToReturn) throws IOException {\n                     } while (hasMore && (EnvironmentEdgeManager.currentTimeMillis() - startTime) < pageSizeInMs);\n \n                     if (!mutations.isEmpty()) {\n+                        if (isDelete || isUpsert) {\n+                            annotateDataMutations(mutations, scan);\n+                        }", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM0OTk5Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541349997", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-12-11T22:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MjU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MzI4Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539673286", "bodyText": "Would this be populated for both view indexes and regular indexes and local indexes?", "author": "gokceni", "createdAt": "2020-12-09T21:48:35Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/generated/ServerCachingProtos.java", "diffHunk": "@@ -2192,6 +2192,21 @@ public Builder setColumnNameBytes(\n      */\n     com.google.protobuf.ByteString\n         getParentTableTypeBytes();\n+\n+    // optional string logicalIndexName = 25;\n+    /**\n+     * <code>optional string logicalIndexName = 25;</code>\n+     */\n+    boolean hasLogicalIndexName();\n+    /**\n+     * <code>optional string logicalIndexName = 25;</code>\n+     */\n+    java.lang.String getLogicalIndexName();", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3OTQyNg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542579426", "bodyText": "@gjacoby126 thanks for addressing my comments. There is just this question remaining.", "author": "gokceni", "createdAt": "2020-12-14T17:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MzI4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MTc0OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542791748", "bodyText": "@gokceni  Correct, should be populated for all indexes.", "author": "gjacoby126", "createdAt": "2020-12-14T21:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MzI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3Mzg0MA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539673840", "bodyText": "perhaps move this to line 684? (out of if else?)", "author": "gokceni", "createdAt": "2020-12-09T21:49:31Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java", "diffHunk": "@@ -674,6 +678,7 @@ private void generateMutations(final TableRef tableRef, final long mutationTimes\n                         mutation.setAttribute(PhoenixIndexBuilder.ATOMIC_OP_ATTRIB, onDupKeyBytes);\n                     }\n                 }\n+                annotateMutationsWithMetadata(table, rowMutations);", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNDk1NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539704955", "bodyText": "+1, there is no difference between the if and else as far as annotation goes right?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3Mzg0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3Mjk0Mg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542572942", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-12-14T17:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3Mzg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3NTkzNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539675935", "bodyText": "Actually why not use the this method in the Ungroupped..Scanner in that for loop that goes over mutations? Also mutation  durability was not checked there I think", "author": "gokceni", "createdAt": "2020-12-09T21:52:54Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java", "diffHunk": "@@ -682,6 +687,49 @@ private void generateMutations(final TableRef tableRef, final long mutationTimes\n         values.putAll(modifiedValues);\n     }\n \n+    private void annotateMutationsWithMetadata(PTable table, List<Mutation> rowMutations) {\n+        //only annotate if the change detection flag is on the table and HBase supports\n+        // preWALAppend coprocs server-side\n+        if (table == null || !table.isChangeDetectionEnabled()\n+            || !HbaseCompatCapabilities.hasPreWALAppend()) {\n+            return;\n+        }\n+        //annotate each mutation with enough metadata so that anyone interested can\n+        // deterministically figure out exactly what Phoenix schema object created the mutation\n+        // Server-side we can annotate the HBase WAL with these.\n+        for (Mutation mutation : rowMutations) {\n+            annotateMutationWithMetadata(table, mutation);\n+        }\n+\n+    }\n+\n+    public static void annotateMutationWithMetadata(PTable table, Mutation mutation) {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2MjcyMg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541362722", "bodyText": "Consolidated in WALAnnotationUtil as @ChinmaySKulkarni suggested.", "author": "gjacoby126", "createdAt": "2020-12-11T22:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3NTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0NDA3NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539644075", "bodyText": "nit: unused import", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:00:48Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java", "diffHunk": "@@ -17,6 +17,7 @@\n  */\n package org.apache.phoenix.end2end;\n \n+import org.apache.phoenix.util.TestDDLUtil;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0OTUxMg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539649512", "bodyText": "nit: static import assertFalse() like you've done for assertNotNull()", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:09:49Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0OTY1Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539649657", "bodyText": "nit: static import assertEquals()", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:10:05Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0OTgyNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539649825", "bodyText": "nit: static import assertTrue()", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:10:21Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0OTk5Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539649997", "bodyText": "nit: static import fail()", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:10:37Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MTM4OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539651388", "bodyText": "Isn't there a config that toggles client-side vs. server-side deletes? Just curious, will setting this config to client-side cause some of these tests to fail?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:12:58Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +\n+                    \"index at create time!\");\n+            } catch (SQLException se) {\n+                TestUtil.assertSqlExceptionCode(\n+                    SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY, se);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = true;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+        assertAnnotation(0, builder.getPhysicalTableIndexName(false),\n+            null, builder.getTableOptions().getSchemaName(),\n+            SchemaUtil.getTableNameFromFullName(builder.getEntityTableIndexName()),\n+            PTableType.INDEX,\n+            ddlTimestamp);\n+    }\n+\n+    //Note that local secondary indexes aren't supported because they go in the same WALEdit as the\n+    // \"base\" table data they index.\n+\n+    private long upsertAndDeleteHelper(SchemaBuilder builder, boolean createGlobalIndex) throws Exception {\n+        try (Connection conn = getConnection()) {\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+\n+            if (createGlobalIndex) {\n+                builder.withTableOptions(tableOptions).withTableIndexDefaults().build();\n+            } else {\n+                builder.withTableOptions(tableOptions).build();\n+            }\n+\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', 'c')\";\n+            conn.createStatement().execute(upsertSql);\n+            conn.commit();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change Detection Enabled is false!\",\n+                table.isChangeDetectionEnabled());\n+            //Deleting by entire PK gets executed as more like an UPSERT VALUES than an UPSERT SELECT", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4OTc5Mg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539689792", "bodyText": "Even if the delete is issued as a select from the client and delete mutations are issued for those, we would still get the same mutations as if the client had directly issued DELETE mutations right? And then WAL annotations wouldn't change either in both scenarios right? If so, why are we preferring one over the other in the test?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MTM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczOTIxOQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539739219", "bodyText": "The annotation happens in different code paths depending on whether the delete gets executed client side (where it happens in MutationState) or server side (where it happens in the coproc), so I have tests for both to make sure that both work properly.", "author": "gjacoby126", "createdAt": "2020-12-09T23:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MTM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MzI3MA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539653270", "bodyText": "Do we want to do some upserts and call getEntriesForTable() again at this point, just to ensure that entries exist now that change detection is enabled?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:16:05Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczOTU5MQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539739591", "bodyText": "We could, but isn't that covered by all the other tests?", "author": "gjacoby126", "createdAt": "2020-12-10T00:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MzI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1NTI1NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539655255", "bodyText": "So the idea is that the WAL entry corresponding to an upsert/delete on an entity (table or view) will contain an annotation which has the lastDDLTimestamp of the entity and this can be used against a potential schema registry to find what was the schema of the entity at that point in time when the mutation was issued on it?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:19:13Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +\n+                    \"index at create time!\");\n+            } catch (SQLException se) {\n+                TestUtil.assertSqlExceptionCode(\n+                    SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY, se);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = true;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+        assertAnnotation(0, builder.getPhysicalTableIndexName(false),\n+            null, builder.getTableOptions().getSchemaName(),\n+            SchemaUtil.getTableNameFromFullName(builder.getEntityTableIndexName()),\n+            PTableType.INDEX,\n+            ddlTimestamp);\n+    }\n+\n+    //Note that local secondary indexes aren't supported because they go in the same WALEdit as the\n+    // \"base\" table data they index.\n+\n+    private long upsertAndDeleteHelper(SchemaBuilder builder, boolean createGlobalIndex) throws Exception {\n+        try (Connection conn = getConnection()) {\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+\n+            if (createGlobalIndex) {\n+                builder.withTableOptions(tableOptions).withTableIndexDefaults().build();\n+            } else {\n+                builder.withTableOptions(tableOptions).build();\n+            }\n+\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', 'c')\";\n+            conn.createStatement().execute(upsertSql);\n+            conn.commit();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change Detection Enabled is false!\",\n+                table.isChangeDetectionEnabled());\n+            //Deleting by entire PK gets executed as more like an UPSERT VALUES than an UPSERT SELECT\n+            //(i.e, it generates the Mutations and then pushes them to server, rather than\n+            // running a select query and deleting the mutations returned)\n+            String deleteSql = \"DELETE FROM \" + builder.getEntityTableName() + \" \" +\n+                \"WHERE OID = 'a' AND KP = 'b'\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();\n+            return table.getLastDDLTimestamp();\n+        }\n+    }\n+\n+    private SchemaBuilder.TableOptions getTableOptions() {\n+        SchemaBuilder.TableOptions tableOptions =\n+            SchemaBuilder.TableOptions.withDefaults();\n+        tableOptions.setImmutable(isImmutable);\n+        tableOptions.setMultiTenant(isMultiTenant);\n+        tableOptions.setChangeDetectionEnabled(true);\n+        return tableOptions;\n+    }\n+\n+    @Test\n+    public void testUpsertSelectClientSide() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = getConnection()) {\n+            SchemaBuilder baseBuilder = new SchemaBuilder(getUrl());\n+            SchemaBuilder targetBuilder = new SchemaBuilder(getUrl());\n+            //upsert selecting from a different table will force processing to be client-side\n+            baseBuilder.withTableOptions(getTableOptions()).build();\n+            conn.createStatement().execute(\"UPSERT INTO \" + baseBuilder.getEntityTableName() + \" \" +\n+                \"VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\");\n+            conn.commit();\n+            targetBuilder.withTableOptions(getTableOptions()).build();\n+            String sql = \"UPSERT INTO \" + targetBuilder.getEntityTableName() +\n+                \" (OID, KP, COL1, COL2, COL3) SELECT * FROM \" + baseBuilder.getEntityTableName();\n+            conn.createStatement().execute(sql);\n+            conn.commit();\n+            int expectedAnnotations = 1;\n+            verifyBaseAndTargetAnnotations(conn, baseBuilder, targetBuilder, expectedAnnotations);\n+        }\n+    }\n+\n+    private void verifyBaseAndTargetAnnotations(Connection conn, SchemaBuilder baseBuilder,\n+                                                SchemaBuilder targetBuilder,\n+                                                int expectedAnnotations) throws SQLException, IOException {\n+        PTable baseTable = PhoenixRuntime.getTableNoCache(conn,\n+            baseBuilder.getEntityTableName());\n+        assertAnnotation(expectedAnnotations, baseBuilder.getPhysicalTableName(false), null,\n+            baseBuilder.getTableOptions().getSchemaName(),\n+            baseBuilder.getDataOptions().getTableName(),\n+            PTableType.TABLE,\n+            baseTable.getLastDDLTimestamp());\n+        PTable targetTable = PhoenixRuntime.getTableNoCache(conn,\n+            targetBuilder.getEntityTableName());\n+        assertAnnotation(expectedAnnotations, targetBuilder.getPhysicalTableName(false), null,\n+            targetBuilder.getTableOptions().getSchemaName(), targetBuilder.getDataOptions().getTableName(),\n+            PTableType.TABLE, targetTable.getLastDDLTimestamp());\n+    }\n+\n+    @Test\n+    public void testUpsertSelectServerSide() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        Assume.assumeFalse(isImmutable); //only mutable tables can be processed server-side\n+        SchemaBuilder targetBuilder = new SchemaBuilder(getUrl());\n+        try (Connection conn = getConnection()) {\n+            targetBuilder.withTableOptions(getTableOptions()).build();\n+            conn.createStatement().execute(\"UPSERT INTO \" + targetBuilder.getEntityTableName() + \" \" +\n+                \"VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\");\n+            conn.commit();\n+            conn.setAutoCommit(true); //required for server side execution\n+            clearAnnotations(TableName.valueOf(targetBuilder.getPhysicalTableName(false)));\n+            String sql = \"UPSERT INTO \" + targetBuilder.getEntityTableName() +\n+                \" (OID, KP, COL1, COL2, COL3) SELECT * FROM \" + targetBuilder.getEntityTableName();\n+            conn.createStatement().execute(sql);\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, targetBuilder.getEntityTableName());\n+            assertAnnotation(1, targetBuilder.getPhysicalTableName(false), null,\n+                targetBuilder.getTableOptions().getSchemaName(),\n+                targetBuilder.getDataOptions().getTableName(),\n+                PTableType.TABLE, table.getLastDDLTimestamp());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testGroupedUpsertSelect() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        //because we're inserting to a different table than we're selecting from, this should be\n+        // processed client-side\n+        SchemaBuilder baseBuilder = new SchemaBuilder(getUrl());\n+        SchemaBuilder targetBuilder = new SchemaBuilder(getUrl());\n+        try (Connection conn = getConnection()) {\n+            baseBuilder.withTableOptions(getTableOptions()).build();\n+            targetBuilder.withTableOptions(getTableOptions()).build();\n+            conn.createStatement().execute(\"UPSERT INTO \" + baseBuilder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\");\n+            conn.commit();\n+            String aggSql = \"UPSERT INTO \" + targetBuilder.getEntityTableName() +\n+                \" SELECT OID, KP, MAX(COL1), MIN(COL2), MAX(COL3) FROM \" + baseBuilder.getEntityTableName() +\n+                \" GROUP BY OID, KP\";\n+            conn.createStatement().execute(aggSql);\n+            conn.commit();\n+            int expectedAnnotations = 1;\n+            verifyBaseAndTargetAnnotations(conn, baseBuilder, targetBuilder, expectedAnnotations);\n+        }\n+    }\n+\n+    @Test\n+    public void testRangeDeleteServerSide() throws Exception {\n+        boolean isClientSide = false;\n+        testRangeDeleteHelper(isClientSide);\n+    }\n+\n+    private void testRangeDeleteHelper(boolean isClientSide) throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        builder.withTableOptions(getTableOptions()).build();\n+        try (Connection conn = getConnection()) {\n+            conn.createStatement().execute(\"UPSERT INTO \" + builder.getEntityTableName() +\n+                \" VALUES ('a', 'b', '2', 'bc', '3')\");\n+            conn.commit();\n+            //Deleting by a partial PK to so that it executes a SELECT and then deletes the\n+            // returned mutations\n+            String sql = \"DELETE FROM \" + builder.getEntityTableName() + \" \" +\n+                \"WHERE OID = 'a' AND KP = 'b'\";\n+\n+            if (isClientSide) {\n+                sql += \" LIMIT 1\";\n+            }\n+            conn.setAutoCommit(!isClientSide);\n+            conn.createStatement().execute(sql);\n+            conn.commit();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            assertAnnotation(2, table.getPhysicalName().getString(), null,\n+                table.getSchemaName().getString(),\n+                table.getTableName().getString(), PTableType.TABLE, table.getLastDDLTimestamp());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testRangeDeleteClientSide() throws Exception {\n+        boolean isClientSide = true;\n+        testRangeDeleteHelper(isClientSide);\n+    }\n+\n+    @Test\n+    public void testGlobalViewUpsert() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        try (Connection conn = getConnection()) {\n+            createGlobalViewHelper(builder, conn);\n+            conn.createStatement().execute(\"UPSERT INTO \" + builder.getEntityGlobalViewName()\n+                + \" VALUES\" + \" ('a', '\" + PhoenixTestBuilder.DDLDefaults.DEFAULT_KP +\n+                \"', '2', 'bc', '3', 'c')\");\n+            conn.commit();\n+            String deleteSql = \"DELETE FROM \" + builder.getEntityGlobalViewName() + \" \" +\n+                \"WHERE OID = 'a' AND KP = '\" + PhoenixTestBuilder.DDLDefaults.DEFAULT_KP + \"' \" +\n+                \"and ID = 'c'\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();\n+            PTable view = PhoenixRuntime.getTableNoCache(conn, builder.getEntityGlobalViewName());\n+            assertAnnotation(2, view.getPhysicalName().getString(), null,\n+                view.getSchemaName().getString(),\n+                view.getTableName().getString(), PTableType.VIEW, view.getLastDDLTimestamp());\n+        }\n+\n+    }\n+\n+    private void createGlobalViewHelper(SchemaBuilder builder, Connection conn) throws Exception {\n+        builder.withTableOptions(getTableOptions()).\n+            withGlobalViewOptions(getGlobalViewOptions(builder)).build();\n+        PTable view = PhoenixRuntime.getTableNoCache(conn, builder.getEntityGlobalViewName());\n+        Assert.assertTrue(\"View does not have change detection enabled!\",\n+            view.isChangeDetectionEnabled());\n+    }\n+\n+    private SchemaBuilder.GlobalViewOptions getGlobalViewOptions(SchemaBuilder builder) {\n+        SchemaBuilder.GlobalViewOptions options = SchemaBuilder.GlobalViewOptions.withDefaults();\n+        options.setChangeDetectionEnabled(true);\n+        return options;\n+    }\n+\n+    @Test\n+    public void testTenantViewUpsert() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        Assume.assumeTrue(isMultiTenant);\n+        boolean createIndex = false;\n+        tenantViewHelper(createIndex);\n+    }\n+\n+    private void tenantViewHelper(boolean createIndex) throws Exception {\n+        //create a base table, global view, and child tenant view, then insert / delete into the\n+        // child tenant view. Make sure that the annotations use the tenant view name\n+        String tenant = generateUniqueName();\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        try (Connection conn = getConnection()) {\n+            createGlobalViewHelper(builder, conn);\n+        }\n+        try (Connection conn = getTenantConnection(tenant)) {\n+            SchemaBuilder.DataOptions dataOptions = builder.getDataOptions();\n+            dataOptions.setTenantId(tenant);\n+            if (createIndex) {\n+                builder.withTenantViewOptions(getTenantViewOptions(builder)).\n+                    withDataOptions(dataOptions).withTenantViewIndexDefaults().build();\n+            } else {\n+                builder.withTenantViewOptions(getTenantViewOptions(builder)).\n+                    withDataOptions(dataOptions).build();\n+            }\n+            builder.withTenantViewOptions(getTenantViewOptions(builder)).\n+                withDataOptions(dataOptions).withTenantViewIndexDefaults().build();\n+            conn.createStatement().execute(\"UPSERT INTO \" + builder.getEntityTenantViewName()\n+                + \" VALUES\" + \" ('\" + PhoenixTestBuilder.DDLDefaults.DEFAULT_KP + \"', '2', 'bc', \" +\n+                \"'3', 'c', \" + \"'col4', 'col5', 'col6', 'd')\");\n+            conn.commit();\n+            String deleteSql = \"DELETE FROM \" + builder.getEntityTenantViewName() + \" \" +\n+                \"WHERE KP = '\"+ PhoenixTestBuilder.DDLDefaults.DEFAULT_KP +\n+                \"' and COL1 = '2' AND ID = 'c' AND ZID = 'd'\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();\n+            PTable view = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTenantViewName());\n+            assertAnnotation(2, view.getPhysicalName().getString(), tenant,\n+                view.getSchemaName().getString(),\n+                view.getTableName().getString(), PTableType.VIEW, view.getLastDDLTimestamp());\n+            if (createIndex) {\n+                assertAnnotation(0,\n+                    MetaDataUtil.getViewIndexPhysicalName(builder.getEntityTableName()),\n+                    tenant, view.getSchemaName().getString(),\n+                    SchemaUtil.getTableNameFromFullName(builder.getEntityTenantViewIndexName()),\n+                    PTableType.INDEX,\n+                    view.getLastDDLTimestamp());\n+            }\n+        }\n+\n+    }\n+\n+    private SchemaBuilder.TenantViewOptions getTenantViewOptions(SchemaBuilder builder) {\n+        SchemaBuilder.TenantViewOptions options = SchemaBuilder.TenantViewOptions.withDefaults();\n+        options.setChangeDetectionEnabled(true);\n+        return options;\n+    }\n+\n+    @Test\n+    public void testTenantViewUpsertWithIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        Assume.assumeTrue(isMultiTenant);\n+        tenantViewHelper(true);\n+    }\n+\n+    private List<Map<String, byte[]>> getEntriesForTable(TableName tableName) throws IOException {\n+        AnnotatedWALObserver c = getTestCoprocessor(tableName);\n+        List<Map<String, byte[]>> entries = c.getWalAnnotationsByTable(tableName);\n+        return entries != null ? entries : new ArrayList<Map<String, byte[]>>();\n+    }\n+\n+    private AnnotatedWALObserver getTestCoprocessor(TableName tableName) throws IOException {\n+        HRegionInfo info = getUtility().getHBaseCluster().getRegions(tableName).get(0).getRegionInfo();\n+        WAL wal = getUtility().getHBaseCluster().getRegionServer(0).getWAL(info);\n+        WALCoprocessorHost host = wal.getCoprocessorHost();\n+        return (AnnotatedWALObserver) host.findCoprocessor(AnnotatedWALObserver.class.getName());\n+    }\n+\n+    private void clearAnnotations(TableName tableName) throws IOException {\n+        AnnotatedWALObserver observer = getTestCoprocessor(tableName);\n+        observer.clearAnnotations();\n+    }\n+\n+    private void assertAnnotation(int numOccurrences, String physicalTableName, String tenant,\n+                                  String schemaName,\n+                                  String logicalTableName,\n+                                  PTableType tableType, long ddlTimestamp) throws IOException {", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczOTc3MQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539739771", "bodyText": "Correct.", "author": "gjacoby126", "createdAt": "2020-12-10T00:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1NTI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0MDA2Mw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539740063", "bodyText": "The part that does that will be contributed to phoenix-connectors, and @bharathv is currently developing it.", "author": "gjacoby126", "createdAt": "2020-12-10T00:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1NTI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MTAxMw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539661013", "bodyText": "Can you please add a comment here for clarity to mention that the upsert/delete statements won't affect this timestamp and it reflects the time of creation of the table in this case (since there is no other ALTER statement)?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:28:17Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +\n+                    \"index at create time!\");\n+            } catch (SQLException se) {\n+                TestUtil.assertSqlExceptionCode(\n+                    SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY, se);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = true;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+        assertAnnotation(0, builder.getPhysicalTableIndexName(false),\n+            null, builder.getTableOptions().getSchemaName(),\n+            SchemaUtil.getTableNameFromFullName(builder.getEntityTableIndexName()),\n+            PTableType.INDEX,\n+            ddlTimestamp);\n+    }\n+\n+    //Note that local secondary indexes aren't supported because they go in the same WALEdit as the\n+    // \"base\" table data they index.\n+\n+    private long upsertAndDeleteHelper(SchemaBuilder builder, boolean createGlobalIndex) throws Exception {\n+        try (Connection conn = getConnection()) {\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+\n+            if (createGlobalIndex) {\n+                builder.withTableOptions(tableOptions).withTableIndexDefaults().build();\n+            } else {\n+                builder.withTableOptions(tableOptions).build();\n+            }\n+\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', 'c')\";\n+            conn.createStatement().execute(upsertSql);\n+            conn.commit();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change Detection Enabled is false!\",\n+                table.isChangeDetectionEnabled());\n+            //Deleting by entire PK gets executed as more like an UPSERT VALUES than an UPSERT SELECT\n+            //(i.e, it generates the Mutations and then pushes them to server, rather than\n+            // running a select query and deleting the mutations returned)\n+            String deleteSql = \"DELETE FROM \" + builder.getEntityTableName() + \" \" +\n+                \"WHERE OID = 'a' AND KP = 'b'\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();\n+            return table.getLastDDLTimestamp();", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2Mjg0NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539662844", "bodyText": "When we expect 0 numOccurences, the logicalname and ddlTimestamp are not used right? Can we pass in null or modify the assertAnnotation() to make this clear?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:31:20Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +\n+                    \"index at create time!\");\n+            } catch (SQLException se) {\n+                TestUtil.assertSqlExceptionCode(\n+                    SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY, se);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = true;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+        assertAnnotation(0, builder.getPhysicalTableIndexName(false),", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2NDQwNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539664405", "bodyText": "When you say \"aren't supported\", do you mean there should be no virtual table name corresponding to the local index in the WAL annotations for the base table? Can we add a test for this?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:33:52Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +\n+                    \"index at create time!\");\n+            } catch (SQLException se) {\n+                TestUtil.assertSqlExceptionCode(\n+                    SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY, se);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = true;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+        assertAnnotation(0, builder.getPhysicalTableIndexName(false),\n+            null, builder.getTableOptions().getSchemaName(),\n+            SchemaUtil.getTableNameFromFullName(builder.getEntityTableIndexName()),\n+            PTableType.INDEX,\n+            ddlTimestamp);\n+    }\n+\n+    //Note that local secondary indexes aren't supported because they go in the same WALEdit as the", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0MjMyNg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539742326", "bodyText": "Actually the opposite -- when a local index is present I believe the WALEdits will have a mix of Cells from both the base table and the local index, because local indexes are stored within the actual table, just in a separate CF. So the later phases of change detection (that read the WALs) will have to filter out Cells that have the local index CF.", "author": "gjacoby126", "createdAt": "2020-12-10T00:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2NDQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzMzM4OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r540433388", "bodyText": "Ok, got it.", "author": "ChinmaySKulkarni", "createdAt": "2020-12-10T19:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2NDQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5MTM0NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539691345", "bodyText": "Is this a connection leak?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:20:35Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java", "diffHunk": "@@ -247,9 +195,10 @@ public void testMultiTenantViewLocalIndex() throws Exception {\n \t\tString indexName = \"IND_\" + generateUniqueName();\n         String fullTableName = SchemaUtil.getTableName(SCHEMA1, tableName);\n         String fullViewName = SchemaUtil.getTableName(SCHEMA2, generateUniqueName());\n-        \n-        createBaseTable(SCHEMA1, tableName, true, null, null, true);\n-        Connection conn = DriverManager.getConnection(getUrl());\n+\n+        Connection conn = getConnection();", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5MTQ0Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539691447", "bodyText": "Is this a connection leak?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:20:46Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java", "diffHunk": "@@ -278,10 +227,8 @@ public void testMultiTenantViewLocalIndex() throws Exception {\n         stmt.setInt(5, 400);\n         stmt.execute();\n         conn.commit();\n-        \n-        Properties props  = PropertiesUtil.deepCopy(TestUtil.TEST_PROPERTIES);\n-        props.setProperty(\"TenantId\", \"10\");\n-        Connection conn1 = DriverManager.getConnection(getUrl(), props);\n+\n+        Connection conn1 = getTenantConnection(\"10\");", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNTk5OQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539705999", "bodyText": "I think we need to do this check everywhere. Also, can this be moved to a relevant Util class since we'd want to potentially call this method in all places where annotation is required?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:47:30Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java", "diffHunk": "@@ -682,6 +687,49 @@ private void generateMutations(final TableRef tableRef, final long mutationTimes\n         values.putAll(modifiedValues);\n     }\n \n+    private void annotateMutationsWithMetadata(PTable table, List<Mutation> rowMutations) {\n+        //only annotate if the change detection flag is on the table and HBase supports\n+        // preWALAppend coprocs server-side\n+        if (table == null || !table.isChangeDetectionEnabled()\n+            || !HbaseCompatCapabilities.hasPreWALAppend()) {\n+            return;\n+        }\n+        //annotate each mutation with enough metadata so that anyone interested can\n+        // deterministically figure out exactly what Phoenix schema object created the mutation\n+        // Server-side we can annotate the HBase WAL with these.\n+        for (Mutation mutation : rowMutations) {\n+            annotateMutationWithMetadata(table, mutation);\n+        }\n+\n+    }\n+\n+    public static void annotateMutationWithMetadata(PTable table, Mutation mutation) {\n+        if (mutation.getDurability() == Durability.SKIP_WAL) {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNjU5MQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539706591", "bodyText": "Maybe WALAnnotationUtil?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNTk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNjg3Mg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539706872", "bodyText": "I thought we weren't going to annotate indexes.", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:49:27Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -1034,6 +1066,15 @@ private void removeBatchMutateContext(ObserverContext<RegionCoprocessorEnvironme\n       this.batchMutateContext.remove();\n   }\n \n+    @Override\n+    public void preWALAppend(ObserverContext<RegionCoprocessorEnvironment> c, WALKey key,\n+                             WALEdit edit) {\n+        if (HbaseCompatCapabilities.hasPreWALAppend() && shouldWALAppend) {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0Mjk3Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539742976", "bodyText": "Despite the name, IndexRegionObserver is actually the coproc that lives on base tables, not indexes. (GlobalIndexChecker is the index coproc)", "author": "gjacoby126", "createdAt": "2020-12-10T00:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNjg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNzI5OQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539707299", "bodyText": "A lot of these imports seem to be unused", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:50:20Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java", "diffHunk": "@@ -50,11 +53,19 @@\n import org.apache.hadoop.hbase.filter.FilterList;\n import org.apache.hadoop.hbase.filter.PageFilter;\n import org.apache.hadoop.hbase.io.ImmutableBytesWritable;\n+import org.apache.hadoop.hbase.regionserver.MiniBatchOperationInProgress;\n import org.apache.hadoop.hbase.regionserver.Region;\n import org.apache.hadoop.hbase.regionserver.RegionScanner;\n import org.apache.hadoop.hbase.regionserver.ScannerContext;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatGlobalIndexChecker;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n import org.apache.phoenix.coprocessor.BaseScannerRegionObserver;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2Mzk1Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541363956", "bodyText": "Fixed -- lots were remnants from when we annotated indexes", "author": "gjacoby126", "createdAt": "2020-12-11T22:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNzI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNzg3Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539707876", "bodyText": "Is this mainly for view indexes? For local indexes we aren't doing any annotation and for global indexes, the logical name is the name of PTable. Can you please clarify and/or add a comment about this?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:51:35Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/index/IndexMaintainer.java", "diffHunk": "@@ -1257,7 +1261,11 @@ public ImmutableBytesPtr getEmptyKeyValueFamily() {\n         // If if there are no covered columns, we know it's our default name\n         return emptyKeyValueCFPtr;\n     }\n-    \n+\n+    public String getLogicalIndexName() {\n+        return logicalIndexName;", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2NDY4NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541364685", "bodyText": "Correct. Will add a comment.", "author": "gjacoby126", "createdAt": "2020-12-11T22:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNzg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxODIwMQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539718201", "bodyText": "@gjacoby126 Here is my understanding overall, please correct me if I'm wrong. There are 2 basic paths:\n\n(Client-side delete and upsert-values) Client issues Puts/Deletes directly: This is handled in MutationState. annotateMutationsWithMetadata()\n(Server-side delete and upsert-selects) Client issues scans, the server intercepts this and issues Put/Delete mutations based on the results read: This is what this method handles right? My understanding is we set the scan attributes in UpsertCompiler and DeleteCompiler and this is intercepted in UngroupedAggregateRegionScanner  where we read the scan attribute and set it on the mutations.", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:12:54Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/ScanUtil.java", "diffHunk": "@@ -1239,4 +1239,21 @@ public static boolean isDummy(List<Cell> result) {\n         Cell cell = result.get(0);\n         return CellUtil.matchingColumn(cell, EMPTY_BYTE_ARRAY, EMPTY_BYTE_ARRAY);\n     }\n+\n+    public static void setWALAnnotationAttributes(PTable table, Scan scan) {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNDA3Mw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539724073", "bodyText": "Can we add comments based on this in the compiler and/or this method. Also a similar comment in MutationState would be helpful.", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxODIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM4MjYyMA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541382620", "bodyText": "Added comments to the Utility methods in ScanUtil and WALAnnotationUtil to avoid duplication", "author": "gjacoby126", "createdAt": "2020-12-11T22:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxODIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNDI0OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539724248", "bodyText": "We should check WAL durability here as well right?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:25:59Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -644,4 +651,33 @@ public boolean next(List<Cell> resultsToReturn) throws IOException {\n     public long getMaxResultSize() {\n         return scan.getMaxResultSize();\n     }\n+\n+    private void annotateDataMutations(UngroupedAggregateRegionObserver.MutationList mutationsList,\n+                                       Scan scan) {\n+        byte[] tenantId = null;\n+        byte[] logicalTableName = null;\n+        byte[] schemaName = null;\n+        byte[] tableType = null;\n+        byte[] ddlTimestamp = null;\n+        tenantId =\n+            scan.getAttribute(MutationState.MutationMetadataType.TENANT_ID.toString());\n+        schemaName =\n+            scan.getAttribute(MutationState.MutationMetadataType.SCHEMA_NAME.toString());\n+        logicalTableName =\n+            scan.getAttribute(MutationState.MutationMetadataType.LOGICAL_TABLE_NAME.toString());\n+        tableType =\n+            scan.getAttribute(MutationState.MutationMetadataType.TABLE_TYPE.toString());\n+        ddlTimestamp = scan.getAttribute(MutationState.MutationMetadataType.TIMESTAMP.toString());\n+\n+        for (Mutation m : mutationsList) {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNDkxNw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539724917", "bodyText": "Since this is specific to indexing, can we rename the class to reflect that?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:27:27Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.util;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+\n+import java.util.Map;\n+\n+/**\n+ * Utility functions shared between IndexRegionObserver and GlobalIndexChecker for annotating the\n+ * HBase WAL with Phoenix-level metadata about mutations.\n+ */\n+public class WALAnnotationUtil {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2NzA5Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541367097", "bodyText": "It's not specific to indexing.", "author": "gjacoby126", "createdAt": "2020-12-11T22:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNDkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNTQxOA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539725418", "bodyText": "nit: Fix indentation.\nAlso, what is this change for?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:28:39Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/coprocessor/TaskMetaDataEndpointTest.java", "diffHunk": "@@ -139,7 +140,12 @@ public RegionServerServices getRegionServerServices() {\n             public ConcurrentMap<String, Object> getSharedData() {\n                 return null;\n             }\n-        };\n+\n+                    @Override", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3MjAzMg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542572032", "bodyText": "A previous version of this patch had PHOENIX-6155 but not its addendum that fixed compilation on certain HBase versions. The current version has the addendum and so this file shouldn't be altered in this patch anymore.", "author": "gjacoby126", "createdAt": "2020-12-14T17:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNTQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNTc0MA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539725740", "bodyText": "Can these variables be private?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:29:24Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java", "diffHunk": "@@ -644,6 +646,9 @@ public void upsertRows(int startRowIndex, int numRows) throws Exception {\n         String entityTableName;\n         String entityGlobalViewName;\n         String entityTenantViewName;\n+        String entityTableIndexName;", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNjI2Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539726266", "bodyText": "nit: Use a static constant representing CHANGE_DETECTION_ENABLED instead", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:30:20Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java", "diffHunk": "@@ -1230,6 +1285,12 @@ private String buildCreateGlobalViewStmt(String fullGlobalViewName, String fullT\n                     .append((globalViewOptions.tableProps.isEmpty() ?\n                             \"\" :\n                             globalViewOptions.tableProps));\n+            if (globalViewOptions.isChangeDetectionEnabled()) {\n+                if (!globalViewOptions.tableProps.isEmpty()) {\n+                    statement.append(\", \");\n+                }\n+                statement.append(\"CHANGE_DETECTION_ENABLED=true\");", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyOTY4Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539729686", "bodyText": "Super nit: multi-line comments throughout the pr have no space for the first line and 1 space for subsequent ones. Maybe keep it the same for all lines, unless this is some convention I'm unaware of, in which case ignore :D", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:38:11Z", "path": "phoenix-hbase-compat-1.5.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatGlobalIndexChecker.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.compat.hbase.coprocessor;\n+\n+import org.apache.hadoop.hbase.coprocessor.BaseRegionObserver;\n+\n+public class CompatGlobalIndexChecker extends BaseRegionObserver {\n+    //HBase 1.5+ has preWALAppend already declared in BaseRegionObserver, so this class is only", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM4MzEwNw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541383107", "bodyText": "This particular file no longer exists, but I fixed some of these as I found them. The reason why is just that I usually don't type a space when I start a one-line comment, and when I find I need to make it multi-line the IDE fixes the spacing on subsequent lines but not the first one. :-)", "author": "gjacoby126", "createdAt": "2020-12-11T22:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyOTY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2NDM2NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541364364", "bodyText": "We don't need CompatGlobalIndexChecker now that we don't annotate indexes so I removed it", "author": "gjacoby126", "createdAt": "2020-12-11T22:27:46Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java", "diffHunk": "@@ -93,10 +106,11 @@\n  * the verified version that is masked by the unverified version(s).\n  *\n  */\n-public class GlobalIndexChecker extends BaseRegionObserver {\n+public class GlobalIndexChecker extends CompatGlobalIndexChecker {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "url": "https://github.com/apache/phoenix/commit/8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-11T23:05:39Z", "type": "forcePushed"}, {"oid": "3c25fc8e03d0c3c831243e7f76e932d803446592", "url": "https://github.com/apache/phoenix/commit/3c25fc8e03d0c3c831243e7f76e932d803446592", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-14T17:16:42Z", "type": "commit"}, {"oid": "3c25fc8e03d0c3c831243e7f76e932d803446592", "url": "https://github.com/apache/phoenix/commit/3c25fc8e03d0c3c831243e7f76e932d803446592", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-14T17:16:42Z", "type": "forcePushed"}]}