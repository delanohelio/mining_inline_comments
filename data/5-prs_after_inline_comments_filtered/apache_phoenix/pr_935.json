{"pr_number": 935, "pr_title": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "pr_createdAt": "2020-10-22T16:55:14Z", "pr_url": "https://github.com/apache/phoenix/pull/935", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNDc1Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512334756", "bodyText": "nit: Don't need commit() since they are DDL statements.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:46:45Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java", "diffHunk": "@@ -387,6 +388,31 @@ public void testViewUsesTableLocalIndex() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCreateViewTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        final String schemaName = \"S_\" + generateUniqueName();\n+        final String tableName = \"T_\" + generateUniqueName();\n+        final String viewName = \"V_\" + generateUniqueName();\n+        final String dataTableFullName = SchemaUtil.getTableName(schemaName, tableName);\n+        final String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+        String tableDDL =\n+            \"CREATE TABLE \" + dataTableFullName + \" (\\n\" + \"ID1 VARCHAR(15) NOT NULL,\\n\"\n+                + \"ID2 VARCHAR(15) NOT NULL,\\n\" + \"CREATED_DATE DATE,\\n\"\n+                + \"CREATION_TIME BIGINT,\\n\" + \"LAST_USED DATE,\\n\"\n+                + \"CONSTRAINT PK PRIMARY KEY (ID1, ID2)) \";\n+        String viewDDL = \"CREATE VIEW \" + viewFullName  + \" AS SELECT * \" +\n+            \"FROM \" + dataTableFullName;\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            conn.commit();", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MDIxMw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r513080213", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-10-27T22:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNDc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNTQ3NA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512335474", "bodyText": "Once we converge on the expected behavior for column inheritance from a parent to its child views, we should add some tests for those scenarios too.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:49:23Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1217,50 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNTYwMQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512335601", "bodyText": "Can we add a test which confirms that ALTER SET  doesn't modify the timestamp?", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:49:53Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java", "diffHunk": "@@ -1326,7 +1327,40 @@ public void testAddingColumnsToTablesAndViews() throws Exception {\n             assertSequenceNumber(schemaName, viewName, PTable.INITIAL_SEQ_NUM + 1);\n         }\n     }\n-\t\n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" ENTITY_ID integer NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (ENTITY_ID, COL1, COL2)\"\n+            + \" ) \" + generateDDLOptions(\"\");\n+\n+        String columnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MDI5NQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r513080295", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-10-27T22:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNTYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNTkzNQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512335935", "bodyText": "Do we need some tests to confirm tenant-view behavior? And then subsequently make this helper method work for resolving those?", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:50:54Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java", "diffHunk": "@@ -910,6 +911,48 @@ public void testTableDescriptorPriority() throws SQLException, IOException {\n         }\n     }\n \n+    @Test\n+    public void testCreateTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        final String schemaName = generateUniqueName();\n+        final String tableName = generateUniqueName();\n+        final String dataTableFullName = SchemaUtil.getTableName(schemaName, tableName);\n+        String ddl =\n+            \"CREATE TABLE \" + dataTableFullName + \" (\\n\" + \"ID1 VARCHAR(15) NOT NULL,\\n\"\n+                + \"ID2 VARCHAR(15) NOT NULL,\\n\" + \"CREATED_DATE DATE,\\n\"\n+                + \"CREATION_TIME BIGINT,\\n\" + \"LAST_USED DATE,\\n\"\n+                + \"CONSTRAINT PK PRIMARY KEY (ID1, ID2)) \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(ddl);\n+            verifyLastDDLTimestamp(schemaName, tableName, dataTableFullName, startTS, conn);\n+        }\n+    }\n+\n+    public static long verifyLastDDLTimestamp(String schemaName, String tableName,\n+                                              String dataTableFullName, long startTS, Connection conn) throws SQLException {\n+        long endTS = EnvironmentEdgeManager.currentTimeMillis();\n+        //First try the JDBC metadata API\n+        PhoenixDatabaseMetaData metadata = (PhoenixDatabaseMetaData) conn.getMetaData();\n+        ResultSet rs = metadata.getTables(\"\", schemaName, tableName, null);\n+        assertTrue(\"No metadata returned\", rs.next());\n+        Long ddlTimestamp = rs.getLong(PhoenixDatabaseMetaData.LAST_DDL_TIMESTAMP);\n+        assertNotNull(\"JDBC DDL timestamp is null!\", ddlTimestamp);\n+        assertTrue(\"JDBC DDL Timestamp not in the right range!\",\n+            ddlTimestamp >= startTS && ddlTimestamp <= endTS);\n+        //Now try the PTable API\n+        PTable table = PhoenixRuntime.getTableNoCache(conn, dataTableFullName);", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MDM3MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r513080370", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-10-27T22:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODM1Mg==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512338352", "bodyText": "Can we add a simple unit test for this inside MetaDataUtilTest?", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:59:12Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java", "diffHunk": "@@ -107,6 +107,18 @@\n             HColumnDescriptor.KEEP_DELETED_CELLS,\n             HColumnDescriptor.REPLICATION_SCOPE);\n \n+    public static Mutation getLastDDLTimestampUpdate(byte[] tableHeaderRowKey,", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MDQwMQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r513080401", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-10-27T22:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODU4MQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512338581", "bodyText": "This will get triggered even for ALTER TABLE/VIEW SET <property>. I thought we didn't want to update the ddl timestamp in those cases.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:59:52Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java", "diffHunk": "@@ -399,6 +399,10 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table, byte[][] rowK\n                                 rowKeyMetaData[TABLE_NAME_INDEX])));\n             }\n         }\n+        //We're changing the application-facing schema by adding a column, so update the DDL\n+        // timestamp\n+        additionalTableMetadataMutations.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg0MzQ5Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512843496", "bodyText": "SET property goes through the column add logic? Thanks, didn't know that, will change the logic to not update the timestamp if no columns are being added, then add a test as you recommend above.", "author": "gjacoby126", "createdAt": "2020-10-27T16:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5NTg3Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512895873", "bodyText": "Yes, thanks.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-27T17:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MDQ3Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r513080477", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-10-27T22:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0Nzg2Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512347866", "bodyText": "This seems risky since we are relying on the fact that the PTable returned from the server has all the necessary attributes set as the PTable we create on the client-side. There are some that we set explicitly inside MetaDataClient which depend on the parent so I'm not sure we still have those set as expected.\nInstead, to be safe we can maybe getDDLTimestamp() from this returned PTable and set that in the builder. Better yet, we could just send the DDL timestamp in the server response rather than the entire PTable. We could then use the setter for this attribute when creating the PTable from its builder.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-27T00:33:17Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -3048,7 +3048,13 @@ public boolean isViewReferenced() {\n              * the counter as NULL_COUNTER for extra safety.\n              */\n             EncodedCQCounter cqCounterToBe = tableType == PTableType.VIEW ? NULL_COUNTER : cqCounter;\n-            PTable table = new PTableImpl.Builder()\n+            PTable table;\n+            //better to use the table sent back from the server so we get an accurate DDL\n+            // timestamp, which is server-generated.\n+            if (result.getTable() != null ) {", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg0NzM5OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512847398", "bodyText": "It seems strange that System.Catalog is the source of truth, we've just been there on the server, and yet the client copy controls. Will look closer at MetadataClient as you suggest to understand why.\nAre we missing tests? Because assuming the client-side copy should control, my replacing it with the server-side copy should have broken tests somewhere, and it doesn't appear to.", "author": "gjacoby126", "createdAt": "2020-10-27T16:34:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0Nzg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwNjY3Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512906673", "bodyText": "I'm not sure that would be covered by a test since we'd only see it if the test were to actually look at the cached PTable rather than say doing a PhoenixRuntime.getTableNoCache() right? Since we're changing what is cached, we should add some tests around this now to make sure the PTable has all expected fields set.\nI see some tests that should cover this code path inside AlterTableWithViewsIT (like testAlterPropertiesOfParentTable()) and also some in ViewTTLIT, but I'm not sure to what extent they would capture this.\nI'm mostly worried about things like setting certain properties based on the parent PTable or overriding null properties with the default values, etc. (see this and this). That's where I'm not sure that the PTable returned from the server will be identical to the one that's created by the client today, since I don't see any code in MetaDataEndpointImpl that does this.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-27T17:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0Nzg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0ODU0Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512348546", "bodyText": "It might be better to just send the DDL timestamp from the server instead of the entire PTable. This is because on the client, we set certain properties which may be derived from the parent, etc. so we probably can't blindly cache the PTable that is returned from the server anyhow.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-27T00:36:01Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -2100,6 +2115,13 @@ public void createTable(RpcController controller, CreateTableRequest request,\n                     builder.setViewIndexIdType(PLong.INSTANCE.getSqlType());\n                 }\n                 builder.setMutationTime(currentTimeStamp);\n+                //send the newly built table back because we generated the DDL timestamp server\n+                // side and the client doesn't have it.\n+                PTable newTable = buildTable(tableKey, cacheKey, region,\n+                    clientTimeStamp, clientVersion);\n+                if (newTable != null) {", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM1MDE3Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512350173", "bodyText": "Similar kind of concern here?", "author": "ChinmaySKulkarni", "createdAt": "2020-10-27T00:42:16Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -4416,10 +4423,15 @@ else if (columnToDrop.isViewReferenced()) {\n                     // client-side cache as it would be too painful. Just let it pull it over from\n                     // the server when needed.\n                     if (tableColumnsToDrop.size() > 0) {\n-                        if (removedIndexTableOrColumn)\n+                        if (removedIndexTableOrColumn) {\n                             connection.removeTable(tenantId, tableName, table.getParentName() == null ? null : table.getParentName().getString(), table.getTimeStamp());\n-                        else\n-                            connection.removeColumn(tenantId, SchemaUtil.getTableName(schemaName, tableName) , tableColumnsToDrop, result.getMutationTime(), seqNum, TransactionUtil.getResolvedTime(connection, result));\n+                        }\n+                        else {\n+                            //replace the cache of this table with the updated one we got back\n+                            // from the server\n+                            connection.addTable(result.getTable(),", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5252eda018d17a0ae0e1e95d61de1745db954283", "url": "https://github.com/apache/phoenix/commit/5252eda018d17a0ae0e1e95d61de1745db954283", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-05T17:55:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MDMwNQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520170305", "bodyText": "In splittable-SYSTEM.CATALOG world, we avoid making synchronous changes to child views when the parent changes, so if a column is added to the parent, we wouldn't add that to each child view's metadata. Instead on resolving the view, we'd combine the parent columns and inherit them that way. This was done for scalability in case child views span many SYSCAT regions. I'm wondering if we can use similar inheritance logic for lastDDLTs of child views.\nThis becomes more complicated for diverged views. In that case, any columns added to a parent view/physical table are inherited by its child views only if they haven't diverged. In those cases, the LastDDLTs for diverged views ideally shouldn't even be modified if a column is added to its parent.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T22:48:02Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java", "diffHunk": "@@ -399,6 +401,19 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table, byte[][] rowK\n                                 rowKeyMetaData[TABLE_NAME_INDEX])));\n             }\n         }\n+        if (isAddingColumns) {\n+            //We're changing the application-facing schema by adding a column, so update the DDL\n+            // timestamp\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            additionalTableMetadataMutations.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                clientTimeStamp, serverTimestamp));\n+            for (PTable viewTable : childViews) {", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MTE5NQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520171195", "bodyText": "Another complication is, pre-4.15 clients do not have this logic to just store view-specific columns. They don't have EXCLUDED_COLUMN linking rows either. The parent column combining logic in those cases is different too.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T22:49:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MDMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MDc3Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521480773", "bodyText": "@ChinmaySKulkarni - I see how inheritance logic could work for PTables, but how would we make that work for the JDBC metadata API? (see PhoenixDatabaseMetaData) I'm asserting throughout my tests that PTables and the metadata API give the same answers, but the metadata API is, I believe, just querying the table or view header row in System.Catalog.\n(Technically, the JDBC metadata API is the \"public\" one and the PTables API is the \"private\" one, though in all the external Phoenix-based applications I work with for my day job, I've switched to using PTables because the JDBC metadata API is just too inefficient since it never caches results.)\nAlso just want to note that in a follow-up JIRA to this, we're going to need to (optionally) call to an external schema registry when we create a table/view or add/remove a column from a table/view, and that will need to be synchronous, because the schema needs to be in the schema registry before DML using that schema starts being processed by the replication pipeline.", "author": "gjacoby126", "createdAt": "2020-11-11T16:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MDMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MTY4NQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521481685", "bodyText": "Will make sure to exempt diverged columns, thanks for pointing that out.", "author": "gjacoby126", "createdAt": "2020-11-11T16:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MDMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUyOTIzMw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521529233", "bodyText": "@ChinmaySKulkarni - is there an authoritative way to tell if a view is diverged? I don't see a PTable property. Is ViewUtil.isDivergedView(PTable) usable? Would I have to use ViewUtil.isDivergingView(PColumn, PTable) instead? Thanks!", "author": "gjacoby126", "createdAt": "2020-11-11T17:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MDMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MTI3OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520171278", "bodyText": "Same concerns here with parent column inheritance and diverged views, etc.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T22:49:55Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java", "diffHunk": "@@ -268,7 +272,20 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table,\n             }\n \n         }\n-        tableMetaData.addAll(additionalTableMetaData);\n+        if (isDroppingColumns) {\n+            //We're changing the application-facing schema by dropping a column, so update the DDL\n+            // timestamp to current _server_ timestamp\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                clientTimeStamp, serverTimestamp));\n+            for (PTable viewTable : childViews) {", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MzM2Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520173367", "bodyText": "Why are we changing this?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T22:54:33Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataProtocol.java", "diffHunk": "@@ -94,7 +94,7 @@\n     public static final long MIN_SYSTEM_TABLE_TIMESTAMP_4_13_0 = MIN_SYSTEM_TABLE_TIMESTAMP_4_11_0;\n     public static final long MIN_SYSTEM_TABLE_TIMESTAMP_4_14_0 = MIN_TABLE_TIMESTAMP + 28;\n     public static final long MIN_SYSTEM_TABLE_TIMESTAMP_4_15_0 = MIN_TABLE_TIMESTAMP + 29;\n-    public static final long MIN_SYSTEM_TABLE_TIMESTAMP_4_16_0 = MIN_TABLE_TIMESTAMP + 31;\n+    public static final long MIN_SYSTEM_TABLE_TIMESTAMP_4_16_0 = MIN_TABLE_TIMESTAMP + 33;", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNjMxMA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525336310", "bodyText": "As I mentioned in a different comment, each syscat column's timestamp needs to be unique", "author": "gjacoby126", "createdAt": "2020-11-17T17:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MzM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3NzU1OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520177558", "bodyText": "I'm a little unclear on these changes. Shouldn't all these 4.16-specific columns be added at the 4.16 ts rather than 4.16 ts - something?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T23:04:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/query/ConnectionQueryServicesImpl.java", "diffHunk": "@@ -3707,15 +3709,20 @@ protected PhoenixConnection upgradeSystemCatalogIfRequired(PhoenixConnection met\n             metaConnection = addColumnsIfNotExists(\n                 metaConnection,\n                 PhoenixDatabaseMetaData.SYSTEM_CATALOG,\n-                MIN_SYSTEM_TABLE_TIMESTAMP_4_16_0 - 1,\n+                MIN_SYSTEM_TABLE_TIMESTAMP_4_16_0 - 2,", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyNjMyMw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521026323", "bodyText": "@ChinmaySKulkarni  The upgrade code requires that each new column has a distinct timestamp (for some reason)", "author": "gjacoby126", "createdAt": "2020-11-11T02:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3NzU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3OTU0Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520179546", "bodyText": "nit: Instead of using u and v, use PTableType.. API", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T23:09:57Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java", "diffHunk": "@@ -2586,4 +2588,18 @@ public static boolean isNoUpgradeSet(Properties props) {\n     public static void doNotUpgradeOnFirstConnection(Properties props) {\n         props.setProperty(DO_NOT_UPGRADE, String.valueOf(true));\n     }\n+\n+    //When upgrading to Phoenix 4.16, make each existing table's DDL timestamp equal to its last\n+    // updated row timestamp.\n+    public static void bootstrapLastDDLTimestamp(PhoenixConnection metaConnection) throws SQLException  {\n+        String pkCols = TENANT_ID + \", \" + TABLE_SCHEM +\n+            \", \" + TABLE_NAME + \", \" + COLUMN_NAME + \", \" + COLUMN_FAMILY;\n+        String upsertSql =\n+            \"UPSERT INTO \" + SYSTEM_CATALOG_NAME + \" (\" + pkCols + \", \" +\n+        LAST_DDL_TIMESTAMP + \")\" + \" \" +\n+            \"SELECT \" + pkCols + \", PHOENIX_ROW_TIMESTAMP() FROM \" + SYSTEM_CATALOG_NAME + \" \" +\n+                \"WHERE \" + TABLE_TYPE + \" \" + \" in \" + \"('u','v')\";", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4ODg2OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520188868", "bodyText": "Also, can we add a comment about why we don't do this for system tables and indexes? Might be better to invert the condition and say WHERE TABLE_TYPE NOT IN ('s', i')", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T23:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3OTU0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAzMDUwOA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521030508", "bodyText": "Because I affirmatively only intend for it to affect tables and views, not \"not system tables or indexes\". I'll add a comment in the code though, good point.\nThe reason, btw, is that only tables and views are relevant schema for external systems trying to interpret Phoenix data. (This is a pre-req change for Phoenix change data capture, to allow Phoenix DML to be emitted as schema'ed messages into a message bus.) Indexes are an internal Phoenix optimization, and system tables are internal Phoenix config; no other system or external schema registry should care about them.\nIf some other kind of Phoenix schema object is created later, I'd want whoever creates it to opt-in to having a ddl timestamp, not need to remember to opt-out.", "author": "gjacoby126", "createdAt": "2020-11-11T02:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3OTU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3OTg5OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520179899", "bodyText": "Can we add a log before and after this UPSERT SELECT to help track the upgrade progress?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T23:10:51Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java", "diffHunk": "@@ -2586,4 +2588,18 @@ public static boolean isNoUpgradeSet(Properties props) {\n     public static void doNotUpgradeOnFirstConnection(Properties props) {\n         props.setProperty(DO_NOT_UPGRADE, String.valueOf(true));\n     }\n+\n+    //When upgrading to Phoenix 4.16, make each existing table's DDL timestamp equal to its last\n+    // updated row timestamp.\n+    public static void bootstrapLastDDLTimestamp(PhoenixConnection metaConnection) throws SQLException  {\n+        String pkCols = TENANT_ID + \", \" + TABLE_SCHEM +", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4ODEyNw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520188127", "bodyText": "Do we want to restrict this to just tables and views i.e. 'u' and 'v' table_types? The upgrade code only adds a ts for existing tables and views, but not indexes and SYSTEM tables, but here we do it for all types. There will be inconsistency in that case between an index created before the 4.16 metadata upgrade (no ts) vs an index created after the 4.16 metadata upgrade (has ts), not to mention fresh clusters will have a ts for all entities.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T23:32:47Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -2037,7 +2049,10 @@ public void createTable(RpcController controller, CreateTableRequest request,\n                     // view's property in case they are different from the parent\n                     ViewUtil.addTagsToPutsForViewAlteredProperties(tableMetadata, parentTable);\n                 }\n-\n+                //set the last DDL timestamp to the current server time since we're creating the\n+                // table\n+                tableMetadata.add(MetaDataUtil.getLastDDLTimestampUpdate(tableKey,\n+                    clientTimeStamp, EnvironmentEdgeManager.currentTimeMillis()));", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAzMTI0MQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521031241", "bodyText": "Thanks, didn't realize those other types also went through that code path. Will add the restriction.", "author": "gjacoby126", "createdAt": "2020-11-11T02:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4ODEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4NjkyMg==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522486922", "bodyText": "Do we need to add childViews to validateAndAddMetadata method ? Maybe I am reading it wrong but I don't see childViews getting used either in AddColumnMutator#validateAndAddMetadata or DropColumnMutator#validateAndAddMetadata.", "author": "shahrs87", "createdAt": "2020-11-12T22:56:18Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java", "diffHunk": "@@ -293,7 +293,9 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table, byte[][] rowK\n                                                          List<ImmutableBytesPtr> invalidateList,\n                                                          List<Region.RowLock> locks,\n                                                          long clientTimeStamp,\n-                                                         long clientVersion) {\n+                                                         long clientVersion,\n+                                                         boolean isAddingColumns,\n+                                                         List<PTable> childViews) {", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU0MTg5Mg==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522541892", "bodyText": "Good catch, it was necessary in a prior draft but the code that used it was just removed. I'll remove the parameter.", "author": "gjacoby126", "createdAt": "2020-11-13T01:07:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4NjkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4OTk2NA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522489964", "bodyText": "tableMetaData.addAll(additionalTableMetaData);\nThe above line won't be executed if isDroppingColumns is false. Earlier it was getting executed even if we are dropping columns.", "author": "shahrs87", "createdAt": "2020-11-12T23:01:32Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java", "diffHunk": "@@ -268,7 +272,19 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table,\n             }\n \n         }\n-        tableMetaData.addAll(additionalTableMetaData);\n+        if (isDroppingColumns) {\n+            //We're changing the application-facing schema by dropping a column, so update the DDL\n+            // timestamp to current _server_ timestamp\n+            if (MetaDataUtil.isTableQueryable(table.getType())) {\n+                long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+                additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                    clientTimeStamp, serverTimestamp));\n+            }\n+            //we don't need to update the DDL timestamp for any child views we may have, because\n+            // when we look up a PTable for any of those child views, we'll take the max timestamp\n+            // of the view and all its ancestors\n+            tableMetaData.addAll(additionalTableMetaData);", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MDY0MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522490640", "bodyText": "The changes here looks exactly same as the changes in AddColumnMutator. Can we create a helper method which accepts table and additionalTableMetaData as argument ?", "author": "shahrs87", "createdAt": "2020-11-12T23:03:10Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java", "diffHunk": "@@ -268,7 +272,19 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table,\n             }\n \n         }\n-        tableMetaData.addAll(additionalTableMetaData);\n+        if (isDroppingColumns) {", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU0OTEyMg==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522549122", "bodyText": "It's not really general-purpose enough to put in a standalone Util method in MetaDataUtil, and since it's only 3 lines repeated in 2 places I figured the minor violation of DRY (Don't Repeat Yourself) wasn't worth working around, since all alternatives I could think of seemed a little ugly.\nFor example, I could put a static utility method in one of the mutators, but then one depends on the other which couples classes that shouldn't be...", "author": "gjacoby126", "createdAt": "2020-11-13T01:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MDY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNjI1MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522506250", "bodyText": "Unable to understand the need of this field addingColumns in builder ? If we need this, then why not a corresponding field in DropColumn request.", "author": "shahrs87", "createdAt": "2020-11-12T23:36:28Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/query/ConnectionQueryServicesImpl.java", "diffHunk": "@@ -2285,6 +2286,7 @@ public MetaDataResponse call(MetaDataService instance) throws IOException {\n                     builder.setClientVersion(VersionUtil.encodeVersion(PHOENIX_MAJOR_VERSION, PHOENIX_MINOR_VERSION, PHOENIX_PATCH_NUMBER));\n                     if (parentTable!=null)\n                         builder.setParentTable(PTableImpl.toProto(parentTable));\n+                    builder.setAddingColumns(addingColumns);", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU0OTk0OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522549948", "bodyText": "In a drop column request, the answer is always \"true\" so there's no need to set the variable; it's hard-coded when the MetadataEndpointImpl creates the DropColumnMutator. (AddColumnRequests can either be to add columns or alter table properties, and we need to distinguish to know whether to update the DDL timestamp; a drop is always a drop.)\nI'll remove the (useless) check on the variable in DropColumnMutator to make that more clear.", "author": "gjacoby126", "createdAt": "2020-11-13T01:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNjI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA2NzcwNQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523067705", "bodyText": "Thank you for educating me. :)", "author": "shahrs87", "createdAt": "2020-11-13T16:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNjI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwODE2NQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522508165", "bodyText": "Here we are adding just 1 filed to builder method. Can we please undo the formatting changes which is making the diff look more than actual changes.", "author": "shahrs87", "createdAt": "2020-11-12T23:42:01Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -3063,60 +3063,62 @@ public boolean isViewReferenced() {\n              */\n             EncodedCQCounter cqCounterToBe = tableType == PTableType.VIEW ? NULL_COUNTER : cqCounter;\n             PTable table = new PTableImpl.Builder()\n-                    .setType(tableType)", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MTY1Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522551653", "bodyText": "Sorry for the inconvenience, but the formatting changes fix the spacing from being incorrect to correct. GitHub does have a \"Hide whitespace changes\" in the setting icon near the top of the page, btw, to make it easier to ignore.", "author": "gjacoby126", "createdAt": "2020-11-13T01:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwODE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3NTc5Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523075797", "bodyText": "I know this is a very nit pick.. but for split lines the spacing rule is 8 spaces. For conditional/loop statements body I agree it is 4 spaces.", "author": "shahrs87", "createdAt": "2020-11-13T16:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwODE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwOTQwOQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522509409", "bodyText": "I am not that much aware of the change here but isn't system table directly queryable ?", "author": "shahrs87", "createdAt": "2020-11-12T23:43:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java", "diffHunk": "@@ -107,6 +107,29 @@\n             HColumnDescriptor.KEEP_DELETED_CELLS,\n             HColumnDescriptor.REPLICATION_SCOPE);\n \n+    public static Put getLastDDLTimestampUpdate(byte[] tableHeaderRowKey,\n+                                                     long clientTimestamp,\n+                                                     long lastDDLTimestamp) {\n+        //use client timestamp as the timestamp of the Cell, to match the other Cells that might\n+        // be created by this DDL. But the actual value will be a _server_ timestamp\n+        Put p = new Put(tableHeaderRowKey, clientTimestamp);\n+        byte[] lastDDLTimestampBytes = PLong.INSTANCE.toBytes(lastDDLTimestamp);\n+        p.addColumn(PhoenixDatabaseMetaData.TABLE_FAMILY_BYTES,\n+            PhoenixDatabaseMetaData.LAST_DDL_TIMESTAMP_BYTES, lastDDLTimestampBytes);\n+        return p;\n+    }\n+\n+    /**\n+     * Checks if a table is meant to be queried directly (and hence is relevant to external\n+     * systems tracking Phoenix schema)\n+     * @param tableType\n+     * @return True if a table or view, false otherwise (such as for an index, system table, or\n+     * subquery)\n+     */\n+    public static boolean isTableQueryable(PTableType tableType) {", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MDcwNw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522550707", "bodyText": "I struggled to find a good name here. \"Queryable\" was the best I could think of, by which I meant that tables and views are meant to be queried, but while you can directly query an index and a system table, end users aren't really supposed to. The internal schema of an index or a system table shouldn't be relevant to an external schema registry trying to track the schema of Phoenix tables.\nHappy to hear other naming suggestions.", "author": "gjacoby126", "createdAt": "2020-11-13T01:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwOTQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3NzU1Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523077557", "bodyText": "I am ok with the name just wanted to learn more context. thank you !", "author": "shahrs87", "createdAt": "2020-11-13T16:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwOTQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1OTk0Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525459943", "bodyText": "I also think this name is a little confusing. Maybe something like isTableTypeDirectlyQueried() is more in line with what we mean", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T19:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwOTQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNTc0Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523035743", "bodyText": "is this comment carried forward from previous test and no longer relevant here ?", "author": "shahrs87", "createdAt": "2020-11-13T15:47:25Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java", "diffHunk": "@@ -1326,7 +1328,69 @@ public void testAddingColumnsToTablesAndViews() throws Exception {\n             assertSequenceNumber(schemaName, viewName, PTable.INITIAL_SEQ_NUM + 1);\n         }\n     }\n-\t\n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" ENTITY_ID integer NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (ENTITY_ID, COL1, COL2)\"\n+            + \" ) \" + generateDDLOptions(\"\");\n+\n+        String columnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testSetPropertyDoesntUpdateDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" ENTITY_ID integer NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (ENTITY_ID, COL1, COL2)\"\n+            + \" ) \" + generateDDLOptions(\"\");\n+\n+        String setPropertyDDL = \"ALTER TABLE \" + dataTableFullName +\n+            \" SET UPDATE_CACHE_FREQUENCY=300000 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNDk1NA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525324954", "bodyText": "@gjacoby126  looks like this comment was missed ?", "author": "shahrs87", "createdAt": "2020-11-17T16:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNzg2MQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523037861", "bodyText": "just 1 minor nit. DriverManager has method getConnection without Properties argument. We can use that in all newly added test cases since we don't override any properties here. If it is too much change please feel free to ignore also.", "author": "shahrs87", "createdAt": "2020-11-13T15:50:44Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java", "diffHunk": "@@ -1326,7 +1328,69 @@ public void testAddingColumnsToTablesAndViews() throws Exception {\n             assertSequenceNumber(schemaName, viewName, PTable.INITIAL_SEQ_NUM + 1);\n         }\n     }\n-\t\n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" ENTITY_ID integer NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (ENTITY_ID, COL1, COL2)\"\n+            + \" ) \" + generateDDLOptions(\"\");\n+\n+        String columnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNDgwOQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525324809", "bodyText": "@gjacoby126  looks like this comment was missed ?", "author": "shahrs87", "createdAt": "2020-11-17T16:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNzg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0MjUwOA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523042508", "bodyText": "Acc to comment, shouldn't the argument for startTime be \"viewDDLTimestamp + 1\"  since we are assuming that timestamp should change.", "author": "shahrs87", "createdAt": "2020-11-13T15:57:54Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NDE0MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523044140", "bodyText": "I understand it is strictly not required but should we sleep for 1 millisecond just to make sure that 1 ms passed between divergeDDL and viewColumnAddDDL execution and the same argument applies for other ddl statements that we execute subsequently in this test.", "author": "shahrs87", "createdAt": "2020-11-13T16:00:25Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnAddDDL);\n+            //verify DDL timestamp changed because we added a column to the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NjM5Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523046397", "bodyText": "Does it make sense to add a check that after dropping column from view it didn't change the ddlTimestamp of the base table ?", "author": "shahrs87", "createdAt": "2020-11-13T16:04:14Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEwNTE3Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523105176", "bodyText": "There's already a check in a different test that dropping a view's column doesn't change the base table's timestamp, but no harm in also having a check here since it's an inherited column.", "author": "gjacoby126", "createdAt": "2020-11-13T17:23:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NjM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0ODA3MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523048070", "bodyText": "Any reason why we want this test to run only if multiTenant is true ? I am not that much aware of this testsuite.\nIf we want to ensure isMultiTenant is true then can we change the test name to testLastDDLTimestampWith_Tenant_ChildViews to be more specific.", "author": "shahrs87", "createdAt": "2020-11-13T16:06:51Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnAddDDL);\n+            //verify DDL timestamp changed because we added a column to the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnDropDDL);\n+            //verify DDL timestamp changed because we dropped a column from the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            //verify DDL timestamp DID NOT change because we added a column from the base table\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+            conn.createStatement().execute(tableColumnDropDDL);\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampWithChildViews() throws Exception {\n+        Assume.assumeTrue(isMultiTenant);", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNTgxNg==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525325816", "bodyText": "@gjacoby126  This is not a comment for changing anything. This is just for my knowledge.", "author": "shahrs87", "createdAt": "2020-11-17T17:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0ODA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNDIyMA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525334220", "bodyText": "@shahrs87 - the test deals in part with tenant-owned views, which don't make sense on a non-MT table.", "author": "gjacoby126", "createdAt": "2020-11-17T17:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0ODA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0OTkwNw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523049907", "bodyText": "Should we move this helper method to CreateTableIT since we are doing almost same thing in CreateTableIT#verifyLastDDLTimestamp and additional timestamp bounds verification.", "author": "shahrs87", "createdAt": "2020-11-13T16:09:49Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnAddDDL);\n+            //verify DDL timestamp changed because we added a column to the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnDropDDL);\n+            //verify DDL timestamp changed because we dropped a column from the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            //verify DDL timestamp DID NOT change because we added a column from the base table\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+            conn.createStatement().execute(tableColumnDropDDL);\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampWithChildViews() throws Exception {\n+        Assume.assumeTrue(isMultiTenant);\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String globalViewName = \"V_\" + generateUniqueName();\n+        String tenantViewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String globalViewFullName = SchemaUtil.getTableName(schemaName, globalViewName);\n+        String tenantViewFullName = SchemaUtil.getTableName(schemaName, tenantViewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        //create a table with a child global view, who then has a child tenant view\n+        String globalViewDDL =\n+            \"CREATE VIEW \" + globalViewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String tenantViewDDL =\n+            \"CREATE VIEW \" + tenantViewFullName + \" AS SELECT * FROM \" + globalViewFullName;\n+\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        long tableDDLTimestamp, globalViewDDLTimestamp;\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(globalViewDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+        }\n+        props.setProperty(TENANT_ID_ATTRIB, TENANT1);\n+        try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+            tenantConn.createStatement().execute(tenantViewDDL);\n+        }\n+        // First, check that adding a child view didn't change the timestamps\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            long newTableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+\n+            long newGlobalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+            assertEquals(globalViewDDLTimestamp, newGlobalViewDDLTimestamp);\n+        }\n+        Thread.sleep(1);\n+        //now add / drop a column from the tenant view and make sure it doesn't change its\n+        // ancestors' timestamps\n+        String tenantViewColumnAddDDL = \"ALTER VIEW \" + tenantViewFullName + \" ADD COL3 varchar\" +\n+            \"(50) \" + \"NULL \";\n+        String tenantViewColumnDropDDL = \"ALTER VIEW \" + tenantViewFullName + \" DROP COLUMN COL3 \";\n+\n+        try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+            tenantConn.createStatement().execute(tenantViewColumnAddDDL);\n+            long newTableDDLTimestamp = getLastDDLTimestamp(tenantConn, dataTableFullName);\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+\n+            long afterTenantColumnAddViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                globalViewFullName);\n+            assertEquals(globalViewDDLTimestamp, afterTenantColumnAddViewDDLTimestamp);\n+\n+            tenantConn.createStatement().execute(tenantViewColumnDropDDL);\n+            //update the tenant view timestamp (we'll need it later)\n+            long afterTenantColumnDropTableDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                dataTableFullName);\n+            assertEquals(tableDDLTimestamp, afterTenantColumnDropTableDDLTimestamp);\n+\n+            long afterTenantColumnDropViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                globalViewFullName);\n+            assertEquals(globalViewDDLTimestamp, afterTenantColumnDropViewDDLTimestamp);\n+        }\n+        Thread.sleep(1);\n+        //now add / drop a column from the base table and make sure it changes the timestamps for\n+        // both the global view (its child) and the tenant view (its grandchild)\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) \" + \"NULL \";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName);\n+                assertEquals(tableDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn,\n+                globalViewFullName);\n+            assertEquals(tableDDLTimestamp, globalViewDDLTimestamp);\n+\n+            conn.createStatement().execute(tableColumnDropDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName);\n+                assertEquals(tableDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn,\n+                globalViewFullName);\n+            assertEquals(tableDDLTimestamp, globalViewDDLTimestamp);\n+        }\n+\n+        //now add / drop a column from the global view and make sure it doesn't change its\n+        // parent (the base table) but does change the timestamp for its child (the tenant view)\n+        String globalViewColumnAddDDL = \"ALTER VIEW \" + globalViewFullName + \" ADD COL5 varchar\" +\n+            \"(50) \" + \"NULL \";\n+        String globalViewColumnDropDDL = \"ALTER VIEW \" + globalViewFullName + \" DROP COLUMN COL5 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(globalViewColumnAddDDL);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+            long newTableDDLTimestamp = getLastDDLTimestamp(conn,\n+                dataTableFullName);\n+            //table DDL timestamp shouldn't have changed\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName);\n+                //but tenant timestamp should have changed\n+                assertEquals(globalViewDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+\n+            conn.createStatement().execute(globalViewColumnDropDDL);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+            newTableDDLTimestamp = getLastDDLTimestamp(conn,\n+                dataTableFullName);\n+            //table DDL timestamp shouldn't have changed\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName);\n+                //but tenant timestamp should have changed\n+                assertEquals(globalViewDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+        }\n+\n+    }\n+\n+    public static long getLastDDLTimestamp(Connection conn, String dataTableFullName) throws SQLException {", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MzEzNw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523053137", "bodyText": "nit: could you please change the comment to be more specific.\n// First, check that adding a child view didn't change the timestamps of base table", "author": "shahrs87", "createdAt": "2020-11-13T16:14:56Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnAddDDL);\n+            //verify DDL timestamp changed because we added a column to the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnDropDDL);\n+            //verify DDL timestamp changed because we dropped a column from the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            //verify DDL timestamp DID NOT change because we added a column from the base table\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+            conn.createStatement().execute(tableColumnDropDDL);\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampWithChildViews() throws Exception {\n+        Assume.assumeTrue(isMultiTenant);\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String globalViewName = \"V_\" + generateUniqueName();\n+        String tenantViewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String globalViewFullName = SchemaUtil.getTableName(schemaName, globalViewName);\n+        String tenantViewFullName = SchemaUtil.getTableName(schemaName, tenantViewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        //create a table with a child global view, who then has a child tenant view\n+        String globalViewDDL =\n+            \"CREATE VIEW \" + globalViewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String tenantViewDDL =\n+            \"CREATE VIEW \" + tenantViewFullName + \" AS SELECT * FROM \" + globalViewFullName;\n+\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        long tableDDLTimestamp, globalViewDDLTimestamp;\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(globalViewDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+        }\n+        props.setProperty(TENANT_ID_ATTRIB, TENANT1);\n+        try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+            tenantConn.createStatement().execute(tenantViewDDL);\n+        }\n+        // First, check that adding a child view didn't change the timestamps", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNjA4OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525326089", "bodyText": "@gjacoby126  looks like this comment was missed ?", "author": "shahrs87", "createdAt": "2020-11-17T17:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MzEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1NDk0Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523054947", "bodyText": "I don't see any usage of first 3 arguments String tenantId, String schemaName, String tableName\nMaybe you used them in earlier draft then removed them ?", "author": "shahrs87", "createdAt": "2020-11-13T16:17:55Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java", "diffHunk": "@@ -910,6 +911,41 @@ public void testTableDescriptorPriority() throws SQLException, IOException {\n         }\n     }\n \n+    @Test\n+    public void testCreateTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        final String schemaName = generateUniqueName();\n+        final String tableName = generateUniqueName();\n+        final String dataTableFullName = SchemaUtil.getTableName(schemaName, tableName);\n+        String ddl =\n+            \"CREATE TABLE \" + dataTableFullName + \" (\\n\" + \"ID1 VARCHAR(15) NOT NULL,\\n\"\n+                + \"ID2 VARCHAR(15) NOT NULL,\\n\" + \"CREATED_DATE DATE,\\n\"\n+                + \"CREATION_TIME BIGINT,\\n\" + \"LAST_USED DATE,\\n\"\n+                + \"CONSTRAINT PK PRIMARY KEY (ID1, ID2)) \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(ddl);\n+            verifyLastDDLTimestamp(schemaName, tableName, dataTableFullName, startTS, conn);\n+        }\n+    }\n+\n+    public static long verifyLastDDLTimestamp(String schemaName, String tableName,\n+                                              String dataTableFullName, long startTS, Connection conn) throws SQLException {\n+        return verifyLastDDLTimestamp(\"\", schemaName, tableName, dataTableFullName, startTS, conn);\n+    }\n+\n+    public static long verifyLastDDLTimestamp(String tenantId, String schemaName, String tableName,\n+                                              String dataTableFullName, long startTS, Connection conn) throws SQLException {", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA2NTM0MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523065340", "bodyText": "nit: indentation mismatch.", "author": "shahrs87", "createdAt": "2020-11-13T16:34:18Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -2802,7 +2827,8 @@ private MetaDataMutationResult mutateColumn(\n                         getParentPhysicalTableName(table), table.getType());\n \n                 result = mutator.validateAndAddMetadata(table, rowKeyMetaData, tableMetadata,\n-                        region, invalidateList, locks, clientTimeStamp, clientVersion);\n+                        region, invalidateList, locks, clientTimeStamp, clientVersion,\n+                    isAddingOrDroppingColumns);", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7f6c9895009a67280e825944ab0019096b916fc2", "url": "https://github.com/apache/phoenix/commit/7f6c9895009a67280e825944ab0019096b916fc2", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-17T21:35:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1MjIxMA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525452210", "bodyText": "nit: We already have conn.commit()inside nullDDLTimestamps()", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T19:49:29Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java", "diffHunk": "@@ -747,4 +640,83 @@ private void verifyExpectedCellValue(byte[] rowKey, byte[] syscatBytes,\n             assertArrayEquals(expectedDateTypeBytes, CellUtil.cloneValue(cell));\n         }\n     }\n+\n+    @Test\n+    public void testLastDDLTimestampBootstrap() throws Exception {\n+        //Create a table, view, and index\n+        String schemaName = \"S_\" + generateUniqueName();\n+        String tableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String fullTableName = SchemaUtil.getTableName(schemaName, tableName);\n+        String fullViewName = SchemaUtil.getTableName(schemaName, viewName);\n+        try (Connection conn = getConnection(false, null)) {\n+            conn.createStatement().execute(\n+                \"CREATE TABLE \" + fullTableName\n+                    + \" (PK1 VARCHAR NOT NULL, PK2 VARCHAR, KV1 VARCHAR, KV2 VARCHAR CONSTRAINT \" +\n+                    \"PK PRIMARY KEY(PK1, PK2)) \");\n+            conn.createStatement().execute(\n+                \"CREATE VIEW \" + fullViewName + \" AS SELECT * FROM \" + fullTableName);\n+\n+            //Now we null out any existing last ddl timestamps\n+            nullDDLTimestamps(conn);\n+            conn.commit();", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NDE1OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525454159", "bodyText": "Should we also move this test to UpgradeNamespaceIT?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T19:51:04Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java", "diffHunk": "@@ -91,122 +100,6 @@\n @Category(NeedsOwnMiniClusterTest.class)\n public class UpgradeIT extends ParallelStatsDisabledIT {\n \n-    @Test\n-    public void testMapTableToNamespaceDuringUpgrade()\n-            throws SQLException, IOException, IllegalArgumentException, InterruptedException {\n-        String[] strings = new String[] { \"a\", \"b\", \"c\", \"d\" };\n-\n-        try (Connection conn = DriverManager.getConnection(getUrl())) {\n-            String schemaName = \"TEST\";\n-            String phoenixFullTableName = schemaName + \".\" + generateUniqueName();\n-            String indexName = \"IDX_\" + generateUniqueName();\n-            String localIndexName = \"LIDX_\" + generateUniqueName();\n-\n-            String viewName = \"VIEW_\" + generateUniqueName();\n-            String viewIndexName = \"VIDX_\" + generateUniqueName();\n-\n-            String[] tableNames = new String[] { phoenixFullTableName, schemaName + \".\" + indexName,\n-                    schemaName + \".\" + localIndexName, \"diff.\" + viewName, \"test.\" + viewName, viewName};\n-            String[] viewIndexes = new String[] { \"diff.\" + viewIndexName, \"test.\" + viewIndexName };\n-            conn.createStatement().execute(\"CREATE TABLE \" + phoenixFullTableName\n-                    + \"(k VARCHAR PRIMARY KEY, v INTEGER, f INTEGER, g INTEGER NULL, h INTEGER NULL)\");\n-            PreparedStatement upsertStmt = conn\n-                    .prepareStatement(\"UPSERT INTO \" + phoenixFullTableName + \" VALUES(?, ?, 0, 0, 0)\");\n-            int i = 1;\n-            for (String str : strings) {\n-                upsertStmt.setString(1, str);\n-                upsertStmt.setInt(2, i++);\n-                upsertStmt.execute();\n-            }\n-            conn.commit();\n-            // creating local index\n-            conn.createStatement()\n-                    .execute(\"create local index \" + localIndexName + \" on \" + phoenixFullTableName + \"(K)\");\n-            // creating global index\n-            conn.createStatement().execute(\"create index \" + indexName + \" on \" + phoenixFullTableName + \"(k)\");\n-            // creating view in schema 'diff'\n-            conn.createStatement().execute(\"CREATE VIEW diff.\" + viewName + \" (col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            // creating view in schema 'test'\n-            conn.createStatement().execute(\"CREATE VIEW test.\" + viewName + \" (col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            conn.createStatement().execute(\"CREATE VIEW \" + viewName + \"(col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            // Creating index on views\n-            conn.createStatement().execute(\"create index \" + viewIndexName + \"  on diff.\" + viewName + \"(col)\");\n-            conn.createStatement().execute(\"create index \" + viewIndexName + \" on test.\" + viewName + \"(col)\");\n-\n-            // validate data\n-            for (String tableName : tableNames) {\n-                ResultSet rs = conn.createStatement().executeQuery(\"select * from \" + tableName);\n-                for (String str : strings) {\n-                    assertTrue(rs.next());\n-                    assertEquals(str, rs.getString(1));\n-                }\n-            }\n-\n-            // validate view Index data\n-            for (String viewIndex : viewIndexes) {\n-                ResultSet rs = conn.createStatement().executeQuery(\"select * from \" + viewIndex);\n-                for (String str : strings) {\n-                    assertTrue(rs.next());\n-                    assertEquals(str, rs.getString(2));\n-                }\n-            }\n-\n-            HBaseAdmin admin = conn.unwrap(PhoenixConnection.class).getQueryServices().getAdmin();\n-            assertTrue(admin.tableExists(phoenixFullTableName));\n-            assertTrue(admin.tableExists(schemaName + QueryConstants.NAME_SEPARATOR + indexName));\n-            assertTrue(admin.tableExists(MetaDataUtil.getViewIndexPhysicalName(Bytes.toBytes(phoenixFullTableName))));\n-            Properties props = new Properties();\n-            props.setProperty(QueryServices.IS_NAMESPACE_MAPPING_ENABLED, Boolean.toString(true));\n-            props.setProperty(QueryServices.IS_SYSTEM_TABLE_MAPPED_TO_NAMESPACE, Boolean.toString(false));\n-            admin.close();\n-            PhoenixConnection phxConn = DriverManager.getConnection(getUrl(), props).unwrap(PhoenixConnection.class);\n-            UpgradeUtil.upgradeTable(phxConn, phoenixFullTableName);\n-            phxConn.close();\n-            props = new Properties();\n-            phxConn = DriverManager.getConnection(getUrl(), props).unwrap(PhoenixConnection.class);\n-            // purge MetaDataCache except for system tables\n-            phxConn.getMetaDataCache().pruneTables(new PMetaData.Pruner() {\n-                @Override public boolean prune(PTable table) {\n-                    return table.getType() != PTableType.SYSTEM;\n-                }\n-\n-                @Override public boolean prune(PFunction function) {\n-                    return false;\n-                }\n-            });\n-            admin = phxConn.getQueryServices().getAdmin();\n-            String hbaseTableName = SchemaUtil.getPhysicalTableName(Bytes.toBytes(phoenixFullTableName), true)\n-                    .getNameAsString();\n-            assertTrue(admin.tableExists(hbaseTableName));\n-            assertTrue(admin.tableExists(Bytes.toBytes(hbaseTableName)));\n-            assertTrue(admin.tableExists(schemaName + QueryConstants.NAMESPACE_SEPARATOR + indexName));\n-            assertTrue(admin.tableExists(MetaDataUtil.getViewIndexPhysicalName(Bytes.toBytes(hbaseTableName))));\n-            i = 0;\n-            // validate data\n-            for (String tableName : tableNames) {\n-                ResultSet rs = phxConn.createStatement().executeQuery(\"select * from \" + tableName);\n-                for (String str : strings) {\n-                    assertTrue(rs.next());\n-                    assertEquals(str, rs.getString(1));\n-                }\n-            }\n-            // validate view Index data\n-            for (String viewIndex : viewIndexes) {\n-                ResultSet rs = conn.createStatement().executeQuery(\"select * from \" + viewIndex);\n-                for (String str : strings) {\n-                    assertTrue(rs.next());\n-                    assertEquals(str, rs.getString(2));\n-                }\n-            }\n-            PName tenantId = phxConn.getTenantId();\n-            PName physicalName = PNameFactory.newName(hbaseTableName);\n-            String newSchemaName = MetaDataUtil.getViewIndexSequenceSchemaName(physicalName, true);\n-            String newSequenceName = MetaDataUtil.getViewIndexSequenceName(physicalName, tenantId, true);\n-            verifySequenceValue(null, newSequenceName, newSchemaName, Short.MIN_VALUE + 3);\n-            admin.close();\n-        }\n-    }\n-\n     @Test\n     public void testMapMultiTenantTableToNamespaceDuringUpgrade() throws SQLException, SnapshotCreationException,", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0OTI2MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r527049260", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-11-19T17:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NDE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NDk5Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525454997", "bodyText": "nit: Don't need the tenantId variable here", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T19:51:43Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java", "diffHunk": "@@ -387,6 +388,48 @@ public void testViewUsesTableLocalIndex() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCreateViewTimestamp() throws Exception {\n+        String tenantId = null;\n+        createViewTimestampHelper(tenantId);", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0NzQ3OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r527047479", "bodyText": "I could just pass null, but this seemed more self-documenting (because the name makes it clear that I'm passing a null tenant id, rather than making someone need to look at the function def to figure that out)", "author": "gjacoby126", "createdAt": "2020-11-19T17:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NDk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NjM3Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525456376", "bodyText": "I think we can remove this else block since the reinitialized value for tenantId isn't being used anywhere", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T19:52:52Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java", "diffHunk": "@@ -387,6 +388,48 @@ public void testViewUsesTableLocalIndex() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCreateViewTimestamp() throws Exception {\n+        String tenantId = null;\n+        createViewTimestampHelper(tenantId);\n+    }\n+\n+    @Test\n+    public void testCreateTenantViewTimestamp() throws Exception {\n+        createViewTimestampHelper(TENANT1);\n+    }\n+\n+    private void createViewTimestampHelper(String tenantId) throws SQLException {\n+        Properties props = new Properties();\n+        if (tenantId != null) {\n+            props.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n+        } else {\n+            tenantId = \"\";", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0OTUwOQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r527049509", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-11-19T17:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NjM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTQ0OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525539449", "bodyText": "This is not entirely true. I know this is frustrating (I was in the same boat), but in 4.15+ based on what I've gathered, here are the rules for column inheritance w.r.t. diverged and non-diverged views:\nDropping columns from a parent\n\nAny columns dropped from an ancestor that is a physical base table are \"inherited\" by its entire child view hierarchy. This is obvious since the physical column no longer exists and so any descendant view wouldn't be able to project anything for those dropped columns.\n\nSince the shape of the child view changes in this case, we should probably use max(view_DDL_ts, parent_DDL_ts_corresponding_to_col_drop).\nNot sure how easy of a change it would be to store this ts corresponding to column dropped from the parent.\n\n\nAny columns dropped from an ancestor that is a view are \"inherited\" by its entire child view hierarchy even if a child view has diverged.\n\nSame here\n\n\n\nAdding columns to a parent\n\nAny columns added to an ancestor that is a view or physical base table are only inherited by its descendant views that have not diverged.\n\nI think your changes already capture this.\n\n\n\nOverall, the rule seems to be:\nOnce a view diverges from its parent, any columns added to an ancestor base table/view are no longer propagated to the view. A column dropped on an ancestor base table/view is however, always propagated to the child view.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:34:37Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1216,251 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MTU1Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525571557", "bodyText": "That doesn't seem like desirable behavior to me as a feature. As we discussed offline, I think diverged views should have been written to get all ancestor DDL changes. (Also, I think we should allow column projection in view definitions -- SELECT COL1, COL2 FROM FOO rather than SELECT * FROM FOO--, rather than having diverged views at all, but that's a whole new feature and out of scope for this discussion.)\nBut setting all that aside, it's the column drops that are the dangerous operations, because they can break existing queries, not column adds, which are always benign. (Don't care about a new column? Don't select it!) So if I were trying to allow for a view to split off from its parent and be semi-independent, it's the drops I'd try to shield it from, not additions.", "author": "gjacoby126", "createdAt": "2020-11-17T22:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NTI0Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525575243", "bodyText": "I agree, but as you said, changing the behavior of diverged views is out of scope for this discussion.\nAs far as current behavior goes, since columns dropped from parents are always inherited by all views (diverged or not), the lastDDLTs should be updated for even diverged views in those cases, whereas your current changes won't do that.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T22:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTczNQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525539735", "bodyText": "We should ideally drop a pre-existing column from the parent for this test rather than a column that was newly added to the parent.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:35:07Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1216,251 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MzA1MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525573050", "bodyText": "I'll do as you suggest, but should it make a difference?", "author": "gjacoby126", "createdAt": "2020-11-17T22:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3ODM0Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525578347", "bodyText": "If the column is added to the base table after its child view diverges, they view won't inherit it anyways, so dropping the same column from the parent shouldn't change the lastDDLTs of the view either. On the contrary, if an existing column is dropped, that should change the ts of the view. In fact this sounds like a good additional test to add.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T22:51:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwNzQ1OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r526307458", "bodyText": "Switched the test to drop an original table column. (But did not add an additional test because of the open question about what diverged views should do.)", "author": "gjacoby126", "createdAt": "2020-11-18T18:00:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTkxMA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525539910", "bodyText": "Same here.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:35:27Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1216,251 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MDI5Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525540293", "bodyText": "Column drop should change the last DDL timestamp for child views as explained in my previous comment.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:36:11Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1216,251 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            long tableDDLTimestamp = CreateTableIT.getLastDDLTimestamp(conn, dataTableFullName);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = CreateTableIT.getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify table DDL timestamp DID NOT change\n+            assertEquals(tableDDLTimestamp, CreateTableIT.getLastDDLTimestamp(conn, dataTableFullName));\n+            //verify view DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, viewDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewColumnAddDDL);\n+            //verify DDL timestamp changed because we added a column to the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, viewDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewColumnDropDDL);\n+            //verify DDL timestamp changed because we dropped a column from the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, viewDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            //verify DDL timestamp DID NOT change because we added a column from the base table\n+            assertEquals(viewDDLTimestamp, CreateTableIT.getLastDDLTimestamp(conn, viewFullName));\n+            conn.createStatement().execute(tableColumnDropDDL);", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MTkyMw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525541923", "bodyText": "Just for clarity, can we mention that this logic only applies to non-diverged views?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:39:15Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java", "diffHunk": "@@ -399,6 +400,17 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table, byte[][] rowK\n                                 rowKeyMetaData[TABLE_NAME_INDEX])));\n             }\n         }\n+        if (isAddingColumns) {\n+            //We're changing the application-facing schema by adding a column, so update the DDL\n+            // timestamp\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            if (MetaDataUtil.isTableQueryable(table.getType())) {\n+                additionalTableMetadataMutations.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                    clientTimeStamp, serverTimestamp));\n+            }\n+            //we don't need to update the DDL timestamp for child views, because when we look up", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MjIyMQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525542221", "bodyText": "For clarity, can we mention that this logic also applies for diverged views?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:39:45Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java", "diffHunk": "@@ -268,6 +272,16 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table,\n             }\n \n         }\n+        //We're changing the application-facing schema by dropping a column, so update the DDL\n+        // timestamp to current _server_ timestamp\n+        if (MetaDataUtil.isTableQueryable(table.getType())) {\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                clientTimeStamp, serverTimestamp));\n+        }\n+        //we don't need to update the DDL timestamp for any child views we may have, because", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0Mjg2Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525542866", "bodyText": "This comment is no longer valid right?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:40:59Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -2846,21 +2872,25 @@ private MetaDataMutationResult mutateColumn(\n                 separateLocalAndRemoteMutations(region, tableMetadata, localMutations,\n                         remoteMutations);\n                 if (!remoteMutations.isEmpty()) {\n-                    // there should only be remote mutations if we are adding a column to a view\n+                    // there should only be remote mutations if we are updating the last ddl", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MzY2MQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525573661", "bodyText": "Oops, forgot to undo that comment change. Thanks, will fix.", "author": "gjacoby126", "createdAt": "2020-11-17T22:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0Mjg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MzU4OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525543589", "bodyText": "Shouldn't this be done even if if (!remoteMutations.isEmpty()) is false if the table/view has child views??", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:42:22Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -2846,21 +2872,25 @@ private MetaDataMutationResult mutateColumn(\n                 separateLocalAndRemoteMutations(region, tableMetadata, localMutations,\n                         remoteMutations);\n                 if (!remoteMutations.isEmpty()) {\n-                    // there should only be remote mutations if we are adding a column to a view\n+                    // there should only be remote mutations if we are updating the last ddl\n+                    // timestamp for child views, or we are adding a column to a view\n                     // that uses encoded column qualifiers (the remote mutations are to update the\n                     // encoded column qualifier counter on the parent table)\n-                    if (mutator.getMutateColumnType() == ColumnMutator.MutateColumnType.ADD_COLUMN\n+                    if (childViews.size() > 0 || ( mutator.getMutateColumnType() == ColumnMutator.MutateColumnType.ADD_COLUMN", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4ODU1OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525588559", "bodyText": "I added the childViews.size() check when I was sending the ddl timestamp mutations remotely to the child view header rows, which I stopped doing in the last draft. That part of the if clause should just be removed right? Or was the existing logic wrong if a child view existed?", "author": "gjacoby126", "createdAt": "2020-11-17T23:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MzU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTcyNw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525549727", "bodyText": "Except for when a column is dropped from some ancestor after the view diverged. In that case, they do \"inherit\" that change, just like they would have before diverging.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:53:54Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/ViewUtil.java", "diffHunk": "@@ -654,10 +654,17 @@ public static PTable addDerivedColumnsFromParent(PTable view, PTable parentTable\n         }\n \n         long maxTableTimestamp = view.getTimeStamp();\n+        long maxDDLTimestamp = view.getLastDDLTimestamp() != null ? view.getLastDDLTimestamp() : 0L;\n         int numPKCols = view.getPKColumns().size();\n-        // set the final table timestamp as the max timestamp of the view/view index or its\n-        // ancestors\n+        // set the final table timestamp and DDL timestamp as the respective max timestamps of the\n+        // view/view index or its ancestors\n         maxTableTimestamp = Math.max(maxTableTimestamp, parentTable.getTimeStamp());\n+        //Diverged views no longer inherit ddl timestamps from their ancestors because they don't\n+        // inherit column changes", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTc5Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525551793", "bodyText": "Maybe we need to introduce another field in PTable to explicitly store any drop column DDLs being issued to a table/view. Then we could use that to get the lastDDLTs of diverged views.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MDA3OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525580079", "bodyText": "I'd be more inclined to:\nStep 1. Update the last ddl timestamp on either add or drop column, and accept that in a future JIRA the schema registry will be redundantly updated in the (hopefully rare) event that a base table of a diverged view adds a column. Essentially this removes the diverged view check here in ViewUtil. (Easy)\nOptional Step 2. Then in a second JIRA change the diverged view logic to inherit changes on both add column and drop column so the updates aren't really redundant. (Harder, but leaves us in a better state)\nIf there's some compelling reason to keep the existing logic, I'm interested to learn about it, but right now it doesn't seem to justify the enormous complexity (which just keeps compounding with time!) that it requires.", "author": "gjacoby126", "createdAt": "2020-11-17T22:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MDc0NA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525580744", "bodyText": "(Especially since this all appears to be undocumented behavior.)", "author": "gjacoby126", "createdAt": "2020-11-17T22:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwNzk1OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r526307958", "bodyText": "@ChinmaySKulkarni - Pushed up a commit that implements Step 1 described above.", "author": "gjacoby126", "createdAt": "2020-11-18T18:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTcyNw=="}], "type": "inlineReview"}, {"oid": "f427501628fcb482405b0c0dff7cf510650dee00", "url": "https://github.com/apache/phoenix/commit/f427501628fcb482405b0c0dff7cf510650dee00", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-18T21:33:32Z", "type": "commit"}, {"oid": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "url": "https://github.com/apache/phoenix/commit/d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-18T21:33:33Z", "type": "commit"}, {"oid": "75c5bdfd326cdf71c0a3ec8b76756ffa0ae1e058", "url": "https://github.com/apache/phoenix/commit/75c5bdfd326cdf71c0a3ec8b76756ffa0ae1e058", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-18T21:52:39Z", "type": "commit"}, {"oid": "75c5bdfd326cdf71c0a3ec8b76756ffa0ae1e058", "url": "https://github.com/apache/phoenix/commit/75c5bdfd326cdf71c0a3ec8b76756ffa0ae1e058", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-18T21:52:39Z", "type": "forcePushed"}, {"oid": "80982e2a559aaad6a0d25885455b0bc6698ac58b", "url": "https://github.com/apache/phoenix/commit/80982e2a559aaad6a0d25885455b0bc6698ac58b", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-19T05:55:55Z", "type": "commit"}, {"oid": "171e7e2891314a309eafb03bd5c5fe37bf85bc89", "url": "https://github.com/apache/phoenix/commit/171e7e2891314a309eafb03bd5c5fe37bf85bc89", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-19T17:02:06Z", "type": "commit"}, {"oid": "939db6e26a7538da918f967c49f1ab43b8f0c806", "url": "https://github.com/apache/phoenix/commit/939db6e26a7538da918f967c49f1ab43b8f0c806", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-19T21:56:04Z", "type": "commit"}]}