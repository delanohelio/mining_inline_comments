{"pr_number": 966, "pr_title": "PHOENIX-6191: Creating a view which has its own new columns should also do checkAndPut checks on SYSTEM.MUTEX", "pr_createdAt": "2020-11-13T07:02:21Z", "pr_url": "https://github.com/apache/phoenix/pull/966", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwODY2Mg==", "url": "https://github.com/apache/phoenix/pull/966#discussion_r523208662", "bodyText": "This is the only new test", "author": "ChinmaySKulkarni", "createdAt": "2020-11-13T20:35:04Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewConcurrencyAndFailureIT.java", "diffHunk": "@@ -0,0 +1,793 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import static org.apache.phoenix.coprocessor.PhoenixMetaDataCoprocessorHost\n+        .PHOENIX_META_DATA_COPROCESSOR_CONF_KEY;\n+import static org.apache.phoenix.exception.SQLExceptionCode.CANNOT_MUTATE_TABLE;\n+import static org.apache.phoenix.util.TestUtil.TEST_PROPERTIES;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.phoenix.coprocessor.BaseMetaDataEndpointObserver;\n+import org.apache.phoenix.coprocessor.PhoenixMetaDataCoprocessorHost\n+        .PhoenixMetaDataControllerEnvironment;\n+import org.apache.phoenix.exception.PhoenixIOException;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.ConcurrentTableMutationException;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.schema.TableNotFoundException;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.PropertiesUtil;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.After;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import com.google.common.collect.Maps;\n+\n+/**\n+ * Tests for views dealing with other ongoing concurrent operations and\n+ * failure scenarios\n+ */\n+@RunWith(Parameterized.class)\n+public class ViewConcurrencyAndFailureIT extends SplitSystemCatalogIT {\n+\n+    protected String tableDDLOptions;\n+    protected String transactionProvider;\n+    protected boolean columnEncoded;\n+\n+    private static final String FAILED_VIEWNAME = SchemaUtil.getTableName(\n+            SCHEMA2, \"FAILED_VIEW_\" + generateUniqueName());\n+    private static final String SLOW_VIEWNAME_PREFIX =\n+            SchemaUtil.getTableName(SCHEMA2, \"SLOW_VIEW\");\n+\n+    private static volatile CountDownLatch latch1 = null;\n+    private static volatile CountDownLatch latch2 = null;\n+    private static volatile boolean throwExceptionInChildLinkPreHook = false;\n+    private static volatile boolean slowDownAddingChildLink = false;\n+\n+    public ViewConcurrencyAndFailureIT(String transactionProvider,\n+            boolean columnEncoded) {\n+        StringBuilder optionBuilder = new StringBuilder();\n+        this.transactionProvider = transactionProvider;\n+        this.columnEncoded = columnEncoded;\n+        if (transactionProvider != null) {\n+            optionBuilder.append(\" TRANSACTION_PROVIDER='\")\n+                    .append(transactionProvider)\n+                    .append(\"'\");\n+        }\n+        if (!columnEncoded) {\n+            if (optionBuilder.length()!=0)\n+                optionBuilder.append(\",\");\n+            optionBuilder.append(\"COLUMN_ENCODED_BYTES=0\");\n+        }\n+        this.tableDDLOptions = optionBuilder.toString();\n+    }\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameters(name=\"ViewIT_transactionProvider={0}, columnEncoded={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return TestUtil.filterTxParamData(Arrays.asList(new Object[][] {\n+                { \"TEPHRA\", false }, { \"TEPHRA\", true },\n+                { \"OMID\", false },\n+                { null, false }, { null, true }}),0);\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        NUM_SLAVES_BASE = 6;\n+        boolean splitSystemCatalog = (driver == null);\n+        Map<String, String> serverProps = Maps.newHashMapWithExpectedSize(1);\n+        serverProps.put(QueryServices.PHOENIX_ACLS_ENABLED, \"true\");\n+        serverProps.put(PHOENIX_META_DATA_COPROCESSOR_CONF_KEY,\n+                TestMetaDataRegionObserver.class.getName());\n+        serverProps.put(\"hbase.coprocessor.abortonerror\", \"false\");\n+        setUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()),\n+                ReadOnlyProps.EMPTY_PROPS);\n+        // Split SYSTEM.CATALOG once after the mini-cluster is started\n+        if (splitSystemCatalog) {\n+            // splitSystemCatalog is incompatible with the balancer chore\n+            getUtility().getHBaseCluster().getMaster().balanceSwitch(false);\n+            splitSystemCatalog();\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        latch1 = null;\n+        latch2 = null;\n+        throwExceptionInChildLinkPreHook = false;\n+        slowDownAddingChildLink = false;\n+    }\n+\n+    @Test\n+    public void testChildViewCreationFails() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SCHEMA1,\n+                    generateUniqueName());\n+            String failingViewName = FAILED_VIEWNAME;\n+            String succeedingViewName = SchemaUtil.getTableName(SCHEMA3,\n+                    generateUniqueName());\n+\n+            String createTableDdl = \"CREATE TABLE \" + fullTableName\n+                    + \"  (k INTEGER NOT NULL PRIMARY KEY, v1 DATE)\"\n+                    + tableDDLOptions;\n+            stmt.execute(createTableDdl);\n+\n+            String createViewDdl = \"CREATE VIEW \" + failingViewName\n+                    + \" (v2 VARCHAR) AS SELECT * FROM \"\n+                    + fullTableName + \" WHERE k > 5\";\n+            try {\n+                stmt.execute(createViewDdl);\n+                fail();\n+            } catch (PhoenixIOException ignored) {\n+            }\n+            createViewDdl = \"CREATE VIEW \" + succeedingViewName\n+                    + \"(v2 VARCHAR) AS SELECT * FROM \" + fullTableName\n+                    + \" WHERE k > 10\";\n+            stmt.execute(createViewDdl);\n+\n+            // the first child view should not exist\n+            try {\n+                PhoenixRuntime.getTableNoCache(conn, failingViewName);\n+                fail();\n+            } catch (TableNotFoundException ignored) {\n+            }\n+\n+            // we should be able to load the table\n+            PhoenixRuntime.getTableNoCache(conn, fullTableName);\n+            // we should be able to load the second view\n+            PhoenixRuntime.getTableNoCache(conn, succeedingViewName);\n+        }\n+    }\n+\n+    @Test\n+    public void testConcurrentViewCreationAndTableDrop() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            String fullTableName = SchemaUtil.getTableName(SCHEMA1,\n+                    generateUniqueName());\n+            String fullViewName1 = SLOW_VIEWNAME_PREFIX + \"_\"\n+                    + generateUniqueName();\n+            latch1 = new CountDownLatch(1);\n+            latch2 = new CountDownLatch(1);\n+            String tableDdl = \"CREATE TABLE \" + fullTableName +\n+                    \"  (k INTEGER NOT NULL PRIMARY KEY, v1 INTEGER, v2 INTEGER)\"\n+                    + tableDDLOptions;\n+            stmt.execute(tableDdl);\n+\n+            ExecutorService executorService = Executors.newFixedThreadPool(\n+                    1, new ThreadFactory() {\n+                @Override\n+                public Thread newThread(Runnable r) {\n+                    Thread t = Executors.defaultThreadFactory().newThread(r);\n+                    t.setDaemon(true);\n+                    t.setPriority(Thread.MIN_PRIORITY);\n+                    return t;\n+                }\n+            });\n+\n+            // When dropping a table, we check the parent->child links in the\n+            // SYSTEM.CHILD_LINK table and check that cascade is set, if it\n+            // isn't, we throw an exception (see ViewUtil.hasChildViews).\n+            // After PHOENIX-4810, we first send a client-server RPC to add\n+            // parent->child links to SYSTEM.CHILD_LINK and then add metadata\n+            // for the view in SYSTEM.CATALOG, so we must delay link creation\n+            // so that the drop table does not fail\n+            slowDownAddingChildLink = true;\n+            // create the view in a separate thread (which will take some time\n+            // to complete)\n+            Future<Exception> future = executorService.submit(\n+                    new CreateViewRunnable(fullTableName, fullViewName1));\n+            // wait till the thread makes the rpc to create the view\n+            latch1.await();\n+            tableDdl = \"DROP TABLE \" + fullTableName;\n+\n+            // Revert this flag since we don't want to wait in preDropTable\n+            slowDownAddingChildLink = false;\n+            // drop table goes through first and so the view creation\n+            // should fail\n+            stmt.execute(tableDdl);\n+            latch2.countDown();\n+\n+            Exception e = future.get();\n+            assertTrue(\"Expected TableNotFoundException since drop table\"\n+                            + \" goes through first\",\n+                    e instanceof TableNotFoundException &&\n+                            fullTableName.equals(((TableNotFoundException) e)\n+                                    .getTableName()));\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testChildLinkCreationFailThrowsException() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            String fullTableName = SchemaUtil.getTableName(SCHEMA1,\n+                    generateUniqueName());\n+            String fullViewName1 = SchemaUtil.getTableName(SCHEMA3,\n+                    generateUniqueName());\n+            // create base table\n+            String tableDdl = \"CREATE TABLE \" + fullTableName\n+                    + \"  (k INTEGER NOT NULL PRIMARY KEY, v1 DATE)\"\n+                    + tableDDLOptions;\n+            stmt.execute(tableDdl);\n+\n+            // Throw an exception in ChildLinkMetaDataEndpoint while adding\n+            // parent->child links to simulate a failure\n+            throwExceptionInChildLinkPreHook = true;\n+            // create a view\n+            String ddl = \"CREATE VIEW \" + fullViewName1\n+                    + \" (v2 VARCHAR) AS SELECT * FROM \"\n+                    + fullTableName + \" WHERE k = 6\";\n+            try {\n+                stmt.execute(ddl);\n+                fail(\"Should have thrown an exception\");\n+            } catch(SQLException sqlE) {\n+                assertEquals(\"Expected a different Error code\",\n+                        SQLExceptionCode.UNABLE_TO_CREATE_CHILD_LINK\n+                                .getErrorCode(), sqlE.getErrorCode());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testConcurrentAddSameColumnDifferentType() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            String fullTableName = SchemaUtil.getTableName(SCHEMA1,\n+                    generateUniqueName());\n+            String fullViewName1 = SLOW_VIEWNAME_PREFIX + \"_\"\n+                    + generateUniqueName();\n+            String fullViewName2 = SchemaUtil.getTableName(SCHEMA3,\n+                    generateUniqueName());\n+            // create base table\n+            String tableDdl = \"CREATE TABLE \" + fullTableName\n+                    + \"  (k INTEGER NOT NULL PRIMARY KEY, v1 DATE)\"\n+                    + tableDDLOptions;\n+            stmt.execute(tableDdl);\n+            // create a view\n+            String ddl = \"CREATE VIEW \" + fullViewName1\n+                    + \" (v2 VARCHAR) AS SELECT * FROM \"\n+                    + fullTableName + \" WHERE k = 6\";\n+            stmt.execute(ddl);\n+\n+            latch1 = new CountDownLatch(1);\n+            latch2 = new CountDownLatch(1);\n+            ExecutorService executorService = Executors.newFixedThreadPool(\n+                    1, new ThreadFactory() {\n+                @Override\n+                public Thread newThread(Runnable r) {\n+                    Thread t = Executors.defaultThreadFactory().newThread(r);\n+                    t.setDaemon(true);\n+                    t.setPriority(Thread.MIN_PRIORITY);\n+                    return t;\n+                }\n+            });\n+\n+            // add a column with the same name and different type to the view\n+            // in a separate thread (which will take some time to complete)\n+            Future<Exception> future = executorService.submit(\n+                    new AddColumnRunnable(fullViewName1, null));\n+            // wait till the thread makes the rpc to add the column\n+            boolean result = latch1.await(2, TimeUnit.MINUTES);\n+            if (!result) {\n+                fail(\"The create view rpc look too long\");\n+            }\n+            tableDdl = \"ALTER TABLE \" + fullTableName + \" ADD v3 INTEGER\";\n+            try {\n+                // add the same column to the base table with a different type\n+                stmt.execute(tableDdl);\n+                fail(\"Adding a column to a base table should fail when \"\n+                        + \"the same column of a different type is being added \"\n+                        + \"to a child view\");\n+            } catch (ConcurrentTableMutationException ignored) {\n+            }\n+            latch2.countDown();\n+\n+            Exception e = future.get();\n+            assertNull(e);\n+\n+            // add the same column to the another view  to ensure that the cell\n+            // used to prevent concurrent modifications was removed\n+            ddl = \"CREATE VIEW \" + fullViewName2\n+                    + \" (v2 VARCHAR) AS SELECT * FROM \"\n+                    + fullTableName + \" WHERE k = 6\";\n+            stmt.execute(ddl);\n+            tableDdl = \"ALTER VIEW \" + fullViewName2 + \" ADD v3 INTEGER\";\n+            stmt.execute(tableDdl);\n+        }\n+    }\n+\n+    // Test that we do a checkAndPut even in case of tenant-specific connections\n+    // (see PHOENIX-6075)\n+    @Test\n+    public void testConcurrentAddSameColumnDifferentTypeTenantView()\n+            throws Exception {\n+        String fullTableName = SchemaUtil.getTableName(SCHEMA1,\n+                generateUniqueName());\n+        String fullViewName1 = SLOW_VIEWNAME_PREFIX + \"_\"\n+                + generateUniqueName();\n+        String fullViewName2 = SchemaUtil.getTableName(SCHEMA3,\n+                generateUniqueName());\n+        String tenantId = \"t001\";\n+        String tableDdl = \"CREATE TABLE \" + fullTableName\n+                + \" (TENANT_ID VARCHAR NOT NULL, k INTEGER NOT NULL, v1 DATE \"\n+                + \"CONSTRAINT PK\"\n+                + \" PRIMARY KEY (TENANT_ID, k)) MULTI_TENANT=true\"\n+                + (!tableDDLOptions.isEmpty() ? \", \" : \"\") + tableDDLOptions;\n+        String viewDdl = \"CREATE VIEW \" + fullViewName1\n+                + \" (v2 VARCHAR) AS SELECT * FROM \"\n+                + fullTableName + \" WHERE k = 6\";\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            // create a multi-tenant base table\n+            stmt.execute(tableDdl);\n+\n+            Properties props = new Properties();\n+            props.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(),\n+                    props);\n+                    Statement tenantStmt = tenantConn.createStatement()) {\n+                // create a tenant-specific view\n+                tenantStmt.execute(viewDdl);\n+            }\n+\n+            latch1 = new CountDownLatch(1);\n+            latch2 = new CountDownLatch(1);\n+            ExecutorService executorService = Executors.newFixedThreadPool(\n+                    1, new ThreadFactory() {\n+                @Override\n+                public Thread newThread(Runnable r) {\n+                    Thread t = Executors.defaultThreadFactory().newThread(r);\n+                    t.setDaemon(true);\n+                    t.setPriority(Thread.MIN_PRIORITY);\n+                    return t;\n+                }\n+            });\n+\n+            // add a column with the same name and different type to the\n+            // tenant-specific view in a\n+            // separate thread (which will take some time to complete)\n+            Future<Exception> future = executorService.submit(\n+                    new AddColumnRunnable(fullViewName1, tenantId));\n+            // wait till the thread makes the rpc to add the column\n+            boolean result = latch1.await(2, TimeUnit.MINUTES);\n+            if (!result) {\n+                fail(\"The tenant-specific view creation rpc look too long\");\n+            }\n+            tableDdl = \"ALTER TABLE \" + fullTableName + \" ADD v3 INTEGER\";\n+            try {\n+                // add the same column to the base table with a different type\n+                stmt.execute(tableDdl);\n+                fail(\"Adding a column to a base table should fail when \"\n+                        + \"the same column of a different type is being added\"\n+                        + \" to a child view\");\n+            } catch (ConcurrentTableMutationException ignored) {\n+            }\n+            latch2.countDown();\n+\n+            Exception e = future.get();\n+            assertNull(e);\n+\n+            // add the same column to the another view  to ensure that the cell\n+            // used to prevent concurrent modifications was removed\n+            viewDdl = \"CREATE VIEW \" + fullViewName2\n+                    + \" (v2 VARCHAR) AS SELECT * FROM \"\n+                    + fullTableName + \" WHERE k = 6\";\n+            stmt.execute(viewDdl);\n+            tableDdl = \"ALTER VIEW \" + fullViewName2 + \" ADD v3 INTEGER\";\n+            stmt.execute(tableDdl);\n+        }\n+    }\n+\n+    @Test\n+    public void testConcurrentAddDifferentColumnParentHasColEncoding()\n+            throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            String fullTableName = SchemaUtil.getTableName(SCHEMA1,\n+                    generateUniqueName());\n+            String fullViewName1 = SLOW_VIEWNAME_PREFIX + \"_\"\n+                    + generateUniqueName();\n+            String fullViewName2 = SchemaUtil.getTableName(SCHEMA3,\n+                    generateUniqueName());\n+            String fullViewName3 = SchemaUtil.getTableName(SCHEMA4,\n+                    generateUniqueName());\n+            // create base table\n+            String tableDdl = \"CREATE TABLE \" + fullTableName\n+                    + \"  (k INTEGER NOT NULL PRIMARY KEY, v1 DATE)\"\n+                    + tableDDLOptions;\n+            stmt.execute(tableDdl);\n+            // create two views\n+            String ddl = \"CREATE VIEW \" + fullViewName1\n+                    + \" (v2 VARCHAR) AS SELECT * FROM \"\n+                    + fullTableName + \" WHERE k = 6\";\n+            stmt.execute(ddl);\n+            ddl = \"CREATE VIEW \" + fullViewName3\n+                    + \" (v2 VARCHAR) AS SELECT * FROM \"\n+                    + fullTableName + \" WHERE k = 7\";\n+            stmt.execute(ddl);\n+\n+            latch1 = new CountDownLatch(1);\n+            latch2 = new CountDownLatch(1);\n+            ExecutorService executorService = Executors.newFixedThreadPool(\n+                    1, new ThreadFactory() {\n+                @Override\n+                public Thread newThread(Runnable r) {\n+                    Thread t = Executors.defaultThreadFactory().newThread(r);\n+                    t.setDaemon(true);\n+                    t.setPriority(Thread.MIN_PRIORITY);\n+                    return t;\n+                }\n+            });\n+\n+            // add a column to a view in a separate thread (we slow this\n+            // operation down)\n+            Future<Exception> future = executorService.submit(\n+                    new AddColumnRunnable(fullViewName1, null));\n+            // wait till the thread makes the rpc to add the column\n+            boolean result = latch1.await(2, TimeUnit.MINUTES);\n+            if (!result) {\n+                fail(\"The alter view rpc look too long\");\n+            }\n+            tableDdl = \"ALTER VIEW \" + fullViewName3 + \" ADD v4 INTEGER\";\n+            try {\n+                // add a column to another view\n+                stmt.execute(tableDdl);\n+                if (columnEncoded) {\n+                    // this should fail as the previous add column is still\n+                    // not complete\n+                    fail(\"Adding columns to two different views concurrently\"\n+                            + \" where the base table\"\n+                            + \" uses encoded columns should fail\");\n+                }\n+            } catch (ConcurrentTableMutationException e) {\n+                if (!columnEncoded) {\n+                    // this should not fail as we don't need to update the\n+                    // parent table for non column encoded tables\n+                    fail(\"Adding columns to two different views concurrently\"\n+                            + \" where the base table does not use encoded\"\n+                            + \" columns should succeed\");\n+                }\n+            }\n+            latch2.countDown();\n+\n+            Exception e = future.get();\n+            // if the base table uses column encoding then the add column\n+            // operation for fullViewName1 fails\n+            assertNull(e);\n+\n+            // add the same column to the another view  to ensure that the cell\n+            // used to prevent concurrent modifications was removed\n+            ddl = \"CREATE VIEW \" + fullViewName2\n+                    + \" (v2 VARCHAR) AS SELECT * FROM \"\n+                    + fullTableName + \" WHERE k = 6\";\n+            stmt.execute(ddl);\n+            tableDdl = \"ALTER VIEW \" + fullViewName2 + \" ADD v3 INTEGER\";\n+            stmt.execute(tableDdl);\n+        }\n+    }\n+\n+    /**\n+     * Concurrently create a view with a WHERE condition and also try to drop\n+     * the parent column on which the WHERE condition depends\n+     */\n+    @Test\n+    public void testConcurrentViewCreationParentColDropViewCondition()\n+            throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            String fullTableName = SchemaUtil.getTableName(SCHEMA1,\n+                    generateUniqueName());\n+            String fullViewName1 = SLOW_VIEWNAME_PREFIX + \"_\"\n+                    + generateUniqueName();\n+\n+            // create base table\n+            String tableDdl = \"CREATE TABLE \" + fullTableName\n+                    + \"  (k INTEGER NOT NULL PRIMARY KEY, v1 INTEGER)\"\n+                    + tableDDLOptions;\n+            stmt.execute(tableDdl);\n+\n+            latch1 = new CountDownLatch(1);\n+            latch2 = new CountDownLatch(1);\n+            ExecutorService executorService = Executors.newFixedThreadPool(\n+                    1, new ThreadFactory() {\n+                        @Override\n+                        public Thread newThread(Runnable r) {\n+                            Thread t = Executors.defaultThreadFactory()\n+                                    .newThread(r);\n+                            t.setDaemon(true);\n+                            t.setPriority(Thread.MIN_PRIORITY);\n+                            return t;\n+                        }\n+                    });\n+\n+            Future<Exception> future = executorService.submit(\n+                    new CreateViewRunnable(fullTableName, fullViewName1));\n+            // wait till the thread makes the rpc to add the column\n+            boolean result = latch1.await(2, TimeUnit.MINUTES);\n+            if (!result) {\n+                fail(\"The create view rpc look too long\");\n+            }\n+            tableDdl = \"ALTER TABLE \" + fullTableName + \" DROP COLUMN v1\";\n+            try {\n+                // drop the view WHERE condition column from the parent\n+                stmt.execute(tableDdl);\n+                fail(\"Dropping a column from a base table should fail when a\"\n+                        + \" child view is concurrently being created whose\"\n+                        + \" view WHERE condition depends on this column\");\n+            } catch (ConcurrentTableMutationException ignored) {\n+            }\n+            latch2.countDown();\n+\n+            Exception e = future.get();\n+            assertNull(e);\n+\n+            // Now doing the same DROP COLUMN from the parent should fail with\n+            // a different exception, but not a ConcurrentTableMutationException\n+            // since the cell used to prevent concurrent modifications\n+            // should be removed\n+            try {\n+                stmt.execute(tableDdl);\n+                fail(\"Dropping a column from a parent that a child view depends\"\n+                        + \" on should fail\");\n+            } catch (SQLException sqlE) {\n+                assertEquals(\"Expected a different SQLException\",\n+                        CANNOT_MUTATE_TABLE.getErrorCode(),sqlE.getErrorCode());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Concurrently create a view which has its own new column and also try to\n+     * add the same column to its parent.\n+     * See PHOENIX-6191\n+     */\n+    @Test\n+    public void testConcurrentViewCreationWithNewColParentColAddition()", "originalCommit": "113f5eb9495ec7c0601822de268cc34495f8a726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ2NjU1OQ==", "url": "https://github.com/apache/phoenix/pull/966#discussion_r524466559", "bodyText": "@ChinmaySKulkarni What is the expected behavior when it is a global view and only one (or some tenants) have the (offending) column?", "author": "jpisaac", "createdAt": "2020-11-16T18:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwODY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ5NzU1NQ==", "url": "https://github.com/apache/phoenix/pull/966#discussion_r524497555", "bodyText": "If any tenant view has the column already, then a conflicting column addition to its parent global view or even the ancestor base table will fail with a CANNOT_MUTATE_TABLE SQLException", "author": "ChinmaySKulkarni", "createdAt": "2020-11-16T18:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwODY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcxMzkxNg==", "url": "https://github.com/apache/phoenix/pull/966#discussion_r523713916", "bodyText": "nit: maybe use newSingleThreadExecutor() instead? (for all similar places in this file)", "author": "virajjasani", "createdAt": "2020-11-15T06:17:51Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewConcurrencyAndFailureIT.java", "diffHunk": "@@ -0,0 +1,793 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import static org.apache.phoenix.coprocessor.PhoenixMetaDataCoprocessorHost\n+        .PHOENIX_META_DATA_COPROCESSOR_CONF_KEY;\n+import static org.apache.phoenix.exception.SQLExceptionCode.CANNOT_MUTATE_TABLE;\n+import static org.apache.phoenix.util.TestUtil.TEST_PROPERTIES;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.phoenix.coprocessor.BaseMetaDataEndpointObserver;\n+import org.apache.phoenix.coprocessor.PhoenixMetaDataCoprocessorHost\n+        .PhoenixMetaDataControllerEnvironment;\n+import org.apache.phoenix.exception.PhoenixIOException;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.ConcurrentTableMutationException;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.schema.TableNotFoundException;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.PropertiesUtil;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.After;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import com.google.common.collect.Maps;\n+\n+/**\n+ * Tests for views dealing with other ongoing concurrent operations and\n+ * failure scenarios\n+ */\n+@RunWith(Parameterized.class)\n+public class ViewConcurrencyAndFailureIT extends SplitSystemCatalogIT {\n+\n+    protected String tableDDLOptions;\n+    protected String transactionProvider;\n+    protected boolean columnEncoded;\n+\n+    private static final String FAILED_VIEWNAME = SchemaUtil.getTableName(\n+            SCHEMA2, \"FAILED_VIEW_\" + generateUniqueName());\n+    private static final String SLOW_VIEWNAME_PREFIX =\n+            SchemaUtil.getTableName(SCHEMA2, \"SLOW_VIEW\");\n+\n+    private static volatile CountDownLatch latch1 = null;\n+    private static volatile CountDownLatch latch2 = null;\n+    private static volatile boolean throwExceptionInChildLinkPreHook = false;\n+    private static volatile boolean slowDownAddingChildLink = false;\n+\n+    public ViewConcurrencyAndFailureIT(String transactionProvider,\n+            boolean columnEncoded) {\n+        StringBuilder optionBuilder = new StringBuilder();\n+        this.transactionProvider = transactionProvider;\n+        this.columnEncoded = columnEncoded;\n+        if (transactionProvider != null) {\n+            optionBuilder.append(\" TRANSACTION_PROVIDER='\")\n+                    .append(transactionProvider)\n+                    .append(\"'\");\n+        }\n+        if (!columnEncoded) {\n+            if (optionBuilder.length()!=0)\n+                optionBuilder.append(\",\");\n+            optionBuilder.append(\"COLUMN_ENCODED_BYTES=0\");\n+        }\n+        this.tableDDLOptions = optionBuilder.toString();\n+    }\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameters(name=\"ViewIT_transactionProvider={0}, columnEncoded={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return TestUtil.filterTxParamData(Arrays.asList(new Object[][] {\n+                { \"TEPHRA\", false }, { \"TEPHRA\", true },\n+                { \"OMID\", false },\n+                { null, false }, { null, true }}),0);\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        NUM_SLAVES_BASE = 6;\n+        boolean splitSystemCatalog = (driver == null);\n+        Map<String, String> serverProps = Maps.newHashMapWithExpectedSize(1);\n+        serverProps.put(QueryServices.PHOENIX_ACLS_ENABLED, \"true\");\n+        serverProps.put(PHOENIX_META_DATA_COPROCESSOR_CONF_KEY,\n+                TestMetaDataRegionObserver.class.getName());\n+        serverProps.put(\"hbase.coprocessor.abortonerror\", \"false\");\n+        setUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()),\n+                ReadOnlyProps.EMPTY_PROPS);\n+        // Split SYSTEM.CATALOG once after the mini-cluster is started\n+        if (splitSystemCatalog) {\n+            // splitSystemCatalog is incompatible with the balancer chore\n+            getUtility().getHBaseCluster().getMaster().balanceSwitch(false);\n+            splitSystemCatalog();\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        latch1 = null;\n+        latch2 = null;\n+        throwExceptionInChildLinkPreHook = false;\n+        slowDownAddingChildLink = false;\n+    }\n+\n+    @Test\n+    public void testChildViewCreationFails() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SCHEMA1,\n+                    generateUniqueName());\n+            String failingViewName = FAILED_VIEWNAME;\n+            String succeedingViewName = SchemaUtil.getTableName(SCHEMA3,\n+                    generateUniqueName());\n+\n+            String createTableDdl = \"CREATE TABLE \" + fullTableName\n+                    + \"  (k INTEGER NOT NULL PRIMARY KEY, v1 DATE)\"\n+                    + tableDDLOptions;\n+            stmt.execute(createTableDdl);\n+\n+            String createViewDdl = \"CREATE VIEW \" + failingViewName\n+                    + \" (v2 VARCHAR) AS SELECT * FROM \"\n+                    + fullTableName + \" WHERE k > 5\";\n+            try {\n+                stmt.execute(createViewDdl);\n+                fail();\n+            } catch (PhoenixIOException ignored) {\n+            }\n+            createViewDdl = \"CREATE VIEW \" + succeedingViewName\n+                    + \"(v2 VARCHAR) AS SELECT * FROM \" + fullTableName\n+                    + \" WHERE k > 10\";\n+            stmt.execute(createViewDdl);\n+\n+            // the first child view should not exist\n+            try {\n+                PhoenixRuntime.getTableNoCache(conn, failingViewName);\n+                fail();\n+            } catch (TableNotFoundException ignored) {\n+            }\n+\n+            // we should be able to load the table\n+            PhoenixRuntime.getTableNoCache(conn, fullTableName);\n+            // we should be able to load the second view\n+            PhoenixRuntime.getTableNoCache(conn, succeedingViewName);\n+        }\n+    }\n+\n+    @Test\n+    public void testConcurrentViewCreationAndTableDrop() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            String fullTableName = SchemaUtil.getTableName(SCHEMA1,\n+                    generateUniqueName());\n+            String fullViewName1 = SLOW_VIEWNAME_PREFIX + \"_\"\n+                    + generateUniqueName();\n+            latch1 = new CountDownLatch(1);\n+            latch2 = new CountDownLatch(1);\n+            String tableDdl = \"CREATE TABLE \" + fullTableName +\n+                    \"  (k INTEGER NOT NULL PRIMARY KEY, v1 INTEGER, v2 INTEGER)\"\n+                    + tableDDLOptions;\n+            stmt.execute(tableDdl);\n+\n+            ExecutorService executorService = Executors.newFixedThreadPool(\n+                    1, new ThreadFactory() {", "originalCommit": "113f5eb9495ec7c0601822de268cc34495f8a726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "33fb75a150362dbcad3c7e064203f50991d9c0e6", "url": "https://github.com/apache/phoenix/commit/33fb75a150362dbcad3c7e064203f50991d9c0e6", "message": "PHOENIX-6191: Creating a view which has its own new columns should also do checkAndPut checks on SYSTEM.MUTEX", "committedDate": "2020-11-16T23:59:07Z", "type": "commit"}, {"oid": "33fb75a150362dbcad3c7e064203f50991d9c0e6", "url": "https://github.com/apache/phoenix/commit/33fb75a150362dbcad3c7e064203f50991d9c0e6", "message": "PHOENIX-6191: Creating a view which has its own new columns should also do checkAndPut checks on SYSTEM.MUTEX", "committedDate": "2020-11-16T23:59:07Z", "type": "forcePushed"}]}