{"pr_number": 903, "pr_title": "PHOENIX-6142: Make DDL operations resilient to orphan parent->child linking rows in SYSTEM.CHILD_LINK", "pr_createdAt": "2020-09-30T01:31:55Z", "pr_url": "https://github.com/apache/phoenix/pull/903", "timeline": [{"oid": "4dddc86d5c6833458c38b4930e8f27cd209ccfd8", "url": "https://github.com/apache/phoenix/commit/4dddc86d5c6833458c38b4930e8f27cd209ccfd8", "message": "PHOENIX-6142: Make DDL operations resilient to orphan parent->child linking rows in SYSTEM.CHILD_LINK", "committedDate": "2020-09-30T19:06:44Z", "type": "forcePushed"}, {"oid": "41883da33e49b431bf859d3984b2d050480e56d5", "url": "https://github.com/apache/phoenix/commit/41883da33e49b431bf859d3984b2d050480e56d5", "message": "PHOENIX-6142: Make DDL operations resilient to orphan parent->child linking rows in SYSTEM.CHILD_LINK", "committedDate": "2020-10-14T20:17:23Z", "type": "forcePushed"}, {"oid": "d698b728b00ce6b3d6f461944c53727fac795fbc", "url": "https://github.com/apache/phoenix/commit/d698b728b00ce6b3d6f461944c53727fac795fbc", "message": "PHOENIX-6142: Make DDL operations resilient to orphan parent->child linking rows in SYSTEM.CHILD_LINK", "committedDate": "2020-10-15T22:10:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQzMDExNA==", "url": "https://github.com/apache/phoenix/pull/903#discussion_r507430114", "bodyText": "Wondering whether you want to add a test -\nthat validates that the order of dropping does not matter, in other words dropping level1view2 first.\nAlso, wondering whether adding multiple global views(level1 views for a parent) would make for a more robust test suite?", "author": "jpisaac", "createdAt": "2020-10-19T04:05:27Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewMetadataIT.java", "diffHunk": "@@ -294,7 +321,246 @@ public void testRecreateDroppedTableWithChildViews() throws Exception {\n         }\n     }\n \n-    private void runDropChildViewsTask() {\n+    @Test\n+    public void testAlterTableIsResilientToOrphanLinks() throws SQLException {\n+        final String parent1TableName = generateUniqueName();\n+        final String parent2TableName = generateUniqueName();\n+        final String viewName = \"V_\" + generateUniqueName();\n+        // Note that this column name is the same as the new column on the child view\n+        final String alterTableDDL = \"ALTER TABLE %s ADD NEW_COL1 VARCHAR\";\n+        createOrphanLink(SCHEMA1, parent1TableName, parent2TableName, SCHEMA2, viewName);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            // Should not fail since this table is unrelated to the view in spite of\n+            // the orphan parent->child link\n+            stmt.execute(String.format(alterTableDDL,\n+                    SchemaUtil.getTableName(SCHEMA1, parent2TableName)));\n+            try {\n+                stmt.execute(String.format(alterTableDDL,\n+                        SchemaUtil.getTableName(SCHEMA1, parent1TableName)));\n+                fail(\"Adding column should be disallowed since there is a conflicting column type \"\n+                        + \"on the child view\");\n+            } catch (SQLException sqlEx) {\n+                assertEquals(CANNOT_MUTATE_TABLE.getErrorCode(), sqlEx.getErrorCode());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testDropTableIsResilientToOrphanLinks() throws SQLException {\n+        final String parent1TableName = generateUniqueName();\n+        final String parent2TableName = generateUniqueName();\n+        final String viewName = \"V_\" + generateUniqueName();\n+        final String dropTableNoCascadeDDL = \"DROP TABLE %s \";\n+        createOrphanLink(SCHEMA1, parent1TableName, parent2TableName, SCHEMA2, viewName);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            // Should not fail since this table is unrelated to the view in spite of\n+            // the orphan parent->child link\n+            stmt.execute(String.format(dropTableNoCascadeDDL,\n+                    SchemaUtil.getTableName(SCHEMA1, parent2TableName)));\n+            try {\n+                stmt.execute(String.format(dropTableNoCascadeDDL,\n+                        SchemaUtil.getTableName(SCHEMA1, parent1TableName)));\n+                fail(\"Drop table without cascade should fail since there is a child view\");\n+            } catch (SQLException sqlEx) {\n+                assertEquals(CANNOT_MUTATE_TABLE.getErrorCode(), sqlEx.getErrorCode());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create a view hierarchy:\n+     *               parent1           parent2\n+     *                  |                 |\n+     *              level1view1      level1view2\n+     *                  |                 |\n+     *           t001.level2view1  t001.level2view2\n+     *                                    |\n+     *                             t001.level3view1\n+     *\n+     * We induce orphan links by recreating the same view names on top of different parents\n+     */\n+    @Test\n+    public void testViewHierarchyWithOrphanLinks() throws Exception {\n+        final List<TableInfo> expectedLegitChildViewsListForParent1 = new ArrayList<>();\n+        final List<TableInfo> expectedLegitChildViewsListForParent2 = new ArrayList<>();\n+        final String tenantId = \"t001\";\n+        final String parent1TableName = \"P1_\" + generateUniqueName();\n+        final String parent2TableName = \"P2_\" + generateUniqueName();\n+        final String level1ViewName1 = \"L1_V_1_\" + generateUniqueName();\n+        final String level1ViewName2 = \"L1_V_2_\" + generateUniqueName();\n+        final String level2ViewName1 = \"L2_V_1_\" + generateUniqueName();\n+        final String level2ViewName2 = \"L2_V_2_\" + generateUniqueName();\n+        final String level3ViewName1 = \"L3_V_1_\" + generateUniqueName();\n+        createOrphanLink(BASE_TABLE_SCHEMA, parent1TableName, parent2TableName,\n+                CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName1);\n+        expectedLegitChildViewsListForParent1.add(new TableInfo(\n+                null, CHILD_VIEW_LEVEL_1_SCHEMA.getBytes(), level1ViewName1.getBytes()));\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            // Create a legit view on top of parent2\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_1_DDL,\n+                    CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName2,\n+                    BASE_TABLE_SCHEMA, parent2TableName));\n+            expectedLegitChildViewsListForParent2.add(new TableInfo(\n+                    null, CHILD_VIEW_LEVEL_1_SCHEMA.getBytes(), level1ViewName2.getBytes()));\n+        }\n+        Properties props = new Properties();\n+        props.put(TENANT_ID_ATTRIB, tenantId);\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_2_DDL,\n+                    CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName1,\n+                    CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName1));\n+            expectedLegitChildViewsListForParent1.add(new TableInfo(tenantId.getBytes(),\n+                    CHILD_VIEW_LEVEL_2_SCHEMA.getBytes(), level2ViewName1.getBytes()));\n+\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_2_DDL,\n+                    CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName2,\n+                    CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName2));\n+            expectedLegitChildViewsListForParent2.add(new TableInfo(tenantId.getBytes(),\n+                    CHILD_VIEW_LEVEL_2_SCHEMA.getBytes(), level2ViewName2.getBytes()));\n+\n+            // Try to recreate the same view on a different global view to create an orphan link\n+            try {\n+                conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_2_DDL,\n+                        CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName2,\n+                        CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName1));\n+                fail(\"Creating the same view again should have failed\");\n+            } catch (TableAlreadyExistsException ignored) {\n+                // expected\n+            }\n+            // Create a third level view\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_3_DDL,\n+                    CHILD_VIEW_LEVEL_3_SCHEMA, level3ViewName1,\n+                    CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName2));\n+            expectedLegitChildViewsListForParent2.add(new TableInfo(tenantId.getBytes(),\n+                    CHILD_VIEW_LEVEL_3_SCHEMA.getBytes(), level3ViewName1.getBytes()));\n+        }\n+        /*\n+            After this setup, SYSTEM.CHILD_LINK parent->child linking rows will look like this:\n+            parent1->level1view1\n+            parent2->level1view1 (orphan)\n+            parent2->level1view2\n+\n+            level1view1->t001.level2view1\n+            level1view1->t001.level2view2 (orphan)\n+            level1view2->t001.level2view2\n+\n+            t001.level2view2->t001.level3view1\n+         */\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            ConnectionQueryServices cqs = conn.unwrap(PhoenixConnection.class).getQueryServices();\n+            try (Table childLinkTable = cqs.getTable(SchemaUtil.getPhysicalName(\n+                    SYSTEM_LINK_HBASE_TABLE_NAME.toBytes(), cqs.getProps()).getName())) {\n+                Pair<List<PTable>, List<TableInfo>> allDescendants =\n+                        ViewUtil.findAllDescendantViews(childLinkTable, cqs.getConfiguration(),\n+                                EMPTY_BYTE_ARRAY, BASE_TABLE_SCHEMA.getBytes(),\n+                                parent1TableName.getBytes(), HConstants.LATEST_TIMESTAMP, false);\n+                List<PTable> legitChildViews = allDescendants.getFirst();\n+                List<TableInfo> orphanViews = allDescendants.getSecond();\n+                // All of the orphan links are legit views of the other parent so they don't count\n+                // as orphan views for this parent\n+                assertTrue(orphanViews.isEmpty());\n+                assertLegitChildViews(expectedLegitChildViewsListForParent1, legitChildViews);\n+\n+                allDescendants = ViewUtil.findAllDescendantViews(childLinkTable,\n+                        cqs.getConfiguration(), EMPTY_BYTE_ARRAY, BASE_TABLE_SCHEMA.getBytes(),\n+                        parent2TableName.getBytes(), HConstants.LATEST_TIMESTAMP, false);\n+                legitChildViews = allDescendants.getFirst();\n+                orphanViews = allDescendants.getSecond();\n+                // All of the orphan links are legit views of the other parent so they don't count\n+                // as orphan views for this parent\n+                assertTrue(orphanViews.isEmpty());\n+                assertLegitChildViews(expectedLegitChildViewsListForParent2, legitChildViews);\n+\n+                // Drop the legitimate level 1 view that was on top of parent1", "originalCommit": "d698b728b00ce6b3d6f461944c53727fac795fbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk1MTY5NA==", "url": "https://github.com/apache/phoenix/pull/903#discussion_r507951694", "bodyText": "Sure, I can add more global views.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-19T17:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQzMDExNA=="}], "type": "inlineReview"}, {"oid": "2609451c7e5852def57eaea3fb2ccf03eeb31e6e", "url": "https://github.com/apache/phoenix/commit/2609451c7e5852def57eaea3fb2ccf03eeb31e6e", "message": "PHOENIX-6142: Make DDL operations resilient to orphan parent->child linking rows in SYSTEM.CHILD_LINK", "committedDate": "2020-10-19T22:35:00Z", "type": "forcePushed"}, {"oid": "12221484bfb535128a729e7a99b5e742e62a98ed", "url": "https://github.com/apache/phoenix/commit/12221484bfb535128a729e7a99b5e742e62a98ed", "message": "PHOENIX-6142: Make DDL operations resilient to orphan parent->child linking rows in SYSTEM.CHILD_LINK", "committedDate": "2020-10-20T17:54:42Z", "type": "commit"}, {"oid": "12221484bfb535128a729e7a99b5e742e62a98ed", "url": "https://github.com/apache/phoenix/commit/12221484bfb535128a729e7a99b5e742e62a98ed", "message": "PHOENIX-6142: Make DDL operations resilient to orphan parent->child linking rows in SYSTEM.CHILD_LINK", "committedDate": "2020-10-20T17:54:42Z", "type": "forcePushed"}]}