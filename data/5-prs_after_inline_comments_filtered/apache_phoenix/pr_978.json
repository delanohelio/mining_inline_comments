{"pr_number": 978, "pr_title": "[PHOENIX-6213] Extend Cell Tags to Delete object to store source of operation.", "pr_createdAt": "2020-11-20T01:04:42Z", "pr_url": "https://github.com/apache/phoenix/pull/978", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyMjgyMw==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528022823", "bodyText": "See RawCell, which unlike the Cell tag methods, isn't deprecated, and is IA LimitedPrivate.COPROC. You'll probably have to downcast.", "author": "gjacoby126", "createdAt": "2020-11-20T23:27:18Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -991,6 +999,46 @@ public void preBatchMutateWithExceptions(ObserverContext<RegionCoprocessorEnviro\n         }\n     }\n \n+    /*\n+        Set Cell Tags to delete markers with source of operation attribute.\n+     */\n+    private void setDeleteAttributes(MiniBatchOperationInProgress<Mutation> miniBatchOp)\n+            throws IOException {\n+        for (int i = 0; i < miniBatchOp.size(); i++) {\n+            Mutation m = miniBatchOp.getOperation(i);\n+            if (!(m instanceof  Delete)) {\n+                // Ignore if it is not Delete type.\n+                continue;\n+            }\n+            byte[] sourceOpAttr = m.getAttribute(QueryServices.SOURCE_OPERATION_ATTRIB);\n+            if (sourceOpAttr == null) {\n+                continue;\n+            }\n+\n+            // TODO: Which tag implementation to use ? ArrayBackedTag or ByteBufferTag ?\n+            Tag sourceOpTag = new ArrayBackedTag(PhoenixTagType.SOURCE_OPERATION_TAG_TYPE, sourceOpAttr);\n+            List<Cell> updatedCells = new ArrayList<>();\n+            for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {\n+                Cell cell = cellScanner.current();\n+                // TODO: Cell#getTagsArray, Cell#getTagsOffset, Cell#getTagsLength are deprecated.", "originalCommit": "fee9340821e47f2207399991359d7afa029b0fd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyMzM4MA==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528023380", "bodyText": "I believe ArrayBackedTag is for Cells built on the heap, and ByteBufferTag is for Cells built off-heap. You're building Cells on-heap, so I assume you'd want ArrayBackedTag. That said, we need to be very careful we're not accidentally leaking memory here by swapping the provided Cells with new ones -- I'm not clear on when the underlying HBase is using on-heap vs off-heap Cells. Needs more research", "author": "gjacoby126", "createdAt": "2020-11-20T23:29:36Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -991,6 +999,46 @@ public void preBatchMutateWithExceptions(ObserverContext<RegionCoprocessorEnviro\n         }\n     }\n \n+    /*\n+        Set Cell Tags to delete markers with source of operation attribute.\n+     */\n+    private void setDeleteAttributes(MiniBatchOperationInProgress<Mutation> miniBatchOp)\n+            throws IOException {\n+        for (int i = 0; i < miniBatchOp.size(); i++) {\n+            Mutation m = miniBatchOp.getOperation(i);\n+            if (!(m instanceof  Delete)) {\n+                // Ignore if it is not Delete type.\n+                continue;\n+            }\n+            byte[] sourceOpAttr = m.getAttribute(QueryServices.SOURCE_OPERATION_ATTRIB);\n+            if (sourceOpAttr == null) {\n+                continue;\n+            }\n+\n+            // TODO: Which tag implementation to use ? ArrayBackedTag or ByteBufferTag ?", "originalCommit": "fee9340821e47f2207399991359d7afa029b0fd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyMzg0Mw==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528023843", "bodyText": "See RawCellBuilder, which is IA LimitedPrivate.COPROC.", "author": "gjacoby126", "createdAt": "2020-11-20T23:30:59Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -991,6 +999,46 @@ public void preBatchMutateWithExceptions(ObserverContext<RegionCoprocessorEnviro\n         }\n     }\n \n+    /*\n+        Set Cell Tags to delete markers with source of operation attribute.\n+     */\n+    private void setDeleteAttributes(MiniBatchOperationInProgress<Mutation> miniBatchOp)\n+            throws IOException {\n+        for (int i = 0; i < miniBatchOp.size(); i++) {\n+            Mutation m = miniBatchOp.getOperation(i);\n+            if (!(m instanceof  Delete)) {\n+                // Ignore if it is not Delete type.\n+                continue;\n+            }\n+            byte[] sourceOpAttr = m.getAttribute(QueryServices.SOURCE_OPERATION_ATTRIB);\n+            if (sourceOpAttr == null) {\n+                continue;\n+            }\n+\n+            // TODO: Which tag implementation to use ? ArrayBackedTag or ByteBufferTag ?\n+            Tag sourceOpTag = new ArrayBackedTag(PhoenixTagType.SOURCE_OPERATION_TAG_TYPE, sourceOpAttr);\n+            List<Cell> updatedCells = new ArrayList<>();\n+            for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {\n+                Cell cell = cellScanner.current();\n+                // TODO: Cell#getTagsArray, Cell#getTagsOffset, Cell#getTagsLength are deprecated.\n+                //TODO: Need to replace them with new methods.\n+                List<Tag> tags = TagUtil.asList(cell.getTagsArray(), cell.getTagsOffset(),\n+                        cell.getTagsLength());\n+                tags.add(sourceOpTag);\n+                // TODO: PrivateCellUtil's IA is Private. Need to change it to LP with\n+                // TODO: IA.COPROC.", "originalCommit": "fee9340821e47f2207399991359d7afa029b0fd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDUzMQ==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528024531", "bodyText": "PrivateCellUtil is IA.Private -- need to use one of the IA.LimitedPrivate or better classes such as RawCell", "author": "gjacoby126", "createdAt": "2020-11-20T23:33:31Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +960,164 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ClientSelectDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ServerSelectDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, \"MultiRowDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planName\n+     */\n+    private void verifyDeletePlan(String delete, String planName, Properties props)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+            SQLParser parser = new SQLParser(delete);\n+            DeleteStatement deleteStmt = (DeleteStatement) parser.parseStatement();\n+            DeleteCompiler compiler = new DeleteCompiler(stmt, null);\n+            MutationPlan plan = compiler.compile(deleteStmt);\n+            assertTrue(plan.getClass().getName().contains(planName));\n+        }\n+    }\n+    private void createAndUpsertTable(String tableName, String indexName, Properties props)\n+            throws SQLException {\n+        String ddl = \"CREATE TABLE \" + tableName +\n+                \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\";\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                statement.execute(ddl);\n+                if (indexName != null) {\n+                    String indexDdl1 = \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"(v1,v2)\";\n+                    statement.execute(indexDdl1);\n+                }\n+            }\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (1, 'foo', 'foo1')\");\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (2, 'bar', 'bar1')\");\n+            conn.commit();\n+        }\n+    }\n+\n+    private void executeDelete(String delete, Properties props, int deleteRowCount)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                int rs = statement.executeUpdate(delete);\n+                assertEquals( deleteRowCount, rs);\n+            }\n+        }\n+    }\n \n+    /*\n+        Verify whether we have tags present for base table and not present for\n+        index tables.\n+     */\n+    private void checkTagPresentInDeleteMarker(String tableName, String startRowKey,\n+            boolean tagPresent, String tagValue) throws IOException {\n+        List<Cell> values = new ArrayList<>();\n+        TableName table = TableName.valueOf(tableName);\n+        // Scan table with specified startRowKey\n+        for (HRegion region : getUtility().getHBaseCluster().getRegions(table)) {\n+            values.clear();\n+            Scan scan = new Scan();\n+            // Make sure to set rawScan to true so that we will get Delete Markers.\n+            scan.setRaw(true);\n+            scan.withStartRow(Bytes.toBytes(startRowKey));\n+            RegionScanner scanner = region.getScanner(scan);\n+            scanner.next(values);\n+            if (!values.isEmpty()) {\n+                break;\n+            }\n+        }\n+        assertTrue(\"Values shouldn't be empty\", !values.isEmpty());\n+        Cell first = values.get(0);\n+        assertTrue(\"First cell should be delete marker \",\n+                PrivateCellUtil.isDelete(first.getType().getCode()));\n+        List<Tag> tags = PrivateCellUtil.getTags(first);\n+        if (tagPresent) {\n+            assertEquals(1, tags.size());\n+            Optional<Tag> optional =\n+                    PrivateCellUtil.getTag(first, PhoenixTagType.SOURCE_OPERATION_TAG_TYPE);", "originalCommit": "fee9340821e47f2207399991359d7afa029b0fd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDc4NA==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528024784", "bodyText": "rather than hardcode the string, can use the class name", "author": "gjacoby126", "createdAt": "2020-11-20T23:34:23Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +960,164 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ClientSelectDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ServerSelectDeleteMutationPlan\", props);", "originalCommit": "fee9340821e47f2207399991359d7afa029b0fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg4ODcxOA==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528888718", "bodyText": "DeleteCompiler#ClientSelectDeleteMutationPlan and other mutation plan classes are private nested classes and are not visible to test classes. Instead of making them public thought to hardcode the string. Let me know if you want me to make them public. Thank you !", "author": "shahrs87", "createdAt": "2020-11-23T17:49:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA0NTAyNQ==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r529045025", "bodyText": "Would putting them at package level work?", "author": "gjacoby126", "createdAt": "2020-11-23T22:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA0NzAxNw==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r529047017", "bodyText": "(If package level wouldn't, I think I'd rather they be public than have the strings hard-coded, so that the dependency is explicit)", "author": "gjacoby126", "createdAt": "2020-11-23T22:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDg3MA==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528024870", "bodyText": "Rather than hardcode the string, can use the classname", "author": "gjacoby126", "createdAt": "2020-11-20T23:34:39Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +960,164 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ClientSelectDeleteMutationPlan\", props);", "originalCommit": "fee9340821e47f2207399991359d7afa029b0fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg4ODYxNw==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528888617", "bodyText": "DeleteCompiler#ClientSelectDeleteMutationPlan and other mutation plan classes are private nested classes and are not visible to test classes. Instead of making them public thought to hardcode the string. Let me know if you want me to make them public. Thank you !", "author": "shahrs87", "createdAt": "2020-11-23T17:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNTQ4NA==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528025484", "bodyText": "Can use CellUtil.isDelete, which is IA.Public", "author": "gjacoby126", "createdAt": "2020-11-20T23:37:00Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +960,164 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ClientSelectDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ServerSelectDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, \"MultiRowDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planName\n+     */\n+    private void verifyDeletePlan(String delete, String planName, Properties props)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+            SQLParser parser = new SQLParser(delete);\n+            DeleteStatement deleteStmt = (DeleteStatement) parser.parseStatement();\n+            DeleteCompiler compiler = new DeleteCompiler(stmt, null);\n+            MutationPlan plan = compiler.compile(deleteStmt);\n+            assertTrue(plan.getClass().getName().contains(planName));\n+        }\n+    }\n+    private void createAndUpsertTable(String tableName, String indexName, Properties props)\n+            throws SQLException {\n+        String ddl = \"CREATE TABLE \" + tableName +\n+                \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\";\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                statement.execute(ddl);\n+                if (indexName != null) {\n+                    String indexDdl1 = \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"(v1,v2)\";\n+                    statement.execute(indexDdl1);\n+                }\n+            }\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (1, 'foo', 'foo1')\");\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (2, 'bar', 'bar1')\");\n+            conn.commit();\n+        }\n+    }\n+\n+    private void executeDelete(String delete, Properties props, int deleteRowCount)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                int rs = statement.executeUpdate(delete);\n+                assertEquals( deleteRowCount, rs);\n+            }\n+        }\n+    }\n \n+    /*\n+        Verify whether we have tags present for base table and not present for\n+        index tables.\n+     */\n+    private void checkTagPresentInDeleteMarker(String tableName, String startRowKey,\n+            boolean tagPresent, String tagValue) throws IOException {\n+        List<Cell> values = new ArrayList<>();\n+        TableName table = TableName.valueOf(tableName);\n+        // Scan table with specified startRowKey\n+        for (HRegion region : getUtility().getHBaseCluster().getRegions(table)) {\n+            values.clear();\n+            Scan scan = new Scan();\n+            // Make sure to set rawScan to true so that we will get Delete Markers.\n+            scan.setRaw(true);\n+            scan.withStartRow(Bytes.toBytes(startRowKey));\n+            RegionScanner scanner = region.getScanner(scan);\n+            scanner.next(values);\n+            if (!values.isEmpty()) {\n+                break;\n+            }\n+        }\n+        assertTrue(\"Values shouldn't be empty\", !values.isEmpty());\n+        Cell first = values.get(0);\n+        assertTrue(\"First cell should be delete marker \",\n+                PrivateCellUtil.isDelete(first.getType().getCode()));", "originalCommit": "fee9340821e47f2207399991359d7afa029b0fd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNTY4MA==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531605680", "bodyText": "nit: both these statements can be included with above try (Statement statement = conn.createStatement())", "author": "virajjasani", "createdAt": "2020-11-27T13:35:14Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +961,163 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ServerSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.MultiRowDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planClass\n+     */\n+    private void verifyDeletePlan(String delete, Class planClass, Properties props)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+            SQLParser parser = new SQLParser(delete);\n+            DeleteStatement deleteStmt = (DeleteStatement) parser.parseStatement();\n+            DeleteCompiler compiler = new DeleteCompiler(stmt, null);\n+            MutationPlan plan = compiler.compile(deleteStmt);\n+            assertEquals(plan.getClass(), planClass);\n+        }\n+    }\n+    private void createAndUpsertTable(String tableName, String indexName, Properties props)\n+            throws SQLException {\n+        String ddl = \"CREATE TABLE \" + tableName +\n+                \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\";\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                statement.execute(ddl);\n+                if (indexName != null) {\n+                    String indexDdl1 = \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"(v1,v2)\";\n+                    statement.execute(indexDdl1);\n+                }\n+            }\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (1, 'foo', 'foo1')\");\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (2, 'bar', 'bar1')\");", "originalCommit": "36c8afe4dcaad08e866193f7d6ab917b87626705", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNjk1MQ==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531606951", "bodyText": "nit: Class<? extends MutationPlan> planClass ?", "author": "virajjasani", "createdAt": "2020-11-27T13:37:46Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +961,163 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ServerSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.MultiRowDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planClass\n+     */\n+    private void verifyDeletePlan(String delete, Class planClass, Properties props)", "originalCommit": "36c8afe4dcaad08e866193f7d6ab917b87626705", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYxMTAzNg==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531611036", "bodyText": "nit: cleaning up entries might not be needed. If values has any record, we will be out of this loop.", "author": "virajjasani", "createdAt": "2020-11-27T13:45:44Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +961,163 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ServerSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.MultiRowDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planClass\n+     */\n+    private void verifyDeletePlan(String delete, Class planClass, Properties props)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+            SQLParser parser = new SQLParser(delete);\n+            DeleteStatement deleteStmt = (DeleteStatement) parser.parseStatement();\n+            DeleteCompiler compiler = new DeleteCompiler(stmt, null);\n+            MutationPlan plan = compiler.compile(deleteStmt);\n+            assertEquals(plan.getClass(), planClass);\n+        }\n+    }\n+    private void createAndUpsertTable(String tableName, String indexName, Properties props)\n+            throws SQLException {\n+        String ddl = \"CREATE TABLE \" + tableName +\n+                \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\";\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                statement.execute(ddl);\n+                if (indexName != null) {\n+                    String indexDdl1 = \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"(v1,v2)\";\n+                    statement.execute(indexDdl1);\n+                }\n+            }\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (1, 'foo', 'foo1')\");\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (2, 'bar', 'bar1')\");\n+            conn.commit();\n+        }\n+    }\n+\n+    private void executeDelete(String delete, Properties props, int deleteRowCount)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                int rs = statement.executeUpdate(delete);\n+                assertEquals( deleteRowCount, rs);\n+            }\n+        }\n+    }\n \n+    /*\n+        Verify whether we have tags present for base table and not present for\n+        index tables.\n+     */\n+    private void checkTagPresentInDeleteMarker(String tableName, String startRowKey,\n+            boolean tagPresent, String tagValue) throws IOException {\n+        List<Cell> values = new ArrayList<>();\n+        TableName table = TableName.valueOf(tableName);\n+        // Scan table with specified startRowKey\n+        for (HRegion region : getUtility().getHBaseCluster().getRegions(table)) {\n+            values.clear();", "originalCommit": "36c8afe4dcaad08e866193f7d6ab917b87626705", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYxMjEzNQ==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531612135", "bodyText": "nit: simplify to assertFalse(\"Values shouldn't be empty\", values.isEmpty()); ?", "author": "virajjasani", "createdAt": "2020-11-27T13:47:56Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +961,163 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ServerSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.MultiRowDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planClass\n+     */\n+    private void verifyDeletePlan(String delete, Class planClass, Properties props)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+            SQLParser parser = new SQLParser(delete);\n+            DeleteStatement deleteStmt = (DeleteStatement) parser.parseStatement();\n+            DeleteCompiler compiler = new DeleteCompiler(stmt, null);\n+            MutationPlan plan = compiler.compile(deleteStmt);\n+            assertEquals(plan.getClass(), planClass);\n+        }\n+    }\n+    private void createAndUpsertTable(String tableName, String indexName, Properties props)\n+            throws SQLException {\n+        String ddl = \"CREATE TABLE \" + tableName +\n+                \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\";\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                statement.execute(ddl);\n+                if (indexName != null) {\n+                    String indexDdl1 = \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"(v1,v2)\";\n+                    statement.execute(indexDdl1);\n+                }\n+            }\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (1, 'foo', 'foo1')\");\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (2, 'bar', 'bar1')\");\n+            conn.commit();\n+        }\n+    }\n+\n+    private void executeDelete(String delete, Properties props, int deleteRowCount)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                int rs = statement.executeUpdate(delete);\n+                assertEquals( deleteRowCount, rs);\n+            }\n+        }\n+    }\n \n+    /*\n+        Verify whether we have tags present for base table and not present for\n+        index tables.\n+     */\n+    private void checkTagPresentInDeleteMarker(String tableName, String startRowKey,\n+            boolean tagPresent, String tagValue) throws IOException {\n+        List<Cell> values = new ArrayList<>();\n+        TableName table = TableName.valueOf(tableName);\n+        // Scan table with specified startRowKey\n+        for (HRegion region : getUtility().getHBaseCluster().getRegions(table)) {\n+            values.clear();\n+            Scan scan = new Scan();\n+            // Make sure to set rawScan to true so that we will get Delete Markers.\n+            scan.setRaw(true);\n+            scan.withStartRow(Bytes.toBytes(startRowKey));\n+            RegionScanner scanner = region.getScanner(scan);\n+            scanner.next(values);\n+            if (!values.isEmpty()) {\n+                break;\n+            }\n+        }\n+        assertTrue(\"Values shouldn't be empty\", !values.isEmpty());", "originalCommit": "36c8afe4dcaad08e866193f7d6ab917b87626705", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNTA3MA==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531625070", "bodyText": "ServerSelectDeleteMutationPlan is because DELETE query has no WHERE clause and we have index on base table which will be part of queryPlan?\n        boolean runOnServer = isAutoCommit && !hasPreOrPostProcessing && !table.isTransactional() && !hasClientSideIndexes && allowServerMutations;\n\n        runOnServer &= queryPlans.get(0).getTableRef().getTable().getType() != PTableType.INDEX;\n\n\nIs this the correct reference?", "author": "virajjasani", "createdAt": "2020-11-27T14:13:37Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +961,163 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ServerSelectDeleteMutationPlan.class, props);", "originalCommit": "36c8afe4dcaad08e866193f7d6ab917b87626705", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgyNDg1Mw==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531824853", "bodyText": "@virajjasani  That's correct. This is my understanding also.  Cc @gjacoby126", "author": "shahrs87", "createdAt": "2020-11-28T02:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNTA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY2MTU0MQ==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531661541", "bodyText": "For now I think it's fine to perform this whole operation here, but eventually, do you think performing this entire cleanup + adding new delete markers could be done at HBase side using Mutation API? Not very strong point but keeping as much cell mutations to hbase side as possible might be better?\nOr maybe keeping this whole batch operation setDeleteAttributes() at hbase side as Public/LP API?\nWDYT @shahrs87 @gjacoby126 ? Apologies if this was already discussed, I know there have been few nice long discussions overall.", "author": "virajjasani", "createdAt": "2020-11-27T15:27:21Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -991,6 +999,47 @@ public void preBatchMutateWithExceptions(ObserverContext<RegionCoprocessorEnviro\n         }\n     }\n \n+    /**\n+     * Set Cell Tags to delete markers with source of operation attribute.\n+     * @param miniBatchOp\n+     * @throws IOException\n+     */\n+    private void setDeleteAttributes(MiniBatchOperationInProgress<Mutation> miniBatchOp)\n+            throws IOException {\n+        for (int i = 0; i < miniBatchOp.size(); i++) {\n+            Mutation m = miniBatchOp.getOperation(i);\n+            if (!(m instanceof  Delete)) {\n+                // Ignore if it is not Delete type.\n+                continue;\n+            }\n+            byte[] sourceOpAttr = m.getAttribute(QueryServices.SOURCE_OPERATION_ATTRIB);\n+            if (sourceOpAttr == null) {\n+                continue;\n+            }\n+\n+            Tag sourceOpTag = new ArrayBackedTag(PhoenixTagType.SOURCE_OPERATION_TAG_TYPE,\n+                    sourceOpAttr);\n+            List<Cell> updatedCells = new ArrayList<>();\n+            for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {\n+                Cell cell = cellScanner.current();\n+                // TODO: Cell#getTagsArray, Cell#getTagsOffset, Cell#getTagsLength are deprecated.\n+                //TODO: Need to replace them with new methods.\n+                List<Tag> tags = PrivateCellUtil.getTags(cell);\n+                tags.add(sourceOpTag);\n+                // TODO: PrivateCellUtil's IA is Private. Need to change it to LP with\n+                // TODO: IA.COPROC.\n+                Cell updatedCell = PrivateCellUtil.createCell(cell, tags);\n+                updatedCells.add(updatedCell);\n+            }\n+            m.getFamilyCellMap().clear();\n+            // Clear and add new Cells to the Mutation.\n+            for (Cell cell : updatedCells) {\n+                Delete d = (Delete) m;\n+                d.addDeleteMarker(cell);\n+            }", "originalCommit": "36c8afe4dcaad08e866193f7d6ab917b87626705", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MTgxNw==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r532781817", "bodyText": "but eventually, do you think performing this entire cleanup + adding new delete markers could be done at HBase side using Mutation API?\n\n@virajjasani  This jira https://issues.apache.org/jira/browse/PHOENIX-6213 was initially a hbase jira. Also refer to this thread here: https://lists.apache.org/thread.html/r68bd14516383d3f624fc0185fff21ab6044f548c1f31e751e4130915%40%3Cdev.hbase.apache.org%3E where hbase developers advised to add cell tags in phoenix coproc. :)", "author": "shahrs87", "createdAt": "2020-11-30T17:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY2MTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4Njg0Mw==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r532786843", "bodyText": "Sounds good, and now with new Builder as IA.LP, we are good to use LP APIs until upgrading to 2.5.x/1.7.x (hopefully) and till then we can use ArrayBackedTag directly.", "author": "virajjasani", "createdAt": "2020-11-30T17:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY2MTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4Mjg4Nw==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r532782887", "bodyText": "@gjacoby126  Could you please advise whether should we add the attribute here ? This codepath is used when we drop the column which will in turn generate Delete Marker.", "author": "shahrs87", "createdAt": "2020-11-30T17:45:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -479,6 +486,8 @@ void deleteCForQ(Tuple result, List<Cell> results, UngroupedAggregateRegionObser\n             delete.addColumns(deleteCF,  deleteCQ, ts);\n             // force tephra to ignore this deletes\n             delete.setAttribute(PhoenixTransactionContext.TX_ROLLBACK_ATTRIBUTE_KEY, new byte[0]);\n+            // TODO: should we set the source of operation attribute here.\n+            // TODO: This will be true if we drop column or drop table", "originalCommit": "c4297874671993afe355587259e30a962a52c4f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNTk5Mg==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r534405992", "bodyText": "Good question, @shahrs87 . I think we should set the attribute there.", "author": "gjacoby126", "createdAt": "2020-12-02T18:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4Mjg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNzcxNQ==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r534407715", "bodyText": "Can update the comment with a TODO pointing to the HBase JIRA introducing the new LP(COPROC) API you made.", "author": "gjacoby126", "createdAt": "2020-12-02T18:57:42Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -991,6 +1000,49 @@ public void preBatchMutateWithExceptions(ObserverContext<RegionCoprocessorEnviro\n         }\n     }\n \n+    /**\n+     * Set Cell Tags to delete markers with source of operation attribute.\n+     * @param miniBatchOp\n+     * @throws IOException\n+     */\n+    private void setDeleteAttributes(MiniBatchOperationInProgress<Mutation> miniBatchOp)\n+            throws IOException {\n+        for (int i = 0; i < miniBatchOp.size(); i++) {\n+            Mutation m = miniBatchOp.getOperation(i);\n+            if (!(m instanceof  Delete)) {\n+                // Ignore if it is not Delete type.\n+                continue;\n+            }\n+            byte[] sourceOpAttr = m.getAttribute(QueryServices.SOURCE_OPERATION_ATTRIB);\n+            if (sourceOpAttr == null) {\n+                continue;\n+            }\n+\n+            Tag sourceOpTag = new ArrayBackedTag(PhoenixTagType.SOURCE_OPERATION_TAG_TYPE,\n+                    sourceOpAttr);\n+            List<Cell> updatedCells = new ArrayList<>();\n+            for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {\n+                Cell cell = cellScanner.current();\n+                RawCell rawCell = (RawCell)cell;\n+                List<Tag> tags = new ArrayList<>();\n+                Iterator<Tag> tagsIterator = rawCell.getTags();\n+                while (tagsIterator.hasNext()) {\n+                    tags.add(tagsIterator.next());\n+                }\n+                tags.add(sourceOpTag);\n+                // TODO: PrivateCellUtil's IA is Private. Need to change it to LP with IA.COPROC.", "originalCommit": "c4297874671993afe355587259e30a962a52c4f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMDc3MA==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r537120770", "bodyText": "Done in latest revision.", "author": "shahrs87", "createdAt": "2020-12-06T20:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNzcxNQ=="}], "type": "inlineReview"}, {"oid": "4da62b62fcff6ffc2c1008b3e006cd0c41daecf8", "url": "https://github.com/apache/phoenix/commit/4da62b62fcff6ffc2c1008b3e006cd0c41daecf8", "message": "[PHOENIX-6213] Extend Cell Tags to Delete object to store source of operation.", "committedDate": "2020-12-06T20:41:48Z", "type": "commit"}, {"oid": "4da62b62fcff6ffc2c1008b3e006cd0c41daecf8", "url": "https://github.com/apache/phoenix/commit/4da62b62fcff6ffc2c1008b3e006cd0c41daecf8", "message": "[PHOENIX-6213] Extend Cell Tags to Delete object to store source of operation.", "committedDate": "2020-12-06T20:41:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMDY3MQ==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r537120671", "bodyText": "Good question, @shahrs87 . I think we should set the attribute there.\n\n@gjacoby126  I started doing changes for setting source operation attribute here. When we drop a column, we create delete markers with delete type \"DELETE_COLUMN\" for the base table and also we delete metadata for that column in SYSCAT table. Is it reasonable to have the feature first for just deleting rows from data table and then we can extend it for drop columns use case. Please advise. Thank you !", "author": "shahrs87", "createdAt": "2020-12-06T20:49:58Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -479,6 +486,10 @@ void deleteCForQ(Tuple result, List<Cell> results, UngroupedAggregateRegionObser\n             delete.addColumns(deleteCF,  deleteCQ, ts);\n             // force tephra to ignore this deletes\n             delete.setAttribute(PhoenixTransactionContext.TX_ROLLBACK_ATTRIBUTE_KEY, new byte[0]);\n+            // TODO: We need to set SOURCE_OPERATION_ATTRIB here also. The control will come here if", "originalCommit": "4da62b62fcff6ffc2c1008b3e006cd0c41daecf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyMDI4MA==", "url": "https://github.com/apache/phoenix/pull/978#discussion_r537820280", "bodyText": "The drop column case can be a separate JIRA.", "author": "gjacoby126", "createdAt": "2020-12-07T20:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMDY3MQ=="}], "type": "inlineReview"}, {"oid": "35a1a67324de60fa569f3f1c3d128db1b421b55e", "url": "https://github.com/apache/phoenix/commit/35a1a67324de60fa569f3f1c3d128db1b421b55e", "message": "Merge branch 'master' of https://github.com/apache/phoenix into phoenix-6213", "committedDate": "2020-12-07T17:29:43Z", "type": "commit"}]}