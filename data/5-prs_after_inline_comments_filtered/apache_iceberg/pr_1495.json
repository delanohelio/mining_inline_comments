{"pr_number": 1495, "pr_title": "HiveMetaHook implementation to enable CREATE TABLE and DROP TABLE from Hive queries", "pr_createdAt": "2020-09-23T11:59:23Z", "pr_url": "https://github.com/apache/iceberg/pull/1495", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r493979620", "bodyText": "Is this telling Iceberg to overwrite the Hive table? I think this property should probably not be persisted to Hive in table properties.", "author": "rdblue", "createdAt": "2020-09-24T00:58:56Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -139,6 +140,8 @@ protected void doRefresh() {\n \n   @Override\n   protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    boolean updateTable = base != null || metadata.propertyAsBoolean(TABLE_FROM_HIVE, false);", "originalCommit": "dc7c1c61197c93bb26215fd945f8e7c83749bd29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4MzkzOQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494283939", "bodyText": "If we do not want to use properties for signaling this behavior (looking at it again with fresh eyes seems like a hack), then we have to modify:\n\nadd method TableBuilder.updateExisting\nadd method TableOperations.commit with new parameter signaling update\nadd method HiveTableOperations/HadoopTableOperations to signal the update\n\nOr we have to resort to parameters sending/hacking through some level and removing the parameter from the lower levels.\nI do not like any of these solutions, so happy to go with any other viable solution...", "author": "pvary", "createdAt": "2020-09-24T12:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3MTQ4Mg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494571482", "bodyText": "What is the purpose of this? Is it because the table already exists in the Hive MetaStore but there is no Iceberg metadata?", "author": "rdblue", "createdAt": "2020-09-24T19:49:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NjA4Ng==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494586086", "bodyText": "Yes, you are right.\nWith the HiveMetaHooks we have the possibility to do some preCreate and commitCreate stuff, but the table should be created by the HMS between these phases. I have even thought about dropping the HMS created table in the commitCreate method but that seems like a serious waste of effort, and also I do not have a HMS client at hand.", "author": "pvary", "createdAt": "2020-09-24T20:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwMzgyNw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494603827", "bodyText": "Okay, thanks for the context.\nI think we may be able to catch this case within HiveTableOperations. When creating a table, we will create a new TableOperations and that will attempt to load the current metadata. Normally, that will fail and because the currentMetadataLocation was null, the failure is caught and metadata is set to null because the table doesn't exist. If the table exists but doesn't have a metadata location, then we will get a table from Hive, but the location property won't exist. We can detect that the location property doesn't exist and set a flag, updateToCreate.\nThat avoids the need for a table property because we detect the state of the Hive MetaStore, and it doesn't incur extra thrift calls.", "author": "rdblue", "createdAt": "2020-09-24T20:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkxNTQ3Ng==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494915476", "bodyText": "This would be a slight modification to the API.\n\nBefore the change we throw a NoSuchIcebergTableException if we tried to load a Hive table which did not have the correct table type and the metadata location set.\nAfter the change we will try to update the table with the correct parameters\n\nWould this be acceptable change in the API behavior?", "author": "pvary", "createdAt": "2020-09-25T11:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxNjA5NQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r495216095", "bodyText": "Could we avoid the behavior change by adding a property in the pre-create hook? If we signal that Hive is creating the table, then this could set the flag to update internally, do the update, and drop the flag from Hive metadata. It still avoids additional calls to Hive.", "author": "rdblue", "createdAt": "2020-09-25T20:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExOTk5OQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r496119999", "bodyText": "This flag is the HiveTableOperations#TABLE_FROM_HIVE (\"iceberg.table.from.hive\").\nWe do not store this to the HMS, but we store this to the Iceberg table since in the HiveTableOperations.doCommit(base, metadata) the metadata is Immutable.", "author": "pvary", "createdAt": "2020-09-28T17:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxMTg3Mg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r496911872", "bodyText": "I agree that this should not change the TableMetadata that was passed in. If we pass the flag in TableMetadata, then it would be stored in the Iceberg metadata.\nBut why can't we add this flag to the HMS table that is passed to the pre-commit phase in the Hive hooks? If we add it to the Hive table that gets created and should be replaced, then there is no need to pass it in Iceberg metadata. And we can remove it when we create the Iceberg table underneath and set the metadata location.", "author": "rdblue", "createdAt": "2020-09-29T17:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNzExNQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r496917115", "bodyText": "Oh... now I get it.\nSeems like a good idea, I will check it!", "author": "pvary", "createdAt": "2020-09-29T17:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxODg0MA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r496918840", "bodyText": "Actually, I see that we already set the table type property in the pre-commit hook. We could use that to detect this case and avoid throwing NoSuchIcebergTableException, then use update.", "author": "rdblue", "createdAt": "2020-09-29T17:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyOTE4OA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497029188", "bodyText": "Uploaded the change.\nWe need to call HMSClient.getTable every time in HiveTableOperations.doCommit, so we can decide if this is a new table or already created by the Hook.\nThis is an extra call in case the new table creation is started from Spark. This might be acceptable.", "author": "pvary", "createdAt": "2020-09-29T20:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MDMyMw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r493980323", "bodyText": "It would be helpful to have some context for this. Why did this change? Could you add some comments to make it more clear what's happening in the code?", "author": "rdblue", "createdAt": "2020-09-24T01:01:39Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergSerDe.java", "diffHunk": "@@ -27,21 +27,32 @@\n import org.apache.hadoop.hive.serde2.SerDeStats;\n import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n import org.apache.hadoop.io.Writable;\n-import org.apache.iceberg.Table;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n import org.apache.iceberg.mr.Catalogs;\n+import org.apache.iceberg.mr.InputFormatConfig;\n import org.apache.iceberg.mr.hive.serde.objectinspector.IcebergObjectInspector;\n import org.apache.iceberg.mr.mapred.Container;\n \n public class HiveIcebergSerDe extends AbstractSerDe {\n-\n+  private Schema schema;\n   private ObjectInspector inspector;\n \n   @Override\n   public void initialize(@Nullable Configuration configuration, Properties serDeProperties) throws SerDeException {\n-    Table table = Catalogs.loadTable(configuration, serDeProperties);\n-\n     try {\n-      this.inspector = IcebergObjectInspector.create(table.schema());\n+      String schemaString = (String) serDeProperties.get(InputFormatConfig.TABLE_SCHEMA);\n+      if (schemaString != null) {\n+        schema = SchemaParser.fromJson(schemaString);\n+      } else {\n+        try {\n+          schema = Catalogs.loadTable(configuration, serDeProperties).schema();\n+        } catch (NoSuchTableException nte) {\n+          throw new SerDeException(\"Please provide an existing table or a valid schema\", nte);\n+        }\n+      }\n+      inspector = IcebergObjectInspector.create(schema);", "originalCommit": "dc7c1c61197c93bb26215fd945f8e7c83749bd29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA4ODg2Ng==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494088866", "bodyText": "Added a comment:\nHiveIcebergSerDe.initialize is called multiple places in Hive code:\n\nWhen we are trying to create a table - HiveDDL data is stored at the serDeProperties, but no Iceberg table is created yet.\nWhen we are compiling the Hive query on HiveServer2 side - We only have table information (location/name), and we have to read the schema using the table data. This is called multiple times so there is room for optimizing here.\nWhen we are executing the Hive query in the execution engine - We do not want to load the table data on every executor, but serDeProperties are populated by HiveIcebergStorageHandler.configureInputJobProperties() and the resulting properties are serialized and distributed to the executors", "author": "pvary", "createdAt": "2020-09-24T07:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MDMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MTg2OQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r493981869", "bodyText": "When setting instance fields, we prefix the field with this. to make it obvious it isn't a local variable.", "author": "rdblue", "createdAt": "2020-09-24T01:08:16Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergMetaHook.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.HiveMetaHook;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.PartitionSpecParser;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hive.HiveTableOperations;\n+import org.apache.iceberg.mr.Catalogs;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class HiveIcebergMetaHook implements HiveMetaHook {\n+  private static final Logger LOG = LoggerFactory.getLogger(HiveIcebergMetaHook.class);\n+  private static final Set<String> PARAMETERS_TO_REMOVE = Stream\n+      .of(InputFormatConfig.TABLE_SCHEMA, InputFormatConfig.PARTITION_SPEC, Catalogs.LOCATION, Catalogs.NAME)\n+      .collect(Collectors.toCollection(HashSet::new));\n+  private static final Set<String> PROPERTIES_TO_REMOVE = Stream\n+      .of(InputFormatConfig.HIVE_DELETE_BACKING_TABLE, \"storage_handler\", \"EXTERNAL\")\n+      .collect(Collectors.toCollection(HashSet::new));\n+\n+  private final Configuration conf;\n+  private Table icebergTable = null;\n+  private Properties catalogProperties;\n+  private boolean deleteIcebergTable;\n+\n+  public HiveIcebergMetaHook(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void preCreateTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    catalogProperties = getCatalogProperties(hmsTable);", "originalCommit": "dc7c1c61197c93bb26215fd945f8e7c83749bd29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA4OTYxNg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494089616", "bodyText": "You have already mentioned once. Will not forget next time. Sorry.\nDone", "author": "pvary", "createdAt": "2020-09-24T07:15:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MTg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjAyMg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r493982022", "bodyText": "Isn't this already logged in the catalog implementation?", "author": "rdblue", "createdAt": "2020-09-24T01:08:54Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergMetaHook.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.HiveMetaHook;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.PartitionSpecParser;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hive.HiveTableOperations;\n+import org.apache.iceberg.mr.Catalogs;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class HiveIcebergMetaHook implements HiveMetaHook {\n+  private static final Logger LOG = LoggerFactory.getLogger(HiveIcebergMetaHook.class);\n+  private static final Set<String> PARAMETERS_TO_REMOVE = Stream\n+      .of(InputFormatConfig.TABLE_SCHEMA, InputFormatConfig.PARTITION_SPEC, Catalogs.LOCATION, Catalogs.NAME)\n+      .collect(Collectors.toCollection(HashSet::new));\n+  private static final Set<String> PROPERTIES_TO_REMOVE = Stream\n+      .of(InputFormatConfig.HIVE_DELETE_BACKING_TABLE, \"storage_handler\", \"EXTERNAL\")\n+      .collect(Collectors.toCollection(HashSet::new));\n+\n+  private final Configuration conf;\n+  private Table icebergTable = null;\n+  private Properties catalogProperties;\n+  private boolean deleteIcebergTable;\n+\n+  public HiveIcebergMetaHook(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void preCreateTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    catalogProperties = getCatalogProperties(hmsTable);\n+    try {\n+      icebergTable = Catalogs.loadTable(conf, catalogProperties);\n+\n+      Preconditions.checkArgument(catalogProperties.getProperty(InputFormatConfig.TABLE_SCHEMA) == null,\n+          \"Iceberg table already created - can not use provided schema\");\n+      Preconditions.checkArgument(catalogProperties.getProperty(InputFormatConfig.PARTITION_SPEC) == null,\n+          \"Iceberg table already created - can not use provided partition specification\");\n+\n+      LOG.info(\"Iceberg table already exists {}\", icebergTable);\n+    } catch (NoSuchTableException nte) {\n+      String schemaString = catalogProperties.getProperty(InputFormatConfig.TABLE_SCHEMA);\n+      Preconditions.checkNotNull(schemaString, \"Please provide a table schema\");\n+      // Just check if it is parsable, and later use for partition specification parsing\n+      Schema schema = SchemaParser.fromJson(schemaString);\n+\n+      String specString = catalogProperties.getProperty(InputFormatConfig.PARTITION_SPEC);\n+      if (specString != null) {\n+        // Just check if it is parsable\n+        PartitionSpecParser.fromJson(schema, schemaString);\n+      }\n+\n+      // Allow purging table data if the table is created now and not set otherwise\n+      if (hmsTable.getParameters().get(InputFormatConfig.HIVE_DELETE_BACKING_TABLE) == null) {\n+        hmsTable.getParameters().put(InputFormatConfig.HIVE_DELETE_BACKING_TABLE, \"TRUE\");\n+      }\n+\n+      // Set the table type even for non HiveCatalog based tables\n+      hmsTable.getParameters().put(BaseMetastoreTableOperations.TABLE_TYPE_PROP,\n+          BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.toUpperCase());\n+\n+      // Remove creation related properties\n+      PARAMETERS_TO_REMOVE.forEach(hmsTable.getParameters()::remove);\n+    }\n+  }\n+\n+  @Override\n+  public void rollbackCreateTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    // do nothing\n+  }\n+\n+  @Override\n+  public void commitCreateTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    if (icebergTable == null) {\n+      catalogProperties.put(HiveTableOperations.TABLE_FROM_HIVE, true);\n+      LOG.info(\"Iceberg table creation with the following properties {}\", catalogProperties.keySet());", "originalCommit": "dc7c1c61197c93bb26215fd945f8e7c83749bd29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA5MDYwNw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494090607", "bodyText": "Removed", "author": "pvary", "createdAt": "2020-09-24T07:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r493982198", "bodyText": "Can you explain this option?", "author": "rdblue", "createdAt": "2020-09-24T01:09:38Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergMetaHook.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.HiveMetaHook;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.PartitionSpecParser;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hive.HiveTableOperations;\n+import org.apache.iceberg.mr.Catalogs;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class HiveIcebergMetaHook implements HiveMetaHook {\n+  private static final Logger LOG = LoggerFactory.getLogger(HiveIcebergMetaHook.class);\n+  private static final Set<String> PARAMETERS_TO_REMOVE = Stream\n+      .of(InputFormatConfig.TABLE_SCHEMA, InputFormatConfig.PARTITION_SPEC, Catalogs.LOCATION, Catalogs.NAME)\n+      .collect(Collectors.toCollection(HashSet::new));\n+  private static final Set<String> PROPERTIES_TO_REMOVE = Stream\n+      .of(InputFormatConfig.HIVE_DELETE_BACKING_TABLE, \"storage_handler\", \"EXTERNAL\")\n+      .collect(Collectors.toCollection(HashSet::new));\n+\n+  private final Configuration conf;\n+  private Table icebergTable = null;\n+  private Properties catalogProperties;\n+  private boolean deleteIcebergTable;\n+\n+  public HiveIcebergMetaHook(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void preCreateTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    catalogProperties = getCatalogProperties(hmsTable);\n+    try {\n+      icebergTable = Catalogs.loadTable(conf, catalogProperties);\n+\n+      Preconditions.checkArgument(catalogProperties.getProperty(InputFormatConfig.TABLE_SCHEMA) == null,\n+          \"Iceberg table already created - can not use provided schema\");\n+      Preconditions.checkArgument(catalogProperties.getProperty(InputFormatConfig.PARTITION_SPEC) == null,\n+          \"Iceberg table already created - can not use provided partition specification\");\n+\n+      LOG.info(\"Iceberg table already exists {}\", icebergTable);\n+    } catch (NoSuchTableException nte) {\n+      String schemaString = catalogProperties.getProperty(InputFormatConfig.TABLE_SCHEMA);\n+      Preconditions.checkNotNull(schemaString, \"Please provide a table schema\");\n+      // Just check if it is parsable, and later use for partition specification parsing\n+      Schema schema = SchemaParser.fromJson(schemaString);\n+\n+      String specString = catalogProperties.getProperty(InputFormatConfig.PARTITION_SPEC);\n+      if (specString != null) {\n+        // Just check if it is parsable\n+        PartitionSpecParser.fromJson(schema, schemaString);\n+      }\n+\n+      // Allow purging table data if the table is created now and not set otherwise\n+      if (hmsTable.getParameters().get(InputFormatConfig.HIVE_DELETE_BACKING_TABLE) == null) {\n+        hmsTable.getParameters().put(InputFormatConfig.HIVE_DELETE_BACKING_TABLE, \"TRUE\");", "originalCommit": "dc7c1c61197c93bb26215fd945f8e7c83749bd29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDExNDU1OQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494114559", "bodyText": "I can see 2 different use-cases for Hive tables Iceberg tables:\n\nTable is created and used only from Hive. When we drop the table we want to drop the underlying Iceberg table as well\nTable is created outside of Hive but want to read it from Hive as well. We create the Hive table above the Iceberg table but when we drop the Hive table we do not want to drop the underlying Iceberg table.\n\nThe proposed solution is:\n\nDefault behavior: When the table is created from Hive and it needs to create the underlying Iceberg table then Hive will master the data. If the underlying Iceberg table is already there then Hive will not master the data. When the Hive table is dropped then the underlying Iceberg table is only dropped if Hive is mastering the data.\nHIVE_DELETE_BACKING_TABLE could override the default behavior when dropping the table\n\nThere is 1 exception: If the HiveCatalog is used it is obviously not possible to keep the table if we drop the HMS table. That is why this check is needed.", "author": "pvary", "createdAt": "2020-09-24T07:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU2ODc3Ng==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494568776", "bodyText": "Would it work to drop the table if it is a HMS table and not if it uses a non-Hive catalog?", "author": "rdblue", "createdAt": "2020-09-24T19:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3MDAwNA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494570004", "bodyText": "Or alternatively, could we use the existing EXTERNAL option? I think that does basically the same thing for data in paths that Hive points to.", "author": "rdblue", "createdAt": "2020-09-24T19:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4OTUzOQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494589539", "bodyText": "The EXTERNAL, MANAGED definition shifted a little bit in Hive lately.\nPreviously the only real difference was that when the table was dropped, the data of EXTERNAL tables was not removed, while the data of the MANAGED tables were cleaned up. Since Hive 3 MANAGED means \"do not touch my directories because there will be a data loss\", and even for EXTERNAL tables we have a new property external.table.purge, which means that the data should be cleaned up if the table is dropped.", "author": "pvary", "createdAt": "2020-09-24T20:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwNDc3Ng==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494604776", "bodyText": "I don't quite understand the new definition of MANAGED that you're talking about, but I think we should try to make it work. We could still respect external.table.purge. I'll try to find some docs on the new definition.", "author": "rdblue", "createdAt": "2020-09-24T20:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwNjEyNQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494606125", "bodyText": "Also: if we know that Hive is creating the table, we should definitely set the correct storage handler and serde. Tables that are created by Spark might be used by Hive (and should depend on hive-site.xml) but we can assume that tables created by Hive have the Iceberg library present and can be set up automatically, I think.", "author": "rdblue", "createdAt": "2020-09-24T20:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4NDg1Mg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494984852", "bodyText": "Maybe this doc can help understand the new MANAGED tables: https://docs.cloudera.com/HDPDocuments/HDP3/HDP-3.1.5/using-hiveql/content/hive_hive_3_tables.html", "author": "pvary", "createdAt": "2020-09-25T13:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxNjY4OQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r495216689", "bodyText": "It seems like the distinction between external and managed still fits. @omalley, what do you think about this?", "author": "rdblue", "createdAt": "2020-09-25T20:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NzMyNw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497077327", "bodyText": "Since managed means that it is hive-owned and in hive acid layout, it doesn't seem like we should have iceberg tables that hive thinks are managed.\nIt doesn't seem like we should have a separate property for deleting the external table's data and should just use the external.table.purge table property that Hive already uses. It probably makes sense to also delete the data when:\n\nWe are using the HiveCatalog.\nThe iceberg location property is set.\n\nsince once the Hive metadata is deleted, it won't be recoverable. Rather than having separate logic, it might make sense to have the HiveCatalog set that property when it creates a table.", "author": "omalley", "createdAt": "2020-09-29T21:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5ODc3OQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497098779", "bodyText": "managed means that it is hive-owned and in hive acid layout\n\nThanks! I didn't realize that managed now means that it uses the Hive ACID layout.\nI agree that if we can reuse a property, then we should. I like the idea to use external.table.purge.\nI would set that automatically when creating a table from Hive, but I don't think it makes sense to drop the table data automatically based on using HiveCatalog. Leaving metadata in place to be cleaned up by something like RemoveOrphanFilesAction is nice so that you can un-delete tables when a user dropped one accidentally. For example, we've seen lots of cases where tables in the wrong db are dropped because the user thought they had run USE.\nI'd say let's keep it simple and just use the existing Hive property.", "author": "rdblue", "createdAt": "2020-09-29T22:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3OTcxNw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497779717", "bodyText": "Moved to using the external.table.purge, but realized that calling Catalogs.dropTable for HiveCatalog tables is not enough, since the table had been already dropped from the HMS, so the HiveCatalog will not find it.", "author": "pvary", "createdAt": "2020-09-30T20:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4NTMyMQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497785321", "bodyText": "Could we detect this in the pre-delete method and set a flag so the post-delete method can purge?", "author": "rdblue", "createdAt": "2020-09-30T20:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5MTIwMQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497791201", "bodyText": "I was thinking around these lines.\nThe problem is that when we drop the table we drop the current snapshot as well.\nWe can access everything through Table object but for removing the data / metadata files, we need some more info. I know of CatalogUtil.dropTableData(FileIO io, TableMetadata metadata), but for that we would need TableMetadata. I might be able to store the snapshot location and later use that, but it is quite late here and this needs more digging \ud83d\ude04", "author": "pvary", "createdAt": "2020-09-30T20:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzODE0Mw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497838143", "bodyText": "StaticTableOperations might help here. We use that to inspect metadata that has already expired in the ExpireSnapshotsAction. That allows you to create a static table based on an older metadata location.", "author": "rdblue", "createdAt": "2020-09-30T22:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwMDMzNg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498300336", "bodyText": "Good pointers! Big thanks!\nFound solution which looks nice \ud83d\ude04", "author": "pvary", "createdAt": "2020-10-01T14:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjUwOQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r493982509", "bodyText": "I think what is happening here should be documented clearly in the code.", "author": "rdblue", "createdAt": "2020-09-24T01:10:51Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergMetaHook.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.HiveMetaHook;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.PartitionSpecParser;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hive.HiveTableOperations;\n+import org.apache.iceberg.mr.Catalogs;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class HiveIcebergMetaHook implements HiveMetaHook {\n+  private static final Logger LOG = LoggerFactory.getLogger(HiveIcebergMetaHook.class);\n+  private static final Set<String> PARAMETERS_TO_REMOVE = Stream\n+      .of(InputFormatConfig.TABLE_SCHEMA, InputFormatConfig.PARTITION_SPEC, Catalogs.LOCATION, Catalogs.NAME)\n+      .collect(Collectors.toCollection(HashSet::new));\n+  private static final Set<String> PROPERTIES_TO_REMOVE = Stream\n+      .of(InputFormatConfig.HIVE_DELETE_BACKING_TABLE, \"storage_handler\", \"EXTERNAL\")\n+      .collect(Collectors.toCollection(HashSet::new));\n+\n+  private final Configuration conf;\n+  private Table icebergTable = null;\n+  private Properties catalogProperties;\n+  private boolean deleteIcebergTable;\n+\n+  public HiveIcebergMetaHook(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void preCreateTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    catalogProperties = getCatalogProperties(hmsTable);\n+    try {\n+      icebergTable = Catalogs.loadTable(conf, catalogProperties);\n+\n+      Preconditions.checkArgument(catalogProperties.getProperty(InputFormatConfig.TABLE_SCHEMA) == null,\n+          \"Iceberg table already created - can not use provided schema\");\n+      Preconditions.checkArgument(catalogProperties.getProperty(InputFormatConfig.PARTITION_SPEC) == null,\n+          \"Iceberg table already created - can not use provided partition specification\");\n+\n+      LOG.info(\"Iceberg table already exists {}\", icebergTable);\n+    } catch (NoSuchTableException nte) {\n+      String schemaString = catalogProperties.getProperty(InputFormatConfig.TABLE_SCHEMA);\n+      Preconditions.checkNotNull(schemaString, \"Please provide a table schema\");\n+      // Just check if it is parsable, and later use for partition specification parsing\n+      Schema schema = SchemaParser.fromJson(schemaString);\n+\n+      String specString = catalogProperties.getProperty(InputFormatConfig.PARTITION_SPEC);\n+      if (specString != null) {\n+        // Just check if it is parsable\n+        PartitionSpecParser.fromJson(schema, schemaString);\n+      }\n+\n+      // Allow purging table data if the table is created now and not set otherwise\n+      if (hmsTable.getParameters().get(InputFormatConfig.HIVE_DELETE_BACKING_TABLE) == null) {\n+        hmsTable.getParameters().put(InputFormatConfig.HIVE_DELETE_BACKING_TABLE, \"TRUE\");\n+      }\n+\n+      // Set the table type even for non HiveCatalog based tables\n+      hmsTable.getParameters().put(BaseMetastoreTableOperations.TABLE_TYPE_PROP,\n+          BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.toUpperCase());\n+\n+      // Remove creation related properties\n+      PARAMETERS_TO_REMOVE.forEach(hmsTable.getParameters()::remove);\n+    }\n+  }\n+\n+  @Override\n+  public void rollbackCreateTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    // do nothing\n+  }\n+\n+  @Override\n+  public void commitCreateTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    if (icebergTable == null) {\n+      catalogProperties.put(HiveTableOperations.TABLE_FROM_HIVE, true);\n+      LOG.info(\"Iceberg table creation with the following properties {}\", catalogProperties.keySet());\n+      Catalogs.createTable(conf, catalogProperties);\n+    }\n+  }\n+\n+  @Override\n+  public void preDropTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) throws MetaException {\n+    catalogProperties = getCatalogProperties(hmsTable);\n+    deleteIcebergTable = hmsTable.getParameters() != null &&\n+        \"TRUE\".equalsIgnoreCase(hmsTable.getParameters().get(InputFormatConfig.HIVE_DELETE_BACKING_TABLE));\n+\n+    if (!deleteIcebergTable) {\n+      if (!Catalogs.canWorkWithoutHive(conf)) {\n+        // This should happen only if someone were manually removing this property from the table, or\n+        // added the table from outside of Hive\n+        throw new MetaException(\"Can not drop Hive table and keep Iceberg table data when using HiveCatalog. \" +\n+            \"Please add \" + InputFormatConfig.HIVE_DELETE_BACKING_TABLE + \"='TRUE' to TBLPROPERTIES \" +\n+            \"of the Hive table to enable dropping\");\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void rollbackDropTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    // do nothing\n+  }\n+\n+  @Override\n+  public void commitDropTable(org.apache.hadoop.hive.metastore.api.Table hmsTable, boolean deleteData) {\n+    if (deleteData && deleteIcebergTable) {\n+      LOG.info(\"Dropping with purge all the data for table {}.{}\", hmsTable.getDbName(), hmsTable.getTableName());\n+      Catalogs.dropTable(conf, catalogProperties);\n+    }\n+  }\n+\n+  private Properties getCatalogProperties(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    Properties properties = new Properties();\n+    properties.putAll(hmsTable.getParameters());\n+\n+    if (properties.get(Catalogs.LOCATION) == null &&\n+        hmsTable.getSd() != null && hmsTable.getSd().getLocation() != null) {\n+      properties.put(Catalogs.LOCATION, hmsTable.getSd().getLocation());\n+    }\n+\n+    if (properties.get(Catalogs.NAME) == null) {\n+      properties.put(Catalogs.NAME, hmsTable.getDbName() + \".\" + hmsTable.getTableName());\n+    }", "originalCommit": "dc7c1c61197c93bb26215fd945f8e7c83749bd29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4MDQxMA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r494180410", "bodyText": "Added a comment, and modified a bit to use TableIdentifier instead of concatenating the strings", "author": "pvary", "createdAt": "2020-09-24T09:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjUwOQ=="}], "type": "inlineReview"}, {"oid": "bc13a60e8987e53828b1f5c6cd3dd1f2654c1e57", "url": "https://github.com/apache/iceberg/commit/bc13a60e8987e53828b1f5c6cd3dd1f2654c1e57", "message": "Addressed review comments", "committedDate": "2020-09-24T12:07:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU0NTcxOQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r495545719", "bodyText": "PartitionSpecParser.fromJson(schema, schemaString)\n\nshould be replaced with\n\nPartitionSpecParser.fromJson(schema, specString)\n\nRight?", "author": "qphien", "createdAt": "2020-09-27T08:26:01Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergMetaHook.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.util.Properties;\n+import java.util.Set;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.HiveMetaHook;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.api.hive_metastoreConstants;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.PartitionSpecParser;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hive.HiveTableOperations;\n+import org.apache.iceberg.mr.Catalogs;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class HiveIcebergMetaHook implements HiveMetaHook {\n+  private static final Logger LOG = LoggerFactory.getLogger(HiveIcebergMetaHook.class);\n+  private static final Set<String> PARAMETERS_TO_REMOVE = ImmutableSet\n+      .of(InputFormatConfig.TABLE_SCHEMA, InputFormatConfig.PARTITION_SPEC, Catalogs.LOCATION, Catalogs.NAME);\n+  private static final Set<String> PROPERTIES_TO_REMOVE = ImmutableSet\n+      .of(InputFormatConfig.HIVE_DELETE_BACKING_TABLE, hive_metastoreConstants.META_TABLE_STORAGE, \"EXTERNAL\");\n+\n+  private final Configuration conf;\n+  private Table icebergTable = null;\n+  private Properties catalogProperties;\n+  private boolean deleteIcebergTable;\n+\n+  public HiveIcebergMetaHook(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  @Override\n+  public void preCreateTable(org.apache.hadoop.hive.metastore.api.Table hmsTable) {\n+    this.catalogProperties = getCatalogProperties(hmsTable);\n+    try {\n+      this.icebergTable = Catalogs.loadTable(conf, catalogProperties);\n+\n+      Preconditions.checkArgument(catalogProperties.getProperty(InputFormatConfig.TABLE_SCHEMA) == null,\n+          \"Iceberg table already created - can not use provided schema\");\n+      Preconditions.checkArgument(catalogProperties.getProperty(InputFormatConfig.PARTITION_SPEC) == null,\n+          \"Iceberg table already created - can not use provided partition specification\");\n+\n+      LOG.info(\"Iceberg table already exists {}\", icebergTable);\n+    } catch (NoSuchTableException nte) {\n+      String schemaString = catalogProperties.getProperty(InputFormatConfig.TABLE_SCHEMA);\n+      Preconditions.checkNotNull(schemaString, \"Please provide a table schema\");\n+      // Just check if it is parsable, and later use for partition specification parsing\n+      Schema schema = SchemaParser.fromJson(schemaString);\n+\n+      String specString = catalogProperties.getProperty(InputFormatConfig.PARTITION_SPEC);\n+      if (specString != null) {\n+        // Just check if it is parsable\n+        PartitionSpecParser.fromJson(schema, schemaString);", "originalCommit": "bc13a60e8987e53828b1f5c6cd3dd1f2654c1e57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1MzA1NA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r496153054", "bodyText": "Good catch!\nThanks.\nFixed, and added tests", "author": "pvary", "createdAt": "2020-09-28T18:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU0NTcxOQ=="}], "type": "inlineReview"}, {"oid": "794b8390c3d9adbe1d3a8358a57b84e22fd3c0c7", "url": "https://github.com/apache/iceberg/commit/794b8390c3d9adbe1d3a8358a57b84e22fd3c0c7", "message": "Fix for partitionspec handling and tests for it", "committedDate": "2020-09-28T18:31:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxMDE0Mg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r496910142", "bodyText": "Is this correct?\nIf this happens, then the table exists and is not an Iceberg table. That is expected if we are creating the table from the Hive hook, but in that case I think that we will have injected metadata in the hook that signals to the TableOperations implementation that the table was pre-created by Hive and should be replaced (so update will be used for the initial commit). If we detect that in TableOperations then we should be able to avoid throwing this exception and return null like before.\nIf the operation is not happening inside of the Hive hooks, then we do want to let the exception propagate because there is an existing Hive table.", "author": "rdblue", "createdAt": "2020-09-29T17:21:02Z", "path": "core/src/main/java/org/apache/iceberg/BaseMetastoreCatalog.java", "diffHunk": "@@ -215,8 +216,15 @@ public TableBuilder withProperty(String key, String value) {\n     @Override\n     public Table create() {\n       TableOperations ops = newTableOps(identifier);\n-      if (ops.current() != null) {\n-        throw new AlreadyExistsException(\"Table already exists: %s\", identifier);\n+      try {\n+        if (ops.current() != null) {\n+          throw new AlreadyExistsException(\"Table already exists: %s\", identifier);\n+        }\n+      } catch (NoSuchIcebergTableException ne) {", "originalCommit": "794b8390c3d9adbe1d3a8358a57b84e22fd3c0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzMDA5MA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497030090", "bodyText": "Removed. With the new HMS table property this is not needed anymore.", "author": "pvary", "createdAt": "2020-09-29T20:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxMDE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMDEwNQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r496920105", "bodyText": "Are we sure that it is okay for this class to have state? What is the lifecycle of hooks in Hive? I would assume that there is one instance of this class that is used for all operations. But the instance fields that hold a table that is being created seems to assume that there is one instance of the class per operation.", "author": "rdblue", "createdAt": "2020-09-29T17:36:49Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergMetaHook.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.util.Properties;\n+import java.util.Set;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.HiveMetaHook;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.api.hive_metastoreConstants;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.PartitionSpecParser;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hive.HiveTableOperations;\n+import org.apache.iceberg.mr.Catalogs;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class HiveIcebergMetaHook implements HiveMetaHook {\n+  private static final Logger LOG = LoggerFactory.getLogger(HiveIcebergMetaHook.class);\n+  private static final Set<String> PARAMETERS_TO_REMOVE = ImmutableSet\n+      .of(InputFormatConfig.TABLE_SCHEMA, InputFormatConfig.PARTITION_SPEC, Catalogs.LOCATION, Catalogs.NAME);\n+  private static final Set<String> PROPERTIES_TO_REMOVE = ImmutableSet\n+      .of(InputFormatConfig.HIVE_DELETE_BACKING_TABLE, hive_metastoreConstants.META_TABLE_STORAGE, \"EXTERNAL\");\n+\n+  private final Configuration conf;\n+  private Table icebergTable = null;", "originalCommit": "794b8390c3d9adbe1d3a8358a57b84e22fd3c0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0MzA3MA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497043070", "bodyText": "The hook is created by the HiveIcebergStorageHandler every time:\nHive code\nOur code:\n  @Override\n  public HiveMetaHook getMetaHook() {\n    return new HiveIcebergMetaHook(conf);\n  }\n\nUsed by hive like this:\n    HiveMetaHook hook = getHook(tbl);\n    if (hook != null) {\n      hook.preCreateTable(tbl);\n    }\n    boolean success = false;\n    try {\n      // Subclasses can override this step (for example, for temporary tables)\n      client.create_table_req(request);\n      if (hook != null) {\n        hook.commitCreateTable(tbl);\n      }\n      success = true;\n    } finally {\n      if (!success && (hook != null)) {\n        try {\n          hook.rollbackCreateTable(tbl);\n        } catch (Exception e) {\n          LOG.error(\"Create rollback failed with\", e);\n        }\n      }\n    }\nThis is fairly stable part of the code as integration with other systems depends on it, but I have not seen the behavior documented", "author": "pvary", "createdAt": "2020-09-29T20:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMDEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0NzQ1Mg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497047452", "bodyText": "Sounds good to me. Thanks!", "author": "rdblue", "createdAt": "2020-09-29T20:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMDEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzNzAxOA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497037018", "bodyText": "Can we remove this? If the debug log shows that this path was taken, then it is redundant.", "author": "rdblue", "createdAt": "2020-09-29T20:43:24Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -142,16 +146,22 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n     String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n \n     boolean threw = true;\n+    boolean updateHiveTable = false;\n     Optional<Long> lockId = Optional.empty();\n     try {\n       lockId = Optional.of(acquireLock());\n       // TODO add lock heart beating for cases where default lock timeout is too low.\n       Table tbl;\n-      if (base != null) {\n-        LOG.debug(\"Committing existing table: {}\", fullName);\n+      try {\n         tbl = metaClients.run(client -> client.getTable(database, tableName));\n+        if (base == null && tbl.getParameters().get(TABLE_CREATION_FROM_HIVE) == null) {\n+          throw new AlreadyExistsException(\"Table already exists: %s.%s\", database, tableName);\n+        }\n+        updateHiveTable = true;\n+        LOG.debug(\"Committing existing table: {}\", fullName);\n         tbl.setSd(storageDescriptor(metadata)); // set to pickup any schema changes\n-      } else {\n+      } catch (NoSuchObjectException nte) {\n+        LOG.trace(\"Table not found {}\", fullName, nte);", "originalCommit": "2c18a3d580ac5b2f9d6bc4a01ca18a64d9f9062b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0NjE2OA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497046168", "bodyText": "Can we suppress the warning instead?\n> Task :iceberg-hive-metastore:compileJava\n/Users/petervary/dev/upstream/iceberg/hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java:163: error: [CatchBlockLogException] Catch block contains log statements but thrown exception is never logged.\n      } catch (NoSuchObjectException nte) {\n        ^\n    (see https://github.com/palantir/gradle-baseline#baseline-error-prone-checks)\n  Did you mean 'LOG.debug(\"Committing new table: {}\", fullName, nte);'?\n\nOr we should just log the exception on debug level?\nI wanted to dig the exception as deep as possible, as it is normal to have it \ud83d\ude04", "author": "pvary", "createdAt": "2020-09-29T20:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzNzAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0OTMwMQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497049301", "bodyText": "It's fine to suppress the exception. I just would normally not bother logging it.", "author": "rdblue", "createdAt": "2020-09-29T20:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzNzAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1NDAyMw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497054023", "bodyText": "Actually, I think you're right. Let's just log it at debug. I see what you're saying now.", "author": "rdblue", "createdAt": "2020-09-29T21:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzNzAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzODMxMg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497038312", "bodyText": "Why rename the variable here?", "author": "rdblue", "createdAt": "2020-09-29T20:44:40Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -179,17 +189,18 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n \n       setParameters(newMetadataLocation, tbl);\n \n-      if (base != null) {\n+      Table newTable = tbl;", "originalCommit": "2c18a3d580ac5b2f9d6bc4a01ca18a64d9f9062b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0NzQ3OQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497047479", "bodyText": "Otherwise I can not use it to the lambda expressions. We need \"final\" variables in lambda calls.", "author": "pvary", "createdAt": "2020-09-29T20:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzODMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1MTI5OA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497051298", "bodyText": "Is this needed? TABLE_TYPE_PROP is set in the pre-commit hook. In fact, can we just use that instead of TABLE_CREATION_FROM_HIVE?", "author": "rdblue", "createdAt": "2020-09-29T20:57:19Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -313,6 +327,11 @@ protected void doUnlock(long lockId) throws TException, InterruptedException {\n   }\n \n   static void validateTableIsIceberg(Table table, String fullName) {\n+    if (\"TRUE\".equalsIgnoreCase(table.getParameters().get(TABLE_CREATION_FROM_HIVE))) {\n+      // No check is needed. The table has been created from Hive (HiveIcebergMetaHook), and we are about to initialize\n+      // the Iceberg metadata\n+      return;\n+    }", "originalCommit": "2c18a3d580ac5b2f9d6bc4a01ca18a64d9f9062b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1NTA2Ng==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497055066", "bodyText": "TABLE_TYPE_PROP is set, but METADATA_LOCATION_PROP is not set, and it would throw the exception. We want to bail out of the checks only if this is indeed in the table creation phase. In other places I have tried to keep to the original behavior.", "author": "pvary", "createdAt": "2020-09-29T21:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1MTI5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NTUyMw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497065523", "bodyText": "Okay, I see. I think I would prefer to simplify this and make it so that the table is Iceberg if and only if the table property is there. If we don't have the metadata location, then we can set metadata to null and everything else should work like normal.\nThat avoids the need for an extra property, which is a good thing because we want to keep the TableOperations as simple as possible.", "author": "rdblue", "createdAt": "2020-09-29T21:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1MTI5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3MTcwMQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497771701", "bodyText": "Done. Had to change a single tests, but that's seems ok.", "author": "pvary", "createdAt": "2020-09-30T20:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1MTI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4OTU1Nw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497789557", "bodyText": "SchemaParser has a cache, so that should help some.", "author": "rdblue", "createdAt": "2020-09-30T20:45:44Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergSerDe.java", "diffHunk": "@@ -27,21 +27,41 @@\n import org.apache.hadoop.hive.serde2.SerDeStats;\n import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n import org.apache.hadoop.io.Writable;\n-import org.apache.iceberg.Table;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n import org.apache.iceberg.mr.Catalogs;\n+import org.apache.iceberg.mr.InputFormatConfig;\n import org.apache.iceberg.mr.hive.serde.objectinspector.IcebergObjectInspector;\n import org.apache.iceberg.mr.mapred.Container;\n \n public class HiveIcebergSerDe extends AbstractSerDe {\n-\n+  private Schema schema;\n   private ObjectInspector inspector;\n \n   @Override\n   public void initialize(@Nullable Configuration configuration, Properties serDeProperties) throws SerDeException {\n-    Table table = Catalogs.loadTable(configuration, serDeProperties);\n-\n     try {\n-      this.inspector = IcebergObjectInspector.create(table.schema());\n+      // HiveIcebergSerDe.initialize is called multiple places in Hive code:\n+      // - When we are trying to create a table - HiveDDL data is stored at the serDeProperties, but no Iceberg table\n+      // is created yet.\n+      // - When we are compiling the Hive query on HiveServer2 side - We only have table information (location/name),\n+      // and we have to read the schema using the table data. This is called multiple times so there is room for\n+      // optimizing here.", "originalCommit": "10127f34eaf2780ad44a385a045be8a656fc1421", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5Mzg1MA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497793850", "bodyText": "Just thinking about how this interacts with #1505: This PR relies on setting the storage handler here and it is stored in parameters. Right now, nothing will remove it, but I think the right thing to do in #1505 is to remove this if Hive is not enabled for the table.\nIf we remove the property when Hive isn't enabled, then this test would break. To fix it, I think we should always set the engine.hive.enabled property to true in the hook. That could be done either in this PR or the other one if this one is merged first.", "author": "rdblue", "createdAt": "2020-09-30T20:53:35Z", "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -157,6 +177,282 @@ public void testJoinTables() throws IOException {\n     Assert.assertArrayEquals(new Object[] {1L, \"Bob\", 102L, 33.33d}, rows.get(2));\n   }\n \n+  @Test\n+  public void testCreateDropTable() throws TException, IOException {\n+    // We need the location for HadoopTable based tests only\n+    String location = locationForCreateTable(temp.getRoot().getPath(), \"customers\");\n+    shell.executeStatement(\"CREATE EXTERNAL TABLE customers \" +\n+        \"STORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler' \" +", "originalCommit": "10127f34eaf2780ad44a385a045be8a656fc1421", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDkzMDAxMg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r500930012", "bodyText": "Done", "author": "pvary", "createdAt": "2020-10-07T11:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5Mzg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5NDQ3OQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497794479", "bodyText": "You should be able to use PartitionSpec in the assertEquals because its equals method is implemented.", "author": "rdblue", "createdAt": "2020-09-30T20:54:48Z", "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -157,6 +177,282 @@ public void testJoinTables() throws IOException {\n     Assert.assertArrayEquals(new Object[] {1L, \"Bob\", 102L, 33.33d}, rows.get(2));\n   }\n \n+  @Test\n+  public void testCreateDropTable() throws TException, IOException {\n+    // We need the location for HadoopTable based tests only\n+    String location = locationForCreateTable(temp.getRoot().getPath(), \"customers\");\n+    shell.executeStatement(\"CREATE EXTERNAL TABLE customers \" +\n+        \"STORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler' \" +\n+        (location != null ? \"LOCATION '\" + location + \"' \" : \"\") +\n+        \"TBLPROPERTIES ('\" + InputFormatConfig.TABLE_SCHEMA + \"'='\" + SchemaParser.toJson(CUSTOMER_SCHEMA) + \"', \" +\n+        \"'\" + InputFormatConfig.PARTITION_SPEC + \"'='\" + PartitionSpecParser.toJson(IDENTITY_SPEC) + \"', \" +\n+        \"'dummy'='test')\");\n+\n+    Properties properties = new Properties();\n+    properties.put(Catalogs.NAME, TableIdentifier.of(\"default\", \"customers\").toString());\n+    if (location != null) {\n+      properties.put(Catalogs.LOCATION, location);\n+    }\n+\n+    // Check the Iceberg table data\n+    org.apache.iceberg.Table icebergTable = Catalogs.loadTable(shell.getHiveConf(), properties);\n+    Assert.assertEquals(SchemaParser.toJson(CUSTOMER_SCHEMA), SchemaParser.toJson(icebergTable.schema()));\n+    Assert.assertEquals(PartitionSpecParser.toJson(IDENTITY_SPEC), PartitionSpecParser.toJson(icebergTable.spec()));", "originalCommit": "10127f34eaf2780ad44a385a045be8a656fc1421", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNTEyMQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498235121", "bodyText": "Done", "author": "pvary", "createdAt": "2020-10-01T13:16:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5NDQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5NDk0Mw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497794943", "bodyText": "Instead of comparing the strings, it would be better to compare icebergTable.schema().asStruct(). StructType implements equals, but Schema doesn't because it may have extra metadata (like aliases).", "author": "rdblue", "createdAt": "2020-09-30T20:55:39Z", "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -157,6 +177,282 @@ public void testJoinTables() throws IOException {\n     Assert.assertArrayEquals(new Object[] {1L, \"Bob\", 102L, 33.33d}, rows.get(2));\n   }\n \n+  @Test\n+  public void testCreateDropTable() throws TException, IOException {\n+    // We need the location for HadoopTable based tests only\n+    String location = locationForCreateTable(temp.getRoot().getPath(), \"customers\");\n+    shell.executeStatement(\"CREATE EXTERNAL TABLE customers \" +\n+        \"STORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler' \" +\n+        (location != null ? \"LOCATION '\" + location + \"' \" : \"\") +\n+        \"TBLPROPERTIES ('\" + InputFormatConfig.TABLE_SCHEMA + \"'='\" + SchemaParser.toJson(CUSTOMER_SCHEMA) + \"', \" +\n+        \"'\" + InputFormatConfig.PARTITION_SPEC + \"'='\" + PartitionSpecParser.toJson(IDENTITY_SPEC) + \"', \" +\n+        \"'dummy'='test')\");\n+\n+    Properties properties = new Properties();\n+    properties.put(Catalogs.NAME, TableIdentifier.of(\"default\", \"customers\").toString());\n+    if (location != null) {\n+      properties.put(Catalogs.LOCATION, location);\n+    }\n+\n+    // Check the Iceberg table data\n+    org.apache.iceberg.Table icebergTable = Catalogs.loadTable(shell.getHiveConf(), properties);\n+    Assert.assertEquals(SchemaParser.toJson(CUSTOMER_SCHEMA), SchemaParser.toJson(icebergTable.schema()));", "originalCommit": "10127f34eaf2780ad44a385a045be8a656fc1421", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNTIzOA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498235238", "bodyText": "Done", "author": "pvary", "createdAt": "2020-10-01T13:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5NDk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzOTYxMg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497839612", "bodyText": "We might want to use a shared HiveClientPool for this. We've had problems in the past where too many clients led to the HMS becoming unresponsive in tests. It's really annoying and makes tests flaky. Sharing a pool across all tests fixes the problem, and makes us more confident that if we hit a connection issue, it is probably in prod code and not test.\nI think it would also make the test cases smaller because you wouldn't need try/finally blocks.", "author": "rdblue", "createdAt": "2020-09-30T22:37:55Z", "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -157,6 +177,282 @@ public void testJoinTables() throws IOException {\n     Assert.assertArrayEquals(new Object[] {1L, \"Bob\", 102L, 33.33d}, rows.get(2));\n   }\n \n+  @Test\n+  public void testCreateDropTable() throws TException, IOException {\n+    // We need the location for HadoopTable based tests only\n+    String location = locationForCreateTable(temp.getRoot().getPath(), \"customers\");\n+    shell.executeStatement(\"CREATE EXTERNAL TABLE customers \" +\n+        \"STORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler' \" +\n+        (location != null ? \"LOCATION '\" + location + \"' \" : \"\") +\n+        \"TBLPROPERTIES ('\" + InputFormatConfig.TABLE_SCHEMA + \"'='\" + SchemaParser.toJson(CUSTOMER_SCHEMA) + \"', \" +\n+        \"'\" + InputFormatConfig.PARTITION_SPEC + \"'='\" + PartitionSpecParser.toJson(IDENTITY_SPEC) + \"', \" +\n+        \"'dummy'='test')\");\n+\n+    Properties properties = new Properties();\n+    properties.put(Catalogs.NAME, TableIdentifier.of(\"default\", \"customers\").toString());\n+    if (location != null) {\n+      properties.put(Catalogs.LOCATION, location);\n+    }\n+\n+    // Check the Iceberg table data\n+    org.apache.iceberg.Table icebergTable = Catalogs.loadTable(shell.getHiveConf(), properties);\n+    Assert.assertEquals(SchemaParser.toJson(CUSTOMER_SCHEMA), SchemaParser.toJson(icebergTable.schema()));\n+    Assert.assertEquals(PartitionSpecParser.toJson(IDENTITY_SPEC), PartitionSpecParser.toJson(icebergTable.spec()));\n+    Assert.assertEquals(Collections.singletonMap(\"dummy\", \"test\"), icebergTable.properties());\n+\n+    // Check the HMS table parameters\n+    IMetaStoreClient client = null;\n+    org.apache.hadoop.hive.metastore.api.Table hmsTable;", "originalCommit": "10127f34eaf2780ad44a385a045be8a656fc1421", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2NTgyNQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498265825", "bodyText": "We are starting a new TestHiveMetastore() in the before method. So every test uses its own HMS instance.\nSo I think reusing HMS connection is not really an option until we use the same HMS instance throughout the tests", "author": "pvary", "createdAt": "2020-10-01T13:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzOTYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDIzOQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498394239", "bodyText": "Oh, we aren't using a shared metastore across test cases?\nWe should probably fix that eventually (maybe get this PR in first though). We do want to keep the metastore around long enough that we detect Iceberg connection leaks. Although it is annoying to have tests fail because the metastore hangs, it's better than releasing a version that leaves connections open and takes down a metastore.", "author": "rdblue", "createdAt": "2020-10-01T17:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzOTYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjIwOQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498402209", "bodyText": "It would also save a serious amount of testing time.\nI think it might need changes in HiveRunner though, we have to check", "author": "pvary", "createdAt": "2020-10-01T17:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzOTYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2NjQ3Ng==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r501166476", "bodyText": "We just made the change to use a suite-level metastore in #1478 and it appears to work fine. We should explore doing the same here, but probably in a follow-up.", "author": "rdblue", "createdAt": "2020-10-07T16:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzOTYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxNTI4Nw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r503715287", "bodyText": "Rebased to the master, and using the suite-level metastore", "author": "pvary", "createdAt": "2020-10-13T07:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzOTYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDc1Nw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497840757", "bodyText": "Should this be done in the case where the table can work without Hive? The if statement seems backward to me.", "author": "rdblue", "createdAt": "2020-09-30T22:41:12Z", "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -157,6 +177,282 @@ public void testJoinTables() throws IOException {\n     Assert.assertArrayEquals(new Object[] {1L, \"Bob\", 102L, 33.33d}, rows.get(2));\n   }\n \n+  @Test\n+  public void testCreateDropTable() throws TException, IOException {\n+    // We need the location for HadoopTable based tests only\n+    String location = locationForCreateTable(temp.getRoot().getPath(), \"customers\");\n+    shell.executeStatement(\"CREATE EXTERNAL TABLE customers \" +\n+        \"STORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler' \" +\n+        (location != null ? \"LOCATION '\" + location + \"' \" : \"\") +\n+        \"TBLPROPERTIES ('\" + InputFormatConfig.TABLE_SCHEMA + \"'='\" + SchemaParser.toJson(CUSTOMER_SCHEMA) + \"', \" +\n+        \"'\" + InputFormatConfig.PARTITION_SPEC + \"'='\" + PartitionSpecParser.toJson(IDENTITY_SPEC) + \"', \" +\n+        \"'dummy'='test')\");\n+\n+    Properties properties = new Properties();\n+    properties.put(Catalogs.NAME, TableIdentifier.of(\"default\", \"customers\").toString());\n+    if (location != null) {\n+      properties.put(Catalogs.LOCATION, location);\n+    }\n+\n+    // Check the Iceberg table data\n+    org.apache.iceberg.Table icebergTable = Catalogs.loadTable(shell.getHiveConf(), properties);\n+    Assert.assertEquals(SchemaParser.toJson(CUSTOMER_SCHEMA), SchemaParser.toJson(icebergTable.schema()));\n+    Assert.assertEquals(PartitionSpecParser.toJson(IDENTITY_SPEC), PartitionSpecParser.toJson(icebergTable.spec()));\n+    Assert.assertEquals(Collections.singletonMap(\"dummy\", \"test\"), icebergTable.properties());\n+\n+    // Check the HMS table parameters\n+    IMetaStoreClient client = null;\n+    org.apache.hadoop.hive.metastore.api.Table hmsTable;\n+    try {\n+      client = new HiveMetaStoreClient(metastore.hiveConf());\n+      hmsTable = client.getTable(\"default\", \"customers\");\n+    } finally {\n+      if (client != null) {\n+        client.close();\n+      }\n+    }\n+\n+    Map<String, String> hmsParams = hmsTable.getParameters();\n+\n+    // This is only set for HiveCatalog based tables. Check the value, then remove it so the other checks can be general\n+    if (needToCheckSnapshotLocation()) {\n+      Assert.assertTrue(hmsParams.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP)\n+          .startsWith(icebergTable.location()));\n+      hmsParams.remove(BaseMetastoreTableOperations.METADATA_LOCATION_PROP);\n+    }\n+\n+    // General metadata checks\n+    Assert.assertEquals(6, hmsParams.size());\n+    Assert.assertEquals(\"test\", hmsParams.get(\"dummy\"));\n+    Assert.assertEquals(\"TRUE\", hmsParams.get(InputFormatConfig.EXTERNAL_TABLE_PURGE));\n+    Assert.assertEquals(\"TRUE\", hmsParams.get(\"EXTERNAL\"));\n+    Assert.assertNotNull(hmsParams.get(hive_metastoreConstants.DDL_TIME));\n+    Assert.assertEquals(HiveIcebergStorageHandler.class.getName(),\n+        hmsTable.getParameters().get(hive_metastoreConstants.META_TABLE_STORAGE));\n+    Assert.assertEquals(BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.toUpperCase(),\n+        hmsTable.getParameters().get(BaseMetastoreTableOperations.TABLE_TYPE_PROP));\n+\n+    if (Catalogs.canWorkWithoutHive(shell.getHiveConf())) {\n+      shell.executeStatement(\"DROP TABLE customers\");\n+\n+      // Check if the table was really dropped even from the Catalog\n+      AssertHelpers.assertThrows(\"should throw exception\", NoSuchTableException.class,\n+          \"Table does not exist\", () -> {\n+            Catalogs.loadTable(shell.getHiveConf(), properties);\n+          }\n+      );\n+    } else {\n+      // Check the HMS table parameters\n+      Path hmsTableLocation;\n+      try {\n+        client = new HiveMetaStoreClient(metastore.hiveConf());\n+        hmsTableLocation = new Path(client.getTable(\"default\", \"customers\").getSd().getLocation());\n+      } finally {\n+        if (client != null) {\n+          client.close();\n+        }\n+      }\n+\n+      // Drop the table\n+      shell.executeStatement(\"DROP TABLE customers\");\n+\n+      // Check if we drop an exception when trying to drop the table\n+      AssertHelpers.assertThrows(\"should throw exception\", NoSuchTableException.class,\n+          \"Table does not exist\", () -> {\n+            Catalogs.loadTable(shell.getHiveConf(), properties);\n+          }\n+      );\n+\n+      // Check if the files are kept\n+      FileSystem fs = Util.getFs(hmsTableLocation, shell.getHiveConf());", "originalCommit": "10127f34eaf2780ad44a385a045be8a656fc1421", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3NTgwOQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498275809", "bodyText": "Fixed comments \ud83d\ude04", "author": "pvary", "createdAt": "2020-10-01T14:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDkzOA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r497840938", "bodyText": "Should this be done with DROP TABLE IF EXISTS in a @Before method?", "author": "rdblue", "createdAt": "2020-09-30T22:41:46Z", "path": "mr/src/test/java/org/apache/iceberg/mr/hive/HiveIcebergStorageHandlerBaseTest.java", "diffHunk": "@@ -157,6 +177,282 @@ public void testJoinTables() throws IOException {\n     Assert.assertArrayEquals(new Object[] {1L, \"Bob\", 102L, 33.33d}, rows.get(2));\n   }\n \n+  @Test\n+  public void testCreateDropTable() throws TException, IOException {\n+    // We need the location for HadoopTable based tests only\n+    String location = locationForCreateTable(temp.getRoot().getPath(), \"customers\");\n+    shell.executeStatement(\"CREATE EXTERNAL TABLE customers \" +\n+        \"STORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler' \" +\n+        (location != null ? \"LOCATION '\" + location + \"' \" : \"\") +\n+        \"TBLPROPERTIES ('\" + InputFormatConfig.TABLE_SCHEMA + \"'='\" + SchemaParser.toJson(CUSTOMER_SCHEMA) + \"', \" +\n+        \"'\" + InputFormatConfig.PARTITION_SPEC + \"'='\" + PartitionSpecParser.toJson(IDENTITY_SPEC) + \"', \" +\n+        \"'dummy'='test')\");\n+\n+    Properties properties = new Properties();\n+    properties.put(Catalogs.NAME, TableIdentifier.of(\"default\", \"customers\").toString());\n+    if (location != null) {\n+      properties.put(Catalogs.LOCATION, location);\n+    }\n+\n+    // Check the Iceberg table data\n+    org.apache.iceberg.Table icebergTable = Catalogs.loadTable(shell.getHiveConf(), properties);\n+    Assert.assertEquals(SchemaParser.toJson(CUSTOMER_SCHEMA), SchemaParser.toJson(icebergTable.schema()));\n+    Assert.assertEquals(PartitionSpecParser.toJson(IDENTITY_SPEC), PartitionSpecParser.toJson(icebergTable.spec()));\n+    Assert.assertEquals(Collections.singletonMap(\"dummy\", \"test\"), icebergTable.properties());\n+\n+    // Check the HMS table parameters\n+    IMetaStoreClient client = null;\n+    org.apache.hadoop.hive.metastore.api.Table hmsTable;\n+    try {\n+      client = new HiveMetaStoreClient(metastore.hiveConf());\n+      hmsTable = client.getTable(\"default\", \"customers\");\n+    } finally {\n+      if (client != null) {\n+        client.close();\n+      }\n+    }\n+\n+    Map<String, String> hmsParams = hmsTable.getParameters();\n+\n+    // This is only set for HiveCatalog based tables. Check the value, then remove it so the other checks can be general\n+    if (needToCheckSnapshotLocation()) {\n+      Assert.assertTrue(hmsParams.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP)\n+          .startsWith(icebergTable.location()));\n+      hmsParams.remove(BaseMetastoreTableOperations.METADATA_LOCATION_PROP);\n+    }\n+\n+    // General metadata checks\n+    Assert.assertEquals(6, hmsParams.size());\n+    Assert.assertEquals(\"test\", hmsParams.get(\"dummy\"));\n+    Assert.assertEquals(\"TRUE\", hmsParams.get(InputFormatConfig.EXTERNAL_TABLE_PURGE));\n+    Assert.assertEquals(\"TRUE\", hmsParams.get(\"EXTERNAL\"));\n+    Assert.assertNotNull(hmsParams.get(hive_metastoreConstants.DDL_TIME));\n+    Assert.assertEquals(HiveIcebergStorageHandler.class.getName(),\n+        hmsTable.getParameters().get(hive_metastoreConstants.META_TABLE_STORAGE));\n+    Assert.assertEquals(BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.toUpperCase(),\n+        hmsTable.getParameters().get(BaseMetastoreTableOperations.TABLE_TYPE_PROP));\n+\n+    if (Catalogs.canWorkWithoutHive(shell.getHiveConf())) {\n+      shell.executeStatement(\"DROP TABLE customers\");\n+\n+      // Check if the table was really dropped even from the Catalog\n+      AssertHelpers.assertThrows(\"should throw exception\", NoSuchTableException.class,\n+          \"Table does not exist\", () -> {\n+            Catalogs.loadTable(shell.getHiveConf(), properties);\n+          }\n+      );\n+    } else {\n+      // Check the HMS table parameters\n+      Path hmsTableLocation;\n+      try {\n+        client = new HiveMetaStoreClient(metastore.hiveConf());\n+        hmsTableLocation = new Path(client.getTable(\"default\", \"customers\").getSd().getLocation());\n+      } finally {\n+        if (client != null) {\n+          client.close();\n+        }\n+      }\n+\n+      // Drop the table\n+      shell.executeStatement(\"DROP TABLE customers\");\n+\n+      // Check if we drop an exception when trying to drop the table\n+      AssertHelpers.assertThrows(\"should throw exception\", NoSuchTableException.class,\n+          \"Table does not exist\", () -> {\n+            Catalogs.loadTable(shell.getHiveConf(), properties);\n+          }\n+      );\n+\n+      // Check if the files are kept\n+      FileSystem fs = Util.getFs(hmsTableLocation, shell.getHiveConf());\n+      // TODO: files should be deleted\n+      // Assert.assertEquals(0, fs.listStatus(hmsTableLocation).length);\n+    }\n+  }\n+\n+  @Test\n+  public void testCreateTableWithoutSpec() throws TException {\n+    // We need the location for HadoopTable based tests only\n+    String location = locationForCreateTable(temp.getRoot().getPath(), \"customers\");\n+    shell.executeStatement(\"CREATE EXTERNAL TABLE customers \" +\n+        \"STORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler' \" +\n+        (location != null ? \"LOCATION '\" + location + \"' \" : \"\") +\n+        \"TBLPROPERTIES ('\" + InputFormatConfig.TABLE_SCHEMA + \"'='\" + SchemaParser.toJson(CUSTOMER_SCHEMA) + \"')\");\n+\n+    Properties properties = new Properties();\n+    properties.put(Catalogs.NAME, TableIdentifier.of(\"default\", \"customers\").toString());\n+    if (location != null) {\n+      properties.put(Catalogs.LOCATION, location);\n+    }\n+\n+    // Check the Iceberg table partition data\n+    org.apache.iceberg.Table icebergTable = Catalogs.loadTable(shell.getHiveConf(), properties);\n+    Assert.assertEquals(PartitionSpecParser.toJson(SPEC), PartitionSpecParser.toJson(icebergTable.spec()));\n+\n+    // Check the HMS table parameters\n+    IMetaStoreClient client = null;\n+    org.apache.hadoop.hive.metastore.api.Table hmsTable;\n+    try {\n+      client = new HiveMetaStoreClient(metastore.hiveConf());\n+      hmsTable = client.getTable(\"default\", \"customers\");\n+    } finally {\n+      if (client != null) {\n+        client.close();\n+      }\n+    }\n+\n+    Map<String, String> hmsParams = hmsTable.getParameters();\n+\n+    // Just check that the PartitionSpec is not set in the metadata\n+    Assert.assertNull(hmsParams.get(InputFormatConfig.PARTITION_SPEC));\n+\n+    if (needToCheckSnapshotLocation()) {\n+      Assert.assertEquals(6, hmsParams.size());\n+    } else {\n+      Assert.assertEquals(5, hmsParams.size());\n+    }\n+\n+    shell.executeStatement(\"DROP TABLE customers\");", "originalCommit": "10127f34eaf2780ad44a385a045be8a656fc1421", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MDMzNg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498280336", "bodyText": "If there is a problem with the HiveMetaHook and the DROP TABLE fails for whatever reason, then all of the tests would be failing. I would keep it this way until we are sure about the stability of the DROP TABLE. What do you think?", "author": "pvary", "createdAt": "2020-10-01T14:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTIxNA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498395214", "bodyText": "I think it can fail here or in @After (which is what I meant to say) with the same effect. Putting it in an after method ensures that no matter what happens with the test, say a NullPointerException somewhere, the table is dropped for the next case.", "author": "rdblue", "createdAt": "2020-10-01T17:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxNDk5NQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498414995", "bodyText": "Does not hurt, and when we change to use a single metastore it will be good", "author": "pvary", "createdAt": "2020-10-01T17:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxNzA1MA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r498417050", "bodyText": "Yeah, this was mainly assuming that the metastore was shared.", "author": "rdblue", "createdAt": "2020-10-01T17:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDkzOA=="}], "type": "inlineReview"}, {"oid": "059c9f5335e25206d0ddbdcac5438b6eae6bf3ac", "url": "https://github.com/apache/iceberg/commit/059c9f5335e25206d0ddbdcac5438b6eae6bf3ac", "message": "Enable hive engine for tests for storageHandler tests too", "committedDate": "2020-10-06T21:09:09Z", "type": "forcePushed"}, {"oid": "20367c90e3ac1f9e4ecfc4870074aad2b3f35972", "url": "https://github.com/apache/iceberg/commit/20367c90e3ac1f9e4ecfc4870074aad2b3f35972", "message": "Cleaned up code after too many local fixes\n- Production code change: For HiveCatalog do not try to load the table in preCreateTable - it should not exist anyway\n- Test code:\n    - Remove stat related table properties when checking\n    - Remove needToCheckSnapshotLocation() use Catalogs.hiveCatalog instead\n    - Add new test to check Hive table creation above existing Iceberg table\n    - locationForCreateTable for HadoopTable should use the same as createIcebergTable method", "committedDate": "2020-10-07T10:44:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2MTQ5OQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r501161499", "bodyText": "I don't think this is correct. Looks like this is happening because we always try to load the table, so the create path (the previous else case after checking base != null) is not taken.\nI think the logic should be: if the table exists, then check whether we are trying to create it (base is null). If we are trying to create it, validate that it is in a state that can be created: the table should have type \"iceberg\", but should not have a metadata location. If it has a metadata location, then the table already exists and it should throw the original AlreadyExistsException.", "author": "rdblue", "createdAt": "2020-10-07T16:47:45Z", "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/HiveCreateReplaceTableTest.java", "diffHunk": "@@ -104,8 +105,8 @@ public void testCreateTableTxnTableCreatedConcurrently() {\n \n     AssertHelpers.assertThrows(\n         \"Create table txn should fail\",\n-        AlreadyExistsException.class,\n-        \"Table already exists: hivedb.tbl\",\n+        CommitFailedException.class,\n+        \"is not same as the current table metadata\",", "originalCommit": "20367c90e3ac1f9e4ecfc4870074aad2b3f35972", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxMTIzMQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r501911231", "bodyText": "Reverted to the original behavior based on your suggestion.\nHad to refactor stuff to reduce complexity", "author": "pvary", "createdAt": "2020-10-08T18:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2MTQ5OQ=="}], "type": "inlineReview"}, {"oid": "d90bcd752cb9aca8516dff5b057fe86fe7fe6bbc", "url": "https://github.com/apache/iceberg/commit/d90bcd752cb9aca8516dff5b057fe86fe7fe6bbc", "message": "Reverted to create the HMS client anyway, since we use it to clean the HMS after every test", "committedDate": "2020-10-08T17:59:08Z", "type": "forcePushed"}, {"oid": "6115ad1c676b644f786382ec9b852c5350433261", "url": "https://github.com/apache/iceberg/commit/6115ad1c676b644f786382ec9b852c5350433261", "message": "Rebased again", "committedDate": "2020-10-08T19:47:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNTI2Nw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r502035267", "bodyText": "I'd recommend taking a look at other classes based on this and copying their use of a client pool, rather than creating a client here.", "author": "rdblue", "createdAt": "2020-10-08T21:56:50Z", "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveMetastore.java", "diffHunk": "@@ -66,26 +75,31 @@\n   private ExecutorService executorService;\n   private TServer server;\n   private HiveMetaStore.HMSHandler baseHandler;\n+  private IMetaStoreClient client = null;\n \n   public void start() {\n     try {\n-      hiveLocalDir = createTempDirectory(\"hive\", asFileAttribute(fromString(\"rwxrwxrwx\"))).toFile();\n+      this.hiveLocalDir = createTempDirectory(\"hive\", asFileAttribute(fromString(\"rwxrwxrwx\"))).toFile();\n       File derbyLogFile = new File(hiveLocalDir, \"derby.log\");\n       System.setProperty(\"derby.stream.error.file\", derbyLogFile.getAbsolutePath());\n       setupMetastoreDB(\"jdbc:derby:\" + getDerbyPath() + \";create=true\");\n \n       TServerSocket socket = new TServerSocket(0);\n       int port = socket.getServerSocket().getLocalPort();\n-      hiveConf = newHiveConf(port);\n-      server = newThriftServer(socket, hiveConf);\n-      executorService = Executors.newSingleThreadExecutor();\n-      executorService.submit(() -> server.serve());\n+      this.hiveConf = newHiveConf(port);\n+      this.server = newThriftServer(socket, hiveConf);\n+      this.executorService = Executors.newSingleThreadExecutor();\n+      this.executorService.submit(() -> server.serve());\n+      this.client = new HiveMetaStoreClient(hiveConf);", "originalCommit": "6115ad1c676b644f786382ec9b852c5350433261", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3Mjc0MQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r502072741", "bodyText": "This might fix the JDK 11 tests, which appear to be failing because of connections to the Hive metastore. My guess is that the \"write error\" is that it times out because the metastore ran out of thread -- and we don't want to increase those threads.\nJDK 8 tests are failing because of a constructor is being used that accepts a HiveConf. That needs to be done using reflection now.", "author": "rdblue", "createdAt": "2020-10-08T23:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjIxMDAxNg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r502210016", "bodyText": "Using a clientPool fixed these issues, but it seems that we do not have enough worker in the HMS and this causes failing tests. Need to investigate why the  clients are not closed.\nThanks for taking a look!", "author": "pvary", "createdAt": "2020-10-09T06:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNTg1NQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r502835855", "bodyText": "I know that it's annoying to track down, but that's exactly why we want to limit the worker threads. Much better to catch leaked connections here rather than trying to fix them for customers at runtime!", "author": "rdblue", "createdAt": "2020-10-10T21:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI0ODA0Nw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r503248047", "bodyText": "This was fun \ud83d\ude04\nUsing System.properties to configure the HMS made the ClientPool use the wrong URI.\nMoved every metastore related stuff to the TestMetaStore", "author": "pvary", "createdAt": "2020-10-12T12:03:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNTI2Nw=="}], "type": "inlineReview"}, {"oid": "6f798bed7101bf2b4eceb079c4b6dc96ab87a77d", "url": "https://github.com/apache/iceberg/commit/6f798bed7101bf2b4eceb079c4b6dc96ab87a77d", "message": "Fixing rebase errors", "committedDate": "2020-10-12T11:55:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5MzM5NA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r503493394", "bodyText": "Why is this needed? It may be nice to use this for applications, but for testing it seems like this allows us to pass the configuration incorrectly and still have tests pass. If it isn't needed, I'd rather remove it so that we must pass configuration properly.", "author": "rdblue", "createdAt": "2020-10-12T19:35:09Z", "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveMetastore.java", "diffHunk": "@@ -66,26 +72,35 @@\n   private ExecutorService executorService;\n   private TServer server;\n   private HiveMetaStore.HMSHandler baseHandler;\n+  private HiveClientPool clientPool;\n \n   public void start() {\n     try {\n-      hiveLocalDir = createTempDirectory(\"hive\", asFileAttribute(fromString(\"rwxrwxrwx\"))).toFile();\n+      this.hiveLocalDir = createTempDirectory(\"hive\", asFileAttribute(fromString(\"rwxrwxrwx\"))).toFile();\n       File derbyLogFile = new File(hiveLocalDir, \"derby.log\");\n       System.setProperty(\"derby.stream.error.file\", derbyLogFile.getAbsolutePath());\n       setupMetastoreDB(\"jdbc:derby:\" + getDerbyPath() + \";create=true\");\n \n       TServerSocket socket = new TServerSocket(0);\n       int port = socket.getServerSocket().getLocalPort();\n-      hiveConf = newHiveConf(port);\n-      server = newThriftServer(socket, hiveConf);\n-      executorService = Executors.newSingleThreadExecutor();\n-      executorService.submit(() -> server.serve());\n+      this.hiveConf = newHiveConf(port);\n+      this.server = newThriftServer(socket, hiveConf);\n+      this.executorService = Executors.newSingleThreadExecutor();\n+      this.executorService.submit(() -> server.serve());\n+\n+      // in Hive3, setting this as a system prop ensures that it will be picked up whenever a new HiveConf is created\n+      System.setProperty(HiveConf.ConfVars.METASTOREURIS.varname, hiveConf.getVar(HiveConf.ConfVars.METASTOREURIS));", "originalCommit": "6f798bed7101bf2b4eceb079c4b6dc96ab87a77d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUwOTc0Mg==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r503509742", "bodyText": "The Hive3 patch brought this in. If I understood @marton-bod correctly this was needed because in the HiveRunner there are some places where the config is not passed down, and this was the only way to fix the HMS client misery.\nWhat I did here was only move this from the test class to the TestHiveMetastore class so it will affect the ClientPools as well", "author": "pvary", "createdAt": "2020-10-12T20:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5MzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyODc2OQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r503728769", "bodyText": "That's correct. The rationale is outlined here: #1478 (comment)\nAs you mentioned, when using Hive3, not all threads spawned during HiveRunner initialization receive our custom properties we set on the HiveShell, therefore using the system props is there to ensure they're picked up during HiveConf construction. This is needed to get the tests working properly on Hive3, without the PersistenceManager-related flaky tests.", "author": "marton-bod", "createdAt": "2020-10-13T07:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5MzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3NjQ3MA==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r504076470", "bodyText": "Okay, thanks for the reasoning. I guess I missed that this required a global setting in the other PR. I think this is fairly safe, since we always want to override the metastore URI using an option from the catalog's config.", "author": "rdblue", "createdAt": "2020-10-13T16:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5MzM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NDE4Mw==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r503494183", "bodyText": "Minor: this seems like a good candidate for else if (serdeProperties...).", "author": "rdblue", "createdAt": "2020-10-12T19:37:01Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergSerDe.java", "diffHunk": "@@ -29,25 +29,42 @@\n import org.apache.hadoop.io.Writable;\n import org.apache.iceberg.Schema;\n import org.apache.iceberg.SchemaParser;\n-import org.apache.iceberg.Table;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n import org.apache.iceberg.mr.Catalogs;\n import org.apache.iceberg.mr.InputFormatConfig;\n import org.apache.iceberg.mr.hive.serde.objectinspector.IcebergObjectInspector;\n import org.apache.iceberg.mr.mapred.Container;\n \n public class HiveIcebergSerDe extends AbstractSerDe {\n-\n   private ObjectInspector inspector;\n \n   @Override\n   public void initialize(@Nullable Configuration configuration, Properties serDeProperties) throws SerDeException {\n+    // HiveIcebergSerDe.initialize is called multiple places in Hive code:\n+    // - When we are trying to create a table - HiveDDL data is stored at the serDeProperties, but no Iceberg table\n+    // is created yet.\n+    // - When we are compiling the Hive query on HiveServer2 side - We only have table information (location/name),\n+    // and we have to read the schema using the table data. This is called multiple times so there is room for\n+    // optimizing here.\n+    // - When we are executing the Hive query in the execution engine - We do not want to load the table data on every\n+    // executor, but serDeProperties are populated by HiveIcebergStorageHandler.configureInputJobProperties() and\n+    // the resulting properties are serialized and distributed to the executors\n+\n     Schema tableSchema;\n     if (configuration.get(InputFormatConfig.TABLE_SCHEMA) != null) {\n       tableSchema = SchemaParser.fromJson(configuration.get(InputFormatConfig.TABLE_SCHEMA));\n     } else {\n-      Table table = Catalogs.loadTable(configuration, serDeProperties);\n-      tableSchema = table.schema();\n+      if (serDeProperties.get(InputFormatConfig.TABLE_SCHEMA) != null) {", "originalCommit": "6f798bed7101bf2b4eceb079c4b6dc96ab87a77d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyNjg0MQ==", "url": "https://github.com/apache/iceberg/pull/1495#discussion_r503726841", "bodyText": "Done.", "author": "pvary", "createdAt": "2020-10-13T07:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NDE4Mw=="}], "type": "inlineReview"}, {"oid": "c787816b029d10ab9f7882b8ca7edf8795b05c71", "url": "https://github.com/apache/iceberg/commit/c787816b029d10ab9f7882b8ca7edf8795b05c71", "message": "HiveMetaHook implementation to enable CREATE TABLE and DROP TABLE from Hive queries\n\n(cherry picked from commit c242616c90fce03e0074c3b9cb218bc77fe66469)", "committedDate": "2020-10-13T07:09:34Z", "type": "commit"}, {"oid": "fcd54062732fbc5a9d84eac9fd15daa9c98d197b", "url": "https://github.com/apache/iceberg/commit/fcd54062732fbc5a9d84eac9fd15daa9c98d197b", "message": "Addressed review comments\n\n(cherry picked from commit bc13a60e8987e53828b1f5c6cd3dd1f2654c1e57)", "committedDate": "2020-10-13T07:09:34Z", "type": "commit"}, {"oid": "734fc5deedead33e1f65a09ff9dc0281f846c687", "url": "https://github.com/apache/iceberg/commit/734fc5deedead33e1f65a09ff9dc0281f846c687", "message": "Fix for partitionspec handling and tests for it", "committedDate": "2020-10-13T07:09:34Z", "type": "commit"}, {"oid": "ffc108bb023644ac34c293564b90245a15be8a74", "url": "https://github.com/apache/iceberg/commit/ffc108bb023644ac34c293564b90245a15be8a74", "message": "Store and remove TABLE_CREATION_FROM_HIVE property in HMS", "committedDate": "2020-10-13T07:09:34Z", "type": "commit"}, {"oid": "f57c5a18efcacdb91f4ebfab401372baa62dea76", "url": "https://github.com/apache/iceberg/commit/f57c5a18efcacdb91f4ebfab401372baa62dea76", "message": "Fix checkstyle", "committedDate": "2020-10-13T07:09:34Z", "type": "commit"}, {"oid": "2756a51f6e35c6bf5e58096ad488310be6685353", "url": "https://github.com/apache/iceberg/commit/2756a51f6e35c6bf5e58096ad488310be6685353", "message": "Handling external.table.purge", "committedDate": "2020-10-13T07:09:34Z", "type": "commit"}, {"oid": "c0dcfb2bc49626823851d0cd3c32c7e7dd57fcea", "url": "https://github.com/apache/iceberg/commit/c0dcfb2bc49626823851d0cd3c32c7e7dd57fcea", "message": "Reworked createTable from Hive", "committedDate": "2020-10-13T07:09:34Z", "type": "commit"}, {"oid": "b9e88d54c0f6df53714b46cca5bc969209a4f4b9", "url": "https://github.com/apache/iceberg/commit/b9e88d54c0f6df53714b46cca5bc969209a4f4b9", "message": "Fixed drop table issue with HiveCatalog", "committedDate": "2020-10-13T07:09:34Z", "type": "commit"}, {"oid": "274c72c2735e8df010c484941a610106dd442f38", "url": "https://github.com/apache/iceberg/commit/274c72c2735e8df010c484941a610106dd442f38", "message": "Removed unused imports", "committedDate": "2020-10-13T07:09:34Z", "type": "commit"}, {"oid": "6aaaee4d48d1bfb5a384242bfc20305dd627922d", "url": "https://github.com/apache/iceberg/commit/6aaaee4d48d1bfb5a384242bfc20305dd627922d", "message": "Moved drop tables to the @After method", "committedDate": "2020-10-13T07:09:34Z", "type": "commit"}, {"oid": "947620e6d6ae9e6f09aec1a4d3c9a791cb2483d3", "url": "https://github.com/apache/iceberg/commit/947620e6d6ae9e6f09aec1a4d3c9a791cb2483d3", "message": "Enable hive engine for tests for storageHandler tests too", "committedDate": "2020-10-13T07:09:35Z", "type": "commit"}, {"oid": "48477598ef2fad16c7acb0c6681d05d564091929", "url": "https://github.com/apache/iceberg/commit/48477598ef2fad16c7acb0c6681d05d564091929", "message": "Enable hive engine for tables created by the Hook", "committedDate": "2020-10-13T07:09:35Z", "type": "commit"}, {"oid": "0e26dd231f6e1c1cf0e3fd390fb8a51099f19e0b", "url": "https://github.com/apache/iceberg/commit/0e26dd231f6e1c1cf0e3fd390fb8a51099f19e0b", "message": "Cleaned up code after too many local fixes\n- Production code change: For HiveCatalog do not try to load the table in preCreateTable - it should not exist anyway\n- Test code:\n    - Remove stat related table properties when checking\n    - Remove needToCheckSnapshotLocation() use Catalogs.hiveCatalog instead\n    - Add new test to check Hive table creation above existing Iceberg table\n    - locationForCreateTable for HadoopTable should use the same as createIcebergTable method", "committedDate": "2020-10-13T07:09:35Z", "type": "commit"}, {"oid": "4fd871d7d0332057bb2f0d5a046c440da7522cb8", "url": "https://github.com/apache/iceberg/commit/4fd871d7d0332057bb2f0d5a046c440da7522cb8", "message": "Using the new metastore in tests", "committedDate": "2020-10-13T07:09:35Z", "type": "commit"}, {"oid": "085ffb9fbc19b4edb92e1945ba5804e8b87c6444", "url": "https://github.com/apache/iceberg/commit/085ffb9fbc19b4edb92e1945ba5804e8b87c6444", "message": "Revert to AlreadyExistsException for concurrent commits to the table", "committedDate": "2020-10-13T07:09:35Z", "type": "commit"}, {"oid": "5ca165efbe9430e16c2d7713ee42ff435bc25752", "url": "https://github.com/apache/iceberg/commit/5ca165efbe9430e16c2d7713ee42ff435bc25752", "message": "Reverted to create the HMS client anyway, since we use it to clean the HMS after every test", "committedDate": "2020-10-13T07:09:35Z", "type": "commit"}, {"oid": "f3bf7f3ed9e409e79ebf6a2add30d0be92198a4e", "url": "https://github.com/apache/iceberg/commit/f3bf7f3ed9e409e79ebf6a2add30d0be92198a4e", "message": "Move to client-pool", "committedDate": "2020-10-13T07:09:35Z", "type": "commit"}, {"oid": "1471f2a39f30aa475a4913bed20af450d6da70b4", "url": "https://github.com/apache/iceberg/commit/1471f2a39f30aa475a4913bed20af450d6da70b4", "message": "Fixed Hive3 test failures", "committedDate": "2020-10-13T07:09:35Z", "type": "commit"}, {"oid": "4296e4566652b982daeb4c58f1474141c7fb55e9", "url": "https://github.com/apache/iceberg/commit/4296e4566652b982daeb4c58f1474141c7fb55e9", "message": "Fixing rebase errors", "committedDate": "2020-10-13T07:09:35Z", "type": "commit"}, {"oid": "2a500084bf7e32b6528e8cc78d2c85ff103df067", "url": "https://github.com/apache/iceberg/commit/2a500084bf7e32b6528e8cc78d2c85ff103df067", "message": "Else if formatting", "committedDate": "2020-10-13T07:20:40Z", "type": "commit"}, {"oid": "2a500084bf7e32b6528e8cc78d2c85ff103df067", "url": "https://github.com/apache/iceberg/commit/2a500084bf7e32b6528e8cc78d2c85ff103df067", "message": "Else if formatting", "committedDate": "2020-10-13T07:20:40Z", "type": "forcePushed"}]}