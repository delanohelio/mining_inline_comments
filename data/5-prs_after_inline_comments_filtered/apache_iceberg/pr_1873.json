{"pr_number": 1873, "pr_title": "Hive: Make lock check retries backoff exponentially", "pr_createdAt": "2020-12-04T03:09:46Z", "pr_url": "https://github.com/apache/iceberg/pull/1873", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535925641", "bodyText": "Might worth to mention in the documentation, or somewhere that this should be smaller than hive.txn.timeout or in newer versions metastore.txn.timeout otherwise the locks might be timed out without because of the lack of heartbeat.", "author": "pvary", "createdAt": "2020-12-04T08:38:25Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds", "originalCommit": "b201863396dd365ec64d33a43aefa776e23c1cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4ODc4Mg==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535988782", "bodyText": "We should also add these configs to configuration.md to the rest of Hadoop conf, @raptond.", "author": "aokolnychyi", "createdAt": "2020-12-04T10:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MTYzNQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536251635", "bodyText": "The Glue catalog is introducing support for a lock using DynamoDB. It would be nice to standardize these options across catalogs so that we only need to document them once and they work the same way. FYI @jackye1995.\nI think it would also make sense for these to be catalog options, rather than pulled from the Hive configuration. We used HiveConf originally because we didn't have catalog-specific configuration, but now I think it would make sense to move these into catalog properties. We don't want to increase the cases where we use a Hadoop Configuration.", "author": "rdblue", "createdAt": "2020-12-04T17:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI3MDY3NQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536270675", "bodyText": "Yes agree. But Hive is currently built around reading from Hadoop configs. If we want to change it to use catalog properties, we need to also change all the places that loads HiveCatalog using the constructor public HiveCatalog(Configuration conf), such as https://github.com/apache/iceberg/blob/master/mr/src/main/java/org/apache/iceberg/mr/Catalogs.java#L215", "author": "jackye1995", "createdAt": "2020-12-04T17:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM4MTcxOA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536381718", "bodyText": "This API is also used from Spark 2 where we don't have a way to specify catalog options. Plus, we already have a Hadoop conf for the lock timeout. How do we approach this?", "author": "aokolnychyi", "createdAt": "2020-12-04T21:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM4MjA5Nw==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536382097", "bodyText": "That being said, I am +1 for adding catalog options. I am just not sure we can get rid of Hadoop conf completely in this case.", "author": "aokolnychyi", "createdAt": "2020-12-04T21:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwMjI2NA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536402264", "bodyText": "In that case, we should default from Configuration, but prefer options passed to the initialize method.", "author": "rdblue", "createdAt": "2020-12-04T21:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExMjE0MA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539112140", "bodyText": "@aokolnychyi @pvary -", "author": "raptond", "createdAt": "2020-12-09T08:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2ODkzMw==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r540368933", "bodyText": "To make sure I got @rdblue and @jackye1995. You are talking about generalizing catalog options, right?", "author": "aokolnychyi", "createdAt": "2020-12-10T17:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNTY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkzNTk3Mw==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535935973", "bodyText": "nit: Could we use VisibleForTesting annotation here?", "author": "pvary", "createdAt": "2020-12-04T08:54:49Z", "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveMetastore.java", "diffHunk": "@@ -84,7 +84,7 @@\n   private ExecutorService executorService;\n   private TServer server;\n   private HiveMetaStore.HMSHandler baseHandler;\n-  private HiveClientPool clientPool;\n+  protected HiveClientPool clientPool; // Exposed for testing.", "originalCommit": "b201863396dd365ec64d33a43aefa776e23c1cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3ODQxNQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539078415", "bodyText": "Since this was a test class, I didn't add this annotation. I finally ended up not using it, so I reverted back the change. Thanks for the review.", "author": "raptond", "createdAt": "2020-12-09T07:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkzNTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MjUxOQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535992519", "bodyText": "nit: it seems we use it only in one place. Would it make sense to just call throw new there?", "author": "aokolnychyi", "createdAt": "2020-12-04T10:22:00Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n+  private static final double HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT = 1.5;\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  protected static class WaitingForLockException extends RuntimeException {\n+    public WaitingForLockException(String message) {\n+      super(message);\n+    }\n+  }\n+\n+  private static final WaitingForLockException WAITING_FOR_LOCK_EXCEPTION =", "originalCommit": "b201863396dd365ec64d33a43aefa776e23c1cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MjAyNQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536252025", "bodyText": "I agree. What is the purpose of having a single instance of an exception? Wouldn't that lead to deceptive stack traces?", "author": "rdblue", "createdAt": "2020-12-04T17:17:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MjUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0ODI5MA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536348290", "bodyText": "It's not needed to be a single instance and holding a different stack trace than where it originated. I'll fix this.", "author": "raptond", "createdAt": "2020-12-04T20:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MjUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MzgxNQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r535993815", "bodyText": "Why protected?", "author": "aokolnychyi", "createdAt": "2020-12-04T10:24:08Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -70,21 +72,38 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR = \"iceberg.hive.lock-check-backoff-scale-factor\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n+  private static final double HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT = 1.5;\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  protected static class WaitingForLockException extends RuntimeException {", "originalCommit": "b201863396dd365ec64d33a43aefa776e23c1cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTc1Ng==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536255756", "bodyText": "I agree. If this is always caught, it should be private.", "author": "rdblue", "createdAt": "2020-12-04T17:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MzgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0ODQ2Mg==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536348462", "bodyText": "It's a miss from using in a testing. Fixing it.", "author": "raptond", "createdAt": "2020-12-04T20:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MzgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NTM4MA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536165380", "bodyText": "Why - 100?", "author": "RussellSpitzer", "createdAt": "2020-12-04T15:07:26Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".", "originalCommit": "b201863396dd365ec64d33a43aefa776e23c1cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MjI2Ng==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538772266", "bodyText": "I only wanted to keep a big number for retry.  Eg Integer.MAX_VALUE. But, the setter adds 1 overflowing to MIN_VALUE.\nInteger.MAX_VALUE - 1 would simply suffice, but I chose conservatively to set Integer.MAX_VALUE - 100.", "author": "raptond", "createdAt": "2020-12-08T20:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NTM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1MTg5OQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538851899", "bodyText": "I think it would be worth noting the rational for a choice like this in a comment.", "author": "rdblue", "createdAt": "2020-12-08T22:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NTM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NTgyNg==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539075826", "bodyText": "\ud83d\udc4d +1 I have added the rationale in the comments.", "author": "raptond", "createdAt": "2020-12-09T07:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NTM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2ODM3MQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536168371", "bodyText": "Is InterruptedException needed?", "author": "aokolnychyi", "createdAt": "2020-12-04T15:11:42Z", "path": "hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveCommitLocks.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.hive;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.HiveMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.LockResponse;\n+import org.apache.hadoop.hive.metastore.api.LockState;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.HasTableOperations;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.types.Types;\n+import org.apache.thrift.TException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+public class TestHiveCommitLocks extends HiveTableBaseTest {\n+  HiveTableOperations ops = null;\n+  HiveTableOperations spyOps = null;\n+  HiveClientPool spyClientPool = null;\n+  HiveMetaStoreClient spyClient = null;\n+  TableMetadata metadataV1 = null;\n+  TableMetadata metadataV2 = null;\n+\n+  long dummyLockId = 500L;\n+  LockResponse waitLockResponse = new LockResponse(dummyLockId, LockState.WAITING);\n+  LockResponse acquiredLockResponse = new LockResponse(dummyLockId, LockState.ACQUIRED);\n+  LockResponse notAcquiredLockResponse = new LockResponse(dummyLockId, LockState.NOT_ACQUIRED);\n+\n+  @Before\n+  public void before() throws Exception {\n+    Table table = catalog.loadTable(TABLE_IDENTIFIER);\n+    ops = (HiveTableOperations) ((HasTableOperations) table).operations();\n+    String dbName = TABLE_IDENTIFIER.namespace().level(0);\n+    String tableName = TABLE_IDENTIFIER.name();\n+    Configuration overriddenHiveConf = new Configuration(hiveConf);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-timeout-ms\", 10 * 1000);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-check-min-wait-ms\", 50);\n+    overriddenHiveConf.setLong(\"iceberg.hive.lock-check-max-wait-ms\", 5 * 1000);\n+    overriddenHiveConf.setDouble(\"iceberg.hive.lock-check-backoff-scale-factor\", 3.0);\n+\n+    metadataV1 = ops.current();\n+\n+    table.updateSchema()\n+        .addColumn(\"n\", Types.IntegerType.get())\n+        .commit();\n+\n+    ops.refresh();\n+\n+    metadataV2 = ops.current();\n+\n+    Assert.assertEquals(2, ops.current().schema().columns().size());\n+\n+    spyClientPool = spy(new HiveClientPool(1, overriddenHiveConf));\n+    AtomicReference<HiveMetaStoreClient> spyClientRef = new AtomicReference<>();\n+\n+    when(spyClientPool.newClient()).thenAnswer(invocation -> {\n+      HiveMetaStoreClient client = (HiveMetaStoreClient) invocation.callRealMethod();\n+      spyClientRef.set(spy(client));\n+      return spyClientRef.get();\n+    });\n+\n+    spyOps = spy(new HiveTableOperations(overriddenHiveConf, spyClientPool, ops.io(), catalog.name(),\n+        dbName, tableName));\n+    spyClientPool.run(client -> client.isLocalMetaStore()); // To ensure new client is created.\n+    Assert.assertNotNull(spyClientRef.get());\n+\n+    spyClient = spyClientRef.get();\n+  }\n+\n+  @After\n+  public void cleanup() {\n+    try {\n+      spyClientPool.close();\n+    } catch (Throwable t) {\n+      // Ignore any exception\n+    }\n+  }\n+\n+  @Test\n+  public void testLockAcquisitionAtFirstTime() throws TException, InterruptedException {\n+    doReturn(acquiredLockResponse).when(spyClient).lock(any());\n+    doNothing().when(spyOps).doUnlock(eq(dummyLockId));\n+\n+    spyOps.doCommit(metadataV2, metadataV1);\n+\n+    Assert.assertEquals(1, spyOps.current().schema().columns().size()); // should be 1 again\n+  }\n+\n+  @Test\n+  public void testLockAcquisitionAfterRetries() throws TException, InterruptedException {", "originalCommit": "b201863396dd365ec64d33a43aefa776e23c1cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3MTQ2Mw==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539071463", "bodyText": "yes, here the HiveTableOperations.doUnlock method throws InterruptedException.", "author": "raptond", "createdAt": "2020-12-09T07:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2ODM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE3MDAyOQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536170029", "bodyText": "nit: extra empty line", "author": "aokolnychyi", "createdAt": "2020-12-04T15:14:00Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -96,7 +115,14 @@ protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, Fi\n     this.database = database;\n     this.tableName = table;\n     this.lockAcquireTimeout =\n-        conf.getLong(HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT);\n+        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT);\n+    this.lockCheckMinWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n+    this.lockCheckMaxWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MAX_WAIT_MS, HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT);\n+    this.lockCheckBackoffScaleFactor =\n+        conf.getDouble(HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR, HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT);\n+", "originalCommit": "b201863396dd365ec64d33a43aefa776e23c1cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NTk2OQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539075969", "bodyText": "taken care.", "author": "raptond", "createdAt": "2020-12-09T07:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE3MDAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MzI1MA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536253250", "bodyText": "We don't expose the scale factor in other places. I think it makes sense to keep it simple and not have one here either.", "author": "rdblue", "createdAt": "2020-12-04T17:19:24Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -96,7 +115,14 @@ protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, Fi\n     this.database = database;\n     this.tableName = table;\n     this.lockAcquireTimeout =\n-        conf.getLong(HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT);\n+        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT);\n+    this.lockCheckMinWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n+    this.lockCheckMaxWaitTime =\n+        conf.getLong(HIVE_LOCK_CHECK_MAX_WAIT_MS, HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT);\n+    this.lockCheckBackoffScaleFactor =\n+        conf.getDouble(HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR, HIVE_LOCK_CHECK_BACKOFF_SCALE_FACTOR_DEFAULT);", "originalCommit": "b201863396dd365ec64d33a43aefa776e23c1cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDkzMA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536354930", "bodyText": "I'll remove the scale factor.", "author": "raptond", "createdAt": "2020-12-04T20:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MzI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTA0OQ==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r536255049", "bodyText": "For InterruptedException, why not throw WaitingForLockException and signal that the thread was interrupted? Then this could use the checked exception call, run(id -> {...}, TException.class) and would not need to wrap the exceptions.", "author": "rdblue", "createdAt": "2020-12-04T17:22:31Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -304,32 +330,57 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".\n+            .exponentialBackoff(\n+                lockCheckMinWaitTime,\n+                lockCheckMaxWaitTime,\n+                lockAcquireTimeout,\n+                lockCheckBackoffScaleFactor)\n+            .throwFailureWhenFinished()\n+            .onlyRetryOn(WaitingForLockException.class)\n+            .run(id -> {\n+              try {\n+                LockResponse response = metaClients.run(client -> client.checkLock(id));\n+                LockState newState = response.getState();\n+                state.set(newState);\n+                if (newState.equals(LockState.WAITING)) {\n+                  throw WAITING_FOR_LOCK_EXCEPTION;\n+                }\n+              } catch (InterruptedException | TException e) {", "originalCommit": "b201863396dd365ec64d33a43aefa776e23c1cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MjkxMA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538762910", "bodyText": "The code looks better after this comment. However throwing WaitingForLockException ends up losing the source of the original InterruptedException because it would get handled here: https://github.com/apache/iceberg/blob/master/core/src/main/java/org/apache/iceberg/util/Tasks.java#L452\nSo, I chose to throw RuntimeException which will stop the retry and preserve the source stack trace.", "author": "raptond", "createdAt": "2020-12-08T19:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NTE4Mw==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538895183", "bodyText": "I'd probably opt to suppress the interrupt and let the code carry on after setting that the thread was interrupted. That results in a CommitFailedException. I don't think that preserving the stack of the InterruptedException is really needed, but I'm fin with it this way if you prefer it.", "author": "rdblue", "createdAt": "2020-12-08T23:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NzgxMA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539077810", "bodyText": "Taken care as per the other comment.", "author": "raptond", "createdAt": "2020-12-09T07:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTA0OQ=="}], "type": "inlineReview"}, {"oid": "599b679904933640a0bd12db790722beeb015626", "url": "https://github.com/apache/iceberg/commit/599b679904933640a0bd12db790722beeb015626", "message": "Hive: Make lock check retries backoff exponentially\n\n50 milliseconds (constant) sleep time between \"checking lock status\" thrashes hive metastore databases when multiple jobs try to commit to the same Iceberg table. This fix allows the frequency of \"checking the WAITING lock status\" configurable and makes use of Tasks to backoff exponentially.", "committedDate": "2020-12-08T19:29:18Z", "type": "commit"}, {"oid": "c53108c2c8271d1679ecff60de4df249339c8f5f", "url": "https://github.com/apache/iceberg/commit/c53108c2c8271d1679ecff60de4df249339c8f5f", "message": "Fix review comments", "committedDate": "2020-12-08T19:29:19Z", "type": "commit"}, {"oid": "c53108c2c8271d1679ecff60de4df249339c8f5f", "url": "https://github.com/apache/iceberg/commit/c53108c2c8271d1679ecff60de4df249339c8f5f", "message": "Fix review comments", "committedDate": "2020-12-08T19:29:19Z", "type": "forcePushed"}, {"oid": "b4dcc67ead41606389948dab7bf3ff5293981528", "url": "https://github.com/apache/iceberg/commit/b4dcc67ead41606389948dab7bf3ff5293981528", "message": "Fix checkstyle issues", "committedDate": "2020-12-08T19:52:40Z", "type": "commit"}, {"oid": "10c23b842145c0190c24b142965975e73739c077", "url": "https://github.com/apache/iceberg/commit/10c23b842145c0190c24b142965975e73739c077", "message": "Fix additional review comments", "committedDate": "2020-12-08T20:44:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NzU4NA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538857584", "bodyText": "Nit: unnecessary whitespace change.", "author": "rdblue", "createdAt": "2020-12-08T22:31:50Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -66,33 +68,50 @@\n public class HiveTableOperations extends BaseMetastoreTableOperations {\n   private static final Logger LOG = LoggerFactory.getLogger(HiveTableOperations.class);\n \n-  private static final String HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n-  private static final long HIVE_ACQUIRE_LOCK_STATE_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final String HIVE_ACQUIRE_LOCK_TIMEOUT_MS = \"iceberg.hive.lock-timeout-ms\";\n+  private static final String HIVE_LOCK_CHECK_MIN_WAIT_MS = \"iceberg.hive.lock-check-min-wait-ms\";\n+  private static final String HIVE_LOCK_CHECK_MAX_WAIT_MS = \"iceberg.hive.lock-check-max-wait-ms\";\n+  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n+  private static final long HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT = 50; // 50 milliseconds\n+  private static final long HIVE_LOCK_CHECK_MAX_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds\n   private static final DynMethods.UnboundMethod ALTER_TABLE = DynMethods.builder(\"alter_table\")\n       .impl(HiveMetaStoreClient.class, \"alter_table_with_environmentContext\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .impl(HiveMetaStoreClient.class, \"alter_table\",\n           String.class, String.class, Table.class, EnvironmentContext.class)\n       .build();\n \n+  private static class WaitingForLockException extends RuntimeException {\n+    WaitingForLockException(String message) {\n+      super(message);\n+    }\n+  }\n+\n   private final HiveClientPool metaClients;\n   private final String fullName;\n   private final String database;\n   private final String tableName;\n   private final Configuration conf;\n   private final long lockAcquireTimeout;\n+  private final long lockCheckMinWaitTime;\n+  private final long lockCheckMaxWaitTime;\n   private final FileIO fileIO;\n \n   protected HiveTableOperations(Configuration conf, HiveClientPool metaClients, FileIO fileIO,\n-                                String catalogName, String database, String table) {\n+      String catalogName, String database, String table) {", "originalCommit": "b4dcc67ead41606389948dab7bf3ff5293981528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExNjA3Mw==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539116073", "bodyText": "done.", "author": "raptond", "createdAt": "2020-12-09T08:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NzU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MzkxNA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r538893914", "bodyText": "I don't think it is necessary to throw RuntimeException here. If this doesn't throw WaitingForLockException then it will exit and move on. Since timeout is not set, it would hit the check for whether the lock was acquired and fail, resulting in the CommitFailedException.\nI think that's a fairly reasonable way to handle an interrupt without wrapping it in a RuntimeException.", "author": "rdblue", "createdAt": "2020-12-08T23:43:12Z", "path": "hive-metastore/src/main/java/org/apache/iceberg/hive/HiveTableOperations.java", "diffHunk": "@@ -294,32 +313,50 @@ private long acquireLock() throws UnknownHostException, TException, InterruptedE\n         System.getProperty(\"user.name\"),\n         InetAddress.getLocalHost().getHostName());\n     LockResponse lockResponse = metaClients.run(client -> client.lock(lockRequest));\n-    LockState state = lockResponse.getState();\n+    AtomicReference<LockState> state = new AtomicReference<>(lockResponse.getState());\n     long lockId = lockResponse.getLockid();\n \n     final long start = System.currentTimeMillis();\n     long duration = 0;\n     boolean timeout = false;\n-    while (!timeout && state.equals(LockState.WAITING)) {\n-      lockResponse = metaClients.run(client -> client.checkLock(lockId));\n-      state = lockResponse.getState();\n \n-      // check timeout\n-      duration = System.currentTimeMillis() - start;\n-      if (duration > lockAcquireTimeout) {\n+    if (state.get().equals(LockState.WAITING)) {\n+      try {\n+        Tasks.foreach(lockId)\n+            .retry(Integer.MAX_VALUE - 100) // Endless retries bound by timeouts. Tasks.retry adds 1 for \"first try\".\n+            .exponentialBackoff(\n+                lockCheckMinWaitTime,\n+                lockCheckMaxWaitTime,\n+                lockAcquireTimeout,\n+                1.5)\n+            .throwFailureWhenFinished()\n+            .onlyRetryOn(WaitingForLockException.class)\n+            .run(id -> {\n+              try {\n+                LockResponse response = metaClients.run(client -> client.checkLock(id));\n+                LockState newState = response.getState();\n+                state.set(newState);\n+                if (newState.equals(LockState.WAITING)) {\n+                  throw new WaitingForLockException(\"Waiting for lock.\");\n+                }\n+              } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(\"Interrupted while checking lock status.\", e);", "originalCommit": "b4dcc67ead41606389948dab7bf3ff5293981528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NzM2MA==", "url": "https://github.com/apache/iceberg/pull/1873#discussion_r539077360", "bodyText": "You are correct. I was fixated on failing the execution. This suggestion works nicely and I have a test case for this. Thank you.", "author": "raptond", "createdAt": "2020-12-09T07:45:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MzkxNA=="}], "type": "inlineReview"}, {"oid": "e1f4d48efe87a0c9e83c66486dd1d0d6ac02c6ae", "url": "https://github.com/apache/iceberg/commit/e1f4d48efe87a0c9e83c66486dd1d0d6ac02c6ae", "message": "More review comments addressed.", "committedDate": "2020-12-09T07:40:46Z", "type": "commit"}, {"oid": "e1f4d48efe87a0c9e83c66486dd1d0d6ac02c6ae", "url": "https://github.com/apache/iceberg/commit/e1f4d48efe87a0c9e83c66486dd1d0d6ac02c6ae", "message": "More review comments addressed.", "committedDate": "2020-12-09T07:40:46Z", "type": "forcePushed"}, {"oid": "bb828ba5b940a821fd18cf11306ead5df2710ca3", "url": "https://github.com/apache/iceberg/commit/bb828ba5b940a821fd18cf11306ead5df2710ca3", "message": "Remove unused import", "committedDate": "2020-12-09T07:49:18Z", "type": "commit"}, {"oid": "bbc91e6caf62d3640af838f3489e73ff2a168680", "url": "https://github.com/apache/iceberg/commit/bbc91e6caf62d3640af838f3489e73ff2a168680", "message": "Add a note on iceberg.hive.lock-check-max-wait-ms", "committedDate": "2020-12-09T08:41:09Z", "type": "commit"}]}