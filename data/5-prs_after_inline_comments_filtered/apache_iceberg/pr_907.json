{"pr_number": 907, "pr_title": "Add v2 manifest lists", "pr_createdAt": "2020-04-09T19:18:08Z", "pr_url": "https://github.com/apache/iceberg/pull/907", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4ODAzNQ==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r406488035", "bodyText": "Moved into TestManifestFileVersions.", "author": "rdblue", "createdAt": "2020-04-09T21:28:57Z", "path": "core/src/test/java/org/apache/iceberg/TestGenericManifestFile.java", "diffHunk": "@@ -1,91 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.iceberg;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.Collection;\n-import org.apache.iceberg.avro.Avro;\n-import org.apache.iceberg.io.CloseableIterable;\n-import org.apache.iceberg.io.FileAppender;\n-import org.apache.iceberg.io.FileIO;\n-import org.apache.iceberg.io.InputFile;\n-import org.apache.iceberg.io.OutputFile;\n-import org.junit.Assert;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n-\n-public class TestGenericManifestFile {\n-\n-  private static final FileIO FILE_IO = new TestTables.LocalFileIO();\n-\n-  @Rule\n-  public TemporaryFolder temp = new TemporaryFolder();\n-\n-  @Test\n-  public void testManifestsWithoutRowStats() throws IOException {", "originalCommit": "456f2caca7da973c5147642b7534b0e8956b9720", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDQ2MA==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r406970460", "bodyText": "I'm going to move the schemas to a different file to avoid leaking them in the API, but I'll leave the schema method that returns the current unified read schema.", "author": "rdblue", "createdAt": "2020-04-10T22:35:55Z", "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -30,25 +30,62 @@\n  * Represents a manifest file that can be scanned to find data files in a table.\n  */\n public interface ManifestFile {\n-  Schema SCHEMA = new Schema(\n-      required(500, \"manifest_path\", Types.StringType.get()),\n-      required(501, \"manifest_length\", Types.LongType.get()),\n-      required(502, \"partition_spec_id\", Types.IntegerType.get()),\n-      optional(503, \"added_snapshot_id\", Types.LongType.get()),\n-      optional(504, \"added_data_files_count\", Types.IntegerType.get()),\n-      optional(505, \"existing_data_files_count\", Types.IntegerType.get()),\n-      optional(506, \"deleted_data_files_count\", Types.IntegerType.get()),\n-      optional(507, \"partitions\", Types.ListType.ofRequired(508, Types.StructType.of(\n-          required(509, \"contains_null\", Types.BooleanType.get()),\n-          optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n-          optional(511, \"upper_bound\", Types.BinaryType.get())\n-      ))),\n-      optional(512, \"added_rows_count\", Types.LongType.get()),\n-      optional(513, \"existing_rows_count\", Types.LongType.get()),\n-      optional(514, \"deleted_rows_count\", Types.LongType.get()));\n+  Types.NestedField PATH = required(500, \"manifest_path\", Types.StringType.get());", "originalCommit": "456f2caca7da973c5147642b7534b0e8956b9720", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "220c6a5d6dd51dba021768ad9dd908e99cf901ef", "url": "https://github.com/apache/iceberg/commit/220c6a5d6dd51dba021768ad9dd908e99cf901ef", "message": "Add v2 manifest lists.\n\n* Update GenericManifestFile to v2 schema\n* Update v1 manifest list writer to use the v1 schema\n* Add a v2 manifest list writer\n* Add tests for v1 and v2 manifest list formats", "committedDate": "2020-04-10T23:29:16Z", "type": "forcePushed"}, {"oid": "3b2fbd0932f37cf32e250f39c9e783c8ee27e455", "url": "https://github.com/apache/iceberg/commit/3b2fbd0932f37cf32e250f39c9e783c8ee27e455", "message": "Add v2 manifest lists.\n\n* Update GenericManifestFile to v2 schema\n* Update v1 manifest list writer to use the v1 schema\n* Add a v2 manifest list writer\n* Add tests for v1 and v2 manifest list formats", "committedDate": "2020-04-11T20:37:57Z", "type": "commit"}, {"oid": "ba51ddace40fb313e7bba9930c0ab5206b402835", "url": "https://github.com/apache/iceberg/commit/ba51ddace40fb313e7bba9930c0ab5206b402835", "message": "Write ManifestFile sequence number in v2 writer.", "committedDate": "2020-04-11T20:37:57Z", "type": "commit"}, {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6", "url": "https://github.com/apache/iceberg/commit/f5644567a13f94ce7a8e2eb820281080eff603c6", "message": "Make static metadata variables final.", "committedDate": "2020-04-11T20:37:57Z", "type": "commit"}, {"oid": "f5644567a13f94ce7a8e2eb820281080eff603c6", "url": "https://github.com/apache/iceberg/commit/f5644567a13f94ce7a8e2eb820281080eff603c6", "message": "Make static metadata variables final.", "committedDate": "2020-04-11T20:37:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzU2MA==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408423560", "bodyText": "I remember we had issues with reordering fields in ManifestFile as GenericAvroWriter was using ordinal positions instead of field ids. Did we solve that?", "author": "aokolnychyi", "createdAt": "2020-04-14T20:44:13Z", "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -30,22 +30,33 @@\n  * Represents a manifest file that can be scanned to find data files in a table.\n  */\n public interface ManifestFile {\n+  Types.NestedField PATH = required(500, \"manifest_path\", Types.StringType.get());\n+  Types.NestedField LENGTH = required(501, \"manifest_length\", Types.LongType.get());\n+  Types.NestedField SPEC_ID = required(502, \"partition_spec_id\", Types.IntegerType.get());\n+  Types.NestedField SNAPSHOT_ID = optional(503, \"added_snapshot_id\", Types.LongType.get());\n+  Types.NestedField ADDED_FILES_COUNT = optional(504, \"added_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField EXISTING_FILES_COUNT = optional(505, \"existing_data_files_count\", Types.IntegerType.get());\n+  Types.NestedField DELETED_FILES_COUNT = optional(506, \"deleted_data_files_count\", Types.IntegerType.get());\n+  Types.StructType PARTITION_SUMMARY_TYPE = Types.StructType.of(\n+      required(509, \"contains_null\", Types.BooleanType.get()),\n+      optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n+      optional(511, \"upper_bound\", Types.BinaryType.get())\n+  );\n+  Types.NestedField PARTITION_SUMMARIES = optional(507, \"partitions\",\n+      Types.ListType.ofRequired(508, PARTITION_SUMMARY_TYPE));\n+  Types.NestedField ADDED_ROWS_COUNT = optional(512, \"added_rows_count\", Types.LongType.get());\n+  Types.NestedField EXISTING_ROWS_COUNT = optional(513, \"existing_rows_count\", Types.LongType.get());\n+  Types.NestedField DELETED_ROWS_COUNT = optional(514, \"deleted_rows_count\", Types.LongType.get());\n+  Types.NestedField SEQUENCE_NUMBER = optional(515, \"sequence_number\", Types.LongType.get());\n+  Types.NestedField MIN_SEQUENCE_NUMBER = optional(516, \"min_sequence_number\", Types.LongType.get());\n+  // next ID to assign: 517\n+\n   Schema SCHEMA = new Schema(\n-      required(500, \"manifest_path\", Types.StringType.get()),\n-      required(501, \"manifest_length\", Types.LongType.get()),\n-      required(502, \"partition_spec_id\", Types.IntegerType.get()),\n-      optional(503, \"added_snapshot_id\", Types.LongType.get()),\n-      optional(504, \"added_data_files_count\", Types.IntegerType.get()),\n-      optional(505, \"existing_data_files_count\", Types.IntegerType.get()),\n-      optional(506, \"deleted_data_files_count\", Types.IntegerType.get()),\n-      optional(507, \"partitions\", Types.ListType.ofRequired(508, Types.StructType.of(\n-          required(509, \"contains_null\", Types.BooleanType.get()),\n-          optional(510, \"lower_bound\", Types.BinaryType.get()), // null if no non-null values\n-          optional(511, \"upper_bound\", Types.BinaryType.get())\n-      ))),\n-      optional(512, \"added_rows_count\", Types.LongType.get()),\n-      optional(513, \"existing_rows_count\", Types.LongType.get()),\n-      optional(514, \"deleted_rows_count\", Types.LongType.get()));\n+      PATH, LENGTH, SPEC_ID,", "originalCommit": "f5644567a13f94ce7a8e2eb820281080eff603c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NjEyMQ==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408456121", "bodyText": "I see this is handled in V1Metadata.", "author": "aokolnychyi", "createdAt": "2020-04-14T21:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MzYyNQ==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408473625", "bodyText": "Yeah, the IndexedRecord field order needs to match the schema order. This is why I added a test for this as well.", "author": "rdblue", "createdAt": "2020-04-14T22:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyOTA5Nw==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408429097", "bodyText": "Even though it was public, I don't think anyone is using it. Seems OK to change.", "author": "aokolnychyi", "createdAt": "2020-04-14T20:54:34Z", "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "diffHunk": "@@ -100,32 +101,17 @@ public GenericManifestFile(org.apache.avro.Schema avroSchema) {\n     this.fromProjectionPos = null;\n   }\n \n-  public GenericManifestFile(String path, long length, int specId, Long snapshotId,", "originalCommit": "f5644567a13f94ce7a8e2eb820281080eff603c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NDU3NQ==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408474575", "bodyText": "Yeah, this should be fine. Classes in core are only semi-public and not part of the API. That module has stronger guarantees.", "author": "rdblue", "createdAt": "2020-04-14T22:32:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyOTA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMTIyMQ==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408431221", "bodyText": "Is this empty line intentional?", "author": "aokolnychyi", "createdAt": "2020-04-14T20:58:44Z", "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "diffHunk": "@@ -84,23 +69,67 @@ public long length() {\n     return writer.length();\n   }\n \n-  private static FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n-    try {\n-      return Avro.write(file)\n-          .schema(ManifestFile.schema())\n-          .named(\"manifest_file\")\n-          .meta(meta)\n-          .overwrite()\n-          .build();\n-\n-    } catch (IOException e) {\n-      throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+  static class V2Writer extends ManifestListWriter {\n+    private final V2Metadata.IndexedManifestFile wrapper;\n+\n+    V2Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId, long sequenceNumber) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"sequence-number\", String.valueOf(sequenceNumber),\n+          \"format-version\", \"2\"));\n+      this.wrapper = new V2Metadata.IndexedManifestFile(sequenceNumber);\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    @Override\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V2Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n \n   static class V1Writer extends ManifestListWriter {\n-    private V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n-      super(snapshotFile, snapshotId, parentSnapshotId);\n+    private final V1Metadata.IndexedManifestFile wrapper = new V1Metadata.IndexedManifestFile();\n+\n+    V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"format-version\", \"1\"));\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V1Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n+", "originalCommit": "f5644567a13f94ce7a8e2eb820281080eff603c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NDk2OA==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408474968", "bodyText": "No.", "author": "rdblue", "createdAt": "2020-04-14T22:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMTIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0ODUxNA==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408448514", "bodyText": "Looks like we are trying to match the new ordering of fields in ManifestFile. Earlier, we co-located ...FilesCount with ...RowsCount to match the ordering of methods in ManifestFile and args in constructors. Is this change intentional?", "author": "aokolnychyi", "createdAt": "2020-04-14T21:31:56Z", "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "diffHunk": "@@ -46,12 +46,14 @@\n   private String manifestPath = null;\n   private Long length = null;\n   private int specId = -1;\n+  private long sequenceNumber = 0;\n+  private long minSequenceNumber = 0;\n   private Long snapshotId = null;\n   private Integer addedFilesCount = null;\n-  private Long addedRowsCount = null;\n   private Integer existingFilesCount = null;\n-  private Long existingRowsCount = null;\n   private Integer deletedFilesCount = null;\n+  private Long addedRowsCount = null;", "originalCommit": "f5644567a13f94ce7a8e2eb820281080eff603c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NDM0Ng==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408474346", "bodyText": "Yes. I think it's likely that these are going to be null in some cases, like manifests that contain equality delete files. Instead of mixing null, non-null, null, non-null, etc. I think it's better to keep the probably-null columns colocated for compression.", "author": "rdblue", "createdAt": "2020-04-14T22:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0ODUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDU0OA==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408470548", "bodyText": "Seems like this is the place where we can pass a snapshot id similar to how we pass a sequence number to V2 and get rid of the logic for inheriting metadata for ManifestEntry via setSnapshotId and iterating through manifests during commit.\nDo I get it correctly, @rdblue?", "author": "aokolnychyi", "createdAt": "2020-04-14T22:21:51Z", "path": "core/src/main/java/org/apache/iceberg/ManifestListWriter.java", "diffHunk": "@@ -84,23 +69,67 @@ public long length() {\n     return writer.length();\n   }\n \n-  private static FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n-    try {\n-      return Avro.write(file)\n-          .schema(ManifestFile.schema())\n-          .named(\"manifest_file\")\n-          .meta(meta)\n-          .overwrite()\n-          .build();\n-\n-    } catch (IOException e) {\n-      throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+  static class V2Writer extends ManifestListWriter {\n+    private final V2Metadata.IndexedManifestFile wrapper;\n+\n+    V2Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId, long sequenceNumber) {\n+      super(snapshotFile, ImmutableMap.of(\n+          \"snapshot-id\", String.valueOf(snapshotId),\n+          \"parent-snapshot-id\", String.valueOf(parentSnapshotId),\n+          \"sequence-number\", String.valueOf(sequenceNumber),\n+          \"format-version\", \"2\"));\n+      this.wrapper = new V2Metadata.IndexedManifestFile(sequenceNumber);\n+    }\n+\n+    @Override\n+    protected ManifestFile prepare(ManifestFile manifest) {\n+      return wrapper.wrap(manifest);\n+    }\n+\n+    @Override\n+    protected FileAppender<ManifestFile> newAppender(OutputFile file, Map<String, String> meta) {\n+      try {\n+        return Avro.write(file)\n+            .schema(V2Metadata.MANIFEST_LIST_SCHEMA)\n+            .named(\"manifest_file\")\n+            .meta(meta)\n+            .overwrite()\n+            .build();\n+\n+      } catch (IOException e) {\n+        throw new RuntimeIOException(e, \"Failed to create snapshot list writer for path: \" + file);\n+      }\n     }\n   }\n \n   static class V1Writer extends ManifestListWriter {\n-    private V1Writer(OutputFile snapshotFile, long snapshotId, Long parentSnapshotId) {\n-      super(snapshotFile, snapshotId, parentSnapshotId);\n+    private final V1Metadata.IndexedManifestFile wrapper = new V1Metadata.IndexedManifestFile();", "originalCommit": "f5644567a13f94ce7a8e2eb820281080eff603c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NDg4NQ==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408474885", "bodyText": "Yes. I'm going to rework inheritance for snapshot ID in a separate commit.", "author": "rdblue", "createdAt": "2020-04-14T22:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4OTQwNQ==", "url": "https://github.com/apache/iceberg/pull/907#discussion_r408489405", "bodyText": "Great!", "author": "aokolnychyi", "createdAt": "2020-04-14T23:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDU0OA=="}], "type": "inlineReview"}, {"oid": "8b1e3161c03dce69a3f251255742cd097a237c66", "url": "https://github.com/apache/iceberg/commit/8b1e3161c03dce69a3f251255742cd097a237c66", "message": "Remove trailing newlines.", "committedDate": "2020-04-14T22:35:51Z", "type": "commit"}]}