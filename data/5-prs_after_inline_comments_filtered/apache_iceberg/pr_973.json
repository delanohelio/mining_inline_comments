{"pr_number": 973, "pr_title": "Push down Iceberg expressions to the ORC reader", "pr_createdAt": "2020-04-27T08:35:40Z", "pr_url": "https://github.com/apache/iceberg/pull/973", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY5OTkwOA==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r421699908", "bodyText": "Should we move the Parquet tests into the iceberg-data module as well so that we can share the test code? It would be great to use parameterized tests (with if statements to exclude cases) instead of copying so much code.", "author": "rdblue", "createdAt": "2020-05-07T18:15:06Z", "path": "data/src/test/java/org/apache/iceberg/data/orc/TestSearchArgument.java", "diffHunk": "@@ -0,0 +1,627 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.data.orc;\n+\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.io.IOException;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.io.InputFile;\n+import org.apache.iceberg.io.OutputFile;\n+import org.apache.iceberg.orc.ORC;\n+import org.apache.iceberg.types.Types;\n+import org.apache.iceberg.types.Types.FloatType;\n+import org.apache.iceberg.types.Types.IntegerType;\n+import org.apache.iceberg.types.Types.LongType;\n+import org.apache.iceberg.types.Types.StringType;\n+import org.apache.orc.OrcFile;\n+import org.apache.orc.Reader;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import static org.apache.iceberg.expressions.Expressions.and;\n+import static org.apache.iceberg.expressions.Expressions.equal;\n+import static org.apache.iceberg.expressions.Expressions.greaterThan;\n+import static org.apache.iceberg.expressions.Expressions.greaterThanOrEqual;\n+import static org.apache.iceberg.expressions.Expressions.in;\n+import static org.apache.iceberg.expressions.Expressions.isNull;\n+import static org.apache.iceberg.expressions.Expressions.lessThan;\n+import static org.apache.iceberg.expressions.Expressions.lessThanOrEqual;\n+import static org.apache.iceberg.expressions.Expressions.not;\n+import static org.apache.iceberg.expressions.Expressions.notEqual;\n+import static org.apache.iceberg.expressions.Expressions.notIn;\n+import static org.apache.iceberg.expressions.Expressions.notNull;\n+import static org.apache.iceberg.expressions.Expressions.or;\n+import static org.apache.iceberg.expressions.Expressions.startsWith;\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+public class TestSearchArgument {", "originalCommit": "181e913d95bb021e52779a5bcd2be5f49d50582c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI3MzMyMw==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r427273323", "bodyText": "Done.\nMoved TestMetricsRowGroupFilter and TestMetricsRowGroupFilterTypes into iceberg-data and merged with their ORC counterparts using parameterized tests.", "author": "shardulm94", "createdAt": "2020-05-19T12:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY5OTkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwMDM1NQ==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r421700355", "bodyText": "Does this need to be public?", "author": "rdblue", "createdAt": "2020-05-07T18:15:50Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ExpressionToSearchArgument.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.math.BigDecimal;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.util.Deque;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Bound;\n+import org.apache.iceberg.expressions.BoundPredicate;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ExpressionVisitors;\n+import org.apache.iceberg.expressions.Literal;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Type.TypeID;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.TypeDescription;\n+import org.apache.orc.storage.common.type.HiveDecimal;\n+import org.apache.orc.storage.ql.io.sarg.PredicateLeaf;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument.TruthValue;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgumentFactory;\n+import org.apache.orc.storage.serde2.io.HiveDecimalWritable;\n+\n+public class ExpressionToSearchArgument extends ExpressionVisitors.BoundVisitor<ExpressionToSearchArgument.Action> {", "originalCommit": "181e913d95bb021e52779a5bcd2be5f49d50582c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1MjU1Ng==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r424852556", "bodyText": "Fixed", "author": "shardulm94", "createdAt": "2020-05-14T03:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwMDM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwMDk0OQ==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r421700949", "bodyText": "Is there a better verb than visit to describe this? How about convert?", "author": "rdblue", "createdAt": "2020-05-07T18:16:50Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ExpressionToSearchArgument.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.math.BigDecimal;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.util.Deque;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Bound;\n+import org.apache.iceberg.expressions.BoundPredicate;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ExpressionVisitors;\n+import org.apache.iceberg.expressions.Literal;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Type.TypeID;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.TypeDescription;\n+import org.apache.orc.storage.common.type.HiveDecimal;\n+import org.apache.orc.storage.ql.io.sarg.PredicateLeaf;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument.TruthValue;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgumentFactory;\n+import org.apache.orc.storage.serde2.io.HiveDecimalWritable;\n+\n+public class ExpressionToSearchArgument extends ExpressionVisitors.BoundVisitor<ExpressionToSearchArgument.Action> {\n+\n+  static SearchArgument visit(Expression expr, TypeDescription readSchema) {", "originalCommit": "181e913d95bb021e52779a5bcd2be5f49d50582c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1MjU4OQ==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r424852589", "bodyText": "Done", "author": "shardulm94", "createdAt": "2020-05-14T03:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwMDk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwMjAwMw==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r421702003", "bodyText": "Nit: missing . at the end of this sentence. This is also a bit long for a description. What about \"Generates a map from field ID to ORC qualified name.\"", "author": "rdblue", "createdAt": "2020-05-07T18:18:44Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ExpressionToSearchArgument.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.math.BigDecimal;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.util.Deque;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Bound;\n+import org.apache.iceberg.expressions.BoundPredicate;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ExpressionVisitors;\n+import org.apache.iceberg.expressions.Literal;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Type.TypeID;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.TypeDescription;\n+import org.apache.orc.storage.common.type.HiveDecimal;\n+import org.apache.orc.storage.ql.io.sarg.PredicateLeaf;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument.TruthValue;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgumentFactory;\n+import org.apache.orc.storage.serde2.io.HiveDecimalWritable;\n+\n+public class ExpressionToSearchArgument extends ExpressionVisitors.BoundVisitor<ExpressionToSearchArgument.Action> {\n+\n+  static SearchArgument visit(Expression expr, TypeDescription readSchema) {\n+    Map<Integer, String> idToColumnName = TypeUtil.visit(ORCSchemaUtil.convert(readSchema), new IdToQuotedColumnName());\n+    SearchArgument.Builder builder = SearchArgumentFactory.newBuilder();\n+    ExpressionVisitors.visit(expr, new ExpressionToSearchArgument(builder, idToColumnName)).invoke();\n+    return builder.build();\n+  }\n+\n+  // Currently every predicate in ORC requires a PredicateLeaf.Type field which is not available for these Iceberg types\n+  private static final Set<TypeID> UNSUPPORTED_TYPES = ImmutableSet.of(\n+      TypeID.BINARY,\n+      TypeID.FIXED,\n+      TypeID.UUID,\n+      TypeID.STRUCT,\n+      TypeID.MAP,\n+      TypeID.LIST\n+  );\n+\n+  private SearchArgument.Builder builder;\n+  private Map<Integer, String> idToColumnName;\n+\n+  private ExpressionToSearchArgument(SearchArgument.Builder builder, Map<Integer, String> idToColumnName) {\n+    this.builder = builder;\n+    this.idToColumnName = idToColumnName;\n+  }\n+\n+  @Override\n+  public Action alwaysTrue() {\n+    return () -> this.builder.literal(TruthValue.YES);\n+  }\n+\n+  @Override\n+  public Action alwaysFalse() {\n+    return () -> this.builder.literal(TruthValue.NO);\n+  }\n+\n+  @Override\n+  public Action not(Action child) {\n+    return () -> {\n+      this.builder.startNot();\n+      child.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public Action and(Action leftChild, Action rightChild) {\n+    return () -> {\n+      this.builder.startAnd();\n+      leftChild.invoke();\n+      rightChild.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public Action or(Action leftChild, Action rightChild) {\n+    return () -> {\n+      this.builder.startOr();\n+      leftChild.invoke();\n+      rightChild.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public <T> Action isNull(Bound<T> expr) {\n+    return () -> this.builder.isNull(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()));\n+  }\n+\n+  @Override\n+  public <T> Action notNull(Bound<T> expr) {\n+    return () -> this.builder.startNot()\n+        .isNull(idToColumnName.get(expr.ref().fieldId()),\n+            type(expr.ref().type()))\n+        .end();\n+  }\n+\n+  @Override\n+  public <T> Action lt(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.lessThan(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action ltEq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.lessThanEquals(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action gt(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.startNot()\n+          .lessThanEquals(idToColumnName.get(expr.ref().fieldId()),\n+              type(expr.ref().type()),\n+              literal(expr.ref().type(), lit.value()))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action gtEq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.startNot()\n+          .lessThan(idToColumnName.get(expr.ref().fieldId()),\n+              type(expr.ref().type()),\n+              literal(expr.ref().type(), lit.value()))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action eq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.equals(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action notEq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.startNot()\n+          .equals(idToColumnName.get(expr.ref().fieldId()),\n+              type(expr.ref().type()),\n+              literal(expr.ref().type(), lit.value()))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action in(Bound<T> expr, Set<T> literalSet) {\n+    return () -> this.builder.in(\n+        idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literalSet.stream().map(lit -> literal(expr.ref().type(), lit)).toArray(Object[]::new));\n+  }\n+\n+  @Override\n+  public <T> Action notIn(Bound<T> expr, Set<T> literalSet) {\n+    return () -> this.builder.startNot()\n+          .in(idToColumnName.get(expr.ref().fieldId()), type(expr.ref().type()),\n+              literalSet.stream().map(lit -> literal(expr.ref().type(), lit)).toArray(Object[]::new))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action startsWith(Bound<T> expr, Literal<T> lit) {\n+    // Cannot push down STARTS_WITH operator to ORC, so return TruthValue.YES_NO_NULL which signifies\n+    // that this predicate cannot help with filtering\n+    return () -> this.builder.literal(TruthValue.YES_NO_NULL);\n+  }\n+\n+  @Override\n+  public <T> Action predicate(BoundPredicate<T> pred) {\n+    if (UNSUPPORTED_TYPES.contains(pred.ref().type().typeId())) {\n+      // Cannot push down predicates for types which cannot be represented in PredicateLeaf.Type, so return\n+      // TruthValue.YES_NO_NULL which signifies that this predicate cannot help with filtering\n+      return () -> this.builder.literal(TruthValue.YES_NO_NULL);\n+    } else {\n+      return super.predicate(pred);\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  interface Action {\n+    void invoke();\n+  }\n+\n+  private PredicateLeaf.Type type(Type icebergType) {\n+    switch (icebergType.typeId()) {\n+      case BOOLEAN:\n+        return PredicateLeaf.Type.BOOLEAN;\n+      case INTEGER:\n+      case LONG:\n+      case TIME:\n+        return PredicateLeaf.Type.LONG;\n+      case FLOAT:\n+      case DOUBLE:\n+        return PredicateLeaf.Type.FLOAT;\n+      case DATE:\n+        return PredicateLeaf.Type.DATE;\n+      case TIMESTAMP:\n+        return PredicateLeaf.Type.TIMESTAMP;\n+      case STRING:\n+        return PredicateLeaf.Type.STRING;\n+      case DECIMAL:\n+        return PredicateLeaf.Type.DECIMAL;\n+      default:\n+        throw new UnsupportedOperationException(\"Type \" + icebergType + \" not supported in ORC SearchArguments\");\n+    }\n+  }\n+\n+  private <T> Object literal(Type icebergType, T icebergLiteral) {\n+    switch (icebergType.typeId()) {\n+      case BOOLEAN:\n+      case LONG:\n+      case TIME:\n+      case DOUBLE:\n+        return icebergLiteral;\n+      case INTEGER:\n+        return ((Integer) icebergLiteral).longValue();\n+      case FLOAT:\n+        return ((Float) icebergLiteral).doubleValue();\n+      case STRING:\n+        return icebergLiteral.toString();\n+      case DATE:\n+        return Date.valueOf(LocalDate.ofEpochDay((Integer) icebergLiteral));\n+      case TIMESTAMP:\n+        long microsFromEpoch = (Long) icebergLiteral;\n+        return Timestamp.from(Instant.ofEpochSecond(Math.floorDiv(microsFromEpoch, 1_000_000),\n+            (microsFromEpoch % 1_000_000) * 1_000));\n+      case DECIMAL:\n+        return new HiveDecimalWritable(HiveDecimal.create((BigDecimal) icebergLiteral, false));\n+      default:\n+        throw new UnsupportedOperationException(\"Type \" + icebergType + \" not supported in ORC SearchArguments\");\n+    }\n+  }\n+\n+  /**\n+   * Generates mapping from field IDs to fully qualified column names compatible with ORC convention for a given\n+   * {@link Schema}", "originalCommit": "181e913d95bb021e52779a5bcd2be5f49d50582c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NDYzNA==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r427164634", "bodyText": "Done", "author": "shardulm94", "createdAt": "2020-05-19T09:34:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwMjAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwMjMwNQ==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r421702305", "bodyText": "Javadoc won't insert a new paragraph for a blank line so you need to add <p>.", "author": "rdblue", "createdAt": "2020-05-07T18:19:15Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ExpressionToSearchArgument.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.math.BigDecimal;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.util.Deque;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Bound;\n+import org.apache.iceberg.expressions.BoundPredicate;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ExpressionVisitors;\n+import org.apache.iceberg.expressions.Literal;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Type.TypeID;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.TypeDescription;\n+import org.apache.orc.storage.common.type.HiveDecimal;\n+import org.apache.orc.storage.ql.io.sarg.PredicateLeaf;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument.TruthValue;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgumentFactory;\n+import org.apache.orc.storage.serde2.io.HiveDecimalWritable;\n+\n+public class ExpressionToSearchArgument extends ExpressionVisitors.BoundVisitor<ExpressionToSearchArgument.Action> {\n+\n+  static SearchArgument visit(Expression expr, TypeDescription readSchema) {\n+    Map<Integer, String> idToColumnName = TypeUtil.visit(ORCSchemaUtil.convert(readSchema), new IdToQuotedColumnName());\n+    SearchArgument.Builder builder = SearchArgumentFactory.newBuilder();\n+    ExpressionVisitors.visit(expr, new ExpressionToSearchArgument(builder, idToColumnName)).invoke();\n+    return builder.build();\n+  }\n+\n+  // Currently every predicate in ORC requires a PredicateLeaf.Type field which is not available for these Iceberg types\n+  private static final Set<TypeID> UNSUPPORTED_TYPES = ImmutableSet.of(\n+      TypeID.BINARY,\n+      TypeID.FIXED,\n+      TypeID.UUID,\n+      TypeID.STRUCT,\n+      TypeID.MAP,\n+      TypeID.LIST\n+  );\n+\n+  private SearchArgument.Builder builder;\n+  private Map<Integer, String> idToColumnName;\n+\n+  private ExpressionToSearchArgument(SearchArgument.Builder builder, Map<Integer, String> idToColumnName) {\n+    this.builder = builder;\n+    this.idToColumnName = idToColumnName;\n+  }\n+\n+  @Override\n+  public Action alwaysTrue() {\n+    return () -> this.builder.literal(TruthValue.YES);\n+  }\n+\n+  @Override\n+  public Action alwaysFalse() {\n+    return () -> this.builder.literal(TruthValue.NO);\n+  }\n+\n+  @Override\n+  public Action not(Action child) {\n+    return () -> {\n+      this.builder.startNot();\n+      child.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public Action and(Action leftChild, Action rightChild) {\n+    return () -> {\n+      this.builder.startAnd();\n+      leftChild.invoke();\n+      rightChild.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public Action or(Action leftChild, Action rightChild) {\n+    return () -> {\n+      this.builder.startOr();\n+      leftChild.invoke();\n+      rightChild.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public <T> Action isNull(Bound<T> expr) {\n+    return () -> this.builder.isNull(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()));\n+  }\n+\n+  @Override\n+  public <T> Action notNull(Bound<T> expr) {\n+    return () -> this.builder.startNot()\n+        .isNull(idToColumnName.get(expr.ref().fieldId()),\n+            type(expr.ref().type()))\n+        .end();\n+  }\n+\n+  @Override\n+  public <T> Action lt(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.lessThan(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action ltEq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.lessThanEquals(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action gt(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.startNot()\n+          .lessThanEquals(idToColumnName.get(expr.ref().fieldId()),\n+              type(expr.ref().type()),\n+              literal(expr.ref().type(), lit.value()))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action gtEq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.startNot()\n+          .lessThan(idToColumnName.get(expr.ref().fieldId()),\n+              type(expr.ref().type()),\n+              literal(expr.ref().type(), lit.value()))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action eq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.equals(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action notEq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.startNot()\n+          .equals(idToColumnName.get(expr.ref().fieldId()),\n+              type(expr.ref().type()),\n+              literal(expr.ref().type(), lit.value()))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action in(Bound<T> expr, Set<T> literalSet) {\n+    return () -> this.builder.in(\n+        idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literalSet.stream().map(lit -> literal(expr.ref().type(), lit)).toArray(Object[]::new));\n+  }\n+\n+  @Override\n+  public <T> Action notIn(Bound<T> expr, Set<T> literalSet) {\n+    return () -> this.builder.startNot()\n+          .in(idToColumnName.get(expr.ref().fieldId()), type(expr.ref().type()),\n+              literalSet.stream().map(lit -> literal(expr.ref().type(), lit)).toArray(Object[]::new))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action startsWith(Bound<T> expr, Literal<T> lit) {\n+    // Cannot push down STARTS_WITH operator to ORC, so return TruthValue.YES_NO_NULL which signifies\n+    // that this predicate cannot help with filtering\n+    return () -> this.builder.literal(TruthValue.YES_NO_NULL);\n+  }\n+\n+  @Override\n+  public <T> Action predicate(BoundPredicate<T> pred) {\n+    if (UNSUPPORTED_TYPES.contains(pred.ref().type().typeId())) {\n+      // Cannot push down predicates for types which cannot be represented in PredicateLeaf.Type, so return\n+      // TruthValue.YES_NO_NULL which signifies that this predicate cannot help with filtering\n+      return () -> this.builder.literal(TruthValue.YES_NO_NULL);\n+    } else {\n+      return super.predicate(pred);\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  interface Action {\n+    void invoke();\n+  }\n+\n+  private PredicateLeaf.Type type(Type icebergType) {\n+    switch (icebergType.typeId()) {\n+      case BOOLEAN:\n+        return PredicateLeaf.Type.BOOLEAN;\n+      case INTEGER:\n+      case LONG:\n+      case TIME:\n+        return PredicateLeaf.Type.LONG;\n+      case FLOAT:\n+      case DOUBLE:\n+        return PredicateLeaf.Type.FLOAT;\n+      case DATE:\n+        return PredicateLeaf.Type.DATE;\n+      case TIMESTAMP:\n+        return PredicateLeaf.Type.TIMESTAMP;\n+      case STRING:\n+        return PredicateLeaf.Type.STRING;\n+      case DECIMAL:\n+        return PredicateLeaf.Type.DECIMAL;\n+      default:\n+        throw new UnsupportedOperationException(\"Type \" + icebergType + \" not supported in ORC SearchArguments\");\n+    }\n+  }\n+\n+  private <T> Object literal(Type icebergType, T icebergLiteral) {\n+    switch (icebergType.typeId()) {\n+      case BOOLEAN:\n+      case LONG:\n+      case TIME:\n+      case DOUBLE:\n+        return icebergLiteral;\n+      case INTEGER:\n+        return ((Integer) icebergLiteral).longValue();\n+      case FLOAT:\n+        return ((Float) icebergLiteral).doubleValue();\n+      case STRING:\n+        return icebergLiteral.toString();\n+      case DATE:\n+        return Date.valueOf(LocalDate.ofEpochDay((Integer) icebergLiteral));\n+      case TIMESTAMP:\n+        long microsFromEpoch = (Long) icebergLiteral;\n+        return Timestamp.from(Instant.ofEpochSecond(Math.floorDiv(microsFromEpoch, 1_000_000),\n+            (microsFromEpoch % 1_000_000) * 1_000));\n+      case DECIMAL:\n+        return new HiveDecimalWritable(HiveDecimal.create((BigDecimal) icebergLiteral, false));\n+      default:\n+        throw new UnsupportedOperationException(\"Type \" + icebergType + \" not supported in ORC SearchArguments\");\n+    }\n+  }\n+\n+  /**\n+   * Generates mapping from field IDs to fully qualified column names compatible with ORC convention for a given\n+   * {@link Schema}\n+   *", "originalCommit": "181e913d95bb021e52779a5bcd2be5f49d50582c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NDY5MA==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r427164690", "bodyText": "Done", "author": "shardulm94", "createdAt": "2020-05-19T09:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwMjMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwODY5MA==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r421708690", "bodyText": "There is no greaterThan? Could you add a comment here to explain that it's using not(\"x\" <= 5) instead of x > 5?", "author": "rdblue", "createdAt": "2020-05-07T18:30:03Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ExpressionToSearchArgument.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.math.BigDecimal;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.util.Deque;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Bound;\n+import org.apache.iceberg.expressions.BoundPredicate;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ExpressionVisitors;\n+import org.apache.iceberg.expressions.Literal;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Type.TypeID;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.TypeDescription;\n+import org.apache.orc.storage.common.type.HiveDecimal;\n+import org.apache.orc.storage.ql.io.sarg.PredicateLeaf;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument.TruthValue;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgumentFactory;\n+import org.apache.orc.storage.serde2.io.HiveDecimalWritable;\n+\n+public class ExpressionToSearchArgument extends ExpressionVisitors.BoundVisitor<ExpressionToSearchArgument.Action> {\n+\n+  static SearchArgument visit(Expression expr, TypeDescription readSchema) {\n+    Map<Integer, String> idToColumnName = TypeUtil.visit(ORCSchemaUtil.convert(readSchema), new IdToQuotedColumnName());\n+    SearchArgument.Builder builder = SearchArgumentFactory.newBuilder();\n+    ExpressionVisitors.visit(expr, new ExpressionToSearchArgument(builder, idToColumnName)).invoke();\n+    return builder.build();\n+  }\n+\n+  // Currently every predicate in ORC requires a PredicateLeaf.Type field which is not available for these Iceberg types\n+  private static final Set<TypeID> UNSUPPORTED_TYPES = ImmutableSet.of(\n+      TypeID.BINARY,\n+      TypeID.FIXED,\n+      TypeID.UUID,\n+      TypeID.STRUCT,\n+      TypeID.MAP,\n+      TypeID.LIST\n+  );\n+\n+  private SearchArgument.Builder builder;\n+  private Map<Integer, String> idToColumnName;\n+\n+  private ExpressionToSearchArgument(SearchArgument.Builder builder, Map<Integer, String> idToColumnName) {\n+    this.builder = builder;\n+    this.idToColumnName = idToColumnName;\n+  }\n+\n+  @Override\n+  public Action alwaysTrue() {\n+    return () -> this.builder.literal(TruthValue.YES);\n+  }\n+\n+  @Override\n+  public Action alwaysFalse() {\n+    return () -> this.builder.literal(TruthValue.NO);\n+  }\n+\n+  @Override\n+  public Action not(Action child) {\n+    return () -> {\n+      this.builder.startNot();\n+      child.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public Action and(Action leftChild, Action rightChild) {\n+    return () -> {\n+      this.builder.startAnd();\n+      leftChild.invoke();\n+      rightChild.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public Action or(Action leftChild, Action rightChild) {\n+    return () -> {\n+      this.builder.startOr();\n+      leftChild.invoke();\n+      rightChild.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public <T> Action isNull(Bound<T> expr) {\n+    return () -> this.builder.isNull(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()));\n+  }\n+\n+  @Override\n+  public <T> Action notNull(Bound<T> expr) {\n+    return () -> this.builder.startNot()\n+        .isNull(idToColumnName.get(expr.ref().fieldId()),\n+            type(expr.ref().type()))\n+        .end();\n+  }\n+\n+  @Override\n+  public <T> Action lt(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.lessThan(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action ltEq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.lessThanEquals(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action gt(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.startNot()\n+          .lessThanEquals(idToColumnName.get(expr.ref().fieldId()),", "originalCommit": "181e913d95bb021e52779a5bcd2be5f49d50582c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NDUzNA==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r427164534", "bodyText": "Done", "author": "shardulm94", "createdAt": "2020-05-19T09:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwODY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcxMDI3NQ==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r421710275", "bodyText": "As a follow-up, you might consider rewriting this to use the new before/after methods instead of the custom order visitor. We just converted IndexByName and the implementation is much easier to read and maintain.", "author": "rdblue", "createdAt": "2020-05-07T18:32:43Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ExpressionToSearchArgument.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.math.BigDecimal;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.util.Deque;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Bound;\n+import org.apache.iceberg.expressions.BoundPredicate;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ExpressionVisitors;\n+import org.apache.iceberg.expressions.Literal;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Type.TypeID;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.TypeDescription;\n+import org.apache.orc.storage.common.type.HiveDecimal;\n+import org.apache.orc.storage.ql.io.sarg.PredicateLeaf;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument.TruthValue;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgumentFactory;\n+import org.apache.orc.storage.serde2.io.HiveDecimalWritable;\n+\n+public class ExpressionToSearchArgument extends ExpressionVisitors.BoundVisitor<ExpressionToSearchArgument.Action> {\n+\n+  static SearchArgument visit(Expression expr, TypeDescription readSchema) {\n+    Map<Integer, String> idToColumnName = TypeUtil.visit(ORCSchemaUtil.convert(readSchema), new IdToQuotedColumnName());\n+    SearchArgument.Builder builder = SearchArgumentFactory.newBuilder();\n+    ExpressionVisitors.visit(expr, new ExpressionToSearchArgument(builder, idToColumnName)).invoke();\n+    return builder.build();\n+  }\n+\n+  // Currently every predicate in ORC requires a PredicateLeaf.Type field which is not available for these Iceberg types\n+  private static final Set<TypeID> UNSUPPORTED_TYPES = ImmutableSet.of(\n+      TypeID.BINARY,\n+      TypeID.FIXED,\n+      TypeID.UUID,\n+      TypeID.STRUCT,\n+      TypeID.MAP,\n+      TypeID.LIST\n+  );\n+\n+  private SearchArgument.Builder builder;\n+  private Map<Integer, String> idToColumnName;\n+\n+  private ExpressionToSearchArgument(SearchArgument.Builder builder, Map<Integer, String> idToColumnName) {\n+    this.builder = builder;\n+    this.idToColumnName = idToColumnName;\n+  }\n+\n+  @Override\n+  public Action alwaysTrue() {\n+    return () -> this.builder.literal(TruthValue.YES);\n+  }\n+\n+  @Override\n+  public Action alwaysFalse() {\n+    return () -> this.builder.literal(TruthValue.NO);\n+  }\n+\n+  @Override\n+  public Action not(Action child) {\n+    return () -> {\n+      this.builder.startNot();\n+      child.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public Action and(Action leftChild, Action rightChild) {\n+    return () -> {\n+      this.builder.startAnd();\n+      leftChild.invoke();\n+      rightChild.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public Action or(Action leftChild, Action rightChild) {\n+    return () -> {\n+      this.builder.startOr();\n+      leftChild.invoke();\n+      rightChild.invoke();\n+      this.builder.end();\n+    };\n+  }\n+\n+  @Override\n+  public <T> Action isNull(Bound<T> expr) {\n+    return () -> this.builder.isNull(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()));\n+  }\n+\n+  @Override\n+  public <T> Action notNull(Bound<T> expr) {\n+    return () -> this.builder.startNot()\n+        .isNull(idToColumnName.get(expr.ref().fieldId()),\n+            type(expr.ref().type()))\n+        .end();\n+  }\n+\n+  @Override\n+  public <T> Action lt(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.lessThan(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action ltEq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.lessThanEquals(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action gt(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.startNot()\n+          .lessThanEquals(idToColumnName.get(expr.ref().fieldId()),\n+              type(expr.ref().type()),\n+              literal(expr.ref().type(), lit.value()))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action gtEq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.startNot()\n+          .lessThan(idToColumnName.get(expr.ref().fieldId()),\n+              type(expr.ref().type()),\n+              literal(expr.ref().type(), lit.value()))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action eq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.equals(idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literal(expr.ref().type(), lit.value()));\n+  }\n+\n+  @Override\n+  public <T> Action notEq(Bound<T> expr, Literal<T> lit) {\n+    return () -> this.builder.startNot()\n+          .equals(idToColumnName.get(expr.ref().fieldId()),\n+              type(expr.ref().type()),\n+              literal(expr.ref().type(), lit.value()))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action in(Bound<T> expr, Set<T> literalSet) {\n+    return () -> this.builder.in(\n+        idToColumnName.get(expr.ref().fieldId()),\n+        type(expr.ref().type()),\n+        literalSet.stream().map(lit -> literal(expr.ref().type(), lit)).toArray(Object[]::new));\n+  }\n+\n+  @Override\n+  public <T> Action notIn(Bound<T> expr, Set<T> literalSet) {\n+    return () -> this.builder.startNot()\n+          .in(idToColumnName.get(expr.ref().fieldId()), type(expr.ref().type()),\n+              literalSet.stream().map(lit -> literal(expr.ref().type(), lit)).toArray(Object[]::new))\n+          .end();\n+  }\n+\n+  @Override\n+  public <T> Action startsWith(Bound<T> expr, Literal<T> lit) {\n+    // Cannot push down STARTS_WITH operator to ORC, so return TruthValue.YES_NO_NULL which signifies\n+    // that this predicate cannot help with filtering\n+    return () -> this.builder.literal(TruthValue.YES_NO_NULL);\n+  }\n+\n+  @Override\n+  public <T> Action predicate(BoundPredicate<T> pred) {\n+    if (UNSUPPORTED_TYPES.contains(pred.ref().type().typeId())) {\n+      // Cannot push down predicates for types which cannot be represented in PredicateLeaf.Type, so return\n+      // TruthValue.YES_NO_NULL which signifies that this predicate cannot help with filtering\n+      return () -> this.builder.literal(TruthValue.YES_NO_NULL);\n+    } else {\n+      return super.predicate(pred);\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  interface Action {\n+    void invoke();\n+  }\n+\n+  private PredicateLeaf.Type type(Type icebergType) {\n+    switch (icebergType.typeId()) {\n+      case BOOLEAN:\n+        return PredicateLeaf.Type.BOOLEAN;\n+      case INTEGER:\n+      case LONG:\n+      case TIME:\n+        return PredicateLeaf.Type.LONG;\n+      case FLOAT:\n+      case DOUBLE:\n+        return PredicateLeaf.Type.FLOAT;\n+      case DATE:\n+        return PredicateLeaf.Type.DATE;\n+      case TIMESTAMP:\n+        return PredicateLeaf.Type.TIMESTAMP;\n+      case STRING:\n+        return PredicateLeaf.Type.STRING;\n+      case DECIMAL:\n+        return PredicateLeaf.Type.DECIMAL;\n+      default:\n+        throw new UnsupportedOperationException(\"Type \" + icebergType + \" not supported in ORC SearchArguments\");\n+    }\n+  }\n+\n+  private <T> Object literal(Type icebergType, T icebergLiteral) {\n+    switch (icebergType.typeId()) {\n+      case BOOLEAN:\n+      case LONG:\n+      case TIME:\n+      case DOUBLE:\n+        return icebergLiteral;\n+      case INTEGER:\n+        return ((Integer) icebergLiteral).longValue();\n+      case FLOAT:\n+        return ((Float) icebergLiteral).doubleValue();\n+      case STRING:\n+        return icebergLiteral.toString();\n+      case DATE:\n+        return Date.valueOf(LocalDate.ofEpochDay((Integer) icebergLiteral));\n+      case TIMESTAMP:\n+        long microsFromEpoch = (Long) icebergLiteral;\n+        return Timestamp.from(Instant.ofEpochSecond(Math.floorDiv(microsFromEpoch, 1_000_000),\n+            (microsFromEpoch % 1_000_000) * 1_000));\n+      case DECIMAL:\n+        return new HiveDecimalWritable(HiveDecimal.create((BigDecimal) icebergLiteral, false));\n+      default:\n+        throw new UnsupportedOperationException(\"Type \" + icebergType + \" not supported in ORC SearchArguments\");\n+    }\n+  }\n+\n+  /**\n+   * Generates mapping from field IDs to fully qualified column names compatible with ORC convention for a given\n+   * {@link Schema}\n+   *\n+   * This visitor also enclose column names in backticks i.e. ` so that ORC can correctly parse column names with\n+   * special characters. A comparison of ORC convention with Iceberg convention is provided below\n+   * <pre>\n+   *                                      Iceberg           ORC\n+   * field                                field             field\n+   * struct -> field                      struct.field      struct.field\n+   * list -> element                      list.element      list._elem\n+   * list -> struct element -> field      list.field        list._elem.field\n+   * map -> key                           map.key           map._key\n+   * map -> value                         map.value         map._value\n+   * map -> struct key -> field           map.key.field     map._key.field\n+   * map -> struct value -> field         map.field         map._value.field\n+   * </pre>\n+   */\n+  static class IdToQuotedColumnName extends TypeUtil.CustomOrderSchemaVisitor<Map<Integer, String>> {", "originalCommit": "181e913d95bb021e52779a5bcd2be5f49d50582c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMwNDA3Mg==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r427304072", "bodyText": "Done", "author": "shardulm94", "createdAt": "2020-05-19T13:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcxMDI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcxMTQ1Mw==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r421711453", "bodyText": "Can we move this to its own test suite? I don't think it should be mixed with the expression conversion tests.", "author": "rdblue", "createdAt": "2020-05-07T18:34:42Z", "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "diffHunk": "@@ -0,0 +1,313 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Binder;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.orc.ExpressionToSearchArgument.IdToQuotedColumnName;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.TypeDescription;\n+import org.apache.orc.storage.ql.io.sarg.PredicateLeaf.Type;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument.TruthValue;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgumentFactory;\n+import org.apache.orc.storage.serde2.io.HiveDecimalWritable;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.expressions.Expressions.and;\n+import static org.apache.iceberg.expressions.Expressions.equal;\n+import static org.apache.iceberg.expressions.Expressions.greaterThan;\n+import static org.apache.iceberg.expressions.Expressions.greaterThanOrEqual;\n+import static org.apache.iceberg.expressions.Expressions.in;\n+import static org.apache.iceberg.expressions.Expressions.isNull;\n+import static org.apache.iceberg.expressions.Expressions.lessThan;\n+import static org.apache.iceberg.expressions.Expressions.lessThanOrEqual;\n+import static org.apache.iceberg.expressions.Expressions.notEqual;\n+import static org.apache.iceberg.expressions.Expressions.notIn;\n+import static org.apache.iceberg.expressions.Expressions.notNull;\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+public class TestExpressionToSearchArgument {\n+\n+  @Test\n+  public void testPrimitiveTypes() {\n+    Schema schema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        required(2, \"long\", Types.LongType.get()),\n+        required(3, \"float\", Types.FloatType.get()),\n+        required(4, \"double\", Types.DoubleType.get()),\n+        required(5, \"boolean\", Types.BooleanType.get()),\n+        required(6, \"string\", Types.StringType.get()),\n+        required(7, \"date\", Types.DateType.get()),\n+        required(8, \"time\", Types.TimeType.get()),\n+        required(9, \"tsTz\", Types.TimestampType.withZone()),\n+        required(10, \"ts\", Types.TimestampType.withoutZone()),\n+        required(11, \"decimal\", Types.DecimalType.of(38, 2))\n+    );\n+\n+    Expression expr = and(\n+        and(\n+            and(lessThan(\"int\", 1), lessThanOrEqual(\"long\", 100)),\n+            and(greaterThan(\"float\", 5.0), greaterThanOrEqual(\"double\", 500.0))\n+        ),\n+        and(\n+            and(equal(\"boolean\", true), notEqual(\"string\", \"test\")),\n+            and(in(\"decimal\", BigDecimal.valueOf(-12345, 2), BigDecimal.valueOf(12345, 2)), notIn(\"time\", 100L, 200L))\n+        )\n+    );\n+    Expression boundFilter = Binder.bind(schema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .startAnd()\n+        .lessThan(\"`int`\", Type.LONG, 1L)\n+        .lessThanEquals(\"`long`\", Type.LONG, 100L)\n+        .startNot().lessThanEquals(\"`float`\", Type.FLOAT, 5.0).end()\n+        .startNot().lessThan(\"`double`\", Type.FLOAT, 500.0).end()\n+        .equals(\"`boolean`\", Type.BOOLEAN, true)\n+        .startNot().equals(\"`string`\", Type.STRING, \"test\").end()\n+        .in(\"`decimal`\", Type.DECIMAL, new HiveDecimalWritable(\"-123.45\"), new HiveDecimalWritable(\"123.45\"))\n+        .startNot().in(\"`time`\", Type.LONG, 100L, 200L).end()\n+        .end()\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.visit(boundFilter, ORCSchemaUtil.convert(schema));\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testTimezoneSensitiveTypes() {\n+    for (String timezone : new String[]{\"America/New_York\", \"Asia/Kolkata\", \"UTC/Greenwich\"}) {\n+      TimeZone.setDefault(TimeZone.getTimeZone(timezone));\n+      Schema schema = new Schema(\n+          required(1, \"date\", Types.DateType.get()),\n+          required(2, \"tsTz\", Types.TimestampType.withZone()),\n+          required(3, \"ts\", Types.TimestampType.withoutZone())\n+      );\n+\n+      Expression expr = and(\n+          and(equal(\"date\", 10L), equal(\"tsTz\", 10 * 3600 * 1000000L)),\n+          equal(\"ts\", 20 * 3600 * 1000000L)\n+      );\n+      Expression boundFilter = Binder.bind(schema.asStruct(), expr, true);\n+      SearchArgument expected = SearchArgumentFactory.newBuilder()\n+          .startAnd()\n+          .equals(\"`date`\", Type.DATE, Date.valueOf(LocalDate.parse(\"1970-01-11\", DateTimeFormatter.ISO_LOCAL_DATE)))\n+          .equals(\"`tsTz`\", Type.TIMESTAMP, Timestamp.from(Instant.ofEpochSecond(10 * 3600)))\n+          .equals(\"`ts`\", Type.TIMESTAMP, Timestamp.from(Instant.ofEpochSecond(20 * 3600)))\n+          .end()\n+          .build();\n+\n+      SearchArgument actual = ExpressionToSearchArgument.visit(boundFilter, ORCSchemaUtil.convert(schema));\n+      Assert.assertEquals(expected.toString(), actual.toString());\n+    }\n+  }\n+\n+  @Test\n+  public void testUnsupportedTypes() {\n+    Schema schema = new Schema(\n+        required(1, \"binary\", Types.BinaryType.get()),\n+        required(2, \"fixed\", Types.FixedType.ofLength(5)),\n+        required(3, \"uuid\", Types.UUIDType.get()),\n+        // use optional fields for performing isNull checks because Iceberg itself resolves them for required fields\n+        optional(4, \"struct\", Types.StructType.of(\n+            required(5, \"long\", Types.LongType.get())\n+        )),\n+        optional(6, \"list\", Types.ListType.ofRequired(7, Types.LongType.get())),\n+        optional(8, \"map\", Types.MapType.ofRequired(9, 10, Types.LongType.get(), Types.LongType.get()))\n+    );\n+\n+    // all operations for these types should resolve to YES_NO_NULL\n+    Expression expr = and(\n+        and(\n+          and(equal(\"binary\", ByteBuffer.allocate(10)), notEqual(\"fixed\", ByteBuffer.allocate(5))),\n+          and(greaterThan(\"uuid\", UUID.fromString(\"1-2-3-4-5\")), isNull(\"struct\"))\n+        ),\n+        and(notNull(\"list\"), isNull(\"map\"))\n+    );\n+    Expression boundFilter = Binder.bind(schema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .literal(TruthValue.YES_NO_NULL)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.visit(boundFilter, ORCSchemaUtil.convert(schema));\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testNestedPrimitives() {\n+    Schema schema = new Schema(\n+        optional(1, \"struct\", Types.StructType.of(\n+            required(2, \"long\", Types.LongType.get())\n+        )),\n+        optional(3, \"list\", Types.ListType.ofRequired(4, Types.LongType.get())),\n+        optional(5, \"map\", Types.MapType.ofRequired(6, 7, Types.LongType.get(), Types.LongType.get())),\n+        optional(8, \"listOfStruct\", Types.ListType.ofRequired(9, Types.StructType.of(\n+            required(10, \"long\", Types.LongType.get()))))\n+    );\n+\n+    Expression expr = and(\n+        and(equal(\"struct.long\", 1), equal(\"list.element\", 2)),\n+        and(equal(\"map.key\", 3), equal(\"listOfStruct.long\", 4))\n+    );\n+    Expression boundFilter = Binder.bind(schema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .startAnd()\n+        .equals(\"`struct`.`long`\", Type.LONG, 1L)\n+        .equals(\"`list`.`_elem`\", Type.LONG, 2L)\n+        .equals(\"`map`.`_key`\", Type.LONG, 3L)\n+        .equals(\"`listOfStruct`.`_elem`.`long`\", Type.LONG, 4L)\n+        .end()\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.visit(boundFilter, ORCSchemaUtil.convert(schema));\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testSpecialCharacters() {\n+    Schema schema = new Schema(\n+        required(1, \"col.with.dots\", Types.StructType.of(\n+            required(2, \"inner.col.with.dots\", Types.LongType.get())\n+        )),\n+        required(3, \"colW!th$peci@lCh@rs\", Types.LongType.get()),\n+        required(4, \"colWith`Quotes`\", Types.LongType.get())\n+    );\n+\n+    Expression expr = and(\n+        equal(\"col.with.dots.inner.col.with.dots\", 1),\n+        and(equal(\"colW!th$peci@lCh@rs\", 2), equal(\"colWith`Quotes`\", 3))\n+    );\n+    Expression boundFilter = Binder.bind(schema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .startAnd()\n+        .equals(\"`col.with.dots`.`inner.col.with.dots`\", Type.LONG, 1L)\n+        .equals(\"`colW!th$peci@lCh@rs`\", Type.LONG, 2L)\n+        .equals(\"`colWith``Quotes```\", Type.LONG, 3L)\n+        .end()\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.visit(boundFilter, ORCSchemaUtil.convert(schema));\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testEvolvedSchema() {\n+    Schema fileSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long_to_be_dropped\", Types.LongType.get())\n+    );\n+\n+    Schema evolvedSchema = new Schema(\n+        required(1, \"int_renamed\", Types.IntegerType.get()),\n+        optional(3, \"float_added\", Types.FloatType.get())\n+    );\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(evolvedSchema, ORCSchemaUtil.convert(fileSchema));\n+\n+    Expression expr = equal(\"int_renamed\", 1);\n+    Expression boundFilter = Binder.bind(evolvedSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.visit(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+\n+    // for columns not in the file, buildOrcProjection will append field names with _r<ID>\n+    // this will be passed down to ORC, but ORC will handle such cases and return a TruthValue during evaluation\n+    expr = equal(\"float_added\", 1);\n+    boundFilter = Binder.bind(evolvedSchema.asStruct(), expr, true);\n+    expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`float_added_r3`\", Type.FLOAT, 1.0)\n+        .build();\n+\n+    actual = ExpressionToSearchArgument.visit(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testIdToQuotedColumnName() {", "originalCommit": "181e913d95bb021e52779a5bcd2be5f49d50582c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NTc3MA==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r427165770", "bodyText": "Done", "author": "shardulm94", "createdAt": "2020-05-19T09:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcxMTQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcxMjM3OA==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r421712378", "bodyText": "I'd prefer to move IdToQuotedColumnName to a top-level class, like IdToOrcName and add it as a utility method in ORCSchemaUtil. That will make it available for other uses so we don't implement it twice because we don't know it exists.", "author": "rdblue", "createdAt": "2020-05-07T18:36:21Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ExpressionToSearchArgument.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.math.BigDecimal;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.util.Deque;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Bound;\n+import org.apache.iceberg.expressions.BoundPredicate;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.ExpressionVisitors;\n+import org.apache.iceberg.expressions.Literal;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Type.TypeID;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.TypeDescription;\n+import org.apache.orc.storage.common.type.HiveDecimal;\n+import org.apache.orc.storage.ql.io.sarg.PredicateLeaf;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgument.TruthValue;\n+import org.apache.orc.storage.ql.io.sarg.SearchArgumentFactory;\n+import org.apache.orc.storage.serde2.io.HiveDecimalWritable;\n+\n+public class ExpressionToSearchArgument extends ExpressionVisitors.BoundVisitor<ExpressionToSearchArgument.Action> {\n+\n+  static SearchArgument visit(Expression expr, TypeDescription readSchema) {\n+    Map<Integer, String> idToColumnName = TypeUtil.visit(ORCSchemaUtil.convert(readSchema), new IdToQuotedColumnName());", "originalCommit": "181e913d95bb021e52779a5bcd2be5f49d50582c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2Mjk2Mg==", "url": "https://github.com/apache/iceberg/pull/973#discussion_r427162962", "bodyText": "Done", "author": "shardulm94", "createdAt": "2020-05-19T09:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcxMjM3OA=="}], "type": "inlineReview"}, {"oid": "350b5bdc73c993e3062ade2b743c1969d037a792", "url": "https://github.com/apache/iceberg/commit/350b5bdc73c993e3062ade2b743c1969d037a792", "message": "Address PR comments", "committedDate": "2020-05-19T12:38:41Z", "type": "forcePushed"}, {"oid": "72ec3b0b58f381fbebbd0540a176496802002efd", "url": "https://github.com/apache/iceberg/commit/72ec3b0b58f381fbebbd0540a176496802002efd", "message": "Address PR comments", "committedDate": "2020-05-19T12:49:15Z", "type": "forcePushed"}, {"oid": "12c076fced140c2b0b92e253873ae1da62fed16c", "url": "https://github.com/apache/iceberg/commit/12c076fced140c2b0b92e253873ae1da62fed16c", "message": "Push down Iceberg expressions to ORC reader", "committedDate": "2020-05-22T22:39:10Z", "type": "commit"}, {"oid": "8634fcfe649bc30bf94afead07e70c4279fcd276", "url": "https://github.com/apache/iceberg/commit/8634fcfe649bc30bf94afead07e70c4279fcd276", "message": "Pass residuals from engines to ORC", "committedDate": "2020-05-22T22:39:47Z", "type": "commit"}, {"oid": "60dc0386a4eb2722efaa63fdbdb9c448a3394c4e", "url": "https://github.com/apache/iceberg/commit/60dc0386a4eb2722efaa63fdbdb9c448a3394c4e", "message": "Address PR comments", "committedDate": "2020-05-22T22:39:47Z", "type": "commit"}, {"oid": "7689df0b90103d649acec0101dffadc2e8af731c", "url": "https://github.com/apache/iceberg/commit/7689df0b90103d649acec0101dffadc2e8af731c", "message": "Use SchemaVisitor instead of CustomOrderSchemaVisitor for IdToOrcName", "committedDate": "2020-05-22T22:39:47Z", "type": "commit"}, {"oid": "7689df0b90103d649acec0101dffadc2e8af731c", "url": "https://github.com/apache/iceberg/commit/7689df0b90103d649acec0101dffadc2e8af731c", "message": "Use SchemaVisitor instead of CustomOrderSchemaVisitor for IdToOrcName", "committedDate": "2020-05-22T22:39:47Z", "type": "forcePushed"}]}