{"pr_number": 1254, "pr_title": "Parquet: Add row position reader", "pr_createdAt": "2020-07-27T12:32:13Z", "pr_url": "https://github.com/apache/iceberg/pull/1254", "timeline": [{"oid": "8bb39c32955484b470b0827907ae7495d42c2dc6", "url": "https://github.com/apache/iceberg/commit/8bb39c32955484b470b0827907ae7495d42c2dc6", "message": "Parquet: Add row position reader", "committedDate": "2020-07-27T12:30:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0NzgwNQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461047805", "bodyText": "Is removing the metadata fields from the projection schema required? We do this in the ORC implementation to avoid unnecessarily creating a Column Vector, and the ORC ReadBuilder take this into account while building the readers. What puzzles me is that this logic is not in the actual read path for Parquet and is only in the test read path.", "author": "shardulm94", "createdAt": "2020-07-27T17:21:25Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.apache.arrow.vector.NullCheckingForGet;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.MetadataColumns;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.parquet.ParquetSchemaUtil;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.ParquetReadOptions;\n+import org.apache.parquet.hadoop.ParquetFileReader;\n+import org.apache.parquet.hadoop.ParquetFileWriter;\n+import org.apache.parquet.hadoop.metadata.BlockMetaData;\n+import org.apache.parquet.hadoop.util.HadoopInputFile;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.catalyst.expressions.GenericInternalRow;\n+import org.apache.spark.sql.types.StructType;\n+import org.apache.spark.unsafe.types.UTF8String;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+@RunWith(Parameterized.class)\n+public class TestSparkParquetReadMetadataColumns {\n+  private static final Schema DATA_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get())\n+  );\n+\n+  private static final Schema PROJECTION_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get()),\n+      MetadataColumns.ROW_POSITION\n+  );\n+\n+  private static final int NUM_ROWS = 1000;\n+  private static final List<InternalRow> DATA_ROWS;\n+  private static final List<InternalRow> EXPECTED_ROWS;\n+  private static final int NUM_ROW_GROUPS = 10;\n+  private static final int ROWS_PER_SPLIT = NUM_ROWS / NUM_ROW_GROUPS;\n+\n+  static {\n+    DATA_ROWS = Lists.newArrayListWithCapacity(NUM_ROWS);\n+    for (long i = 0; i < NUM_ROWS; i++) {\n+      InternalRow row = new GenericInternalRow(DATA_SCHEMA.columns().size());\n+      row.update(0, i);\n+      row.update(1, UTF8String.fromString(\"str\" + i));\n+      DATA_ROWS.add(row);\n+    }\n+\n+    EXPECTED_ROWS = Lists.newArrayListWithCapacity(NUM_ROWS);\n+    for (long i = 0; i < NUM_ROWS; i++) {\n+      InternalRow row = new GenericInternalRow(PROJECTION_SCHEMA.columns().size());\n+      row.update(0, i);\n+      row.update(1, UTF8String.fromString(\"str\" + i));\n+      row.update(2, i);\n+      EXPECTED_ROWS.add(row);\n+    }\n+  }\n+\n+  @Parameterized.Parameters\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+        new Object[] { false },\n+        //new Object[] { true }\n+    };\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private boolean vectorized;\n+  private File testFile;\n+\n+  public TestSparkParquetReadMetadataColumns(boolean vectorized) {\n+    this.vectorized = vectorized;\n+  }\n+\n+  @Before\n+  public void writeFile() throws IOException {\n+    List<Path> fileSplits = new ArrayList<>();\n+    StructType struct = SparkSchemaUtil.convert(DATA_SCHEMA);\n+    Configuration conf = new Configuration();\n+\n+    testFile = temp.newFile();\n+    Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n+    ParquetFileWriter parquetFileWriter = new ParquetFileWriter(\n+        conf,\n+        ParquetSchemaUtil.convert(DATA_SCHEMA, \"testSchema\"),\n+        new Path(testFile.getAbsolutePath())\n+    );\n+\n+    parquetFileWriter.start();\n+    for (int i = 0; i < NUM_ROW_GROUPS; i += 1) {\n+      File split = temp.newFile();\n+      Assert.assertTrue(\"Delete should succeed\", split.delete());\n+      fileSplits.add(new Path(split.getAbsolutePath()));\n+      try (FileAppender<InternalRow> writer = Parquet.write(Files.localOutput(split))\n+          .createWriterFunc(msgType -> SparkParquetWriters.buildWriter(struct, msgType))\n+          .schema(DATA_SCHEMA)\n+          .overwrite()\n+          .build()) {\n+        writer.addAll(DATA_ROWS.subList(i * ROWS_PER_SPLIT, (i + 1) * ROWS_PER_SPLIT));\n+      }\n+      parquetFileWriter.appendFile(HadoopInputFile.fromPath(new Path(split.getAbsolutePath()), conf));\n+    }\n+    parquetFileWriter\n+        .end(ParquetFileWriter.mergeMetadataFiles(fileSplits, conf).getFileMetaData().getKeyValueMetaData());\n+  }\n+\n+  @Test\n+  public void testReadRowNumbers() throws IOException {\n+    readAndValidate(null, null, null, EXPECTED_ROWS);\n+  }\n+\n+  @Test\n+  public void testReadRowNumbersWithFilter() throws IOException {\n+    // current iceberg support row group filter.\n+    for (int i = 0; i < NUM_ROW_GROUPS; i += 1) {\n+      readAndValidate(Expressions.greaterThanOrEqual(\"id\", i * ROWS_PER_SPLIT), null, null,\n+          EXPECTED_ROWS.subList(i * ROWS_PER_SPLIT, 1000));\n+    }\n+  }\n+\n+  @Test\n+  public void testReadRowNumbersWithSplits() throws IOException {\n+    ParquetFileReader fileReader = new ParquetFileReader(\n+        HadoopInputFile.fromPath(new Path(testFile.getAbsolutePath()), new Configuration()),\n+        ParquetReadOptions.builder().build());\n+    List<BlockMetaData> rowGroups = fileReader.getRowGroups();\n+    for (int i = 0; i < NUM_ROW_GROUPS; i += 1) {\n+      readAndValidate(null,\n+          rowGroups.get(i).getColumns().get(1).getStartingPos(),\n+          rowGroups.get(i).getCompressedSize(),\n+          EXPECTED_ROWS.subList(i * ROWS_PER_SPLIT, (i + 1) * ROWS_PER_SPLIT));\n+    }\n+  }\n+\n+  private void readAndValidate(Expression filter, Long splitStart, Long splitLength, List<InternalRow> expected)\n+      throws IOException {\n+    Schema projectionWithoutMetadataFields = TypeUtil.selectNot(PROJECTION_SCHEMA, MetadataColumns.metadataFieldIds());", "originalCommit": "8bb39c32955484b470b0827907ae7495d42c2dc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyMTEzNw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461321137", "bodyText": "Hmm, this is a copy-paste error. let me remove this at first. At least, I don't use any related logic right now.", "author": "chenjunjiedada", "createdAt": "2020-07-28T05:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0NzgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA3MTkxOA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461071918", "bodyText": "If I change this to row.update(0, 2 * i); and the same for EXPECTED_ROWS, testReadRowNumbersWithSplits() seems to fail. Can you check if the split generation logic in the test case is correct?", "author": "shardulm94", "createdAt": "2020-07-27T18:03:09Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.apache.arrow.vector.NullCheckingForGet;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.MetadataColumns;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.parquet.ParquetSchemaUtil;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.ParquetReadOptions;\n+import org.apache.parquet.hadoop.ParquetFileReader;\n+import org.apache.parquet.hadoop.ParquetFileWriter;\n+import org.apache.parquet.hadoop.metadata.BlockMetaData;\n+import org.apache.parquet.hadoop.util.HadoopInputFile;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.catalyst.expressions.GenericInternalRow;\n+import org.apache.spark.sql.types.StructType;\n+import org.apache.spark.unsafe.types.UTF8String;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+@RunWith(Parameterized.class)\n+public class TestSparkParquetReadMetadataColumns {\n+  private static final Schema DATA_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get())\n+  );\n+\n+  private static final Schema PROJECTION_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get()),\n+      MetadataColumns.ROW_POSITION\n+  );\n+\n+  private static final int NUM_ROWS = 1000;\n+  private static final List<InternalRow> DATA_ROWS;\n+  private static final List<InternalRow> EXPECTED_ROWS;\n+  private static final int NUM_ROW_GROUPS = 10;\n+  private static final int ROWS_PER_SPLIT = NUM_ROWS / NUM_ROW_GROUPS;\n+\n+  static {\n+    DATA_ROWS = Lists.newArrayListWithCapacity(NUM_ROWS);\n+    for (long i = 0; i < NUM_ROWS; i++) {\n+      InternalRow row = new GenericInternalRow(DATA_SCHEMA.columns().size());\n+      row.update(0, i);", "originalCommit": "8bb39c32955484b470b0827907ae7495d42c2dc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyMTcwNA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461321704", "bodyText": "Nice catch! The split start should use the first column's starting pos other than the second one. I updated the UT to cover both row.update(0, i) and row.update(0, 2*i).", "author": "chenjunjiedada", "createdAt": "2020-07-28T05:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA3MTkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1MDE3Nw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461150177", "bodyText": "Nit: Should be rowGroupRowOffsetInFile to maintain consistent camel casing in the variable name.", "author": "shardulm94", "createdAt": "2020-07-27T20:28:53Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java", "diffHunk": "@@ -137,6 +137,41 @@ public void setPageSource(PageReadStore pageStore) {\n     }\n   }\n \n+  static class PositionReader implements ParquetValueReader<Long> {\n+    private long rowOffsetInCurrentRowGroup = -1;\n+    private long rowGroupRowOffsetInfile;", "originalCommit": "8bb39c32955484b470b0827907ae7495d42c2dc6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9b131c34fb7162cf329c64471a27517d598458b1", "url": "https://github.com/apache/iceberg/commit/9b131c34fb7162cf329c64471a27517d598458b1", "message": "address comments", "committedDate": "2020-07-28T05:19:55Z", "type": "commit"}, {"oid": "9b131c34fb7162cf329c64471a27517d598458b1", "url": "https://github.com/apache/iceberg/commit/9b131c34fb7162cf329c64471a27517d598458b1", "message": "address comments", "committedDate": "2020-07-28T05:19:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDk0MQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461890941", "bodyText": "Why not add the position to the page source? Then the two operations are tied together: the row offset is the start offset for the new pages.", "author": "rdblue", "createdAt": "2020-07-28T21:29:24Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReader.java", "diffHunk": "@@ -30,4 +30,6 @@\n   List<TripleIterator<?>> columns();\n \n   void setPageSource(PageReadStore pageStore);\n+\n+  default void setRowOffsetForRowGroup(long position) {}", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjkwNw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462006907", "bodyText": "I can change to that. Just one thing that do we mind to change the function signature in the public API?", "author": "chenjunjiedada", "createdAt": "2020-07-29T02:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MTkwMQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461891901", "bodyText": "Can you move this to the top of the file with the other factory methods?", "author": "rdblue", "createdAt": "2020-07-28T21:31:25Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java", "diffHunk": "@@ -137,6 +137,41 @@ public void setPageSource(PageReadStore pageStore) {\n     }\n   }\n \n+  static class PositionReader implements ParquetValueReader<Long> {\n+    private long rowOffsetInCurrentRowGroup = -1;\n+    private long rowGroupRowOffsetInFile;\n+\n+    @Override\n+    public Long read(Long reuse) {\n+      rowOffsetInCurrentRowGroup = rowOffsetInCurrentRowGroup + 1;\n+      return rowGroupRowOffsetInFile + rowOffsetInCurrentRowGroup;\n+    }\n+\n+    @Override\n+    public TripleIterator<?> column() {\n+      return NullReader.NULL_COLUMN;\n+    }\n+\n+    @Override\n+    public List<TripleIterator<?>> columns() {\n+      return NullReader.COLUMNS;\n+    }\n+\n+    @Override\n+    public void setPageSource(PageReadStore pageStore) {\n+    }\n+\n+    @Override\n+    public void setRowOffsetForRowGroup(long rowGroupStartPos) {\n+      this.rowGroupRowOffsetInFile = rowGroupStartPos;\n+      this.rowOffsetInCurrentRowGroup = -1;\n+    }\n+  }\n+\n+  public static ParquetValueReader<Long> position() {\n+    return new PositionReader();\n+  }", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNDM4OA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462014388", "bodyText": "Done.", "author": "chenjunjiedada", "createdAt": "2020-07-29T03:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MTkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MjQ5Mw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461892493", "bodyText": "How about naming this startPositions?", "author": "rdblue", "createdAt": "2020-07-28T21:32:44Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -157,6 +164,23 @@ ParquetFileReader reader() {\n     return shouldSkip;\n   }\n \n+  private Map<Long, Long> generateRowGroupsStartRowPos() {\n+    ParquetFileReader fileReader = newReader(this.file, ParquetReadOptions.builder().build());\n+    Map<Long, Long> offsetToStartRowPosMap = new HashMap<>();\n+    long curRowCount = 0;\n+    for (int i = 0; i < fileReader.getRowGroups().size(); i += 1) {\n+      BlockMetaData meta = fileReader.getRowGroups().get(i);\n+      offsetToStartRowPosMap.put(meta.getStartingPos(), curRowCount);\n+      curRowCount += meta.getRowCount();\n+    }\n+\n+    return offsetToStartRowPosMap;\n+  }\n+\n+  long[] getRowGroupsStartRowPos() {", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5NTMzMg==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461995332", "bodyText": "startPositions may confuse with rowGroup.startingPosition, how about startRowPosititions?", "author": "chenjunjiedada", "createdAt": "2020-07-29T02:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MjQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzY0Mg==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461893642", "bodyText": "Why does this separately read the Parquet file to create a map that is used to initialize an array, when the starting position could be set for the array in the existing loop? I don't think this method is needed.", "author": "rdblue", "createdAt": "2020-07-28T21:35:09Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -157,6 +164,23 @@ ParquetFileReader reader() {\n     return shouldSkip;\n   }\n \n+  private Map<Long, Long> generateRowGroupsStartRowPos() {", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5MjE2OQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461992169", "bodyText": "The existing loop of row groups is based on the row groups that had been filtered with options.  So we need to read the Parquet file without any filter to get each starting row position of row group.", "author": "chenjunjiedada", "createdAt": "2020-07-29T01:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1OTE5Mg==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462659192", "bodyText": "You're right. Good catch!\nCan you add some comments to explain why this is needed for later?", "author": "rdblue", "createdAt": "2020-07-30T00:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMzAxMQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462713011", "bodyText": "Done.", "author": "chenjunjiedada", "createdAt": "2020-07-30T03:29:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5NTU1Mw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461895553", "bodyText": "In general, try to be specific with names, but avoid unnecessary context. In this case, these names can be simpler: rowGroupStart and rowOffset would work fine. Extra context like InFile and InCurrent aren't adding clarity.", "author": "rdblue", "createdAt": "2020-07-28T21:39:34Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java", "diffHunk": "@@ -137,6 +137,41 @@ public void setPageSource(PageReadStore pageStore) {\n     }\n   }\n \n+  static class PositionReader implements ParquetValueReader<Long> {\n+    private long rowOffsetInCurrentRowGroup = -1;\n+    private long rowGroupRowOffsetInFile;", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNDM1MQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462014351", "bodyText": "Done.", "author": "chenjunjiedada", "createdAt": "2020-07-29T03:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5NTU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwMDA0NA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461900044", "bodyText": "Why not use try-with-resources instead of a finally block?", "author": "rdblue", "createdAt": "2020-07-28T21:45:23Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.apache.arrow.vector.NullCheckingForGet;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.MetadataColumns;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.parquet.ParquetSchemaUtil;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.ParquetReadOptions;\n+import org.apache.parquet.hadoop.ParquetFileReader;\n+import org.apache.parquet.hadoop.ParquetFileWriter;\n+import org.apache.parquet.hadoop.metadata.BlockMetaData;\n+import org.apache.parquet.hadoop.util.HadoopInputFile;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.catalyst.expressions.GenericInternalRow;\n+import org.apache.spark.sql.types.StructType;\n+import org.apache.spark.unsafe.types.UTF8String;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+@RunWith(Parameterized.class)\n+public class TestSparkParquetReadMetadataColumns {\n+  private static final Schema DATA_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get())\n+  );\n+\n+  private static final Schema PROJECTION_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get()),\n+      MetadataColumns.ROW_POSITION\n+  );\n+\n+  private static final int NUM_ROWS = 1000;\n+  private static final List<InternalRow> DATA_ROWS;\n+  private static final List<InternalRow> EXPECTED_ROWS;\n+  private static final int NUM_ROW_GROUPS = 10;\n+  private static final int ROWS_PER_SPLIT = NUM_ROWS / NUM_ROW_GROUPS;\n+\n+  static {\n+    DATA_ROWS = Lists.newArrayListWithCapacity(NUM_ROWS);\n+    for (long i = 0; i < NUM_ROWS; i += 1) {\n+      InternalRow row = new GenericInternalRow(DATA_SCHEMA.columns().size());\n+      if (i >= 500) {\n+        row.update(0, 2 * i);\n+      } else {\n+        row.update(0, i);\n+      }\n+      row.update(1, UTF8String.fromString(\"str\" + i));\n+      DATA_ROWS.add(row);\n+    }\n+\n+    EXPECTED_ROWS = Lists.newArrayListWithCapacity(NUM_ROWS);\n+    for (long i = 0; i < NUM_ROWS; i += 1) {\n+      InternalRow row = new GenericInternalRow(PROJECTION_SCHEMA.columns().size());\n+      if (i >= 500) {\n+        row.update(0, 2 * i);\n+      } else {\n+        row.update(0, i);\n+      }\n+      row.update(1, UTF8String.fromString(\"str\" + i));\n+      row.update(2, i);\n+      EXPECTED_ROWS.add(row);\n+    }\n+  }\n+\n+  @Parameterized.Parameters\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+        new Object[] { false },\n+        //new Object[] { true }\n+    };\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private boolean vectorized;\n+  private File testFile;\n+\n+  public TestSparkParquetReadMetadataColumns(boolean vectorized) {\n+    this.vectorized = vectorized;\n+  }\n+\n+  @Before\n+  public void writeFile() throws IOException {\n+    List<Path> fileSplits = new ArrayList<>();\n+    StructType struct = SparkSchemaUtil.convert(DATA_SCHEMA);\n+    Configuration conf = new Configuration();\n+\n+    testFile = temp.newFile();\n+    Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n+    ParquetFileWriter parquetFileWriter = new ParquetFileWriter(\n+        conf,\n+        ParquetSchemaUtil.convert(DATA_SCHEMA, \"testSchema\"),\n+        new Path(testFile.getAbsolutePath())\n+    );\n+\n+    parquetFileWriter.start();\n+    for (int i = 0; i < NUM_ROW_GROUPS; i += 1) {\n+      File split = temp.newFile();\n+      Assert.assertTrue(\"Delete should succeed\", split.delete());\n+      fileSplits.add(new Path(split.getAbsolutePath()));\n+      try (FileAppender<InternalRow> writer = Parquet.write(Files.localOutput(split))\n+          .createWriterFunc(msgType -> SparkParquetWriters.buildWriter(struct, msgType))\n+          .schema(DATA_SCHEMA)\n+          .overwrite()\n+          .build()) {\n+        writer.addAll(DATA_ROWS.subList(i * ROWS_PER_SPLIT, (i + 1) * ROWS_PER_SPLIT));\n+      }\n+      parquetFileWriter.appendFile(HadoopInputFile.fromPath(new Path(split.getAbsolutePath()), conf));\n+    }\n+    parquetFileWriter\n+        .end(ParquetFileWriter.mergeMetadataFiles(fileSplits, conf).getFileMetaData().getKeyValueMetaData());\n+  }\n+\n+  @Test\n+  public void testReadRowNumbers() throws IOException {\n+    readAndValidate(null, null, null, EXPECTED_ROWS);\n+  }\n+\n+  @Test\n+  public void testReadRowNumbersWithFilter() throws IOException {\n+    // current iceberg supports row group filter.\n+    for (int i = 1; i < 5; i += 1) {\n+      readAndValidate(\n+          Expressions.and(Expressions.lessThan(\"id\", 500),\n+              Expressions.greaterThanOrEqual(\"id\", i * ROWS_PER_SPLIT)),\n+          null,\n+          null,\n+          EXPECTED_ROWS.subList(i * ROWS_PER_SPLIT, 500));\n+    }\n+  }\n+\n+  @Test\n+  public void testReadRowNumbersWithSplits() throws IOException {\n+    ParquetFileReader fileReader = new ParquetFileReader(\n+        HadoopInputFile.fromPath(new Path(testFile.getAbsolutePath()), new Configuration()),\n+        ParquetReadOptions.builder().build());\n+    List<BlockMetaData> rowGroups = fileReader.getRowGroups();\n+    for (int i = 0; i < NUM_ROW_GROUPS; i += 1) {\n+      readAndValidate(null,\n+          rowGroups.get(i).getColumns().get(0).getStartingPos(),\n+          rowGroups.get(i).getCompressedSize(),\n+          EXPECTED_ROWS.subList(i * ROWS_PER_SPLIT, (i + 1) * ROWS_PER_SPLIT));\n+    }\n+  }\n+\n+  private void readAndValidate(Expression filter, Long splitStart, Long splitLength, List<InternalRow> expected)\n+      throws IOException {\n+    CloseableIterable<InternalRow> reader = null;\n+    try {\n+      Parquet.ReadBuilder builder = Parquet.read(Files.localInput(testFile))\n+          .project(PROJECTION_SCHEMA);\n+\n+      if (vectorized) {\n+        builder.createBatchedReaderFunc(fileSchema -> VectorizedSparkParquetReaders.buildReader(PROJECTION_SCHEMA,\n+            fileSchema, NullCheckingForGet.NULL_CHECKING_ENABLED));\n+      } else {\n+        builder = builder.createReaderFunc(msgType -> SparkParquetReaders.buildReader(PROJECTION_SCHEMA, msgType));\n+      }\n+\n+      if (filter != null) {\n+        builder = builder.filter(filter);\n+      }\n+\n+      if (splitStart != null && splitLength != null) {\n+        builder = builder.split(splitStart, splitLength);\n+      }\n+\n+      reader = builder.build();\n+\n+      final Iterator<InternalRow> actualRows = reader.iterator();\n+\n+      for (InternalRow internalRow : expected) {\n+        Assert.assertTrue(\"Should have expected number of rows\", actualRows.hasNext());\n+        TestHelpers.assertEquals(PROJECTION_SCHEMA, internalRow, actualRows.next());\n+      }\n+      Assert.assertFalse(\"Should not have extra rows\", actualRows.hasNext());\n+    } finally {\n+      if (reader != null) {\n+        reader.close();", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNDMyNw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462014327", "bodyText": "Done.", "author": "chenjunjiedada", "createdAt": "2020-07-29T03:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwMDA0NA=="}], "type": "inlineReview"}, {"oid": "76293446f71ae911f858a67cba210caca7549a9b", "url": "https://github.com/apache/iceberg/commit/76293446f71ae911f858a67cba210caca7549a9b", "message": "address comments", "committedDate": "2020-07-29T11:20:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MjAxMA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462662010", "bodyText": "Can we use the same name for the variable?", "author": "rdblue", "createdAt": "2020-07-30T00:19:26Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -157,6 +164,23 @@ ParquetFileReader reader() {\n     return shouldSkip;\n   }\n \n+  private Map<Long, Long> generateRowGroupsStartRowPos() {\n+    ParquetFileReader fileReader = newReader(this.file, ParquetReadOptions.builder().build());\n+    Map<Long, Long> offsetToStartRowPosMap = new HashMap<>();\n+    long curRowCount = 0;\n+    for (int i = 0; i < fileReader.getRowGroups().size(); i += 1) {\n+      BlockMetaData meta = fileReader.getRowGroups().get(i);\n+      offsetToStartRowPosMap.put(meta.getStartingPos(), curRowCount);\n+      curRowCount += meta.getRowCount();\n+    }\n+\n+    return offsetToStartRowPosMap;\n+  }\n+\n+  long[] startRowPositions() {\n+    return rowGroupsStartRowPos;", "originalCommit": "76293446f71ae911f858a67cba210caca7549a9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMzA2OA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462713068", "bodyText": "NP, Done.", "author": "chenjunjiedada", "createdAt": "2020-07-30T03:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MjIzNQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462662235", "bodyText": "How about naming this offsetToStartPos and similarly updating the method name? There's no need to include a type in the variable name, usually.", "author": "rdblue", "createdAt": "2020-07-30T00:20:21Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -85,6 +87,9 @@\n     this.rowGroups = reader.getRowGroups();\n     this.shouldSkip = new boolean[rowGroups.size()];\n \n+    Map<Long, Long> offsetToStartRowPosMap = generateRowGroupsStartRowPos();", "originalCommit": "76293446f71ae911f858a67cba210caca7549a9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMzExMA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462713110", "bodyText": "OK, done.", "author": "chenjunjiedada", "createdAt": "2020-07-30T03:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MjIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2NDM0Mw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462664343", "bodyText": "Instead of adding this, can you update setPageSource like the other interface that changed?", "author": "rdblue", "createdAt": "2020-07-30T00:27:56Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java", "diffHunk": "@@ -72,4 +73,7 @@ public boolean hasNext() {\n     return triplesRead < triplesCount;\n   }\n \n+  public void setRowPosition(long rowPosition) {", "originalCommit": "76293446f71ae911f858a67cba210caca7549a9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2NDQzMw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462664433", "bodyText": "Is this needed? I don't see any uses.", "author": "rdblue", "createdAt": "2020-07-30T00:28:19Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java", "diffHunk": "@@ -34,6 +34,7 @@\n   protected long triplesRead = 0L;\n   protected long advanceNextPageCount = 0L;\n   protected Dictionary dictionary;\n+  protected long rowPosition;", "originalCommit": "76293446f71ae911f858a67cba210caca7549a9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxNTQ3Mg==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462715472", "bodyText": "Right, this and setRowPosition are no longer needed.", "author": "chenjunjiedada", "createdAt": "2020-07-30T03:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2NDQzMw=="}], "type": "inlineReview"}, {"oid": "07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "url": "https://github.com/apache/iceberg/commit/07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "message": "fix naming and remove useless variable", "committedDate": "2020-07-30T11:31:59Z", "type": "forcePushed"}, {"oid": "07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "url": "https://github.com/apache/iceberg/commit/07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "message": "fix naming and remove useless variable", "committedDate": "2020-07-30T11:31:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NTAxNA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r463355014", "bodyText": "It just occurred to me (after merging this) that we may want to make this lazy, like we do in Avro. That way if the row positions are never used, we don't incur the cost of reading the footer another time.", "author": "rdblue", "createdAt": "2020-07-31T01:15:08Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -85,6 +87,10 @@\n     this.rowGroups = reader.getRowGroups();\n     this.shouldSkip = new boolean[rowGroups.size()];\n \n+    // Fetch all row groups starting positions to compute the row offsets of the filtered row groups\n+    Map<Long, Long> offsetToStartPos = generateOffsetToStartPos();", "originalCommit": "07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1Nzk1OA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r463357958", "bodyText": "I used to think to apply Caffeine cache this. Let me think about this again and also check what Avro does. I will update this in follow up vectorization code path.", "author": "chenjunjiedada", "createdAt": "2020-07-31T01:26:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NTAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNjg4Nw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r491236887", "bodyText": "@chenjunjiedada  yes we should make this lazy , do you have issue to track improvements to existing logic?", "author": "sudssf", "createdAt": "2020-09-18T23:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NTAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MzkyMA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r491243920", "bodyText": "@sudssf , Yes, I have a PR: #1356. It reads the file when the required schema contains position column.\n    if (expectedSchema.findField(MetadataColumns.ROW_POSITION.fieldId()) != null) {\n      // Only read footer when needed\n      offsetToStartPos = generateOffsetToStartPos();\n    }", "author": "chenjunjiedada", "createdAt": "2020-09-19T00:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NTAxNA=="}], "type": "inlineReview"}]}