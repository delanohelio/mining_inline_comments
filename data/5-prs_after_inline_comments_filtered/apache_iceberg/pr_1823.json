{"pr_number": 1823, "pr_title": "AWS: Glue catalog lock interface", "pr_createdAt": "2020-11-25T07:13:41Z", "pr_url": "https://github.com/apache/iceberg/pull/1823", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0ODgyOA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530548828", "bodyText": "I think this should default to true because it is needed for correct operations.", "author": "rdblue", "createdAt": "2020-11-25T17:45:53Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMzA1Nw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530633057", "bodyText": "Yes I agree, but after a second thought, there are a few considerations for making this false by default:\n\nthis is an additional AWS resource that charges the user if enabled, so it is better to let people explicitly do that\nfor data warehouse ETLM use cases, the current Glue concurrent modification exception is good enough as a safe guard. I think it makes more sense for user to turn this on when they know there is a potential for conflict commits in use cases like streaming.\n\n@yyanyy and @giovannifumarola, what do you think?", "author": "jackye1995", "createdAt": "2020-11-25T20:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MDk0NA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530670944", "bodyText": "I think it is important to always be correct. If we want users to need to opt in, then we can add a configuration setting that must be supplied, like the dynamo table. If that isn't supplied, then loading the catalog fails with an error message. Then we know that the user configured a specific dynamo table and understands that dynamo will be used.", "author": "rdblue", "createdAt": "2020-11-25T22:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4OTgwMw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530689803", "bodyText": "+1, also I'm not an expert in AWS free tier but according to this it seems like low provisioned capacity counts towards free tier, so charging might not be a big problem in normal use cases. If this is the case, I guess this also applies to how table gets set up (billingMode).", "author": "yyanyy", "createdAt": "2020-11-25T23:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0ODgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0OTUwMQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530549501", "bodyText": "Can we base this on a prefix + catalog name instead of a constant? That way we don't do something unsafe by default.", "author": "rdblue", "createdAt": "2020-11-25T17:47:06Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * One lock table is designed to be used for only one catalog.\n+   * It is recommended to use a different table name for each Glue catalog.\n+   * If the table does not exist, it will be created at runtime.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_TABLE = \"gluecatalog.lock.table\";\n+  public static final String GLUE_CATALOG_LOCK_TABLE_DEFAULT = \"IcebergGlueCatalogLockTable\";", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NzQwMg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530587402", "bodyText": "I considered this option, and decided to go with the way of setting the entire table name. This is because people can specify different catalog names and still point to the same Glue catalog, and in that case they want to use the same lock table. So setting the entire table name seems to be the most flexible option to satisfy all use cases.", "author": "jackye1995", "createdAt": "2020-11-25T19:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0OTUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MTIyOQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530671229", "bodyText": "I'm just talking about the default value. If a user wants to set the table specifically, then I agree that it should be the lock.table property to override. But the default should be based on a prefix and the catalog name to avoid needless conflict.", "author": "rdblue", "createdAt": "2020-11-25T22:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0OTUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2NTMxNg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533065316", "bodyText": "Combined with the discussion above, I think not providing a default name seems to be the right approach to go, so that user knows exactly what table they are using, and its cost associated. Let me update with that.", "author": "jackye1995", "createdAt": "2020-12-01T04:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0OTUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0OTg1Ng==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530549856", "bodyText": "Commits can take longer than this. What about using the max retry time for commits?", "author": "rdblue", "createdAt": "2020-11-25T17:47:47Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * One lock table is designed to be used for only one catalog.\n+   * It is recommended to use a different table name for each Glue catalog.\n+   * If the table does not exist, it will be created at runtime.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_TABLE = \"gluecatalog.lock.table\";\n+  public static final String GLUE_CATALOG_LOCK_TABLE_DEFAULT = \"IcebergGlueCatalogLockTable\";\n+\n+  /**\n+   * After the given time in milliseconds, the process will give up the attempt to acquire a lock.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_WAIT = \"gluecatalog.lock.wait\";\n+  public static final long GLUE_CATALOG_LOCK_WAIT_DEFAULT = TimeUnit.MINUTES.toMillis(3);\n+\n+  /**\n+   * After the given time in milliseconds, the lock is automatically expired.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_EXPIRE = \"gluecatalog.lock.expire\";\n+  public static final long GLUE_CATALOG_LOCK_EXPIRE_DEFAULT = TimeUnit.MINUTES.toMillis(2);", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NjExNw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530586117", "bodyText": "Oh yes, I was planning to set it to 1200000ms which is hive.zookeeper.session.timeout, somehow typed it wrong...", "author": "jackye1995", "createdAt": "2020-11-25T18:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0OTg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MTM2MA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530671360", "bodyText": "I was thinking commit.retry.max-wait-ms from table properties, which is the maximum amount of time before an operation fails and will stop retrying. That way, we know that the committer that holds the lock will no longer retry.", "author": "rdblue", "createdAt": "2020-11-25T22:20:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0OTg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2NjEyNQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533066125", "bodyText": "Do you mean commit.retry.total-timeout-ms? commit.retry.max-wait-ms is only 60000ms which is 1 minute.", "author": "jackye1995", "createdAt": "2020-12-01T04:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0OTg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1MDQ1MQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530550451", "bodyText": "Typo: try -> trying. The current message makes it sound like its telling the reader to try to create the table.", "author": "rdblue", "createdAt": "2020-11-25T17:48:59Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NTAzMQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530595031", "bodyText": "Can the lock have a configurable type? eg DYNAMODB by default? We were hoping to leverage the work here to make nessie an option for the 'locking' mechanism here and bring nessie support to Glue. I hope to have a patch up soon to follow on from this.", "author": "rymurr", "createdAt": "2020-11-25T19:19:29Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = true;", "originalCommit": "8cb01808eff4d3fe8dee19467f3cd69aa85e165a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MjExMA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530672110", "bodyText": "I'm curious what this would look like.", "author": "rdblue", "createdAt": "2020-11-25T22:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NTAzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5MDY4MQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r531690681", "bodyText": "more info in my response to Jack.", "author": "rymurr", "createdAt": "2020-11-27T16:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NTAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NjcwNQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530596705", "bodyText": "Can we extend this interface a little bit? Again to help us w/ Nessie. Being able to pass at the very least the new metadata location would broaden the types of actions the implementer of this class can do.\nSimilar: Could we call this ConcurrencyManager or something similar? To hihglight that this is helping negotiate commit-ability rather than a pure lock mechanism?", "author": "rymurr", "createdAt": "2020-11-25T19:23:01Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+interface LockManager {\n+\n+  /**\n+   * Try to lock a table once\n+   * @param database Glue database name\n+   * @param table Glue table name\n+   * @param expireMillis max duration to hold the lock in milliseconds\n+   * @return if lock acquisition succeeded or not\n+   */\n+  boolean tryLock(String database, String table, long expireMillis);", "originalCommit": "8cb01808eff4d3fe8dee19467f3cd69aa85e165a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMzM5OA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530603398", "bodyText": "This code only locks at the table level. I think in future we can add additional methods here, e.g. based on the implementation we can have lock at the row level, folder level, etc.", "author": "giovannifumarola", "createdAt": "2020-11-25T19:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NjcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2NDIyOA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530664228", "bodyText": "Could you provide more details for what is needed in Nessie? I have not read too much into the Nessie package yet (will do during thanksgiving), but one thing I think make more sense for both use cases is to expose the interface like\nboolean tryLock(String lockId, long expireMillis);\n\nAnd then formulate the lock id based on different needs, does that work in your case?", "author": "jackye1995", "createdAt": "2020-11-25T22:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NjcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5MDUxMA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r531690510", "bodyText": "Sorry for the delay @jackye1995 . I've been thinking a lot about this and its not straigthtforward to do consistently. If nessie acts as the lock then acquiring the lock is effectively commiting the update to Nessie. A failure in the Glue layer would then require a rollback of nessie or the table is in an inconsistent state across Nessie/Glue. Obviously thats not acceptable, but possible. Let me think more and I can update you on Monday.\nI like your suggestion re lockId. Doing a String may not be quite right as it might need excessive parsing by the impl. Nessie specifically needs at minimum TableIdentifier (or some derivation of it) and the current metadata location. I guess dynamo needs simply the TableIdentifier. So we could add the metadata location to the interface or we can collapse into a lock id object of some sort? The unlock could then take that object?", "author": "rymurr", "createdAt": "2020-11-27T16:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NjcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg5ODQyNg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533898426", "bodyText": "For now I have updated the interface to take a Sting lockId. I am curious about how exactly are you thinking about integrating Nessie with Glue, so I am just leaving the interface to be as open as possible for easier integration in the future. The use of an object LockId seems a bit convoluted, since the interface was intended to be used as an internal lock mechanism for Glue catalog, but based on your description it's like Glue and Nessie doing duplicated work. Let's discuss this in slack and have another PR for the actual work if necessary.", "author": "jackye1995", "createdAt": "2020-12-02T05:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NjcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNTgxNA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530605814", "bodyText": "NIT:\nthis should be\npublic static final String AWS_GLUE_CATALOG_LOCK_ENABLED = AWS_GLUE_CATALOG + \"lock.enabled\";\npublic static final String AWS_GLUE_CATALOG = \"aws.gluecatalog.\";\nYou can reuse AWS_GLUE_CATALOG for the other properties.\nI would also add aws for readability.", "author": "giovannifumarola", "createdAt": "2020-11-25T19:42:30Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MDM3MA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530670370", "bodyText": "I'd prefer not to do this because it breaks grep or github search to find configuration strings. I think it is worth the duplication of \"gluecatalog\" to make it easy to search and find these.", "author": "rdblue", "createdAt": "2020-11-25T22:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNzMyOQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530607329", "bodyText": "This is not clear. We are using a single table for a single customer?", "author": "giovannifumarola", "createdAt": "2020-11-25T19:45:42Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * One lock table is designed to be used for only one catalog.", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2NzkzNQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533067935", "bodyText": "Because it is not straightforward to get a consistent glue catalog ID, unless we always initialize a client to fetch the AWS account and region from the caller, which creates lots of complications. By doing this, you basically have one dynamo lock table for one Glue catalog, which is simpler.", "author": "jackye1995", "createdAt": "2020-12-01T04:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNzMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNzcyNA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530607724", "bodyText": "NIT: Timeout", "author": "giovannifumarola", "createdAt": "2020-11-25T19:46:32Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * One lock table is designed to be used for only one catalog.\n+   * It is recommended to use a different table name for each Glue catalog.\n+   * If the table does not exist, it will be created at runtime.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_TABLE = \"gluecatalog.lock.table\";\n+  public static final String GLUE_CATALOG_LOCK_TABLE_DEFAULT = \"IcebergGlueCatalogLockTable\";\n+\n+  /**\n+   * After the given time in milliseconds, the process will give up the attempt to acquire a lock.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_WAIT = \"gluecatalog.lock.wait\";", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MjU0OQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530672549", "bodyText": "We also like to include the units to be clear, like commit.retry.min-wait-ms.", "author": "rdblue", "createdAt": "2020-11-25T22:23:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNzcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwODMyOA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530608328", "bodyText": "NIT: You can use PropertyUtil.propertyAs", "author": "giovannifumarola", "createdAt": "2020-11-25T19:47:49Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -182,6 +218,14 @@ public AwsProperties(Map<String, String> properties) {\n     this.s3FileIoAcl = ObjectCannedACL.fromValue(aclType);\n     Preconditions.checkArgument(s3FileIoAcl == null || !s3FileIoAcl.equals(ObjectCannedACL.UNKNOWN_TO_SDK_VERSION),\n         \"Cannot support S3 CannedACL \" + aclType);\n+\n+    this.glueCatalogLockEnabled = PropertyUtil.propertyAsBoolean(properties,\n+        GLUE_CATALOG_LOCK_ENABLED, GLUE_CATALOG_LOCK_ENABLED_DEFAULT);\n+    this.glueCatalogLockTable = properties.getOrDefault(GLUE_CATALOG_LOCK_TABLE, GLUE_CATALOG_LOCK_TABLE_DEFAULT);", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwOTM3Mw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530609373", "bodyText": "NIT: Javadoc.\ne.g.\n/** default implementation of lock manager... it returns always true etc.. mainly using for testing purposes or when no external locking systems are needed.\n*/", "author": "giovannifumarola", "createdAt": "2020-11-25T19:50:10Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DefaultLockManager.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+public class DefaultLockManager implements LockManager {\n+", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMDY4NQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530610685", "bodyText": "NIT: Javadoc.", "author": "giovannifumarola", "createdAt": "2020-11-25T19:53:05Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMTMyNw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530611327", "bodyText": "NIT: dynamoDbClient", "author": "giovannifumarola", "createdAt": "2020-11-25T19:54:26Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3ODc5Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533078792", "bodyText": "all the clients in the module are using the short name, that is why dynamo is used here.", "author": "jackye1995", "createdAt": "2020-12-01T05:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMTMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjg1Mw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530612853", "bodyText": "why pay per request instead of provisioned?", "author": "giovannifumarola", "createdAt": "2020-11-25T19:57:29Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3OTE4MA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533079180", "bodyText": "By having this, there is no cost if the table is created but not used. Users can manually change it or create the table by themselves through getLockTableSchema and getLockTableColDefinitions", "author": "jackye1995", "createdAt": "2020-12-01T05:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwNDkwOA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547504908", "bodyText": "This seems like a good thing to document.", "author": "rdblue", "createdAt": "2020-12-22T20:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzE2Nw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530613167", "bodyText": "add as config? or is it a standard aws timeout?", "author": "giovannifumarola", "createdAt": "2020-11-25T19:58:13Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MzAxMQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530673011", "bodyText": "I think this is one that doesn't need to be configured. It is just how long between checks, right?\nThat said, 5s seems a little long to me.", "author": "rdblue", "createdAt": "2020-11-25T22:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3OTUwNQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533079505", "bodyText": "Yes I don't think it needs to be configured. The table creation process in Dynamo typically take around 3-10 seconds, that is why I put 5 seconds.", "author": "jackye1995", "createdAt": "2020-12-01T05:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzg3Nw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530613877", "bodyText": "NIT: ensureTableExistsOrCreate\nbecause the function creates a table if does not exists.\n\"Ensure\" gives the impressions of a boolean check.", "author": "giovannifumarola", "createdAt": "2020-11-25T19:59:52Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDkwNQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530614905", "bodyText": "add log line.\nWe should inform if the item does not exist in the table.", "author": "giovannifumarola", "createdAt": "2020-11-25T20:01:47Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);\n+        }\n+        DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+            .tableName(tableName)\n+            .build());\n+        isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String database, String table, long expireMillis) {\n+    String tableId = tableId(database, table);\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_TABLE_ID, AttributeValue.builder().s(tableId).build());\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":tid\", AttributeValue.builder().s(tableId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(awsProperties.glueCatalogLockTable())\n+          .item(key)\n+          // succeed only if there is no lock, or the lock is there but already expired\n+          .conditionExpression(\"attribute_not_exists(\" +\n+              LOCK_TABLE_COL_TABLE_ID + \") OR (\" +\n+              LOCK_TABLE_COL_TABLE_ID + \" = :tid AND \" +\n+              LOCK_TABLE_COL_EXPIRE_TS_MILLIS + \" < :ts)\")\n+          .expressionAttributeValues(expressionValues)\n+          .build());\n+      return true;\n+    } catch (Exception e) {\n+      // most likely it's ConditionalCheckFailedException, but we will catch any exception\n+      LOG.debug(\"Acquiring lock {}.{} failed\", database, table, e);\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void unlock(String database, String table) {\n+    String tableId = tableId(database, table);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_TABLE_ID, AttributeValue.builder().s(tableId).build());\n+\n+    dynamo.deleteItem(DeleteItemRequest.builder()", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA4MDM5NQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533080395", "bodyText": "what log line do you mean? It does not throw exception or have any indication if it is not in the table.", "author": "jackye1995", "createdAt": "2020-12-01T05:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyNDU0MA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547524540", "bodyText": "I think we need to do a conditional delete to ensure that this does not release the lock held by another process. As long as that requires a conditional delete, it would make sense to add attribute_exists to ensure that this only succeeds if the lock exists and was still held by this process. Then a failure of either assumption will result in ConditionalCheckFailedException and this can log that the lock was no longer held.", "author": "rdblue", "createdAt": "2020-12-22T21:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTIzNQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530615235", "bodyText": "this should be warn.", "author": "giovannifumarola", "createdAt": "2020-11-25T20:02:31Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, try to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);\n+        }\n+        DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+            .tableName(tableName)\n+            .build());\n+        isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String database, String table, long expireMillis) {\n+    String tableId = tableId(database, table);\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_TABLE_ID, AttributeValue.builder().s(tableId).build());\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":tid\", AttributeValue.builder().s(tableId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(awsProperties.glueCatalogLockTable())\n+          .item(key)\n+          // succeed only if there is no lock, or the lock is there but already expired\n+          .conditionExpression(\"attribute_not_exists(\" +\n+              LOCK_TABLE_COL_TABLE_ID + \") OR (\" +\n+              LOCK_TABLE_COL_TABLE_ID + \" = :tid AND \" +\n+              LOCK_TABLE_COL_EXPIRE_TS_MILLIS + \" < :ts)\")\n+          .expressionAttributeValues(expressionValues)\n+          .build());\n+      return true;\n+    } catch (Exception e) {\n+      // most likely it's ConditionalCheckFailedException, but we will catch any exception\n+      LOG.debug(\"Acquiring lock {}.{} failed\", database, table, e);", "originalCommit": "4afaa87d34fef77570de66c93844837fa8c74ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4Nzc4Nw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530687787", "bodyText": "+1, personally speaking non-ConditionalCheckFailedException may even worth a log.error", "author": "yyanyy", "createdAt": "2020-11-25T23:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA4MDY0OA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533080648", "bodyText": "+1, personally speaking non-ConditionalCheckFailedException may even worth a log.error\n\nConditionalCheckFailedException is expected, that is why I put it only in debug log. But yes I agree non-ConditionalCheckFailedException should be error.", "author": "jackye1995", "createdAt": "2020-12-01T05:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NDk1Ng==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530684956", "bodyText": "Is \"One lock table is designed to be used for only one catalog\" still accurate? It seems to me that we are able to have one lock table controlling multiple catalogs? And I think if we do want to recommend one table per catalog, we probably want to update the default to be prefix + catalog name to follow our own recommendation just as Ryan commented above. Although I'm not super clear on what exactly is the benefit of having one ddb table per catalog...", "author": "yyanyy", "createdAt": "2020-11-25T23:01:43Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -114,6 +115,33 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * If {@link org.apache.iceberg.aws.glue.GlueCatalog} should use external lock or not, default to false.\n+   * If set to true, it will use DynamoDB to enforce locking during commits.\n+   */\n+  public static final String GLUE_CATALOG_LOCK_ENABLED = \"gluecatalog.lock.enabled\";\n+  public static final boolean GLUE_CATALOG_LOCK_ENABLED_DEFAULT = false;\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * One lock table is designed to be used for only one catalog.\n+   * It is recommended to use a different table name for each Glue catalog.", "originalCommit": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA4Njg4MQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533086881", "bodyText": "I think there will always be a confusion of Glue catalog ID versus the catalog name concept in Iceberg. The reason I don't want to do what you propose is that:\n\nwe will be forcing users to use the same catalog name for the same Glue catalog, which might not be the case, so I don't want to make catalog name the identifier for uniqueness.\nGetting the actual Glue catalog ID is not straightforward, there is no API for it and there might be proxies, different endpoints involved pointing to different catalogs, so it is hard to get a consistent id.\n\nI don't see any particular benefit for sharing the same dynamo table across all catalogs, since Dynamo itself is serverless and dividing them seems to have more flexibility, so I think the current design should be fine.", "author": "jackye1995", "createdAt": "2020-12-01T05:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NDk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTU2NQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530685565", "bodyText": "I think System.currentTimeMillis may lead to clock skew problem. DDBLockClient's implementation to workaround this problem is interesting, probably worth borrowing: https://github.com/awslabs/amazon-dynamodb-lock-client#how-we-handle-clock-skew", "author": "yyanyy", "createdAt": "2020-11-25T23:04:05Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);\n+        }\n+        DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+            .tableName(tableName)\n+            .build());\n+        isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String database, String table, long expireMillis) {\n+    String tableId = tableId(database, table);\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_TABLE_ID, AttributeValue.builder().s(tableId).build());\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)", "originalCommit": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA4OTYzMQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533089631", "bodyText": "yeah I thought about that but not sure if we need to handle it given the expiration is 20 minutes or more. And I don't fully understand what that method does, it says\nThe way locks are expired is that a call to acquireLock reads in the current lock, checks the RecordVersionNumber of the lock (which is a GUID) and starts a timer. If the lock still has the same GUID after the lease duration time has passed, the client will determine that the lock is stale and expire it.\n\nDoes that mean the next process has to wait for the duration of expiration to acquire the lock?", "author": "jackye1995", "createdAt": "2020-12-01T05:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3NDc2Ng==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533674766", "bodyText": "I think there's no guarantee on how far away the clock can skew, so 20min would reduce the chance but wouldn't fully avoid the problem. Regarding its explanation, I think in addition to expiration time it also has the concept of heartbeat which has a shorter duration than the expiration time, and the lock holding thread will need to heartbeat and update the GUID once a while to extend the lease, so that when another thread observes a GUID, wait for the expiration time, and come back and still see the same GUID, then that definitely means the old thread died. In this case we probably don't want to set expiration time to be as long as 20min since that would mean if a thread died even without concurrent thread waiting, the next coming thread will have to wait for 20min before considering the lock as expired.", "author": "yyanyy", "createdAt": "2020-12-01T19:42:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg2OTQzMw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533869433", "bodyText": "I see. I think this is probably a feature we should add after the initial commit of the lock interface if necessary, as long as we keep the interface consistent. Otherwise the PR will be too big. Let me add a comment for this for now.", "author": "jackye1995", "createdAt": "2020-12-02T03:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyMzYxOA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547523618", "bodyText": "I think that this should be handled soon. Correctness is the most important concern and I think clock skew is a significant problem. I like the approach of storing how long other clients should wait in the lock state to handle skew. We can implement heartbeats to reduce that wait time later, but I think it is important to fix it now. Otherwise, we will need to change the lock table and that's going to be more difficult to do without downtime and across library versions.", "author": "rdblue", "createdAt": "2020-12-22T21:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTgwNQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530685805", "bodyText": "I think we may still need to catch ResourceNotFoundException  here: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DescribeTable.html", "author": "yyanyy", "createdAt": "2020-11-25T23:05:03Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);\n+        }\n+        DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()", "originalCommit": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA4NzYyMg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533087622", "bodyText": "why? Given we already called create table and waited for 5 seconds", "author": "jackye1995", "createdAt": "2020-12-01T05:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3NzM3NA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533677374", "bodyText": "Since DescribeTable is eventually consistent, I don't think eventually consistency guarantees that 5s would be enough to settle? It's another \"the risk is lower but isn't fully mitigated\" case", "author": "yyanyy", "createdAt": "2020-12-01T19:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NjEyMQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530686121", "bodyText": "I think we might want some timeout (hard coded probably could be fine) to avoid staying in the loop forever", "author": "yyanyy", "createdAt": "2020-11-25T23:06:04Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {", "originalCommit": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA4OTcwOQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r533089709", "bodyText": "sounds good!", "author": "jackye1995", "createdAt": "2020-12-01T05:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NjEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NzMxNA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r530687314", "bodyText": "Do we want Thread.currentThread().interrupt here?", "author": "yyanyy", "createdAt": "2020-11-25T23:10:24Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_TABLE_ID = \"tableId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_TABLE_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(AwsProperties awsProperties) {\n+    this(AwsClientUtil.defaultDynamoClient(), awsProperties);\n+  }\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExists();\n+  }\n+\n+  private void ensureLockTableExists() {\n+    ensureTableExists(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExists(String tableName, List<KeySchemaElement> schema,\n+                                 List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      while (!isTableActive) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active\", tableName);\n+        try {\n+          Thread.sleep(5000);\n+        } catch (InterruptedException ie) {\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", e);", "originalCommit": "02b6ddababbedd4864acbd5d808b7d5950b2d8a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eedd4f17cb9bea8e555e2f974132730d96087386", "url": "https://github.com/apache/iceberg/commit/eedd4f17cb9bea8e555e2f974132730d96087386", "message": "AWS: Glue catalog locking through DynamoDB", "committedDate": "2020-12-02T04:23:57Z", "type": "forcePushed"}, {"oid": "af78fd4b37d2b8f8a174239f0bf9383a7615f630", "url": "https://github.com/apache/iceberg/commit/af78fd4b37d2b8f8a174239f0bf9383a7615f630", "message": "AWS: Glue catalog locking through DynamoDB", "committedDate": "2020-12-21T22:14:57Z", "type": "forcePushed"}, {"oid": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "url": "https://github.com/apache/iceberg/commit/17874b628e12aedb347b1e9303b6a7928d4b9bee", "message": "AWS: Glue catalog locking through DynamoDB", "committedDate": "2020-12-21T22:36:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ3MTc3Nw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547471777", "bodyText": "Does this change need to be in this PR?", "author": "rdblue", "createdAt": "2020-12-22T19:38:16Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/s3/S3FileIOTest.java", "diffHunk": "@@ -202,8 +201,7 @@ public void testACL() throws Exception {\n \n   @Test\n   public void testClientFactorySerialization() throws Exception {\n-    S3FileIO fileIO = new S3FileIO();\n-    fileIO.initialize(Maps.newHashMap());\n+    S3FileIO fileIO = new S3FileIO(clientFactory::s3);", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwOTQ5OQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547509499", "bodyText": "Otherwise it will throw exception because glue lock is not found when initializing AwsProperties. Changing the constructor resolves the issue.", "author": "jackye1995", "createdAt": "2020-12-22T21:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ3MTc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwMzExNw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547503117", "bodyText": "If this is used for testing, then why not implement it as an in-memory lock manager using synchronized methods? It seems strange to have a default lock manager that doesn't perform locking.", "author": "rdblue", "createdAt": "2020-12-22T20:54:55Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DefaultLockManager.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+/**\n+ * Default implementation of {@link LockManager} that always returns true.\n+ * It is mainly used for testing purposes or when no external locking systems are needed.\n+ */\n+public class DefaultLockManager implements LockManager {", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwNDY5OA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547504698", "bodyText": "Nit: there should be no need to add <>. If the table name is empty or null, that should be a separate exception.", "author": "rdblue", "createdAt": "2020-12-22T20:58:37Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwOTU0NQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547509545", "bodyText": "The return value of ++ should not be used in Iceberg because it is hard to reason about. Can you move the increment to a separate line?", "author": "rdblue", "createdAt": "2020-12-22T21:12:06Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwOTYyNA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547509624", "bodyText": "Nit: needs a newline between control flow statements.", "author": "rdblue", "createdAt": "2020-12-22T21:12:21Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwOTc2MA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547509760", "bodyText": "Nit: error messages should use sentence case: \"Describe table ...\"", "author": "rdblue", "createdAt": "2020-12-22T21:12:48Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMDE5OA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547510198", "bodyText": "This should break out of the loop when interrupted.", "author": "rdblue", "createdAt": "2020-12-22T21:14:00Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMDM5Ng==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547510396", "bodyText": "How about \"Timed out after %s ms waiting for table %s to become active\"?", "author": "rdblue", "createdAt": "2020-12-22T21:14:35Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);\n+        }\n+      }\n+\n+      if (!isTableActive) {\n+        throw new IllegalStateException(String.format(\"DynamoDB table <%s> failed to become active after %d ms\",\n+            tableName, LOCK_TABLE_CREATION_WAIT_MS * LOCK_TABLE_CREATION_WAIT_ROUNDS));", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMTA3MQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547511071", "bodyText": "I don't think that \"round\" is very clear. In most places we refer to this as an \"attempt\" or \"try\". What do you think about using \"attempt\" here?", "author": "rdblue", "createdAt": "2020-12-22T21:16:19Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMTIxNQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547511215", "bodyText": "Could this use Tasks instead of custom logic? That supports retries with a configurable backoff policy.", "author": "rdblue", "createdAt": "2020-12-22T21:16:42Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMTY0Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547511642", "bodyText": "Nit: No need for a newline at the start of a method.", "author": "rdblue", "createdAt": "2020-12-22T21:17:51Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);\n+        }\n+      }\n+\n+      if (!isTableActive) {\n+        throw new IllegalStateException(String.format(\"DynamoDB table <%s> failed to become active after %d ms\",\n+            tableName, LOCK_TABLE_CREATION_WAIT_MS * LOCK_TABLE_CREATION_WAIT_ROUNDS));\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String lockId, long expireMillis) {\n+", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMTcwNw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547511707", "bodyText": "Nit: double newline.", "author": "rdblue", "createdAt": "2020-12-22T21:17:59Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);\n+        }\n+      }\n+\n+      if (!isTableActive) {\n+        throw new IllegalStateException(String.format(\"DynamoDB table <%s> failed to become active after %d ms\",\n+            tableName, LOCK_TABLE_CREATION_WAIT_MS * LOCK_TABLE_CREATION_WAIT_ROUNDS));\n+      }\n+    }\n+  }\n+\n+", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMjc2Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547512762", "bodyText": "This is duplicated below when waiting for the table to become active. I think it would be cleaner to have a tableExists method:\n  private boolean tableExists(String tableName) {\n    try {\n      dynamo.describeTable(...);\n      return true;\n    } catch (ResourceNotFoundException e) {\n      return false;\n    }\n  }\nThen you could call that method here as well as in waitUntilActive. That would avoid having so much logic in a catch block.", "author": "rdblue", "createdAt": "2020-12-22T21:20:44Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxNzIzMw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547517233", "bodyText": "Iceberg generally avoids using \"get\" in names unless it is making the API more clear and understandable. Here, it is sufficient to use lockTableSchema() and lockTableColumnDefinitions()", "author": "rdblue", "createdAt": "2020-12-22T21:33:13Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);\n+        }\n+      }\n+\n+      if (!isTableActive) {\n+        throw new IllegalStateException(String.format(\"DynamoDB table <%s> failed to become active after %d ms\",\n+            tableName, LOCK_TABLE_CREATION_WAIT_MS * LOCK_TABLE_CREATION_WAIT_ROUNDS));\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String lockId, long expireMillis) {\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_LOCK_ID, AttributeValue.builder().s(lockId).build());\n+    // TODO: fix potential clock skew issue\n+    //   more details: https://github.com/awslabs/amazon-dynamodb-lock-client#how-we-handle-clock-skew\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":lid\", AttributeValue.builder().s(lockId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(awsProperties.glueCatalogLockTable())\n+          .item(key)\n+          // succeed only if there is no lock, or the lock is there but already expired\n+          .conditionExpression(\"attribute_not_exists(\" +\n+              LOCK_TABLE_COL_LOCK_ID + \") OR (\" +\n+              LOCK_TABLE_COL_LOCK_ID + \" = :lid AND \" +\n+              LOCK_TABLE_COL_EXPIRE_TS_MILLIS + \" < :ts)\")\n+          .expressionAttributeValues(expressionValues)\n+          .build());\n+      return true;\n+    } catch (ConditionalCheckFailedException e) {\n+      LOG.debug(\"Acquiring lock {} failed\", lockId, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Encountered unexpected exception when acquiring lock {}\", lockId, e);\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void unlock(String lockId) {\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_LOCK_ID, AttributeValue.builder().s(lockId).build());\n+\n+    dynamo.deleteItem(DeleteItemRequest.builder()\n+        .tableName(awsProperties.glueCatalogLockTable())\n+        .key(key)\n+        .build());\n+  }\n+\n+  /**\n+   * The lock table schema, for users who would like to create the table separately\n+   * @return lock table schema\n+   */\n+  public static List<KeySchemaElement> getLockTableSchema() {", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyMTE2Nw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547521167", "bodyText": "The condition expression used in tryLock allows another process to claim the lock if it appears to be expired. If that happens before the unlock runs in the process that originally held the lock, then unlocking will make the problem worse by deleting the lock held by the new process.\nI think this should be fixed by adding a UUID for the lock manager. A lock manager should only release a lock if it is still held. That is, if the UUID of the current holder matches the lock manager's UUID.", "author": "rdblue", "createdAt": "2020-12-22T21:43:57Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final long LOCK_TABLE_CREATION_WAIT_MS = 5000;\n+  private static final int LOCK_TABLE_CREATION_WAIT_ROUNDS = 10;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final DynamoDbClient dynamo;\n+  private final AwsProperties awsProperties;\n+\n+  DynamoLockManager(DynamoDbClient dynamo, AwsProperties awsProperties) {\n+    this.dynamo = dynamo;\n+    this.awsProperties = awsProperties;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(awsProperties.glueCatalogLockTable(), LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+    } catch (ResourceNotFoundException e) {\n+      LOG.info(\"Glue lock DynamoDB table <{}> not found, trying to create\", tableName);\n+      dynamo.createTable(CreateTableRequest.builder()\n+          .tableName(tableName)\n+          .keySchema(schema)\n+          .attributeDefinitions(definitions)\n+          .billingMode(BillingMode.PAY_PER_REQUEST)\n+          .build());\n+\n+      boolean isTableActive = false;\n+      int round = 0;\n+      while (!isTableActive && round < LOCK_TABLE_CREATION_WAIT_ROUNDS) {\n+        LOG.info(\"waiting for DynamoDB table <{}> to be active, round {}\", tableName, round++);\n+        try {\n+          Thread.sleep(LOCK_TABLE_CREATION_WAIT_MS);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+          LOG.warn(\"Glue lock DynamoDB table creation sleep interrupted\", ie);\n+        }\n+        try {\n+          DescribeTableResponse describeTableResponse = dynamo.describeTable(DescribeTableRequest.builder()\n+              .tableName(tableName)\n+              .build());\n+          isTableActive = describeTableResponse.table().tableStatus().equals(TableStatus.ACTIVE);\n+        } catch (ResourceNotFoundException e2) {\n+          LOG.error(\"describe table failed after table creation\", e2);\n+        }\n+      }\n+\n+      if (!isTableActive) {\n+        throw new IllegalStateException(String.format(\"DynamoDB table <%s> failed to become active after %d ms\",\n+            tableName, LOCK_TABLE_CREATION_WAIT_MS * LOCK_TABLE_CREATION_WAIT_ROUNDS));\n+      }\n+    }\n+  }\n+\n+\n+  @Override\n+  public boolean tryLock(String lockId, long expireMillis) {\n+\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_LOCK_ID, AttributeValue.builder().s(lockId).build());\n+    // TODO: fix potential clock skew issue\n+    //   more details: https://github.com/awslabs/amazon-dynamodb-lock-client#how-we-handle-clock-skew\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":lid\", AttributeValue.builder().s(lockId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(awsProperties.glueCatalogLockTable())\n+          .item(key)\n+          // succeed only if there is no lock, or the lock is there but already expired\n+          .conditionExpression(\"attribute_not_exists(\" +\n+              LOCK_TABLE_COL_LOCK_ID + \") OR (\" +\n+              LOCK_TABLE_COL_LOCK_ID + \" = :lid AND \" +\n+              LOCK_TABLE_COL_EXPIRE_TS_MILLIS + \" < :ts)\")\n+          .expressionAttributeValues(expressionValues)\n+          .build());\n+      return true;\n+    } catch (ConditionalCheckFailedException e) {\n+      LOG.debug(\"Acquiring lock {} failed\", lockId, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Encountered unexpected exception when acquiring lock {}\", lockId, e);\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void unlock(String lockId) {", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyNjkxMg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547526912", "bodyText": "Nit: Rather than creating a new string each time, could you do this once in the constructor?", "author": "rdblue", "createdAt": "2020-12-22T21:58:40Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();\n+    }\n+  }\n+\n+  private void acquireLock() {\n+    try {\n+      boolean lockAcquired = lockManager.tryLock(lockId(databaseName, tableName),\n+          awsProperties.glueCatalogLockExpireMs(), awsProperties.glueCatalogLockWaitMs());\n+      if (!lockAcquired) {\n+        throw new CommitFailedException(\"Timed out after %s ms waiting for lock on %s.%s\",\n+            awsProperties.glueCatalogLockWaitMs(), databaseName, tableName);\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new CommitFailedException(e, \"Thread interrupted during commit\");\n+    } catch (Exception e) {\n+      throw new CommitFailedException(e, \"Unexpected exception when locking %s.%s\", databaseName, tableName);\n     }\n   }\n \n+  private void unlock() {\n+    try {\n+      lockManager.unlock(lockId(databaseName, tableName));\n+    } catch (Exception e) {\n+      LOG.error(\"Unexpected exception when unlocking {}.{}, manual unlock might be needed\", databaseName, tableName, e);\n+    }\n+  }\n+\n+  private String lockId(String database, String table) {\n+    return String.format(\"%s.%s\", database, table);\n+  }", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyNzMwMg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547527302", "bodyText": "This should throw something other than CommitFailedException because that exception will cause a retry. When the commit is interrupted, I don't think that it should retry.", "author": "rdblue", "createdAt": "2020-12-22T21:59:38Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();\n+    }\n+  }\n+\n+  private void acquireLock() {\n+    try {\n+      boolean lockAcquired = lockManager.tryLock(lockId(databaseName, tableName),\n+          awsProperties.glueCatalogLockExpireMs(), awsProperties.glueCatalogLockWaitMs());\n+      if (!lockAcquired) {\n+        throw new CommitFailedException(\"Timed out after %s ms waiting for lock on %s.%s\",\n+            awsProperties.glueCatalogLockWaitMs(), databaseName, tableName);\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new CommitFailedException(e, \"Thread interrupted during commit\");", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyODQwMA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547528400", "bodyText": "Why does this throw CommitFailedException when the lock timeout expires and on any exception thrown by the lock manager?\nThat will cause a retry, which will try to acquire the lock again. I don't think that's the right behavior because failure to get the lock has already exceeded the lock retry timeout. To wait longer, just extend the lock timeout.", "author": "rdblue", "createdAt": "2020-12-22T22:02:44Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();\n+    }\n+  }\n+\n+  private void acquireLock() {", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEwNTc0OQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r548105749", "bodyText": "This is also following the behavior of HiveTableOperations. I think it makes sense to throw CommitFailedException because locking is a part of doCommit, so the failure to get lock is a type of commit failure. In the approach you described, the wait time can be long, and in the current approach the wait time is short for each retry.", "author": "jackye1995", "createdAt": "2020-12-23T18:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyODQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyOTYyOQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547529629", "bodyText": "Can you put this in a separate try/finally block?\nIf any of the exceptions above is thrown, then this needs to delete the metadata location. But if that for some reason fails, this also needs to attempt to unlock. Since both unlock and deleteFile must be done even if the other fails, we need to separate them into different finally blocks that are independent.", "author": "rdblue", "createdAt": "2020-12-22T22:06:06Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEwMjAzMw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r548102033", "bodyText": "Interesting, this is the same logic as HiveTableOperations, I thought about this issue and explained to myself that we will just wait for the lock to timeout in that case. We should probably do the same in Hive then.", "author": "jackye1995", "createdAt": "2020-12-23T18:07:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyOTYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMDAyOA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547530028", "bodyText": "This should not swallow the exception, it should re-throw it.\nI also think that there is no need to catch Exception here because there are no checked exceptions thrown by unlock. RuntimeException should be fine.", "author": "rdblue", "createdAt": "2020-12-22T22:07:09Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();\n+    }\n+  }\n+\n+  private void acquireLock() {\n+    try {\n+      boolean lockAcquired = lockManager.tryLock(lockId(databaseName, tableName),\n+          awsProperties.glueCatalogLockExpireMs(), awsProperties.glueCatalogLockWaitMs());\n+      if (!lockAcquired) {\n+        throw new CommitFailedException(\"Timed out after %s ms waiting for lock on %s.%s\",\n+            awsProperties.glueCatalogLockWaitMs(), databaseName, tableName);\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new CommitFailedException(e, \"Thread interrupted during commit\");\n+    } catch (Exception e) {\n+      throw new CommitFailedException(e, \"Unexpected exception when locking %s.%s\", databaseName, tableName);\n     }\n   }\n \n+  private void unlock() {\n+    try {\n+      lockManager.unlock(lockId(databaseName, tableName));\n+    } catch (Exception e) {\n+      LOG.error(\"Unexpected exception when unlocking {}.{}, manual unlock might be needed\", databaseName, tableName, e);", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMDEwMg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547530102", "bodyText": "Similar to unlock, this doesn't need to catch Exception.", "author": "rdblue", "createdAt": "2020-12-22T22:07:25Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -117,9 +120,39 @@ protected void doCommit(TableMetadata base, TableMetadata metadata) {\n       if (exceptionThrown) {\n         io().deleteFile(newMetadataLocation);\n       }\n+\n+      unlock();\n+    }\n+  }\n+\n+  private void acquireLock() {\n+    try {\n+      boolean lockAcquired = lockManager.tryLock(lockId(databaseName, tableName),\n+          awsProperties.glueCatalogLockExpireMs(), awsProperties.glueCatalogLockWaitMs());\n+      if (!lockAcquired) {\n+        throw new CommitFailedException(\"Timed out after %s ms waiting for lock on %s.%s\",\n+            awsProperties.glueCatalogLockWaitMs(), databaseName, tableName);\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new CommitFailedException(e, \"Thread interrupted during commit\");\n+    } catch (Exception e) {", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMTcyNg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547531726", "bodyText": "Can this use Tasks instead of custom retry logic?", "author": "rdblue", "createdAt": "2020-12-22T22:11:43Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+/**\n+ * An interface for locking, used to ensure Glue catalog commit isolation.\n+ */\n+interface LockManager {\n+\n+  /**\n+   * Try to acquire lock\n+   * @param lockId a unique id for the lock\n+   * @param expireMillis max duration to hold the lock in milliseconds\n+   * @return if lock acquisition succeeded or not\n+   */\n+  boolean tryLock(String lockId, long expireMillis);\n+\n+  /**\n+   * Try to acquire a lock in a given period of time\n+   * @param lockId a unique id for the lock\n+   * @param expireMillis max duration to hold the lock in milliseconds\n+   * @param waitMillis max time to try acquire the lock in milliseconds\n+   * @return if lock acquisition succeeded or not\n+   * @throws InterruptedException if sleep is interrupted between two tries to acquire the lock\n+   */\n+  default boolean tryLock(String lockId, long expireMillis, long waitMillis)\n+      throws InterruptedException {\n+    long limit = System.currentTimeMillis() + waitMillis;\n+    boolean succeeded = false;\n+    while (!succeeded && System.currentTimeMillis() < limit) {\n+      succeeded = tryLock(lockId, expireMillis);\n+      if (!succeeded) {\n+        Thread.sleep(50);\n+      }\n+    }\n+    return succeeded;", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMjE2Ng==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547532166", "bodyText": "Is there no way to programmatically run tests?", "author": "rdblue", "createdAt": "2020-12-22T22:12:59Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMzIzMA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547533230", "bodyText": "Tests already fail if an unexpected exception is thrown. I would remove the try/catch here.", "author": "rdblue", "createdAt": "2020-12-22T22:15:44Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMzg5OA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547533898", "bodyText": "If DynamoLockManager.tableExists is package-private, then you'd be able to call that here.", "author": "rdblue", "createdAt": "2020-12-22T22:17:49Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzNzQyOA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547537428", "bodyText": "Assertions like this should have context because if this fails, it just produces a generic error message like \"expected true\". It is better to explain what true means:\nAssert.assertTrue(\"Should successfully acquire the lock\", succeed);", "author": "rdblue", "createdAt": "2020-12-22T22:28:03Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzNzc4Mw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547537783", "bodyText": "If the lock stored the expiration interval, then this could assert that a result was received and that the interval is the one expected.", "author": "rdblue", "createdAt": "2020-12-22T22:29:02Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(\"database.table\").build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .key(key)\n+          .build());", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODQwNg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547538406", "bodyText": "I think what's happening here is that the attempts are deciding that others are expired. A comment would be helpful here.", "author": "rdblue", "createdAt": "2020-12-22T22:31:00Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(\"database.table\").build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT))\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(1, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testWaitLock_singleProcess() throws Exception {\n+    boolean succeed = lockManager.tryLock(\"database.table\",\n+        AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT,\n+        AwsProperties.GLUE_CATALOG_LOCK_WAIT_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(\"database.table\").build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testWaitLock_multiProcess_allSucceed() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            return lockManager.tryLock(\"database.table\", 10, 100000);", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODY4OA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547538688", "bodyText": "It seems to me that this should succeed because the lock manager holds the lock. I guess it doesn't need to be re-entrant.", "author": "rdblue", "createdAt": "2020-12-22T22:31:55Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(\"database.table\").build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT))", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODg5OA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547538898", "bodyText": "I think a better test would be to create two lock managers and use tryLock / unlock to show that the other will time out waiting to acquire the lock.\nThat's what we do in other cases, like when we are simulating two concurrent writes. We create two writers, start one and then commit the other, and finally verify that the original had to retry.", "author": "rdblue", "createdAt": "2020-12-22T22:32:37Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManagerTest.class);\n+\n+  private static final String DYNAMO_LOCAL_DOWNLOAD_URL =\n+      \"https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\";\n+  private static final String DYNAMO_LOCAL_DIR_NAME = \"/tmp/dynamo-local\";\n+  private static final int DYNAMO_LOCAL_SERVER_PORT = 2333;\n+  private static final String TABLE_NAME = \"dynamoLockTable\";\n+\n+  private Process dynamoLocalProcess;\n+  private DynamoDbClient dynamo;\n+  private AwsProperties properties;\n+  private LockManager lockManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    Process pr = rt.exec(String.format(\"curl %s -o %s.tar.gz\", DYNAMO_LOCAL_DOWNLOAD_URL, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"mkdir %s\", DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+    pr = rt.exec(String.format(\"tar xvzf %s.tar.gz -C %s\", DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME));\n+    pr.waitFor();\n+  }\n+\n+  @Before\n+  public void before() throws Exception {\n+    Runtime rt = Runtime.getRuntime();\n+    dynamoLocalProcess = rt.exec(String.format(\"java -Djava.library.path=%s/DynamoDBLocal_lib -jar \" +\n+            \"%s/DynamoDBLocal.jar -inMemory -port %s\",\n+        DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_DIR_NAME, DYNAMO_LOCAL_SERVER_PORT));\n+    Thread.sleep(1000); // wait for start\n+    dynamo = DynamoDbClient.builder()\n+        .endpointOverride(URI.create(String.format(\"http://0.0.0.0:%d/\", DYNAMO_LOCAL_SERVER_PORT)))\n+        .region(Region.US_EAST_1) // dummy region\n+        .credentialsProvider(StaticCredentialsProvider.create(\n+            AwsBasicCredentials.create(\"key\", \"secret\"))) // dummy credential\n+        .httpClient(UrlConnectionHttpClient.create())\n+        .build();\n+    properties = new AwsProperties();\n+    properties.setGlueCatalogLockEnabled(true);\n+    properties.setGlueCatalogLockTable(TABLE_NAME);\n+    lockManager = new DynamoLockManager(dynamo, properties);\n+  }\n+\n+  @After\n+  public void after() throws Exception {\n+    dynamo.deleteTable(DeleteTableRequest.builder()\n+        .tableName(TABLE_NAME)\n+        .build());\n+    dynamoLocalProcess.destroy();\n+    dynamoLocalProcess.waitFor();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() throws Exception {\n+    Runtime.getRuntime().exec(String.format(\"rm %s.tar.gz\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+    Runtime.getRuntime().exec(String.format(\"rm -rf %s\", DYNAMO_LOCAL_DIR_NAME)).waitFor();\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(\"database.table\", AwsProperties.GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(\"database.table\").build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(TABLE_NAME)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzOTU4Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547539582", "bodyText": "Nit: unnecessary whitespace change.", "author": "rdblue", "createdAt": "2020-12-22T22:34:34Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/GlueCatalogTest.java", "diffHunk": "@@ -80,14 +80,16 @@ public void constructor_emptyWarehousePath() {\n         \"Cannot initialize GlueCatalog because warehousePath must not be null\",\n         () -> {\n             GlueCatalog catalog = new GlueCatalog();\n-            catalog.initialize(CATALOG_NAME, null, new AwsProperties(), glue, null);\n+            catalog.initialize(CATALOG_NAME, null, new AwsProperties(), glue, new DefaultLockManager(), null);\n         });\n   }\n \n   @Test\n   public void constructor_warehousePathWithEndSlash() {\n+", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0MDE3NQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547540175", "bodyText": "You might want to just copy testConcurrentFastAppends. We know that does a good job of catching collisions. https://github.com/apache/iceberg/blob/master/hive-metastore/src/test/java/org/apache/iceberg/hive/TestHiveTableConcurrency.java#L45-L79", "author": "rdblue", "createdAt": "2020-12-22T22:36:12Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/GlueCatalogLockTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AppendFiles;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PendingUpdate;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.aws.s3.S3FileIO;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+\n+public class GlueCatalogLockTest extends GlueTestBase {\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    GlueTestBase.beforeClass();\n+    String testBucketPath = \"s3://\" + testBucketName + \"/\" + testPathPrefix;\n+    lockTableName = getRandomName();\n+    S3FileIO fileIO = new S3FileIO(clientFactory::s3);\n+    glueCatalog = new GlueCatalog();\n+    AwsProperties awsProperties = new AwsProperties();\n+    awsProperties.setGlueCatalogLockTable(lockTableName);\n+    awsProperties.setGlueCatalogLockEnabled(true);\n+    dynamo = clientFactory.dynamo();\n+    glueCatalog.initialize(catalogName, testBucketPath, awsProperties, glue,\n+        new DynamoLockManager(dynamo, awsProperties), fileIO);\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    GlueTestBase.afterClass();\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testParallelCommit() {", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NTQ4MQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547555481", "bodyText": "Shouldn't this use GLUE_CATALOG_LOCK_ENABLED_DEFAULT?", "author": "rdblue", "createdAt": "2020-12-22T23:26:57Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -155,6 +196,10 @@ public AwsProperties() {\n \n     this.glueCatalogId = null;\n     this.glueCatalogSkipArchive = GLUE_CATALOG_SKIP_ARCHIVE_DEFAULT;\n+    this.glueCatalogLockEnabled = false;", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NTY0Mw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547555643", "bodyText": "Typo: \"GLue\" -> \"Glue\"", "author": "rdblue", "createdAt": "2020-12-22T23:27:36Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -198,6 +243,19 @@ public AwsProperties(Map<String, String> properties) {\n     this.s3FileIoAcl = ObjectCannedACL.fromValue(aclType);\n     Preconditions.checkArgument(s3FileIoAcl == null || !s3FileIoAcl.equals(ObjectCannedACL.UNKNOWN_TO_SDK_VERSION),\n         \"Cannot support S3 CannedACL \" + aclType);\n+\n+    this.glueCatalogLockEnabled = PropertyUtil.propertyAsBoolean(properties,\n+        GLUE_CATALOG_LOCK_ENABLED, GLUE_CATALOG_LOCK_ENABLED_DEFAULT);\n+    this.glueCatalogLockTable = properties.get(GLUE_CATALOG_LOCK_TABLE);\n+    this.glueCatalogLockWaitMs = PropertyUtil.propertyAsLong(properties,\n+        GLUE_CATALOG_LOCK_WAIT_MS, GLUE_CATALOG_LOCK_WAIT_MS_DEFAULT);\n+    this.glueCatalogLockExpireMs = PropertyUtil.propertyAsLong(properties,\n+        GLUE_CATALOG_LOCK_MS_EXPIRE, GLUE_CATALOG_LOCK_EXPIRE_MS_DEFAULT);\n+\n+    if (glueCatalogLockEnabled) {\n+      Preconditions.checkNotNull(glueCatalogLockTable,\n+          GLUE_CATALOG_LOCK_TABLE + \" must not be null with GLue catalog lock is enabled\");", "originalCommit": "17874b628e12aedb347b1e9303b6a7928d4b9bee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NTkwOA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r547555908", "bodyText": "Also, I think we normally use \"is required\" instead of \"must not be null\". Null is what we get when it isn't set, but we don't need to call attention to that value. We need to tell the user what is wrong, which is that a required configuration is missing.", "author": "rdblue", "createdAt": "2020-12-22T23:28:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NTY0Mw=="}], "type": "inlineReview"}, {"oid": "2c565d5b408a80115935899450b54a96dcf0405e", "url": "https://github.com/apache/iceberg/commit/2c565d5b408a80115935899450b54a96dcf0405e", "message": "AWS: Glue catalog locking through DynamoDB", "committedDate": "2020-12-23T17:58:38Z", "type": "forcePushed"}, {"oid": "4f94b13edc7e6a10e85385e1493e9fee02853346", "url": "https://github.com/apache/iceberg/commit/4f94b13edc7e6a10e85385e1493e9fee02853346", "message": "AWS: Glue catalog locking through DynamoDB", "committedDate": "2020-12-23T21:46:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNzc3OA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549517778", "bodyText": "The test will already fail if an unexpected exception is thrown. Is there value in adding extra code here to do the same thing?", "author": "rdblue", "createdAt": "2020-12-28T23:31:40Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LockManagerTest.class);\n+\n+  private static final String DATABASE = \"database\";\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  private LockManager lockManager;\n+  private String tableName;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    lockTableName = genTableName();\n+    dynamo = AwsClientFactories.defaultFactory().dynamo();\n+  }\n+\n+  @Before\n+  public void before() {\n+    lockManager = new DynamoLockManager(dynamo, lockTableName);\n+    tableName = genTableName();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(lockTableName)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");", "originalCommit": "951291449040a6127da99fcb40ec65faf46564c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxODg4Nw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549518887", "bodyText": "What about using lock.table? I'm not sure that \"dynamo\" needs to be in the property name because it doesn't provide much value.", "author": "rdblue", "createdAt": "2020-12-28T23:37:58Z", "path": "aws/src/main/java/org/apache/iceberg/aws/AwsProperties.java", "diffHunk": "@@ -130,6 +131,37 @@\n    */\n   public static final String S3FILEIO_ACL = \"s3fileio.acl\";\n \n+  /**\n+   * The implementation of LockManager to use for concurrent commits.\n+   */\n+  public static final String LOCK_IMPL = \"lock.impl\";\n+\n+  /**\n+   * After the given time in milliseconds, the process will give up the attempt to acquire a lock.\n+   * Default to 3 minutes.\n+   */\n+  public static final String LOCK_WAIT_MS = \"lock.wait-ms\";\n+  public static final long LOCK_WAIT_MS_DEFAULT = TimeUnit.MINUTES.toMillis(3);\n+\n+  /**\n+   * After the given time in milliseconds, the lock is automatically expired.\n+   * Default to 20 minutes.\n+   */\n+  public static final String LOCK_EXPIRE_MS = \"lock.expire-ms\";\n+  public static final long LOCK_EXPIRE_MS_DEFAULT = TimeUnit.MINUTES.toMillis(20);\n+\n+  /**\n+   * The DynamoDB table used for locking.\n+   * <p>\n+   * The table name must be explicitly provided as an input when lock is enabled.\n+   * This ensures the user is aware of the use of a DynamoDB table that might incur cost.\n+   * Each glue catalog should use a different DynamoDB table for locking,\n+   * otherwise tables with the same name from different catalog will block each other's commit.\n+   * If the table with the given name does not exist,\n+   * the table will be created at runtime with billing mode set to PAY_PER_REQUEST.\n+   */\n+  public static final String LOCK_DYNAMO_TABLE = \"lock.dynamo.table\";", "originalCommit": "951291449040a6127da99fcb40ec65faf46564c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTM0Nw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549519347", "bodyText": "Minor: seems odd to have a separate method when the schema and definitions are always the same and this isn't called from elsewhere.", "author": "rdblue", "createdAt": "2020-12-28T23:40:41Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final int LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX = 5;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private DynamoDbClient dynamo;\n+  private String lockTableName;\n+\n+  /**\n+   * constructor for dynamic initialization, {@link #initialize(Map)} must be called later.\n+   */\n+  DynamoLockManager() {\n+  }\n+\n+  /**\n+   * All arg constructor, used for testing purpose\n+   * @param dynamo dynamo client\n+   * @param lockTableName lock table name\n+   */\n+  DynamoLockManager(DynamoDbClient dynamo, String lockTableName) {\n+    this.dynamo = dynamo;\n+    this.lockTableName = lockTableName;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(lockTableName, LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,", "originalCommit": "951291449040a6127da99fcb40ec65faf46564c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTc0MQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549519741", "bodyText": "Since this should only retry on IllegalStateException, I think you should use onlyRetryOn(IllegalStateException.class). That way, other exceptions thrown from the Dynamo client won't cause retries that just take longer to fail.", "author": "rdblue", "createdAt": "2020-12-28T23:43:11Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final int LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX = 5;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private DynamoDbClient dynamo;\n+  private String lockTableName;\n+\n+  /**\n+   * constructor for dynamic initialization, {@link #initialize(Map)} must be called later.\n+   */\n+  DynamoLockManager() {\n+  }\n+\n+  /**\n+   * All arg constructor, used for testing purpose\n+   * @param dynamo dynamo client\n+   * @param lockTableName lock table name\n+   */\n+  DynamoLockManager(DynamoDbClient dynamo, String lockTableName) {\n+    this.dynamo = dynamo;\n+    this.lockTableName = lockTableName;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(lockTableName, LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    if (tableExists(tableName)) {\n+      return;\n+    }\n+\n+    LOG.info(\"Dynamo lock table {} not found, trying to create\", tableName);\n+    dynamo.createTable(CreateTableRequest.builder()\n+        .tableName(tableName)\n+        .keySchema(schema)\n+        .attributeDefinitions(definitions)\n+        .billingMode(BillingMode.PAY_PER_REQUEST)\n+        .build());\n+\n+    Tasks.foreach(tableName)\n+        .retry(LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX)\n+        .throwFailureWhenFinished()", "originalCommit": "951291449040a6127da99fcb40ec65faf46564c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTkzNA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549519934", "bodyText": "It is better to avoid including class, method, or variable names in messages because the user often won't be familiar with this code's variable names. Instead, use \"Table name\" or \"Lock table name\" because that's what the user sets.", "author": "rdblue", "createdAt": "2020-12-28T23:44:29Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final int LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX = 5;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private DynamoDbClient dynamo;\n+  private String lockTableName;\n+\n+  /**\n+   * constructor for dynamic initialization, {@link #initialize(Map)} must be called later.\n+   */\n+  DynamoLockManager() {\n+  }\n+\n+  /**\n+   * All arg constructor, used for testing purpose\n+   * @param dynamo dynamo client\n+   * @param lockTableName lock table name\n+   */\n+  DynamoLockManager(DynamoDbClient dynamo, String lockTableName) {\n+    this.dynamo = dynamo;\n+    this.lockTableName = lockTableName;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(lockTableName, LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    if (tableExists(tableName)) {\n+      return;\n+    }\n+\n+    LOG.info(\"Dynamo lock table {} not found, trying to create\", tableName);\n+    dynamo.createTable(CreateTableRequest.builder()\n+        .tableName(tableName)\n+        .keySchema(schema)\n+        .attributeDefinitions(definitions)\n+        .billingMode(BillingMode.PAY_PER_REQUEST)\n+        .build());\n+\n+    Tasks.foreach(tableName)\n+        .retry(LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX)\n+        .throwFailureWhenFinished()\n+        .run(this::checkTableActive);\n+  }\n+\n+  private boolean tableExists(String tableName) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      return true;\n+    } catch (ResourceNotFoundException e) {\n+      return false;\n+    }\n+  }\n+\n+  private void checkTableActive(String tableName) {\n+    try {\n+      DescribeTableResponse response = dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      TableStatus currentStatus = response.table().tableStatus();\n+      if (!currentStatus.equals(TableStatus.ACTIVE)) {\n+        throw new IllegalStateException(String.format(\"Dynamo table %s is not active, current status: %s\",\n+            tableName, currentStatus));\n+      }\n+    } catch (ResourceNotFoundException e) {\n+      throw new IllegalStateException(String.format(\"Cannot find Dynamo table %s\", tableName));\n+    }\n+  }\n+\n+  @Override\n+  public void initialize(Map<String, String> properties) {\n+    this.dynamo = AwsClientFactories.from(properties).dynamo();\n+    this.lockTableName = properties.get(AwsProperties.LOCK_DYNAMO_TABLE);\n+    Preconditions.checkNotNull(lockTableName, \"tableName must not be null\");", "originalCommit": "951291449040a6127da99fcb40ec65faf46564c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDIzMw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549520233", "bodyText": "Nit: unnecessary newline.", "author": "rdblue", "createdAt": "2020-12-28T23:46:07Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager implements LockManager {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String LOCK_TABLE_COL_LOCK_ID = \"lockId\";\n+  private static final String LOCK_TABLE_COL_EXPIRE_TS_MILLIS = \"expireTimestampMillis\";\n+  private static final int LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX = 5;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(LOCK_TABLE_COL_LOCK_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private DynamoDbClient dynamo;\n+  private String lockTableName;\n+\n+  /**\n+   * constructor for dynamic initialization, {@link #initialize(Map)} must be called later.\n+   */\n+  DynamoLockManager() {\n+  }\n+\n+  /**\n+   * All arg constructor, used for testing purpose\n+   * @param dynamo dynamo client\n+   * @param lockTableName lock table name\n+   */\n+  DynamoLockManager(DynamoDbClient dynamo, String lockTableName) {\n+    this.dynamo = dynamo;\n+    this.lockTableName = lockTableName;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+    ensureTableExistsOrCreate(lockTableName, LOCK_TABLE_SCHEMA, LOCK_TABLE_COL_DEFINITIONS);\n+  }\n+\n+  private void ensureTableExistsOrCreate(String tableName, List<KeySchemaElement> schema,\n+                                         List<AttributeDefinition> definitions) {\n+    if (tableExists(tableName)) {\n+      return;\n+    }\n+\n+    LOG.info(\"Dynamo lock table {} not found, trying to create\", tableName);\n+    dynamo.createTable(CreateTableRequest.builder()\n+        .tableName(tableName)\n+        .keySchema(schema)\n+        .attributeDefinitions(definitions)\n+        .billingMode(BillingMode.PAY_PER_REQUEST)\n+        .build());\n+\n+    Tasks.foreach(tableName)\n+        .retry(LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX)\n+        .throwFailureWhenFinished()\n+        .run(this::checkTableActive);\n+  }\n+\n+  private boolean tableExists(String tableName) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      return true;\n+    } catch (ResourceNotFoundException e) {\n+      return false;\n+    }\n+  }\n+\n+  private void checkTableActive(String tableName) {\n+    try {\n+      DescribeTableResponse response = dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      TableStatus currentStatus = response.table().tableStatus();\n+      if (!currentStatus.equals(TableStatus.ACTIVE)) {\n+        throw new IllegalStateException(String.format(\"Dynamo table %s is not active, current status: %s\",\n+            tableName, currentStatus));\n+      }\n+    } catch (ResourceNotFoundException e) {\n+      throw new IllegalStateException(String.format(\"Cannot find Dynamo table %s\", tableName));\n+    }\n+  }\n+\n+  @Override\n+  public void initialize(Map<String, String> properties) {\n+    this.dynamo = AwsClientFactories.from(properties).dynamo();\n+    this.lockTableName = properties.get(AwsProperties.LOCK_DYNAMO_TABLE);\n+    Preconditions.checkNotNull(lockTableName, \"tableName must not be null\");\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  @Override\n+  public boolean tryLock(String lockId, long expireMillis) {\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(LOCK_TABLE_COL_LOCK_ID, AttributeValue.builder().s(lockId).build());\n+    // TODO: fix potential clock skew issue\n+    //   more details: https://github.com/awslabs/amazon-dynamodb-lock-client#how-we-handle-clock-skew\n+    key.put(LOCK_TABLE_COL_EXPIRE_TS_MILLIS, AttributeValue.builder().n(\n+        Long.toString(System.currentTimeMillis() + expireMillis)\n+    ).build());\n+\n+    Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+    expressionValues.put(\":lid\", AttributeValue.builder().s(lockId).build());\n+    expressionValues.put(\":ts\", AttributeValue.builder().n(Long.toString(System.currentTimeMillis())).build());\n+\n+    try {\n+", "originalCommit": "951291449040a6127da99fcb40ec65faf46564c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTQyOA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549521428", "bodyText": "I think that this should validate that the lock is correctly held by the expected lock manager. Since there isn't an ID for the lock manager yet, it should at least validate that there is a valid timestamp in the table.", "author": "rdblue", "createdAt": "2020-12-28T23:53:43Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LockManagerTest.class);\n+\n+  private static final String DATABASE = \"database\";\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  private LockManager lockManager;\n+  private String tableName;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    lockTableName = genTableName();\n+    dynamo = AwsClientFactories.defaultFactory().dynamo();\n+  }\n+\n+  @Before\n+  public void before() {\n+    lockManager = new DynamoLockManager(dynamo, lockTableName);\n+    tableName = genTableName();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(lockTableName)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()", "originalCommit": "951291449040a6127da99fcb40ec65faf46564c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTU2Ng==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549521566", "bodyText": "I think this should create different lock managers to simulate multiple processes, not use the same one.", "author": "rdblue", "createdAt": "2020-12-28T23:54:30Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LockManagerTest.class);\n+\n+  private static final String DATABASE = \"database\";\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  private LockManager lockManager;\n+  private String tableName;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    lockTableName = genTableName();\n+    dynamo = AwsClientFactories.defaultFactory().dynamo();\n+  }\n+\n+  @Before\n+  public void before() {\n+    lockManager = new DynamoLockManager(dynamo, lockTableName);\n+    tableName = genTableName();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(lockTableName)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(lockTableName)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> lockManager.tryLock(tableId(tableName),", "originalCommit": "951291449040a6127da99fcb40ec65faf46564c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTgxMQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549521811", "bodyText": "This doesn't test unlock, it tests that lock succeeds after dropping the lock item in the table.", "author": "rdblue", "createdAt": "2020-12-28T23:55:57Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LockManagerTest.class);\n+\n+  private static final String DATABASE = \"database\";\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  private LockManager lockManager;\n+  private String tableName;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    lockTableName = genTableName();\n+    dynamo = AwsClientFactories.defaultFactory().dynamo();\n+  }\n+\n+  @Before\n+  public void before() {\n+    lockManager = new DynamoLockManager(dynamo, lockTableName);\n+    tableName = genTableName();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(lockTableName)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(lockTableName)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> lockManager.tryLock(tableId(tableName),\n+            AwsProperties.LOCK_EXPIRE_MS_DEFAULT))\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(1, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testWaitLock_singleProcess() throws Exception {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT,\n+        AwsProperties.LOCK_WAIT_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(lockTableName)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testWaitLock_multiProcess_allSucceed() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            return lockManager.tryLock(tableId(tableName), 10, 100000);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"lock acquire interrupted\", e);\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(100, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testWaitLock_multiProcess_allFail() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            return lockManager.tryLock(tableId(tableName), 1000000, 10);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"lock acquire interrupted\", e);\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(1, results.stream().filter(s -> s).count());\n+  }\n+\n+\n+  @Test\n+  public void testUnlock() {", "originalCommit": "951291449040a6127da99fcb40ec65faf46564c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMjA3OQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r549522079", "bodyText": "Considering the lock only uses an ID string, I don't think that this method is needed. You could just use a static ID string.", "author": "rdblue", "createdAt": "2020-12-28T23:57:08Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/DynamoLockManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+\n+public class DynamoLockManagerTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LockManagerTest.class);\n+\n+  private static final String DATABASE = \"database\";\n+\n+  private static String lockTableName;\n+  private static DynamoDbClient dynamo;\n+\n+  private LockManager lockManager;\n+  private String tableName;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    lockTableName = genTableName();\n+    dynamo = AwsClientFactories.defaultFactory().dynamo();\n+  }\n+\n+  @Before\n+  public void before() {\n+    lockManager = new DynamoLockManager(dynamo, lockTableName);\n+    tableName = genTableName();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    dynamo.deleteTable(DeleteTableRequest.builder().tableName(lockTableName).build());\n+  }\n+\n+  @Test\n+  public void testTableCreation() {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(lockTableName)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when describing DynamoDB lock table\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_singleProcess() {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(lockTableName)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testLock_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> lockManager.tryLock(tableId(tableName),\n+            AwsProperties.LOCK_EXPIRE_MS_DEFAULT))\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(1, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testWaitLock_singleProcess() throws Exception {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT,\n+        AwsProperties.LOCK_WAIT_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    try {\n+      dynamo.getItem(GetItemRequest.builder()\n+          .tableName(lockTableName)\n+          .key(key)\n+          .build());\n+    } catch (Exception e) {\n+      LOG.error(\"encountered failure\", e);\n+      Assert.fail(\"Should not throw exception when getting lock after insert\");\n+    }\n+  }\n+\n+  @Test\n+  public void testWaitLock_multiProcess_allSucceed() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            return lockManager.tryLock(tableId(tableName), 10, 100000);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"lock acquire interrupted\", e);\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(100, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testWaitLock_multiProcess_allFail() {\n+    List<Boolean> results = IntStream.range(0, 100).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            return lockManager.tryLock(tableId(tableName), 1000000, 10);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"lock acquire interrupted\", e);\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(1, results.stream().filter(s -> s).count());\n+  }\n+\n+\n+  @Test\n+  public void testUnlock() {\n+    boolean succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+    Map<String, AttributeValue> key = Maps.newHashMap();\n+    key.put(\"lockId\", AttributeValue.builder().s(tableId(tableName)).build());\n+    dynamo.deleteItem(DeleteItemRequest.builder()\n+        .tableName(lockTableName)\n+        .key(key)\n+        .build());\n+    succeed = lockManager.tryLock(tableId(tableName),\n+        AwsProperties.LOCK_EXPIRE_MS_DEFAULT);\n+    Assert.assertTrue(succeed);\n+  }\n+\n+  @Test\n+  public void testTableCreationFailure() {\n+    DynamoDbClient dynamo2 = Mockito.mock(DynamoDbClient.class);\n+    Mockito.doThrow(ResourceNotFoundException.class).when(dynamo2)\n+        .describeTable(Mockito.any(DescribeTableRequest.class));\n+    AssertHelpers.assertThrows(\"should fail to initialize the lock manager\",\n+        IllegalStateException.class,\n+        \"Cannot find Dynamo table\",\n+        () -> new DynamoLockManager(dynamo2, lockTableName));\n+  }\n+\n+  private static String tableId(String tableName) {", "originalCommit": "951291449040a6127da99fcb40ec65faf46564c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1855b4ea40d020c178d5a454b99d1639dfedfce1", "url": "https://github.com/apache/iceberg/commit/1855b4ea40d020c178d5a454b99d1639dfedfce1", "message": "AWS: Glue catalog locking through DynamoDB", "committedDate": "2020-12-30T00:57:34Z", "type": "forcePushed"}, {"oid": "5794af1414902a7a4d464dc947f34a89f60e7e10", "url": "https://github.com/apache/iceberg/commit/5794af1414902a7a4d464dc947f34a89f60e7e10", "message": "AWS: Glue catalog locking through DynamoDB", "committedDate": "2020-12-30T01:54:15Z", "type": "forcePushed"}, {"oid": "4d9b78176102d7cfa1234b04af780725554a74f8", "url": "https://github.com/apache/iceberg/commit/4d9b78176102d7cfa1234b04af780725554a74f8", "message": "AWS: Glue catalog locking through DynamoDB", "committedDate": "2020-12-30T04:04:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDM2Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694362", "bodyText": "Why does this include owner ID? If it identifies a lock, that shouldn't depend on owner. And if this identifies a lock, what is the entity ID?\nIt seems like you want the lock manager to have an ID (owner ID) and a lock to have an ID (entity ID), but this mixes them together.", "author": "rdblue", "createdAt": "2020-12-31T21:35:39Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+/**\n+ * An interface for locking, used to ensure Glue catalog commit isolation.\n+ */\n+interface LockManager extends AutoCloseable {\n+\n+  /**\n+   * Try to acquire a lock\n+   * @param lockId lock ID\n+   * @throws LockNotAcquiredException if lock is not acquired\n+   */\n+  void acquire(LockId lockId);\n+\n+  /**\n+   * Release a lock\n+   * @param lockId lock ID\n+   * @throws IllegalArgumentException if lock entity not found or trying to unlock with a wrong owner ID\n+   */\n+  void release(LockId lockId);\n+\n+  /**\n+   * Initialize lock manager from catalog properties.\n+   * @param properties catalog properties\n+   */\n+  void initialize(Map<String, String> properties);\n+\n+  class LockId {\n+\n+    private final String entityId;\n+    private final String ownerId;\n+\n+    LockId(String entityId, String ownerId) {", "originalCommit": "4d9b78176102d7cfa1234b04af780725554a74f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5OTg3Mw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550699873", "bodyText": "The reason I did not use an id for the lock manager is that one lock manager can acquire an entity for multiple times when it is used in multiple threads. By using the newMetadataLocation as the ownerId, we guarantee only the lock owner can unlock.\nMaybe LockId is not a good concept to group those two concepts, I can separate them and directly use these terms in the method signature, make it like acquire(String entityId, String ownerId).", "author": "jackye1995", "createdAt": "2020-12-31T22:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDQxNw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694417", "bodyText": "Why not use lock and unlock?", "author": "rdblue", "createdAt": "2020-12-31T21:36:03Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+/**\n+ * An interface for locking, used to ensure Glue catalog commit isolation.\n+ */\n+interface LockManager extends AutoCloseable {\n+\n+  /**\n+   * Try to acquire a lock\n+   * @param lockId lock ID\n+   * @throws LockNotAcquiredException if lock is not acquired\n+   */\n+  void acquire(LockId lockId);", "originalCommit": "4d9b78176102d7cfa1234b04af780725554a74f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDcwMDE1NA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550700154", "bodyText": "Not a significant reason at all, but otherwise the config key would be like lock.lock-timeout-ms which has 2 locks...\nI am okay with either lock & unlock or acquire & release.", "author": "jackye1995", "createdAt": "2020-12-31T22:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDU5Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694592", "bodyText": "Why would a lock need more than one heartbeat thread?", "author": "rdblue", "createdAt": "2020-12-31T21:37:14Z", "path": "core/src/main/java/org/apache/iceberg/CatalogProperties.java", "diffHunk": "@@ -31,4 +33,24 @@ private CatalogProperties() {\n   public static final String HIVE_URI = \"uri\";\n   public static final String HIVE_CLIENT_POOL_SIZE = \"clients\";\n   public static final int HIVE_CLIENT_POOL_SIZE_DEFAULT = 2;\n+\n+  public static final String LOCK_IMPL = \"lock.impl\";\n+\n+  public static final String LOCK_HEARTBEAT_INTERVAL_MS = \"lock.heartbeat-interval-ms\";\n+  public static final long LOCK_HEARTBEAT_INTERVAL_MS_DEFAULT = TimeUnit.SECONDS.toMillis(3);\n+\n+  public static final String LOCK_HEARTBEAT_TIMEOUT_MS = \"lock.heartbeat-timeout-ms\";\n+  public static final long LOCK_HEARTBEAT_TIMEOUT_MS_DEFAULT = TimeUnit.SECONDS.toMillis(15);\n+\n+  public static final String LOCK_HEARTBEAT_THREADS = \"lock.heartbeat-threads\";\n+  public static final int LOCK_HEARTBEAT_THREADS_DEFAULT = 4;", "originalCommit": "4d9b78176102d7cfa1234b04af780725554a74f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDcwMDMwNA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550700304", "bodyText": "Because all heartbeats are executed by a shared ScheduledExecutorService. If there are multiple commits ongoing for multiple tables, it will need more than 1 thread.", "author": "jackye1995", "createdAt": "2020-12-31T22:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDczOA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694738", "bodyText": "Since this is getting large, we may want to separate it into the lock manager PR that Glue uses, and a new PR for the dynamo lock manager.", "author": "rdblue", "createdAt": "2020-12-31T21:38:30Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/GlueCatalogTest.java", "diffHunk": "@@ -70,7 +70,8 @@\n   public void before() {\n     glue = Mockito.mock(GlueClient.class);\n     glueCatalog = new GlueCatalog();\n-    glueCatalog.initialize(CATALOG_NAME, WAREHOUSE_PATH, new AwsProperties(), glue, null);\n+    glueCatalog.initialize(CATALOG_NAME, WAREHOUSE_PATH, new AwsProperties(), glue,\n+        LockManagers.defaultLockManager(), null);", "originalCommit": "4d9b78176102d7cfa1234b04af780725554a74f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDcwMDMyMQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550700321", "bodyText": "Sure, I can do that.", "author": "jackye1995", "createdAt": "2020-12-31T22:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDkxMw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550694913", "bodyText": "Could you rename this to InMemoryLockManager? I think we should make it clear that this is not suitable for real world use.", "author": "rdblue", "createdAt": "2020-12-31T21:39:56Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new DefaultLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class LockManagerBase implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {\n+          if (scheduler == null) {\n+            scheduler = Executors.newScheduledThreadPool(heartbeatThreads);\n+          }\n+        }\n+      }\n+      return scheduler;\n+    }\n+\n+    @Override\n+    public void initialize(Map<String, String> properties) {\n+      this.acquireTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS, CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS_DEFAULT);\n+      this.acquireIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS, CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS_DEFAULT);\n+      this.heartbeatIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS, CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS_DEFAULT);\n+      this.heartbeatTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS, CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS_DEFAULT);\n+      this.heartbeatThreads = PropertyUtil.propertyAsInt(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_THREADS, CatalogProperties.LOCK_HEARTBEAT_THREADS_DEFAULT);\n+    }\n+  }\n+\n+  /**\n+   * Default implementation of {@link LockManager} that uses an in-memory concurrent map for locking.\n+   * This implementation should only be used for testing,\n+   * or if the caller only needs locking within the same JVM during table commits.\n+   */\n+  static class DefaultLockManager extends LockManagerBase {", "originalCommit": "4d9b78176102d7cfa1234b04af780725554a74f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDcwMDMzNg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550700336", "bodyText": "Will do", "author": "jackye1995", "createdAt": "2020-12-31T22:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NDkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NTExMQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550695111", "bodyText": "This looks good to me.", "author": "rdblue", "createdAt": "2020-12-31T21:42:00Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new DefaultLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }", "originalCommit": "4d9b78176102d7cfa1234b04af780725554a74f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NzgwOQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550697809", "bodyText": "Can you also store the interval in the row? That way, the process that holds the lock shares its expectation with other processes. If you don't do that, then another process could use a wait interval shorter than the lock holder's heartbeat interval and incorrectly unlock. So the expected wait interval should come from the process that currently holds the lock, not the process attempting to get it.", "author": "rdblue", "createdAt": "2020-12-31T22:06:37Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/DynamoLockManager.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.aws.AwsClientFactories;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.Tasks;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeDefinition;\n+import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.services.dynamodb.model.BillingMode;\n+import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;\n+import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DeleteItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n+import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.GetItemResponse;\n+import software.amazon.awssdk.services.dynamodb.model.InternalServerErrorException;\n+import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n+import software.amazon.awssdk.services.dynamodb.model.KeyType;\n+import software.amazon.awssdk.services.dynamodb.model.ProvisionedThroughputExceededException;\n+import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n+import software.amazon.awssdk.services.dynamodb.model.RequestLimitExceededException;\n+import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n+import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n+import software.amazon.awssdk.services.dynamodb.model.TableStatus;\n+import software.amazon.awssdk.services.dynamodb.model.TransactionConflictException;\n+\n+/**\n+ * DynamoDB implementation for the lock manager.\n+ */\n+class DynamoLockManager extends LockManagers.LockManagerBase {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DynamoLockManager.class);\n+\n+  private static final String COL_LOCK_ENTITY_ID = \"entityId\";\n+  private static final String COL_LEASE_DURATION_MS = \"leaseDurationMs\";\n+  private static final String COL_VERSION = \"version\";\n+  private static final String COL_LOCK_OWNER_ID = \"ownerId\";\n+\n+  private static final String CONDITION_LOCK_ID_MATCH =\n+          COL_LOCK_ENTITY_ID + \"= :eid AND \" +\n+          COL_LOCK_OWNER_ID + \" = :oid\";\n+  private static final String CONDITION_LOCK_ENTITY_NOT_EXIST = \"attribute_not_exists(\" + COL_LOCK_ENTITY_ID + \")\";\n+  private static final String CONDITION_LOCK_ENTITY_NOT_EXIST_OR_VERSION_MATCH =\n+          \"attribute_not_exists(\" + COL_LOCK_ENTITY_ID + \") OR (\" +\n+          COL_LOCK_ENTITY_ID + \"= :eid AND \" +\n+          COL_VERSION + \"= :vid)\";\n+\n+  private static final int LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX = 5;\n+\n+  private static final List<KeySchemaElement> LOCK_TABLE_SCHEMA = Lists.newArrayList(\n+      KeySchemaElement.builder()\n+          .attributeName(COL_LOCK_ENTITY_ID)\n+          .keyType(KeyType.HASH)\n+          .build()\n+  );\n+\n+  private static final List<AttributeDefinition> LOCK_TABLE_COL_DEFINITIONS = Lists.newArrayList(\n+      AttributeDefinition.builder()\n+          .attributeName(COL_LOCK_ENTITY_ID)\n+          .attributeType(ScalarAttributeType.S)\n+          .build()\n+  );\n+\n+  private final Map<String, ScheduledFuture<?>> heartbeats = Maps.newHashMap();\n+\n+  private DynamoDbClient dynamo;\n+  private String lockTableName;\n+\n+  /**\n+   * constructor for dynamic initialization, {@link #initialize(Map)} must be called later.\n+   */\n+  DynamoLockManager() {\n+  }\n+\n+  /**\n+   * constructor used for testing purpose\n+   * @param dynamo dynamo client\n+   * @param lockTableName lock table name\n+   */\n+  DynamoLockManager(DynamoDbClient dynamo, String lockTableName) {\n+    super.initialize(Maps.newHashMap());\n+    this.dynamo = dynamo;\n+    this.lockTableName = lockTableName;\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  private void ensureLockTableExistsOrCreate() {\n+\n+    if (tableExists(lockTableName)) {\n+      return;\n+    }\n+\n+    LOG.info(\"Dynamo lock table {} not found, trying to create\", lockTableName);\n+    dynamo.createTable(CreateTableRequest.builder()\n+        .tableName(lockTableName)\n+        .keySchema(lockTableSchema())\n+        .attributeDefinitions(lockTableColDefinitions())\n+        .billingMode(BillingMode.PAY_PER_REQUEST)\n+        .build());\n+\n+    Tasks.foreach(lockTableName)\n+        .retry(LOCK_TABLE_CREATION_WAIT_ATTEMPTS_MAX)\n+        .throwFailureWhenFinished()\n+        .onlyRetryOn(IllegalStateException.class)\n+        .run(this::checkTableActive);\n+  }\n+\n+  @VisibleForTesting\n+  boolean tableExists(String tableName) {\n+    try {\n+      dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      return true;\n+    } catch (ResourceNotFoundException e) {\n+      return false;\n+    }\n+  }\n+\n+  private void checkTableActive(String tableName) {\n+    try {\n+      DescribeTableResponse response = dynamo.describeTable(DescribeTableRequest.builder()\n+          .tableName(tableName)\n+          .build());\n+      TableStatus currentStatus = response.table().tableStatus();\n+      if (!currentStatus.equals(TableStatus.ACTIVE)) {\n+        throw new IllegalStateException(String.format(\"Dynamo table %s is not active, current status: %s\",\n+            tableName, currentStatus));\n+      }\n+    } catch (ResourceNotFoundException e) {\n+      throw new IllegalStateException(String.format(\"Cannot find Dynamo table %s\", tableName));\n+    }\n+  }\n+\n+  @Override\n+  public void initialize(Map<String, String> properties) {\n+    super.initialize(properties);\n+    this.dynamo = AwsClientFactories.from(properties).dynamo();\n+    this.lockTableName = properties.get(CatalogProperties.LOCK_TABLE);\n+    Preconditions.checkNotNull(lockTableName, \"DynamoDB lock table name must not be null\");\n+    ensureLockTableExistsOrCreate();\n+  }\n+\n+  @Override\n+  public void acquire(LockId lockId) {\n+    try {\n+      Tasks.foreach(lockId)\n+          .throwFailureWhenFinished()\n+          .retry(Integer.MAX_VALUE - 1)\n+          .exponentialBackoff(acquireIntervalMs(), acquireIntervalMs(), acquireTimeoutMs(), 1)\n+          .onlyRetryOn(\n+              ConditionalCheckFailedException.class,\n+              ProvisionedThroughputExceededException.class,\n+              TransactionConflictException.class,\n+              RequestLimitExceededException.class,\n+              InternalServerErrorException.class)\n+          .run(this::acquireOnce);\n+    } catch (RuntimeException e) {\n+      throw new LockNotAcquiredException(\"Fail to acquire lock \" + lockId, e);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  void acquireOnce(LockId lockId) {\n+    GetItemResponse response = dynamo.getItem(GetItemRequest.builder()\n+        .tableName(lockTableName)\n+        .key(toKey(lockId))\n+        .build());\n+\n+    if (!response.hasItem()) {\n+      dynamo.putItem(PutItemRequest.builder()\n+          .tableName(lockTableName)\n+          .item(toNewItem(lockId))\n+          .conditionExpression(CONDITION_LOCK_ENTITY_NOT_EXIST)\n+          .build());\n+    } else {\n+      Map<String, AttributeValue> currentItem = response.item();\n+\n+      try {\n+        Thread.sleep(Long.parseLong(currentItem.get(COL_LEASE_DURATION_MS).n()));\n+      } catch (InterruptedException e) {\n+        throw new LockNotAcquiredException(\n+                String.format(\"Fail to acquire lock %s, interrupted during sleep\", lockId), e);\n+      }\n+\n+      Map<String, AttributeValue> expressionValues = Maps.newHashMap();\n+      expressionValues.put(\":eid\", AttributeValue.builder().s(lockId.entityId()).build());\n+      expressionValues.put(\":vid\", AttributeValue.builder().s(currentItem.get(COL_VERSION).s()).build());", "originalCommit": "4d9b78176102d7cfa1234b04af780725554a74f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDcwMTI3Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r550701272", "bodyText": "I don't think the situation you describe would happen. The heartbeat timeout duration is already stored (L270), and the lock acquisition process would wait for the stored heartbeat timeout duration before trying to acquire (L211).\nThis means the total acquisition time might exceed lock.acquire-timeout-ms, because it will first wait for the heartbeat timeout duration and then check if acquisition time has timed out or not. And the lock.acquire-interval-ms can be very very short, and this lock mechanism would still work.\nMaybe you are looking at the wrong line. The expressionValues here are only used to check against CONDITION_LOCK_ENTITY_NOT_EXIST_OR_VERSION_MATCH, the actual data stored is at toNewItem at L270.", "author": "jackye1995", "createdAt": "2020-12-31T22:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDY5NzgwOQ=="}], "type": "inlineReview"}, {"oid": "02bf864b8e692b52cd0a9136e11baed9c4d5f64e", "url": "https://github.com/apache/iceberg/commit/02bf864b8e692b52cd0a9136e11baed9c4d5f64e", "message": "AWS: Glue catalog lock interface", "committedDate": "2021-01-04T18:58:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2NzA1Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r551667052", "bodyText": "Why not return false?", "author": "rdblue", "createdAt": "2021-01-05T01:35:30Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+\n+/**\n+ * An interface for locking, used to ensure Glue catalog commit isolation.\n+ */\n+interface LockManager extends AutoCloseable {\n+\n+  /**\n+   * Try to acquire a lock\n+   * @param entityId ID of the entity to lock\n+   * @param ownerId ID of the owner if the lock\n+   * @throws LockNotAcquiredException if lock is not acquired", "originalCommit": "fc214dd839b383ac592160663fbd46cabefa0c4d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY3MTc3OA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r551671778", "bodyText": "Throwing exception makes it easier to use with Tasks if the caller wants to retry.", "author": "jackye1995", "createdAt": "2021-01-05T01:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2NzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY4ODgxNQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r551688815", "bodyText": "Can't that be an internal exception if this returns false? You could still use the exception for Tasks, but then wouldn't need to expose it to users.", "author": "rdblue", "createdAt": "2021-01-05T02:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2NzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTczOTY3MA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r551739670", "bodyText": "Sure, updated to return false", "author": "jackye1995", "createdAt": "2021-01-05T06:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2NzA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2ODEwMQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r551668101", "bodyText": "Nit: in similar cases we use Base first, like BaseLockManager.", "author": "rdblue", "createdAt": "2021-01-05T01:38:38Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class LockManagerBase implements LockManager {", "originalCommit": "fc214dd839b383ac592160663fbd46cabefa0c4d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTczOTY5OQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r551739699", "bodyText": "Fixed", "author": "jackye1995", "createdAt": "2021-01-05T06:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2ODEwMQ=="}], "type": "inlineReview"}, {"oid": "2270cec79b3c085654468a8ad9282dcb0437c6b7", "url": "https://github.com/apache/iceberg/commit/2270cec79b3c085654468a8ad9282dcb0437c6b7", "message": "AWS: Glue catalog lock interface", "committedDate": "2021-01-05T06:20:50Z", "type": "commit"}, {"oid": "2270cec79b3c085654468a8ad9282dcb0437c6b7", "url": "https://github.com/apache/iceberg/commit/2270cec79b3c085654468a8ad9282dcb0437c6b7", "message": "AWS: Glue catalog lock interface", "committedDate": "2021-01-05T06:20:50Z", "type": "forcePushed"}, {"oid": "2c2822cf375b9d3473fb650d23c78106a2f10635", "url": "https://github.com/apache/iceberg/commit/2c2822cf375b9d3473fb650d23c78106a2f10635", "message": "update name BaseLockManager", "committedDate": "2021-01-05T06:26:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NzU0Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552087542", "bodyText": "I think this also needs to shut down the heartbeat thread pool. That should probably be done in the base class, so probably just call super.close() here and add the shutdown there.", "author": "rdblue", "createdAt": "2021-01-05T17:39:51Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class BaseLockManager implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {\n+          if (scheduler == null) {\n+            scheduler = Executors.newScheduledThreadPool(heartbeatThreads);\n+          }\n+        }\n+      }\n+      return scheduler;\n+    }\n+\n+    @Override\n+    public void initialize(Map<String, String> properties) {\n+      this.acquireTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS, CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS_DEFAULT);\n+      this.acquireIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS, CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS_DEFAULT);\n+      this.heartbeatIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS, CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS_DEFAULT);\n+      this.heartbeatTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS, CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS_DEFAULT);\n+      this.heartbeatThreads = PropertyUtil.propertyAsInt(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_THREADS, CatalogProperties.LOCK_HEARTBEAT_THREADS_DEFAULT);\n+    }\n+  }\n+\n+  /**\n+   * Implementation of {@link LockManager} that uses an in-memory concurrent map for locking.\n+   * This implementation should only be used for testing,\n+   * or if the caller only needs locking within the same JVM during table commits.\n+   */\n+  static class InMemoryLockManager extends BaseLockManager {\n+\n+    private static final Map<String, DefaultLockContent> LOCKS = Maps.newConcurrentMap();\n+    private static final Map<String, ScheduledFuture<?>> HEARTBEATS = Maps.newHashMap();\n+\n+    InMemoryLockManager(Map<String, String> properties) {\n+      initialize(properties);\n+    }\n+\n+    @VisibleForTesting\n+    void acquireOnce(String entityId, String ownerId) {\n+      DefaultLockContent content = LOCKS.get(entityId);\n+      if (content != null && content.expireMs() > System.currentTimeMillis()) {\n+        throw new IllegalStateException(String.format(\"Lock for %s currently held by %s, expiration: %s\",\n+            entityId, content.ownerId(), content.expireMs()));\n+      }\n+\n+      long expiration = System.currentTimeMillis() + heartbeatTimeoutMs();\n+      boolean succeed;\n+      if (content == null) {\n+        DefaultLockContent previous = LOCKS.putIfAbsent(\n+            entityId, new DefaultLockContent(ownerId, expiration));\n+        succeed = previous == null;\n+      } else {\n+        succeed = LOCKS.replace(entityId, content, new DefaultLockContent(ownerId, expiration));\n+      }\n+\n+      if (succeed) {\n+        // cleanup old heartbeat\n+        if (HEARTBEATS.containsKey(entityId)) {\n+          HEARTBEATS.remove(entityId).cancel(false);\n+        }\n+\n+        HEARTBEATS.put(entityId, scheduler().scheduleAtFixedRate(() -> {\n+          DefaultLockContent lastContent = LOCKS.get(entityId);\n+          try {\n+            long newExpiration = System.currentTimeMillis() + heartbeatTimeoutMs();\n+            LOCKS.replace(entityId, lastContent, new DefaultLockContent(ownerId, newExpiration));\n+          } catch (NullPointerException e) {\n+            throw new RuntimeException(\"Cannot heartbeat to a deleted lock \" + entityId, e);\n+          }\n+\n+        }, 0, heartbeatIntervalMs(), TimeUnit.MILLISECONDS));\n+\n+      } else {\n+        throw new IllegalStateException(\"Unable to acquire lock \" + entityId);\n+      }\n+    }\n+\n+    @Override\n+    public boolean acquire(String entityId, String ownerId) {\n+      try {\n+        Tasks.foreach(entityId)\n+            .retry(Integer.MAX_VALUE - 1)\n+            .onlyRetryOn(IllegalStateException.class)\n+            .throwFailureWhenFinished()\n+            .exponentialBackoff(acquireIntervalMs(), acquireIntervalMs(), acquireTimeoutMs(), 1)\n+            .run(id -> acquireOnce(id, ownerId));\n+        return true;\n+      } catch (IllegalStateException e) {\n+        return false;\n+      }\n+    }\n+\n+    @Override\n+    public void release(String entityId, String ownerId) {\n+      DefaultLockContent currentContent = LOCKS.get(entityId);\n+      if (currentContent == null) {\n+        throw new IllegalArgumentException(\"Cannot find lock for entity \" + entityId);\n+      }\n+\n+      if (!currentContent.ownerId().equals(ownerId)) {\n+        throw new IllegalArgumentException(String.format(\n+            \"Cannot unlock %s by %s, current owner: %s\", entityId, ownerId, currentContent.ownerId()));\n+      }\n+      HEARTBEATS.remove(entityId).cancel(false);\n+      LOCKS.remove(entityId);\n+    }\n+\n+    @Override\n+    public void close() {", "originalCommit": "2c2822cf375b9d3473fb650d23c78106a2f10635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5MzQ4NA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552093484", "bodyText": "I did not close the thread pool because it is a shared pool. Instead I just cancel all ongoing scheduled futures. Closing the thread pool would result in failure of other lock managers if there are multiple managers.\nThis is the same pattern we use for S3OutputStream with a shared pool. The close() method does not shutdown the execution service.\nI think what I can do is to use MoreExecutors.getExitingScheduledExecutorService, so that a shutdown hook is added for it.", "author": "jackye1995", "createdAt": "2021-01-05T17:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NzU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMzU5NA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552103594", "bodyText": "Oh, I see. Thanks, I missed that because scheduler() is not a static method.", "author": "rdblue", "createdAt": "2021-01-05T18:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NzU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5Mjg3Ng==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552092876", "bodyText": "Because this locks in the try block, the finally will be called when the lock fails. I think that's correct for cleaning up the metadata location, but the lock release will currently fail because the lock isn't held by this thread. That will cause the lock failure exception to get replaced by the unlock failure.\nI think the solution is to not throw exceptions in release. I'll comment on that below.", "author": "rdblue", "createdAt": "2021-01-05T17:49:19Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -100,10 +104,11 @@ protected void doRefresh() {\n   protected void doCommit(TableMetadata base, TableMetadata metadata) {\n     String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n     boolean exceptionThrown = true;\n-    Table glueTable = getGlueTable();\n-    checkMetadataLocation(glueTable, base);\n-    Map<String, String> properties = prepareProperties(glueTable, newMetadataLocation);\n     try {\n+      lock(newMetadataLocation);", "originalCommit": "2c2822cf375b9d3473fb650d23c78106a2f10635", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e46fba906da05f1efd990e3301e36089b336fef3", "url": "https://github.com/apache/iceberg/commit/e46fba906da05f1efd990e3301e36089b336fef3", "message": "use ExitingScheduledExecutorService", "committedDate": "2021-01-05T17:58:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMDQyNw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552100427", "bodyText": "IllegalArgumentException isn't quite right. The argument is correct, it is the lock state that is the problem. IllegalStateException is a better one to throw for this and the next case.\nWe also need to consider what this exception would cause if thrown. The release method is currently called in a finally block so if it throws an exception, it will replace the real failure. I noted that above where if the lock can't be acquired, either this or the next check's exception will be thrown.\nIn addition to that problem, a failure here could cause duplicate data. If the table state is updated, then success must be reported back. If not, then it is very likely that the operation will retry at some level and there is no guarantee that the operation is idempotent. For example, a writer moving data from Kafka to an Iceberg table will append data. If a checkpoint commit fails, it will retry. If the failure happened after the commit actually succeeded, then the append will be done twice causing duplicate data in the table.\nMost of the time, a failure like that would cause the metadata file that was to be committed to be deleted, which ends up locking up the table. But this unlock happens after the delete would happen, so the table would appear correct but the operation would probably retry.\nI think the solution to these problems is to make this log the error and return a boolean. If the lock was held and released, return true. If it was not held, then return false. That way the caller can decide how to handle it. And we should log the error messages you have here for context.", "author": "rdblue", "createdAt": "2021-01-05T18:02:37Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class BaseLockManager implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {\n+          if (scheduler == null) {\n+            scheduler = Executors.newScheduledThreadPool(heartbeatThreads);\n+          }\n+        }\n+      }\n+      return scheduler;\n+    }\n+\n+    @Override\n+    public void initialize(Map<String, String> properties) {\n+      this.acquireTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS, CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS_DEFAULT);\n+      this.acquireIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS, CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS_DEFAULT);\n+      this.heartbeatIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS, CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS_DEFAULT);\n+      this.heartbeatTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS, CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS_DEFAULT);\n+      this.heartbeatThreads = PropertyUtil.propertyAsInt(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_THREADS, CatalogProperties.LOCK_HEARTBEAT_THREADS_DEFAULT);\n+    }\n+  }\n+\n+  /**\n+   * Implementation of {@link LockManager} that uses an in-memory concurrent map for locking.\n+   * This implementation should only be used for testing,\n+   * or if the caller only needs locking within the same JVM during table commits.\n+   */\n+  static class InMemoryLockManager extends BaseLockManager {\n+\n+    private static final Map<String, DefaultLockContent> LOCKS = Maps.newConcurrentMap();\n+    private static final Map<String, ScheduledFuture<?>> HEARTBEATS = Maps.newHashMap();\n+\n+    InMemoryLockManager(Map<String, String> properties) {\n+      initialize(properties);\n+    }\n+\n+    @VisibleForTesting\n+    void acquireOnce(String entityId, String ownerId) {\n+      DefaultLockContent content = LOCKS.get(entityId);\n+      if (content != null && content.expireMs() > System.currentTimeMillis()) {\n+        throw new IllegalStateException(String.format(\"Lock for %s currently held by %s, expiration: %s\",\n+            entityId, content.ownerId(), content.expireMs()));\n+      }\n+\n+      long expiration = System.currentTimeMillis() + heartbeatTimeoutMs();\n+      boolean succeed;\n+      if (content == null) {\n+        DefaultLockContent previous = LOCKS.putIfAbsent(\n+            entityId, new DefaultLockContent(ownerId, expiration));\n+        succeed = previous == null;\n+      } else {\n+        succeed = LOCKS.replace(entityId, content, new DefaultLockContent(ownerId, expiration));\n+      }\n+\n+      if (succeed) {\n+        // cleanup old heartbeat\n+        if (HEARTBEATS.containsKey(entityId)) {\n+          HEARTBEATS.remove(entityId).cancel(false);\n+        }\n+\n+        HEARTBEATS.put(entityId, scheduler().scheduleAtFixedRate(() -> {\n+          DefaultLockContent lastContent = LOCKS.get(entityId);\n+          try {\n+            long newExpiration = System.currentTimeMillis() + heartbeatTimeoutMs();\n+            LOCKS.replace(entityId, lastContent, new DefaultLockContent(ownerId, newExpiration));\n+          } catch (NullPointerException e) {\n+            throw new RuntimeException(\"Cannot heartbeat to a deleted lock \" + entityId, e);\n+          }\n+\n+        }, 0, heartbeatIntervalMs(), TimeUnit.MILLISECONDS));\n+\n+      } else {\n+        throw new IllegalStateException(\"Unable to acquire lock \" + entityId);\n+      }\n+    }\n+\n+    @Override\n+    public boolean acquire(String entityId, String ownerId) {\n+      try {\n+        Tasks.foreach(entityId)\n+            .retry(Integer.MAX_VALUE - 1)\n+            .onlyRetryOn(IllegalStateException.class)\n+            .throwFailureWhenFinished()\n+            .exponentialBackoff(acquireIntervalMs(), acquireIntervalMs(), acquireTimeoutMs(), 1)\n+            .run(id -> acquireOnce(id, ownerId));\n+        return true;\n+      } catch (IllegalStateException e) {\n+        return false;\n+      }\n+    }\n+\n+    @Override\n+    public void release(String entityId, String ownerId) {\n+      DefaultLockContent currentContent = LOCKS.get(entityId);\n+      if (currentContent == null) {\n+        throw new IllegalArgumentException(\"Cannot find lock for entity \" + entityId);", "originalCommit": "2c2822cf375b9d3473fb650d23c78106a2f10635", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMTI4Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552101282", "bodyText": "I'm fine with including this in the implementation, but it doesn't seem to me that there are that many cases where an internal heartbeat helps. If the thread that owns the lock fails, the heartbeat thread will continue to live. So the heartbeat is really a process heartbeat. And because the locks are all process-local anyway there isn't much value.", "author": "rdblue", "createdAt": "2021-01-05T18:04:19Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class BaseLockManager implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {\n+          if (scheduler == null) {\n+            scheduler = Executors.newScheduledThreadPool(heartbeatThreads);\n+          }\n+        }\n+      }\n+      return scheduler;\n+    }\n+\n+    @Override\n+    public void initialize(Map<String, String> properties) {\n+      this.acquireTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS, CatalogProperties.LOCK_ACQUIRE_TIMEOUT_MS_DEFAULT);\n+      this.acquireIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS, CatalogProperties.LOCK_ACQUIRE_INTERVAL_MS_DEFAULT);\n+      this.heartbeatIntervalMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS, CatalogProperties.LOCK_HEARTBEAT_INTERVAL_MS_DEFAULT);\n+      this.heartbeatTimeoutMs = PropertyUtil.propertyAsLong(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS, CatalogProperties.LOCK_HEARTBEAT_TIMEOUT_MS_DEFAULT);\n+      this.heartbeatThreads = PropertyUtil.propertyAsInt(properties,\n+          CatalogProperties.LOCK_HEARTBEAT_THREADS, CatalogProperties.LOCK_HEARTBEAT_THREADS_DEFAULT);\n+    }\n+  }\n+\n+  /**\n+   * Implementation of {@link LockManager} that uses an in-memory concurrent map for locking.\n+   * This implementation should only be used for testing,\n+   * or if the caller only needs locking within the same JVM during table commits.\n+   */\n+  static class InMemoryLockManager extends BaseLockManager {\n+\n+    private static final Map<String, DefaultLockContent> LOCKS = Maps.newConcurrentMap();\n+    private static final Map<String, ScheduledFuture<?>> HEARTBEATS = Maps.newHashMap();", "originalCommit": "2c2822cf375b9d3473fb650d23c78106a2f10635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzMzE1Mg==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552133152", "bodyText": "Yes this is more for illustration purpose.", "author": "jackye1995", "createdAt": "2021-01-05T19:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMTI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMjgyNA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552102824", "bodyText": "I noted this below, but I think this pool needs to be shut down.\nWe also need to ensure that the threads are named and are daemon threads. That ensures that the JVM can exit even if this isn't shut down cleanly and naming helps when trying to debug what is happening in a process. To do that you just need to pass a thread factory, which you can create like this:\nimport org.apache.iceberg.relocated.com.google.common.util.concurrent.ThreadFactoryBuilder;\n...\n          new ThreadFactoryBuilder()\n              .setDaemon(true)\n              .setNameFormat(String.format(\"%s-heartbeat-pool-%d\"), this)\n              .build()", "author": "rdblue", "createdAt": "2021-01-05T18:07:10Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class BaseLockManager implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {\n+          if (scheduler == null) {\n+            scheduler = Executors.newScheduledThreadPool(heartbeatThreads);", "originalCommit": "2c2822cf375b9d3473fb650d23c78106a2f10635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNDgyOQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552104829", "bodyText": "Nevermind, it looks like you fixed this as I was commenting.", "author": "rdblue", "createdAt": "2021-01-05T18:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMjgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjExNjk5MQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552116991", "bodyText": "Yes I just updated with exactly this", "author": "jackye1995", "createdAt": "2021-01-05T18:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMjgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNDA2OQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552104069", "bodyText": "Because this isn't a static method, this is the instance of the lock manager, so it doesn't really protect creation of the thread pool. I think you'd need to lock on BaseLockManager.class or some other static shared object.", "author": "rdblue", "createdAt": "2021-01-05T18:09:25Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManagers.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.common.DynConstructors;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.MoreExecutors;\n+import org.apache.iceberg.relocated.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import org.apache.iceberg.util.PropertyUtil;\n+import org.apache.iceberg.util.Tasks;\n+\n+class LockManagers {\n+\n+  private static final LockManager LOCK_MANAGER_DEFAULT = new InMemoryLockManager(Maps.newHashMap());\n+\n+  private LockManagers() {\n+  }\n+\n+  public static LockManager defaultLockManager() {\n+    return LOCK_MANAGER_DEFAULT;\n+  }\n+\n+  public static LockManager from(Map<String, String> properties) {\n+    if (properties.containsKey(CatalogProperties.LOCK_IMPL)) {\n+      return loadLockManager(properties.get(CatalogProperties.LOCK_IMPL), properties);\n+    } else {\n+      return defaultLockManager();\n+    }\n+  }\n+\n+  private static LockManager loadLockManager(String impl, Map<String, String> properties) {\n+    DynConstructors.Ctor<LockManager> ctor;\n+    try {\n+      ctor = DynConstructors.builder(LockManager.class).hiddenImpl(impl).buildChecked();\n+    } catch (NoSuchMethodException e) {\n+      throw new IllegalArgumentException(String.format(\n+          \"Cannot initialize LockManager, missing no-arg constructor: %s\", impl), e);\n+    }\n+\n+    LockManager lockManager;\n+    try {\n+      lockManager = ctor.newInstance();\n+    } catch (ClassCastException e) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Cannot initialize LockManager, %s does not implement LockManager.\", impl), e);\n+    }\n+\n+    lockManager.initialize(properties);\n+    return lockManager;\n+  }\n+\n+  abstract static class BaseLockManager implements LockManager {\n+\n+    private static volatile ScheduledExecutorService scheduler;\n+\n+    private long acquireTimeoutMs;\n+    private long acquireIntervalMs;\n+    private long heartbeatIntervalMs;\n+    private long heartbeatTimeoutMs;\n+    private int heartbeatThreads;\n+\n+    public long heartbeatTimeoutMs() {\n+      return heartbeatTimeoutMs;\n+    }\n+\n+    public long heartbeatIntervalMs() {\n+      return heartbeatIntervalMs;\n+    }\n+\n+    public long acquireIntervalMs() {\n+      return acquireIntervalMs;\n+    }\n+\n+    public long acquireTimeoutMs() {\n+      return acquireTimeoutMs;\n+    }\n+\n+    public int heartbeatThreads() {\n+      return heartbeatThreads;\n+    }\n+\n+    @SuppressWarnings(\"StaticGuardedByInstance\")\n+    public ScheduledExecutorService scheduler() {\n+      if (scheduler == null) {\n+        synchronized (this) {", "originalCommit": "e46fba906da05f1efd990e3301e36089b336fef3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1Njk1Mw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552156953", "bodyText": "Fixed", "author": "jackye1995", "createdAt": "2021-01-05T19:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNDA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNTk0OQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552105949", "bodyText": "If this is going to call private methods in lock manager, then I think it would be good to validate that the entity is actually locked. This test would pass with an empty implementation of acquireOnce.", "author": "rdblue", "createdAt": "2021-01-05T18:12:58Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/InMemoryLockManagerTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class InMemoryLockManagerTest {\n+\n+  private LockManagers.InMemoryLockManager lockManager;\n+  private String lockEntityId;\n+  private String ownerId;\n+\n+  @Before\n+  public void before() {\n+    lockEntityId = UUID.randomUUID().toString();\n+    ownerId = UUID.randomUUID().toString();\n+    lockManager = new LockManagers.InMemoryLockManager(Maps.newHashMap());\n+  }\n+\n+  @After\n+  public void after() {\n+    lockManager.close();\n+  }\n+\n+  @Test\n+  public void testAcquireOnce_singleProcess() {\n+    lockManager.acquireOnce(lockEntityId, ownerId);", "originalCommit": "e46fba906da05f1efd990e3301e36089b336fef3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNjQ0MQ==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552106441", "bodyText": "This test would also pass with an empty implementation.", "author": "rdblue", "createdAt": "2021-01-05T18:13:50Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/InMemoryLockManagerTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class InMemoryLockManagerTest {\n+\n+  private LockManagers.InMemoryLockManager lockManager;\n+  private String lockEntityId;\n+  private String ownerId;\n+\n+  @Before\n+  public void before() {\n+    lockEntityId = UUID.randomUUID().toString();\n+    ownerId = UUID.randomUUID().toString();\n+    lockManager = new LockManagers.InMemoryLockManager(Maps.newHashMap());\n+  }\n+\n+  @After\n+  public void after() {\n+    lockManager.close();\n+  }\n+\n+  @Test\n+  public void testAcquireOnce_singleProcess() {\n+    lockManager.acquireOnce(lockEntityId, ownerId);\n+  }\n+\n+  @Test\n+  public void testAcquireOnce_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 10).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            lockManager.acquireOnce(lockEntityId, ownerId);\n+            return true;\n+          } catch (IllegalStateException e) {\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(\n+        \"only 1 thread should have acquired the lock\",\n+        1, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testReleaseAndAcquire() {\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+    lockManager.release(lockEntityId, ownerId);\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));", "originalCommit": "e46fba906da05f1efd990e3301e36089b336fef3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNzAzMw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552107033", "bodyText": "How long does this take to run? It seems like a good idea to use some settings to avoid long runtimes. What about setting the timeout to 1s or something?", "author": "rdblue", "createdAt": "2021-01-05T18:14:52Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/InMemoryLockManagerTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class InMemoryLockManagerTest {\n+\n+  private LockManagers.InMemoryLockManager lockManager;\n+  private String lockEntityId;\n+  private String ownerId;\n+\n+  @Before\n+  public void before() {\n+    lockEntityId = UUID.randomUUID().toString();\n+    ownerId = UUID.randomUUID().toString();\n+    lockManager = new LockManagers.InMemoryLockManager(Maps.newHashMap());", "originalCommit": "e46fba906da05f1efd990e3301e36089b336fef3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1NTYwNA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552155604", "bodyText": "Added a timeout rule", "author": "jackye1995", "createdAt": "2021-01-05T19:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNzAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5MzAwNA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552193004", "bodyText": "Sorry, I meant configuring the lock manager timeouts to small increments, not adding a Timeout. Since you adjust settings in individual tests, it should be fine.", "author": "rdblue", "createdAt": "2021-01-05T21:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNzAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwODA1Mw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552108053", "bodyText": "Can you make this interval shorter? 5s is a long time to wait. 200ms would do fine.", "author": "rdblue", "createdAt": "2021-01-05T18:15:55Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/InMemoryLockManagerTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class InMemoryLockManagerTest {\n+\n+  private LockManagers.InMemoryLockManager lockManager;\n+  private String lockEntityId;\n+  private String ownerId;\n+\n+  @Before\n+  public void before() {\n+    lockEntityId = UUID.randomUUID().toString();\n+    ownerId = UUID.randomUUID().toString();\n+    lockManager = new LockManagers.InMemoryLockManager(Maps.newHashMap());\n+  }\n+\n+  @After\n+  public void after() {\n+    lockManager.close();\n+  }\n+\n+  @Test\n+  public void testAcquireOnce_singleProcess() {\n+    lockManager.acquireOnce(lockEntityId, ownerId);\n+  }\n+\n+  @Test\n+  public void testAcquireOnce_multiProcess() {\n+    List<Boolean> results = IntStream.range(0, 10).parallel()\n+        .mapToObj(i -> {\n+          try {\n+            lockManager.acquireOnce(lockEntityId, ownerId);\n+            return true;\n+          } catch (IllegalStateException e) {\n+            return false;\n+          }\n+        })\n+        .collect(Collectors.toList());\n+    Assert.assertEquals(\n+        \"only 1 thread should have acquired the lock\",\n+        1, results.stream().filter(s -> s).count());\n+  }\n+\n+  @Test\n+  public void testReleaseAndAcquire() {\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+    lockManager.release(lockEntityId, ownerId);\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+  }\n+\n+  @Test\n+  public void testReleaseWithWrongOwner() {\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+    AssertHelpers.assertThrows(\"should throw exception if ownerId is wrong\",\n+        IllegalArgumentException.class,\n+        \"current owner\",\n+        () -> lockManager.release(lockEntityId, UUID.randomUUID().toString()));\n+  }\n+\n+  @Test\n+  public void testAcquire_singleProcess() throws Exception {\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+    String oldOwner = ownerId;\n+\n+    CompletableFuture.supplyAsync(() -> {\n+      try {\n+        Thread.sleep(5000);\n+      } catch (InterruptedException e) {\n+        throw new RuntimeException(e);\n+      }\n+      lockManager.release(lockEntityId, oldOwner);\n+      return null;\n+    });\n+\n+    ownerId = UUID.randomUUID().toString();\n+    long start = System.currentTimeMillis();\n+    Assert.assertTrue(lockManager.acquire(lockEntityId, ownerId));\n+    Assert.assertTrue(\"should succeed after 5 seconds\",\n+        System.currentTimeMillis() - start >= 5000);", "originalCommit": "e46fba906da05f1efd990e3301e36089b336fef3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1NTY3Mw==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552155673", "bodyText": "Updated", "author": "jackye1995", "createdAt": "2021-01-05T19:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwODA1Mw=="}], "type": "inlineReview"}, {"oid": "4b953d3be031948520700b86b98e63f6b5674a49", "url": "https://github.com/apache/iceberg/commit/4b953d3be031948520700b86b98e63f6b5674a49", "message": "update tests", "committedDate": "2021-01-05T19:49:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5MTU0OA==", "url": "https://github.com/apache/iceberg/pull/1823#discussion_r552191548", "bodyText": "This isn't quite correct. It should return true if the lock was held and released, and false otherwise. This should also note that the contract requires not throwing exceptions from this method.", "author": "rdblue", "createdAt": "2021-01-05T21:00:39Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/LockManager.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+\n+/**\n+ * An interface for locking, used to ensure Glue catalog commit isolation.\n+ */\n+interface LockManager extends AutoCloseable {\n+\n+  /**\n+   * Try to acquire a lock\n+   * @param entityId ID of the entity to lock\n+   * @param ownerId ID of the owner if the lock\n+   * @return if the lock for the entity is acquired by the owner\n+   */\n+  boolean acquire(String entityId, String ownerId);\n+\n+  /**\n+   * Release a lock\n+   * @param entityId ID of the entity to lock\n+   * @param ownerId ID of the owner if the lock\n+   * @return if the lock for the entity of the owner is released", "originalCommit": "4b953d3be031948520700b86b98e63f6b5674a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}