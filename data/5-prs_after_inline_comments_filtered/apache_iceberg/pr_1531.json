{"pr_number": 1531, "pr_title": "Allow impl for LocationProvider for to be created during runtime", "pr_createdAt": "2020-09-30T04:59:17Z", "pr_url": "https://github.com/apache/iceberg/pull/1531", "timeline": [{"oid": "db7f3e50b317ed7318cf6e541a32f3339b20e250", "url": "https://github.com/apache/iceberg/commit/db7f3e50b317ed7318cf6e541a32f3339b20e250", "message": "new table properties", "committedDate": "2020-09-29T20:08:21Z", "type": "commit"}, {"oid": "4074a9489b5881c03557b570b592f2a6c15a9a39", "url": "https://github.com/apache/iceberg/commit/4074a9489b5881c03557b570b592f2a6c15a9a39", "message": "expose helper method to get class from partition field", "committedDate": "2020-09-29T20:08:21Z", "type": "commit"}, {"oid": "9412875711965cae28566482765e6b4ec8a9cbf0", "url": "https://github.com/apache/iceberg/commit/9412875711965cae28566482765e6b4ec8a9cbf0", "message": "localized location provider", "committedDate": "2020-09-29T20:08:21Z", "type": "commit"}, {"oid": "ad8b9c196263b1e87f21c067c368c0fec07d906f", "url": "https://github.com/apache/iceberg/commit/ad8b9c196263b1e87f21c067c368c0fec07d906f", "message": "test dataframe writes", "committedDate": "2020-09-30T04:58:49Z", "type": "commit"}, {"oid": "9b5f96f08e89d2a04eed09106a7fb1cae125c130", "url": "https://github.com/apache/iceberg/commit/9b5f96f08e89d2a04eed09106a7fb1cae125c130", "message": "formatting", "committedDate": "2020-09-30T05:25:23Z", "type": "commit"}, {"oid": "51ced5f39aecaf007ada49d6a6dceb3c0495875a", "url": "https://github.com/apache/iceberg/commit/51ced5f39aecaf007ada49d6a6dceb3c0495875a", "message": "format tests", "committedDate": "2020-09-30T05:49:34Z", "type": "commit"}, {"oid": "c0abcf635fecb77d1d973ea1a37f35d008a38fcd", "url": "https://github.com/apache/iceberg/commit/c0abcf635fecb77d1d973ea1a37f35d008a38fcd", "message": "dynamically load location provider", "committedDate": "2020-10-01T04:54:13Z", "type": "commit"}, {"oid": "bd2d8af93bee5a534e37fcf32e85ea430410393e", "url": "https://github.com/apache/iceberg/commit/bd2d8af93bee5a534e37fcf32e85ea430410393e", "message": "revert refactoring", "committedDate": "2020-10-01T04:58:15Z", "type": "commit"}, {"oid": "a5eff74e37e4ba142f0f16058117266d8e154969", "url": "https://github.com/apache/iceberg/commit/a5eff74e37e4ba142f0f16058117266d8e154969", "message": "remove extra line", "committedDate": "2020-10-01T04:58:56Z", "type": "commit"}, {"oid": "706cfcbd00bdbe17101e8329be2d4e308552a6ac", "url": "https://github.com/apache/iceberg/commit/706cfcbd00bdbe17101e8329be2d4e308552a6ac", "message": "rename test", "committedDate": "2020-10-01T05:05:22Z", "type": "commit"}, {"oid": "2c51cd7c679ca0bfb3a965ae562b99a57ea51e73", "url": "https://github.com/apache/iceberg/commit/2c51cd7c679ca0bfb3a965ae562b99a57ea51e73", "message": "address feedback: test location provider", "committedDate": "2020-10-03T03:57:58Z", "type": "commit"}, {"oid": "34192da3d1cdad443e542f5711461097cd7abbc1", "url": "https://github.com/apache/iceberg/commit/34192da3d1cdad443e542f5711461097cd7abbc1", "message": "revert old test", "committedDate": "2020-10-03T04:01:38Z", "type": "commit"}, {"oid": "77210d38ea59fb1c6eda0ab9e5e530a8e6e0dd9e", "url": "https://github.com/apache/iceberg/commit/77210d38ea59fb1c6eda0ab9e5e530a8e6e0dd9e", "message": "improve error message", "committedDate": "2020-10-03T04:22:03Z", "type": "commit"}, {"oid": "73fe85d87feda48cdee01d76e572ac1f2bcb8233", "url": "https://github.com/apache/iceberg/commit/73fe85d87feda48cdee01d76e572ac1f2bcb8233", "message": "format test", "committedDate": "2020-10-03T04:25:09Z", "type": "commit"}, {"oid": "9b22a8c19d570dd7c6e7671b31dc704cf122b85c", "url": "https://github.com/apache/iceberg/commit/9b22a8c19d570dd7c6e7671b31dc704cf122b85c", "message": "propagate exception", "committedDate": "2020-10-03T04:30:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0OTM2Mw==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499749363", "bodyText": "Instead of exception rules, we like to use AssertHelpers.assertThrows. That way, the test doesn't need to end when the exception is thrown and you can run other validations.\nAlso, we don't typically use the prefix this. unless setting an instance field, unless it helps understanding what's going on. We always using when assigning, though.", "author": "rdblue", "createdAt": "2020-10-05T17:11:43Z", "path": "core/src/test/java/org/apache/iceberg/TestLocationProvider.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.util.Map;\n+import org.apache.iceberg.io.LocationProvider;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public class TestLocationProvider extends TableTestBase {\n+  @Parameterized.Parameters\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+        new Object[] { 1 },\n+        new Object[] { 2 },\n+    };\n+  }\n+\n+  public TestLocationProvider(int formatVersion) {\n+    super(formatVersion);\n+  }\n+\n+  @Rule\n+  public ExpectedException exceptionRule = ExpectedException.none();\n+\n+  // publicly visible for testing to be dynamically loaded\n+  public static class DynamicallyLoadedLocationProvider implements LocationProvider {\n+    String tableLocation;\n+    Map<String, String> properties;\n+\n+    public DynamicallyLoadedLocationProvider(String tableLocation, Map<String, String> properties) {\n+      this.tableLocation = tableLocation;\n+      this.properties = properties;\n+    }\n+\n+    @Override\n+    public String newDataLocation(String filename) {\n+      return String.format(\"%s/test_custom_provider/%s\", this.tableLocation, filename);\n+    }\n+\n+    @Override\n+    public String newDataLocation(PartitionSpec spec, StructLike partitionData, String filename) {\n+      throw new RuntimeException(\"Test custom provider does not expect any invocation\");\n+    }\n+  }\n+\n+  // publicly visible for testing to be dynamically loaded\n+  public static class InvalidDynamicallyLoadedLocationProvider implements LocationProvider {\n+    // No public constructor\n+\n+    @Override\n+    public String newDataLocation(String filename) {\n+      throw new IllegalStateException(\"Should have never been instantiated\");\n+    }\n+\n+    @Override\n+    public String newDataLocation(PartitionSpec spec, StructLike partitionData, String filename) {\n+      throw new IllegalStateException(\"Should have never been instantiated\");\n+    }\n+  }\n+\n+  @Test\n+  public void testDefaultLocationProvider() {\n+    this.table.updateProperties()\n+        .commit();\n+\n+    this.table.locationProvider().newDataLocation(\"my_file\");\n+    Assert.assertEquals(\n+        \"Default data path should have table location as root\",\n+        String.format(\"%s/data/%s\", this.table.location(), \"my_file\"),\n+        this.table.locationProvider().newDataLocation(\"my_file\")\n+    );\n+  }\n+\n+  @Test\n+  public void testDefaultLocationProviderWithCustomDataLocation() {\n+    this.table.updateProperties()\n+        .set(TableProperties.WRITE_NEW_DATA_LOCATION, \"new_location\")\n+        .commit();\n+\n+    this.table.locationProvider().newDataLocation(\"my_file\");\n+    Assert.assertEquals(\n+        \"Default location provider should allow custom path location\",\n+        \"new_location/my_file\",\n+        this.table.locationProvider().newDataLocation(\"my_file\")\n+    );\n+  }\n+\n+  @Test\n+  public void testDynamicallyLoadedLocationProvider() {\n+    this.table.updateProperties()\n+        .set(TableProperties.LOCATION_PROVIDER_IMPL,\n+            String.format(\"%s$%s\",\n+                this.getClass().getCanonicalName(),\n+                DynamicallyLoadedLocationProvider.class.getSimpleName()))\n+        .commit();\n+\n+    Assert.assertTrue(String.format(\"Table should load impl defined in its properties\"),\n+        this.table.locationProvider() instanceof DynamicallyLoadedLocationProvider\n+    );\n+\n+    Assert.assertEquals(\n+        \"Custom provider should take base table location\",\n+        String.format(\"%s/test_custom_provider/%s\", this.table.location(), \"my_file\"),\n+        this.table.locationProvider().newDataLocation(\"my_file\")\n+    );\n+  }\n+\n+  @Test\n+  public void testDynamicallyLoadedLocationProviderNotFound() {\n+    String nonExistentImpl = String.format(\"%s$NonExistent%s\",\n+        this.getClass().getCanonicalName(),\n+        DynamicallyLoadedLocationProvider.class.getSimpleName());\n+    this.table.updateProperties()\n+        .set(TableProperties.LOCATION_PROVIDER_IMPL, nonExistentImpl)\n+        .commit();\n+\n+    exceptionRule.expect(IllegalArgumentException.class);\n+    exceptionRule.expectMessage(\n+        String.format(\"Unable to instantiate the provided implementation %s for %s.\",\n+            nonExistentImpl,\n+            LocationProvider.class));\n+    this.table.locationProvider();", "originalCommit": "9b22a8c19d570dd7c6e7671b31dc704cf122b85c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MDAzNQ==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499750035", "bodyText": "Should we support a no-arg constructor as well as the one that passes the table location and properties?", "author": "rdblue", "createdAt": "2020-10-05T17:12:54Z", "path": "core/src/test/java/org/apache/iceberg/TestLocationProvider.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.util.Map;\n+import org.apache.iceberg.io.LocationProvider;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public class TestLocationProvider extends TableTestBase {\n+  @Parameterized.Parameters\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+        new Object[] { 1 },\n+        new Object[] { 2 },\n+    };\n+  }\n+\n+  public TestLocationProvider(int formatVersion) {\n+    super(formatVersion);\n+  }\n+\n+  @Rule\n+  public ExpectedException exceptionRule = ExpectedException.none();\n+\n+  // publicly visible for testing to be dynamically loaded\n+  public static class DynamicallyLoadedLocationProvider implements LocationProvider {\n+    String tableLocation;\n+    Map<String, String> properties;\n+\n+    public DynamicallyLoadedLocationProvider(String tableLocation, Map<String, String> properties) {\n+      this.tableLocation = tableLocation;\n+      this.properties = properties;\n+    }\n+\n+    @Override\n+    public String newDataLocation(String filename) {\n+      return String.format(\"%s/test_custom_provider/%s\", this.tableLocation, filename);\n+    }\n+\n+    @Override\n+    public String newDataLocation(PartitionSpec spec, StructLike partitionData, String filename) {\n+      throw new RuntimeException(\"Test custom provider does not expect any invocation\");\n+    }\n+  }\n+\n+  // publicly visible for testing to be dynamically loaded\n+  public static class InvalidDynamicallyLoadedLocationProvider implements LocationProvider {\n+    // No public constructor", "originalCommit": "9b22a8c19d570dd7c6e7671b31dc704cf122b85c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MDIxOQ==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499750219", "bodyText": "What happens if the class doesn't implement LocationProvider?\nCould you add a test case for that?", "author": "rdblue", "createdAt": "2020-10-05T17:13:13Z", "path": "core/src/test/java/org/apache/iceberg/TestLocationProvider.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.util.Map;\n+import org.apache.iceberg.io.LocationProvider;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public class TestLocationProvider extends TableTestBase {\n+  @Parameterized.Parameters\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+        new Object[] { 1 },\n+        new Object[] { 2 },\n+    };\n+  }\n+\n+  public TestLocationProvider(int formatVersion) {\n+    super(formatVersion);\n+  }\n+\n+  @Rule\n+  public ExpectedException exceptionRule = ExpectedException.none();\n+\n+  // publicly visible for testing to be dynamically loaded\n+  public static class DynamicallyLoadedLocationProvider implements LocationProvider {\n+    String tableLocation;\n+    Map<String, String> properties;\n+\n+    public DynamicallyLoadedLocationProvider(String tableLocation, Map<String, String> properties) {\n+      this.tableLocation = tableLocation;\n+      this.properties = properties;\n+    }\n+\n+    @Override\n+    public String newDataLocation(String filename) {\n+      return String.format(\"%s/test_custom_provider/%s\", this.tableLocation, filename);\n+    }\n+\n+    @Override\n+    public String newDataLocation(PartitionSpec spec, StructLike partitionData, String filename) {\n+      throw new RuntimeException(\"Test custom provider does not expect any invocation\");\n+    }\n+  }\n+\n+  // publicly visible for testing to be dynamically loaded\n+  public static class InvalidDynamicallyLoadedLocationProvider implements LocationProvider {\n+    // No public constructor\n+\n+    @Override\n+    public String newDataLocation(String filename) {\n+      throw new IllegalStateException(\"Should have never been instantiated\");\n+    }\n+\n+    @Override\n+    public String newDataLocation(PartitionSpec spec, StructLike partitionData, String filename) {\n+      throw new IllegalStateException(\"Should have never been instantiated\");\n+    }\n+  }\n+\n+  @Test\n+  public void testDefaultLocationProvider() {\n+    this.table.updateProperties()\n+        .commit();\n+\n+    this.table.locationProvider().newDataLocation(\"my_file\");\n+    Assert.assertEquals(\n+        \"Default data path should have table location as root\",\n+        String.format(\"%s/data/%s\", this.table.location(), \"my_file\"),\n+        this.table.locationProvider().newDataLocation(\"my_file\")\n+    );\n+  }\n+\n+  @Test\n+  public void testDefaultLocationProviderWithCustomDataLocation() {\n+    this.table.updateProperties()\n+        .set(TableProperties.WRITE_NEW_DATA_LOCATION, \"new_location\")\n+        .commit();\n+\n+    this.table.locationProvider().newDataLocation(\"my_file\");\n+    Assert.assertEquals(\n+        \"Default location provider should allow custom path location\",\n+        \"new_location/my_file\",\n+        this.table.locationProvider().newDataLocation(\"my_file\")\n+    );\n+  }\n+\n+  @Test\n+  public void testDynamicallyLoadedLocationProvider() {\n+    this.table.updateProperties()\n+        .set(TableProperties.LOCATION_PROVIDER_IMPL,\n+            String.format(\"%s$%s\",\n+                this.getClass().getCanonicalName(),\n+                DynamicallyLoadedLocationProvider.class.getSimpleName()))\n+        .commit();\n+\n+    Assert.assertTrue(String.format(\"Table should load impl defined in its properties\"),\n+        this.table.locationProvider() instanceof DynamicallyLoadedLocationProvider\n+    );\n+\n+    Assert.assertEquals(\n+        \"Custom provider should take base table location\",\n+        String.format(\"%s/test_custom_provider/%s\", this.table.location(), \"my_file\"),\n+        this.table.locationProvider().newDataLocation(\"my_file\")\n+    );\n+  }\n+\n+  @Test\n+  public void testDynamicallyLoadedLocationProviderNotFound() {\n+    String nonExistentImpl = String.format(\"%s$NonExistent%s\",\n+        this.getClass().getCanonicalName(),\n+        DynamicallyLoadedLocationProvider.class.getSimpleName());\n+    this.table.updateProperties()\n+        .set(TableProperties.LOCATION_PROVIDER_IMPL, nonExistentImpl)\n+        .commit();\n+\n+    exceptionRule.expect(IllegalArgumentException.class);\n+    exceptionRule.expectMessage(\n+        String.format(\"Unable to instantiate the provided implementation %s for %s.\",\n+            nonExistentImpl,\n+            LocationProvider.class));\n+    this.table.locationProvider();\n+  }\n+\n+  @Test\n+  public void testInvalidDynamicallyLoadedLocationProvider() {", "originalCommit": "9b22a8c19d570dd7c6e7671b31dc704cf122b85c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MTAyMg==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499751022", "bodyText": "Do we want to add this to the docs?", "author": "aokolnychyi", "createdAt": "2020-10-05T17:14:37Z", "path": "core/src/main/java/org/apache/iceberg/TableProperties.java", "diffHunk": "@@ -87,6 +87,8 @@ private TableProperties() {\n   public static final String OBJECT_STORE_ENABLED = \"write.object-storage.enabled\";\n   public static final boolean OBJECT_STORE_ENABLED_DEFAULT = false;\n \n+  public static final String LOCATION_PROVIDER_IMPL = \"write.location-provider.impl\";", "originalCommit": "9b22a8c19d570dd7c6e7671b31dc704cf122b85c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1ODkzMQ==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499758931", "bodyText": "Yes", "author": "rdblue", "createdAt": "2020-10-05T17:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MTAyMg=="}], "type": "inlineReview"}, {"oid": "c0c25a251ced0038d1527eda303f34f64d1c632c", "url": "https://github.com/apache/iceberg/commit/c0c25a251ced0038d1527eda303f34f64d1c632c", "message": "support no-arg and write more negative tests", "committedDate": "2020-10-05T19:00:34Z", "type": "commit"}, {"oid": "6f60d5f77b6641a01638d75af2618940bbd9ded4", "url": "https://github.com/apache/iceberg/commit/6f60d5f77b6641a01638d75af2618940bbd9ded4", "message": "use assert helper for future test extension", "committedDate": "2020-10-05T19:11:45Z", "type": "commit"}, {"oid": "c14078a4efe51cadf2238bc2af131e8cbfb703f1", "url": "https://github.com/apache/iceberg/commit/c14078a4efe51cadf2238bc2af131e8cbfb703f1", "message": "order and update python props", "committedDate": "2020-10-05T19:14:57Z", "type": "commit"}, {"oid": "a34b5d206a29d92ef489c2a27ed96b7b06d31b10", "url": "https://github.com/apache/iceberg/commit/a34b5d206a29d92ef489c2a27ed96b7b06d31b10", "message": "prefix with new prop with WRITE", "committedDate": "2020-10-05T19:19:36Z", "type": "commit"}, {"oid": "299ed00c6df9ff6b8628afd36fbeae4d18cc83e2", "url": "https://github.com/apache/iceberg/commit/299ed00c6df9ff6b8628afd36fbeae4d18cc83e2", "message": "update docs", "committedDate": "2020-10-05T19:42:02Z", "type": "commit"}, {"oid": "0eee2886d3511362581f170aa0e9217740b1e472", "url": "https://github.com/apache/iceberg/commit/0eee2886d3511362581f170aa0e9217740b1e472", "message": "add doc stiring", "committedDate": "2020-10-05T20:01:18Z", "type": "commit"}, {"oid": "5906be082b4371947a784e239245c0c35d1928df", "url": "https://github.com/apache/iceberg/commit/5906be082b4371947a784e239245c0c35d1928df", "message": "fix formatting", "committedDate": "2020-10-05T21:01:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MzQ3Nw==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499873477", "bodyText": "When the arguments passed to one constructor are a prefix of the args passed to the other, there is no need to use a different builder or call because the arguments actually passed are limited by the number of parameters defined by the constructor. That makes it possible to pass both arguments to either one, and any extras are ignored.\nThat helps simplify cases like this because you don't need the extra optional logic:\n  ctor = DynConstructors.builder(LocationProvider.class)\n      .impl(impl, String.class, Map.class)\n      .impl(impl) // fall back to no-arg constructor\n      .build()\n  return ctor.newInstance(location, properties);", "author": "rdblue", "createdAt": "2020-10-05T21:08:10Z", "path": "core/src/main/java/org/apache/iceberg/LocationProviders.java", "diffHunk": "@@ -45,6 +50,53 @@ public static LocationProvider locationsFor(String location, Map<String, String>\n     }\n   }\n \n+  private static LocationProvider dynamicallyLoadLocationProvider(String location, Map<String, String> properties) {\n+    String impl = properties.get(TableProperties.WRITE_LOCATION_PROVIDER_IMPL);\n+    Optional<DynConstructors.Ctor<LocationProvider>> noArgConstructor = findConstructor(() ->\n+        DynConstructors.builder(LocationProvider.class)\n+            .impl(impl).build()\n+    );\n+    Optional<DynConstructors.Ctor<LocationProvider>> twoArgConstructor = Optional.empty();", "originalCommit": "5906be082b4371947a784e239245c0c35d1928df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg4MDMxNg==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499880316", "bodyText": "thanks for the explanation here", "author": "mickjermsurawong-stripe", "createdAt": "2020-10-05T21:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MzQ3Nw=="}], "type": "inlineReview"}, {"oid": "5f9be8ccb54af92fabfc147af2ab6261ade6a8ea", "url": "https://github.com/apache/iceberg/commit/5f9be8ccb54af92fabfc147af2ab6261ade6a8ea", "message": "simplify constructor", "committedDate": "2020-10-05T21:35:16Z", "type": "commit"}, {"oid": "3aeb9e51878350845a31561c8861720c5a2f6841", "url": "https://github.com/apache/iceberg/commit/3aeb9e51878350845a31561c8861720c5a2f6841", "message": "add doc to new property", "committedDate": "2020-10-05T21:35:28Z", "type": "commit"}, {"oid": "2729b79e2f28bc503514223680a03fce4d3eccb7", "url": "https://github.com/apache/iceberg/commit/2729b79e2f28bc503514223680a03fce4d3eccb7", "message": "revert manual html updates", "committedDate": "2020-10-05T21:36:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg4NzIyNQ==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499887225", "bodyText": "If provided class has the specified constructor signature, but not implementing LocationProvider, it can still be loaded into the dynConstructor. The following block differentiates this missing interface more explicitly.\nMight be a bit more code churn, but it does give more signals to users.", "author": "mickjermsurawong-stripe", "createdAt": "2020-10-05T21:38:55Z", "path": "core/src/main/java/org/apache/iceberg/LocationProviders.java", "diffHunk": "@@ -36,7 +37,29 @@ private LocationProviders() {\n   }\n \n   public static LocationProvider locationsFor(String location, Map<String, String> properties) {\n-    if (PropertyUtil.propertyAsBoolean(properties,\n+    if (properties.containsKey(TableProperties.WRITE_LOCATION_PROVIDER_IMPL)) {\n+      String impl = properties.get(TableProperties.WRITE_LOCATION_PROVIDER_IMPL);\n+      DynConstructors.Ctor<LocationProvider> ctor;\n+      try {\n+        ctor = DynConstructors.builder(LocationProvider.class)\n+            .impl(impl, String.class, Map.class)\n+            .impl(impl).build(); // fall back to no-arg constructor\n+      } catch (RuntimeException e) {\n+        throw new IllegalArgumentException(String.format(\n+            \"Unable to find a constructor for implementation %s of %s. \" +\n+                \"Make sure the implementation is in classpath, and that it either \" +\n+                \"has a public no-arg constructor or a two-arg constructor \" +\n+                \"taking in the string base table location and its property string map.\",\n+            impl, LocationProvider.class));\n+      }", "originalCommit": "2729b79e2f28bc503514223680a03fce4d3eccb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxOTY0MA==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499919640", "bodyText": "Dynamic constructor?", "author": "rdblue", "createdAt": "2020-10-05T23:08:48Z", "path": "core/src/main/java/org/apache/iceberg/LocationProviders.java", "diffHunk": "@@ -36,7 +37,29 @@ private LocationProviders() {\n   }\n \n   public static LocationProvider locationsFor(String location, Map<String, String> properties) {\n-    if (PropertyUtil.propertyAsBoolean(properties,\n+    if (properties.containsKey(TableProperties.WRITE_LOCATION_PROVIDER_IMPL)) {\n+      String impl = properties.get(TableProperties.WRITE_LOCATION_PROVIDER_IMPL);\n+      DynConstructors.Ctor<LocationProvider> ctor;\n+      try {\n+        ctor = DynConstructors.builder(LocationProvider.class)\n+            .impl(impl, String.class, Map.class)\n+            .impl(impl).build(); // fall back to no-arg constructor\n+      } catch (RuntimeException e) {\n+        throw new IllegalArgumentException(String.format(\n+            \"Unable to find a constructor for implementation %s of %s. \" +\n+                \"Make sure the implementation is in classpath, and that it either \" +\n+                \"has a public no-arg constructor or a two-arg constructor \" +\n+                \"taking in the string base table location and its property string map.\",\n+            impl, LocationProvider.class));\n+      }\n+      try {\n+        return ctor.newInstance(location, properties);\n+      } catch (ClassCastException e) {\n+        throw new IllegalArgumentException(\n+            String.format(\"Provided implementation for dynamic instantiation should implement %s, \" +\n+                \"but found dynamic constructor %s.\", LocationProvider.class, ctor));", "originalCommit": "2729b79e2f28bc503514223680a03fce4d3eccb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMDc2Nw==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499920767", "bodyText": "Here as well you should probably throw the exception with the original as a cause so the context isn't lost.", "author": "rdblue", "createdAt": "2020-10-05T23:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxOTY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMDYzNw==", "url": "https://github.com/apache/iceberg/pull/1531#discussion_r499920637", "bodyText": "Since you're catching the exception, it probably makes more sense to use buildChecked so the exception class isn't generic. That exception also has good information about why all of the implementations failed, so I would recommend adding that exception as a cause to this one that is thrown. I like throwing this one for context, though!", "author": "rdblue", "createdAt": "2020-10-05T23:11:58Z", "path": "core/src/main/java/org/apache/iceberg/LocationProviders.java", "diffHunk": "@@ -36,7 +37,29 @@ private LocationProviders() {\n   }\n \n   public static LocationProvider locationsFor(String location, Map<String, String> properties) {\n-    if (PropertyUtil.propertyAsBoolean(properties,\n+    if (properties.containsKey(TableProperties.WRITE_LOCATION_PROVIDER_IMPL)) {\n+      String impl = properties.get(TableProperties.WRITE_LOCATION_PROVIDER_IMPL);\n+      DynConstructors.Ctor<LocationProvider> ctor;\n+      try {\n+        ctor = DynConstructors.builder(LocationProvider.class)\n+            .impl(impl, String.class, Map.class)\n+            .impl(impl).build(); // fall back to no-arg constructor\n+      } catch (RuntimeException e) {\n+        throw new IllegalArgumentException(String.format(\n+            \"Unable to find a constructor for implementation %s of %s. \" +\n+                \"Make sure the implementation is in classpath, and that it either \" +\n+                \"has a public no-arg constructor or a two-arg constructor \" +\n+                \"taking in the string base table location and its property string map.\",\n+            impl, LocationProvider.class));", "originalCommit": "2729b79e2f28bc503514223680a03fce4d3eccb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8c324c5b1c842bd6482204093e822acfd56e527d", "url": "https://github.com/apache/iceberg/commit/8c324c5b1c842bd6482204093e822acfd56e527d", "message": "propagate cause", "committedDate": "2020-10-05T23:30:41Z", "type": "commit"}]}