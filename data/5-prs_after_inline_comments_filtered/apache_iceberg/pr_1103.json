{"pr_number": 1103, "pr_title": "Add IcebergSerDe", "pr_createdAt": "2020-06-08T16:30:37Z", "pr_url": "https://github.com/apache/iceberg/pull/1103", "timeline": [{"oid": "a96f950a9800f7efe6717e02d437c8c155758ac7", "url": "https://github.com/apache/iceberg/commit/a96f950a9800f7efe6717e02d437c8c155758ac7", "message": "Adding serde classes", "committedDate": "2020-06-08T15:21:02Z", "type": "commit"}, {"oid": "8ec7a4bf44fea63dd17a95e31f283b2541ee6dfd", "url": "https://github.com/apache/iceberg/commit/8ec7a4bf44fea63dd17a95e31f283b2541ee6dfd", "message": "added some required classes", "committedDate": "2020-06-08T15:50:10Z", "type": "commit"}, {"oid": "90311cc8ba9d11ace4e8c4237f5c908d95d91ce6", "url": "https://github.com/apache/iceberg/commit/90311cc8ba9d11ace4e8c4237f5c908d95d91ce6", "message": "Add tests", "committedDate": "2020-06-08T16:24:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg0NzE4MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r436847180", "bodyText": "Can you add the log message you want now? Or just remove the try/catch as it's not adding anything right now.", "author": "massdosage", "createdAt": "2020-06-08T16:45:29Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSchemaToTypeInfo.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.hadoop.hive.serde.serdeConstants;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.typeinfo.HiveDecimalUtils;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+/**\n+ * Class to convert Iceberg types to Hive TypeInfo\n+ */\n+final class IcebergSchemaToTypeInfo {\n+\n+  private IcebergSchemaToTypeInfo() {\n+\n+  }\n+\n+  private static final ImmutableMap<Object, Object> primitiveTypeToTypeInfo = ImmutableMap.builder()\n+      .put(Types.BooleanType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BOOLEAN_TYPE_NAME))\n+      .put(Types.IntegerType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.INT_TYPE_NAME))\n+      .put(Types.LongType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .put(Types.FloatType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.FLOAT_TYPE_NAME))\n+      .put(Types.DoubleType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.DOUBLE_TYPE_NAME))\n+      .put(Types.BinaryType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BINARY_TYPE_NAME))\n+      .put(Types.StringType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME))\n+      .put(Types.DateType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.DATE_TYPE_NAME))\n+      .put(Types.TimestampType.withoutZone(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .put(Types.TimestampType.withZone(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .build();\n+\n+  public static List<TypeInfo> getColumnTypes(Schema schema) throws Exception {\n+    List<Types.NestedField> fields = schema.columns();\n+    List<TypeInfo> types = new ArrayList<>(fields.size());\n+    for (Types.NestedField field : fields) {\n+      types.add(generateTypeInfo(field.type()));\n+    }\n+    return types;\n+  }\n+\n+  private static TypeInfo generateTypeInfo(Type type) throws Exception {\n+    if (primitiveTypeToTypeInfo.containsKey(type)) {\n+      return (TypeInfo) primitiveTypeToTypeInfo.get(type);\n+    }\n+    switch (type.typeId()) {\n+      case UUID:\n+        return TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME);\n+      case FIXED:\n+        return TypeInfoFactory.getPrimitiveTypeInfo(\"binary\");\n+      case TIME:\n+        return TypeInfoFactory.getPrimitiveTypeInfo(\"long\");\n+      case DECIMAL:\n+        Types.DecimalType dec = (Types.DecimalType) type;\n+        int scale = dec.scale();\n+        int precision = dec.precision();\n+        try {\n+          HiveDecimalUtils.validateParameter(precision, scale);\n+        } catch (Exception e) {\n+          //TODO Log that precision / scale isn't valid", "originalCommit": "90311cc8ba9d11ace4e8c4237f5c908d95d91ce6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "url": "https://github.com/apache/iceberg/commit/c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "message": "Remove try/catch", "committedDate": "2020-06-09T08:45:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NjU1OA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438286558", "bodyText": "Nit: no need for a blank line here.", "author": "rdblue", "createdAt": "2020-06-10T17:18:59Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSchemaToTypeInfo.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.hadoop.hive.serde.serdeConstants;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.typeinfo.HiveDecimalUtils;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+/**\n+ * Class to convert Iceberg types to Hive TypeInfo\n+ */\n+final class IcebergSchemaToTypeInfo {\n+\n+  private IcebergSchemaToTypeInfo() {\n+", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NzM0OA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438287348", "bodyText": "Why not use serdeConstants here and for the fixed case?", "author": "rdblue", "createdAt": "2020-06-10T17:20:20Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSchemaToTypeInfo.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.hadoop.hive.serde.serdeConstants;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.typeinfo.HiveDecimalUtils;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+/**\n+ * Class to convert Iceberg types to Hive TypeInfo\n+ */\n+final class IcebergSchemaToTypeInfo {\n+\n+  private IcebergSchemaToTypeInfo() {\n+\n+  }\n+\n+  private static final ImmutableMap<Object, Object> primitiveTypeToTypeInfo = ImmutableMap.builder()\n+      .put(Types.BooleanType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BOOLEAN_TYPE_NAME))\n+      .put(Types.IntegerType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.INT_TYPE_NAME))\n+      .put(Types.LongType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .put(Types.FloatType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.FLOAT_TYPE_NAME))\n+      .put(Types.DoubleType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.DOUBLE_TYPE_NAME))\n+      .put(Types.BinaryType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BINARY_TYPE_NAME))\n+      .put(Types.StringType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME))\n+      .put(Types.DateType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.DATE_TYPE_NAME))\n+      .put(Types.TimestampType.withoutZone(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .put(Types.TimestampType.withZone(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .build();\n+\n+  public static List<TypeInfo> getColumnTypes(Schema schema) throws Exception {\n+    List<Types.NestedField> fields = schema.columns();\n+    List<TypeInfo> types = new ArrayList<>(fields.size());\n+    for (Types.NestedField field : fields) {\n+      types.add(generateTypeInfo(field.type()));\n+    }\n+    return types;\n+  }\n+\n+  private static TypeInfo generateTypeInfo(Type type) throws Exception {\n+    if (primitiveTypeToTypeInfo.containsKey(type)) {\n+      return (TypeInfo) primitiveTypeToTypeInfo.get(type);\n+    }\n+    switch (type.typeId()) {\n+      case UUID:\n+        return TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME);\n+      case FIXED:\n+        return TypeInfoFactory.getPrimitiveTypeInfo(\"binary\");\n+      case TIME:\n+        return TypeInfoFactory.getPrimitiveTypeInfo(\"long\");", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4ODU3MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438288570", "bodyText": "Since this is public, can you add Javadoc describing its purpose?", "author": "rdblue", "createdAt": "2020-06-10T17:22:28Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergWritable.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.Record;\n+\n+public class IcebergWritable implements Writable {", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4ODY1Ng==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438288656", "bodyText": "No need to include empty public constructors.", "author": "rdblue", "createdAt": "2020-06-10T17:22:36Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergWritable.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.Record;\n+\n+public class IcebergWritable implements Writable {\n+\n+  private Record record;\n+  private Schema schema;\n+\n+  public IcebergWritable() {}", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4ODk3Nw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438288977", "bodyText": "We typically use the verb wrap for this pattern.", "author": "rdblue", "createdAt": "2020-06-10T17:23:11Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergWritable.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.Record;\n+\n+public class IcebergWritable implements Writable {\n+\n+  private Record record;\n+  private Schema schema;\n+\n+  public IcebergWritable() {}\n+\n+  public void setRecord(Record record) {", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4OTE3Nw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438289177", "bodyText": "For getters, we omit get because it doesn't add any value.", "author": "rdblue", "createdAt": "2020-06-10T17:23:33Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergWritable.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.Record;\n+\n+public class IcebergWritable implements Writable {\n+\n+  private Record record;\n+  private Schema schema;\n+\n+  public IcebergWritable() {}\n+\n+  public void setRecord(Record record) {\n+    this.record = record;\n+  }\n+\n+  public Record getRecord() {", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4OTQ3MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438289470", "bodyText": "If this writable isn't actually writable, then I think this should throw UnsupportedOperationException here and in readFields.", "author": "rdblue", "createdAt": "2020-06-10T17:24:04Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergWritable.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.Record;\n+\n+public class IcebergWritable implements Writable {\n+\n+  private Record record;\n+  private Schema schema;\n+\n+  public IcebergWritable() {}\n+\n+  public void setRecord(Record record) {\n+    this.record = record;\n+  }\n+\n+  public Record getRecord() {\n+    return record;\n+  }\n+\n+  public Schema getSchema() {\n+    return schema;\n+  }\n+\n+  public void setSchema(Schema schema) {\n+    this.schema = schema;\n+  }\n+\n+  @Override\n+  public void write(DataOutput dataOutput) throws IOException {\n+", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MTY3Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438291672", "bodyText": "If this is configurable, then why use the double underscore name? Couldn't this use snapshot_id instead?", "author": "rdblue", "createdAt": "2020-06-10T17:27:35Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/SystemTableUtil.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.types.Types;\n+\n+public class SystemTableUtil {\n+\n+  static final String VIRTUAL_COLUMN_NAME = \"iceberg.hive.snapshot.virtual.column.name\";\n+\n+  private static final String DEFAULT_SNAPSHOT_ID_COLUMN_NAME = \"snapshot__id\";", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0MzU1NA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438643554", "bodyText": "We ended up going with the double underscore option to follow the convention of the inbuilt virtual columns in Hive: https://cwiki.apache.org/confluence/display/Hive/LanguageManual+VirtualColumns\nI agree it does add a little bit of extra confusion with the slight difference between Iceberg's column name and our choice for the virtual column name, but the argument could go either way. We're happy to go for any option as it'll just be a matter of documenting - do you have a preference?", "author": "cmathiesen", "createdAt": "2020-06-11T09:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MTY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3NDE5Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439074192", "bodyText": "If this is to follow an established pattern in Hive, I'm happy with it.", "author": "rdblue", "createdAt": "2020-06-11T21:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MTY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MjE3OA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438292178", "bodyText": "We generally like to use Lists.newArrayList() to avoid depending on a specific implementation class.", "author": "rdblue", "createdAt": "2020-06-10T17:28:25Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/SystemTableUtil.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.types.Types;\n+\n+public class SystemTableUtil {\n+\n+  static final String VIRTUAL_COLUMN_NAME = \"iceberg.hive.snapshot.virtual.column.name\";\n+\n+  private static final String DEFAULT_SNAPSHOT_ID_COLUMN_NAME = \"snapshot__id\";\n+\n+  private SystemTableUtil() {}\n+\n+  protected static Schema schemaWithVirtualColumn(Schema schema, String columnName) {\n+    List<Types.NestedField> columns = new ArrayList<>(schema.columns());", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MzA1Mw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438293053", "bodyText": "The field positions match, right? If so, then this could just iterate through positions in the original record instead of names. That would avoid a hashmap lookup of the position for both get and set.", "author": "rdblue", "createdAt": "2020-06-10T17:29:50Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/SystemTableUtil.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.types.Types;\n+\n+public class SystemTableUtil {\n+\n+  static final String VIRTUAL_COLUMN_NAME = \"iceberg.hive.snapshot.virtual.column.name\";\n+\n+  private static final String DEFAULT_SNAPSHOT_ID_COLUMN_NAME = \"snapshot__id\";\n+\n+  private SystemTableUtil() {}\n+\n+  protected static Schema schemaWithVirtualColumn(Schema schema, String columnName) {\n+    List<Types.NestedField> columns = new ArrayList<>(schema.columns());\n+    columns.add(Types.NestedField.optional(Integer.MAX_VALUE, columnName, Types.LongType.get()));\n+    return new Schema(columns);\n+  }\n+\n+  protected static Record recordWithVirtualColumn(Record record, long snapshotId, Schema oldSchema,\n+                                                   String columnName) {\n+    Schema newSchema = schemaWithVirtualColumn(oldSchema, columnName);\n+    Record newRecord = GenericRecord.create(newSchema);\n+    for (Types.NestedField field : oldSchema.columns()) {", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MzUwNQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438293505", "bodyText": "When are properties used and when is configuration used? I'm surprised that we need both.", "author": "rdblue", "createdAt": "2020-06-10T17:30:33Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/SystemTableUtil.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.types.Types;\n+\n+public class SystemTableUtil {\n+\n+  static final String VIRTUAL_COLUMN_NAME = \"iceberg.hive.snapshot.virtual.column.name\";\n+\n+  private static final String DEFAULT_SNAPSHOT_ID_COLUMN_NAME = \"snapshot__id\";\n+\n+  private SystemTableUtil() {}\n+\n+  protected static Schema schemaWithVirtualColumn(Schema schema, String columnName) {\n+    List<Types.NestedField> columns = new ArrayList<>(schema.columns());\n+    columns.add(Types.NestedField.optional(Integer.MAX_VALUE, columnName, Types.LongType.get()));\n+    return new Schema(columns);\n+  }\n+\n+  protected static Record recordWithVirtualColumn(Record record, long snapshotId, Schema oldSchema,\n+                                                   String columnName) {\n+    Schema newSchema = schemaWithVirtualColumn(oldSchema, columnName);\n+    Record newRecord = GenericRecord.create(newSchema);\n+    for (Types.NestedField field : oldSchema.columns()) {\n+      newRecord.setField(field.name(), record.getField(field.name()));\n+    }\n+    newRecord.setField(columnName, snapshotId);\n+    return newRecord;\n+  }\n+\n+  protected static String getVirtualColumnName(Configuration conf) {\n+    String virtualColumnName = conf.get(VIRTUAL_COLUMN_NAME);\n+    if (virtualColumnName == null) {\n+      return DEFAULT_SNAPSHOT_ID_COLUMN_NAME;\n+    } else {\n+      return virtualColumnName;\n+    }\n+  }\n+\n+  protected static String getVirtualColumnName(Properties properties) {", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY4ODg4MQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438688881", "bodyText": "Yeah we agree, we discovered this when adding the SerDe - the IF uses Configuration but the SerDe only uses Properties and we wanted to use the methods across both classes and it seemed simpler to overload a method rather than create new Properties from the Configuration in the IF", "author": "cmathiesen", "createdAt": "2020-06-11T10:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MzUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY5MzY0Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438693642", "bodyText": "Although is exactly what we're doing in the TableResolver class... :')", "author": "cmathiesen", "createdAt": "2020-06-11T10:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MzUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg5ODc1OQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r440898759", "bodyText": "The configuration contains all the configs we set in HiveConf and possible hadoop conf as well.\nThe properties are a  merged result of Hive table and partition properties.  We can see how Hive uses these as part of the initialize method of AbstractSerde\npublic void initialize(Configuration configuration, Properties tableProperties,\n                         Properties partitionProperties) throws SerDeException {\n    initialize(configuration,\n               SerDeUtils.createOverlayedProperties(tableProperties, partitionProperties));\n  }```", "author": "rdsr", "createdAt": "2020-06-16T14:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MzUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMDM4NQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438300385", "bodyText": "It looks like this would be easier to implement using the type visitors, which already have the logic to traverse a schema. A good example is converting a Type to Spark's DataType.", "author": "rdblue", "createdAt": "2020-06-10T17:42:10Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSchemaToTypeInfo.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.hadoop.hive.serde.serdeConstants;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.typeinfo.HiveDecimalUtils;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+/**\n+ * Class to convert Iceberg types to Hive TypeInfo\n+ */\n+final class IcebergSchemaToTypeInfo {\n+\n+  private IcebergSchemaToTypeInfo() {\n+\n+  }\n+\n+  private static final ImmutableMap<Object, Object> primitiveTypeToTypeInfo = ImmutableMap.builder()\n+      .put(Types.BooleanType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BOOLEAN_TYPE_NAME))\n+      .put(Types.IntegerType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.INT_TYPE_NAME))\n+      .put(Types.LongType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .put(Types.FloatType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.FLOAT_TYPE_NAME))\n+      .put(Types.DoubleType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.DOUBLE_TYPE_NAME))\n+      .put(Types.BinaryType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BINARY_TYPE_NAME))\n+      .put(Types.StringType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME))\n+      .put(Types.DateType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.DATE_TYPE_NAME))\n+      .put(Types.TimestampType.withoutZone(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .put(Types.TimestampType.withZone(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .build();\n+\n+  public static List<TypeInfo> getColumnTypes(Schema schema) throws Exception {\n+    List<Types.NestedField> fields = schema.columns();\n+    List<TypeInfo> types = new ArrayList<>(fields.size());\n+    for (Types.NestedField field : fields) {\n+      types.add(generateTypeInfo(field.type()));\n+    }\n+    return types;\n+  }\n+\n+  private static TypeInfo generateTypeInfo(Type type) throws Exception {", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY5NDQ4Nw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438694487", "bodyText": "That looks way simpler, I'll get started on that", "author": "cmathiesen", "createdAt": "2020-06-11T10:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMDM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwNTI2MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439005260", "bodyText": "I already have a type visitor somewhere from Schema to ObjectInspector. I can also submit that one on my PR so you can focus on the remaining things to do.", "author": "guilload", "createdAt": "2020-06-11T19:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMDM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE5MDM1MQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439190351", "bodyText": "Yea +1 for a visitor. We have TypeInfo to Iceberg Type visitor for inspiration https://github.com/linkedin/iceberg/blob/master/hive/src/main/java/org/apache/iceberg/hive/legacy/HiveTypeToIcebergType.java", "author": "rdsr", "createdAt": "2020-06-12T03:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMDM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5MTI5MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439291290", "bodyText": "@guilload that would be great, thank you!", "author": "cmathiesen", "createdAt": "2020-06-12T08:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMDM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMDM2Ng==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439600366", "bodyText": "Still work in progress, things missing are mostly unit tests, but this is what it'll look like:\nguilload@3bffa7c", "author": "guilload", "createdAt": "2020-06-12T19:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMDM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE0NjY0Mw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r440146643", "bodyText": "That looks promising, happy to move that in here when you're done if the others agree. Thanks!", "author": "massdosage", "createdAt": "2020-06-15T12:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMDM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMDY2MQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438300661", "bodyText": "Doesn't Hive have timestamp types?", "author": "rdblue", "createdAt": "2020-06-10T17:42:38Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSchemaToTypeInfo.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.hadoop.hive.serde.serdeConstants;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.typeinfo.HiveDecimalUtils;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+/**\n+ * Class to convert Iceberg types to Hive TypeInfo\n+ */\n+final class IcebergSchemaToTypeInfo {\n+\n+  private IcebergSchemaToTypeInfo() {\n+\n+  }\n+\n+  private static final ImmutableMap<Object, Object> primitiveTypeToTypeInfo = ImmutableMap.builder()\n+      .put(Types.BooleanType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BOOLEAN_TYPE_NAME))\n+      .put(Types.IntegerType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.INT_TYPE_NAME))\n+      .put(Types.LongType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .put(Types.FloatType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.FLOAT_TYPE_NAME))\n+      .put(Types.DoubleType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.DOUBLE_TYPE_NAME))\n+      .put(Types.BinaryType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BINARY_TYPE_NAME))\n+      .put(Types.StringType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME))\n+      .put(Types.DateType.get(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.DATE_TYPE_NAME))\n+      .put(Types.TimestampType.withoutZone(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))\n+      .put(Types.TimestampType.withZone(), TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.BIGINT_TYPE_NAME))", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMTgzOA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438301838", "bodyText": "I think getVritualColumnName should have a better method name. Here, it isn't clear what's happening because which virtual column is getting added is not obvious. If this were snapshotIdColumnName then I think it would be better.", "author": "rdblue", "createdAt": "2020-06-10T17:44:39Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSerDe.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import javax.annotation.Nullable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.serde2.AbstractSerDe;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.SerDeStats;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SnapshotsTable;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.types.Types;\n+\n+public class IcebergSerDe extends AbstractSerDe {\n+\n+  private Schema schema;\n+  private ObjectInspector inspector;\n+\n+  @Override\n+  public void initialize(@Nullable Configuration configuration, Properties serDeProperties) throws SerDeException {\n+    Table table = null;\n+    try {\n+      table = TableResolver.resolveTableFromConfiguration(configuration, serDeProperties);\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Unable to resolve table from configuration: \", e);\n+    }\n+    this.schema = table.schema();\n+    if (table instanceof SnapshotsTable) {\n+      try {\n+        this.inspector = new IcebergObjectInspectorGenerator().createObjectInspector(schema);\n+      } catch (Exception e) {\n+        throw new SerDeException(e);\n+      }\n+    } else {\n+      List<Types.NestedField> columns = new ArrayList<>(schema.columns());\n+      columns.add(Types.NestedField.optional(Integer.MAX_VALUE, SystemTableUtil.getVirtualColumnName(serDeProperties),", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNDk1MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438304950", "bodyText": "Does this need to allocate a new ArrayList every time or can it reuse one?\nWe try to make the code called for every row in a tight loop (like this method) as small as possible for performance reasons. Ideally, we would be able to reuse this storage, have the list of columns already prepared, and access field values by column position instead of by name. Something like this:\npublic Object deserialize(Writable writable) {\n  Record record = ((IcebergWritable) writable).record();\n  for (int i = 0; i < recordSize; i += 1) {\n    reusedArray[i] = record.get(i, Object.class);\n  }\n  return reusedArrayAsList;\n}", "author": "rdblue", "createdAt": "2020-06-10T17:49:55Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSerDe.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import javax.annotation.Nullable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.serde2.AbstractSerDe;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.SerDeStats;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SnapshotsTable;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.types.Types;\n+\n+public class IcebergSerDe extends AbstractSerDe {\n+\n+  private Schema schema;\n+  private ObjectInspector inspector;\n+\n+  @Override\n+  public void initialize(@Nullable Configuration configuration, Properties serDeProperties) throws SerDeException {\n+    Table table = null;\n+    try {\n+      table = TableResolver.resolveTableFromConfiguration(configuration, serDeProperties);\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Unable to resolve table from configuration: \", e);\n+    }\n+    this.schema = table.schema();\n+    if (table instanceof SnapshotsTable) {\n+      try {\n+        this.inspector = new IcebergObjectInspectorGenerator().createObjectInspector(schema);\n+      } catch (Exception e) {\n+        throw new SerDeException(e);\n+      }\n+    } else {\n+      List<Types.NestedField> columns = new ArrayList<>(schema.columns());\n+      columns.add(Types.NestedField.optional(Integer.MAX_VALUE, SystemTableUtil.getVirtualColumnName(serDeProperties),\n+              Types.LongType.get()));\n+      Schema withVirtualColumn = new Schema(columns);\n+\n+      try {\n+        this.inspector = new IcebergObjectInspectorGenerator().createObjectInspector(withVirtualColumn);\n+      } catch (Exception e) {\n+        throw new SerDeException(e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<? extends Writable> getSerializedClass() {\n+    return null;\n+  }\n+\n+  @Override\n+  public Writable serialize(Object o, ObjectInspector objectInspector) {\n+    return null;\n+  }\n+\n+  @Override\n+  public SerDeStats getSerDeStats() {\n+    return null;\n+  }\n+\n+  @Override\n+  public Object deserialize(Writable writable) {\n+    IcebergWritable icebergWritable = (IcebergWritable) writable;\n+    List<Types.NestedField> fields = icebergWritable.getSchema().columns();\n+    List<Object> row = new ArrayList<>();", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNjg2Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438306862", "bodyText": "This should assert that the types are correct, not just that there is the correct number of types.\nAlso, please use context where possible to make it clear what the assertion expects, like \"Converted TypeInfo should have the same number of columns\". That makes it easier to understand when tests start to fail.", "author": "rdblue", "createdAt": "2020-06-10T17:53:04Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/TestIcebergSchemaToTypeInfo.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.hadoop.hive.serde.serdeConstants;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestIcebergSchemaToTypeInfo {\n+\n+  @Test\n+  public void testGeneratePrimitiveTypeInfo() throws Exception {\n+    Schema schema = new Schema(\n+        required(1, \"id\", Types.IntegerType.get()),\n+        optional(2, \"data\", Types.StringType.get()),\n+        required(8, \"feature1\", Types.BooleanType.get()),\n+        required(12, \"lat\", Types.FloatType.get()),\n+        required(15, \"x\", Types.LongType.get()),\n+        required(16, \"date\", Types.DateType.get()),\n+        required(17, \"double\", Types.DoubleType.get()),\n+        required(18, \"binary\", Types.BinaryType.get()));\n+    List<TypeInfo> types = IcebergSchemaToTypeInfo.getColumnTypes(schema);\n+\n+    assertEquals(8, types.size());", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwODEwMg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438308102", "bodyText": "No need for new ArrayList<>(...) here. Arrays.asList(...) should return a list.", "author": "rdblue", "createdAt": "2020-06-10T17:55:06Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/TestIcebergSchemaToTypeInfo.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.hadoop.hive.serde.serdeConstants;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestIcebergSchemaToTypeInfo {\n+\n+  @Test\n+  public void testGeneratePrimitiveTypeInfo() throws Exception {\n+    Schema schema = new Schema(\n+        required(1, \"id\", Types.IntegerType.get()),\n+        optional(2, \"data\", Types.StringType.get()),\n+        required(8, \"feature1\", Types.BooleanType.get()),\n+        required(12, \"lat\", Types.FloatType.get()),\n+        required(15, \"x\", Types.LongType.get()),\n+        required(16, \"date\", Types.DateType.get()),\n+        required(17, \"double\", Types.DoubleType.get()),\n+        required(18, \"binary\", Types.BinaryType.get()));\n+    List<TypeInfo> types = IcebergSchemaToTypeInfo.getColumnTypes(schema);\n+\n+    assertEquals(8, types.size());\n+  }\n+\n+  @Test\n+  public void testGenerateMapTypeInfo() throws Exception {\n+    TypeInfo expected = TypeInfoFactory.getMapTypeInfo(\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME),\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME));\n+\n+    Schema schema = new Schema(\n+        optional(7, \"properties\", Types.MapType.ofOptional(18, 19,\n+            Types.StringType.get(),\n+            Types.StringType.get()\n+        ), \"string map of properties\"));\n+\n+    List<TypeInfo> types = IcebergSchemaToTypeInfo.getColumnTypes(schema);\n+\n+    assertEquals(1, types.size());\n+    assertEquals(expected, types.get(0));\n+  }\n+\n+  @Test\n+  public void testGenerateListTypeInfo() throws Exception {\n+    TypeInfo expected = TypeInfoFactory\n+        .getListTypeInfo(TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.DOUBLE_TYPE_NAME));\n+    Schema schema = new Schema(\n+        required(6, \"doubles\", Types.ListType.ofRequired(17,\n+            Types.DoubleType.get()\n+        )));\n+    List<TypeInfo> types = IcebergSchemaToTypeInfo.getColumnTypes(schema);\n+\n+    assertEquals(1, types.size());\n+    assertEquals(expected, types.get(0));\n+  }\n+\n+  @Test\n+  public void testGenerateMapAndStructTypeInfo() throws Exception {\n+    List<String> names1 = new ArrayList<>(Arrays.asList(\"address\", \"city\", \"state\", \"zip\"));\n+    List<TypeInfo> typeInfo1 = new ArrayList<>(Arrays.asList(\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME),\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME),\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME),\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.INT_TYPE_NAME)\n+    ));\n+    TypeInfo mapKeyStructExpected = TypeInfoFactory.getStructTypeInfo(names1, typeInfo1);\n+\n+    List<String> names2 = new ArrayList<>(Arrays.asList(\"lat\", \"long\"));", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwOTk4Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438309982", "bodyText": "Minor: these names could be better to make it clear what's happening. These are the types for the value struct, so you could name the variable valueTypes, and the names valueNames.", "author": "rdblue", "createdAt": "2020-06-10T17:58:06Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/TestIcebergSchemaToTypeInfo.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.hadoop.hive.serde.serdeConstants;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestIcebergSchemaToTypeInfo {\n+\n+  @Test\n+  public void testGeneratePrimitiveTypeInfo() throws Exception {\n+    Schema schema = new Schema(\n+        required(1, \"id\", Types.IntegerType.get()),\n+        optional(2, \"data\", Types.StringType.get()),\n+        required(8, \"feature1\", Types.BooleanType.get()),\n+        required(12, \"lat\", Types.FloatType.get()),\n+        required(15, \"x\", Types.LongType.get()),\n+        required(16, \"date\", Types.DateType.get()),\n+        required(17, \"double\", Types.DoubleType.get()),\n+        required(18, \"binary\", Types.BinaryType.get()));\n+    List<TypeInfo> types = IcebergSchemaToTypeInfo.getColumnTypes(schema);\n+\n+    assertEquals(8, types.size());\n+  }\n+\n+  @Test\n+  public void testGenerateMapTypeInfo() throws Exception {\n+    TypeInfo expected = TypeInfoFactory.getMapTypeInfo(\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME),\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME));\n+\n+    Schema schema = new Schema(\n+        optional(7, \"properties\", Types.MapType.ofOptional(18, 19,\n+            Types.StringType.get(),\n+            Types.StringType.get()\n+        ), \"string map of properties\"));\n+\n+    List<TypeInfo> types = IcebergSchemaToTypeInfo.getColumnTypes(schema);\n+\n+    assertEquals(1, types.size());\n+    assertEquals(expected, types.get(0));\n+  }\n+\n+  @Test\n+  public void testGenerateListTypeInfo() throws Exception {\n+    TypeInfo expected = TypeInfoFactory\n+        .getListTypeInfo(TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.DOUBLE_TYPE_NAME));\n+    Schema schema = new Schema(\n+        required(6, \"doubles\", Types.ListType.ofRequired(17,\n+            Types.DoubleType.get()\n+        )));\n+    List<TypeInfo> types = IcebergSchemaToTypeInfo.getColumnTypes(schema);\n+\n+    assertEquals(1, types.size());\n+    assertEquals(expected, types.get(0));\n+  }\n+\n+  @Test\n+  public void testGenerateMapAndStructTypeInfo() throws Exception {\n+    List<String> names1 = new ArrayList<>(Arrays.asList(\"address\", \"city\", \"state\", \"zip\"));\n+    List<TypeInfo> typeInfo1 = new ArrayList<>(Arrays.asList(\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME),\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME),\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.STRING_TYPE_NAME),\n+        TypeInfoFactory.getPrimitiveTypeInfo(serdeConstants.INT_TYPE_NAME)\n+    ));\n+    TypeInfo mapKeyStructExpected = TypeInfoFactory.getStructTypeInfo(names1, typeInfo1);\n+\n+    List<String> names2 = new ArrayList<>(Arrays.asList(\"lat\", \"long\"));\n+    List<TypeInfo> typeInfo2 = new ArrayList<>(Arrays.asList(", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMDk2MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438310960", "bodyText": "Minor: you might consider changing the signature of createCustomRecord to Schema, Object... and wrap the object array as a list internally. Then these would be shorter: createCustomRecord(schema, \"Michael\", 3000L).", "author": "rdblue", "createdAt": "2020-06-10T17:59:44Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/TestIcebergSerDe.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.hadoop.HadoopCatalog;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class TestIcebergSerDe {\n+\n+  private File tableLocation;\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @Before\n+  public void before() throws IOException {\n+    tableLocation = temp.newFolder();\n+    Schema schema = new Schema(optional(1, \"name\", Types.StringType.get()),\n+        optional(2, \"salary\", Types.LongType.get()));\n+    PartitionSpec spec = PartitionSpec.unpartitioned();\n+\n+    Configuration conf = new Configuration();\n+    HadoopCatalog catalog = new HadoopCatalog(conf, tableLocation.getAbsolutePath());\n+    TableIdentifier id = TableIdentifier.parse(\"source_db.table_a\");\n+    Table table = catalog.createTable(id, schema, spec);\n+\n+    List<Record> data = new ArrayList<>();\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Michael\", 3000L)));", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMTY2MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438311660", "bodyText": "Does Hive support non-string map keys? It looks like all of the test cases are string maps.", "author": "rdblue", "createdAt": "2020-06-10T18:00:53Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/TestIcebergSerDe.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.hadoop.HadoopCatalog;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class TestIcebergSerDe {\n+\n+  private File tableLocation;\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @Before\n+  public void before() throws IOException {\n+    tableLocation = temp.newFolder();\n+    Schema schema = new Schema(optional(1, \"name\", Types.StringType.get()),\n+        optional(2, \"salary\", Types.LongType.get()));\n+    PartitionSpec spec = PartitionSpec.unpartitioned();\n+\n+    Configuration conf = new Configuration();\n+    HadoopCatalog catalog = new HadoopCatalog(conf, tableLocation.getAbsolutePath());\n+    TableIdentifier id = TableIdentifier.parse(\"source_db.table_a\");\n+    Table table = catalog.createTable(id, schema, spec);\n+\n+    List<Record> data = new ArrayList<>();\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Michael\", 3000L)));\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Andy\", 3000L)));\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Berta\", 4000L)));\n+\n+    DataFile fileA = TestHelpers.writeFile(temp.newFile(), table, null, FileFormat.PARQUET, data);\n+\n+    table.newAppend().appendFile(fileA).commit();\n+  }\n+\n+  @Test\n+  public void testDeserializeMap() {\n+    Schema schema = new Schema(required(1, \"map_type\", Types.MapType\n+        .ofRequired(18, 19, Types.StringType.get(), Types.StringType.get())));", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyODU5Mw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438728593", "bodyText": "Yeah, it supports all primitive types as keys I believe - I've added an extra test case using an Integer key type, but should I add a larger range of tests like this one?", "author": "cmathiesen", "createdAt": "2020-06-11T11:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMTY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3Mzc5Nw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439073797", "bodyText": "No, one non-string test case is good.", "author": "rdblue", "createdAt": "2020-06-11T21:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMTY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMjUzOQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438312539", "bodyText": "I think the assertEquals is sufficient since it checks deep equality.", "author": "rdblue", "createdAt": "2020-06-10T18:02:29Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/TestIcebergSerDe.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.hadoop.HadoopCatalog;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class TestIcebergSerDe {\n+\n+  private File tableLocation;\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @Before\n+  public void before() throws IOException {\n+    tableLocation = temp.newFolder();\n+    Schema schema = new Schema(optional(1, \"name\", Types.StringType.get()),\n+        optional(2, \"salary\", Types.LongType.get()));\n+    PartitionSpec spec = PartitionSpec.unpartitioned();\n+\n+    Configuration conf = new Configuration();\n+    HadoopCatalog catalog = new HadoopCatalog(conf, tableLocation.getAbsolutePath());\n+    TableIdentifier id = TableIdentifier.parse(\"source_db.table_a\");\n+    Table table = catalog.createTable(id, schema, spec);\n+\n+    List<Record> data = new ArrayList<>();\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Michael\", 3000L)));\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Andy\", 3000L)));\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Berta\", 4000L)));\n+\n+    DataFile fileA = TestHelpers.writeFile(temp.newFile(), table, null, FileFormat.PARQUET, data);\n+\n+    table.newAppend().appendFile(fileA).commit();\n+  }\n+\n+  @Test\n+  public void testDeserializeMap() {\n+    Schema schema = new Schema(required(1, \"map_type\", Types.MapType\n+        .ofRequired(18, 19, Types.StringType.get(), Types.StringType.get())));\n+    Map<String, String> expected = ImmutableMap.of(\"foo\", \"bar\");\n+    List<Map> data = new ArrayList<>();\n+    data.add(expected);\n+\n+    Record record = TestHelpers.createCustomRecord(schema, data);\n+    IcebergWritable writable = new IcebergWritable();\n+    writable.setRecord(record);\n+    writable.setSchema(schema);\n+\n+    IcebergSerDe serDe = new IcebergSerDe();\n+    List<Object> deserialized = (List<Object>) serDe.deserialize(writable);\n+    Map result = (Map) deserialized.get(0);\n+\n+    assertEquals(expected, result);\n+    assertTrue(result.containsKey(\"foo\"));\n+    assertTrue(result.containsValue(\"bar\"));", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMjYzOQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438312639", "bodyText": "Should this use the object inspectors?", "author": "rdblue", "createdAt": "2020-06-10T18:02:39Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/TestIcebergSerDe.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.hadoop.HadoopCatalog;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class TestIcebergSerDe {\n+\n+  private File tableLocation;\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @Before\n+  public void before() throws IOException {\n+    tableLocation = temp.newFolder();\n+    Schema schema = new Schema(optional(1, \"name\", Types.StringType.get()),\n+        optional(2, \"salary\", Types.LongType.get()));\n+    PartitionSpec spec = PartitionSpec.unpartitioned();\n+\n+    Configuration conf = new Configuration();\n+    HadoopCatalog catalog = new HadoopCatalog(conf, tableLocation.getAbsolutePath());\n+    TableIdentifier id = TableIdentifier.parse(\"source_db.table_a\");\n+    Table table = catalog.createTable(id, schema, spec);\n+\n+    List<Record> data = new ArrayList<>();\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Michael\", 3000L)));\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Andy\", 3000L)));\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Berta\", 4000L)));\n+\n+    DataFile fileA = TestHelpers.writeFile(temp.newFile(), table, null, FileFormat.PARQUET, data);\n+\n+    table.newAppend().appendFile(fileA).commit();\n+  }\n+\n+  @Test\n+  public void testDeserializeMap() {\n+    Schema schema = new Schema(required(1, \"map_type\", Types.MapType\n+        .ofRequired(18, 19, Types.StringType.get(), Types.StringType.get())));\n+    Map<String, String> expected = ImmutableMap.of(\"foo\", \"bar\");\n+    List<Map> data = new ArrayList<>();\n+    data.add(expected);\n+\n+    Record record = TestHelpers.createCustomRecord(schema, data);\n+    IcebergWritable writable = new IcebergWritable();\n+    writable.setRecord(record);\n+    writable.setSchema(schema);\n+\n+    IcebergSerDe serDe = new IcebergSerDe();\n+    List<Object> deserialized = (List<Object>) serDe.deserialize(writable);\n+    Map result = (Map) deserialized.get(0);", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMzExMg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438313112", "bodyText": "I'm not sure so many test cases are necessary since this is really just testing that a record is converted to a collection with the same field order. That's all deserialize is doing.", "author": "rdblue", "createdAt": "2020-06-10T18:03:28Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/TestIcebergSerDe.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.hadoop.HadoopCatalog;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class TestIcebergSerDe {\n+\n+  private File tableLocation;\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @Before\n+  public void before() throws IOException {\n+    tableLocation = temp.newFolder();\n+    Schema schema = new Schema(optional(1, \"name\", Types.StringType.get()),\n+        optional(2, \"salary\", Types.LongType.get()));\n+    PartitionSpec spec = PartitionSpec.unpartitioned();\n+\n+    Configuration conf = new Configuration();\n+    HadoopCatalog catalog = new HadoopCatalog(conf, tableLocation.getAbsolutePath());\n+    TableIdentifier id = TableIdentifier.parse(\"source_db.table_a\");\n+    Table table = catalog.createTable(id, schema, spec);\n+\n+    List<Record> data = new ArrayList<>();\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Michael\", 3000L)));\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Andy\", 3000L)));\n+    data.add(TestHelpers.createCustomRecord(schema, Arrays.asList(\"Berta\", 4000L)));\n+\n+    DataFile fileA = TestHelpers.writeFile(temp.newFile(), table, null, FileFormat.PARQUET, data);\n+\n+    table.newAppend().appendFile(fileA).commit();\n+  }\n+\n+  @Test\n+  public void testDeserializeMap() {\n+    Schema schema = new Schema(required(1, \"map_type\", Types.MapType\n+        .ofRequired(18, 19, Types.StringType.get(), Types.StringType.get())));\n+    Map<String, String> expected = ImmutableMap.of(\"foo\", \"bar\");\n+    List<Map> data = new ArrayList<>();\n+    data.add(expected);\n+\n+    Record record = TestHelpers.createCustomRecord(schema, data);\n+    IcebergWritable writable = new IcebergWritable();\n+    writable.setRecord(record);\n+    writable.setSchema(schema);\n+\n+    IcebergSerDe serDe = new IcebergSerDe();\n+    List<Object> deserialized = (List<Object>) serDe.deserialize(writable);\n+    Map result = (Map) deserialized.get(0);\n+\n+    assertEquals(expected, result);\n+    assertTrue(result.containsKey(\"foo\"));\n+    assertTrue(result.containsValue(\"bar\"));\n+  }\n+\n+  @Test\n+  public void testDeserializeList() {", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MzQ3Mw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439073473", "bodyText": "And if we take the advice from @guilload and just return the record, then we don't need to test at all! We could convert the whole suite to testing the object inspectors against Iceberg generics.", "author": "rdblue", "createdAt": "2020-06-11T21:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMzExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMzk3OA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438313978", "bodyText": "Does Hive use LocalDate as its internal representation for date? That's what Iceberg generics are going to return. I think the object inspector needs to convert that correctly to the representation that Hive expects.", "author": "rdblue", "createdAt": "2020-06-10T18:05:03Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergObjectInspectorGenerator.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.ListTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.MapTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.StructTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.types.Types;\n+\n+class IcebergObjectInspectorGenerator {\n+\n+  protected ObjectInspector createObjectInspector(Schema schema) throws Exception {\n+    List<String> columnNames = setColumnNames(schema);\n+    List<TypeInfo> columnTypes = IcebergSchemaToTypeInfo.getColumnTypes(schema);\n+\n+    List<ObjectInspector> columnOIs = new ArrayList<>(columnTypes.size());\n+    for (int i = 0; i < columnTypes.size(); i++) {\n+      columnOIs.add(createObjectInspectorWorker(columnTypes.get(i)));\n+    }\n+    return ObjectInspectorFactory.getStandardStructObjectInspector(columnNames, columnOIs, null);\n+  }\n+\n+  protected ObjectInspector createObjectInspectorWorker(TypeInfo typeInfo) throws Exception {\n+    ObjectInspector.Category typeCategory = typeInfo.getCategory();\n+\n+    switch (typeCategory) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pti = (PrimitiveTypeInfo) typeInfo;\n+        return PrimitiveObjectInspectorFactory.getPrimitiveJavaObjectInspector(pti);", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg5NTY3Mw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438895673", "bodyText": "Hive uses java.sql.Date and java.sql.Timestamp so I've been working on doing some converting between types to stop Hive complaining :')", "author": "cmathiesen", "createdAt": "2020-06-11T15:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMzk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MzI2OQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439073269", "bodyText": "It sounds like @guilload can help out with some of the object inspector questions.", "author": "rdblue", "createdAt": "2020-06-11T21:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMzk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE5MDA1NA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439190054", "bodyText": "Maybe this can be a visitor?  We recently built a visitor the other way round Hive -> Iceberg. https://github.com/linkedin/iceberg/blob/master/hive/src/main/java/org/apache/iceberg/hive/legacy/HiveTypeToIcebergType.java", "author": "rdsr", "createdAt": "2020-06-12T03:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMzk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNDM5MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438314390", "bodyText": "Does this need to be removed from the InputFormat class?", "author": "rdblue", "createdAt": "2020-06-10T18:05:46Z", "path": "mr/src/main/java/org/apache/iceberg/mr/InputFormatConfig.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr;\n+\n+import java.util.function.Function;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.catalog.Catalog;\n+import org.apache.iceberg.expressions.Expression;\n+\n+public class InputFormatConfig {", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1OTYwNA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438659604", "bodyText": "This is from #933, specifically at https://github.com/apache/iceberg/pull/933/files#diff-0aa47c0ca21b715226d83ae55f4b4671 so we just pulled that class in here \"as is\" as it was easier. If you'd prefer we can trim this down to just the config needed by the SerDe or we can (temporarily) put the code elsewhere in this PR and then refactor it back into this class when we come back to#933 after this is merged.", "author": "massdosage", "createdAt": "2020-06-11T09:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNDM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3Mjg1Nw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439072857", "bodyText": "I think it's safer to either reference it in place or to move it in this commit. Otherwise, changes to the other class may not show up as git commit conflicts and we could accidentally lose them by adding the class in one commit and removing the other copy later.", "author": "rdblue", "createdAt": "2020-06-11T21:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNDM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2MzgyNQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439463825", "bodyText": "I don't think I understand what you want us to do here. We need it here for this to compile and get merged in separately from #933. We basically cut and paste the class out of the other branch to here. We'll happily resolve any conflicts etc. in #933 later if needed.", "author": "massdosage", "createdAt": "2020-06-12T14:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNDM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNzI1MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439507250", "bodyText": "If we are moving code into its own top-level class, then we need to delete the code that is moving from its original location so we don't drop changes that are introduced in the mean time.", "author": "rdblue", "createdAt": "2020-06-12T16:02:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNDM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE0NTQyMg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r440145422", "bodyText": "Ah, OK, now I see what you mean, yes, that makes sense. I've done that now", "author": "massdosage", "createdAt": "2020-06-15T12:38:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNDM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzAwMA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438317000", "bodyText": "Why does this coerce to a URI and get the path? The full path should be used so I don't see a reason to modify it.", "author": "rdblue", "createdAt": "2020-06-10T18:10:22Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/TableResolver.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Properties;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.hadoop.HadoopCatalog;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+\n+final class TableResolver {\n+\n+  private TableResolver() {\n+  }\n+\n+  static Table resolveTableFromJob(JobConf conf) throws IOException {\n+    Properties properties = new Properties();\n+    properties.setProperty(InputFormatConfig.CATALOG_NAME, extractProperty(conf, InputFormatConfig.CATALOG_NAME));\n+    if (conf.get(InputFormatConfig.CATALOG_NAME).equals(InputFormatConfig.HADOOP_CATALOG)) {\n+      properties.setProperty(InputFormatConfig.SNAPSHOT_TABLE, conf.get(InputFormatConfig.SNAPSHOT_TABLE, \"true\"));\n+    }\n+    properties.setProperty(InputFormatConfig.TABLE_LOCATION, extractProperty(conf, InputFormatConfig.TABLE_LOCATION));\n+    properties.setProperty(InputFormatConfig.TABLE_NAME, extractProperty(conf, InputFormatConfig.TABLE_NAME));\n+    return resolveTableFromConfiguration(conf, properties);\n+  }\n+\n+  static Table resolveTableFromConfiguration(Configuration conf, Properties properties) throws IOException {\n+    String catalogName = properties.getProperty(InputFormatConfig.CATALOG_NAME);\n+    URI tableLocation = pathAsURI(properties.getProperty(InputFormatConfig.TABLE_LOCATION));", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzc3MQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438317771", "bodyText": "I think the warehouse path should be passed separately, possibly as table properties but maybe just defaulting to the Hive warehouse path. It doesn't make sense to me to pass a full URI and then use HadoopCatalog instead of HadoopTables, which handles tables at a specific path. There is no benefit to HadoopCatalog if you have the full table location.", "author": "rdblue", "createdAt": "2020-06-10T18:11:44Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/TableResolver.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Properties;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.hadoop.HadoopCatalog;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+\n+final class TableResolver {\n+\n+  private TableResolver() {\n+  }\n+\n+  static Table resolveTableFromJob(JobConf conf) throws IOException {\n+    Properties properties = new Properties();\n+    properties.setProperty(InputFormatConfig.CATALOG_NAME, extractProperty(conf, InputFormatConfig.CATALOG_NAME));\n+    if (conf.get(InputFormatConfig.CATALOG_NAME).equals(InputFormatConfig.HADOOP_CATALOG)) {\n+      properties.setProperty(InputFormatConfig.SNAPSHOT_TABLE, conf.get(InputFormatConfig.SNAPSHOT_TABLE, \"true\"));\n+    }\n+    properties.setProperty(InputFormatConfig.TABLE_LOCATION, extractProperty(conf, InputFormatConfig.TABLE_LOCATION));\n+    properties.setProperty(InputFormatConfig.TABLE_NAME, extractProperty(conf, InputFormatConfig.TABLE_NAME));\n+    return resolveTableFromConfiguration(conf, properties);\n+  }\n+\n+  static Table resolveTableFromConfiguration(Configuration conf, Properties properties) throws IOException {\n+    String catalogName = properties.getProperty(InputFormatConfig.CATALOG_NAME);\n+    URI tableLocation = pathAsURI(properties.getProperty(InputFormatConfig.TABLE_LOCATION));\n+    if (catalogName == null) {\n+      throw new IllegalArgumentException(\"Catalog property: 'iceberg.catalog' not set in JobConf\");\n+    }\n+    switch (catalogName) {\n+      case InputFormatConfig.HADOOP_TABLES:\n+        HadoopTables tables = new HadoopTables(conf);\n+        return tables.load(tableLocation.getPath());\n+      case InputFormatConfig.HADOOP_CATALOG:\n+        String tableName = properties.getProperty(InputFormatConfig.TABLE_NAME);\n+        TableIdentifier id = TableIdentifier.parse(tableName);\n+        if (tableName.endsWith(InputFormatConfig.SNAPSHOT_TABLE_SUFFIX)) {\n+          if (!Boolean.parseBoolean(properties.getProperty(InputFormatConfig.SNAPSHOT_TABLE,\n+                  Boolean.TRUE.toString()))) {\n+            String tablePath = id.toString().replaceAll(\"\\\\.\", \"/\");\n+            URI warehouseLocation = pathAsURI(tableLocation.getPath().replaceAll(tablePath, \"\"));\n+            HadoopCatalog catalog = new HadoopCatalog(conf, warehouseLocation.getPath());\n+            return catalog.loadTable(id);\n+          } else {\n+            return resolveMetadataTable(conf, tableLocation.getPath(), tableName);\n+          }\n+        } else {\n+          URI warehouseLocation = pathAsURI(extractWarehousePath(tableLocation.getPath(), tableName));", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NjUxOA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438776518", "bodyText": "We had initially implemented the IF using a method similar to what you're describing: we required a user to add an extra table property called iceberg.warehouse.location I think and used that to resolve the table with HadoopCatalog. The LOCATION property of your Hive table has to be unique for each table (which is why we always have a property for a full table path), so we couldn't put a path to a common warehouse there. We initially tried using the same location for multiple tables and relied on the table name/ID to resolve the table correctly in Iceberg but that caused major confusion in Hive when trying to join tables :')\nSo originally we used an extra property for the warehouse location, but we realised we could extract this location from the full table path and save the user an extra configuration property. We don't have any strong preference either way, so I'm happy to change this as you've suggested\nAlthough thinking about this raises another point - I've just realised/tested that you could create an Iceberg table using HadoopCatalog but if you had the full path you can use HadoopTables to load the table again instead... And with Hive we can always expect to have the full path to the table because the location needs to be unique, so we could simplify here and only use HadoopTables for this IF? @massdosage", "author": "cmathiesen", "createdAt": "2020-06-11T13:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNzcyMg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438837722", "bodyText": "IIRC when the InputFormat \"runs\" there is always a value in the associated HiveConf named \"location\" (InputFormatConfig.TABLE_LOCATION above) which points to the \"base\" location of the table being queried. So I think we should be able to just use that and require that the location is set correctly when the Hive table is created which is the normal way of doing things for external tables. Then we can just use that here and not worry about additional table properties or the other code paths which hopefully simplifies things.", "author": "massdosage", "createdAt": "2020-06-11T14:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MjI5Nw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439072297", "bodyText": "I've just realised/tested that you could create an Iceberg table using HadoopCatalog but if you had the full path you can use HadoopTables to load the table again instead...\n\nYes, this is why I said there is no benefit to using HadoopCatalog. If you already have the full path, you can open the table with HadoopTables and not worry about the warehouse path to pass to the catalog.\nThe only drawback is that this approach doesn't work for Hive tables. You'd need to know whether the table is a Hive table or a Hadoop table because they use different commit mechanisms.\nFor tables tracked by the iceberg-hive connector, you'd just need to instantiate the HiveCatalog and use the table name to load the table.", "author": "rdblue", "createdAt": "2020-06-11T21:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMxMjQyNg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439312426", "bodyText": "OK, may I suggest we just focus on supporting HadoopTables using the location for now and then add support for HiveCatalog in a future PR after this is merged? Just to keep the scope of this PR down etc.", "author": "massdosage", "createdAt": "2020-06-12T09:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwODA3Nw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439508077", "bodyText": "Yeah, that sounds good.", "author": "rdblue", "createdAt": "2020-06-12T16:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxODA2OQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438318069", "bodyText": "How are the db and table name passed?", "author": "rdblue", "createdAt": "2020-06-10T18:12:13Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/TableResolver.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Properties;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.hadoop.HadoopCatalog;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+\n+final class TableResolver {\n+\n+  private TableResolver() {\n+  }\n+\n+  static Table resolveTableFromJob(JobConf conf) throws IOException {\n+    Properties properties = new Properties();\n+    properties.setProperty(InputFormatConfig.CATALOG_NAME, extractProperty(conf, InputFormatConfig.CATALOG_NAME));\n+    if (conf.get(InputFormatConfig.CATALOG_NAME).equals(InputFormatConfig.HADOOP_CATALOG)) {\n+      properties.setProperty(InputFormatConfig.SNAPSHOT_TABLE, conf.get(InputFormatConfig.SNAPSHOT_TABLE, \"true\"));\n+    }\n+    properties.setProperty(InputFormatConfig.TABLE_LOCATION, extractProperty(conf, InputFormatConfig.TABLE_LOCATION));\n+    properties.setProperty(InputFormatConfig.TABLE_NAME, extractProperty(conf, InputFormatConfig.TABLE_NAME));\n+    return resolveTableFromConfiguration(conf, properties);\n+  }\n+\n+  static Table resolveTableFromConfiguration(Configuration conf, Properties properties) throws IOException {\n+    String catalogName = properties.getProperty(InputFormatConfig.CATALOG_NAME);\n+    URI tableLocation = pathAsURI(properties.getProperty(InputFormatConfig.TABLE_LOCATION));\n+    if (catalogName == null) {\n+      throw new IllegalArgumentException(\"Catalog property: 'iceberg.catalog' not set in JobConf\");\n+    }\n+    switch (catalogName) {\n+      case InputFormatConfig.HADOOP_TABLES:\n+        HadoopTables tables = new HadoopTables(conf);\n+        return tables.load(tableLocation.getPath());\n+      case InputFormatConfig.HADOOP_CATALOG:\n+        String tableName = properties.getProperty(InputFormatConfig.TABLE_NAME);\n+        TableIdentifier id = TableIdentifier.parse(tableName);\n+        if (tableName.endsWith(InputFormatConfig.SNAPSHOT_TABLE_SUFFIX)) {\n+          if (!Boolean.parseBoolean(properties.getProperty(InputFormatConfig.SNAPSHOT_TABLE,\n+                  Boolean.TRUE.toString()))) {\n+            String tablePath = id.toString().replaceAll(\"\\\\.\", \"/\");\n+            URI warehouseLocation = pathAsURI(tableLocation.getPath().replaceAll(tablePath, \"\"));\n+            HadoopCatalog catalog = new HadoopCatalog(conf, warehouseLocation.getPath());\n+            return catalog.loadTable(id);\n+          } else {\n+            return resolveMetadataTable(conf, tableLocation.getPath(), tableName);\n+          }\n+        } else {\n+          URI warehouseLocation = pathAsURI(extractWarehousePath(tableLocation.getPath(), tableName));\n+          HadoopCatalog catalog = new HadoopCatalog(conf, warehouseLocation.getPath());\n+          return catalog.loadTable(id);\n+        }\n+      case InputFormatConfig.HIVE_CATALOG:\n+        //TODO Implement HiveCatalog", "originalCommit": "c0cec1786f33ae4dafe46e0aa8be61e5acebea4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3Nzc0MQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r438777741", "bodyText": "Hive adds a property to the conf called name which is whatever you've defined in the CREATE TABLE name part, so that property will include db and table name", "author": "cmathiesen", "createdAt": "2020-06-11T13:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxODA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0NTc1Mw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r447345753", "bodyText": "Should this throw an exception instead of returning null?", "author": "rdblue", "createdAt": "2020-06-30T01:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxODA2OQ=="}], "type": "inlineReview"}, {"oid": "e4ccfd7b996c68fb4ad82d7351c244baa43b4856", "url": "https://github.com/apache/iceberg/commit/e4ccfd7b996c68fb4ad82d7351c244baa43b4856", "message": "Fix date/time types, address format comments", "committedDate": "2020-06-11T16:52:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjU3NA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439002574", "bodyText": "There's actually no need to return anything other the Record object. Hive relies on the ObjectInspector class to retrieve values from arbitrary data structures and convert those values to the classes Hive expects.\nYou may want to take a look at https://cwiki.apache.org/confluence/display/Hive/DeveloperGuide#DeveloperGuide-ObjectInspector and then read the implementation of a few object inspectors in the Hive codebase.\nSo all we have to do here is return the Record object and ensure we have the right object inspectors for the Record class and other data types that are not represented in the same fashion in Iceberg vs. Hive.\nAs a matter of fact, I started working on an object inspector for the Record class last year. Why don't I submit a PR on top off this one to get you started?", "author": "guilload", "createdAt": "2020-06-11T18:55:03Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSerDe.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import javax.annotation.Nullable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.serde2.AbstractSerDe;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.SerDeStats;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SnapshotsTable;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+public class IcebergSerDe extends AbstractSerDe {\n+\n+  private Schema schema;\n+  private ObjectInspector inspector;\n+  private List<Object> row;\n+\n+  @Override\n+  public void initialize(@Nullable Configuration configuration, Properties serDeProperties) throws SerDeException {\n+    Table table = null;\n+    try {\n+      table = TableResolver.resolveTableFromConfiguration(configuration, serDeProperties);\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Unable to resolve table from configuration: \", e);\n+    }\n+    this.schema = table.schema();\n+    if (table instanceof SnapshotsTable) {\n+      try {\n+        this.inspector = new IcebergObjectInspectorGenerator().createObjectInspector(schema);\n+      } catch (Exception e) {\n+        throw new SerDeException(e);\n+      }\n+    } else {\n+      List<Types.NestedField> columns = new ArrayList<>(schema.columns());\n+      columns.add(Types.NestedField.optional(Integer.MAX_VALUE,\n+          SystemTableUtil.snapshotIdVirtualColumnName(serDeProperties), Types.LongType.get()));\n+      Schema withVirtualColumn = new Schema(columns);\n+      try {\n+        this.inspector = new IcebergObjectInspectorGenerator().createObjectInspector(withVirtualColumn);\n+      } catch (Exception e) {\n+        throw new SerDeException(e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<? extends Writable> getSerializedClass() {\n+    return null;\n+  }\n+\n+  @Override\n+  public Writable serialize(Object o, ObjectInspector objectInspector) {\n+    return null;\n+  }\n+\n+  @Override\n+  public SerDeStats getSerDeStats() {\n+    return null;\n+  }\n+\n+  @Override\n+  public Object deserialize(Writable writable) {", "originalCommit": "e4ccfd7b996c68fb4ad82d7351c244baa43b4856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDIzMA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439080230", "bodyText": "Instead of using ObjectInspectors, do you think it's worth building a ReaderFunc which returns Hive compatible objects instead? We can save one conversion that way. e.g Avro objects -> Hive objects, instead of Avro objects -> Iceberg Generic objects -> Hive objects. The downside is we will have to build a Hive-compatible ReaderFunc for each file format but I don't expect it to be too hard.", "author": "shardulm94", "createdAt": "2020-06-11T21:28:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE5MTI4NQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439191285", "bodyText": "+1. We should build this similar to reader Funcs. Please see examples of this in Spark module org.apache.iceberg.spark.data.SparkValueReaders [for Avro] and org.apache.iceberg.spark.data.SparkOrcValueReaders", "author": "rdsr", "createdAt": "2020-06-12T03:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NzIyOQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439467229", "bodyText": "\"There's actually no need to return anything other the Record object.\"\n@guilload are you sure about this? Ultimately this all ends up being used by the old Map Reduce V1 API where serialization required the usage of Writables. Have you managed to get an InputFormat working end to end in an actual Hive 2.3.x client with a type that isn't a Writable? I see that the InputFormats etc. for Delta and Hudi both seem to use ArrayWritableand have Writables scattered over the code which I'm assuming is for this reason. I'd be happy to remove the Writable I'm just not sure it would actually work when run on a cluster.", "author": "massdosage", "createdAt": "2020-06-12T14:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwOTE4Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439509182", "bodyText": "Ultimately this all ends up being used by the old Map Reduce V1 API where serialization required the usage of Writables\n\nI think the suggestion was to return Record from deserialize, not to use a non-writable. After deserialize, I don't think there is a requirement for anything to be a Writable.", "author": "rdblue", "createdAt": "2020-06-12T16:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMDA3NA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439510074", "bodyText": "Instead of using ObjectInspectors, do you think it's worth building a ReaderFunc which returns Hive compatible objects instead?\n\nThis seems like a larger effort that is probably something for a follow-up instead. It seems much easier to me to add a small translation layer just for the types that need it and use the current Iceberg generics, rather than building a new object model for data formats.", "author": "rdblue", "createdAt": "2020-06-12T16:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxNzA0Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439517042", "bodyText": "Ultimately this all ends up being used by the old Map Reduce V1 API where serialization required the usage of Writables\n\nI think the suggestion was to return Record from deserialize, not to use a non-writable. After deserialize, I don't think there is a requirement for anything to be a Writable.\n\nWe can certainly try, we should probably do it in Hiveberg first as we can then run a full HiveRunner test over it to make sure there aren't any surprises in the internals of Hive or MR.", "author": "massdosage", "createdAt": "2020-06-12T16:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0NjE1Nw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439646157", "bodyText": "Ultimately this all ends up being used by the old Map Reduce V1 API where serialization required the usage of Writables\n\nI think the suggestion was to return Record from deserialize, not to use a non-writable. After deserialize, I don't think there is a requirement for anything to be a Writable.\n\nExactly. Until getting to deserialize the object has to be a Writable but after that point, it can be anything really, as long as the right object inspector is provided. I have already successfully tested this approach on local branch where I built a simple Hive input format on top of #1104 and implemented my own SerDe with this object inspector.", "author": "guilload", "createdAt": "2020-06-12T21:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1NTU0MQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r440055541", "bodyText": "OK, sounds good, do you want to make this change as part of what you mention above with the Object Inspectors or later?", "author": "massdosage", "createdAt": "2020-06-15T09:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2NTMyOQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r446165329", "bodyText": "Above changes have now been merged into this PR.", "author": "massdosage", "createdAt": "2020-06-26T12:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMzk0OA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439003948", "bodyText": "See this is where object inspectors come in handy, they'll take care of the conversion for us. Plus, you can clearly see that this current approach won't work for nested data structures.", "author": "guilload", "createdAt": "2020-06-11T18:57:37Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSerDe.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import javax.annotation.Nullable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.serde2.AbstractSerDe;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.SerDeStats;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SnapshotsTable;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+public class IcebergSerDe extends AbstractSerDe {\n+\n+  private Schema schema;\n+  private ObjectInspector inspector;\n+  private List<Object> row;\n+\n+  @Override\n+  public void initialize(@Nullable Configuration configuration, Properties serDeProperties) throws SerDeException {\n+    Table table = null;\n+    try {\n+      table = TableResolver.resolveTableFromConfiguration(configuration, serDeProperties);\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Unable to resolve table from configuration: \", e);\n+    }\n+    this.schema = table.schema();\n+    if (table instanceof SnapshotsTable) {\n+      try {\n+        this.inspector = new IcebergObjectInspectorGenerator().createObjectInspector(schema);\n+      } catch (Exception e) {\n+        throw new SerDeException(e);\n+      }\n+    } else {\n+      List<Types.NestedField> columns = new ArrayList<>(schema.columns());\n+      columns.add(Types.NestedField.optional(Integer.MAX_VALUE,\n+          SystemTableUtil.snapshotIdVirtualColumnName(serDeProperties), Types.LongType.get()));\n+      Schema withVirtualColumn = new Schema(columns);\n+      try {\n+        this.inspector = new IcebergObjectInspectorGenerator().createObjectInspector(withVirtualColumn);\n+      } catch (Exception e) {\n+        throw new SerDeException(e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<? extends Writable> getSerializedClass() {\n+    return null;\n+  }\n+\n+  @Override\n+  public Writable serialize(Object o, ObjectInspector objectInspector) {\n+    return null;\n+  }\n+\n+  @Override\n+  public SerDeStats getSerDeStats() {\n+    return null;\n+  }\n+\n+  @Override\n+  public Object deserialize(Writable writable) {\n+    IcebergWritable icebergWritable = (IcebergWritable) writable;\n+    List<Types.NestedField> fields = icebergWritable.schema().columns();\n+\n+    if (row == null || row.size() != fields.size()) {\n+      row = new ArrayList<Object>(fields.size());\n+    } else {\n+      row.clear();\n+    }\n+    for (int i = 0; i < fields.size(); i++) {\n+      Object obj = ((IcebergWritable) writable).record().get(i);\n+      Type fieldType = fields.get(i).type();\n+      if (fieldType.equals(Types.DateType.get())) {\n+        row.add(Date.valueOf((LocalDate) obj));", "originalCommit": "e4ccfd7b996c68fb4ad82d7351c244baa43b4856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE5MDc3OA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439190778", "bodyText": "throw Unsupported?", "author": "rdsr", "createdAt": "2020-06-12T03:43:47Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSerDe.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import javax.annotation.Nullable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.serde2.AbstractSerDe;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.SerDeStats;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SnapshotsTable;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+public class IcebergSerDe extends AbstractSerDe {\n+\n+  private Schema schema;\n+  private ObjectInspector inspector;\n+  private List<Object> row;\n+\n+  @Override\n+  public void initialize(@Nullable Configuration configuration, Properties serDeProperties) throws SerDeException {\n+    Table table = null;\n+    try {\n+      table = TableResolver.resolveTableFromConfiguration(configuration, serDeProperties);\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Unable to resolve table from configuration: \", e);\n+    }\n+    this.schema = table.schema();\n+    if (table instanceof SnapshotsTable) {\n+      try {\n+        this.inspector = new IcebergObjectInspectorGenerator().createObjectInspector(schema);\n+      } catch (Exception e) {\n+        throw new SerDeException(e);\n+      }\n+    } else {\n+      List<Types.NestedField> columns = new ArrayList<>(schema.columns());\n+      columns.add(Types.NestedField.optional(Integer.MAX_VALUE,\n+          SystemTableUtil.snapshotIdVirtualColumnName(serDeProperties), Types.LongType.get()));\n+      Schema withVirtualColumn = new Schema(columns);\n+      try {\n+        this.inspector = new IcebergObjectInspectorGenerator().createObjectInspector(withVirtualColumn);\n+      } catch (Exception e) {\n+        throw new SerDeException(e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<? extends Writable> getSerializedClass() {\n+    return null;\n+  }\n+\n+  @Override\n+  public Writable serialize(Object o, ObjectInspector objectInspector) {\n+    return null;", "originalCommit": "e4ccfd7b996c68fb4ad82d7351c244baa43b4856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE5MjQ3Nw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439192477", "bodyText": "@cmathiesen @rdblue . Do u folks see value in having Hive classes in a separate hive  module instead of MR?  Similar to Iceberg Pig ? I think we need to provide a reader func implementation for Hive to be used with the MR module", "author": "rdsr", "createdAt": "2020-06-12T03:51:22Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSerDe.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.sql.Date;\n+import java.sql.Timestamp;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import javax.annotation.Nullable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.serde2.AbstractSerDe;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.SerDeStats;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SnapshotsTable;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+public class IcebergSerDe extends AbstractSerDe {", "originalCommit": "e4ccfd7b996c68fb4ad82d7351c244baa43b4856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NDkxMw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439464913", "bodyText": "We discussed this with @rdblue and he didn't want to introduce another sub-package at this stage so we agreed to keep it all here. I don't mind either way to be honest.", "author": "massdosage", "createdAt": "2020-06-12T14:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE5MjQ3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMTIyNQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439511225", "bodyText": "As long as the Hive dependencies are provided/compileOnly and we can still use the MR models, I don't see much harm in keeping them in one module.", "author": "rdblue", "createdAt": "2020-06-12T16:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE5MjQ3Nw=="}], "type": "inlineReview"}, {"oid": "eecb8336d66c3922e2b37552be35418abce5dd0b", "url": "https://github.com/apache/iceberg/commit/eecb8336d66c3922e2b37552be35418abce5dd0b", "message": "Remove HadoopCatalog, clean up SerDe and tests", "committedDate": "2020-06-12T13:47:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1ODA2NQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r439658065", "bodyText": "According to https://github.com/ExpediaGroup/hiveberg/blob/master/README.md#time-travel-and-system-tables it seems like to access a snapshot metadata table, we need to create a new table which ends in __snapshots. Instead of that, can we rather let the user create a table with any name but put the metadata table name as part of the location instead.\nCREATE TABLE source_db.table_a_snapshot_metadata_table\n  STORED BY 'com.expediagroup.hiveberg.IcebergStorageHandler'\n  LOCATION 'path_to_original_data_table#snapshots'\n    TBLPROPERTIES ('iceberg.catalog'='hadoop.catalog')\n\nThat way,\n\nYou don't need to reserve a table suffix\nYou don't need flags like iceberg.snapshots.table=false\nTableResolver code is also simplified as it does not need to understand the syntax for metadata tables in different catalogs. e.g. HadoopTables uses #snapshots, HiveCatalog uses .snapshots. It simply has to pass the location as-is to the catalog.\nIt will also be able to handle other metadata tables, like partitions, manifest, entries, etc. without any additional handling.", "author": "shardulm94", "createdAt": "2020-06-12T21:56:16Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/TableResolver.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.util.Properties;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+final class TableResolver {\n+\n+  private TableResolver() {\n+  }\n+\n+  static Table resolveTableFromJob(JobConf conf) throws IOException {\n+    Properties properties = new Properties();\n+    properties.setProperty(InputFormatConfig.CATALOG_NAME,\n+        conf.get(InputFormatConfig.CATALOG_NAME, InputFormatConfig.HADOOP_TABLES)); //Default to HadoopTables\n+    properties.setProperty(InputFormatConfig.SNAPSHOT_TABLE,\n+        conf.get(InputFormatConfig.SNAPSHOT_TABLE, \"true\"));\n+    properties.setProperty(InputFormatConfig.TABLE_LOCATION, extractProperty(conf, InputFormatConfig.TABLE_LOCATION));\n+    properties.setProperty(InputFormatConfig.TABLE_NAME, extractProperty(conf, InputFormatConfig.TABLE_NAME));\n+    return resolveTableFromConfiguration(conf, properties);\n+  }\n+\n+  static Table resolveTableFromConfiguration(Configuration conf, Properties properties) throws IOException {\n+    String catalogName = properties.getProperty(InputFormatConfig.CATALOG_NAME, InputFormatConfig.HADOOP_TABLES);\n+    String tableLocation = properties.getProperty(InputFormatConfig.TABLE_LOCATION);\n+    String tableName = properties.getProperty(InputFormatConfig.TABLE_NAME);\n+    Preconditions.checkNotNull(tableLocation, \"Table location is not set.\");\n+    Preconditions.checkNotNull(tableName, \"Table name is not set.\");\n+    switch (catalogName) {\n+      case InputFormatConfig.HADOOP_TABLES:\n+        HadoopTables tables = new HadoopTables(conf);\n+        if (tableName.endsWith(InputFormatConfig.SNAPSHOT_TABLE_SUFFIX)) {", "originalCommit": "eecb8336d66c3922e2b37552be35418abce5dd0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyODgzMw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r440028833", "bodyText": "I definitely think we should adopt the simplification offered by points 2,3,4. My only concern with point 1, is that it can often be useful to guide users into a good convention by making it a default behaviour. That said, table naming strategies are almost certainly the responsibility of the data lake owner and not the implementation - so perhaps best to drop the reserved suffix also. Thanks for this suggestion.", "author": "teabot", "createdAt": "2020-06-15T08:58:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1ODA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ4NTEzMQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r440485131", "bodyText": "I think this is a good idea, especially if it supports all metadata tables without additional work.", "author": "rdblue", "createdAt": "2020-06-15T22:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1ODA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyMjQwNA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r441522404", "bodyText": "We've made a note of all of these suggestions so thank you, first of all, and we're working on a new implementation for system tables via Hive. As was mentioned in the other PR, we'll take out all the system table + virtual column stuff from these initial PR's and will open another PR for just system tables after merging this and #933", "author": "cmathiesen", "createdAt": "2020-06-17T12:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1ODA2NQ=="}], "type": "inlineReview"}, {"oid": "2350025f11bf3ce6df226d21a87d5c403ab50b53", "url": "https://github.com/apache/iceberg/commit/2350025f11bf3ce6df226d21a87d5c403ab50b53", "message": "refactored code from IcebergInputFormat into InputFormatConfig", "committedDate": "2020-06-15T12:36:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNDU5NQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r440324595", "bodyText": "Seems like this class is shared by both mrv2 and mrv1 apis, similar to InputFormatConfig. We should have a consistent package name there..", "author": "rdsr", "createdAt": "2020-06-15T17:12:20Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/TableResolver.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;", "originalCommit": "2350025f11bf3ce6df226d21a87d5c403ab50b53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0NDAzMA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r441644030", "bodyText": "In this PR it's only being used by the mrv1 API which is why it's in the mapred package. When we look at #933 after this we can discuss how much code is shared and then potentially move this up a package level and have it contain shared code etc.", "author": "massdosage", "createdAt": "2020-06-17T15:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNDU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkwNDEzOQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r440904139", "bodyText": "nit: maybe just rename this to columnNames.  Also why is this protected , seems like it can static like its counterpart in IcebergSchemaToTypeInfo", "author": "rdsr", "createdAt": "2020-06-16T14:40:19Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergObjectInspectorGenerator.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.ListTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.MapTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.StructTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.types.Types;\n+\n+class IcebergObjectInspectorGenerator {\n+\n+  protected ObjectInspector createObjectInspector(Schema schema) throws Exception {\n+    List<String> columnNames = setColumnNames(schema);\n+    List<TypeInfo> columnTypes = IcebergSchemaToTypeInfo.getColumnTypes(schema);\n+\n+    List<ObjectInspector> columnOIs = new ArrayList<>(columnTypes.size());\n+    for (int i = 0; i < columnTypes.size(); i++) {\n+      columnOIs.add(createObjectInspectorWorker(columnTypes.get(i)));\n+    }\n+    return ObjectInspectorFactory.getStandardStructObjectInspector(columnNames, columnOIs, null);\n+  }\n+\n+  protected ObjectInspector createObjectInspectorWorker(TypeInfo typeInfo) throws Exception {\n+    ObjectInspector.Category typeCategory = typeInfo.getCategory();\n+\n+    switch (typeCategory) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pti = (PrimitiveTypeInfo) typeInfo;\n+        return PrimitiveObjectInspectorFactory.getPrimitiveJavaObjectInspector(pti);\n+      case LIST:\n+        ListTypeInfo ati = (ListTypeInfo) typeInfo;\n+        return ObjectInspectorFactory\n+            .getStandardListObjectInspector(createObjectInspectorWorker(ati.getListElementTypeInfo()));\n+      case MAP:\n+        MapTypeInfo mti = (MapTypeInfo) typeInfo;\n+        return ObjectInspectorFactory.getStandardMapObjectInspector(\n+            createObjectInspectorWorker(mti.getMapKeyTypeInfo()),\n+            createObjectInspectorWorker(mti.getMapValueTypeInfo()));\n+      case STRUCT:\n+        StructTypeInfo sti = (StructTypeInfo) typeInfo;\n+        List<ObjectInspector> ois = new ArrayList<>(sti.getAllStructFieldTypeInfos().size());\n+        for (TypeInfo structTypeInfos : sti.getAllStructFieldTypeInfos()) {\n+          ois.add(createObjectInspectorWorker(structTypeInfos));\n+        }\n+        return ObjectInspectorFactory.getStandardStructObjectInspector(sti.getAllStructFieldNames(), ois);\n+      default:\n+        throw new SerDeException(\"Couldn't create Object Inspector for category: '\" + typeCategory + \"'\");\n+    }\n+  }\n+\n+  protected List<String> setColumnNames(Schema schema) {", "originalCommit": "2350025f11bf3ce6df226d21a87d5c403ab50b53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTcwMg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r441211702", "bodyText": "I think the indentation was correct before. Can you revert this?", "author": "rdblue", "createdAt": "2020-06-17T00:20:04Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapreduce/IcebergInputFormat.java", "diffHunk": "@@ -265,9 +158,9 @@ private static void checkResiduals(CombinedScanTask task) {\n       Expression residual = fileScanTask.residual();\n       if (residual != null && !residual.equals(Expressions.alwaysTrue())) {\n         throw new UnsupportedOperationException(\n-            String.format(\n-                \"Filter expression %s is not completely satisfied. Additional rows \" +\n-                    \"can be returned not satisfied by the filter expression\", residual));\n+                String.format(\n+                        \"Filter expression %s is not completely satisfied. Additional rows \" +\n+                                \"can be returned not satisfied by the filter expression\", residual));", "originalCommit": "2350025f11bf3ce6df226d21a87d5c403ab50b53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0NDc1Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r441644752", "bodyText": "Yes, sorry!", "author": "massdosage", "createdAt": "2020-06-17T15:42:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTg5Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r441211892", "bodyText": "Can you revert the whitespace-only changes in this file? Otherwise this is going to have more conflicts than necessary.", "author": "rdblue", "createdAt": "2020-06-17T00:20:46Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapreduce/IcebergInputFormat.java", "diffHunk": "@@ -517,20 +411,20 @@ private Record withIdentityPartitionColumns(\n   }\n \n   private static Table findTable(Configuration conf) {\n-    String path = conf.get(TABLE_PATH);\n+    String path = conf.get(InputFormatConfig.TABLE_PATH);\n     Preconditions.checkArgument(path != null, \"Table path should not be null\");\n     if (path.contains(\"/\")) {\n       HadoopTables tables = new HadoopTables(conf);\n       return tables.load(path);\n     }\n \n-    String catalogFuncClass = conf.get(CATALOG);\n+    String catalogFuncClass = conf.get(InputFormatConfig.CATALOG);\n     if (catalogFuncClass != null) {\n       Function<Configuration, Catalog> catalogFunc = (Function<Configuration, Catalog>)\n-          DynConstructors.builder(Function.class)\n-                         .impl(catalogFuncClass)\n-                         .build()\n-                         .newInstance();\n+              DynConstructors.builder(Function.class)\n+                      .impl(catalogFuncClass)\n+                      .build()\n+                      .newInstance();", "originalCommit": "2350025f11bf3ce6df226d21a87d5c403ab50b53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1MDM3Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r441650372", "bodyText": "Yes, definitely.", "author": "massdosage", "createdAt": "2020-06-17T15:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTg5Mg=="}], "type": "inlineReview"}, {"oid": "abaafb501982052d6849923ccde51b4d7351c377", "url": "https://github.com/apache/iceberg/commit/abaafb501982052d6849923ccde51b4d7351c377", "message": "Remove system tables", "committedDate": "2020-06-17T13:09:32Z", "type": "commit"}, {"oid": "c5b6cd8171aa1d73df7da3cf14ce256c21c57a61", "url": "https://github.com/apache/iceberg/commit/c5b6cd8171aa1d73df7da3cf14ce256c21c57a61", "message": "revert whitespace changes", "committedDate": "2020-06-17T16:10:50Z", "type": "commit"}, {"oid": "f7c5c39387b13c27a44d17e4c5534578763c788a", "url": "https://github.com/apache/iceberg/commit/f7c5c39387b13c27a44d17e4c5534578763c788a", "message": "Refactor IcebergObjectInspector and implement custom object inspectors (#12)", "committedDate": "2020-06-26T11:16:03Z", "type": "commit"}, {"oid": "6421ed6b47d5e6d3cbdcf56fe48798c8c815e6a0", "url": "https://github.com/apache/iceberg/commit/6421ed6b47d5e6d3cbdcf56fe48798c8c815e6a0", "message": "Merge branch 'master' into iceberg-serde", "committedDate": "2020-06-26T12:00:07Z", "type": "commit"}, {"oid": "38e43396763cd7f3d2ba402579555119b5289daa", "url": "https://github.com/apache/iceberg/commit/38e43396763cd7f3d2ba402579555119b5289daa", "message": "fix compiler errors", "committedDate": "2020-06-26T12:52:24Z", "type": "commit"}, {"oid": "b3a0cfe243b58719ab5b3b26f0dbd108b3f35c6d", "url": "https://github.com/apache/iceberg/commit/b3a0cfe243b58719ab5b3b26f0dbd108b3f35c6d", "message": "tidied up and fleshed out tests", "committedDate": "2020-06-29T14:10:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0NDkzNA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r447344934", "bodyText": "I didn't realize Java added an UncheckedIOException in 8. We have one that is RuntimeIOException. We should probably convert Iceberg over to using the standard Java one.", "author": "rdblue", "createdAt": "2020-06-30T00:58:21Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSerDe.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Properties;\n+import javax.annotation.Nullable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.serde2.AbstractSerDe;\n+import org.apache.hadoop.hive.serde2.SerDeException;\n+import org.apache.hadoop.hive.serde2.SerDeStats;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.io.Writable;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.mr.mapred.serde.objectinspector.IcebergObjectInspector;\n+\n+public class IcebergSerDe extends AbstractSerDe {\n+\n+  private ObjectInspector inspector;\n+\n+  @Override\n+  public void initialize(@Nullable Configuration configuration, Properties serDeProperties) throws SerDeException {\n+    final Table table;\n+\n+    try {\n+      table = TableResolver.resolveTableFromConfiguration(configuration, serDeProperties);\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Unable to resolve table from configuration: \", e);", "originalCommit": "b3a0cfe243b58719ab5b3b26f0dbd108b3f35c6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0NjY2MQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r447346661", "bodyText": "This isn't correct because it doesn't follow the contract of ByteBuffer. Avro will reuse byte buffers, so there is no guarantee that this array is the correct length. In addition, we want to generally follow the ByteBuffer contract so that we don't need to worry about whether an optimization later (buffer reuse) will break certain sections of code.\nAn easy fix is to use ByteBuffers.toByteArray here.", "author": "rdblue", "createdAt": "2020-06-30T01:04:25Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/serde/objectinspector/IcebergBinaryObjectInspector.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred.serde.objectinspector;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.hadoop.hive.serde2.objectinspector.primitive.BinaryObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.io.BytesWritable;\n+\n+public final class IcebergBinaryObjectInspector extends IcebergPrimitiveObjectInspector\n+                                                implements BinaryObjectInspector {\n+\n+  private static final IcebergBinaryObjectInspector INSTANCE = new IcebergBinaryObjectInspector();\n+\n+  public static IcebergBinaryObjectInspector get() {\n+    return INSTANCE;\n+  }\n+\n+  private IcebergBinaryObjectInspector() {\n+    super(TypeInfoFactory.binaryTypeInfo);\n+  }\n+\n+  @Override\n+  public byte[] getPrimitiveJavaObject(Object o) {\n+    return o == null ? null : ((ByteBuffer) o).array();", "originalCommit": "b3a0cfe243b58719ab5b3b26f0dbd108b3f35c6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0ODExMQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r447348111", "bodyText": "Couldn't fixed by read as binary? And UUID as string? And doesn't Hive support time?", "author": "rdblue", "createdAt": "2020-06-30T01:08:52Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/serde/objectinspector/IcebergObjectInspector.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred.serde.objectinspector;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+\n+public final class IcebergObjectInspector extends TypeUtil.SchemaVisitor<ObjectInspector> {\n+\n+  public static ObjectInspector create(@Nullable Schema schema) {\n+    if (schema == null) {\n+      return IcebergRecordObjectInspector.empty();\n+    }\n+\n+    return TypeUtil.visit(schema, new IcebergObjectInspector());\n+  }\n+\n+  public static ObjectInspector create(Types.NestedField... fields) {\n+    return create(new Schema(fields));\n+  }\n+\n+  @Override\n+  public ObjectInspector field(Types.NestedField field, ObjectInspector fieldObjectInspector) {\n+    return fieldObjectInspector;\n+  }\n+\n+  @Override\n+  public ObjectInspector list(Types.ListType listTypeInfo, ObjectInspector listObjectInspector) {\n+    return ObjectInspectorFactory.getStandardListObjectInspector(listObjectInspector);\n+  }\n+\n+  @Override\n+  public ObjectInspector map(Types.MapType mapType,\n+                             ObjectInspector keyObjectInspector, ObjectInspector valueObjectInspector) {\n+    return ObjectInspectorFactory.getStandardMapObjectInspector(keyObjectInspector, valueObjectInspector);\n+  }\n+\n+  @Override\n+  public ObjectInspector primitive(Type.PrimitiveType primitiveType) {\n+    final PrimitiveTypeInfo primitiveTypeInfo;\n+\n+    switch (primitiveType.typeId()) {\n+      case BINARY:\n+        return IcebergBinaryObjectInspector.get();\n+      case BOOLEAN:\n+        primitiveTypeInfo = TypeInfoFactory.booleanTypeInfo;\n+        break;\n+      case DATE:\n+        return IcebergDateObjectInspector.get();\n+      case DECIMAL:\n+        Types.DecimalType type = (Types.DecimalType) primitiveType;\n+        return IcebergDecimalObjectInspector.get(type.precision(), type.scale());\n+      case DOUBLE:\n+        primitiveTypeInfo = TypeInfoFactory.doubleTypeInfo;\n+        break;\n+      case FLOAT:\n+        primitiveTypeInfo = TypeInfoFactory.floatTypeInfo;\n+        break;\n+      case INTEGER:\n+        primitiveTypeInfo = TypeInfoFactory.intTypeInfo;\n+        break;\n+      case LONG:\n+        primitiveTypeInfo = TypeInfoFactory.longTypeInfo;\n+        break;\n+      case STRING:\n+        primitiveTypeInfo = TypeInfoFactory.stringTypeInfo;\n+        break;\n+      case TIMESTAMP:\n+        boolean adjustToUTC = ((Types.TimestampType) primitiveType).shouldAdjustToUTC();\n+        return IcebergTimestampObjectInspector.get(adjustToUTC);\n+\n+      case FIXED:\n+      case TIME:\n+      case UUID:\n+      default:\n+        throw new IllegalArgumentException(primitiveType.typeId() + \" type is not supported\");", "originalCommit": "b3a0cfe243b58719ab5b3b26f0dbd108b3f35c6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM1OTgzMg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448359832", "bodyText": "First two done. As for TIME - Hive supports DATE and TIMESTAMP, I don't know enough about Iceberg's types to comment on how these differ from TIME but I'm guessing it doesn't?", "author": "massdosage", "createdAt": "2020-07-01T13:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0ODExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0OTg2OA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r447349868", "bodyText": "@omalley, is the Iceberg field ID suitable to return as a Hive field ID here?", "author": "rdblue", "createdAt": "2020-06-30T01:14:59Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/serde/objectinspector/IcebergRecordObjectInspector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred.serde.objectinspector;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+\n+public final class IcebergRecordObjectInspector extends StructObjectInspector {\n+\n+  private static final IcebergRecordObjectInspector EMPTY =\n+          new IcebergRecordObjectInspector(Types.StructType.of(), Collections.emptyList());\n+\n+  private final List<IcebergRecordStructField> structFields;\n+\n+  public IcebergRecordObjectInspector(Types.StructType structType, List<ObjectInspector> objectInspectors) {\n+    Preconditions.checkArgument(structType.fields().size() == objectInspectors.size());\n+\n+    this.structFields = Lists.newArrayListWithExpectedSize(structType.fields().size());\n+\n+    int position = 0;\n+\n+    for (Types.NestedField field : structType.fields()) {\n+      ObjectInspector oi = objectInspectors.get(position);\n+      IcebergRecordStructField structField = new IcebergRecordStructField(field, oi, position);\n+      structFields.add(structField);\n+      position++;\n+    }\n+  }\n+\n+  public static IcebergRecordObjectInspector empty() {\n+    return EMPTY;\n+  }\n+\n+  @Override\n+  public List<? extends StructField> getAllStructFieldRefs() {\n+    return structFields;\n+  }\n+\n+  @Override\n+  public StructField getStructFieldRef(String name) {\n+    return ObjectInspectorUtils.getStandardStructFieldRef(name, structFields);\n+  }\n+\n+  @Override\n+  public Object getStructFieldData(Object o, StructField structField) {\n+    return ((Record) o).get(((IcebergRecordStructField) structField).position());\n+  }\n+\n+  @Override\n+  public List<Object> getStructFieldsDataAsList(Object o) {\n+    Record record = (Record) o;\n+    return structFields\n+            .stream()\n+            .map(f -> record.get(f.position()))\n+            .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public String getTypeName() {\n+    return ObjectInspectorUtils.getStandardStructTypeName(this);\n+  }\n+\n+  @Override\n+  public Category getCategory() {\n+    return Category.STRUCT;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    IcebergRecordObjectInspector that = (IcebergRecordObjectInspector) o;\n+    return structFields.equals(that.structFields);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return structFields.hashCode();\n+  }\n+\n+  private static class IcebergRecordStructField implements StructField {\n+\n+    private final Types.NestedField field;\n+    private final ObjectInspector oi;\n+    private final int position;\n+\n+    IcebergRecordStructField(Types.NestedField field, ObjectInspector oi, int position) {\n+      this.field = field;\n+      this.oi = oi;\n+      this.position = position; // position in the record\n+    }\n+\n+    @Override\n+    public String getFieldName() {\n+      return field.name();\n+    }\n+\n+    @Override\n+    public ObjectInspector getFieldObjectInspector() {\n+      return oi;\n+    }\n+\n+    @Override\n+    public int getFieldID() {", "originalCommit": "b3a0cfe243b58719ab5b3b26f0dbd108b3f35c6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1MDA5Ng==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r447350096", "bodyText": "We typically prefer Objects.hash to this older pattern.", "author": "rdblue", "createdAt": "2020-06-30T01:15:43Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/serde/objectinspector/IcebergRecordObjectInspector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred.serde.objectinspector;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+\n+public final class IcebergRecordObjectInspector extends StructObjectInspector {\n+\n+  private static final IcebergRecordObjectInspector EMPTY =\n+          new IcebergRecordObjectInspector(Types.StructType.of(), Collections.emptyList());\n+\n+  private final List<IcebergRecordStructField> structFields;\n+\n+  public IcebergRecordObjectInspector(Types.StructType structType, List<ObjectInspector> objectInspectors) {\n+    Preconditions.checkArgument(structType.fields().size() == objectInspectors.size());\n+\n+    this.structFields = Lists.newArrayListWithExpectedSize(structType.fields().size());\n+\n+    int position = 0;\n+\n+    for (Types.NestedField field : structType.fields()) {\n+      ObjectInspector oi = objectInspectors.get(position);\n+      IcebergRecordStructField structField = new IcebergRecordStructField(field, oi, position);\n+      structFields.add(structField);\n+      position++;\n+    }\n+  }\n+\n+  public static IcebergRecordObjectInspector empty() {\n+    return EMPTY;\n+  }\n+\n+  @Override\n+  public List<? extends StructField> getAllStructFieldRefs() {\n+    return structFields;\n+  }\n+\n+  @Override\n+  public StructField getStructFieldRef(String name) {\n+    return ObjectInspectorUtils.getStandardStructFieldRef(name, structFields);\n+  }\n+\n+  @Override\n+  public Object getStructFieldData(Object o, StructField structField) {\n+    return ((Record) o).get(((IcebergRecordStructField) structField).position());\n+  }\n+\n+  @Override\n+  public List<Object> getStructFieldsDataAsList(Object o) {\n+    Record record = (Record) o;\n+    return structFields\n+            .stream()\n+            .map(f -> record.get(f.position()))\n+            .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public String getTypeName() {\n+    return ObjectInspectorUtils.getStandardStructTypeName(this);\n+  }\n+\n+  @Override\n+  public Category getCategory() {\n+    return Category.STRUCT;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    IcebergRecordObjectInspector that = (IcebergRecordObjectInspector) o;\n+    return structFields.equals(that.structFields);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return structFields.hashCode();\n+  }\n+\n+  private static class IcebergRecordStructField implements StructField {\n+\n+    private final Types.NestedField field;\n+    private final ObjectInspector oi;\n+    private final int position;\n+\n+    IcebergRecordStructField(Types.NestedField field, ObjectInspector oi, int position) {\n+      this.field = field;\n+      this.oi = oi;\n+      this.position = position; // position in the record\n+    }\n+\n+    @Override\n+    public String getFieldName() {\n+      return field.name();\n+    }\n+\n+    @Override\n+    public ObjectInspector getFieldObjectInspector() {\n+      return oi;\n+    }\n+\n+    @Override\n+    public int getFieldID() {\n+      return field.fieldId();\n+    }\n+\n+    @Override\n+    public String getFieldComment() {\n+      return field.doc();\n+    }\n+\n+    int position() {\n+      return position;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+\n+      IcebergRecordStructField that = (IcebergRecordStructField) o;\n+      return field.equals(that.field) && oi.equals(that.oi);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return 31 * field.hashCode() + oi.hashCode();", "originalCommit": "b3a0cfe243b58719ab5b3b26f0dbd108b3f35c6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1MDk5Nw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r447350997", "bodyText": "Minor: It seems like this would be a bit cleaner if the outer class was abstract and these were anonymous classes with an implementation for LocalDateTime convert(Object o) or something similar. Using Function is okay, but seems like it uses functions to avoid normal inheritance.", "author": "rdblue", "createdAt": "2020-06-30T01:19:09Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/serde/objectinspector/IcebergTimestampObjectInspector.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred.serde.objectinspector;\n+\n+import java.sql.Timestamp;\n+import java.time.LocalDateTime;\n+import java.time.OffsetDateTime;\n+import java.util.function.Function;\n+import org.apache.hadoop.hive.serde2.io.TimestampWritable;\n+import org.apache.hadoop.hive.serde2.objectinspector.primitive.TimestampObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+\n+public final class IcebergTimestampObjectInspector extends IcebergPrimitiveObjectInspector\n+        implements TimestampObjectInspector {\n+\n+  private static final IcebergTimestampObjectInspector INSTANCE_WITH_ZONE =\n+          new IcebergTimestampObjectInspector(o -> ((OffsetDateTime) o).toLocalDateTime());", "originalCommit": "b3a0cfe243b58719ab5b3b26f0dbd108b3f35c6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2NDA2MA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r447364060", "bodyText": "It would be nice to have more cases in this test suite:\n\nWhen the buffer's limit is less than array().length\nWhen the buffer's arrayOffset is non-zero\nWhen the buffer's position is non-zero", "author": "rdblue", "createdAt": "2020-06-30T02:04:38Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/serde/objectinspector/TestIcebergBinaryObjectInspector.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred.serde.objectinspector;\n+\n+import java.nio.ByteBuffer;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.primitive.BinaryObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.io.BytesWritable;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestIcebergBinaryObjectInspector {\n+\n+  @Test\n+  public void testIcebergBinaryObjectInspector() {", "originalCommit": "b3a0cfe243b58719ab5b3b26f0dbd108b3f35c6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2NDk1Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r447364952", "bodyText": "Instead of converting to Date and then wrapping with DateWritable, could we use the DateWritable constructor that accepts an integer? That would be more direct and we could convert using DateTimeUtil.daysFromDate(localDate) that we use elsewhere.", "author": "rdblue", "createdAt": "2020-06-30T02:07:45Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/serde/objectinspector/IcebergDateObjectInspector.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred.serde.objectinspector;\n+\n+import java.sql.Date;\n+import java.time.LocalDate;\n+import org.apache.hadoop.hive.serde2.io.DateWritable;\n+import org.apache.hadoop.hive.serde2.objectinspector.primitive.DateObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+\n+public final class IcebergDateObjectInspector extends IcebergPrimitiveObjectInspector implements DateObjectInspector {\n+\n+  private static final IcebergDateObjectInspector INSTANCE = new IcebergDateObjectInspector();\n+\n+  public static IcebergDateObjectInspector get() {\n+    return INSTANCE;\n+  }\n+\n+  private IcebergDateObjectInspector() {\n+    super(TypeInfoFactory.dateTypeInfo);\n+  }\n+\n+  @Override\n+  public Date getPrimitiveJavaObject(Object o) {\n+    return o == null ? null : Date.valueOf((LocalDate) o);\n+  }\n+\n+  @Override\n+  public DateWritable getPrimitiveWritableObject(Object o) {\n+    Date date = getPrimitiveJavaObject(o);\n+    return date == null ? null : new DateWritable(date);", "originalCommit": "b3a0cfe243b58719ab5b3b26f0dbd108b3f35c6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f0d8a1ba24f664fc4c07dd43988b06bb5a886e27", "url": "https://github.com/apache/iceberg/commit/f0d8a1ba24f664fc4c07dd43988b06bb5a886e27", "message": "Fix binary object inspector and handle fixed and UUID types (#13)\n\n* Refactor TestIcebergObjectInspector\r\n* Inherit from AbstractPrimitiveJavaObjectInspector rather than IcebergPrimitiveObjectInspector\r\n* Avoid creating an intermediate Date object\r\n* Fix IcebergRecordStructField.equals\r\n* Use inheritance to implement static Timestamp object inspectors\r\n* Handle UUID type as String\r\n* Handle fixed type as binary (byte array)", "committedDate": "2020-07-01T12:42:27Z", "type": "commit"}, {"oid": "de445c4aa7416a21b978b7f448b9d7fde27c7ced", "url": "https://github.com/apache/iceberg/commit/de445c4aa7416a21b978b7f448b9d7fde27c7ced", "message": "throw UnsupportedOperationException instead of returning null", "committedDate": "2020-07-01T13:19:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NjUwMg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448476502", "bodyText": "Why was this introduced? It seems like relying on the same execution order between the schema creation and the test methods is brittle.\nI'd prefer to move back to fixed IDs since that's easier to test and more clear in assertions.", "author": "rdblue", "createdAt": "2020-07-01T16:21:23Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/serde/objectinspector/TestIcebergObjectInspector.java", "diffHunk": "@@ -38,31 +38,37 @@\n \n public class TestIcebergObjectInspector {\n \n+  private int id = 0;", "originalCommit": "f0d8a1ba24f664fc4c07dd43988b06bb5a886e27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUwOTg5Mw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448509893", "bodyText": "That made my life easier when adding new field but I get your point, I'll fix it in a follow-up PR.", "author": "guilload", "createdAt": "2020-07-01T17:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUxNjA4OA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448516088", "bodyText": "@rdblue , @guilload, @massdosage if there are many issues, open items, does it make sense to create a milestone with all the open tickets? So that it can be worked on in parallel by us and we don't duplicate effort or step on each other's toes?", "author": "rdsr", "createdAt": "2020-07-01T17:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MDc2Mg==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448540762", "bodyText": "Sounds good to me. You should be able to create and edit milestones.", "author": "rdblue", "createdAt": "2020-07-01T18:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgxMzgwMw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448813803", "bodyText": "I think the only missing necessary follow up here already has a PR at #1157 so I'm not sure we need to do this? We're now co-ordinating with @guilload on the next steps for the mapred InputFormat.", "author": "massdosage", "createdAt": "2020-07-02T07:50:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NzQ2Mw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448477463", "bodyText": "We usually prefer using AssertHelpers.assertThrows here, but this is minor since you don't need to check that other state has not been modified after the failure.", "author": "rdblue", "createdAt": "2020-07-01T16:23:01Z", "path": "mr/src/test/java/org/apache/iceberg/mr/mapred/TestTableResolver.java", "diffHunk": "@@ -111,4 +111,21 @@ public void resolveTableFromPropertiesDefault() throws IOException {\n     Assert.assertEquals(tableLocation.getAbsolutePath(), table.location());\n   }\n \n+  @Test(expected = UnsupportedOperationException.class)\n+  public void resolveTableFromConfigurationHiveCatalog() throws IOException {\n+    Configuration conf = new Configuration();\n+    conf.set(InputFormatConfig.CATALOG_NAME, InputFormatConfig.HIVE_CATALOG);\n+    conf.set(InputFormatConfig.TABLE_NAME, \"table_a\");\n+\n+    TableResolver.resolveTableFromConfiguration(conf);\n+  }\n+\n+  @Test(expected = NullPointerException.class)", "originalCommit": "de445c4aa7416a21b978b7f448b9d7fde27c7ced", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgxNDI3NQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448814275", "bodyText": "Since the above is almost certainly going to be refactored when we merge more logic between the two InputFormats we can tackle this then.", "author": "massdosage", "createdAt": "2020-07-02T07:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NzQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzNzI2Mw==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r449237263", "bodyText": "I agree. I didn't want to block progress on Hive just for this.", "author": "rdblue", "createdAt": "2020-07-02T19:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NzQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NjkwOA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448496908", "bodyText": "can we put the hive classes in org.apache.iceberg.hive ? This is committed, but are you guys ok for this refactor?", "author": "rdsr", "createdAt": "2020-07-01T16:57:54Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/IcebergSerDe.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;", "originalCommit": "de445c4aa7416a21b978b7f448b9d7fde27c7ced", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUwMTEwOQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448501109", "bodyText": "I thought the convention was that the package name needed to match the subproject name and this isn't in the hive subproject but maybe that's not the case? Alternatively they could go in org.apache.iceberg.mr.hive?", "author": "massdosage", "createdAt": "2020-07-01T17:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NjkwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUwNDk0OA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448504948", "bodyText": "I prefer org.apache.iceberg.mr.hive", "author": "rdsr", "createdAt": "2020-07-01T17:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NjkwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MTMyNA==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448541324", "bodyText": "mr.hive sounds good to me.\nI don't think we need to worry too much about this kind of refactor right now. We expect it to change rapidly as we build. We'll include a note in any release about how it is experimental and subject to change.", "author": "rdblue", "createdAt": "2020-07-01T18:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NjkwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgxMTk2OQ==", "url": "https://github.com/apache/iceberg/pull/1103#discussion_r448811969", "bodyText": "OK, my preference would be to leave this as it is for now and then do a review of all the packaging once we have the StorageHandler and InputFormat merged.", "author": "massdosage", "createdAt": "2020-07-02T07:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NjkwOA=="}], "type": "inlineReview"}]}