{"pr_number": 1633, "pr_title": "AWS Glue catalog and table operations", "pr_createdAt": "2020-10-19T15:42:04Z", "pr_url": "https://github.com/apache/iceberg/pull/1633", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg2NTMxNg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507865316", "bodyText": "nit: Javadoc style. Capitalization and such", "author": "RussellSpitzer", "createdAt": "2020-10-19T15:53:40Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg2NTg0Mg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507865842", "bodyText": "nit: Javadoc style. Capitalization and probably needs elaboration", "author": "RussellSpitzer", "createdAt": "2020-10-19T15:54:26Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg2NjcyMQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507866721", "bodyText": "nit: Iceberg error messages are usually \"Cannot x because y. (Workaround or fix)\"", "author": "RussellSpitzer", "createdAt": "2020-10-19T15:55:33Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg2OTY1Ng==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507869656", "bodyText": "This java doc isn't clear to me. I think the summary here should describe what the method is doing \"Returns the default warehouse location as stored in the glue service (?). If not present, uses X .... \"\nThen under return \"default warehouse path as a string using Hive's formatting\"\nDoes that sound right?", "author": "RussellSpitzer", "createdAt": "2020-10-19T15:59:31Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEzNDgwNQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508134805", "bodyText": "Yeah let me just be precise with the behavior of it instead of saying it's the same as Hive.", "author": "jackye1995", "createdAt": "2020-10-20T00:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg2OTY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3MzA2OQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507873069", "bodyText": "I tend to be afraid of while(true) break, I would prefer this was written in a different style. One quick change here which wouldn't be that different would be a \"do while\" which would let you keep basically everything the same but you could drop the \"break\".\nIdeally I like to avoid \"break\" if at all possible and especially in loops, but ymmv.", "author": "RussellSpitzer", "createdAt": "2020-10-19T16:04:20Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    while (true) {", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEzNjMzMg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508136332", "bodyText": "Sure, will use a do...while syntax for this.", "author": "jackye1995", "createdAt": "2020-10-20T00:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3MzA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3Mzg1Ng==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507873856", "bodyText": "Is there any possibility we might want to log the contents of this Exception? Feel's like we may want to surface some classes of errors.", "author": "RussellSpitzer", "createdAt": "2020-10-19T16:05:31Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    while (true) {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+      if (nextToken == null) {\n+        break;\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      dropTable(newTableOps(identifier), identifier, purge);\n+      return true;\n+    } catch (Exception e) {", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5OTcwNw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508099707", "bodyText": "Yeah I'd definitely like to log the contents of this exception. It would greatly help debug issues like whether or not the table drop failed due to invalid permissions, possibly the wrong role is being assumed at this point in time, etc.", "author": "kbendick", "createdAt": "2020-10-19T22:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3Mzg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEzMDI4MQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508130281", "bodyText": "Yes I definitely forgot to log here. Will be more detailed on this part.", "author": "jackye1995", "createdAt": "2020-10-20T00:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3Mzg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4Mjk0Ng==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507882946", "bodyText": "another maybe \"do while\" oppertunity", "author": "RussellSpitzer", "createdAt": "2020-10-19T16:19:08Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    while (true) {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+      if (nextToken == null) {\n+        break;\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      dropTable(newTableOps(identifier), identifier, purge);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  private TableMetadata dropTable(TableOperations ops, TableIdentifier identifier, boolean purge) {\n+    TableMetadata lastMetadata = null;\n+    if (ops.current() != null) {\n+      lastMetadata = ops.current();\n+    }\n+\n+    glue.deleteTable(DeleteTableRequest.builder()\n+        .catalogId(catalogId)\n+        .databaseName(IcebergToGlueConverter.toDatabaseName(identifier.namespace()))\n+        .name(identifier.name())\n+        .build());\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+    }\n+\n+    LOG.info(\"Dropped table: {}\", identifier);\n+    return lastMetadata;\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    TableOperations ops = newTableOps(from);\n+    // keep metadata\n+    TableMetadata tableMetadata = dropTable(ops, from, false);\n+    // use the same info to create the new table\n+    createTable(to, tableMetadata.schema(), tableMetadata.spec(), tableMetadata.properties());\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    glue.createDatabase(CreateDatabaseRequest.builder()\n+        .catalogId(catalogId)\n+        .databaseInput(IcebergToGlueConverter.toDatabaseInput(namespace, metadata))\n+        .build());\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespace.isEmpty()) {\n+      // if it is not a list all op, just check if the namespace exists and return itself.\n+      if (namespaceExists(namespace)) {\n+        return Lists.newArrayList(namespace);\n+      }\n+      throw new NoSuchNamespaceException(\n+          \"Glue does not support nested namespace, cannot list namespaces under %s\", namespace);\n+    }\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<Namespace> results = new ArrayList<>();\n+    while (true) {\n+      GetDatabasesResponse response = glue.getDatabases(GetDatabasesRequest.builder()", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4NTc1MA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507885750", "bodyText": "Nit: Can we add Preconditions.checkNotNull on anything that is nullable here so we can avoid nulll checks later?", "author": "kbendick", "createdAt": "2020-10-19T16:23:07Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEzODA2OQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508138069", "bodyText": "warehousePath is checked by validateWarehousePath in the constructor, and catalogId can be null. I can add the precondition for conf and glue.", "author": "jackye1995", "createdAt": "2020-10-20T00:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4NTc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4NjA2Nw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507886067", "bodyText": "I'm a little nervous about this implementation not following the pattern of the other catalogs and refusing to drop if there is something in the namespace. Downstream code may be relying on this to prevent destructive operations ...", "author": "RussellSpitzer", "createdAt": "2020-10-19T16:23:35Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    while (true) {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+      if (nextToken == null) {\n+        break;\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      dropTable(newTableOps(identifier), identifier, purge);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  private TableMetadata dropTable(TableOperations ops, TableIdentifier identifier, boolean purge) {\n+    TableMetadata lastMetadata = null;\n+    if (ops.current() != null) {\n+      lastMetadata = ops.current();\n+    }\n+\n+    glue.deleteTable(DeleteTableRequest.builder()\n+        .catalogId(catalogId)\n+        .databaseName(IcebergToGlueConverter.toDatabaseName(identifier.namespace()))\n+        .name(identifier.name())\n+        .build());\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+    }\n+\n+    LOG.info(\"Dropped table: {}\", identifier);\n+    return lastMetadata;\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    TableOperations ops = newTableOps(from);\n+    // keep metadata\n+    TableMetadata tableMetadata = dropTable(ops, from, false);\n+    // use the same info to create the new table\n+    createTable(to, tableMetadata.schema(), tableMetadata.spec(), tableMetadata.properties());\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    glue.createDatabase(CreateDatabaseRequest.builder()\n+        .catalogId(catalogId)\n+        .databaseInput(IcebergToGlueConverter.toDatabaseInput(namespace, metadata))\n+        .build());\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespace.isEmpty()) {\n+      // if it is not a list all op, just check if the namespace exists and return itself.\n+      if (namespaceExists(namespace)) {\n+        return Lists.newArrayList(namespace);\n+      }\n+      throw new NoSuchNamespaceException(\n+          \"Glue does not support nested namespace, cannot list namespaces under %s\", namespace);\n+    }\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<Namespace> results = new ArrayList<>();\n+    while (true) {\n+      GetDatabasesResponse response = glue.getDatabases(GetDatabasesRequest.builder()\n+          .catalogId(catalogId)\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasDatabaseList()) {\n+        results.addAll(response.databaseList().stream()\n+            .map(GlueToIcebergConverter::toNamespace)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+      if (nextToken == null) {\n+        break;\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    String databaseName = IcebergToGlueConverter.toDatabaseName(namespace);\n+    try {\n+      GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+          .catalogId(catalogId)\n+          .name(databaseName)\n+          .build());\n+      return response.database().parameters();\n+    } catch (InvalidInputException e) {\n+      throw new NoSuchNamespaceException(\"invalid input for namespace %s, error message: %s\",\n+          namespace, e.getMessage());\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchNamespaceException(\"fail to find Glue database for namespace %s, error message: %s\",\n+          databaseName, e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * After completing this operation, you no longer have access to the tables\n+   * (and all table versions and partitions that might belong to the tables)\n+   * and the user-defined functions in the deleted database.\n+   * AWS Glue deletes these \"orphaned\" resources asynchronously in a timely manner, at the discretion of the service.\n+   * To ensure the immediate deletion of all related resources, before calling DeleteDatabase, use DeleteTableVersion\n+   * or BatchDeleteTableVersion, DeletePartition or BatchDeletePartition, DeleteUserDefinedFunction,\n+   * and DeleteTable or BatchDeleteTable, to delete any resources that belong to the database.\n+   * @param namespace a namespace. {@link Namespace}\n+   * @return always true\n+   * @throws NamespaceNotEmptyException never thrown", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEyOTEwNg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508129106", "bodyText": "Good point, this is definitely a different behavior between Glue and Hive. I can do a ListTable before dropping.", "author": "jackye1995", "createdAt": "2020-10-19T23:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4NjA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4ODAxOA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507888018", "bodyText": "Nit: Java Doc style and summary need elaboration", "author": "RussellSpitzer", "createdAt": "2020-10-19T16:26:23Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+public class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  private static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullName;\n+\n+  private FileIO fileIO;\n+\n+  /**\n+   * constructor", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4OTI4NQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507889285", "bodyText": "This could just be a one liner\n/**\n\nReturns table name in the form glue.catalogId.databaseName.tableName\n**/", "author": "RussellSpitzer", "createdAt": "2020-10-19T16:28:18Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+public class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  private static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullName;\n+\n+  private FileIO fileIO;\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param databaseName Glue database name\n+   * @param tableName Glue table name\n+   */\n+  public GlueTableOperations(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      String databaseName,\n+      String tableName) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.databaseName = databaseName;\n+    this.tableName = tableName;\n+    this.fullName = String.format(\"glue.%s.%s.%s\", catalogId, databaseName, tableName);\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    if (fileIO == null) {\n+      fileIO = new HadoopFileIO(conf);\n+    }\n+    return fileIO;\n+  }\n+\n+  /**\n+   * glue.catalogId.databaseName.tableName", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5NjM2OA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507896368", "bodyText": "More error messages which should be in the form Cannot x because y. I think the concurrent update to table error should also include the information\n\"\"\"   * For users that need high frequency and high concurrency update,\n* please consider requesting rate increase for Glue UpdateTable API,\n* or use an external lock system such as DynamoDB lock.\"\"\"\nWhich an end user will usually not see", "author": "RussellSpitzer", "createdAt": "2020-10-19T16:39:19Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+public class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  private static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullName;\n+\n+  private FileIO fileIO;\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param databaseName Glue database name\n+   * @param tableName Glue table name\n+   */\n+  public GlueTableOperations(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      String databaseName,\n+      String tableName) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.databaseName = databaseName;\n+    this.tableName = tableName;\n+    this.fullName = String.format(\"glue.%s.%s.%s\", catalogId, databaseName, tableName);\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    if (fileIO == null) {\n+      fileIO = new HadoopFileIO(conf);\n+    }\n+    return fileIO;\n+  }\n+\n+  /**\n+   * glue.catalogId.databaseName.tableName\n+   * It's only for logging purpose, so it's okay for catalogId to be null.\n+   * @return table name\n+   */\n+  @Override\n+  protected String tableName() {\n+    return fullName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      String metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+      refreshFromMetadataLocation(metadataLocation);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * We rely on Glue's ConcurrentModificationException to detect commit conflicts.\n+   * For users that need high frequency and high concurrency update,\n+   * please consider requesting rate increase for Glue UpdateTable API,\n+   * or use an external lock system such as DynamoDB lock.\n+   * @param base old metadata\n+   * @param metadata new metadata\n+   */\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {\n+        glueTable = glueTableOptional.get();\n+        // If we try to create the table but the metadata location is already set, then we had a concurrent commit\n+        if (base == null && glueTable.parameters().get(METADATA_LOCATION_PROP) != null) {\n+          throw new AlreadyExistsException(\"Table already exists in Glue: %s\", tableName());\n+        }\n+        isUpdate = true;\n+        LOG.debug(\"Committing existing Glue table: {}\", tableName());\n+      } else {\n+        LOG.debug(\"Committing new Glue table: {}\", tableName());\n+      }\n+\n+      String glueMetadataLocation = isUpdate ? glueTable.parameters().get(METADATA_LOCATION_PROP) : null;\n+      String baseMetadataLocation = base != null ? base.metadataFileLocation() : null;\n+      if (!Objects.equals(baseMetadataLocation, glueMetadataLocation)) {\n+        throw new CommitFailedException(\n+            \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s\",\n+            baseMetadataLocation, glueMetadataLocation, tableName());\n+      }\n+\n+      // set parameters\n+      Map<String, String> parameters = isUpdate ? Maps.newHashMap(glueTable.parameters()) : Maps.newHashMap();\n+      updateParameters(parameters, newMetadataLocation);\n+      persistGlueTable(isUpdate, parameters);\n+      exceptionThrown = false;\n+    } catch (ConcurrentModificationException e) {\n+      throw new CommitFailedException(e, \"Glue detected concurrent update to table %s\", tableName());", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5NzU3Ng==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507897576", "bodyText": "Style on javadoc", "author": "RussellSpitzer", "createdAt": "2020-10-19T16:41:15Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueToIcebergConverter.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchIcebergTableException;\n+import software.amazon.awssdk.services.glue.model.Database;\n+import software.amazon.awssdk.services.glue.model.Table;\n+\n+public class GlueToIcebergConverter {\n+\n+  private GlueToIcebergConverter() {\n+  }\n+\n+  public static Namespace toNamespace(Database database) {\n+    return Namespace.of(database.name());\n+  }\n+\n+  public static TableIdentifier toTableId(Table table) {\n+    return TableIdentifier.of(table.databaseName(), table.name());\n+  }\n+\n+  /**\n+   * validate the Glue table is Iceberg table by checking its parameters", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5ODIzMA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507898230", "bodyText": "Exception message pattern", "author": "RussellSpitzer", "createdAt": "2020-10-19T16:42:22Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/IcebergToGlueConverter.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import software.amazon.awssdk.services.glue.model.DatabaseInput;\n+\n+public class IcebergToGlueConverter {\n+\n+  private IcebergToGlueConverter() {\n+  }\n+\n+  private static final Pattern GLUE_DB_PATTERN = Pattern.compile(\"^[a-z0-9_]{1,252}$\");\n+\n+\n+  private static boolean isValidNamespace(Namespace namespace) {\n+    if (namespace.levels().length != 1) {\n+      return false;\n+    }\n+    String dbName = namespace.level(0);\n+    return dbName != null && GLUE_DB_PATTERN.matcher(dbName).find();\n+  }\n+\n+  /**\n+   * A database name cannot be longer than 252 characters.\n+   * The only acceptable characters are lowercase letters, numbers, and the underscore character.\n+   * More details: https://docs.aws.amazon.com/athena/latest/ug/glue-best-practices.html\n+   * @param namespace namespace\n+   * @return if namespace can be accepted by Glue\n+   * @throws NoSuchNamespaceException no such namespace\n+   */\n+  public static String toDatabaseName(Namespace namespace) {\n+    if (!isValidNamespace(namespace)) {\n+      throw new NoSuchNamespaceException(\n+          \"Bad namespace name %s, must be 1-232 chars of lowercase letters, numbers, underscore\", namespace);", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NzY3MQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507987671", "bodyText": "Nit: could be the same line", "author": "yyanyy", "createdAt": "2020-10-19T18:52:05Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    while (true) {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+      if (nextToken == null) {\n+        break;\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      dropTable(newTableOps(identifier), identifier, purge);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  private TableMetadata dropTable(TableOperations ops, TableIdentifier identifier, boolean purge) {\n+    TableMetadata lastMetadata = null;\n+    if (ops.current() != null) {\n+      lastMetadata = ops.current();\n+    }", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4ODMxOQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r507988319", "bodyText": "Do we want to validate to before dropping, so that we don't firstly drop table and then realize input was invalid?", "author": "yyanyy", "createdAt": "2020-10-19T18:53:11Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    while (true) {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+      if (nextToken == null) {\n+        break;\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      dropTable(newTableOps(identifier), identifier, purge);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  private TableMetadata dropTable(TableOperations ops, TableIdentifier identifier, boolean purge) {\n+    TableMetadata lastMetadata = null;\n+    if (ops.current() != null) {\n+      lastMetadata = ops.current();\n+    }\n+\n+    glue.deleteTable(DeleteTableRequest.builder()\n+        .catalogId(catalogId)\n+        .databaseName(IcebergToGlueConverter.toDatabaseName(identifier.namespace()))\n+        .name(identifier.name())\n+        .build());\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+    }\n+\n+    LOG.info(\"Dropped table: {}\", identifier);\n+    return lastMetadata;\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    TableOperations ops = newTableOps(from);\n+    // keep metadata\n+    TableMetadata tableMetadata = dropTable(ops, from, false);", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1Mzg4MA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508153880", "bodyText": "good point, let me add the check", "author": "jackye1995", "createdAt": "2020-10-20T01:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4ODMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5Nzg5OA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508097898", "bodyText": "You might need a try ... catch block here as the call to getTables can throw iirc.", "author": "kbendick", "createdAt": "2020-10-19T22:25:06Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    while (true) {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0ODczNA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508148734", "bodyText": "I did not catch any exception because glue client only throw RuntimeException, and it seems to be okay in other catalog implementations.", "author": "jackye1995", "createdAt": "2020-10-20T01:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5Nzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwMTM0OQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513601349", "bodyText": "It depends on the exception. If the namespace is missing, then we have an exception for that so users can handle it. We would want to translate the AWS exception to the Iceberg one. But for connection issues, it's okay to throw the original exception.\nSince namespaceExists is called above, I'm guessing that case is already handled, though that doesn't account for concurrent deletes.", "author": "rdblue", "createdAt": "2020-10-28T16:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5Nzg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5ODc1NQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508098755", "bodyText": "Nit: Maybe add an info log above when the table is dropped from the catalog and then one here about whether or not the table was purged?", "author": "kbendick", "createdAt": "2020-10-19T22:27:14Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    while (true) {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+      if (nextToken == null) {\n+        break;\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      dropTable(newTableOps(identifier), identifier, purge);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  private TableMetadata dropTable(TableOperations ops, TableIdentifier identifier, boolean purge) {\n+    TableMetadata lastMetadata = null;\n+    if (ops.current() != null) {\n+      lastMetadata = ops.current();\n+    }\n+\n+    glue.deleteTable(DeleteTableRequest.builder()\n+        .catalogId(catalogId)\n+        .databaseName(IcebergToGlueConverter.toDatabaseName(identifier.namespace()))\n+        .name(identifier.name())\n+        .build());\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+    }\n+\n+    LOG.info(\"Dropped table: {}\", identifier);", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMDE4Mw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508100183", "bodyText": "Seems like this operation can throw as well. Since the BaseMetastoreCatalog doesn't declare thi with a checked exception, you might want to document what it can throw that you know of or wrap in try...catch (though arguably that could be up the calling code).", "author": "kbendick", "createdAt": "2020-10-19T22:30:55Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    while (true) {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+      if (nextToken == null) {\n+        break;\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      dropTable(newTableOps(identifier), identifier, purge);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  private TableMetadata dropTable(TableOperations ops, TableIdentifier identifier, boolean purge) {\n+    TableMetadata lastMetadata = null;\n+    if (ops.current() != null) {\n+      lastMetadata = ops.current();\n+    }\n+\n+    glue.deleteTable(DeleteTableRequest.builder()\n+        .catalogId(catalogId)\n+        .databaseName(IcebergToGlueConverter.toDatabaseName(identifier.namespace()))\n+        .name(identifier.name())\n+        .build());\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+    }\n+\n+    LOG.info(\"Dropped table: {}\", identifier);\n+    return lastMetadata;\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    TableOperations ops = newTableOps(from);\n+    // keep metadata\n+    TableMetadata tableMetadata = dropTable(ops, from, false);\n+    // use the same info to create the new table\n+    createTable(to, tableMetadata.schema(), tableMetadata.spec(), tableMetadata.properties());\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    glue.createDatabase(CreateDatabaseRequest.builder()\n+        .catalogId(catalogId)\n+        .databaseInput(IcebergToGlueConverter.toDatabaseInput(namespace, metadata))\n+        .build());", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE2NTQzNg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508165436", "bodyText": "Based on my observation of other catalogs, we are not handling runtime exceptions, and aws clients only throw runtime exception. That is why I do not try catch anything here. I can probably add a check for AlreadyExistsException.", "author": "jackye1995", "createdAt": "2020-10-20T02:09:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMDE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTE0Ng==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508101146", "bodyText": "Maybe I'm just totally missing the obvious but I don't see where parameter is being used. Loks like it's built and then the database is updated directly via propeties.", "author": "kbendick", "createdAt": "2020-10-19T22:33:28Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  // Catalog ID is the AWS account ID. When it is null, it uses the account of the Glue client.\n+  private final String catalogId;\n+  private final String warehousePath;\n+\n+  /**\n+   * constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  /**\n+   * constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Glue warehouse path must be set\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Glue warehouse path %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    String dbName = IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace());\n+    String tableName = tableIdentifier.name();\n+    return new GlueTableOperations(conf, glue, catalogId, dbName, tableName);\n+  }\n+\n+  /**\n+   * Use the same format as Hive for default warehouse location\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.toDatabaseName(tableIdentifier.namespace()),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    while (true) {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+      if (nextToken == null) {\n+        break;\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      dropTable(newTableOps(identifier), identifier, purge);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  private TableMetadata dropTable(TableOperations ops, TableIdentifier identifier, boolean purge) {\n+    TableMetadata lastMetadata = null;\n+    if (ops.current() != null) {\n+      lastMetadata = ops.current();\n+    }\n+\n+    glue.deleteTable(DeleteTableRequest.builder()\n+        .catalogId(catalogId)\n+        .databaseName(IcebergToGlueConverter.toDatabaseName(identifier.namespace()))\n+        .name(identifier.name())\n+        .build());\n+\n+    if (purge && lastMetadata != null) {\n+      CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+    }\n+\n+    LOG.info(\"Dropped table: {}\", identifier);\n+    return lastMetadata;\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    TableOperations ops = newTableOps(from);\n+    // keep metadata\n+    TableMetadata tableMetadata = dropTable(ops, from, false);\n+    // use the same info to create the new table\n+    createTable(to, tableMetadata.schema(), tableMetadata.spec(), tableMetadata.properties());\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    glue.createDatabase(CreateDatabaseRequest.builder()\n+        .catalogId(catalogId)\n+        .databaseInput(IcebergToGlueConverter.toDatabaseInput(namespace, metadata))\n+        .build());\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespace.isEmpty()) {\n+      // if it is not a list all op, just check if the namespace exists and return itself.\n+      if (namespaceExists(namespace)) {\n+        return Lists.newArrayList(namespace);\n+      }\n+      throw new NoSuchNamespaceException(\n+          \"Glue does not support nested namespace, cannot list namespaces under %s\", namespace);\n+    }\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<Namespace> results = new ArrayList<>();\n+    while (true) {\n+      GetDatabasesResponse response = glue.getDatabases(GetDatabasesRequest.builder()\n+          .catalogId(catalogId)\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasDatabaseList()) {\n+        results.addAll(response.databaseList().stream()\n+            .map(GlueToIcebergConverter::toNamespace)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+      if (nextToken == null) {\n+        break;\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    String databaseName = IcebergToGlueConverter.toDatabaseName(namespace);\n+    try {\n+      GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+          .catalogId(catalogId)\n+          .name(databaseName)\n+          .build());\n+      return response.database().parameters();\n+    } catch (InvalidInputException e) {\n+      throw new NoSuchNamespaceException(\"invalid input for namespace %s, error message: %s\",\n+          namespace, e.getMessage());\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchNamespaceException(\"fail to find Glue database for namespace %s, error message: %s\",\n+          databaseName, e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * After completing this operation, you no longer have access to the tables\n+   * (and all table versions and partitions that might belong to the tables)\n+   * and the user-defined functions in the deleted database.\n+   * AWS Glue deletes these \"orphaned\" resources asynchronously in a timely manner, at the discretion of the service.\n+   * To ensure the immediate deletion of all related resources, before calling DeleteDatabase, use DeleteTableVersion\n+   * or BatchDeleteTableVersion, DeletePartition or BatchDeletePartition, DeleteUserDefinedFunction,\n+   * and DeleteTable or BatchDeleteTable, to delete any resources that belong to the database.\n+   * @param namespace a namespace. {@link Namespace}\n+   * @return always true\n+   * @throws NamespaceNotEmptyException never thrown\n+   */\n+  @Override\n+  public boolean dropNamespace(Namespace namespace) throws NamespaceNotEmptyException {\n+    namespaceExists(namespace);\n+    glue.deleteDatabase(DeleteDatabaseRequest.builder()\n+        .catalogId(catalogId)\n+        .name(IcebergToGlueConverter.toDatabaseName(namespace))\n+        .build());\n+    // Always successful, otherwise exception is thrown\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean setProperties(Namespace namespace, Map<String, String> properties) throws NoSuchNamespaceException {\n+    Map<String, String> parameter = Maps.newHashMap();\n+    parameter.putAll(loadNamespaceMetadata(namespace));\n+    parameter.putAll(properties);", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE2NDEzOA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508164138", "bodyText": "It's used in persistGlueTable in doCommit", "author": "jackye1995", "createdAt": "2020-10-20T02:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU5OTk3OQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r509599979", "bodyText": "Ok. But to me, it seems like the locally declared parameter isn't used in this function.\nAre you sure you didn't intend to use the merged parameter map instead of properties here when calling IcebergToGlueConverter.toDatabaseInput(namespace, properties)? https://github.com/apache/iceberg/pull/1633/files#diff-51a208168318cb652ad5beb86d3433d714aca916f9816c4cffcc88e273daf6afR287?", "author": "kbendick", "createdAt": "2020-10-21T19:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTYwMjMyNw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r509602327", "bodyText": "Conversely, the updated local metadata map is used in removeProperties instead of the passed in properties. So I still feel like potentially this variable is unused / was potentially meant to be passed into the IcebergToGlueConverter.toDatabaseInput instead of passing in the properties map.\nHere's the usage in removeProperties that follows a similar pattern:\n\nBuild an updated table properties map.\nUse the updated map when passing to the iceberg to glue converted for databaseInput\n\nhttps://github.com/apache/iceberg/pull/1633/files#diff-51a208168318cb652ad5beb86d3433d714aca916f9816c4cffcc88e273daf6afR296-R302", "author": "kbendick", "createdAt": "2020-10-21T19:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3MTE4OA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r509671188", "bodyText": "Oh yeah sorry that one was actually my typo, thank you for pointing out. Somehow I was reading the wrong line when doing the reply...\nI have pushed the latest code that has the fix and also with the integration test against actual Glue service that detected those bugs.", "author": "jackye1995", "createdAt": "2020-10-21T20:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MTQ5OA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508151498", "bodyText": "I don't really see much value in this test given how heavily mocked it is.", "author": "kbendick", "createdAt": "2020-10-20T01:17:47Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/TestGlueCatalog.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableResponse;\n+import software.amazon.awssdk.services.glue.model.Database;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseResponse;\n+\n+public class TestGlueCatalog {\n+\n+  private static final String WAREHOUSE_PATH = \"s3://bucket\";\n+  private GlueClient glue;\n+  private GlueCatalog glueCatalog;\n+\n+  @Before\n+  public void before() {\n+    glue = Mockito.mock(GlueClient.class);\n+    glueCatalog = new GlueCatalog(\n+        new Configuration(),\n+        glue,\n+        null,\n+        WAREHOUSE_PATH\n+    );\n+  }\n+\n+  @Test\n+  public void defaultWarehouseLocation_noDbUri() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    String location = glueCatalog.defaultWarehouseLocation(TableIdentifier.of(\"db\", \"table\"));\n+    Assert.assertEquals(WAREHOUSE_PATH + \"/db.db/table\", location);\n+  }\n+\n+  @Test\n+  public void defaultWarehouseLocation_dbUri() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db\").locationUri(\"s3://bucket2/db\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    String location = glueCatalog.defaultWarehouseLocation(TableIdentifier.of(\"db\", \"table\"));\n+    Assert.assertEquals(\"s3://bucket2/db/table\", location);\n+  }\n+\n+  @Test\n+  public void listTables() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db1\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    Mockito.doReturn(GetTablesResponse.builder()\n+        .tableList(\n+            Table.builder().databaseName(\"db1\").name(\"t1\").build(),\n+            Table.builder().databaseName(\"db1\").name(\"t2\").build()\n+        ).build())\n+        .when(glue).getTables(Mockito.any(GetTablesRequest.class));\n+    Assert.assertEquals(\n+        Lists.newArrayList(\n+            TableIdentifier.of(\"db1\", \"t1\"),\n+            TableIdentifier.of(\"db1\", \"t2\")\n+        ),\n+        glueCatalog.listTables(Namespace.of(\"db1\"))\n+    );\n+  }\n+\n+  @Test\n+  public void dropTable() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db1\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    Mockito.doReturn(DeleteTableResponse.builder().build())\n+        .when(glue).deleteTable(Mockito.any(DeleteTableRequest.class));\n+    glueCatalog.dropTable(TableIdentifier.of(\"db1\", \"t1\"));\n+  }\n+\n+  @Test\n+  public void renameTable() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db1\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    Mockito.doReturn(DeleteTableResponse.builder().build())\n+        .when(glue).deleteTable(Mockito.any(DeleteTableRequest.class));\n+    Mockito.doReturn(CreateTableResponse.builder().build())\n+        .when(glue).createTable(Mockito.any(CreateTableRequest.class));\n+    glueCatalog.dropTable(TableIdentifier.of(\"db1\", \"t1\"));\n+  }\n+\n+  @Test\n+  public void createNamespace() {\n+    Mockito.doReturn(CreateDatabaseResponse.builder().build())\n+        .when(glue).createDatabase(Mockito.any(CreateDatabaseRequest.class));\n+    glueCatalog.createNamespace(Namespace.of(\"db\"));\n+  }\n+\n+  @Test(expected = NoSuchNamespaceException.class)\n+  public void createNamespace_badName() {\n+    Mockito.doReturn(CreateDatabaseResponse.builder().build())\n+        .when(glue).createDatabase(Mockito.any(CreateDatabaseRequest.class));\n+    glueCatalog.createNamespace(Namespace.of(\"db-1\"));\n+  }\n+\n+  @Test\n+  public void listNamespaces_all() {\n+    Mockito.doReturn(GetDatabasesResponse.builder()\n+        .databaseList(\n+            Database.builder().name(\"db1\").build(),\n+            Database.builder().name(\"db2\").build()\n+        ).build())\n+        .when(glue).getDatabases(Mockito.any(GetDatabasesRequest.class));\n+    Assert.assertEquals(\n+        Lists.newArrayList(\n+            Namespace.of(\"db1\"),\n+            Namespace.of(\"db2\")\n+        ),\n+        glueCatalog.listNamespaces()\n+    );", "originalCommit": "0621754136976a9aa17c90858bed545e1c35a5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1NDE4Mg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r508154182", "bodyText": "100% agree, I am thinking about also publish the actual Glue tests, but I have to also mark them as Ignored because it needs AWS credentials to run.", "author": "jackye1995", "createdAt": "2020-10-20T01:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MTQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MDQwMw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r510450403", "bodyText": "Not a problem for now but wondering if we want to add a path/folder with random name to the warehouse location inside bucket to allow concurrent runs", "author": "yyanyy", "createdAt": "2020-10-22T20:53:42Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/TestGlueCatalogInteg.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.types.Types;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.Database;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.model.Delete;\n+import software.amazon.awssdk.services.s3.model.DeleteObjectsRequest;\n+import software.amazon.awssdk.services.s3.model.HeadObjectRequest;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\n+import software.amazon.awssdk.services.s3.model.ObjectIdentifier;\n+\n+@Ignore\n+public class TestGlueCatalogInteg {\n+\n+  private static final List<String> NAMESPACES = new ArrayList<>();\n+  private static final GlueClient GLUE = GlueClient.create();\n+  private static final S3Client S3 = S3Client.create();\n+  private static final String BUCKET = System.getenv(\"GLUE_BUCKET\");\n+  private static GlueCatalog glueCatalog;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    Configuration configuration = new Configuration();\n+    // Iceberg uses Hadoop 2.7.3, and the hadoop-aws module does not support reading environment variable yet\n+    configuration.set(\"fs.s3a.access.key\", System.getenv(\"AWS_ACCESS_KEY_ID\"));\n+    configuration.set(\"fs.s3a.secret.key\", System.getenv(\"AWS_SECRET_ACCESS_KEY\"));\n+    glueCatalog = new GlueCatalog(configuration, GLUE, null, \"s3a://\" + BUCKET);", "originalCommit": "a90dfa07d4285f46993dfcb22777801a55d7c4de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5OTIxMQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r510499211", "bodyText": "yeah that's a good idea, let me do that", "author": "jackye1995", "createdAt": "2020-10-22T22:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MDQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MDg0Mg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r510450842", "bodyText": "Nit: could directly be ops.current()", "author": "yyanyy", "createdAt": "2020-10-22T20:54:33Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String catalogName;\n+  private final String warehousePath;\n+\n+  /**\n+   * Constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = Preconditions.checkNotNull(conf, \"Cannot initialize GlueCatalog because Hadoop config is null\");\n+    this.glue = Preconditions.checkNotNull(glue, \"Cannot initialize GlueCatalog because GlueClient is null\");\n+    this.catalogId = catalogId;\n+    this.catalogName = \"glue.\" + catalogId; // for logging purpose\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Cannot initialize GlueCatalog because warehousePath must not be null\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Cannot initialize GlueCatalog because warehousePath %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new GlueTableOperations(conf, glue, catalogId, tableIdentifier);\n+  }\n+\n+  /**\n+   * This method produces the same result as using a HiveCatalog.\n+   * If databaseUri exists for the Glue database URI, the default location is databaseUri/tableName.\n+   * If not, the default location is warehousePath/databaseName.db/tableName\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.getDatabaseName(tableIdentifier))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.getDatabaseName(tableIdentifier),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    do {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+    } while (nextToken != null);\n+    LOG.debug(\"Listing of namespace: {} resulted in the following tables: {}\", namespace, results);\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      TableOperations ops = newTableOps(identifier);\n+      TableMetadata lastMetadata = ops.current() != null ? ops.current() : null;", "originalCommit": "a90dfa07d4285f46993dfcb22777801a55d7c4de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MjY5Mg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r510452692", "bodyText": "Sorry for coming back to this again, I wonder if it's worth adding a try catch block here and try recreating the old fromTable if this throws, so that for validation errors we didn't detect earlier or transient glue 5xx error we still could restore the table to the old state", "author": "yyanyy", "createdAt": "2020-10-22T20:57:54Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String catalogName;\n+  private final String warehousePath;\n+\n+  /**\n+   * Constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, String catalogId, String warehousePath) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   */\n+  public GlueCatalog(Configuration conf, GlueClient glue, String catalogId, String warehousePath) {\n+    this.conf = Preconditions.checkNotNull(conf, \"Cannot initialize GlueCatalog because Hadoop config is null\");\n+    this.glue = Preconditions.checkNotNull(glue, \"Cannot initialize GlueCatalog because GlueClient is null\");\n+    this.catalogId = catalogId;\n+    this.catalogName = \"glue.\" + catalogId; // for logging purpose\n+    this.warehousePath = warehousePath;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Cannot initialize GlueCatalog because warehousePath must not be null\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Cannot initialize GlueCatalog because warehousePath %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new GlueTableOperations(conf, glue, catalogId, tableIdentifier);\n+  }\n+\n+  /**\n+   * This method produces the same result as using a HiveCatalog.\n+   * If databaseUri exists for the Glue database URI, the default location is databaseUri/tableName.\n+   * If not, the default location is warehousePath/databaseName.db/tableName\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.getDatabaseName(tableIdentifier))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.getDatabaseName(tableIdentifier),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    do {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+    } while (nextToken != null);\n+    LOG.debug(\"Listing of namespace: {} resulted in the following tables: {}\", namespace, results);\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      TableOperations ops = newTableOps(identifier);\n+      TableMetadata lastMetadata = ops.current() != null ? ops.current() : null;\n+      glue.deleteTable(DeleteTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(identifier))\n+          .name(identifier.name())\n+          .build());\n+      LOG.info(\"Successfully dropped table {} from Glue\", identifier);\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Glue table {} data purged\", identifier);\n+      }\n+      LOG.info(\"Dropped table: {}\", identifier);\n+      return true;\n+    } catch (EntityNotFoundException e) {\n+      LOG.error(\"Cannot drop table {} because table not found or not accessible\", identifier, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Cannot complete drop table operation for {} due to unexpected exception\", identifier, e);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    // check new namespace exists\n+    if (!namespaceExists(to.namespace())) {\n+      throw new NoSuchNamespaceException(\"Cannot rename %s to %s because namespace %s does not exist\",\n+          from, to, to.namespace());\n+    }\n+    // keep metadata\n+    Table fromTable = null;\n+    try {\n+      GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(from))\n+          .name(IcebergToGlueConverter.getTableName(from))\n+          .build());\n+      fromTable = response.table();\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchTableException(e, \"Cannot rename %s because the table does not exist in Glue\", from);\n+    }\n+    dropTable(from, false);\n+    // use the same Glue info to create the new table, pointing to the old metadata\n+    glue.createTable(CreateTableRequest.builder()", "originalCommit": "a90dfa07d4285f46993dfcb22777801a55d7c4de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMDA3Ng==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r510500076", "bodyText": "sounds good, let me do that", "author": "jackye1995", "createdAt": "2020-10-22T22:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MjY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MzI5Mg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r510453292", "bodyText": "do we want to/is it easy to test the purge parameter?", "author": "yyanyy", "createdAt": "2020-10-22T20:59:01Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/TestGlueCatalogInteg.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.types.Types;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.Database;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.model.Delete;\n+import software.amazon.awssdk.services.s3.model.DeleteObjectsRequest;\n+import software.amazon.awssdk.services.s3.model.HeadObjectRequest;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\n+import software.amazon.awssdk.services.s3.model.ObjectIdentifier;\n+\n+@Ignore\n+public class TestGlueCatalogInteg {\n+\n+  private static final List<String> NAMESPACES = new ArrayList<>();\n+  private static final GlueClient GLUE = GlueClient.create();\n+  private static final S3Client S3 = S3Client.create();\n+  private static final String BUCKET = System.getenv(\"GLUE_BUCKET\");\n+  private static GlueCatalog glueCatalog;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    Configuration configuration = new Configuration();\n+    // Iceberg uses Hadoop 2.7.3, and the hadoop-aws module does not support reading environment variable yet\n+    configuration.set(\"fs.s3a.access.key\", System.getenv(\"AWS_ACCESS_KEY_ID\"));\n+    configuration.set(\"fs.s3a.secret.key\", System.getenv(\"AWS_SECRET_ACCESS_KEY\"));\n+    glueCatalog = new GlueCatalog(configuration, GLUE, null, \"s3a://\" + BUCKET);\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    for (String namespace : NAMESPACES) {\n+      try {\n+        // delete db also delete tables\n+        GLUE.deleteDatabase(DeleteDatabaseRequest.builder().name(namespace).build());\n+      } catch (Exception e) {\n+        // pass\n+      }\n+    }\n+    boolean hasContent = true;\n+    while (hasContent) {\n+      ListObjectsV2Response response = S3.listObjectsV2(ListObjectsV2Request.builder().bucket(BUCKET).build());\n+      hasContent = response.hasContents();\n+      if (hasContent) {\n+        S3.deleteObjects(DeleteObjectsRequest.builder().bucket(BUCKET).delete(Delete.builder().objects(\n+            response.contents().stream()\n+                .map(obj -> ObjectIdentifier.builder().key(obj.key()).build())\n+                .collect(Collectors.toList())\n+        ).build()).build());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testNamespace() {\n+    // create ns\n+    String namespace = getRandomName();\n+    NAMESPACES.add(namespace);\n+    glueCatalog.createNamespace(Namespace.of(namespace));\n+    Database database = GLUE.getDatabase(GetDatabaseRequest.builder().name(namespace).build()).database();\n+    Assert.assertEquals(namespace, database.name());\n+    // list all\n+    List<Namespace> namespaceList = glueCatalog.listNamespaces();\n+    Assert.assertTrue(namespaceList.size() > 0);\n+    Assert.assertTrue(namespaceList.contains(Namespace.of(namespace)));\n+    // list self\n+    namespaceList = glueCatalog.listNamespaces(Namespace.of(namespace));\n+    Assert.assertEquals(1, namespaceList.size());\n+    Assert.assertEquals(namespace, IcebergToGlueConverter.toDatabaseName(namespaceList.get(0)));\n+    Map<String, String> properties = new HashMap<>();\n+    properties.put(\"key\", \"val\");\n+    properties.put(\"key2\", \"val2\");\n+    // set properties\n+    glueCatalog.setProperties(Namespace.of(namespace), properties);\n+    database = GLUE.getDatabase(GetDatabaseRequest.builder().name(namespace).build()).database();\n+    Assert.assertTrue(database.parameters().containsKey(\"key\"));\n+    Assert.assertEquals(\"val\", database.parameters().get(\"key\"));\n+    Assert.assertTrue(database.parameters().containsKey(\"key2\"));\n+    Assert.assertEquals(\"val2\", database.parameters().get(\"key2\"));\n+    // remove properties\n+    glueCatalog.removeProperties(Namespace.of(namespace), Sets.newHashSet(\"key\"));\n+    database = GLUE.getDatabase(GetDatabaseRequest.builder().name(namespace).build()).database();\n+    Assert.assertFalse(database.parameters().containsKey(\"key\"));\n+    Assert.assertTrue(database.parameters().containsKey(\"key2\"));\n+    Assert.assertEquals(\"val2\", database.parameters().get(\"key2\"));\n+    // add back property\n+    properties = new HashMap<>();\n+    properties.put(\"key\", \"val\");\n+    glueCatalog.setProperties(Namespace.of(namespace), properties);\n+    database = GLUE.getDatabase(GetDatabaseRequest.builder().name(namespace).build()).database();\n+    Assert.assertTrue(database.parameters().containsKey(\"key\"));\n+    Assert.assertEquals(\"val\", database.parameters().get(\"key\"));\n+    Assert.assertTrue(database.parameters().containsKey(\"key2\"));\n+    Assert.assertEquals(\"val2\", database.parameters().get(\"key2\"));\n+    // duplicate\n+    AssertHelpers.assertThrows(\"should not create namespace with the same name\",\n+        AlreadyExistsException.class,\n+        () -> glueCatalog.createNamespace(Namespace.of(namespace)));\n+    // bad name\n+    AssertHelpers.assertThrows(\"should not create namespace with bad name\",\n+        NoSuchNamespaceException.class,\n+        () -> glueCatalog.createNamespace(Namespace.of(\"db-1\")));\n+    // drop namespace\n+    glueCatalog.dropNamespace(Namespace.of(namespace));\n+    AssertHelpers.assertThrows(\"namespace should not exist after deletion\",\n+        EntityNotFoundException.class,\n+        () -> GLUE.getDatabase(GetDatabaseRequest.builder().name(namespace).build()));\n+  }\n+\n+  @Test\n+  public void testCreateTable() {\n+    // create ns\n+    String namespace = getRandomName();\n+    NAMESPACES.add(namespace);\n+    glueCatalog.createNamespace(Namespace.of(namespace));\n+    // exists\n+    Assert.assertTrue(glueCatalog.namespaceExists(Namespace.of(namespace)));\n+    // list table should have nothing\n+    Assert.assertTrue(glueCatalog.listTables(Namespace.of(namespace)).isEmpty());\n+    // create table\n+    Schema schema = new Schema(Types.NestedField.required(1, \"c1\", Types.StringType.get(), \"c1\"));\n+    PartitionSpec partitionSpec = PartitionSpec.builderFor(schema).build();\n+    String tableName = getRandomName();\n+    glueCatalog.createTable(TableIdentifier.of(namespace, tableName), schema, partitionSpec);\n+    GetTableResponse response = GLUE.getTable(GetTableRequest.builder()\n+        .databaseName(namespace).name(tableName).build());\n+    Assert.assertEquals(namespace, response.table().databaseName());\n+    Assert.assertEquals(tableName, response.table().name());\n+    Assert.assertEquals(BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.toUpperCase(Locale.ENGLISH),\n+        response.table().parameters().get(BaseMetastoreTableOperations.TABLE_TYPE_PROP));\n+    Assert.assertTrue(response.table().parameters().containsKey(BaseMetastoreTableOperations.METADATA_LOCATION_PROP));\n+    String metaLocation = response.table().parameters().get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP);\n+    String key = metaLocation.split(BUCKET)[1].substring(1);\n+    S3.headObject(HeadObjectRequest.builder().bucket(BUCKET).key(key).build());\n+    // exists\n+    Assert.assertTrue(glueCatalog.tableExists(TableIdentifier.of(namespace, tableName)));\n+    // load\n+    Table table = glueCatalog.loadTable(TableIdentifier.of(namespace, tableName));\n+    Assert.assertEquals(partitionSpec, table.spec());\n+    Assert.assertEquals(schema.toString(), table.schema().toString());\n+    // list table should show\n+    List<TableIdentifier> tables = glueCatalog.listTables(Namespace.of(namespace));\n+    Assert.assertEquals(1, tables.size());\n+    Assert.assertEquals(TableIdentifier.of(namespace, tableName), tables.get(0));\n+    // duplicate\n+    AssertHelpers.assertThrows(\"should not create table with the same name\",\n+        AlreadyExistsException.class,\n+        () -> glueCatalog.createTable(TableIdentifier.of(namespace, tableName), schema, partitionSpec));\n+    // bad name\n+    AssertHelpers.assertThrows(\"should not create table with bad name\",\n+        IllegalArgumentException.class,\n+        () -> glueCatalog.createTable(TableIdentifier.of(namespace, \"table-1\"), schema, partitionSpec));\n+    // drop\n+    glueCatalog.dropTable(TableIdentifier.of(namespace, tableName));", "originalCommit": "a90dfa07d4285f46993dfcb22777801a55d7c4de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMDIwNA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r510500204", "bodyText": "yes I can add that test", "author": "jackye1995", "createdAt": "2020-10-22T22:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MzI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU5OTQyMg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513599422", "bodyText": "Why not just remove the trailing /?", "author": "rdblue", "createdAt": "2020-10-28T16:44:27Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.IcebergAWSConfigs;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.awscore.exception.AwsServiceException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String catalogName;\n+  private final String warehousePath;\n+  private final boolean skipArchive;\n+\n+  /**\n+   * Constructor that initializes all args from Hadoop configuration, used by engines like Spark and Flink\n+   * @param conf Hadoop config passed from engines\n+   */\n+  public GlueCatalog(Configuration conf) {\n+    this(\n+        conf,\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_CATALOG_ID),\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_WAREHOUSE_PATH),\n+        conf.getBoolean(IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE,\n+            IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE_DEFAULT)\n+    );\n+  }\n+\n+  /**\n+   * Constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath, skipArchive);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this.conf = Preconditions.checkNotNull(conf, \"Cannot initialize GlueCatalog because Hadoop config is null\");\n+    this.glue = Preconditions.checkNotNull(glue, \"Cannot initialize GlueCatalog because GlueClient is null\");\n+    this.catalogId = catalogId;\n+    this.catalogName = \"glue.\" + catalogId; // for logging purpose\n+    this.warehousePath = warehousePath;\n+    this.skipArchive = skipArchive;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Cannot initialize GlueCatalog because warehousePath must not be null\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Cannot initialize GlueCatalog because warehousePath %s must not end with /\", warehousePath);", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5MTkxMg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513691912", "bodyText": "yeah that's actually better, let me do that", "author": "jackye1995", "createdAt": "2020-10-28T19:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU5OTQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwMDIxOA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513600218", "bodyText": "Nit: we like to use an empty line after control flow statements to space out blocks a bit more.", "author": "rdblue", "createdAt": "2020-10-28T16:45:31Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.IcebergAWSConfigs;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.awscore.exception.AwsServiceException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String catalogName;\n+  private final String warehousePath;\n+  private final boolean skipArchive;\n+\n+  /**\n+   * Constructor that initializes all args from Hadoop configuration, used by engines like Spark and Flink\n+   * @param conf Hadoop config passed from engines\n+   */\n+  public GlueCatalog(Configuration conf) {\n+    this(\n+        conf,\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_CATALOG_ID),\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_WAREHOUSE_PATH),\n+        conf.getBoolean(IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE,\n+            IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE_DEFAULT)\n+    );\n+  }\n+\n+  /**\n+   * Constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath, skipArchive);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this.conf = Preconditions.checkNotNull(conf, \"Cannot initialize GlueCatalog because Hadoop config is null\");\n+    this.glue = Preconditions.checkNotNull(glue, \"Cannot initialize GlueCatalog because GlueClient is null\");\n+    this.catalogId = catalogId;\n+    this.catalogName = \"glue.\" + catalogId; // for logging purpose\n+    this.warehousePath = warehousePath;\n+    this.skipArchive = skipArchive;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Cannot initialize GlueCatalog because warehousePath must not be null\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Cannot initialize GlueCatalog because warehousePath %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new GlueTableOperations(conf, glue, catalogId, skipArchive, tableIdentifier);\n+  }\n+\n+  /**\n+   * This method produces the same result as using a HiveCatalog.\n+   * If databaseUri exists for the Glue database URI, the default location is databaseUri/tableName.\n+   * If not, the default location is warehousePath/databaseName.db/tableName\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.getDatabaseName(tableIdentifier))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+    return String.format(", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwNDE1OQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513604159", "bodyText": "Looks like this is needed in a lot of places.", "author": "rdblue", "createdAt": "2020-10-28T16:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwMDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5MjEzNw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513692137", "bodyText": "sure, will update", "author": "jackye1995", "createdAt": "2020-10-28T19:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwMDIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMDY5NQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513610695", "bodyText": "Shouldn't this be an empty list? A namespace doesn't contain itself.", "author": "rdblue", "createdAt": "2020-10-28T16:59:28Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.IcebergAWSConfigs;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.awscore.exception.AwsServiceException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String catalogName;\n+  private final String warehousePath;\n+  private final boolean skipArchive;\n+\n+  /**\n+   * Constructor that initializes all args from Hadoop configuration, used by engines like Spark and Flink\n+   * @param conf Hadoop config passed from engines\n+   */\n+  public GlueCatalog(Configuration conf) {\n+    this(\n+        conf,\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_CATALOG_ID),\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_WAREHOUSE_PATH),\n+        conf.getBoolean(IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE,\n+            IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE_DEFAULT)\n+    );\n+  }\n+\n+  /**\n+   * Constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath, skipArchive);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this.conf = Preconditions.checkNotNull(conf, \"Cannot initialize GlueCatalog because Hadoop config is null\");\n+    this.glue = Preconditions.checkNotNull(glue, \"Cannot initialize GlueCatalog because GlueClient is null\");\n+    this.catalogId = catalogId;\n+    this.catalogName = \"glue.\" + catalogId; // for logging purpose\n+    this.warehousePath = warehousePath;\n+    this.skipArchive = skipArchive;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Cannot initialize GlueCatalog because warehousePath must not be null\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Cannot initialize GlueCatalog because warehousePath %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new GlueTableOperations(conf, glue, catalogId, skipArchive, tableIdentifier);\n+  }\n+\n+  /**\n+   * This method produces the same result as using a HiveCatalog.\n+   * If databaseUri exists for the Glue database URI, the default location is databaseUri/tableName.\n+   * If not, the default location is warehousePath/databaseName.db/tableName\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.getDatabaseName(tableIdentifier))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.getDatabaseName(tableIdentifier),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    do {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+    } while (nextToken != null);\n+    LOG.debug(\"Listing of namespace: {} resulted in the following tables: {}\", namespace, results);\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      TableOperations ops = newTableOps(identifier);\n+      TableMetadata lastMetadata = ops.current();\n+      glue.deleteTable(DeleteTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(identifier))\n+          .name(identifier.name())\n+          .build());\n+      LOG.info(\"Successfully dropped table {} from Glue\", identifier);\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Glue table {} data purged\", identifier);\n+      }\n+      LOG.info(\"Dropped table: {}\", identifier);\n+      return true;\n+    } catch (EntityNotFoundException e) {\n+      LOG.error(\"Cannot drop table {} because table not found or not accessible\", identifier, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Cannot complete drop table operation for {} due to unexpected exception\", identifier, e);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    // check new namespace exists\n+    if (!namespaceExists(to.namespace())) {\n+      throw new NoSuchNamespaceException(\"Cannot rename %s to %s because namespace %s does not exist\",\n+          from, to, to.namespace());\n+    }\n+    // keep metadata\n+    Table fromTable = null;\n+    String fromTableDbName = IcebergToGlueConverter.getDatabaseName(from);\n+    String fromTableName = IcebergToGlueConverter.getTableName(from);\n+    try {\n+      GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(fromTableDbName)\n+          .name(fromTableName)\n+          .build());\n+      fromTable = response.table();\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchTableException(e, \"Cannot rename %s because the table does not exist in Glue\", from);\n+    }\n+    dropTable(from, false);\n+    // use the same Glue info to create the new table, pointing to the old metadata\n+    TableInput.Builder tableInputBuilder = TableInput.builder()\n+        .owner(fromTable.owner())\n+        .tableType(fromTable.tableType())\n+        .parameters(fromTable.parameters());\n+    try {\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(to))\n+          .tableInput(tableInputBuilder.name(IcebergToGlueConverter.getTableName(to)).build())\n+          .build());\n+      LOG.info(\"Renamed table from {} to {}\", from, to);\n+    } catch (AwsServiceException | NoSuchTableException e) {\n+      // rollback, recreate old table and rethrow exception\n+      LOG.error(\"Fail to rename table from {} to {}, rollback the old table\", from, to, e);\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(fromTableDbName)\n+          .tableInput(tableInputBuilder.name(fromTableName).build())\n+          .build());\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    try {\n+      glue.createDatabase(CreateDatabaseRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseInput(IcebergToGlueConverter.toDatabaseInput(namespace, metadata))\n+          .build());\n+      LOG.info(\"Created namespace: {}\", namespace);\n+    } catch (software.amazon.awssdk.services.glue.model.AlreadyExistsException e) {\n+      throw new AlreadyExistsException(\"Cannot create namespace %s because it already exists in Glue\", namespace);\n+    }\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespace.isEmpty()) {\n+      // if it is not a list all op, just check if the namespace exists and return itself.\n+      if (namespaceExists(namespace)) {\n+        return Lists.newArrayList(namespace);", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5MjM0MQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513692341", "bodyText": "okay my misunderstanding, will fix", "author": "jackye1995", "createdAt": "2020-10-28T19:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMDY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMTI0Ng==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513611246", "bodyText": "Nit: we generally prefer factory methods like Lists.newArrayList() over specific list type constructors.", "author": "rdblue", "createdAt": "2020-10-28T17:00:13Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.IcebergAWSConfigs;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.awscore.exception.AwsServiceException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String catalogName;\n+  private final String warehousePath;\n+  private final boolean skipArchive;\n+\n+  /**\n+   * Constructor that initializes all args from Hadoop configuration, used by engines like Spark and Flink\n+   * @param conf Hadoop config passed from engines\n+   */\n+  public GlueCatalog(Configuration conf) {\n+    this(\n+        conf,\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_CATALOG_ID),\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_WAREHOUSE_PATH),\n+        conf.getBoolean(IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE,\n+            IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE_DEFAULT)\n+    );\n+  }\n+\n+  /**\n+   * Constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath, skipArchive);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this.conf = Preconditions.checkNotNull(conf, \"Cannot initialize GlueCatalog because Hadoop config is null\");\n+    this.glue = Preconditions.checkNotNull(glue, \"Cannot initialize GlueCatalog because GlueClient is null\");\n+    this.catalogId = catalogId;\n+    this.catalogName = \"glue.\" + catalogId; // for logging purpose\n+    this.warehousePath = warehousePath;\n+    this.skipArchive = skipArchive;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Cannot initialize GlueCatalog because warehousePath must not be null\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Cannot initialize GlueCatalog because warehousePath %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new GlueTableOperations(conf, glue, catalogId, skipArchive, tableIdentifier);\n+  }\n+\n+  /**\n+   * This method produces the same result as using a HiveCatalog.\n+   * If databaseUri exists for the Glue database URI, the default location is databaseUri/tableName.\n+   * If not, the default location is warehousePath/databaseName.db/tableName\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.getDatabaseName(tableIdentifier))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.getDatabaseName(tableIdentifier),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    do {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+    } while (nextToken != null);\n+    LOG.debug(\"Listing of namespace: {} resulted in the following tables: {}\", namespace, results);\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      TableOperations ops = newTableOps(identifier);\n+      TableMetadata lastMetadata = ops.current();\n+      glue.deleteTable(DeleteTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(identifier))\n+          .name(identifier.name())\n+          .build());\n+      LOG.info(\"Successfully dropped table {} from Glue\", identifier);\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Glue table {} data purged\", identifier);\n+      }\n+      LOG.info(\"Dropped table: {}\", identifier);\n+      return true;\n+    } catch (EntityNotFoundException e) {\n+      LOG.error(\"Cannot drop table {} because table not found or not accessible\", identifier, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Cannot complete drop table operation for {} due to unexpected exception\", identifier, e);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    // check new namespace exists\n+    if (!namespaceExists(to.namespace())) {\n+      throw new NoSuchNamespaceException(\"Cannot rename %s to %s because namespace %s does not exist\",\n+          from, to, to.namespace());\n+    }\n+    // keep metadata\n+    Table fromTable = null;\n+    String fromTableDbName = IcebergToGlueConverter.getDatabaseName(from);\n+    String fromTableName = IcebergToGlueConverter.getTableName(from);\n+    try {\n+      GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(fromTableDbName)\n+          .name(fromTableName)\n+          .build());\n+      fromTable = response.table();\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchTableException(e, \"Cannot rename %s because the table does not exist in Glue\", from);\n+    }\n+    dropTable(from, false);\n+    // use the same Glue info to create the new table, pointing to the old metadata\n+    TableInput.Builder tableInputBuilder = TableInput.builder()\n+        .owner(fromTable.owner())\n+        .tableType(fromTable.tableType())\n+        .parameters(fromTable.parameters());\n+    try {\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(to))\n+          .tableInput(tableInputBuilder.name(IcebergToGlueConverter.getTableName(to)).build())\n+          .build());\n+      LOG.info(\"Renamed table from {} to {}\", from, to);\n+    } catch (AwsServiceException | NoSuchTableException e) {\n+      // rollback, recreate old table and rethrow exception\n+      LOG.error(\"Fail to rename table from {} to {}, rollback the old table\", from, to, e);\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(fromTableDbName)\n+          .tableInput(tableInputBuilder.name(fromTableName).build())\n+          .build());\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    try {\n+      glue.createDatabase(CreateDatabaseRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseInput(IcebergToGlueConverter.toDatabaseInput(namespace, metadata))\n+          .build());\n+      LOG.info(\"Created namespace: {}\", namespace);\n+    } catch (software.amazon.awssdk.services.glue.model.AlreadyExistsException e) {\n+      throw new AlreadyExistsException(\"Cannot create namespace %s because it already exists in Glue\", namespace);\n+    }\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespace.isEmpty()) {\n+      // if it is not a list all op, just check if the namespace exists and return itself.\n+      if (namespaceExists(namespace)) {\n+        return Lists.newArrayList(namespace);\n+      }\n+      throw new NoSuchNamespaceException(\n+          \"Glue does not support nested namespace, cannot list namespaces under %s\", namespace);\n+    }\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<Namespace> results = new ArrayList<>();", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMjEzMg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513612132", "bodyText": "I think this needs an else to set nextToken = null and exit the loop. Otherwise, a response with no database list for a non-null token would cause an infinite loop because the token never changes.", "author": "rdblue", "createdAt": "2020-10-28T17:01:27Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.IcebergAWSConfigs;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.awscore.exception.AwsServiceException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String catalogName;\n+  private final String warehousePath;\n+  private final boolean skipArchive;\n+\n+  /**\n+   * Constructor that initializes all args from Hadoop configuration, used by engines like Spark and Flink\n+   * @param conf Hadoop config passed from engines\n+   */\n+  public GlueCatalog(Configuration conf) {\n+    this(\n+        conf,\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_CATALOG_ID),\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_WAREHOUSE_PATH),\n+        conf.getBoolean(IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE,\n+            IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE_DEFAULT)\n+    );\n+  }\n+\n+  /**\n+   * Constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath, skipArchive);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this.conf = Preconditions.checkNotNull(conf, \"Cannot initialize GlueCatalog because Hadoop config is null\");\n+    this.glue = Preconditions.checkNotNull(glue, \"Cannot initialize GlueCatalog because GlueClient is null\");\n+    this.catalogId = catalogId;\n+    this.catalogName = \"glue.\" + catalogId; // for logging purpose\n+    this.warehousePath = warehousePath;\n+    this.skipArchive = skipArchive;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Cannot initialize GlueCatalog because warehousePath must not be null\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Cannot initialize GlueCatalog because warehousePath %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new GlueTableOperations(conf, glue, catalogId, skipArchive, tableIdentifier);\n+  }\n+\n+  /**\n+   * This method produces the same result as using a HiveCatalog.\n+   * If databaseUri exists for the Glue database URI, the default location is databaseUri/tableName.\n+   * If not, the default location is warehousePath/databaseName.db/tableName\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.getDatabaseName(tableIdentifier))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.getDatabaseName(tableIdentifier),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    do {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+    } while (nextToken != null);\n+    LOG.debug(\"Listing of namespace: {} resulted in the following tables: {}\", namespace, results);\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      TableOperations ops = newTableOps(identifier);\n+      TableMetadata lastMetadata = ops.current();\n+      glue.deleteTable(DeleteTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(identifier))\n+          .name(identifier.name())\n+          .build());\n+      LOG.info(\"Successfully dropped table {} from Glue\", identifier);\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Glue table {} data purged\", identifier);\n+      }\n+      LOG.info(\"Dropped table: {}\", identifier);\n+      return true;\n+    } catch (EntityNotFoundException e) {\n+      LOG.error(\"Cannot drop table {} because table not found or not accessible\", identifier, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Cannot complete drop table operation for {} due to unexpected exception\", identifier, e);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    // check new namespace exists\n+    if (!namespaceExists(to.namespace())) {\n+      throw new NoSuchNamespaceException(\"Cannot rename %s to %s because namespace %s does not exist\",\n+          from, to, to.namespace());\n+    }\n+    // keep metadata\n+    Table fromTable = null;\n+    String fromTableDbName = IcebergToGlueConverter.getDatabaseName(from);\n+    String fromTableName = IcebergToGlueConverter.getTableName(from);\n+    try {\n+      GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(fromTableDbName)\n+          .name(fromTableName)\n+          .build());\n+      fromTable = response.table();\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchTableException(e, \"Cannot rename %s because the table does not exist in Glue\", from);\n+    }\n+    dropTable(from, false);\n+    // use the same Glue info to create the new table, pointing to the old metadata\n+    TableInput.Builder tableInputBuilder = TableInput.builder()\n+        .owner(fromTable.owner())\n+        .tableType(fromTable.tableType())\n+        .parameters(fromTable.parameters());\n+    try {\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(to))\n+          .tableInput(tableInputBuilder.name(IcebergToGlueConverter.getTableName(to)).build())\n+          .build());\n+      LOG.info(\"Renamed table from {} to {}\", from, to);\n+    } catch (AwsServiceException | NoSuchTableException e) {\n+      // rollback, recreate old table and rethrow exception\n+      LOG.error(\"Fail to rename table from {} to {}, rollback the old table\", from, to, e);\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(fromTableDbName)\n+          .tableInput(tableInputBuilder.name(fromTableName).build())\n+          .build());\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    try {\n+      glue.createDatabase(CreateDatabaseRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseInput(IcebergToGlueConverter.toDatabaseInput(namespace, metadata))\n+          .build());\n+      LOG.info(\"Created namespace: {}\", namespace);\n+    } catch (software.amazon.awssdk.services.glue.model.AlreadyExistsException e) {\n+      throw new AlreadyExistsException(\"Cannot create namespace %s because it already exists in Glue\", namespace);\n+    }\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespace.isEmpty()) {\n+      // if it is not a list all op, just check if the namespace exists and return itself.\n+      if (namespaceExists(namespace)) {\n+        return Lists.newArrayList(namespace);\n+      }\n+      throw new NoSuchNamespaceException(\n+          \"Glue does not support nested namespace, cannot list namespaces under %s\", namespace);\n+    }\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<Namespace> results = new ArrayList<>();\n+    do {\n+      GetDatabasesResponse response = glue.getDatabases(GetDatabasesRequest.builder()\n+          .catalogId(catalogId)\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasDatabaseList()) {", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMzAxMA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513613010", "bodyText": "Does this need to check whether the namespace is empty?", "author": "rdblue", "createdAt": "2020-10-28T17:02:43Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.IcebergAWSConfigs;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.awscore.exception.AwsServiceException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String catalogName;\n+  private final String warehousePath;\n+  private final boolean skipArchive;\n+\n+  /**\n+   * Constructor that initializes all args from Hadoop configuration, used by engines like Spark and Flink\n+   * @param conf Hadoop config passed from engines\n+   */\n+  public GlueCatalog(Configuration conf) {\n+    this(\n+        conf,\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_CATALOG_ID),\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_WAREHOUSE_PATH),\n+        conf.getBoolean(IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE,\n+            IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE_DEFAULT)\n+    );\n+  }\n+\n+  /**\n+   * Constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath, skipArchive);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this.conf = Preconditions.checkNotNull(conf, \"Cannot initialize GlueCatalog because Hadoop config is null\");\n+    this.glue = Preconditions.checkNotNull(glue, \"Cannot initialize GlueCatalog because GlueClient is null\");\n+    this.catalogId = catalogId;\n+    this.catalogName = \"glue.\" + catalogId; // for logging purpose\n+    this.warehousePath = warehousePath;\n+    this.skipArchive = skipArchive;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Cannot initialize GlueCatalog because warehousePath must not be null\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Cannot initialize GlueCatalog because warehousePath %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new GlueTableOperations(conf, glue, catalogId, skipArchive, tableIdentifier);\n+  }\n+\n+  /**\n+   * This method produces the same result as using a HiveCatalog.\n+   * If databaseUri exists for the Glue database URI, the default location is databaseUri/tableName.\n+   * If not, the default location is warehousePath/databaseName.db/tableName\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.getDatabaseName(tableIdentifier))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.getDatabaseName(tableIdentifier),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    do {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+    } while (nextToken != null);\n+    LOG.debug(\"Listing of namespace: {} resulted in the following tables: {}\", namespace, results);\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      TableOperations ops = newTableOps(identifier);\n+      TableMetadata lastMetadata = ops.current();\n+      glue.deleteTable(DeleteTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(identifier))\n+          .name(identifier.name())\n+          .build());\n+      LOG.info(\"Successfully dropped table {} from Glue\", identifier);\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Glue table {} data purged\", identifier);\n+      }\n+      LOG.info(\"Dropped table: {}\", identifier);\n+      return true;\n+    } catch (EntityNotFoundException e) {\n+      LOG.error(\"Cannot drop table {} because table not found or not accessible\", identifier, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Cannot complete drop table operation for {} due to unexpected exception\", identifier, e);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    // check new namespace exists\n+    if (!namespaceExists(to.namespace())) {\n+      throw new NoSuchNamespaceException(\"Cannot rename %s to %s because namespace %s does not exist\",\n+          from, to, to.namespace());\n+    }\n+    // keep metadata\n+    Table fromTable = null;\n+    String fromTableDbName = IcebergToGlueConverter.getDatabaseName(from);\n+    String fromTableName = IcebergToGlueConverter.getTableName(from);\n+    try {\n+      GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(fromTableDbName)\n+          .name(fromTableName)\n+          .build());\n+      fromTable = response.table();\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchTableException(e, \"Cannot rename %s because the table does not exist in Glue\", from);\n+    }\n+    dropTable(from, false);\n+    // use the same Glue info to create the new table, pointing to the old metadata\n+    TableInput.Builder tableInputBuilder = TableInput.builder()\n+        .owner(fromTable.owner())\n+        .tableType(fromTable.tableType())\n+        .parameters(fromTable.parameters());\n+    try {\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(to))\n+          .tableInput(tableInputBuilder.name(IcebergToGlueConverter.getTableName(to)).build())\n+          .build());\n+      LOG.info(\"Renamed table from {} to {}\", from, to);\n+    } catch (AwsServiceException | NoSuchTableException e) {\n+      // rollback, recreate old table and rethrow exception\n+      LOG.error(\"Fail to rename table from {} to {}, rollback the old table\", from, to, e);\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(fromTableDbName)\n+          .tableInput(tableInputBuilder.name(fromTableName).build())\n+          .build());\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    try {\n+      glue.createDatabase(CreateDatabaseRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseInput(IcebergToGlueConverter.toDatabaseInput(namespace, metadata))\n+          .build());\n+      LOG.info(\"Created namespace: {}\", namespace);\n+    } catch (software.amazon.awssdk.services.glue.model.AlreadyExistsException e) {\n+      throw new AlreadyExistsException(\"Cannot create namespace %s because it already exists in Glue\", namespace);\n+    }\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespace.isEmpty()) {\n+      // if it is not a list all op, just check if the namespace exists and return itself.\n+      if (namespaceExists(namespace)) {\n+        return Lists.newArrayList(namespace);\n+      }\n+      throw new NoSuchNamespaceException(\n+          \"Glue does not support nested namespace, cannot list namespaces under %s\", namespace);\n+    }\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<Namespace> results = new ArrayList<>();\n+    do {\n+      GetDatabasesResponse response = glue.getDatabases(GetDatabasesRequest.builder()\n+          .catalogId(catalogId)\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasDatabaseList()) {\n+        results.addAll(response.databaseList().stream()\n+            .map(GlueToIcebergConverter::toNamespace)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+    } while (nextToken != null);\n+    LOG.debug(\"Listing namespace {} returned namespaces: {}\", namespace, results);\n+    return results;\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    String databaseName = IcebergToGlueConverter.toDatabaseName(namespace);\n+    try {\n+      GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+          .catalogId(catalogId)\n+          .name(databaseName)\n+          .build());\n+      Map<String, String> result = response.database().parameters();\n+      LOG.debug(\"Loaded metadata for namespace {} found {}\", namespace, result);\n+      return result;\n+    } catch (InvalidInputException e) {\n+      throw new NoSuchNamespaceException(\"invalid input for namespace %s, error message: %s\",\n+          namespace, e.getMessage());\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchNamespaceException(\"fail to find Glue database for namespace %s, error message: %s\",\n+          databaseName, e.getMessage());\n+    }\n+  }\n+\n+  @Override\n+  public boolean dropNamespace(Namespace namespace) throws NamespaceNotEmptyException {\n+    namespaceExists(namespace);\n+    List<TableIdentifier> tableIdentifiers = listTables(namespace);", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5MzQ4OQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513693489", "bodyText": "yeah, that's why I try to list all tables of the namespace.", "author": "jackye1995", "createdAt": "2020-10-28T19:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMzAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NDk2OQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525644969", "bodyText": "I mean whether the namespace is Namespace.of() and has no components. I think loadNamespace should handle it in the call to toDatabaseName, which ends up calling checkNamespace.", "author": "rdblue", "createdAt": "2020-11-18T01:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMzAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNDY2Mw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513614663", "bodyText": "This name isn't very descriptive. It seems to mean \"a parameter that will be passed somewhere\", but doesn't describe what the object is. I think a better name would be newProperties or similar. That fits the conventions we use elsewhere.", "author": "rdblue", "createdAt": "2020-10-28T17:05:00Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.IcebergAWSConfigs;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.awscore.exception.AwsServiceException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String catalogName;\n+  private final String warehousePath;\n+  private final boolean skipArchive;\n+\n+  /**\n+   * Constructor that initializes all args from Hadoop configuration, used by engines like Spark and Flink\n+   * @param conf Hadoop config passed from engines\n+   */\n+  public GlueCatalog(Configuration conf) {\n+    this(\n+        conf,\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_CATALOG_ID),\n+        conf.get(IcebergAWSConfigs.ICEBERG_AWS_GLUE_WAREHOUSE_PATH),\n+        conf.getBoolean(IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE,\n+            IcebergAWSConfigs.ICEBERG_AWS_GLUE_SKIP_ARCHIVE_DEFAULT)\n+    );\n+  }\n+\n+  /**\n+   * Constructor with default glue client\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this(conf, GlueClient.create(), catalogId, warehousePath, skipArchive);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return catalogName;\n+  }\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   */\n+  public GlueCatalog(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      String warehousePath,\n+      boolean skipArchive) {\n+    this.conf = Preconditions.checkNotNull(conf, \"Cannot initialize GlueCatalog because Hadoop config is null\");\n+    this.glue = Preconditions.checkNotNull(glue, \"Cannot initialize GlueCatalog because GlueClient is null\");\n+    this.catalogId = catalogId;\n+    this.catalogName = \"glue.\" + catalogId; // for logging purpose\n+    this.warehousePath = warehousePath;\n+    this.skipArchive = skipArchive;\n+    validateWarehousePath();\n+  }\n+\n+  private void validateWarehousePath() {\n+    Preconditions.checkArgument(warehousePath != null && warehousePath.length() > 0,\n+        \"Cannot initialize GlueCatalog because warehousePath must not be null\");\n+    Preconditions.checkArgument(warehousePath.charAt(warehousePath.length() - 1) != '/',\n+        \"Cannot initialize GlueCatalog because warehousePath %s must not end with /\", warehousePath);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    glue.close();\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new GlueTableOperations(conf, glue, catalogId, skipArchive, tableIdentifier);\n+  }\n+\n+  /**\n+   * This method produces the same result as using a HiveCatalog.\n+   * If databaseUri exists for the Glue database URI, the default location is databaseUri/tableName.\n+   * If not, the default location is warehousePath/databaseName.db/tableName\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.getDatabaseName(tableIdentifier))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.getDatabaseName(tableIdentifier),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = new ArrayList<>();\n+    do {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+    } while (nextToken != null);\n+    LOG.debug(\"Listing of namespace: {} resulted in the following tables: {}\", namespace, results);\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      TableOperations ops = newTableOps(identifier);\n+      TableMetadata lastMetadata = ops.current();\n+      glue.deleteTable(DeleteTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(identifier))\n+          .name(identifier.name())\n+          .build());\n+      LOG.info(\"Successfully dropped table {} from Glue\", identifier);\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Glue table {} data purged\", identifier);\n+      }\n+      LOG.info(\"Dropped table: {}\", identifier);\n+      return true;\n+    } catch (EntityNotFoundException e) {\n+      LOG.error(\"Cannot drop table {} because table not found or not accessible\", identifier, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Cannot complete drop table operation for {} due to unexpected exception\", identifier, e);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    // check new namespace exists\n+    if (!namespaceExists(to.namespace())) {\n+      throw new NoSuchNamespaceException(\"Cannot rename %s to %s because namespace %s does not exist\",\n+          from, to, to.namespace());\n+    }\n+    // keep metadata\n+    Table fromTable = null;\n+    String fromTableDbName = IcebergToGlueConverter.getDatabaseName(from);\n+    String fromTableName = IcebergToGlueConverter.getTableName(from);\n+    try {\n+      GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(fromTableDbName)\n+          .name(fromTableName)\n+          .build());\n+      fromTable = response.table();\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchTableException(e, \"Cannot rename %s because the table does not exist in Glue\", from);\n+    }\n+    dropTable(from, false);\n+    // use the same Glue info to create the new table, pointing to the old metadata\n+    TableInput.Builder tableInputBuilder = TableInput.builder()\n+        .owner(fromTable.owner())\n+        .tableType(fromTable.tableType())\n+        .parameters(fromTable.parameters());\n+    try {\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(to))\n+          .tableInput(tableInputBuilder.name(IcebergToGlueConverter.getTableName(to)).build())\n+          .build());\n+      LOG.info(\"Renamed table from {} to {}\", from, to);\n+    } catch (AwsServiceException | NoSuchTableException e) {\n+      // rollback, recreate old table and rethrow exception\n+      LOG.error(\"Fail to rename table from {} to {}, rollback the old table\", from, to, e);\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(fromTableDbName)\n+          .tableInput(tableInputBuilder.name(fromTableName).build())\n+          .build());\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void createNamespace(Namespace namespace, Map<String, String> metadata) {\n+    try {\n+      glue.createDatabase(CreateDatabaseRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseInput(IcebergToGlueConverter.toDatabaseInput(namespace, metadata))\n+          .build());\n+      LOG.info(\"Created namespace: {}\", namespace);\n+    } catch (software.amazon.awssdk.services.glue.model.AlreadyExistsException e) {\n+      throw new AlreadyExistsException(\"Cannot create namespace %s because it already exists in Glue\", namespace);\n+    }\n+  }\n+\n+  @Override\n+  public List<Namespace> listNamespaces(Namespace namespace) throws NoSuchNamespaceException {\n+    if (!namespace.isEmpty()) {\n+      // if it is not a list all op, just check if the namespace exists and return itself.\n+      if (namespaceExists(namespace)) {\n+        return Lists.newArrayList(namespace);\n+      }\n+      throw new NoSuchNamespaceException(\n+          \"Glue does not support nested namespace, cannot list namespaces under %s\", namespace);\n+    }\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<Namespace> results = new ArrayList<>();\n+    do {\n+      GetDatabasesResponse response = glue.getDatabases(GetDatabasesRequest.builder()\n+          .catalogId(catalogId)\n+          .nextToken(nextToken)\n+          .build());\n+      if (response.hasDatabaseList()) {\n+        results.addAll(response.databaseList().stream()\n+            .map(GlueToIcebergConverter::toNamespace)\n+            .collect(Collectors.toList()));\n+        nextToken = response.nextToken();\n+      }\n+    } while (nextToken != null);\n+    LOG.debug(\"Listing namespace {} returned namespaces: {}\", namespace, results);\n+    return results;\n+  }\n+\n+  @Override\n+  public Map<String, String> loadNamespaceMetadata(Namespace namespace) throws NoSuchNamespaceException {\n+    String databaseName = IcebergToGlueConverter.toDatabaseName(namespace);\n+    try {\n+      GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+          .catalogId(catalogId)\n+          .name(databaseName)\n+          .build());\n+      Map<String, String> result = response.database().parameters();\n+      LOG.debug(\"Loaded metadata for namespace {} found {}\", namespace, result);\n+      return result;\n+    } catch (InvalidInputException e) {\n+      throw new NoSuchNamespaceException(\"invalid input for namespace %s, error message: %s\",\n+          namespace, e.getMessage());\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchNamespaceException(\"fail to find Glue database for namespace %s, error message: %s\",\n+          databaseName, e.getMessage());\n+    }\n+  }\n+\n+  @Override\n+  public boolean dropNamespace(Namespace namespace) throws NamespaceNotEmptyException {\n+    namespaceExists(namespace);\n+    List<TableIdentifier> tableIdentifiers = listTables(namespace);\n+    if (!CollectionUtils.isEmpty(tableIdentifiers)) {\n+      throw new NamespaceNotEmptyException(\"Cannot drop namespace %s because it is not empty. \" +\n+          \"The following tables still exist under the namespace: %s\", namespace, tableIdentifiers);\n+    }\n+    glue.deleteDatabase(DeleteDatabaseRequest.builder()\n+        .catalogId(catalogId)\n+        .name(IcebergToGlueConverter.toDatabaseName(namespace))\n+        .build());\n+    LOG.info(\"Dropped namespace: {}\", namespace);\n+    // Always successful, otherwise exception is thrown\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean setProperties(Namespace namespace, Map<String, String> properties) throws NoSuchNamespaceException {\n+    Map<String, String> parameter = Maps.newHashMap();", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNTA1Mg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513615052", "bodyText": "The method below uses metadata, which is also good.", "author": "rdblue", "createdAt": "2020-10-28T17:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNDY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5Mzg5Mw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513693893", "bodyText": "Sure, parameter is used to mean properties in Glue that's why I used it. Will update to that.", "author": "jackye1995", "createdAt": "2020-10-28T19:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNDY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNzQ5OA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513617498", "bodyText": "Can Glue only have one catalog per account? Saying that the catalog ID \"is\" the AWS account ID seems to imply that.\nAssuming that the account ID is a default catalog ID, I think that this should be more clear that the account ID is used by default, and that is the ID for the account's default catalog.", "author": "rdblue", "createdAt": "2020-10-28T17:08:53Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.OperationTimeoutException;\n+import software.amazon.awssdk.services.glue.model.ResourceNumberLimitExceededException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+public class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  protected static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final boolean skipArchive;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullName;\n+\n+  private FileIO fileIO;\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5ODI4Mg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513698282", "bodyText": "This is a very confusing concept within Glue... technically speaking each AWS account has one AWS Glue Data Catalog per AWS region. However, the GlueClient is always initialized with an AWS region, so the account ID is the only identifier needed to contact a different catalog.\nAs a result, the catalogId in Glue always mean the AWS account ID, and that is what the user would like to configure outside the client. I can rewrite the doc to be more clear on this.", "author": "jackye1995", "createdAt": "2020-10-28T19:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNzQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxOTA3NA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513619074", "bodyText": "The full name here should be the name of the catalog, then the db and table name. This view is good for debugging (and may be what you want for toString) but the name returned for the table should be the name used to load it. So if I've called my Glue catalog prodglue, then it would be something like prodglue.rdblue.test_table.", "author": "rdblue", "createdAt": "2020-10-28T17:11:05Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.OperationTimeoutException;\n+import software.amazon.awssdk.services.glue.model.ResourceNumberLimitExceededException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+public class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  protected static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final boolean skipArchive;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullName;\n+\n+  private FileIO fileIO;\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   * @param tableIdentifier table identifier\n+   */\n+  public GlueTableOperations(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      boolean skipArchive,\n+      TableIdentifier tableIdentifier) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.skipArchive = skipArchive;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullName = String.format(\"glue.%s.%s.%s\", catalogId, databaseName, tableName);", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5OTU5NQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513699595", "bodyText": "I see. I am basically using glue.<catalogId> as the name, that is why I am writing it like this. Sounds like the name concept is used here differently, let me add this additional field then.", "author": "jackye1995", "createdAt": "2020-10-28T19:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxOTA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjExMA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513632110", "bodyText": "Is this required? Using user.name doesn't seem like a very accurate way to determine the user.", "author": "rdblue", "createdAt": "2020-10-28T17:29:04Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.OperationTimeoutException;\n+import software.amazon.awssdk.services.glue.model.ResourceNumberLimitExceededException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+public class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  protected static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final boolean skipArchive;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullName;\n+\n+  private FileIO fileIO;\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   * @param tableIdentifier table identifier\n+   */\n+  public GlueTableOperations(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      boolean skipArchive,\n+      TableIdentifier tableIdentifier) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.skipArchive = skipArchive;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullName = String.format(\"glue.%s.%s.%s\", catalogId, databaseName, tableName);\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    if (fileIO == null) {\n+      fileIO = new HadoopFileIO(conf);\n+    }\n+    return fileIO;\n+  }\n+\n+  /**\n+   * Returns table name in the form glue.catalogId.databaseName.tableName\n+   * @return table name\n+   */\n+  @Override\n+  protected String tableName() {\n+    return fullName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    String metadataLocation = null;\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+    refreshFromMetadataLocation(metadataLocation);\n+  }\n+\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {\n+        glueTable = glueTableOptional.get();\n+        // If we try to create the table but the metadata location is already set, then we had a concurrent commit\n+        if (base == null && glueTable.parameters().get(METADATA_LOCATION_PROP) != null) {\n+          throw new AlreadyExistsException(\"Cannot commit because table %s already exists in Glue\", tableName());\n+        }\n+        isUpdate = true;\n+        LOG.debug(\"Committing existing Glue table: {}\", tableName());\n+      } else {\n+        LOG.debug(\"Committing new Glue table: {}\", tableName());\n+      }\n+      checkMetadataLocation(isUpdate, glueTable, base);\n+      Map<String, String> parameters = isUpdate ? Maps.newHashMap(glueTable.parameters()) : Maps.newHashMap();\n+      updateParameters(parameters, newMetadataLocation);\n+      persistGlueTable(isUpdate, parameters);\n+      exceptionThrown = false;\n+    } catch (CommitFailedException | AlreadyExistsException e) {\n+      throw e;\n+    } catch (ConcurrentModificationException e) {\n+      throw new CommitFailedException(e,\n+          \"Cannot commit %s because Glue detected concurrent update\", tableName());\n+    } catch (software.amazon.awssdk.services.glue.model.AlreadyExistsException e) {\n+      throw new AlreadyExistsException(e,\n+          \"Cannot commit %s because its Glue table already exists when trying to create one\", tableName());\n+    } catch (OperationTimeoutException | ResourceNumberLimitExceededException e) {\n+      throw new CommitFailedException(e,\n+          \"Cannot commit %s because Glue operation or resource limit exceeded, \" +\n+              \"please consider contact AWS to raise the limit\", tableName());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unexpected exception during commit for \" + tableName(), e);\n+    } finally {\n+      if (exceptionThrown) {\n+        io().deleteFile(newMetadataLocation);\n+      }\n+    }\n+  }\n+\n+  private void checkMetadataLocation(boolean isUpdate, Table glueTable, TableMetadata base) {\n+    String glueMetadataLocation = isUpdate ? glueTable.parameters().get(METADATA_LOCATION_PROP) : null;\n+    String baseMetadataLocation = base != null ? base.metadataFileLocation() : null;\n+    if (!Objects.equals(baseMetadataLocation, glueMetadataLocation)) {\n+      throw new CommitFailedException(\n+          \"Cannot commit %s because base metadata location '%s' is not same as the current Glue location '%s'\",\n+          tableName(), baseMetadataLocation, glueMetadataLocation);\n+    }\n+  }\n+\n+  private Optional<Table> getGlueTable() {\n+    try {\n+      GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(databaseName)\n+          .name(tableName)\n+          .build());\n+      return Optional.ofNullable(response.table());\n+    } catch (EntityNotFoundException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private void updateParameters(Map<String, String> parameters, String newMetadataLocation) {\n+    parameters.put(TABLE_TYPE_PROP, ICEBERG_TABLE_TYPE_VALUE.toUpperCase(Locale.ENGLISH));\n+    parameters.put(METADATA_LOCATION_PROP, newMetadataLocation);\n+    if (currentMetadataLocation() != null && !currentMetadataLocation().isEmpty()) {\n+      parameters.put(PREVIOUS_METADATA_LOCATION_PROP, currentMetadataLocation());\n+    }\n+  }\n+\n+  private void persistGlueTable(boolean isUpdate, Map<String, String> parameters) {\n+    if (isUpdate) {\n+      glue.updateTable(UpdateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(databaseName)\n+          .skipArchive(skipArchive)\n+          .tableInput(TableInput.builder()\n+              .name(tableName)\n+              .parameters(parameters)\n+              .build())\n+          .build());\n+    } else {\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(catalogId)\n+          .databaseName(databaseName)\n+          .tableInput(TableInput.builder()\n+              .name(tableName)\n+              .owner(System.getProperty(\"user.name\"))", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMTIyOA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513701228", "bodyText": "Agree, I am basically following what Hive is doing here. There is no other meaningful information that can be put as input here because the Glue client cannot provide the caller information. I can also just remove the field if that is cleaner.", "author": "jackye1995", "createdAt": "2020-10-28T19:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMzA3Ng==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513633076", "bodyText": "A timeout doesn't seem like the same case as exceeding a resource limit. Should these be handled separately?", "author": "rdblue", "createdAt": "2020-10-28T17:30:24Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.OperationTimeoutException;\n+import software.amazon.awssdk.services.glue.model.ResourceNumberLimitExceededException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+public class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  protected static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final boolean skipArchive;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullName;\n+\n+  private FileIO fileIO;\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   * @param tableIdentifier table identifier\n+   */\n+  public GlueTableOperations(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      boolean skipArchive,\n+      TableIdentifier tableIdentifier) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.skipArchive = skipArchive;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullName = String.format(\"glue.%s.%s.%s\", catalogId, databaseName, tableName);\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    if (fileIO == null) {\n+      fileIO = new HadoopFileIO(conf);\n+    }\n+    return fileIO;\n+  }\n+\n+  /**\n+   * Returns table name in the form glue.catalogId.databaseName.tableName\n+   * @return table name\n+   */\n+  @Override\n+  protected String tableName() {\n+    return fullName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    String metadataLocation = null;\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+    refreshFromMetadataLocation(metadataLocation);\n+  }\n+\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {\n+        glueTable = glueTableOptional.get();\n+        // If we try to create the table but the metadata location is already set, then we had a concurrent commit\n+        if (base == null && glueTable.parameters().get(METADATA_LOCATION_PROP) != null) {\n+          throw new AlreadyExistsException(\"Cannot commit because table %s already exists in Glue\", tableName());\n+        }\n+        isUpdate = true;\n+        LOG.debug(\"Committing existing Glue table: {}\", tableName());\n+      } else {\n+        LOG.debug(\"Committing new Glue table: {}\", tableName());\n+      }\n+      checkMetadataLocation(isUpdate, glueTable, base);\n+      Map<String, String> parameters = isUpdate ? Maps.newHashMap(glueTable.parameters()) : Maps.newHashMap();\n+      updateParameters(parameters, newMetadataLocation);\n+      persistGlueTable(isUpdate, parameters);\n+      exceptionThrown = false;\n+    } catch (CommitFailedException | AlreadyExistsException e) {\n+      throw e;\n+    } catch (ConcurrentModificationException e) {\n+      throw new CommitFailedException(e,\n+          \"Cannot commit %s because Glue detected concurrent update\", tableName());\n+    } catch (software.amazon.awssdk.services.glue.model.AlreadyExistsException e) {\n+      throw new AlreadyExistsException(e,\n+          \"Cannot commit %s because its Glue table already exists when trying to create one\", tableName());\n+    } catch (OperationTimeoutException | ResourceNumberLimitExceededException e) {\n+      throw new CommitFailedException(e,\n+          \"Cannot commit %s because Glue operation or resource limit exceeded, \" +\n+              \"please consider contact AWS to raise the limit\", tableName());", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNDQyOQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513704429", "bodyText": "Yeah I was expecting OperationTimeoutException to catch throttling due to API rate limit exceeded, but it also catches other situations. it is probably better to make it a different case.", "author": "jackye1995", "createdAt": "2020-10-28T19:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMzA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMzc0Ng==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513633746", "bodyText": "I think it would make more sense to move these into persistGlueTable since that's when the actual call is made.", "author": "rdblue", "createdAt": "2020-10-28T17:31:25Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.hadoop.HadoopFileIO;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.OperationTimeoutException;\n+import software.amazon.awssdk.services.glue.model.ResourceNumberLimitExceededException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+public class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  protected static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final boolean skipArchive;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullName;\n+\n+  private FileIO fileIO;\n+\n+  /**\n+   * All-arg constructor\n+   * @param conf Hadoop config, passed in for users of HadoopIO\n+   * @param glue Glue client\n+   * @param catalogId Glue catalog ID, which is the AWS account ID. When null, it uses the account of the Glue client.\n+   * @param skipArchive if Glue should skip an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to turn this feature off.\n+   * @param tableIdentifier table identifier\n+   */\n+  public GlueTableOperations(\n+      Configuration conf,\n+      GlueClient glue,\n+      String catalogId,\n+      boolean skipArchive,\n+      TableIdentifier tableIdentifier) {\n+    this.conf = conf;\n+    this.glue = glue;\n+    this.catalogId = catalogId;\n+    this.skipArchive = skipArchive;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullName = String.format(\"glue.%s.%s.%s\", catalogId, databaseName, tableName);\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    if (fileIO == null) {\n+      fileIO = new HadoopFileIO(conf);\n+    }\n+    return fileIO;\n+  }\n+\n+  /**\n+   * Returns table name in the form glue.catalogId.databaseName.tableName\n+   * @return table name\n+   */\n+  @Override\n+  protected String tableName() {\n+    return fullName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    String metadataLocation = null;\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+    refreshFromMetadataLocation(metadataLocation);\n+  }\n+\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {\n+        glueTable = glueTableOptional.get();\n+        // If we try to create the table but the metadata location is already set, then we had a concurrent commit\n+        if (base == null && glueTable.parameters().get(METADATA_LOCATION_PROP) != null) {\n+          throw new AlreadyExistsException(\"Cannot commit because table %s already exists in Glue\", tableName());\n+        }\n+        isUpdate = true;\n+        LOG.debug(\"Committing existing Glue table: {}\", tableName());\n+      } else {\n+        LOG.debug(\"Committing new Glue table: {}\", tableName());", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTQ4Ng==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513635486", "bodyText": "This doesn't appear to verify that any of the above calls actually happened. Mock tests should validate that the expected RPC calls were actually made.", "author": "rdblue", "createdAt": "2020-10-28T17:33:59Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/TestGlueCatalog.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableResponse;\n+import software.amazon.awssdk.services.glue.model.Database;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseResponse;\n+\n+public class TestGlueCatalog {\n+\n+  private static final String WAREHOUSE_PATH = \"s3a://bucket\";\n+  private GlueClient glue;\n+  private GlueCatalog glueCatalog;\n+\n+  @Before\n+  public void before() {\n+    glue = Mockito.mock(GlueClient.class);\n+    glueCatalog = new GlueCatalog(new Configuration(), glue, null, WAREHOUSE_PATH, false);\n+  }\n+\n+  @Test\n+  public void defaultWarehouseLocation_noDbUri() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    String location = glueCatalog.defaultWarehouseLocation(TableIdentifier.of(\"db\", \"table\"));\n+    Assert.assertEquals(WAREHOUSE_PATH + \"/db.db/table\", location);\n+  }\n+\n+  @Test\n+  public void defaultWarehouseLocation_dbUri() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db\").locationUri(\"s3://bucket2/db\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    String location = glueCatalog.defaultWarehouseLocation(TableIdentifier.of(\"db\", \"table\"));\n+    Assert.assertEquals(\"s3://bucket2/db/table\", location);\n+  }\n+\n+  @Test\n+  public void listTables() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db1\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    Mockito.doReturn(GetTablesResponse.builder()\n+        .tableList(\n+            Table.builder().databaseName(\"db1\").name(\"t1\").build(),\n+            Table.builder().databaseName(\"db1\").name(\"t2\").build()\n+        ).build())\n+        .when(glue).getTables(Mockito.any(GetTablesRequest.class));\n+    Assert.assertEquals(\n+        Lists.newArrayList(\n+            TableIdentifier.of(\"db1\", \"t1\"),\n+            TableIdentifier.of(\"db1\", \"t2\")\n+        ),\n+        glueCatalog.listTables(Namespace.of(\"db1\"))\n+    );\n+  }\n+\n+  @Test\n+  public void dropTable() {\n+    Map<String, String> properties = new HashMap<>();\n+    properties.put(BaseMetastoreTableOperations.TABLE_TYPE_PROP,\n+        BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE);\n+    Mockito.doReturn(GetTableResponse.builder()\n+        .table(Table.builder().databaseName(\"db1\").name(\"t1\").parameters(properties).build()).build())\n+        .when(glue).getTable(Mockito.any(GetTableRequest.class));\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db1\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    Mockito.doReturn(DeleteTableResponse.builder().build())\n+        .when(glue).deleteTable(Mockito.any(DeleteTableRequest.class));\n+    glueCatalog.dropTable(TableIdentifier.of(\"db1\", \"t1\"));", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjU0MA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513636540", "bodyText": "It is usually better to use AssertHelpers.assertThrows. That way, you can check the error message and run additional assertions after the exception. For example, if you're testing create when a table already exists, you can validate that the right exception is thrown and that the existing table was not modified.", "author": "rdblue", "createdAt": "2020-10-28T17:35:31Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/TestGlueCatalog.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableResponse;\n+import software.amazon.awssdk.services.glue.model.Database;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseResponse;\n+\n+public class TestGlueCatalog {\n+\n+  private static final String WAREHOUSE_PATH = \"s3a://bucket\";\n+  private GlueClient glue;\n+  private GlueCatalog glueCatalog;\n+\n+  @Before\n+  public void before() {\n+    glue = Mockito.mock(GlueClient.class);\n+    glueCatalog = new GlueCatalog(new Configuration(), glue, null, WAREHOUSE_PATH, false);\n+  }\n+\n+  @Test\n+  public void defaultWarehouseLocation_noDbUri() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    String location = glueCatalog.defaultWarehouseLocation(TableIdentifier.of(\"db\", \"table\"));\n+    Assert.assertEquals(WAREHOUSE_PATH + \"/db.db/table\", location);\n+  }\n+\n+  @Test\n+  public void defaultWarehouseLocation_dbUri() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db\").locationUri(\"s3://bucket2/db\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    String location = glueCatalog.defaultWarehouseLocation(TableIdentifier.of(\"db\", \"table\"));\n+    Assert.assertEquals(\"s3://bucket2/db/table\", location);\n+  }\n+\n+  @Test\n+  public void listTables() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db1\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    Mockito.doReturn(GetTablesResponse.builder()\n+        .tableList(\n+            Table.builder().databaseName(\"db1\").name(\"t1\").build(),\n+            Table.builder().databaseName(\"db1\").name(\"t2\").build()\n+        ).build())\n+        .when(glue).getTables(Mockito.any(GetTablesRequest.class));\n+    Assert.assertEquals(\n+        Lists.newArrayList(\n+            TableIdentifier.of(\"db1\", \"t1\"),\n+            TableIdentifier.of(\"db1\", \"t2\")\n+        ),\n+        glueCatalog.listTables(Namespace.of(\"db1\"))\n+    );\n+  }\n+\n+  @Test\n+  public void dropTable() {\n+    Map<String, String> properties = new HashMap<>();\n+    properties.put(BaseMetastoreTableOperations.TABLE_TYPE_PROP,\n+        BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE);\n+    Mockito.doReturn(GetTableResponse.builder()\n+        .table(Table.builder().databaseName(\"db1\").name(\"t1\").parameters(properties).build()).build())\n+        .when(glue).getTable(Mockito.any(GetTableRequest.class));\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db1\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    Mockito.doReturn(DeleteTableResponse.builder().build())\n+        .when(glue).deleteTable(Mockito.any(DeleteTableRequest.class));\n+    glueCatalog.dropTable(TableIdentifier.of(\"db1\", \"t1\"));\n+  }\n+\n+  @Test\n+  public void renameTable() {\n+    Map<String, String> properties = new HashMap<>();\n+    properties.put(BaseMetastoreTableOperations.TABLE_TYPE_PROP,\n+        BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE);\n+    Mockito.doReturn(GetTableResponse.builder()\n+        .table(Table.builder().databaseName(\"db1\").name(\"t1\").parameters(properties).build()).build())\n+        .when(glue).getTable(Mockito.any(GetTableRequest.class));\n+    Mockito.doReturn(GetTablesResponse.builder().build())\n+        .when(glue).getTables(Mockito.any(GetTablesRequest.class));\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db1\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    Mockito.doReturn(DeleteTableResponse.builder().build())\n+        .when(glue).deleteTable(Mockito.any(DeleteTableRequest.class));\n+    Mockito.doReturn(CreateTableResponse.builder().build())\n+        .when(glue).createTable(Mockito.any(CreateTableRequest.class));\n+    glueCatalog.dropTable(TableIdentifier.of(\"db1\", \"t1\"));\n+  }\n+\n+  @Test\n+  public void createNamespace() {\n+    Mockito.doReturn(CreateDatabaseResponse.builder().build())\n+        .when(glue).createDatabase(Mockito.any(CreateDatabaseRequest.class));\n+    glueCatalog.createNamespace(Namespace.of(\"db\"));\n+  }\n+\n+  @Test(expected = NoSuchNamespaceException.class)\n+  public void createNamespace_badName() {\n+    Mockito.doReturn(CreateDatabaseResponse.builder().build())\n+        .when(glue).createDatabase(Mockito.any(CreateDatabaseRequest.class));\n+    glueCatalog.createNamespace(Namespace.of(\"db-1\"));\n+  }\n+\n+  @Test\n+  public void listNamespaces_all() {\n+    Mockito.doReturn(GetDatabasesResponse.builder()\n+        .databaseList(\n+            Database.builder().name(\"db1\").build(),\n+            Database.builder().name(\"db2\").build()\n+        ).build())\n+        .when(glue).getDatabases(Mockito.any(GetDatabasesRequest.class));\n+    Assert.assertEquals(\n+        Lists.newArrayList(\n+            Namespace.of(\"db1\"),\n+            Namespace.of(\"db2\")\n+        ),\n+        glueCatalog.listNamespaces()\n+    );\n+  }\n+\n+  @Test\n+  public void listNamespaces_self() {\n+    Mockito.doReturn(GetDatabaseResponse.builder()\n+        .database(Database.builder().name(\"db1\").build()).build())\n+        .when(glue).getDatabase(Mockito.any(GetDatabaseRequest.class));\n+    Assert.assertEquals(\n+        Lists.newArrayList(\n+            Namespace.of(\"db1\")\n+        ),\n+        glueCatalog.listNamespaces(Namespace.of(\"db1\"))\n+    );\n+  }\n+\n+  @Test(expected = NoSuchNamespaceException.class)", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNzU1NA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513637554", "bodyText": "Can you separate the different calls into test methods? Combining a lot of cases together makes it harder to see what's wrong because failures prevent other test cases from running.", "author": "rdblue", "createdAt": "2020-10-28T17:36:56Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/TestGlueCatalogInteg.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.types.Types;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.Database;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableVersionsRequest;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.model.Delete;\n+import software.amazon.awssdk.services.s3.model.DeleteObjectsRequest;\n+import software.amazon.awssdk.services.s3.model.HeadObjectRequest;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\n+import software.amazon.awssdk.services.s3.model.ObjectIdentifier;\n+import software.amazon.awssdk.services.s3.model.S3Object;\n+\n+@Ignore\n+public class TestGlueCatalogInteg {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(TestGlueCatalogInteg.class);\n+\n+  private static final List<String> NAMESPACES = new ArrayList<>();\n+  private static final GlueClient GLUE = GlueClient.create();\n+  private static final S3Client S3 = S3Client.create();\n+  private static final String PREFIX = getRandomName();\n+\n+  // the integration test requires the following env variables\n+  private static final String AWS_ACCESS_KEY_ID = System.getenv(\"AWS_ACCESS_KEY_ID\");\n+  private static final String AWS_SECRET_ACCESS_KEY = System.getenv(\"AWS_SECRET_ACCESS_KEY\");\n+  private static final String BUCKET = System.getenv(\"GLUE_BUCKET\");\n+\n+  private static GlueCatalog glueCatalog;\n+  private static GlueCatalog glueCatalogWithSkip;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    Configuration configuration = new Configuration();\n+    // Iceberg uses Hadoop 2.7.3, and the hadoop-aws module does not support reading environment variable yet\n+    configuration.set(\"fs.s3a.access.key\", AWS_ACCESS_KEY_ID);\n+    configuration.set(\"fs.s3a.secret.key\", AWS_SECRET_ACCESS_KEY);\n+    String testBucketPath = \"s3a://\" + BUCKET + \"/\" + PREFIX;\n+    glueCatalog = new GlueCatalog(configuration, GLUE, null, testBucketPath, false);\n+    glueCatalogWithSkip = new GlueCatalog(configuration, GLUE, null, testBucketPath, true);\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    for (String namespace : NAMESPACES) {\n+      try {\n+        // delete db also delete tables\n+        GLUE.deleteDatabase(DeleteDatabaseRequest.builder().name(namespace).build());\n+      } catch (Exception e) {\n+        // pass\n+      }\n+    }\n+    boolean hasContent = true;\n+    while (hasContent) {\n+      ListObjectsV2Response response = S3.listObjectsV2(ListObjectsV2Request.builder()\n+          .bucket(BUCKET).prefix(PREFIX).build());\n+      hasContent = response.hasContents();\n+      if (hasContent) {\n+        S3.deleteObjects(DeleteObjectsRequest.builder().bucket(BUCKET).delete(Delete.builder().objects(\n+            response.contents().stream()\n+                .map(obj -> ObjectIdentifier.builder().key(obj.key()).build())\n+                .collect(Collectors.toList())\n+        ).build()).build());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testNamespace() {\n+    // create ns\n+    String namespace = getRandomName();\n+    NAMESPACES.add(namespace);\n+    glueCatalog.createNamespace(Namespace.of(namespace));\n+    Database database = GLUE.getDatabase(GetDatabaseRequest.builder().name(namespace).build()).database();\n+    Assert.assertEquals(namespace, database.name());\n+    // list all", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzOTE0OA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r513639148", "bodyText": "I think this should use a config map like we're discussing in the catalog loading PR. We'll probably want to wait on this one until the direction there is agreed, and then update this.", "author": "rdblue", "createdAt": "2020-10-28T17:39:23Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.IcebergAWSConfigs;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.awscore.exception.AwsServiceException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final Configuration conf;\n+  private final GlueClient glue;\n+  private final String catalogId;\n+  private final String catalogName;\n+  private final String warehousePath;\n+  private final boolean skipArchive;\n+\n+  /**\n+   * Constructor that initializes all args from Hadoop configuration, used by engines like Spark and Flink\n+   * @param conf Hadoop config passed from engines\n+   */\n+  public GlueCatalog(Configuration conf) {", "originalCommit": "bdb4dd597475c06cfc31080f01712ef6a9d8a7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5ec64d6132ca194f19a6e059929e29f101299200", "url": "https://github.com/apache/iceberg/commit/5ec64d6132ca194f19a6e059929e29f101299200", "message": "AWS Glue catalog and table operations", "committedDate": "2020-11-06T08:45:59Z", "type": "forcePushed"}, {"oid": "ac83e1eda2d5f578996096587cf02cbf30a280cd", "url": "https://github.com/apache/iceberg/commit/ac83e1eda2d5f578996096587cf02cbf30a280cd", "message": "AWS Glue catalog and table operations", "committedDate": "2020-11-11T01:25:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMDA4OQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521620089", "bodyText": "I don't think this should throw NoSuchNamespaceException. What about ValidationException?\nAlso, tests should generally check the error message as well.", "author": "rdblue", "createdAt": "2020-11-11T20:29:46Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/GlueCatalogNamespaceTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import software.amazon.awssdk.services.glue.model.Database;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+\n+public class GlueCatalogNamespaceTest extends GlueTestBase {\n+\n+  @Test\n+  public void testCreateNamespace() {\n+    String namespace = getRandomName();\n+    namespaces.add(namespace);\n+    glueCatalog.createNamespace(Namespace.of(namespace));\n+    Database database = glue.getDatabase(GetDatabaseRequest.builder().name(namespace).build()).database();\n+    Assert.assertEquals(namespace, database.name());\n+  }\n+\n+  @Test\n+  public void testCreateDuplicate() {\n+    String namespace = createNamespace();\n+    AssertHelpers.assertThrows(\"should not create namespace with the same name\",\n+        AlreadyExistsException.class,\n+        () -> glueCatalog.createNamespace(Namespace.of(namespace)));\n+  }\n+\n+  @Test\n+  public void testCreateBadName() {\n+    AssertHelpers.assertThrows(\"should not create namespace with bad name\",\n+        NoSuchNamespaceException.class,\n+        () -> glueCatalog.createNamespace(Namespace.of(\"db-1\")));", "originalCommit": "73bee5903e0bcaa1590973d7f4ef2409e26d6221", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMTk4NQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521621985", "bodyText": "Should this also test a namespace with more than 1 part?", "author": "rdblue", "createdAt": "2020-11-11T20:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMDA4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0MzU1NA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521843554", "bodyText": "Added. More details are directly tested in unit test of IcebergToGlueConverter", "author": "jackye1995", "createdAt": "2020-11-12T05:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMDA4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0NTU5Mw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521845593", "bodyText": "Yes ValidationException sounds better for the situations, I will update.", "author": "jackye1995", "createdAt": "2020-11-12T05:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMDA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMTg3MA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521621870", "bodyText": "I usually like to check operations like create by checking the opposite state first, so asserting that the namespace does not exist using the glue client.\nI also think it is a best practice to provide context in most assertions, like assertEquals(\"Random name should match loaded when directly\", namespace, database.name()).", "author": "rdblue", "createdAt": "2020-11-11T20:33:21Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/GlueCatalogNamespaceTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import software.amazon.awssdk.services.glue.model.Database;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+\n+public class GlueCatalogNamespaceTest extends GlueTestBase {\n+\n+  @Test\n+  public void testCreateNamespace() {\n+    String namespace = getRandomName();\n+    namespaces.add(namespace);\n+    glueCatalog.createNamespace(Namespace.of(namespace));\n+    Database database = glue.getDatabase(GetDatabaseRequest.builder().name(namespace).build()).database();\n+    Assert.assertEquals(namespace, database.name());", "originalCommit": "73bee5903e0bcaa1590973d7f4ef2409e26d6221", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0NTMzNQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521845335", "bodyText": "Will add messages to assertions.", "author": "jackye1995", "createdAt": "2020-11-12T05:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMTg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMjY2Mg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521622662", "bodyText": "Can you add a bit more whitespace to break up sections of this test? It seems a bit dense.", "author": "rdblue", "createdAt": "2020-11-11T20:34:53Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/GlueCatalogTableTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableVersionsRequest;\n+import software.amazon.awssdk.services.s3.model.HeadObjectRequest;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\n+import software.amazon.awssdk.services.s3.model.S3Object;\n+\n+public class GlueCatalogTableTest extends GlueTestBase {\n+\n+  @Test\n+  public void testCreateTable() {\n+    String namespace = createNamespace();\n+    String tableName = getRandomName();\n+    glueCatalog.createTable(TableIdentifier.of(namespace, tableName), schema, partitionSpec);\n+    GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+        .databaseName(namespace).name(tableName).build());\n+    Assert.assertEquals(namespace, response.table().databaseName());\n+    Assert.assertEquals(tableName, response.table().name());\n+    Assert.assertEquals(BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.toUpperCase(Locale.ENGLISH),\n+        response.table().parameters().get(BaseMetastoreTableOperations.TABLE_TYPE_PROP));\n+    Assert.assertTrue(response.table().parameters().containsKey(BaseMetastoreTableOperations.METADATA_LOCATION_PROP));\n+    String metaLocation = response.table().parameters().get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP);\n+    String key = metaLocation.split(testBucketName, -1)[1].substring(1);\n+    s3.headObject(HeadObjectRequest.builder().bucket(testBucketName).key(key).build());\n+    Table table = glueCatalog.loadTable(TableIdentifier.of(namespace, tableName));\n+    Assert.assertEquals(partitionSpec, table.spec());\n+    Assert.assertEquals(schema.toString(), table.schema().toString());", "originalCommit": "73bee5903e0bcaa1590973d7f4ef2409e26d6221", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMjkxOQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521622919", "bodyText": "This context is usually better if it is added to the assertion, so that when the test fails it is printed in the output.", "author": "rdblue", "createdAt": "2020-11-11T20:35:23Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/GlueCatalogTableTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableVersionsRequest;\n+import software.amazon.awssdk.services.s3.model.HeadObjectRequest;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\n+import software.amazon.awssdk.services.s3.model.S3Object;\n+\n+public class GlueCatalogTableTest extends GlueTestBase {\n+\n+  @Test\n+  public void testCreateTable() {\n+    String namespace = createNamespace();\n+    String tableName = getRandomName();\n+    glueCatalog.createTable(TableIdentifier.of(namespace, tableName), schema, partitionSpec);\n+    GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+        .databaseName(namespace).name(tableName).build());\n+    Assert.assertEquals(namespace, response.table().databaseName());\n+    Assert.assertEquals(tableName, response.table().name());\n+    Assert.assertEquals(BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.toUpperCase(Locale.ENGLISH),\n+        response.table().parameters().get(BaseMetastoreTableOperations.TABLE_TYPE_PROP));\n+    Assert.assertTrue(response.table().parameters().containsKey(BaseMetastoreTableOperations.METADATA_LOCATION_PROP));\n+    String metaLocation = response.table().parameters().get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP);\n+    String key = metaLocation.split(testBucketName, -1)[1].substring(1);\n+    s3.headObject(HeadObjectRequest.builder().bucket(testBucketName).key(key).build());\n+    Table table = glueCatalog.loadTable(TableIdentifier.of(namespace, tableName));\n+    Assert.assertEquals(partitionSpec, table.spec());\n+    Assert.assertEquals(schema.toString(), table.schema().toString());\n+  }\n+\n+  @Test\n+  public void testCreateTableDuplicate() {\n+    String namespace = createNamespace();\n+    String tableName = createTable(namespace);\n+    AssertHelpers.assertThrows(\"should not create table with the same name\",\n+        AlreadyExistsException.class,\n+        () -> glueCatalog.createTable(TableIdentifier.of(namespace, tableName), schema, partitionSpec));\n+  }\n+\n+  @Test\n+  public void testCreateTableBadName() {\n+    String namespace = createNamespace();\n+    AssertHelpers.assertThrows(\"should not create table with bad name\",\n+        IllegalArgumentException.class,\n+        () -> glueCatalog.createTable(TableIdentifier.of(namespace, \"table-1\"), schema, partitionSpec));\n+  }\n+\n+  @Test\n+  public void testListTables() {\n+    String namespace = createNamespace();\n+    // list table should have nothing", "originalCommit": "73bee5903e0bcaa1590973d7f4ef2409e26d6221", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMzk4Mg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521623982", "bodyText": "What is a rename rollback? Why does this test fail? The table looks like it should exist.", "author": "rdblue", "createdAt": "2020-11-11T20:37:40Z", "path": "aws/src/integration/java/org/apache/iceberg/aws/glue/GlueCatalogTableTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataFiles;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableVersionsRequest;\n+import software.amazon.awssdk.services.s3.model.HeadObjectRequest;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\n+import software.amazon.awssdk.services.s3.model.S3Object;\n+\n+public class GlueCatalogTableTest extends GlueTestBase {\n+\n+  @Test\n+  public void testCreateTable() {\n+    String namespace = createNamespace();\n+    String tableName = getRandomName();\n+    glueCatalog.createTable(TableIdentifier.of(namespace, tableName), schema, partitionSpec);\n+    GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+        .databaseName(namespace).name(tableName).build());\n+    Assert.assertEquals(namespace, response.table().databaseName());\n+    Assert.assertEquals(tableName, response.table().name());\n+    Assert.assertEquals(BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.toUpperCase(Locale.ENGLISH),\n+        response.table().parameters().get(BaseMetastoreTableOperations.TABLE_TYPE_PROP));\n+    Assert.assertTrue(response.table().parameters().containsKey(BaseMetastoreTableOperations.METADATA_LOCATION_PROP));\n+    String metaLocation = response.table().parameters().get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP);\n+    String key = metaLocation.split(testBucketName, -1)[1].substring(1);\n+    s3.headObject(HeadObjectRequest.builder().bucket(testBucketName).key(key).build());\n+    Table table = glueCatalog.loadTable(TableIdentifier.of(namespace, tableName));\n+    Assert.assertEquals(partitionSpec, table.spec());\n+    Assert.assertEquals(schema.toString(), table.schema().toString());\n+  }\n+\n+  @Test\n+  public void testCreateTableDuplicate() {\n+    String namespace = createNamespace();\n+    String tableName = createTable(namespace);\n+    AssertHelpers.assertThrows(\"should not create table with the same name\",\n+        AlreadyExistsException.class,\n+        () -> glueCatalog.createTable(TableIdentifier.of(namespace, tableName), schema, partitionSpec));\n+  }\n+\n+  @Test\n+  public void testCreateTableBadName() {\n+    String namespace = createNamespace();\n+    AssertHelpers.assertThrows(\"should not create table with bad name\",\n+        IllegalArgumentException.class,\n+        () -> glueCatalog.createTable(TableIdentifier.of(namespace, \"table-1\"), schema, partitionSpec));\n+  }\n+\n+  @Test\n+  public void testListTables() {\n+    String namespace = createNamespace();\n+    // list table should have nothing\n+    Assert.assertTrue(glueCatalog.listTables(Namespace.of(namespace)).isEmpty());\n+    String tableName = createTable(namespace);\n+    // list table should show\n+    List<TableIdentifier> tables = glueCatalog.listTables(Namespace.of(namespace));\n+    Assert.assertEquals(1, tables.size());\n+    Assert.assertEquals(TableIdentifier.of(namespace, tableName), tables.get(0));\n+  }\n+\n+  @Test\n+  public void testTableExists() {\n+    String namespace = createNamespace();\n+    String tableName = createTable(namespace);\n+    Assert.assertTrue(glueCatalog.tableExists(TableIdentifier.of(namespace, tableName)));\n+  }\n+\n+  @Test\n+  public void testUpdateTable() {\n+    String namespace = createNamespace();\n+    String tableName = getRandomName();\n+    // current should be null\n+    TableOperations ops = glueCatalog.newTableOps(TableIdentifier.of(namespace, tableName));\n+    TableMetadata current = ops.current();\n+    Assert.assertNull(current);\n+    // create table, refresh should update\n+    createTable(namespace, tableName);\n+    current = ops.refresh();\n+    Assert.assertEquals(schema.toString(), current.schema().toString());\n+    Assert.assertEquals(partitionSpec, current.spec());\n+    Table table = glueCatalog.loadTable(TableIdentifier.of(namespace, tableName));\n+    Assert.assertTrue(table.history().isEmpty());\n+    // commit new version, should create a new snapshot\n+    table = glueCatalog.loadTable(TableIdentifier.of(namespace, tableName));\n+    DataFile dataFile = DataFiles.builder(partitionSpec)\n+        .withPath(\"/path/to/data-a.parquet\")\n+        .withFileSizeInBytes(10)\n+        .withRecordCount(1)\n+        .build();\n+    table.newAppend().appendFile(dataFile).commit();\n+    table = glueCatalog.loadTable(TableIdentifier.of(namespace, tableName));\n+    Assert.assertEquals(1, table.history().size());\n+  }\n+\n+  @Test\n+  public void testRenameTable() {\n+    String namespace = createNamespace();\n+    String tableName = createTable(namespace);\n+    Table table = glueCatalog.loadTable(TableIdentifier.of(namespace, tableName));\n+    // rename table\n+    String newTableName = tableName + \"_2\";\n+    glueCatalog.renameTable(TableIdentifier.of(namespace, tableName), TableIdentifier.of(namespace, newTableName));\n+    Table renamedTable = glueCatalog.loadTable(TableIdentifier.of(namespace, newTableName));\n+    Assert.assertEquals(table.location(), renamedTable.location());\n+    Assert.assertEquals(table.schema().toString(), renamedTable.schema().toString());\n+    Assert.assertEquals(table.spec(), renamedTable.spec());\n+    Assert.assertEquals(table.currentSnapshot(), renamedTable.currentSnapshot());\n+  }\n+\n+  @Test\n+  public void testRenameTableRollback() {\n+    String namespace = createNamespace();\n+    String tableName = createTable(namespace);\n+    TableIdentifier id = TableIdentifier.of(namespace, tableName);\n+    Table table = glueCatalog.loadTable(id);\n+    // rename rollback\n+    AssertHelpers.assertThrows(\"should not have table\",\n+        NoSuchTableException.class,\n+        () -> glueCatalog.renameTable(\n+            TableIdentifier.of(namespace, tableName), TableIdentifier.of(namespace, tableName + \"-3\")));", "originalCommit": "73bee5903e0bcaa1590973d7f4ef2409e26d6221", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzMzM1OA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521833358", "bodyText": "Sorry the message is vague, and the test here is not very intuitive, I will update.\nBecause there is no actual rename operation in Glue, rename means deleting an old table and creating a new table in Glue pointing to the same metadata. If the creation process fails, it should \"rollback\" and keep the old table.", "author": "jackye1995", "createdAt": "2020-11-12T04:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMzk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMzQzNw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521633437", "bodyText": "Does this need to be public? It makes sense to have it for tests, but I would probably avoid public constructors that we need to support later.", "author": "rdblue", "createdAt": "2020-11-11T20:56:02Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.s3.S3FileIO;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.awscore.exception.AwsServiceException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces, Configurable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  public static final String CONFIG_GLUE_CATALOG_ID = \"glue-catalog-id\";\n+  public static final String CONFIG_SKIP_ARCHIVE = \"skip-archive\";\n+  public static final boolean CONFIG_SKIP_ARCHIVE_DEFAULT = false;\n+\n+  private final GlueClient glue;\n+  private Configuration hadoopConf;\n+  private String catalogId;\n+  private String catalogName;\n+  private String warehousePath;\n+  private boolean skipArchive;\n+  private FileIO fileIO;\n+\n+  /**\n+   * No-arg constructor to load the catalog dynamically.\n+   * <p>\n+   * Only the AWS Glue client is initialized.\n+   * Other fields must be initialized by calling {@link GlueCatalog#initialize(String, Map)} later.\n+   */\n+  public GlueCatalog() {\n+    this.glue = AwsClientUtil.defaultGlueClient();\n+  }\n+\n+  /**\n+   * All-arg constructor to directly initialize the catalog.\n+   * <p>\n+   * All the fields are directly initialized.\n+   * There is no need to call {@link GlueCatalog#initialize(String, Map)} later.\n+   *\n+   * @param glue Glue client\n+   * @param catalogName a custom name for the catalog, usually obtained from a Spark or Flink session.\n+   * @param catalogId The ID of the Glue Data Catalog where the tables reside.\n+   *                  If none is provided, the AWS account ID is used by default.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip archiving an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to set this value to true.\n+   * @param fileIO file IO to use.\n+   */\n+  public GlueCatalog(GlueClient glue, String catalogName, String catalogId, String warehousePath,", "originalCommit": "73bee5903e0bcaa1590973d7f4ef2409e26d6221", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzNDI0NA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521634244", "bodyText": "Since all this does is call initialize, maybe we don't even need it for tests. That method could be package-private.", "author": "rdblue", "createdAt": "2020-11-11T20:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMzQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzMzYzMw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521833633", "bodyText": "I will just have a package private constructor taking the glue client, and always call the initialize method then, which should simply the situation here a lot.", "author": "jackye1995", "createdAt": "2020-11-12T04:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMzQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMzgyNA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521633824", "bodyText": "There's a helper for this: PropertyUtil.propertyAsBoolean.", "author": "rdblue", "createdAt": "2020-11-11T20:56:53Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.s3.S3FileIO;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.awscore.exception.AwsServiceException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces, Configurable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  public static final String CONFIG_GLUE_CATALOG_ID = \"glue-catalog-id\";\n+  public static final String CONFIG_SKIP_ARCHIVE = \"skip-archive\";\n+  public static final boolean CONFIG_SKIP_ARCHIVE_DEFAULT = false;\n+\n+  private final GlueClient glue;\n+  private Configuration hadoopConf;\n+  private String catalogId;\n+  private String catalogName;\n+  private String warehousePath;\n+  private boolean skipArchive;\n+  private FileIO fileIO;\n+\n+  /**\n+   * No-arg constructor to load the catalog dynamically.\n+   * <p>\n+   * Only the AWS Glue client is initialized.\n+   * Other fields must be initialized by calling {@link GlueCatalog#initialize(String, Map)} later.\n+   */\n+  public GlueCatalog() {\n+    this.glue = AwsClientUtil.defaultGlueClient();\n+  }\n+\n+  /**\n+   * All-arg constructor to directly initialize the catalog.\n+   * <p>\n+   * All the fields are directly initialized.\n+   * There is no need to call {@link GlueCatalog#initialize(String, Map)} later.\n+   *\n+   * @param glue Glue client\n+   * @param catalogName a custom name for the catalog, usually obtained from a Spark or Flink session.\n+   * @param catalogId The ID of the Glue Data Catalog where the tables reside.\n+   *                  If none is provided, the AWS account ID is used by default.\n+   * @param warehousePath warehouse path, such as s3://my-iceberg-bucket/metadata_prod\n+   * @param skipArchive if Glue should skip archiving an old table version when creating a new version in a commit.\n+   *                    By default Glue archives all old table versions after an UpdateTable call.\n+   *                    but Glue has a default max number of archived table versions (can be increased).\n+   *                    So for streaming use case with lots of commits, it is recommended to set this value to true.\n+   * @param fileIO file IO to use.\n+   */\n+  public GlueCatalog(GlueClient glue, String catalogName, String catalogId, String warehousePath,\n+                     boolean skipArchive, FileIO fileIO) {\n+    this.glue = Preconditions.checkNotNull(glue, \"Cannot initialize GlueCatalog because GlueClient is null\");\n+    initialize(catalogName, catalogId, warehousePath, skipArchive, fileIO);\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String skipArchiveValue = properties.get(CONFIG_SKIP_ARCHIVE);\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    initialize(\n+        name,\n+        properties.get(CONFIG_GLUE_CATALOG_ID),\n+        properties.get(CatalogProperties.WAREHOUSE_LOCATION),\n+        skipArchiveValue == null ? CONFIG_SKIP_ARCHIVE_DEFAULT :\n+            Boolean.parseBoolean(properties.get(CONFIG_SKIP_ARCHIVE)),", "originalCommit": "73bee5903e0bcaa1590973d7f4ef2409e26d6221", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgxNTgyMA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521815820", "bodyText": "Oh yes, completely forgot that, thank you", "author": "jackye1995", "createdAt": "2020-11-12T03:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzMzgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzNTQzNA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r521635434", "bodyText": "I don't think this class needs to be public or have a public constructor.", "author": "rdblue", "createdAt": "2020-11-11T21:00:14Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.core.exception.SdkException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+public class GlueTableOperations extends BaseMetastoreTableOperations {", "originalCommit": "73bee5903e0bcaa1590973d7f4ef2409e26d6221", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "efa701d15d419e673d95a33c2f49610de30441fc", "url": "https://github.com/apache/iceberg/commit/efa701d15d419e673d95a33c2f49610de30441fc", "message": "AWS Glue catalog and table operations", "committedDate": "2020-11-12T06:19:02Z", "type": "forcePushed"}, {"oid": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "url": "https://github.com/apache/iceberg/commit/ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "message": "AWS Glue catalog and table operations", "committedDate": "2020-11-17T05:34:25Z", "type": "commit"}, {"oid": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "url": "https://github.com/apache/iceberg/commit/ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "message": "AWS Glue catalog and table operations", "committedDate": "2020-11-17T05:34:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0MjIxOA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525642218", "bodyText": "Not a blocker, but I wonder if we should choose the FileIO for a table based on the table location. Any s3 URI would use S3FileIO, but other URIs would still use the default HadoopFileIO.\nAnother thing I've been considering is using a delegating FileIO that checks whether S3FileIO is available and loads it. If it is available, then it is used for all s3 paths, but HadoopFileIO is used for the others. This may be over-complicated.", "author": "rdblue", "createdAt": "2020-11-18T01:49:42Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.aws.s3.S3FileIO;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.GlueException;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces, Configurable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final GlueClient glue;\n+  private Configuration hadoopConf;\n+  private String catalogName;\n+  private String warehousePath;\n+  private AwsProperties awsProperties;\n+  private FileIO fileIO;\n+\n+  /**\n+   * No-arg constructor to load the catalog dynamically.\n+   * <p>\n+   * Only the AWS Glue client is initialized.\n+   * Other fields must be initialized by calling {@link GlueCatalog#initialize(String, Map)} later.\n+   */\n+  public GlueCatalog() {\n+    this(AwsClientUtil.defaultGlueClient());\n+  }\n+\n+  @VisibleForTesting\n+  GlueCatalog(GlueClient glue) {\n+    this.glue = glue;\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    initialize(\n+        name,\n+        properties.get(CatalogProperties.WAREHOUSE_LOCATION),\n+        new AwsProperties(properties),\n+        fileIOImpl == null ? new S3FileIO() : CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf));", "originalCommit": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0ODkyOA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525648928", "bodyText": "Yes I am also thinking about a delegating fileIO, but in another PR. I can switch default back to HadoopFileIO if that is more inclusive of all file path types.", "author": "jackye1995", "createdAt": "2020-11-18T02:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0MjIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0Mzk4OQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525643989", "bodyText": "Seems like it would be safer to do this in the opposite order: create the new table as a copy and then drop the existing table. That way, if anything goes wrong, you have at least one copy of the table no matter what. And if only half of the operation succeeds, then you can clean it up by running DROP TABLE.\nThis way, if you lose connectivity after dropping the table, you may not be able to recover.", "author": "rdblue", "createdAt": "2020-11-18T01:55:11Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueCatalog.java", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.BaseMetastoreCatalog;\n+import org.apache.iceberg.CatalogProperties;\n+import org.apache.iceberg.CatalogUtil;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.TableOperations;\n+import org.apache.iceberg.aws.AwsClientUtil;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.aws.s3.S3FileIO;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.SupportsNamespaces;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.NoSuchNamespaceException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.annotations.VisibleForTesting;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.GlueException;\n+import software.amazon.awssdk.services.glue.model.InvalidInputException;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+\n+public class GlueCatalog extends BaseMetastoreCatalog implements Closeable, SupportsNamespaces, Configurable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueCatalog.class);\n+\n+  private final GlueClient glue;\n+  private Configuration hadoopConf;\n+  private String catalogName;\n+  private String warehousePath;\n+  private AwsProperties awsProperties;\n+  private FileIO fileIO;\n+\n+  /**\n+   * No-arg constructor to load the catalog dynamically.\n+   * <p>\n+   * Only the AWS Glue client is initialized.\n+   * Other fields must be initialized by calling {@link GlueCatalog#initialize(String, Map)} later.\n+   */\n+  public GlueCatalog() {\n+    this(AwsClientUtil.defaultGlueClient());\n+  }\n+\n+  @VisibleForTesting\n+  GlueCatalog(GlueClient glue) {\n+    this.glue = glue;\n+  }\n+\n+  @Override\n+  public void initialize(String name, Map<String, String> properties) {\n+    String fileIOImpl = properties.get(CatalogProperties.FILE_IO_IMPL);\n+    initialize(\n+        name,\n+        properties.get(CatalogProperties.WAREHOUSE_LOCATION),\n+        new AwsProperties(properties),\n+        fileIOImpl == null ? new S3FileIO() : CatalogUtil.loadFileIO(fileIOImpl, properties, hadoopConf));\n+  }\n+\n+  @VisibleForTesting\n+  void initialize(String name, String path, AwsProperties properties, FileIO io) {\n+    this.catalogName = name;\n+    this.awsProperties = properties;\n+    this.warehousePath = cleanWarehousePath(path);\n+    this.fileIO = io;\n+  }\n+\n+  private String cleanWarehousePath(String path) {\n+    Preconditions.checkArgument(path != null && path.length() > 0,\n+        \"Cannot initialize GlueCatalog because warehousePath must not be null\");\n+    int len = path.length();\n+    if (path.charAt(len - 1) == '/') {\n+      return path.substring(0, len - 1);\n+    } else {\n+      return path;\n+    }\n+  }\n+\n+  @Override\n+  protected TableOperations newTableOps(TableIdentifier tableIdentifier) {\n+    return new GlueTableOperations(glue, catalogName, awsProperties, fileIO, tableIdentifier);\n+  }\n+\n+  /**\n+   * This method produces the same result as using a HiveCatalog.\n+   * If databaseUri exists for the Glue database URI, the default location is databaseUri/tableName.\n+   * If not, the default location is warehousePath/databaseName.db/tableName\n+   * @param tableIdentifier table id\n+   * @return default warehouse path\n+   */\n+  @Override\n+  protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n+    // check if value is set in database\n+    GetDatabaseResponse response = glue.getDatabase(GetDatabaseRequest.builder()\n+        .name(IcebergToGlueConverter.getDatabaseName(tableIdentifier))\n+        .build());\n+    String dbLocationUri = response.database().locationUri();\n+    if (dbLocationUri != null) {\n+      return String.format(\"%s/%s\", dbLocationUri, tableIdentifier.name());\n+    }\n+\n+    return String.format(\n+        \"%s/%s.db/%s\",\n+        warehousePath,\n+        IcebergToGlueConverter.getDatabaseName(tableIdentifier),\n+        tableIdentifier.name());\n+  }\n+\n+  @Override\n+  public List<TableIdentifier> listTables(Namespace namespace) {\n+    namespaceExists(namespace);\n+    // should be safe to list all before returning the list, instead of dynamically load the list.\n+    String nextToken = null;\n+    List<TableIdentifier> results = Lists.newArrayList();\n+    do {\n+      GetTablesResponse response = glue.getTables(GetTablesRequest.builder()\n+          .catalogId(awsProperties.glueCatalogId())\n+          .databaseName(IcebergToGlueConverter.toDatabaseName(namespace))\n+          .nextToken(nextToken)\n+          .build());\n+      nextToken = response.nextToken();\n+      if (response.hasTableList()) {\n+        results.addAll(response.tableList().stream()\n+            .map(GlueToIcebergConverter::toTableId)\n+            .collect(Collectors.toList()));\n+      }\n+    } while (nextToken != null);\n+\n+    LOG.debug(\"Listing of namespace: {} resulted in the following tables: {}\", namespace, results);\n+    return results;\n+  }\n+\n+  @Override\n+  public boolean dropTable(TableIdentifier identifier, boolean purge) {\n+    try {\n+      TableOperations ops = newTableOps(identifier);\n+      TableMetadata lastMetadata = ops.current();\n+      glue.deleteTable(DeleteTableRequest.builder()\n+          .catalogId(awsProperties.glueCatalogId())\n+          .databaseName(IcebergToGlueConverter.getDatabaseName(identifier))\n+          .name(identifier.name())\n+          .build());\n+      LOG.info(\"Successfully dropped table {} from Glue\", identifier);\n+      if (purge && lastMetadata != null) {\n+        CatalogUtil.dropTableData(ops.io(), lastMetadata);\n+        LOG.info(\"Glue table {} data purged\", identifier);\n+      }\n+      LOG.info(\"Dropped table: {}\", identifier);\n+      return true;\n+    } catch (EntityNotFoundException e) {\n+      LOG.error(\"Cannot drop table {} because table not found or not accessible\", identifier, e);\n+      return false;\n+    } catch (Exception e) {\n+      LOG.error(\"Cannot complete drop table operation for {} due to unexpected exception\", identifier, e);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Rename table in Glue is a drop table and create table.\n+   * @param from identifier of the table to rename\n+   * @param to new table name\n+   */\n+  @Override\n+  public void renameTable(TableIdentifier from, TableIdentifier to) {\n+    // check new namespace exists\n+    if (!namespaceExists(to.namespace())) {\n+      throw new NoSuchNamespaceException(\"Cannot rename %s to %s because namespace %s does not exist\",\n+          from, to, to.namespace());\n+    }\n+    // keep metadata\n+    Table fromTable = null;\n+    String fromTableDbName = IcebergToGlueConverter.getDatabaseName(from);\n+    String fromTableName = IcebergToGlueConverter.getTableName(from);\n+    String toTableDbName = IcebergToGlueConverter.getDatabaseName(to);\n+    String toTableName = IcebergToGlueConverter.getTableName(to);\n+    try {\n+      GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+          .catalogId(awsProperties.glueCatalogId())\n+          .databaseName(fromTableDbName)\n+          .name(fromTableName)\n+          .build());\n+      fromTable = response.table();\n+    } catch (EntityNotFoundException e) {\n+      throw new NoSuchTableException(e, \"Cannot rename %s because the table does not exist in Glue\", from);\n+    }\n+\n+    dropTable(from, false);\n+    // use the same Glue info to create the new table, pointing to the old metadata\n+    TableInput.Builder tableInputBuilder = TableInput.builder()\n+        .owner(fromTable.owner())\n+        .tableType(fromTable.tableType())\n+        .parameters(fromTable.parameters());\n+    try {\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(awsProperties.glueCatalogId())\n+          .databaseName(toTableDbName)\n+          .tableInput(tableInputBuilder.name(toTableName).build())\n+          .build());\n+      LOG.info(\"Renamed table from {} to {}\", from, to);\n+    } catch (GlueException e) {\n+      // rollback, recreate old table and rethrow exception\n+      LOG.error(\"Fail to rename table from {} to {}, rollback the old table\", from, to, e);\n+      glue.createTable(CreateTableRequest.builder()\n+          .catalogId(awsProperties.glueCatalogId())\n+          .databaseName(fromTableDbName)\n+          .tableInput(tableInputBuilder.name(fromTableName).build())\n+          .build());\n+      throw e;\n+    }", "originalCommit": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NjYwNQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525646605", "bodyText": "This logic is used in Hive because when running in Hive, HiveMetaHook is used to create the Iceberg table and by the time it runs the commit, Hive has already created the metadata in the HiveMetaStore.\nThis shouldn't be needed for Glue because we don't expect any other process to create the Glue table. Concurrent table creation should always call create, which may fail with an AlreadyExistsException.", "author": "rdblue", "createdAt": "2020-11-18T02:03:39Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.core.exception.SdkException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  private static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final GlueClient glue;\n+  private final AwsProperties awsProperties;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullTableName;\n+  private final FileIO fileIO;\n+\n+  GlueTableOperations(GlueClient glue, String catalogName, AwsProperties awsProperties,\n+                      FileIO fileIO, TableIdentifier tableIdentifier) {\n+    this.glue = glue;\n+    this.awsProperties = awsProperties;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullTableName = String.format(\"%s.%s.%s\", catalogName, databaseName, tableName);\n+    this.fileIO = fileIO;\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    return fileIO;\n+  }\n+\n+  @Override\n+  protected String tableName() {\n+    return fullTableName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    String metadataLocation = null;\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+\n+    refreshFromMetadataLocation(metadataLocation);\n+  }\n+\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {", "originalCommit": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzA5NA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525647094", "bodyText": "When would ConcurrentModificationException be thrown by Glue?", "author": "rdblue", "createdAt": "2020-11-18T02:04:59Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.core.exception.SdkException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  private static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final GlueClient glue;\n+  private final AwsProperties awsProperties;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullTableName;\n+  private final FileIO fileIO;\n+\n+  GlueTableOperations(GlueClient glue, String catalogName, AwsProperties awsProperties,\n+                      FileIO fileIO, TableIdentifier tableIdentifier) {\n+    this.glue = glue;\n+    this.awsProperties = awsProperties;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullTableName = String.format(\"%s.%s.%s\", catalogName, databaseName, tableName);\n+    this.fileIO = fileIO;\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    return fileIO;\n+  }\n+\n+  @Override\n+  protected String tableName() {\n+    return fullTableName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    String metadataLocation = null;\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+\n+    refreshFromMetadataLocation(metadataLocation);\n+  }\n+\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {\n+        glueTable = glueTableOptional.get();\n+        isUpdate = true;\n+        // If we try to create the table but the metadata location is already set, then we had a concurrent commit\n+        if (base == null && glueTable.parameters().get(METADATA_LOCATION_PROP) != null) {\n+          throw new AlreadyExistsException(\"Cannot commit because table %s already exists in Glue\", tableName());\n+        }\n+      }\n+\n+      checkMetadataLocation(isUpdate, glueTable, base);\n+      Map<String, String> properties = prepareProperties(isUpdate, glueTable, newMetadataLocation);\n+      persistGlueTable(isUpdate, properties);\n+      exceptionThrown = false;\n+    } catch (CommitFailedException | AlreadyExistsException e) {\n+      throw e;\n+    } catch (ConcurrentModificationException e) {\n+      throw new CommitFailedException(e,\n+          \"Cannot commit %s because Glue detected concurrent update\", tableName());", "originalCommit": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQzOTQwNA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r526439404", "bodyText": "This is thrown when two processes call glue.updateTable at the same time, similar to AlreadyExistsException for createTable", "author": "jackye1995", "createdAt": "2020-11-18T21:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ1OTA2Nw==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r526459067", "bodyText": "I think this is the right way to handle that. I'm just curious about how this is caught. Is it a local check or a server-side check?", "author": "rdblue", "createdAt": "2020-11-18T22:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2ODMzMA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r526468330", "bodyText": "It's a server side check", "author": "jackye1995", "createdAt": "2020-11-18T22:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzE5NQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525647195", "bodyText": "How does this block know that create was called?", "author": "rdblue", "createdAt": "2020-11-18T02:05:18Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.core.exception.SdkException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  private static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final GlueClient glue;\n+  private final AwsProperties awsProperties;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullTableName;\n+  private final FileIO fileIO;\n+\n+  GlueTableOperations(GlueClient glue, String catalogName, AwsProperties awsProperties,\n+                      FileIO fileIO, TableIdentifier tableIdentifier) {\n+    this.glue = glue;\n+    this.awsProperties = awsProperties;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullTableName = String.format(\"%s.%s.%s\", catalogName, databaseName, tableName);\n+    this.fileIO = fileIO;\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    return fileIO;\n+  }\n+\n+  @Override\n+  protected String tableName() {\n+    return fullTableName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    String metadataLocation = null;\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+\n+    refreshFromMetadataLocation(metadataLocation);\n+  }\n+\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {\n+        glueTable = glueTableOptional.get();\n+        isUpdate = true;\n+        // If we try to create the table but the metadata location is already set, then we had a concurrent commit\n+        if (base == null && glueTable.parameters().get(METADATA_LOCATION_PROP) != null) {\n+          throw new AlreadyExistsException(\"Cannot commit because table %s already exists in Glue\", tableName());\n+        }\n+      }\n+\n+      checkMetadataLocation(isUpdate, glueTable, base);\n+      Map<String, String> properties = prepareProperties(isUpdate, glueTable, newMetadataLocation);\n+      persistGlueTable(isUpdate, properties);\n+      exceptionThrown = false;\n+    } catch (CommitFailedException | AlreadyExistsException e) {\n+      throw e;\n+    } catch (ConcurrentModificationException e) {\n+      throw new CommitFailedException(e,\n+          \"Cannot commit %s because Glue detected concurrent update\", tableName());\n+    } catch (software.amazon.awssdk.services.glue.model.AlreadyExistsException e) {\n+      throw new AlreadyExistsException(e,\n+          \"Cannot commit %s because its Glue table already exists when trying to create one\", tableName());", "originalCommit": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ0MzUyNg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r526443526", "bodyText": "because createTable throws AlreadyExistsException, updateTable throws ConcurrentModificationException", "author": "jackye1995", "createdAt": "2020-11-18T21:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzYwMQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525647601", "bodyText": "If the above block is removed, then this no longer needs to be in the try block. I think that also means you can remove CommitFailedException from the catch.", "author": "rdblue", "createdAt": "2020-11-18T02:06:36Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.core.exception.SdkException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  private static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final GlueClient glue;\n+  private final AwsProperties awsProperties;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullTableName;\n+  private final FileIO fileIO;\n+\n+  GlueTableOperations(GlueClient glue, String catalogName, AwsProperties awsProperties,\n+                      FileIO fileIO, TableIdentifier tableIdentifier) {\n+    this.glue = glue;\n+    this.awsProperties = awsProperties;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullTableName = String.format(\"%s.%s.%s\", catalogName, databaseName, tableName);\n+    this.fileIO = fileIO;\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    return fileIO;\n+  }\n+\n+  @Override\n+  protected String tableName() {\n+    return fullTableName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    String metadataLocation = null;\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+\n+    refreshFromMetadataLocation(metadataLocation);\n+  }\n+\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {\n+        glueTable = glueTableOptional.get();\n+        isUpdate = true;\n+        // If we try to create the table but the metadata location is already set, then we had a concurrent commit\n+        if (base == null && glueTable.parameters().get(METADATA_LOCATION_PROP) != null) {\n+          throw new AlreadyExistsException(\"Cannot commit because table %s already exists in Glue\", tableName());\n+        }\n+      }\n+\n+      checkMetadataLocation(isUpdate, glueTable, base);", "originalCommit": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0Nzg1NA==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525647854", "bodyText": "Why does this use ofNullable? Seems like the response returning a null table is an error.", "author": "rdblue", "createdAt": "2020-11-18T02:07:23Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.core.exception.SdkException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  private static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final GlueClient glue;\n+  private final AwsProperties awsProperties;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullTableName;\n+  private final FileIO fileIO;\n+\n+  GlueTableOperations(GlueClient glue, String catalogName, AwsProperties awsProperties,\n+                      FileIO fileIO, TableIdentifier tableIdentifier) {\n+    this.glue = glue;\n+    this.awsProperties = awsProperties;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullTableName = String.format(\"%s.%s.%s\", catalogName, databaseName, tableName);\n+    this.fileIO = fileIO;\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    return fileIO;\n+  }\n+\n+  @Override\n+  protected String tableName() {\n+    return fullTableName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    String metadataLocation = null;\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+\n+    refreshFromMetadataLocation(metadataLocation);\n+  }\n+\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {\n+        glueTable = glueTableOptional.get();\n+        isUpdate = true;\n+        // If we try to create the table but the metadata location is already set, then we had a concurrent commit\n+        if (base == null && glueTable.parameters().get(METADATA_LOCATION_PROP) != null) {\n+          throw new AlreadyExistsException(\"Cannot commit because table %s already exists in Glue\", tableName());\n+        }\n+      }\n+\n+      checkMetadataLocation(isUpdate, glueTable, base);\n+      Map<String, String> properties = prepareProperties(isUpdate, glueTable, newMetadataLocation);\n+      persistGlueTable(isUpdate, properties);\n+      exceptionThrown = false;\n+    } catch (CommitFailedException | AlreadyExistsException e) {\n+      throw e;\n+    } catch (ConcurrentModificationException e) {\n+      throw new CommitFailedException(e,\n+          \"Cannot commit %s because Glue detected concurrent update\", tableName());\n+    } catch (software.amazon.awssdk.services.glue.model.AlreadyExistsException e) {\n+      throw new AlreadyExistsException(e,\n+          \"Cannot commit %s because its Glue table already exists when trying to create one\", tableName());\n+    } catch (SdkException e) {\n+      throw new CommitFailedException(e, \"Cannot commit %s because unexpected exception contacting AWS\", tableName());\n+    } finally {\n+      if (exceptionThrown) {\n+        io().deleteFile(newMetadataLocation);\n+      }\n+    }\n+  }\n+\n+  private void checkMetadataLocation(boolean isUpdate, Table glueTable, TableMetadata base) {\n+    String glueMetadataLocation = isUpdate ? glueTable.parameters().get(METADATA_LOCATION_PROP) : null;\n+    String baseMetadataLocation = base != null ? base.metadataFileLocation() : null;\n+    if (!Objects.equals(baseMetadataLocation, glueMetadataLocation)) {\n+      throw new CommitFailedException(\n+          \"Cannot commit %s because base metadata location '%s' is not same as the current Glue location '%s'\",\n+          tableName(), baseMetadataLocation, glueMetadataLocation);\n+    }\n+  }\n+\n+  private Optional<Table> getGlueTable() {\n+    try {\n+      GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+          .catalogId(awsProperties.glueCatalogId())\n+          .databaseName(databaseName)\n+          .name(tableName)\n+          .build());\n+      return Optional.ofNullable(response.table());", "originalCommit": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0ODIzNQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525648235", "bodyText": "I don't think these exceptions are caught by other blocks, so you should be able to just remove this.", "author": "rdblue", "createdAt": "2020-11-18T02:08:48Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.core.exception.SdkException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  private static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final GlueClient glue;\n+  private final AwsProperties awsProperties;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullTableName;\n+  private final FileIO fileIO;\n+\n+  GlueTableOperations(GlueClient glue, String catalogName, AwsProperties awsProperties,\n+                      FileIO fileIO, TableIdentifier tableIdentifier) {\n+    this.glue = glue;\n+    this.awsProperties = awsProperties;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullTableName = String.format(\"%s.%s.%s\", catalogName, databaseName, tableName);\n+    this.fileIO = fileIO;\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    return fileIO;\n+  }\n+\n+  @Override\n+  protected String tableName() {\n+    return fullTableName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    String metadataLocation = null;\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+\n+    refreshFromMetadataLocation(metadataLocation);\n+  }\n+\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {\n+        glueTable = glueTableOptional.get();\n+        isUpdate = true;\n+        // If we try to create the table but the metadata location is already set, then we had a concurrent commit\n+        if (base == null && glueTable.parameters().get(METADATA_LOCATION_PROP) != null) {\n+          throw new AlreadyExistsException(\"Cannot commit because table %s already exists in Glue\", tableName());\n+        }\n+      }\n+\n+      checkMetadataLocation(isUpdate, glueTable, base);\n+      Map<String, String> properties = prepareProperties(isUpdate, glueTable, newMetadataLocation);\n+      persistGlueTable(isUpdate, properties);\n+      exceptionThrown = false;\n+    } catch (CommitFailedException | AlreadyExistsException e) {\n+      throw e;", "originalCommit": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0ODgyMQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525648821", "bodyText": "If currentMetadataLocation is an empty string, then there is a problem. Empty strings shouldn't be handles like null strings.", "author": "rdblue", "createdAt": "2020-11-18T02:10:31Z", "path": "aws/src/main/java/org/apache/iceberg/aws/glue/GlueTableOperations.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.TableMetadata;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.AlreadyExistsException;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.exceptions.NoSuchTableException;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.core.exception.SdkException;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.ConcurrentModificationException;\n+import software.amazon.awssdk.services.glue.model.CreateTableRequest;\n+import software.amazon.awssdk.services.glue.model.EntityNotFoundException;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.TableInput;\n+import software.amazon.awssdk.services.glue.model.UpdateTableRequest;\n+\n+class GlueTableOperations extends BaseMetastoreTableOperations {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueTableOperations.class);\n+\n+  // same as org.apache.hadoop.hive.metastore.TableType.EXTERNAL_TABLE\n+  // more details: https://docs.aws.amazon.com/glue/latest/webapi/API_TableInput.html\n+  private static final String GLUE_EXTERNAL_TABLE_TYPE = \"EXTERNAL_TABLE\";\n+\n+  private final GlueClient glue;\n+  private final AwsProperties awsProperties;\n+  private final String databaseName;\n+  private final String tableName;\n+  private final String fullTableName;\n+  private final FileIO fileIO;\n+\n+  GlueTableOperations(GlueClient glue, String catalogName, AwsProperties awsProperties,\n+                      FileIO fileIO, TableIdentifier tableIdentifier) {\n+    this.glue = glue;\n+    this.awsProperties = awsProperties;\n+    this.databaseName = IcebergToGlueConverter.getDatabaseName(tableIdentifier);\n+    this.tableName = IcebergToGlueConverter.getTableName(tableIdentifier);\n+    this.fullTableName = String.format(\"%s.%s.%s\", catalogName, databaseName, tableName);\n+    this.fileIO = fileIO;\n+  }\n+\n+  @Override\n+  public FileIO io() {\n+    return fileIO;\n+  }\n+\n+  @Override\n+  protected String tableName() {\n+    return fullTableName;\n+  }\n+\n+  @Override\n+  protected void doRefresh() {\n+    String metadataLocation = null;\n+    Optional<Table> tableOptional = getGlueTable();\n+    if (tableOptional.isPresent()) {\n+      Table table = tableOptional.get();\n+      GlueToIcebergConverter.validateTable(table, tableName());\n+      metadataLocation = table.parameters().get(METADATA_LOCATION_PROP);\n+    } else {\n+      if (currentMetadataLocation() != null) {\n+        throw new NoSuchTableException(\"Cannot find Glue table %s after refresh, \" +\n+            \"maybe another process deleted it or revoked your access permission\", tableName());\n+      }\n+    }\n+\n+    refreshFromMetadataLocation(metadataLocation);\n+  }\n+\n+  @Override\n+  protected void doCommit(TableMetadata base, TableMetadata metadata) {\n+    String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n+    boolean exceptionThrown = true;\n+    boolean isUpdate = false;\n+    Table glueTable = null;\n+    try {\n+      Optional<Table> glueTableOptional = getGlueTable();\n+      if (glueTableOptional.isPresent()) {\n+        glueTable = glueTableOptional.get();\n+        isUpdate = true;\n+        // If we try to create the table but the metadata location is already set, then we had a concurrent commit\n+        if (base == null && glueTable.parameters().get(METADATA_LOCATION_PROP) != null) {\n+          throw new AlreadyExistsException(\"Cannot commit because table %s already exists in Glue\", tableName());\n+        }\n+      }\n+\n+      checkMetadataLocation(isUpdate, glueTable, base);\n+      Map<String, String> properties = prepareProperties(isUpdate, glueTable, newMetadataLocation);\n+      persistGlueTable(isUpdate, properties);\n+      exceptionThrown = false;\n+    } catch (CommitFailedException | AlreadyExistsException e) {\n+      throw e;\n+    } catch (ConcurrentModificationException e) {\n+      throw new CommitFailedException(e,\n+          \"Cannot commit %s because Glue detected concurrent update\", tableName());\n+    } catch (software.amazon.awssdk.services.glue.model.AlreadyExistsException e) {\n+      throw new AlreadyExistsException(e,\n+          \"Cannot commit %s because its Glue table already exists when trying to create one\", tableName());\n+    } catch (SdkException e) {\n+      throw new CommitFailedException(e, \"Cannot commit %s because unexpected exception contacting AWS\", tableName());\n+    } finally {\n+      if (exceptionThrown) {\n+        io().deleteFile(newMetadataLocation);\n+      }\n+    }\n+  }\n+\n+  private void checkMetadataLocation(boolean isUpdate, Table glueTable, TableMetadata base) {\n+    String glueMetadataLocation = isUpdate ? glueTable.parameters().get(METADATA_LOCATION_PROP) : null;\n+    String baseMetadataLocation = base != null ? base.metadataFileLocation() : null;\n+    if (!Objects.equals(baseMetadataLocation, glueMetadataLocation)) {\n+      throw new CommitFailedException(\n+          \"Cannot commit %s because base metadata location '%s' is not same as the current Glue location '%s'\",\n+          tableName(), baseMetadataLocation, glueMetadataLocation);\n+    }\n+  }\n+\n+  private Optional<Table> getGlueTable() {\n+    try {\n+      GetTableResponse response = glue.getTable(GetTableRequest.builder()\n+          .catalogId(awsProperties.glueCatalogId())\n+          .databaseName(databaseName)\n+          .name(tableName)\n+          .build());\n+      return Optional.ofNullable(response.table());\n+    } catch (EntityNotFoundException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private Map<String, String> prepareProperties(boolean isUpdate, Table glueTable, String newMetadataLocation) {\n+    Map<String, String> properties = isUpdate ? Maps.newHashMap(glueTable.parameters()) : Maps.newHashMap();\n+    properties.put(TABLE_TYPE_PROP, ICEBERG_TABLE_TYPE_VALUE.toUpperCase(Locale.ENGLISH));\n+    properties.put(METADATA_LOCATION_PROP, newMetadataLocation);\n+    if (currentMetadataLocation() != null && !currentMetadataLocation().isEmpty()) {", "originalCommit": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4OTY0OQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r526489649", "bodyText": "Yes, I am not very sure if this is a potential edge case to hit, so I am basically following the same way as HiveTableOperations.", "author": "jackye1995", "createdAt": "2020-11-18T23:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0ODgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA5MDY3MQ==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r527090671", "bodyText": "That looks wrong to me, but if that's the currently released behavior then let's keep it. \u2639\ufe0f", "author": "rdblue", "createdAt": "2020-11-19T18:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0ODgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY1NTE0Mg==", "url": "https://github.com/apache/iceberg/pull/1633#discussion_r525655142", "bodyText": "These tests are okay, but it still doesn't seem like this is testing much. Most of the tests are responding to Mockito.any(GetDatabaseRequest.class) or similar, so it doesn't really test what gets passed to Glue. Better mocking would be great, but I'm starting to think that it may just be easier to maintain an in-memory catalog and a Glue client implementation that updates it. I think that would work better to catch simple problems.", "author": "rdblue", "createdAt": "2020-11-18T02:19:13Z", "path": "aws/src/test/java/org/apache/iceberg/aws/glue/GlueCatalogTest.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.aws.glue;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.BaseMetastoreTableOperations;\n+import org.apache.iceberg.aws.AwsProperties;\n+import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.catalog.TableIdentifier;\n+import org.apache.iceberg.exceptions.NamespaceNotEmptyException;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import software.amazon.awssdk.services.glue.GlueClient;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.CreateDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.Database;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.DeleteTableRequest;\n+import software.amazon.awssdk.services.glue.model.DeleteTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabaseResponse;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesRequest;\n+import software.amazon.awssdk.services.glue.model.GetDatabasesResponse;\n+import software.amazon.awssdk.services.glue.model.GetTableRequest;\n+import software.amazon.awssdk.services.glue.model.GetTableResponse;\n+import software.amazon.awssdk.services.glue.model.GetTablesRequest;\n+import software.amazon.awssdk.services.glue.model.GetTablesResponse;\n+import software.amazon.awssdk.services.glue.model.Table;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseRequest;\n+import software.amazon.awssdk.services.glue.model.UpdateDatabaseResponse;\n+\n+public class GlueCatalogTest {", "originalCommit": "ecee35546e1bc8b30fb52d3ca11e8a02d92222fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f418262b74f6fa9169f5ea68b51acefed5f8ec8e", "url": "https://github.com/apache/iceberg/commit/f418262b74f6fa9169f5ea68b51acefed5f8ec8e", "message": "fix order in rename, simplify  commit", "committedDate": "2020-11-18T23:13:21Z", "type": "commit"}]}